// ==UserScript==
// @name         Bilibili-Gate
// @namespace    https://magicdawn.fun
// @version      0.33.9
// @author       magicdawn
// @description  Bilibili 自定义首页
// @license      MIT
// @icon         https://www.bilibili.com/favicon.ico
// @homepageURL  https://greasyfork.org/zh-CN/scripts/443530-bilibili-gate
// @supportURL   https://github.com/magicdawn/Bilibili-Gate/issues
// @downloadURL  https://raw.githubusercontent.com/magicdawn/Bilibili-Gate/refs/heads/release/bilibili-gate.user.js
// @updateURL    https://raw.githubusercontent.com/magicdawn/Bilibili-Gate/refs/heads/release/bilibili-gate.meta.js
// @match        https://www.bilibili.com/
// @match        https://www.bilibili.com/?*
// @match        https://www.bilibili.com/index.html
// @match        https://www.bilibili.com/index.html?*
// @match        https://www.bilibili.com/video/*
// @match        https://www.bilibili.com/list/watchlater?*
// @match        https://www.bilibili.com/bangumi/play/*
// @match        https://space.bilibili.com/*
// @match        https://search.bilibili.com/*
// @require      https://registry.npmmirror.com/axios/0.30.0/files/dist/axios.min.js
// @require      https://registry.npmmirror.com/react/18.3.1/files/umd/react.production.min.js
// @require      https://registry.npmmirror.com/react-dom/18.3.1/files/umd/react-dom.production.min.js
// @require      https://registry.npmmirror.com/ua-parser-js/1.0.40/files/dist/ua-parser.min.js
// @require      https://registry.npmmirror.com/framer-motion/12.23.24/files/dist/framer-motion.js
// @require      https://registry.npmmirror.com/localforage/1.10.0/files/dist/localforage.min.js
// @require      https://registry.npmmirror.com/pinyin-match/1.2.8/files/dist/main.js
// @require      https://registry.npmmirror.com/spark-md5/3.0.2/files/spark-md5.min.js
// @require      https://registry.npmmirror.com/dayjs/1.11.18/files/dayjs.min.js
// @require      https://registry.npmmirror.com/dayjs/1.11.18/files/plugin/duration.js
// @require      https://registry.npmmirror.com/@ant-design/cssinjs/1.24.0/files/dist/umd/cssinjs.min.js
// @require      https://registry.npmmirror.com/antd/5.27.6/files/dist/antd.min.js
// @tag          bilibili
// @connect      app.bilibili.com
// @grant        GM.deleteValue
// @grant        GM.getValue
// @grant        GM.listValues
// @grant        GM.openInTab
// @grant        GM.registerMenuCommand
// @grant        GM.setClipboard
// @grant        GM.setValue
// @grant        GM.xmlHttpRequest
// @grant        GM_addStyle
// @grant        GM_addValueChangeListener
// @grant        GM_download
// @grant        GM_info
// @grant        unsafeWindow
// @run-at       document-body
// ==/UserScript==

(async function (H, antd, UAParser, axios, sparkMd5, dayjs, duration, require$$0, cssinjs, framerMotion, PinyinMatch, localforage) {
  'use strict';

  function _interopNamespaceDefault(e) {
    const n = Object.create(null, { [Symbol.toStringTag]: { value: 'Module' } });
    if (e) {
      for (const k in e) {
        if (k !== 'default') {
          const d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: () => e[k]
          });
        }
      }
    }
    n.default = e;
    return Object.freeze(n);
  }

  const H__namespace = _interopNamespaceDefault(H);

  const d$2=new Set;const importCSS = async e=>{d$2.has(e)||(d$2.add(e),(t=>{typeof GM_addStyle=="function"?GM_addStyle(t):document.head.appendChild(document.createElement("style")).append(t);})(e));};

  importCSS(` @charset "UTF-8";._cls-gate-video-grid-divider_kgj54_1 .ant-divider-inner-text {
  display: inline-flex;
  align-items: center;
  min-height: 30px;
}
._cls-gate-video-grid-divider_kgj54_1 .ant-divider-inner-text a {
  color: var(--ant-color-link);
}
._cls-gate-video-grid-divider_kgj54_1 .ant-divider-inner-text a:hover {
  color: var(--ant-color-primary);
}
._video-grid_b2rnv_2 {
  display: grid;
  position: relative;
  width: 100%;
  grid-gap: 20px 12px;
  grid-template-columns: repeat(var(--col), minmax(0, 1fr));
  --bilibili-gate--video-card--border-radius: 15px;
}

/**
 * bili-feed4
 * \u53D6\u81EA .battle-feed-area .battle-feed-body
 */
._video-grid-bili-feed4_b2rnv_15 {
  grid-gap: 20px 20px;
}
._video-grid-bili-feed4_b2rnv_15 .ant-divider-horizontal.ant-divider-with-text {
  margin-bottom: -15px;
  margin-top: -15px;
}
._video-grid-bili-feed4_b2rnv_15 .ant-divider-horizontal.ant-divider-with-text:first-of-type {
  margin-top: 0;
}

@media (max-width: 1399px) {
  ._video-grid-bili-feed4_b2rnv_15 {
    --col: 4;
  }
  ._video-grid-bili-feed4_b2rnv_15._limit-one-line_b2rnv_30 > *:nth-of-type(1n + 5) {
    display: none !important;
  }
  ._video-grid-bili-feed4_b2rnv_15._limit-two-lines_b2rnv_33 > *:nth-of-type(1n + 9) {
    display: none !important;
  }
}
@media (min-width: 1400px) {
  ._video-grid-bili-feed4_b2rnv_15 {
    --col: 5;
  }
  ._video-grid-bili-feed4_b2rnv_15._limit-one-line_b2rnv_30 > *:nth-of-type(1n + 6) {
    display: none !important;
  }
  ._video-grid-bili-feed4_b2rnv_15._limit-two-lines_b2rnv_33 > *:nth-of-type(1n + 11) {
    display: none !important;
  }
}
/**
 * @container \u5BB9\u5668
 */
._video-grid-container_b2rnv_51 {
  container-type: inline-size;
}
._video-grid-container_b2rnv_51._virtual-grid-enabled_b2rnv_54 .virtuoso-grid-item {
  padding-bottom: var(--row-gap);
}
._video-grid-container_b2rnv_51._virtual-grid-enabled_b2rnv_54 .virtuoso-grid-item .bili-video-card {
  margin-bottom: 0;
  height: 100%;
}

._video-grid-custom_b2rnv_62 {
  --col: 4;
  column-gap: 20px;
  row-gap: 0;
  --row-gap: clamp(20px, 1.4vw, 40px);
}
._video-grid-custom_b2rnv_62 .bili-video-card {
  margin-bottom: var(--row-gap);
}
._video-grid-custom_b2rnv_62 .ant-divider-horizontal.ant-divider-with-text {
  margin-bottom: 5px;
  margin-top: calc(10px - var(--row-gap));
}
._video-grid-custom_b2rnv_62 .ant-divider-horizontal.ant-divider-with-text:first-of-type {
  margin-top: 0;
}

@container (width >= 1276px) {
  ._video-grid_b2rnv_2._video-grid-custom_b2rnv_62 {
    --col: 5;
  }
}
@container (inline-size >= 2080px) {
  ._video-grid_b2rnv_2._video-grid-custom_b2rnv_62 {
    --col: 6;
  }
}
@container (inline-size >= 2465px) {
  ._video-grid_b2rnv_2._video-grid-custom_b2rnv_62 {
    --col: 7;
  }
}
@container (inline-size >= 2860px) {
  ._video-grid_b2rnv_2._video-grid-custom_b2rnv_62 {
    --col: 8;
  }
}
@container (inline-size >= 3265px) {
  ._video-grid_b2rnv_2._video-grid-custom_b2rnv_62 {
    --col: 9;
  }
}
@container (inline-size >= 3680px) {
  ._video-grid_b2rnv_2._video-grid-custom_b2rnv_62 {
    --col: 10;
  }
}
/**
 * \u53CC\u5217\u6A21\u5F0F
 */
._narrow-mode_b2rnv_112 {
  --col: 2 !important;
}*,::before,::after{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}::backdrop{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}.icon-only-round-button{width:32px;height:32px;display:flex;align-items:center;justify-content:center;border-radius:50%;padding:0;}.inline-icon-only-round-button{width:32px;height:32px;display:inline-flex;align-items:center;justify-content:center;border-radius:50%;padding:0;}.flex-center{display:flex;align-items:center;justify-content:center;}.flex-v-center{display:flex;align-items:center;}.inline-flex-center{display:inline-flex;align-items:center;justify-content:center;}.\\[refresh\\:scroll\\]{refresh:scroll;}.\\[\\&_svg\\]\\:pointer-events-none svg,.pointer-events-none{pointer-events:none;}.visible{visibility:visible;}.invisible{visibility:hidden;}.absolute{position:absolute;}.fixed{position:fixed;}.position-relative,.relative{position:relative;}.sticky{position:sticky;}.static{position:static;}.inset-0{inset:0;}.inset-x-0{left:0;right:0;}.bottom--6px{bottom:-6px;}.bottom-0{bottom:0;}.left--2px{left:-2px;}.left--5px{left:-5px;}.left-0{left:0;}.left-50\\%{left:50%;}.left-8px{left:8px;}.right--5px{right:-5px;}.right-\\[calc\\(8px\\+28px\\+5px\\)\\]{right:calc(8px + 28px + 5px);}.right-0{right:0;}.right-10px{right:10px;}.right-8px{right:8px;}.top--1px,.top-\\[-1px\\]{top:-1px;}.top-\\[-0\\.5px\\]{top:-0.5px;}.top-0{top:0;}.top-0\\.5px{top:0.5px;}.top-10px{top:10px;}.top-1px{top:1px;}.top-4px{top:4px;}.top-50\\%{top:50%;}.top-8px{top:8px;}.z-2{z-index:2;}.z-3{z-index:3;}.z-4{z-index:4;}.z-5{z-index:5;}.z-6{z-index:6;}.z-9999{z-index:9999;}.z-gate-base-modal{z-index:var(--bilibili-gate--z-base-modal);}.z-gate-rec-header{z-index:var(--bilibili-gate--z-rec-header);}.z-gate-toast{z-index:var(--bilibili-gate--z-toast);}.grid{display:grid;}.grid-col-span-full{grid-column:1/-1;}.grid-cols-\\[250px_1fr\\]{grid-template-columns:250px 1fr;}.grid-cols-\\[repeat\\(2\\,max-content\\)_1fr\\]{grid-template-columns:repeat(2,max-content) 1fr;}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr));}.grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr));}.m10{margin:40px;}.m13{margin:52px;}.m14{margin:56px;}.m15{margin:60px;}.m16{margin:64px;}.m16\\.52{margin:66.08px;}.m160{margin:640px;}.m19{margin:76px;}.m19\\.833{margin:79.332px;}.m239\\.82{margin:959.28px;}.m24{margin:96px;}.m29\\.756{margin:119.024px;}.m33{margin:132px;}.m434\\.8{margin:1739.2px;}.m5{margin:20px;}.m8{margin:32px;}.m9{margin:36px;}.\\[\\&\\.ant-empty-normal\\]\\:my-5px.ant-empty-normal,.my-5px{margin-top:5px;margin-bottom:5px;}.mx-0{margin-left:0;margin-right:0;}.mx-1,.mx-4px{margin-left:4px;margin-right:4px;}.mx-5px{margin-left:5px;margin-right:5px;}.mx-auto{margin-left:auto;margin-right:auto;}.my-0{margin-top:0;margin-bottom:0;}.my-2px{margin-top:2px;margin-bottom:2px;}.my-7px{margin-top:7px;margin-bottom:7px;}.\\[\\&_svg\\]\\:mr-5px svg,.mr-5px{margin-right:5px;}.\\[\\&_svg\\]\\:mt--1px svg,.mt--1px{margin-top:-1px;}.mb-0{margin-bottom:0;}.mb-10px{margin-bottom:10px;}.mb-20px{margin-bottom:20px;}.mb-2px{margin-bottom:2px;}.mb-40px{margin-bottom:40px;}.mb-5px{margin-bottom:5px;}.ml-10px{margin-left:10px;}.ml-12px{margin-left:12px;}.ml-15px{margin-left:15px;}.ml-1px{margin-left:1px;}.ml-20px{margin-left:20px;}.ml-2px{margin-left:2px;}.ml-30px{margin-left:30px;}.ml-4px{margin-left:4px;}.ml-5px{margin-left:5px;}.ml-6px{margin-left:6px;}.ml-8px{margin-left:8px;}.mr-0\\!{margin-right:0 !important;}.mr-10px{margin-right:10px;}.mr-24px{margin-right:24px;}.mr-2px{margin-right:2px;}.mr-4px{margin-right:4px;}.mr-6px{margin-right:6px;}.ms{margin-inline-start:16px;}.mt--2px{margin-top:-2px;}.mt-10px{margin-top:10px;}.mt-15px{margin-top:15px;}.mt-2,.mt-8px{margin-top:8px;}.mt-20px{margin-top:20px;}.mt-2px{margin-top:2px;}.mt-3px{margin-top:3px;}.mt-4px{margin-top:4px;}.mt-6px{margin-top:6px;}.first\\:ml-0:first-child{margin-left:0;}.first\\:mt-0:first-child{margin-top:0;}.first\\:mt-0px:first-child{margin-top:0;}.box-content{box-sizing:content-box;}.block{display:block;}.inline-block{display:inline-block;}.contents{display:contents;}.hidden{display:none;}.aspect-1{aspect-ratio:1;}.aspect-16\\/9{aspect-ratio:16/9;}.aspect-ratio-10\\/16{aspect-ratio:10/16;}.\\[\\&_svg\\]\\:size-14px svg,.size-14px{width:14px;height:14px;}.ant-spin .ant-spin-dot.\\[\\.ant-spin_\\.ant-spin-dot\\&\\]\\:size-25px,.size-25px{width:25px;height:25px;}.size-12px{width:12px;height:12px;}.size-13px{width:13px;height:13px;}.size-15px{width:15px;height:15px;}.size-16px{width:16px;height:16px;}.size-17px{width:17px;height:17px;}.size-18px{width:18px;height:18px;}.size-20px{width:20px;height:20px;}.size-24px{width:24px;height:24px;}.size-26px{width:26px;height:26px;}.size-28px{width:28px;height:28px;}.size-30px{width:30px;height:30px;}.size-32px{width:32px;height:32px;}.size-40px{width:40px;height:40px;}.size-full{width:100%;height:100%;}.h-\\[calc\\(100vh-10px\\)\\]{height:calc(100vh - 10px);}.h-\\[calc\\(100vh-30px\\)\\]{height:calc(100vh - 30px);}.h-0{height:0;}.h-100\\%,.h-full{height:100%;}.h-100vh{height:100vh;}.h-14px{height:14px;}.h-16px{height:16px;}.h-19px{height:19px;}.h-22px{height:22px;}.h-24px{height:24px;}.h-2px{height:2px;}.h-34px{height:34px;}.h-35px{height:35px;}.h-3px{height:3px;}.h-auto{height:auto;}.max-h-\\[calc\\(90vh-50px\\)\\]{max-height:calc(90vh - 50px);}.max-h-\\[max\\(362px\\,calc\\(90vh-50px-56px-15px\\)\\)\\]{max-height:max(362px,calc(90vh - 50px - 56px - 15px));}.max-h-250px{max-height:250px;}.max-h-50vh{max-height:50vh;}.max-h-unset{max-height:unset;}.max-w-130px{max-width:130px;}.max-w-288px{max-width:288px;}.max-w-350px{max-width:350px;}.max-w-450px{max-width:450px;}.min-h-100px{min-height:100px;}.min-h-100vh{min-height:100vh;}.min-h-25px{min-height:25px;}.min-h-362px{min-height:362px;}.min-w-130px{min-width:130px;}.min-w-200px{min-width:200px;}.min-w-24px{min-width:24px;}.min-w-300px{min-width:300px;}.min-w-32px{min-width:32px;}.min-w-60px{min-width:60px;}.min-w-80px{min-width:80px;}.min-w-95px{min-width:95px;}.w-\\[calc\\(100vw-30px\\)\\]{width:calc(100vw - 30px);}.w-\\[calc\\(325\\*2\\+40px\\)\\]{width:calc(325 * 2 + 40px);}.w-\\[max-content\\]{width:max-content;}.w-0{width:0;}.w-100\\%,.w-full{width:100%;}.w-114px{width:114px;}.w-130px{width:130px;}.w-150px{width:150px;}.w-160px{width:160px;}.w-16px{width:16px;}.w-34px{width:34px;}.w-500px{width:500px;}.flex{display:flex;}.\\[\\&_\\.ant-checkbox-label\\]\\:inline-flex .ant-checkbox-label,.inline-flex{display:inline-flex;}.flex-1{flex:1 1 0%;}.flex-none{flex:none;}.flex-shrink,.flex-shrink-1{flex-shrink:1;}.flex-shrink-0,.shrink-0{flex-shrink:0;}.flex-grow-1{flex-grow:1;}.flex-basis-100\\%{flex-basis:100%;}.flex-row{flex-direction:row;}.flex-row-reverse{flex-direction:row-reverse;}.flex-col{flex-direction:column;}.flex-wrap{flex-wrap:wrap;}.translate-x--50\\%{--un-translate-x:-50%;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.translate-y--50\\%{--un-translate-y:-50%;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.translate-y-100\\%{--un-translate-y:100%;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.rotate-0{--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-rotate:0deg;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.rotate-180{--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-rotate:180deg;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.rotate-z-0{--un-rotate:0;--un-rotate-z:0deg;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.rotate-z-180deg{--un-rotate:0;--un-rotate-z:180deg;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.transform{transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}@keyframes spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}.animate-spin{animation:spin 1s linear infinite;}.cursor-\\[edit\\]{cursor:edit;}.cursor-pointer{cursor:pointer;}.cursor-text{cursor:text;}.cursor-not-allowed{cursor:not-allowed;}.cursor-grab{cursor:grab;}.\\[\\&_\\.ant-checkbox-label\\]\\:select-none .ant-checkbox-label,.\\[\\&_svg\\]\\:select-none svg,.select-none{-webkit-user-select:none;user-select:none;}.resize{resize:both;}.list-circle{list-style-type:circle;}.content-start{align-content:flex-start;}.items-start{align-items:flex-start;}.\\[\\&_\\.ant-checkbox-label\\]\\:items-center .ant-checkbox-label,.items-center{align-items:center;}.self-start{align-self:flex-start;}.justify-start{justify-content:flex-start;}.justify-end{justify-content:flex-end;}.justify-center{justify-content:center;}.justify-between{justify-content:space-between;}.justify-left{justify-content:left;}.gap-0{gap:0;}.gap-10px{gap:10px;}.gap-1px{gap:1px;}.gap-4px{gap:4px;}.gap-8px{gap:8px;}.gap-x-1,.gap-x-4px{column-gap:4px;}.gap-x-10px{column-gap:10px;}.gap-x-12px{column-gap:12px;}.gap-x-15px{column-gap:15px;}.gap-x-20px{column-gap:20px;}.gap-x-2px{column-gap:2px;}.gap-x-30px{column-gap:30px;}.gap-x-40px{column-gap:40px;}.gap-x-50px{column-gap:50px;}.gap-x-5px{column-gap:5px;}.gap-x-6px{column-gap:6px;}.gap-x-8px{column-gap:8px;}.gap-y-10px{row-gap:10px;}.gap-y-15px{row-gap:15px;}.gap-y-2px{row-gap:2px;}.gap-y-3px{row-gap:3px;}.gap-y-4px{row-gap:4px;}.gap-y-5px{row-gap:5px;}.gap-y-6px{row-gap:6px;}.gap-y-8px{row-gap:8px;}.overflow-hidden{overflow:hidden;}.overflow-y-auto{overflow-y:auto;}.overflow-y-scroll{overflow-y:scroll;}.text-ellipsis{text-overflow:ellipsis;}.whitespace-nowrap{white-space:nowrap;}.whitespace-pre-wrap{white-space:pre-wrap;}.break-normal{overflow-wrap:normal;word-break:normal;}.b-1px,.border{border-width:1px;}.b-2px{border-width:2px;}.b-5px{border-width:5px;}.b-b-1px{border-bottom-width:1px;}.b-t-1px{border-top-width:1px;}.border-b-0{border-bottom-width:0px;}.b-\\#444{--un-border-opacity:1;border-color:rgb(68 68 68 / var(--un-border-opacity));}.b-gate-bg-lv-2{border-color:var(--bilibili-gate--bg-lv2);}.b-gate-border,.bilibili-gate-using-dark .dark\\:b-gate-border{border-color:var(--bilibili-gate--border-color);}.b-gate-primary{border-color:var(--bilibili-gate--primary-color);}.b-transparent{border-color:transparent;}.b-white\\/20\\%{border-color:rgb(255 255 255 / 0.2);}.b-white\\/33\\%{border-color:rgb(255 255 255 / 0.33);}.hover\\:b-gate-primary:hover{border-color:var(--bilibili-gate--primary-color);}.b-b-gate-bg-lv1{border-bottom-color:var(--bilibili-gate--bg-lv1);}.b-b-transparent{border-bottom-color:transparent;}.b-t-\\[var\\(--bilibili-gate-separator-color\\)\\]{border-top-color:var(--bilibili-gate-separator-color);}.rounded,.rounded-4px{border-radius:4px;}.rounded-10px{border-radius:10px;}.rounded-15px{border-radius:15px;}.rounded-20px{border-radius:20px;}.rounded-2px{border-radius:2px;}.rounded-5px{border-radius:5px;}.rounded-6px{border-radius:6px;}.rounded-8px{border-radius:8px;}.rounded-full{border-radius:9999px;}.rounded-b-none{border-bottom-left-radius:0;border-bottom-right-radius:0;}.rounded-t-6px{border-top-left-radius:6px;border-top-right-radius:6px;}.rounded-t-gate-video-card{border-top-left-radius:var(--bilibili-gate--video-card--border-radius);border-top-right-radius:var(--bilibili-gate--video-card--border-radius);}.b-solid{border-style:solid;}.border-none{border-style:none;}.b-b-solid{border-bottom-style:solid;}.b-t-solid{border-top-style:solid;}.bg-\\[rgb\\(33_33_33_\\/_0\\.7\\)\\]{--un-bg-opacity:0.7;background-color:rgb(33 33 33 / var(--un-bg-opacity)) /* rgb(33 33 33 / 0.7) */;}.bg-\\$bg1_float{background-color:var(--bg1_float) /* var(--bg1_float) */;}.bg-black\\/10{background-color:rgb(0 0 0 / 0.1) /* #000 */;}.bg-black\\/50{background-color:rgb(0 0 0 / 0.5) /* #000 */;}.bg-black\\/90\\%{background-color:rgb(0 0 0 / 0.9) /* #000 */;}.bg-gate-bg{background-color:var(--bilibili-gate--bg) /* var(--bilibili-gate--bg) */;}.bg-gate-bg-lv-2{background-color:var(--bilibili-gate--bg-lv2) /* var(--bilibili-gate--bg-lv2) */;}.bg-gate-bg-lv-3{background-color:var(--bilibili-gate--bg-lv3) /* var(--bilibili-gate--bg-lv3) */;}.bg-gate-bg-lv1{background-color:var(--bilibili-gate--bg-lv1) /* var(--bilibili-gate--bg-lv1) */;}.bg-gate-primary{background-color:var(--bilibili-gate--primary-color) /* var(--bilibili-gate--primary-color) */;}.bg-gate-primary\\!{background-color:var(--bilibili-gate--primary-color) /* var(--bilibili-gate--primary-color) */ !important;}.bg-transparent{background-color:transparent /* transparent */;}.bg-white\\/14\\%{background-color:rgb(255 255 255 / 0.14) /* #fff */;}.bg-white\\/50\\%{background-color:rgb(255 255 255 / 0.5) /* #fff */;}.hover\\:bg-gate-bg-lv-3:hover{background-color:var(--bilibili-gate--bg-lv3) /* var(--bilibili-gate--bg-lv3) */;}.hover\\:bg-gate-bg-lv1:hover{background-color:var(--bilibili-gate--bg-lv1) /* var(--bilibili-gate--bg-lv1) */;}.hover\\:bg-gate-primary:hover{background-color:var(--bilibili-gate--primary-color) /* var(--bilibili-gate--primary-color) */;}.hover\\:bg-white\\/40\\%:hover{background-color:rgb(255 255 255 / 0.4) /* #fff */;}.\\[\\&_g\\]\\:fill-inherit g{fill:inherit /* inherit */;}.\\[\\&_path\\]\\:fill-gate-primary path,.fill-gate-primary{fill:var(--bilibili-gate--primary-color) /* var(--bilibili-gate--primary-color) */;}.fill-none{fill:none;}.\\[\\&_\\.circle\\]\\:stroke-current .circle{stroke:currentColor /* currentColor */;}.object-cover{object-fit:cover;}.object-contain{object-fit:contain;}.p-10px{padding:10px;}.p-15px{padding:15px;}.p-1px{padding:1px;}.p-20px{padding:20px;}.p-8px{padding:8px;}.\\[\\&_\\.ant-radio-button-wrapper\\]\\:px-10px .ant-radio-button-wrapper{padding-left:10px;padding-right:10px;}.p-x-1,.px-4px{padding-left:4px;padding-right:4px;}.px,.px-16px{padding-left:16px;padding-right:16px;}.px-0{padding-left:0;padding-right:0;}.px-15px{padding-left:15px;padding-right:15px;}.px-24px{padding-left:24px;padding-right:24px;}.px-2px{padding-left:2px;padding-right:2px;}.px-5px{padding-left:5px;padding-right:5px;}.px-6px{padding-left:6px;padding-right:6px;}.px-8px{padding-left:8px;padding-right:8px;}.py-0{padding-top:0;padding-bottom:0;}.py-10px{padding-top:10px;padding-bottom:10px;}.py-12px{padding-top:12px;padding-bottom:12px;}.py-2px{padding-top:2px;padding-bottom:2px;}.py-30px{padding-top:30px;padding-bottom:30px;}.py-3px{padding-top:3px;padding-bottom:3px;}.py-4px{padding-top:4px;padding-bottom:4px;}.py-5px{padding-top:5px;padding-bottom:5px;}.py-8px{padding-top:8px;padding-bottom:8px;}.pb-15px{padding-bottom:15px;}.pb-2px{padding-bottom:2px;}.pb1257{padding-bottom:5028px;}.pl-10px{padding-left:10px;}.pl-16px{padding-left:16px;}.pl-25px{padding-left:25px;}.pl-2px{padding-left:2px;}.pl-4px{padding-left:4px;}.pl-5px{padding-left:5px;}.pl-6px{padding-left:6px;}.pr-0{padding-right:0;}.pr-10px{padding-right:10px;}.pr-12px{padding-right:12px;}.pr-15px{padding-right:15px;}.pr-6px{padding-right:6px;}.ps{padding-inline-start:16px;}.pt-0{padding-top:0;}.pt-15px{padding-top:15px;}.pt-5px{padding-top:5px;}.text-center{text-align:center;}.text-\\[1\\.5rem\\]{font-size:24px;}.text-1\\.3em,.text-size-1\\.3em{font-size:1.3em;}.text-12px,.text-size-12px{font-size:12px;}.text-14px,.text-size-14px{font-size:14px;}.text-15px{font-size:15px;}.text-16px,.text-size-16px{font-size:16px;}.font-size-20px,.text-20px,.text-size-20px{font-size:20px;}.text-2em{font-size:2em;}.text-size-0{font-size:0;}.text-size-1\\.5em{font-size:1.5em;}.text-size-120\\%{font-size:120%;}.text-size-13px{font-size:13px;}.color-gate-primary,.text-gate-primary{color:var(--bilibili-gate--primary-color) /* var(--bilibili-gate--primary-color) */;}.color-gate-text,.text-gate-text{color:var(--bilibili-gate--text-color) /* var(--bilibili-gate--text-color) */;}.text-red{--un-text-opacity:1;color:rgb(248 113 113 / var(--un-text-opacity)) /* #f87171 */;}.color-white,.text-white{--un-text-opacity:1;color:rgb(255 255 255 / var(--un-text-opacity)) /* #fff */;}.text-yellow-400{--un-text-opacity:1;color:rgb(250 204 21 / var(--un-text-opacity)) /* #facc15 */;}.hover\\:color-gate-primary:hover{color:var(--bilibili-gate--primary-color) /* var(--bilibili-gate--primary-color) */;}.color-inherit{color:inherit;}.font-700{font-weight:700;}.\\[\\&_\\.ant-btn-icon\\]\\:line-height-0 .ant-btn-icon,.line-height-\\[0\\]{line-height:0;}.line-height-\\[1\\]{line-height:1;}.line-height-\\[unset\\],.line-height-unset{line-height:unset;}.line-height-1\\.5{line-height:6px;}.line-height-14px{line-height:14px;}.line-height-18px{line-height:18px;}.italic{font-style:italic;}.tab{-moz-tab-size:4;-o-tab-size:4;tab-size:4;}.shadow{--un-shadow:var(--un-shadow-inset) 0 1px 3px 0 var(--un-shadow-color, rgb(0 0 0 / 0.1)),var(--un-shadow-inset) 0 1px 2px -1px var(--un-shadow-color, rgb(0 0 0 / 0.1));box-shadow:var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow);}.\\[\\&\\.ant-btn\\:not\\(\\:disabled\\)\\:focus-visible\\]\\:outline-0.ant-btn:not(:disabled):focus-visible{outline-width:0px;}.outline-none\\!{outline:2px solid transparent !important;outline-offset:2px !important;}.ring-1px{--un-ring-width:1px;--un-ring-offset-shadow:var(--un-ring-inset) 0 0 0 var(--un-ring-offset-width) var(--un-ring-offset-color);--un-ring-shadow:var(--un-ring-inset) 0 0 0 calc(var(--un-ring-width) + var(--un-ring-offset-width)) var(--un-ring-color);box-shadow:var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow);}.ring-gate-border{--un-ring-color:var(--bilibili-gate--border-color) /* var(--bilibili-gate--border-color) */;}.ring-gate-primary{--un-ring-color:var(--bilibili-gate--primary-color) /* var(--bilibili-gate--primary-color) */;}.backdrop-blur-10px{--un-backdrop-blur:blur(10px);-webkit-backdrop-filter:var(--un-backdrop-blur) var(--un-backdrop-brightness) var(--un-backdrop-contrast) var(--un-backdrop-grayscale) var(--un-backdrop-hue-rotate) var(--un-backdrop-invert) var(--un-backdrop-opacity) var(--un-backdrop-saturate) var(--un-backdrop-sepia);backdrop-filter:var(--un-backdrop-blur) var(--un-backdrop-brightness) var(--un-backdrop-contrast) var(--un-backdrop-grayscale) var(--un-backdrop-hue-rotate) var(--un-backdrop-invert) var(--un-backdrop-opacity) var(--un-backdrop-saturate) var(--un-backdrop-sepia);}.filter{filter:var(--un-blur) var(--un-brightness) var(--un-contrast) var(--un-drop-shadow) var(--un-grayscale) var(--un-hue-rotate) var(--un-invert) var(--un-saturate) var(--un-sepia);}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;}.transition-300{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:300ms;}.transition-transform{transition-property:transform;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;}.transition-duration-300{transition-duration:300ms;}.ease,.ease-in-out{transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);}.ease-out{transition-timing-function:cubic-bezier(0, 0, 0.2, 1);}.transition-property-\\[border-color\\]{transition-property:border-color;}.transition-property-all{transition-property:all;}@media (min-width: 1280px){.xl\\:gap-x-8px{column-gap:8px;}}.bilibili-gate-root .bili-video-card__skeleton--cover, .bilibili-gate-root .bili-video-card__skeleton--text, .bilibili-gate-root .bili-video-card__skeleton--light, .bilibili-gate-root .bili-video-card__skeleton--avatar {
  background: linear-gradient(135deg, rgba(0, 0, 0, 0.06) 25%, rgba(0, 0, 0, 0.15) 37%, rgba(0, 0, 0, 0.06) 63%);
}
.bilibili-gate-root .bili-video-card__skeleton--text.tiny {
  margin-top: 4px;
  width: 15%;
}
html.bilibili-gate-using-dark .bilibili-gate-root .bili-video-card__skeleton--cover, html.bilibili-gate-using-dark .bilibili-gate-root .bili-video-card__skeleton--text, html.bilibili-gate-using-dark .bilibili-gate-root .bili-video-card__skeleton--light, html.bilibili-gate-using-dark .bilibili-gate-root .bili-video-card__skeleton--avatar {
  background-color: #444;
}

._skeleton-active_wlycr_12 .bili-video-card__skeleton--cover, ._skeleton-active_wlycr_12 .bili-video-card__skeleton--text, ._skeleton-active_wlycr_12 .bili-video-card__skeleton--light, ._skeleton-active_wlycr_12 .bili-video-card__skeleton--avatar {
  background-size: 400% 100%;
  animation-name: _ant-skeleton-loading_wlycr_1;
  animation-duration: 2s;
  animation-timing-function: ease;
  animation-iteration-count: infinite;
}

@keyframes _ant-skeleton-loading_wlycr_1 {
  0% {
    background-position: 100% 50%;
  }
  80%, 100% {
    background-position: 0 50%;
  }
} `);

  const globalScss = '@charset "UTF-8";\n:root {\n  --bilibili-gate--font: "Alibaba PuHuiTi 3.0", "PingFang SC", HarmonyOS_Regular, "Helvetica Neue", "Microsoft YaHei", sans-serif;\n}\n\n:root {\n  --bilibili-gate--border-color: oklch(from var(--bilibili-gate--bg) calc(l - 0.05) c h);\n  --bilibili-gate--bg-lv1: oklch(from var(--bilibili-gate--bg) calc(l - 0.04) c h);\n  --bilibili-gate--bg-lv2: oklch(from var(--bilibili-gate--bg) calc(l - 0.08) c h);\n  --bilibili-gate--bg-lv3: oklch(from var(--bilibili-gate--bg) calc(l - 0.12) c h);\n}\n:root.bilibili-gate-using-dark {\n  --bilibili-gate--border-color: oklch(from var(--bilibili-gate--bg) calc(l + 0.07) c h);\n  --bilibili-gate--bg-lv1: oklch(from var(--bilibili-gate--bg) calc(l + 0.03) c h);\n  --bilibili-gate--bg-lv2: oklch(from var(--bilibili-gate--bg) calc(l + 0.08) c h);\n  --bilibili-gate--bg-lv3: oklch(from var(--bilibili-gate--bg) calc(l + 0.12) c h);\n}\n\n:root {\n  --bilibili-gate--z-rec-header: 1001;\n  --bilibili-gate--z-base-modal: 10003;\n  --bilibili-gate--z-antd-popup-base: 11000;\n  --bilibili-gate--z-video-card-large-preview: 11200;\n  --bilibili-gate--z-video-card-context-menu: 11300;\n  --bilibili-gate--z-toast: 90000;\n}\n\n.bilibili-gate-root {\n  font-family: var(--custom-font-family--options--font-family, var(--bilibili-gate--font)) !important;\n  --back-top-right: 24px;\n}\n.bilibili-gate-root .bili-video-card .bili-video-card__info--tit:hover,\n.bilibili-gate-root .bili-video-card a:not(.disable-hover):hover {\n  color: var(--bilibili-gate--primary-color) !important;\n}\n.bilibili-gate-root .ant-btn {\n  font-size: 13px;\n}\n.bilibili-gate-root .ant-btn:disabled {\n  cursor: wait;\n}\n.bilibili-gate-root .ant-btn > span.ant-btn-icon {\n  line-height: 0;\n}\n.bilibili-gate-root .ant-radio-button-wrapper-disabled {\n  cursor: wait;\n}\n\n@media (max-width: 1440px) {\n  .bilibili-gate-root {\n    --back-top-right: 16px;\n  }\n}\nbody .ant-tooltip a {\n  color: #1677ff;\n  transition: color 0.3s;\n}\nbody .ant-tooltip a:visited {\n  color: #1677ff;\n}\nbody .ant-tooltip a:hover {\n  color: #69b1ff;\n}\nbody .ant-tooltip a:active {\n  color: #0958d9;\n}\n\nbody button:where(.ant-switch):focus, body button:where(.ant-switch):active {\n  background-color: rgba(0, 0, 0, 0.25);\n  outline: unset;\n}\n\n/**\nB站自带 css, 影响了 solid button :focus 样式\nbody button:focus, body button:active {\n  background-color: transparent;\n  outline: none;\n}\n */\nbody .ant-btn.ant-btn-variant-solid:focus, body .ant-btn.ant-btn-variant-solid:active {\n  color: var(--ant-button-primary-color);\n  background: var(--ant-color-primary);\n}';
  importCSS(globalScss);
  const clsGateVideoGridDivider = "_cls-gate-video-grid-divider_kgj54_1";
  const videoGrid = "_video-grid_b2rnv_2";
  const videoGridBiliFeed4 = "_video-grid-bili-feed4_b2rnv_15";
  const limitTwoLines = "_limit-two-lines_b2rnv_33";
  const videoGridContainer = "_video-grid-container_b2rnv_51";
  const videoGridCustom = "_video-grid-custom_b2rnv_62";
  const narrowMode = "_narrow-mode_b2rnv_112";
  function countBy(arr, mapper) {
    const result = {};
    for (let i2 = 0; i2 < arr.length; i2++) {
      const item = arr[i2];
      const key = mapper(item);
      result[key] = (result[key] ?? 0) + 1;
    }
    return result;
  }
  function difference(firstArr, secondArr) {
    const secondSet = new Set(secondArr);
    return firstArr.filter((item) => !secondSet.has(item));
  }
  function groupBy(arr, getKeyFromItem) {
    const result = {};
    for (let i2 = 0; i2 < arr.length; i2++) {
      const item = arr[i2];
      const key = getKeyFromItem(item);
      if (!Object.hasOwn(result, key)) {
        result[key] = [];
      }
      result[key].push(item);
    }
    return result;
  }
  function compareValues(a2, b, order) {
    if (a2 < b) {
      return order === "asc" ? -1 : 1;
    }
    if (a2 > b) {
      return order === "asc" ? 1 : -1;
    }
    return 0;
  }
  function orderBy(arr, criteria, orders) {
    return arr.slice().sort((a2, b) => {
      const ordersLength = orders.length;
      for (let i2 = 0; i2 < criteria.length; i2++) {
        const order = ordersLength > i2 ? orders[i2] : orders[ordersLength - 1];
        const criterion = criteria[i2];
        const criterionIsFunction = typeof criterion === "function";
        const valueA = criterionIsFunction ? criterion(a2) : a2[criterion];
        const valueB = criterionIsFunction ? criterion(b) : b[criterion];
        const result = compareValues(valueA, valueB, order);
        if (result !== 0) {
          return result;
        }
      }
      return 0;
    });
  }
  function random(minimum, maximum) {
    if (maximum == null) {
      maximum = minimum;
      minimum = 0;
    }
    if (minimum >= maximum) {
      throw new Error("Invalid input: The maximum value must be greater than the minimum value.");
    }
    return Math.random() * (maximum - minimum) + minimum;
  }
  function randomInt(minimum, maximum) {
    return Math.floor(random(minimum, maximum));
  }
  function shuffle(arr) {
    const result = arr.slice();
    for (let i2 = result.length - 1; i2 >= 1; i2--) {
      const j = Math.floor(Math.random() * (i2 + 1));
      [result[i2], result[j]] = [result[j], result[i2]];
    }
    return result;
  }
  function isSymbol(value) {
    return typeof value === "symbol" || value instanceof Symbol;
  }
  function toNumber(value) {
    if (isSymbol(value)) {
      return NaN;
    }
    return Number(value);
  }
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === Infinity || value === -Infinity) {
      const sign = value < 0 ? -1 : 1;
      return sign * Number.MAX_VALUE;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    const finite = toFinite(value);
    const remainder = finite % 1;
    return remainder ? finite - remainder : finite;
  }
  function uniq(arr) {
    return [...new Set(arr)];
  }
  function uniqBy(arr, mapper) {
    const map = new Map();
    for (let i2 = 0; i2 < arr.length; i2++) {
      const item = arr[i2];
      const key = mapper(item);
      if (!map.has(key)) {
        map.set(key, item);
      }
    }
    return Array.from(map.values());
  }
  let AbortError$1 = class AbortError extends Error {
    constructor(message2 = "The operation was aborted") {
      super(message2);
      this.name = "AbortError";
    }
  };
  function debounce$1(func, debounceMs, { signal, edges } = {}) {
    let pendingThis = void 0;
    let pendingArgs = null;
    const leading = edges != null && edges.includes("leading");
    const trailing = edges == null || edges.includes("trailing");
    const invoke = () => {
      if (pendingArgs !== null) {
        func.apply(pendingThis, pendingArgs);
        pendingThis = void 0;
        pendingArgs = null;
      }
    };
    const onTimerEnd = () => {
      if (trailing) {
        invoke();
      }
      cancel();
    };
    let timeoutId = null;
    const schedule = () => {
      if (timeoutId != null) {
        clearTimeout(timeoutId);
      }
      timeoutId = setTimeout(() => {
        timeoutId = null;
        onTimerEnd();
      }, debounceMs);
    };
    const cancelTimer = () => {
      if (timeoutId !== null) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
    };
    const cancel = () => {
      cancelTimer();
      pendingThis = void 0;
      pendingArgs = null;
    };
    const flush = () => {
      invoke();
    };
    const debounced = function(...args) {
      if (signal?.aborted) {
        return;
      }
      pendingThis = this;
      pendingArgs = args;
      const isFirstCall = timeoutId == null;
      schedule();
      if (leading && isFirstCall) {
        invoke();
      }
    };
    debounced.schedule = schedule;
    debounced.cancel = cancel;
    debounced.flush = flush;
    signal?.addEventListener("abort", cancel, { once: true });
    return debounced;
  }
  function noop$1() {
  }
  function once(func) {
    let called = false;
    let cache2;
    return function(...args) {
      if (!called) {
        called = true;
        cache2 = func(...args);
      }
      return cache2;
    };
  }
  function delay(ms2, { signal } = {}) {
    return new Promise((resolve, reject) => {
      const abortError = () => {
        reject(new AbortError$1());
      };
      const abortHandler = () => {
        clearTimeout(timeoutId);
        abortError();
      };
      if (signal?.aborted) {
        return abortError();
      }
      const timeoutId = setTimeout(() => {
        signal?.removeEventListener("abort", abortHandler);
        resolve();
      }, ms2);
      signal?.addEventListener("abort", abortHandler, { once: true });
    });
  }
  function throttle$1(func, throttleMs, { signal, edges = ["leading", "trailing"] } = {}) {
    let pendingAt = null;
    const debounced = debounce$1(func, throttleMs, { signal, edges });
    const throttled = function(...args) {
      if (pendingAt == null) {
        pendingAt = Date.now();
      } else {
        if (Date.now() - pendingAt >= throttleMs) {
          pendingAt = Date.now();
          debounced.cancel();
        }
      }
      debounced.apply(this, args);
    };
    throttled.cancel = debounced.cancel;
    throttled.flush = debounced.flush;
    return throttled;
  }
  function range(start, end, step = 1) {
    if (end == null) {
      end = start;
      start = 0;
    }
    if (!Number.isInteger(step) || step === 0) {
      throw new Error(`The step value must be a non-zero integer.`);
    }
    const length2 = Math.max(Math.ceil((end - start) / step), 0);
    const result = new Array(length2);
    for (let i2 = 0; i2 < length2; i2++) {
      result[i2] = start + i2 * step;
    }
    return result;
  }
  function isPrimitive(value) {
    return value == null || typeof value !== "object" && typeof value !== "function";
  }
  function isTypedArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }
  function clone(obj) {
    if (isPrimitive(obj)) {
      return obj;
    }
    if (Array.isArray(obj) || isTypedArray(obj) || obj instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && obj instanceof SharedArrayBuffer) {
      return obj.slice(0);
    }
    const prototype = Object.getPrototypeOf(obj);
    const Constructor = prototype.constructor;
    if (obj instanceof Date || obj instanceof Map || obj instanceof Set) {
      return new Constructor(obj);
    }
    if (obj instanceof RegExp) {
      const newRegExp = new Constructor(obj);
      newRegExp.lastIndex = obj.lastIndex;
      return newRegExp;
    }
    if (obj instanceof DataView) {
      return new Constructor(obj.buffer.slice(0));
    }
    if (obj instanceof Error) {
      const newError = new Constructor(obj.message);
      newError.stack = obj.stack;
      newError.name = obj.name;
      newError.cause = obj.cause;
      return newError;
    }
    if (typeof File !== "undefined" && obj instanceof File) {
      const newFile = new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });
      return newFile;
    }
    if (typeof obj === "object") {
      const newObject = Object.create(prototype);
      return Object.assign(newObject, obj);
    }
    return obj;
  }
  function getSymbols(object) {
    return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
  }
  function getTag(value) {
    if (value == null) {
      return value === void 0 ? "[object Undefined]" : "[object Null]";
    }
    return Object.prototype.toString.call(value);
  }
  const regexpTag = "[object RegExp]";
  const stringTag = "[object String]";
  const numberTag = "[object Number]";
  const booleanTag = "[object Boolean]";
  const argumentsTag = "[object Arguments]";
  const symbolTag = "[object Symbol]";
  const dateTag = "[object Date]";
  const mapTag = "[object Map]";
  const setTag = "[object Set]";
  const arrayTag = "[object Array]";
  const functionTag = "[object Function]";
  const arrayBufferTag = "[object ArrayBuffer]";
  const objectTag = "[object Object]";
  const errorTag = "[object Error]";
  const dataViewTag = "[object DataView]";
  const uint8ArrayTag = "[object Uint8Array]";
  const uint8ClampedArrayTag = "[object Uint8ClampedArray]";
  const uint16ArrayTag = "[object Uint16Array]";
  const uint32ArrayTag = "[object Uint32Array]";
  const bigUint64ArrayTag = "[object BigUint64Array]";
  const int8ArrayTag = "[object Int8Array]";
  const int16ArrayTag = "[object Int16Array]";
  const int32ArrayTag = "[object Int32Array]";
  const bigInt64ArrayTag = "[object BigInt64Array]";
  const float32ArrayTag = "[object Float32Array]";
  const float64ArrayTag = "[object Float64Array]";
  function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = new Map(), cloneValue = void 0) {
    const cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);
    if (cloned !== void 0) {
      return cloned;
    }
    if (isPrimitive(valueToClone)) {
      return valueToClone;
    }
    if (stack.has(valueToClone)) {
      return stack.get(valueToClone);
    }
    if (Array.isArray(valueToClone)) {
      const result = new Array(valueToClone.length);
      stack.set(valueToClone, result);
      for (let i2 = 0; i2 < valueToClone.length; i2++) {
        result[i2] = cloneDeepWithImpl(valueToClone[i2], i2, objectToClone, stack, cloneValue);
      }
      if (Object.hasOwn(valueToClone, "index")) {
        result.index = valueToClone.index;
      }
      if (Object.hasOwn(valueToClone, "input")) {
        result.input = valueToClone.input;
      }
      return result;
    }
    if (valueToClone instanceof Date) {
      return new Date(valueToClone.getTime());
    }
    if (valueToClone instanceof RegExp) {
      const result = new RegExp(valueToClone.source, valueToClone.flags);
      result.lastIndex = valueToClone.lastIndex;
      return result;
    }
    if (valueToClone instanceof Map) {
      const result = new Map();
      stack.set(valueToClone, result);
      for (const [key, value] of valueToClone) {
        result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));
      }
      return result;
    }
    if (valueToClone instanceof Set) {
      const result = new Set();
      stack.set(valueToClone, result);
      for (const value of valueToClone) {
        result.add(cloneDeepWithImpl(value, void 0, objectToClone, stack, cloneValue));
      }
      return result;
    }
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
      return valueToClone.subarray();
    }
    if (isTypedArray(valueToClone)) {
      const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
      stack.set(valueToClone, result);
      for (let i2 = 0; i2 < valueToClone.length; i2++) {
        result[i2] = cloneDeepWithImpl(valueToClone[i2], i2, objectToClone, stack, cloneValue);
      }
      return result;
    }
    if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
      return valueToClone.slice(0);
    }
    if (valueToClone instanceof DataView) {
      const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
      stack.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
      return result;
    }
    if (typeof File !== "undefined" && valueToClone instanceof File) {
      const result = new File([valueToClone], valueToClone.name, {
        type: valueToClone.type
      });
      stack.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
      return result;
    }
    if (typeof Blob !== "undefined" && valueToClone instanceof Blob) {
      const result = new Blob([valueToClone], { type: valueToClone.type });
      stack.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
      return result;
    }
    if (valueToClone instanceof Error) {
      const result = new valueToClone.constructor();
      stack.set(valueToClone, result);
      result.message = valueToClone.message;
      result.name = valueToClone.name;
      result.stack = valueToClone.stack;
      result.cause = valueToClone.cause;
      copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
      return result;
    }
    if (valueToClone instanceof Boolean) {
      const result = new Boolean(valueToClone.valueOf());
      stack.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
      return result;
    }
    if (valueToClone instanceof Number) {
      const result = new Number(valueToClone.valueOf());
      stack.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
      return result;
    }
    if (valueToClone instanceof String) {
      const result = new String(valueToClone.valueOf());
      stack.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
      return result;
    }
    if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
      const result = Object.create(Object.getPrototypeOf(valueToClone));
      stack.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
      return result;
    }
    return valueToClone;
  }
  function copyProperties(target, source, objectToClone = target, stack, cloneValue) {
    const keys = [...Object.keys(source), ...getSymbols(source)];
    for (let i2 = 0; i2 < keys.length; i2++) {
      const key = keys[i2];
      const descriptor = Object.getOwnPropertyDescriptor(target, key);
      if (descriptor == null || descriptor.writable) {
        target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);
      }
    }
  }
  function isCloneableObject(object) {
    switch (getTag(object)) {
      case argumentsTag:
      case arrayTag:
      case arrayBufferTag:
      case dataViewTag:
      case booleanTag:
      case dateTag:
      case float32ArrayTag:
      case float64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case mapTag:
      case numberTag:
      case objectTag:
      case regexpTag:
      case setTag:
      case stringTag:
      case symbolTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag: {
        return true;
      }
      default: {
        return false;
      }
    }
  }
  function cloneDeep(obj) {
    return cloneDeepWithImpl(obj, void 0, obj, new Map(), void 0);
  }
  function isPlainObject(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    const proto = Object.getPrototypeOf(value);
    const hasObjectPrototype = proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null;
    if (!hasObjectPrototype) {
      return false;
    }
    return Object.prototype.toString.call(value) === "[object Object]";
  }
  function isUnsafeProperty(key) {
    return key === "__proto__";
  }
  function mergeWith(target, source, merge2) {
    const sourceKeys = Object.keys(source);
    for (let i2 = 0; i2 < sourceKeys.length; i2++) {
      const key = sourceKeys[i2];
      if (isUnsafeProperty(key)) {
        continue;
      }
      const sourceValue = source[key];
      const targetValue = target[key];
      const merged = merge2(targetValue, sourceValue, key, target, source);
      if (merged !== void 0) {
        target[key] = merged;
      } else if (Array.isArray(sourceValue)) {
        if (Array.isArray(targetValue)) {
          target[key] = mergeWith(targetValue ?? [], sourceValue, merge2);
        } else {
          target[key] = mergeWith([], sourceValue, merge2);
        }
      } else if (isPlainObject(sourceValue)) {
        if (isPlainObject(targetValue)) {
          target[key] = mergeWith(targetValue, sourceValue, merge2);
        } else {
          target[key] = mergeWith({}, sourceValue, merge2);
        }
      } else if (targetValue === void 0 || sourceValue !== void 0) {
        target[key] = sourceValue;
      }
    }
    return target;
  }
  function omit(obj, keys) {
    const result = { ...obj };
    for (let i2 = 0; i2 < keys.length; i2++) {
      const key = keys[i2];
      delete result[key];
    }
    return result;
  }
  function pick(obj, keys) {
    const result = {};
    for (let i2 = 0; i2 < keys.length; i2++) {
      const key = keys[i2];
      if (Object.hasOwn(obj, key)) {
        result[key] = obj[key];
      }
    }
    return result;
  }
  const CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");
  function words(str) {
    return Array.from(str.match(CASE_SPLIT_PATTERN) ?? []);
  }
  function toMerged(target, source) {
    return mergeWith(clone(target), source, function mergeRecursively(targetValue, sourceValue) {
      if (Array.isArray(sourceValue)) {
        if (Array.isArray(targetValue)) {
          return mergeWith(clone(targetValue), sourceValue, mergeRecursively);
        } else {
          return mergeWith([], sourceValue, mergeRecursively);
        }
      } else if (isPlainObject(sourceValue)) {
        if (isPlainObject(targetValue)) {
          return mergeWith(clone(targetValue), sourceValue, mergeRecursively);
        } else {
          return mergeWith({}, sourceValue, mergeRecursively);
        }
      }
    });
  }
  function eq(value, other) {
    return value === other || Number.isNaN(value) && Number.isNaN(other);
  }
  function isEqualWith(a2, b, areValuesEqual) {
    return isEqualWithImpl(a2, b, void 0, void 0, void 0, void 0, areValuesEqual);
  }
  function isEqualWithImpl(a2, b, property, aParent, bParent, stack, areValuesEqual) {
    const result = areValuesEqual(a2, b, property, aParent, bParent, stack);
    if (result !== void 0) {
      return result;
    }
    if (typeof a2 === typeof b) {
      switch (typeof a2) {
        case "bigint":
        case "string":
        case "boolean":
        case "symbol":
        case "undefined": {
          return a2 === b;
        }
        case "number": {
          return a2 === b || Object.is(a2, b);
        }
        case "function": {
          return a2 === b;
        }
        case "object": {
          return areObjectsEqual(a2, b, stack, areValuesEqual);
        }
      }
    }
    return areObjectsEqual(a2, b, stack, areValuesEqual);
  }
  function areObjectsEqual(a2, b, stack, areValuesEqual) {
    if (Object.is(a2, b)) {
      return true;
    }
    let aTag = getTag(a2);
    let bTag = getTag(b);
    if (aTag === argumentsTag) {
      aTag = objectTag;
    }
    if (bTag === argumentsTag) {
      bTag = objectTag;
    }
    if (aTag !== bTag) {
      return false;
    }
    switch (aTag) {
      case stringTag:
        return a2.toString() === b.toString();
      case numberTag: {
        const x = a2.valueOf();
        const y = b.valueOf();
        return eq(x, y);
      }
      case booleanTag:
      case dateTag:
      case symbolTag:
        return Object.is(a2.valueOf(), b.valueOf());
      case regexpTag: {
        return a2.source === b.source && a2.flags === b.flags;
      }
      case functionTag: {
        return a2 === b;
      }
    }
    stack = stack ?? new Map();
    const aStack = stack.get(a2);
    const bStack = stack.get(b);
    if (aStack != null && bStack != null) {
      return aStack === b;
    }
    stack.set(a2, b);
    stack.set(b, a2);
    try {
      switch (aTag) {
        case mapTag: {
          if (a2.size !== b.size) {
            return false;
          }
          for (const [key, value] of a2.entries()) {
            if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a2, b, stack, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        case setTag: {
          if (a2.size !== b.size) {
            return false;
          }
          const aValues = Array.from(a2.values());
          const bValues = Array.from(b.values());
          for (let i2 = 0; i2 < aValues.length; i2++) {
            const aValue = aValues[i2];
            const index = bValues.findIndex((bValue) => {
              return isEqualWithImpl(aValue, bValue, void 0, a2, b, stack, areValuesEqual);
            });
            if (index === -1) {
              return false;
            }
            bValues.splice(index, 1);
          }
          return true;
        }
        case arrayTag:
        case uint8ArrayTag:
        case uint8ClampedArrayTag:
        case uint16ArrayTag:
        case uint32ArrayTag:
        case bigUint64ArrayTag:
        case int8ArrayTag:
        case int16ArrayTag:
        case int32ArrayTag:
        case bigInt64ArrayTag:
        case float32ArrayTag:
        case float64ArrayTag: {
          if (typeof Buffer !== "undefined" && Buffer.isBuffer(a2) !== Buffer.isBuffer(b)) {
            return false;
          }
          if (a2.length !== b.length) {
            return false;
          }
          for (let i2 = 0; i2 < a2.length; i2++) {
            if (!isEqualWithImpl(a2[i2], b[i2], i2, a2, b, stack, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        case arrayBufferTag: {
          if (a2.byteLength !== b.byteLength) {
            return false;
          }
          return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b), stack, areValuesEqual);
        }
        case dataViewTag: {
          if (a2.byteLength !== b.byteLength || a2.byteOffset !== b.byteOffset) {
            return false;
          }
          return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b), stack, areValuesEqual);
        }
        case errorTag: {
          return a2.name === b.name && a2.message === b.message;
        }
        case objectTag: {
          const areEqualInstances = areObjectsEqual(a2.constructor, b.constructor, stack, areValuesEqual) || isPlainObject(a2) && isPlainObject(b);
          if (!areEqualInstances) {
            return false;
          }
          const aKeys = [...Object.keys(a2), ...getSymbols(a2)];
          const bKeys = [...Object.keys(b), ...getSymbols(b)];
          if (aKeys.length !== bKeys.length) {
            return false;
          }
          for (let i2 = 0; i2 < aKeys.length; i2++) {
            const propKey = aKeys[i2];
            const aProp = a2[propKey];
            if (!Object.hasOwn(b, propKey)) {
              return false;
            }
            const bProp = b[propKey];
            if (!isEqualWithImpl(aProp, bProp, propKey, a2, b, stack, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        default: {
          return false;
        }
      }
    } finally {
      stack.delete(a2);
      stack.delete(b);
    }
  }
  function isEqual$1(a2, b) {
    return isEqualWith(a2, b, noop$1);
  }
  function isNil(x) {
    return x == null;
  }
  function startCase(str) {
    const words$1 = words(str.trim());
    let result = "";
    for (let i2 = 0; i2 < words$1.length; i2++) {
      const word = words$1[i2];
      if (result) {
        result += " ";
      }
      result += word[0].toUpperCase() + word.slice(1).toLowerCase();
    }
    return result;
  }
  function attempt(func) {
    try {
      return [null, func()];
    } catch (error) {
      return [error, null];
    }
  }
  async function attemptAsync(func) {
    try {
      const result = await func();
      return [null, result];
    } catch (error) {
      return [error, null];
    }
  }
  function invariant(condition, message2) {
    if (condition) {
      return;
    }
    if (typeof message2 === "string") {
      throw new Error(message2);
    }
    throw message2;
  }
  function isDeepKey(key) {
    switch (typeof key) {
      case "number":
      case "symbol": {
        return false;
      }
      case "string": {
        return key.includes(".") || key.includes("[") || key.includes("]");
      }
    }
  }
  function toKey(value) {
    if (typeof value === "string" || typeof value === "symbol") {
      return value;
    }
    if (Object.is(value?.valueOf?.(), -0)) {
      return "-0";
    }
    return String(value);
  }
  function toString(value) {
    if (value == null) {
      return "";
    }
    if (typeof value === "string") {
      return value;
    }
    if (Array.isArray(value)) {
      return value.map(toString).join(",");
    }
    const result = String(value);
    if (result === "0" && Object.is(Number(value), -0)) {
      return "-0";
    }
    return result;
  }
  function toPath(deepKey) {
    if (Array.isArray(deepKey)) {
      return deepKey.map(toKey);
    }
    if (typeof deepKey === "symbol") {
      return [deepKey];
    }
    deepKey = toString(deepKey);
    const result = [];
    const length2 = deepKey.length;
    if (length2 === 0) {
      return result;
    }
    let index = 0;
    let key = "";
    let quoteChar = "";
    let bracket = false;
    if (deepKey.charCodeAt(0) === 46) {
      result.push("");
      index++;
    }
    while (index < length2) {
      const char2 = deepKey[index];
      if (quoteChar) {
        if (char2 === "\\" && index + 1 < length2) {
          index++;
          key += deepKey[index];
        } else if (char2 === quoteChar) {
          quoteChar = "";
        } else {
          key += char2;
        }
      } else if (bracket) {
        if (char2 === '"' || char2 === "'") {
          quoteChar = char2;
        } else if (char2 === "]") {
          bracket = false;
          result.push(key);
          key = "";
        } else {
          key += char2;
        }
      } else {
        if (char2 === "[") {
          bracket = true;
          if (key) {
            result.push(key);
            key = "";
          }
        } else if (char2 === ".") {
          if (key) {
            result.push(key);
            key = "";
          }
        } else {
          key += char2;
        }
      }
      index++;
    }
    if (key) {
      result.push(key);
    }
    return result;
  }
  function get(object, path, defaultValue2) {
    if (object == null) {
      return defaultValue2;
    }
    switch (typeof path) {
      case "string": {
        if (isUnsafeProperty(path)) {
          return defaultValue2;
        }
        const result = object[path];
        if (result === void 0) {
          if (isDeepKey(path)) {
            return get(object, toPath(path), defaultValue2);
          } else {
            return defaultValue2;
          }
        }
        return result;
      }
      case "number":
      case "symbol": {
        if (typeof path === "number") {
          path = toKey(path);
        }
        const result = object[path];
        if (result === void 0) {
          return defaultValue2;
        }
        return result;
      }
      default: {
        if (Array.isArray(path)) {
          return getWithPath(object, path, defaultValue2);
        }
        if (Object.is(path?.valueOf(), -0)) {
          path = "-0";
        } else {
          path = String(path);
        }
        if (isUnsafeProperty(path)) {
          return defaultValue2;
        }
        const result = object[path];
        if (result === void 0) {
          return defaultValue2;
        }
        return result;
      }
    }
  }
  function getWithPath(object, path, defaultValue2) {
    if (path.length === 0) {
      return defaultValue2;
    }
    let current = object;
    for (let index = 0; index < path.length; index++) {
      if (current == null) {
        return defaultValue2;
      }
      if (isUnsafeProperty(path[index])) {
        return defaultValue2;
      }
      current = current[path[index]];
    }
    if (current === void 0) {
      return defaultValue2;
    }
    return current;
  }
  function isObject$2(value) {
    return value !== null && (typeof value === "object" || typeof value === "function");
  }
  const IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length2 = Number.MAX_SAFE_INTEGER) {
    switch (typeof value) {
      case "number": {
        return Number.isInteger(value) && value >= 0 && value < length2;
      }
      case "symbol": {
        return false;
      }
      case "string": {
        return IS_UNSIGNED_INTEGER.test(value);
      }
    }
  }
  const regexIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  const regexIsPlainProp = /^\w*$/;
  function isKey(value, object) {
    if (Array.isArray(value)) {
      return false;
    }
    if (typeof value === "number" || typeof value === "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return typeof value === "string" && (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value)) || object != null && Object.hasOwn(object, value);
  }
  const assignValue = (object, key, value) => {
    const objValue = object[key];
    if (!(Object.hasOwn(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      object[key] = value;
    }
  };
  function updateWith(obj, path, updater, customizer) {
    if (obj == null && !isObject$2(obj)) {
      return obj;
    }
    const resolvedPath = isKey(path, obj) ? [path] : Array.isArray(path) ? path : typeof path === "string" ? toPath(path) : [path];
    const updateValue = updater(get(obj, resolvedPath));
    let current = obj;
    for (let i2 = 0; i2 < resolvedPath.length && current != null; i2++) {
      const key = toKey(resolvedPath[i2]);
      if (isUnsafeProperty(key)) {
        continue;
      }
      let newValue;
      if (i2 === resolvedPath.length - 1) {
        newValue = updateValue;
      } else {
        const objValue = current[key];
        const customizerResult = customizer?.(objValue, key, obj);
        newValue = customizerResult !== void 0 ? customizerResult : isObject$2(objValue) ? objValue : isIndex(resolvedPath[i2 + 1]) ? [] : {};
      }
      assignValue(current, key, newValue);
      current = current[key];
    }
    return obj;
  }
  function set(obj, path, value) {
    return updateWith(obj, path, () => value, () => void 0);
  }
  function times(n2, getValue) {
    n2 = toInteger(n2);
    if (n2 < 1 || !Number.isSafeInteger(n2)) {
      return [];
    }
    const result = new Array(n2);
    for (let i2 = 0; i2 < n2; i2++) {
      result[i2] = typeof getValue === "function" ? getValue(i2) : i2;
    }
    return result;
  }
  const TRACK_MEMO_SYMBOL = Symbol();
  const GET_ORIGINAL_SYMBOL = Symbol();
  const AFFECTED_PROPERTY = "a";
  const IS_TARGET_COPIED_PROPERTY = "f";
  const PROXY_PROPERTY = "p";
  const PROXY_CACHE_PROPERTY = "c";
  const TARGET_CACHE_PROPERTY = "t";
  const HAS_KEY_PROPERTY = "h";
  const ALL_OWN_KEYS_PROPERTY = "w";
  const HAS_OWN_KEY_PROPERTY = "o";
  const KEYS_PROPERTY = "k";
  let newProxy$1 = (target, handler) => new Proxy(target, handler);
  const getProto = Object.getPrototypeOf;
  const objectsToTrack = new WeakMap();
  const isObjectToTrack = (obj) => obj && (objectsToTrack.has(obj) ? objectsToTrack.get(obj) : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);
  const isObject$1 = (x) => typeof x === "object" && x !== null;
  const needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);
  const copyTargetObject = (obj) => {
    if (Array.isArray(obj)) {
      return Array.from(obj);
    }
    const descriptors = Object.getOwnPropertyDescriptors(obj);
    Object.values(descriptors).forEach((desc) => {
      desc.configurable = true;
    });
    return Object.create(getProto(obj), descriptors);
  };
  const createProxyHandler = (origObj, isTargetCopied) => {
    const state2 = {
      [IS_TARGET_COPIED_PROPERTY]: isTargetCopied
    };
    let trackObject = false;
    const recordUsage = (type, key) => {
      if (!trackObject) {
        let used = state2[AFFECTED_PROPERTY].get(origObj);
        if (!used) {
          used = {};
          state2[AFFECTED_PROPERTY].set(origObj, used);
        }
        if (type === ALL_OWN_KEYS_PROPERTY) {
          used[ALL_OWN_KEYS_PROPERTY] = true;
        } else {
          let set2 = used[type];
          if (!set2) {
            set2 = new Set();
            used[type] = set2;
          }
          set2.add(key);
        }
      }
    };
    const recordObjectAsUsed = () => {
      trackObject = true;
      state2[AFFECTED_PROPERTY].delete(origObj);
    };
    const handler = {
      get(target, key) {
        if (key === GET_ORIGINAL_SYMBOL) {
          return origObj;
        }
        recordUsage(KEYS_PROPERTY, key);
        return createProxy(Reflect.get(target, key), state2[AFFECTED_PROPERTY], state2[PROXY_CACHE_PROPERTY], state2[TARGET_CACHE_PROPERTY]);
      },
      has(target, key) {
        if (key === TRACK_MEMO_SYMBOL) {
          recordObjectAsUsed();
          return true;
        }
        recordUsage(HAS_KEY_PROPERTY, key);
        return Reflect.has(target, key);
      },
      getOwnPropertyDescriptor(target, key) {
        recordUsage(HAS_OWN_KEY_PROPERTY, key);
        return Reflect.getOwnPropertyDescriptor(target, key);
      },
      ownKeys(target) {
        recordUsage(ALL_OWN_KEYS_PROPERTY);
        return Reflect.ownKeys(target);
      }
    };
    if (isTargetCopied) {
      handler.set = handler.deleteProperty = () => false;
    }
    return [handler, state2];
  };
  const getOriginalObject = (obj) => (
obj[GET_ORIGINAL_SYMBOL] ||
obj
  );
  const createProxy = (obj, affected, proxyCache2, targetCache2) => {
    if (!isObjectToTrack(obj))
      return obj;
    let targetAndCopied = targetCache2 && targetCache2.get(obj);
    if (!targetAndCopied) {
      const target2 = getOriginalObject(obj);
      if (needsToCopyTargetObject(target2)) {
        targetAndCopied = [target2, copyTargetObject(target2)];
      } else {
        targetAndCopied = [target2];
      }
      targetCache2 === null || targetCache2 === void 0 ? void 0 : targetCache2.set(obj, targetAndCopied);
    }
    const [target, copiedTarget] = targetAndCopied;
    let handlerAndState = proxyCache2 && proxyCache2.get(target);
    if (!handlerAndState || handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {
      handlerAndState = createProxyHandler(target, !!copiedTarget);
      handlerAndState[1][PROXY_PROPERTY] = newProxy$1(copiedTarget || target, handlerAndState[0]);
      if (proxyCache2) {
        proxyCache2.set(target, handlerAndState);
      }
    }
    handlerAndState[1][AFFECTED_PROPERTY] = affected;
    handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache2;
    handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache2;
    return handlerAndState[1][PROXY_PROPERTY];
  };
  const isAllOwnKeysChanged = (prevObj, nextObj) => {
    const prevKeys = Reflect.ownKeys(prevObj);
    const nextKeys = Reflect.ownKeys(nextObj);
    return prevKeys.length !== nextKeys.length || prevKeys.some((k, i2) => k !== nextKeys[i2]);
  };
  const isChanged = (prevObj, nextObj, affected, cache2, isEqual2 = Object.is) => {
    if (isEqual2(prevObj, nextObj)) {
      return false;
    }
    if (!isObject$1(prevObj) || !isObject$1(nextObj))
      return true;
    const used = affected.get(getOriginalObject(prevObj));
    if (!used)
      return true;
    if (cache2) {
      const hit = cache2.get(prevObj);
      if (hit === nextObj) {
        return false;
      }
      cache2.set(prevObj, nextObj);
    }
    let changed = null;
    for (const key of used[HAS_KEY_PROPERTY] || []) {
      changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);
      if (changed)
        return changed;
    }
    if (used[ALL_OWN_KEYS_PROPERTY] === true) {
      changed = isAllOwnKeysChanged(prevObj, nextObj);
      if (changed)
        return changed;
    } else {
      for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {
        const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);
        const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);
        changed = hasPrev !== hasNext;
        if (changed)
          return changed;
      }
    }
    for (const key of used[KEYS_PROPERTY] || []) {
      changed = isChanged(prevObj[key], nextObj[key], affected, cache2, isEqual2);
      if (changed)
        return changed;
    }
    if (changed === null)
      throw new Error("invalid used");
    return changed;
  };
  const getUntracked = (obj) => {
    if (isObjectToTrack(obj)) {
      return obj[GET_ORIGINAL_SYMBOL] || null;
    }
    return null;
  };
  const markToTrack = (obj, mark = true) => {
    objectsToTrack.set(obj, mark);
  };
  const affectedToPathList = (obj, affected, onlyWithValues) => {
    const list2 = [];
    const seen = new WeakSet();
    const walk = (x, path) => {
      var _a, _b, _c;
      if (seen.has(x)) {
        return;
      }
      if (isObject$1(x)) {
        seen.add(x);
      }
      const used = isObject$1(x) && affected.get(getOriginalObject(x));
      if (used) {
        (_a = used[HAS_KEY_PROPERTY]) === null || _a === void 0 ? void 0 : _a.forEach((key) => {
          const segment = `:has(${String(key)})`;
          list2.push(path ? [...path, segment] : [segment]);
        });
        if (used[ALL_OWN_KEYS_PROPERTY] === true) {
          const segment = ":ownKeys";
          list2.push(path ? [...path, segment] : [segment]);
        } else {
          (_b = used[HAS_OWN_KEY_PROPERTY]) === null || _b === void 0 ? void 0 : _b.forEach((key) => {
            const segment = `:hasOwn(${String(key)})`;
            list2.push(path ? [...path, segment] : [segment]);
          });
        }
        (_c = used[KEYS_PROPERTY]) === null || _c === void 0 ? void 0 : _c.forEach((key) => {
          if ("value" in (Object.getOwnPropertyDescriptor(x, key) || {})) {
            walk(x[key], path ? [...path, key] : [key]);
          }
        });
      } else if (path) {
        list2.push(path);
      }
    };
    walk(obj);
    return list2;
  };
  const __vite_import_meta_env__$1 = {};
  const isObject = (x) => typeof x === "object" && x !== null;
  const canProxyDefault = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer) && !(x instanceof Promise);
  const createSnapshotDefault = (target, version) => {
    const cache2 = snapCache$2.get(target);
    if ((cache2 == null ? void 0 : cache2[0]) === version) {
      return cache2[1];
    }
    const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
    markToTrack(snap, true);
    snapCache$2.set(target, [version, snap]);
    Reflect.ownKeys(target).forEach((key) => {
      if (Object.getOwnPropertyDescriptor(snap, key)) {
        return;
      }
      const value = Reflect.get(target, key);
      const { enumerable } = Reflect.getOwnPropertyDescriptor(
        target,
        key
      );
      const desc = {
        value,
        enumerable,

configurable: true
      };
      if (refSet.has(value)) {
        markToTrack(value, false);
      } else if (proxyStateMap$2.has(value)) {
        const [target2, ensureVersion] = proxyStateMap$2.get(
          value
        );
        desc.value = createSnapshotDefault(target2, ensureVersion());
      }
      Object.defineProperty(snap, key, desc);
    });
    return Object.preventExtensions(snap);
  };
  const createHandlerDefault = (isInitializing, addPropListener, removePropListener, notifyUpdate) => ({
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      const hasPrevValue = !isInitializing() && Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject(value)) {
        value = getUntracked(value) || value;
      }
      const nextValue = !proxyStateMap$2.has(value) && canProxy(value) ? proxy(value) : value;
      addPropListener(prop, nextValue);
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  });
  const proxyStateMap$2 = new WeakMap();
  const refSet = new WeakSet();
  const snapCache$2 = new WeakMap();
  const versionHolder = [1];
  const proxyCache = new WeakMap();
  let objectIs = Object.is;
  let newProxy = (target, handler) => new Proxy(target, handler);
  let canProxy = canProxyDefault;
  let createSnapshot = createSnapshotDefault;
  let createHandler = createHandlerDefault;
  function proxy(baseObject = {}) {
    if (!isObject(baseObject)) {
      throw new Error("object required");
    }
    const found = proxyCache.get(baseObject);
    if (found) {
      return found;
    }
    let version = versionHolder[0];
    const listeners2 = new Set();
    const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
      if (version !== nextVersion) {
        checkVersion = version = nextVersion;
        listeners2.forEach((listener) => listener(op, nextVersion));
      }
    };
    let checkVersion = version;
    const ensureVersion = (nextCheckVersion = versionHolder[0]) => {
      if (checkVersion !== nextCheckVersion) {
        checkVersion = nextCheckVersion;
        propProxyStates.forEach(([propProxyState]) => {
          const propVersion = propProxyState[1](nextCheckVersion);
          if (propVersion > version) {
            version = propVersion;
          }
        });
      }
      return version;
    };
    const createPropListener = (prop) => (op, nextVersion) => {
      const newOp = [...op];
      newOp[1] = [prop, ...newOp[1]];
      notifyUpdate(newOp, nextVersion);
    };
    const propProxyStates = new Map();
    const addPropListener = (prop, propValue) => {
      const propProxyState = !refSet.has(propValue) && proxyStateMap$2.get(propValue);
      if (propProxyState) {
        if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && propProxyStates.has(prop)) {
          throw new Error("prop listener already exists");
        }
        if (listeners2.size) {
          const remove = propProxyState[2](createPropListener(prop));
          propProxyStates.set(prop, [propProxyState, remove]);
        } else {
          propProxyStates.set(prop, [propProxyState]);
        }
      }
    };
    const removePropListener = (prop) => {
      var _a;
      const entry = propProxyStates.get(prop);
      if (entry) {
        propProxyStates.delete(prop);
        (_a = entry[1]) == null ? void 0 : _a.call(entry);
      }
    };
    const addListener = (listener) => {
      listeners2.add(listener);
      if (listeners2.size === 1) {
        propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
          if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && prevRemove) {
            throw new Error("remove already exists");
          }
          const remove = propProxyState[2](createPropListener(prop));
          propProxyStates.set(prop, [propProxyState, remove]);
        });
      }
      const removeListener = () => {
        listeners2.delete(listener);
        if (listeners2.size === 0) {
          propProxyStates.forEach(([propProxyState, remove], prop) => {
            if (remove) {
              remove();
              propProxyStates.set(prop, [propProxyState]);
            }
          });
        }
      };
      return removeListener;
    };
    let initializing = true;
    const handler = createHandler(
      () => initializing,
      addPropListener,
      removePropListener,
      notifyUpdate
    );
    const proxyObject = newProxy(baseObject, handler);
    proxyCache.set(baseObject, proxyObject);
    const proxyState = [baseObject, ensureVersion, addListener];
    proxyStateMap$2.set(proxyObject, proxyState);
    Reflect.ownKeys(baseObject).forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(
        baseObject,
        key
      );
      if ("value" in desc && desc.writable) {
        proxyObject[key] = baseObject[key];
      }
    });
    initializing = false;
    return proxyObject;
  }
  function subscribe$3(proxyObject, callback, notifyInSync) {
    const proxyState = proxyStateMap$2.get(proxyObject);
    if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && !proxyState) {
      console.warn("Please use proxy object");
    }
    let promise;
    const ops = [];
    const addListener = proxyState[2];
    let isListenerActive = false;
    const listener = (op) => {
      ops.push(op);
      if (notifyInSync) {
        callback(ops.splice(0));
        return;
      }
      if (!promise) {
        promise = Promise.resolve().then(() => {
          promise = void 0;
          if (isListenerActive) {
            callback(ops.splice(0));
          }
        });
      }
    };
    const removeListener = addListener(listener);
    isListenerActive = true;
    return () => {
      isListenerActive = false;
      removeListener();
    };
  }
  function snapshot(proxyObject) {
    const proxyState = proxyStateMap$2.get(proxyObject);
    if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && !proxyState) {
      console.warn("Please use proxy object");
    }
    const [target, ensureVersion] = proxyState;
    return createSnapshot(target, ensureVersion());
  }
  function unstable_getInternalStates() {
    return {
      proxyStateMap: proxyStateMap$2,
      refSet,
      snapCache: snapCache$2,
      versionHolder,
      proxyCache
    };
  }
  const __vite_import_meta_env__ = {};
  const useAffectedDebugValue = (state2, affected) => {
    const pathList = H.useRef(void 0);
    H.useEffect(() => {
      pathList.current = affectedToPathList(state2, affected);
    });
    H.useDebugValue(pathList.current);
  };
  const condUseAffectedDebugValue = useAffectedDebugValue;
  const targetCache = new WeakMap();
  function useSnapshot(proxyObject, options) {
    const notifyInSync = options == null ? void 0 : options.sync;
    const affected = H.useMemo(
      () => proxyObject && new WeakMap(),
      [proxyObject]
    );
    const lastSnapshot = H.useRef(void 0);
    let inRender = true;
    const currSnapshot = H.useSyncExternalStore(
      H.useCallback(
        (callback) => {
          const unsub = subscribe$3(proxyObject, callback, notifyInSync);
          callback();
          return unsub;
        },
        [proxyObject, notifyInSync]
      ),
      () => {
        const nextSnapshot = snapshot(proxyObject);
        try {
          if (!inRender && lastSnapshot.current && !isChanged(
            lastSnapshot.current,
            nextSnapshot,
            affected,
new WeakMap()
          )) {
            return lastSnapshot.current;
          }
        } catch (e2) {
        }
        return nextSnapshot;
      },
      () => snapshot(proxyObject)
    );
    inRender = false;
    H.useLayoutEffect(() => {
      lastSnapshot.current = currSnapshot;
    });
    if ((__vite_import_meta_env__ ? "production" : void 0) !== "production") {
      condUseAffectedDebugValue(currSnapshot, affected);
    }
    const proxyCache2 = H.useMemo(() => new WeakMap(), []);
    return createProxy(currSnapshot, affected, proxyCache2, targetCache);
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var browser$1 = { exports: {} };
  var ms$1;
  var hasRequiredMs;
  function requireMs() {
    if (hasRequiredMs) return ms$1;
    hasRequiredMs = 1;
    var s2 = 1e3;
    var m2 = s2 * 60;
    var h2 = m2 * 60;
    var d2 = h2 * 24;
    var w = d2 * 7;
    var y = d2 * 365.25;
    ms$1 = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match2) {
        return;
      }
      var n2 = parseFloat(match2[1]);
      var type = (match2[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y;
        case "weeks":
        case "week":
        case "w":
          return n2 * w;
        case "days":
        case "day":
        case "d":
          return n2 * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return Math.round(ms2 / d2) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms2 / h2) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms2 / m2) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms2 / s2) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return plural(ms2, msAbs, d2, "day");
      }
      if (msAbs >= h2) {
        return plural(ms2, msAbs, h2, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms2, msAbs, m2, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms2, msAbs, s2, "second");
      }
      return ms2 + " ms";
    }
    function plural(ms2, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms2 / n2) + " " + name + (isPlural ? "s" : "");
    }
    return ms$1;
  }
  var common$1;
  var hasRequiredCommon$1;
  function requireCommon$1() {
    if (hasRequiredCommon$1) return common$1;
    hasRequiredCommon$1 = 1;
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = requireMs();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i2);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number( new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format) => {
            if (match2 === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match2 = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match2;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter2) {
        const newDebug = createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    common$1 = setup;
    return common$1;
  }
  var hasRequiredBrowser$1;
  function requireBrowser$1() {
    if (hasRequiredBrowser$1) return browser$1.exports;
    hasRequiredBrowser$1 = 1;
    (function(module, exports) {
      var define_process_env_default = {};
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        let m2;
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) ||

typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 ||
typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c2 = "color: " + this.color;
        args.splice(1, 0, c2, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match2) => {
          if (match2 === "%%") {
            return;
          }
          index++;
          if (match2 === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c2);
      }
      exports.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r2;
        try {
          r2 = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
        } catch (error) {
        }
        if (!r2 && typeof process !== "undefined" && "env" in process) {
          r2 = define_process_env_default.DEBUG;
        }
        return r2;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module.exports = requireCommon$1()(exports);
      const { formatters } = module.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    })(browser$1, browser$1.exports);
    return browser$1.exports;
  }
  var browserExports = requireBrowser$1();
  const debugFactory = getDefaultExportFromCjs(browserExports);
  const APP_NAME = "Bilibili-Gate";
  const APP_NAMESPACE = "bilibili-gate";
  const APP_KEY_PREFIX = "bilibili_gate";
  const APP_SHORT_PREFIX = "bili-gate";
  const baseDebug = debugFactory(APP_NAMESPACE);
  const HOST_API = "https://api.bilibili.com";
  const HOST_APP = "https://app.bilibili.com";
  const TVKeyInfo = {
    appkey: "4409e2ce8ffd12b8",
    appsec: "59b43e04ad6965f34319062b478f83dd"
  };
  const APP_CLS_ROOT = `${APP_NAMESPACE}-root`;
  const APP_CLS_GRID = `${APP_NAMESPACE}-video-grid`;
  const APP_CLS_CARD = `${APP_NAMESPACE}-video-card`;
  const APP_CLS_CARD_ACTIVE = `${APP_NAMESPACE}-video-card-active`;
  const APP_CLS_CARD_COVER = `${APP_NAMESPACE}-video-card-cover`;
  const APP_CLS_TAB_BAR = `${APP_NAMESPACE}-tab-bar`;
  const APP_CLS_CARD_RECOMMEND_REASON = `${APP_NAMESPACE}-video-card__recommend-reason`;
  const REQUEST_FAIL_MSG = "请求失败, 请重试 !!!";
  const OPERATION_FAIL_MSG = "操作失败, 请重试 !!!";
  const TLD = "bilibili.com";
  var BiliDomain = ((BiliDomain2) => {
    BiliDomain2[BiliDomain2["Tld"] = TLD] = "Tld";
    BiliDomain2["Main"] = `www.${TLD}`;
    BiliDomain2["Space"] = `space.${TLD}`;
    BiliDomain2["Search"] = `search.${TLD}`;
    return BiliDomain2;
  })(BiliDomain || {});
  const {
    hostname,
    pathname
  } = location;
  hostname === BiliDomain.Tld || hostname.endsWith(`.${BiliDomain.Tld}`);
  const IN_BILIBILI_MAIN = [BiliDomain.Tld, BiliDomain.Main].includes(hostname);
  const IN_BILIBILI_SPACE_PAGE = hostname === BiliDomain.Space;
  const IN_BILIBILI_SEARCH_PAGE = hostname === BiliDomain.Search;
  const IN_BILIBILI_HOMEPAGE = IN_BILIBILI_MAIN && (pathname === "/" || pathname === "/index.html");
  function logFactory(logFn) {
    return function appLog2(...args) {
      const [message2, ...rest] = args;
      const label = `%c${APP_NAME}%c`;
      const labelFormats = ["padding: 2px 4px; border-radius: 4px; color: #fff; background: #01847f; font-weight: bold;", ""];
      if (typeof message2 === "string") {
        return logFn(`${label} ${message2}`, ...labelFormats, ...rest);
      } else {
        return logFn(`${label}`, ...labelFormats, message2, ...rest);
      }
    };
  }
  const appWarn = logFactory(console.warn);
  const appError = logFactory(console.error);
  var ETab = ((ETab2) => {
    ETab2["AppRecommend"] = "app-recommend";
    ETab2["PcRecommend"] = "pc-recommend";
    ETab2["KeepFollowOnly"] = "keep-follow-only";
    ETab2["DynamicFeed"] = "dynamic-feed";
    ETab2["Watchlater"] = "watchlater";
    ETab2["Fav"] = "fav";
    ETab2["Hot"] = "hot";
    ETab2["Live"] = "live";
    ETab2["SpaceUpload"] = "space-upload";
    return ETab2;
  })(ETab || {});
  var EHotSubTab = ((EHotSubTab2) => {
    EHotSubTab2["PopularGeneral"] = "popular-general";
    EHotSubTab2["PopularWeekly"] = "popular-weekly";
    EHotSubTab2["Rank"] = "ranking";
    return EHotSubTab2;
  })(EHotSubTab || {});
  const ALL_TAB_KEYS = Object.values(ETab);
  const NONE_CONFIGURABLE_TAB_KEYS = [
    "space-upload"
];
  const CONFIGURABLE_TAB_KEYS = difference(ALL_TAB_KEYS, NONE_CONFIGURABLE_TAB_KEYS);
  var jsxRuntime = { exports: {} };
  var reactJsxRuntime_production_min = {};
  /**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactJsxRuntime_production_min;
  function requireReactJsxRuntime_production_min() {
    if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
    hasRequiredReactJsxRuntime_production_min = 1;
    var f2 = H, k = Symbol.for("react.element"), l2 = Symbol.for("react.fragment"), m2 = Object.prototype.hasOwnProperty, n2 = f2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p2 = { key: true, ref: true, __self: true, __source: true };
    function q(c2, a2, g2) {
      var b, d2 = {}, e2 = null, h2 = null;
      void 0 !== g2 && (e2 = "" + g2);
      void 0 !== a2.key && (e2 = "" + a2.key);
      void 0 !== a2.ref && (h2 = a2.ref);
      for (b in a2) m2.call(a2, b) && !p2.hasOwnProperty(b) && (d2[b] = a2[b]);
      if (c2 && c2.defaultProps) for (b in a2 = c2.defaultProps, a2) void 0 === d2[b] && (d2[b] = a2[b]);
      return { $$typeof: k, type: c2, key: e2, ref: h2, props: d2, _owner: n2.current };
    }
    reactJsxRuntime_production_min.Fragment = l2;
    reactJsxRuntime_production_min.jsx = q;
    reactJsxRuntime_production_min.jsxs = q;
    return reactJsxRuntime_production_min;
  }
  var hasRequiredJsxRuntime;
  function requireJsxRuntime() {
    if (hasRequiredJsxRuntime) return jsxRuntime.exports;
    hasRequiredJsxRuntime = 1;
    {
      jsxRuntime.exports = requireReactJsxRuntime_production_min();
    }
    return jsxRuntime.exports;
  }
  var jsxRuntimeExports = requireJsxRuntime();
  function sheetForTag(tag) {
    if (tag.sheet) {
      return tag.sheet;
    }
    for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
      if (document.styleSheets[i2].ownerNode === tag) {
        return document.styleSheets[i2];
      }
    }
    return void 0;
  }
  function createStyleElement(options) {
    var tag = document.createElement("style");
    tag.setAttribute("data-emotion", options.key);
    if (options.nonce !== void 0) {
      tag.setAttribute("nonce", options.nonce);
    }
    tag.appendChild(document.createTextNode(""));
    tag.setAttribute("data-s", "");
    return tag;
  }
  var StyleSheet = function() {
    function StyleSheet2(options) {
      var _this = this;
      this._insertTag = function(tag) {
        var before;
        if (_this.tags.length === 0) {
          if (_this.insertionPoint) {
            before = _this.insertionPoint.nextSibling;
          } else if (_this.prepend) {
            before = _this.container.firstChild;
          } else {
            before = _this.before;
          }
        } else {
          before = _this.tags[_this.tags.length - 1].nextSibling;
        }
        _this.container.insertBefore(tag, before);
        _this.tags.push(tag);
      };
      this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
      this.tags = [];
      this.ctr = 0;
      this.nonce = options.nonce;
      this.key = options.key;
      this.container = options.container;
      this.prepend = options.prepend;
      this.insertionPoint = options.insertionPoint;
      this.before = null;
    }
    var _proto = StyleSheet2.prototype;
    _proto.hydrate = function hydrate(nodes) {
      nodes.forEach(this._insertTag);
    };
    _proto.insert = function insert(rule) {
      if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
        this._insertTag(createStyleElement(this));
      }
      var tag = this.tags[this.tags.length - 1];
      if (this.isSpeedy) {
        var sheet = sheetForTag(tag);
        try {
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (e2) {
        }
      } else {
        tag.appendChild(document.createTextNode(rule));
      }
      this.ctr++;
    };
    _proto.flush = function flush() {
      this.tags.forEach(function(tag) {
        var _tag$parentNode;
        return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
      });
      this.tags = [];
      this.ctr = 0;
    };
    return StyleSheet2;
  }();
  var MS = "-ms-";
  var MOZ = "-moz-";
  var WEBKIT = "-webkit-";
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var KEYFRAMES = "@keyframes";
  var LAYER = "@layer";
  var abs = Math.abs;
  var from = String.fromCharCode;
  var assign = Object.assign;
  function hash(value, length2) {
    return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
  }
  function trim(value) {
    return value.trim();
  }
  function match(value, pattern) {
    return (value = pattern.exec(value)) ? value[0] : value;
  }
  function replace(value, pattern, replacement) {
    return value.replace(pattern, replacement);
  }
  function indexof(value, search) {
    return value.indexOf(search);
  }
  function charat(value, index) {
    return value.charCodeAt(index) | 0;
  }
  function substr(value, begin, end) {
    return value.slice(begin, end);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array) {
    return array.push(value), value;
  }
  function combine(array, callback) {
    return array.map(callback).join("");
  }
  var line = 1;
  var column = 1;
  var length = 0;
  var position = 0;
  var character = 0;
  var characters = "";
  function node(value, root2, parent, type, props, children, length2) {
    return { value, root: root2, parent, type, props, children, line, column, length: length2, return: "" };
  }
  function copy(root2, props) {
    return assign(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
  }
  function char() {
    return character;
  }
  function prev() {
    character = position > 0 ? charat(characters, --position) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position < length ? charat(characters, position++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek() {
    return charat(characters, position);
  }
  function caret() {
    return position;
  }
  function slice(begin, end) {
    return substr(characters, begin, end);
  }
  function token(type) {
    switch (type) {
case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
case 59:
      case 123:
      case 125:
        return 4;
case 58:
        return 3;
case 34:
      case 39:
      case 40:
      case 91:
        return 2;
case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type) {
    return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
  }
  function whitespace(type) {
    while (character = peek())
      if (character < 33)
        next();
      else
        break;
    return token(type) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index, count) {
    while (--count && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
  }
  function delimiter(type) {
    while (next())
      switch (character) {
case type:
          return position;
case 34:
        case 39:
          if (type !== 34 && type !== 39)
            delimiter(character);
          break;
case 40:
          if (type === 41)
            delimiter(type);
          break;
case 92:
          next();
          break;
      }
    return position;
  }
  function commenter(type, index) {
    while (next())
      if (type + character === 47 + 10)
        break;
      else if (type + character === 42 + 42 && peek() === 47)
        break;
    return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
  }
  function identifier(index) {
    while (!token(peek()))
      next();
    return slice(index, position);
  }
  function compile(value) {
    return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
    var index = 0;
    var offset = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type = "";
    var props = rules;
    var children = rulesets;
    var reference = rule;
    var characters2 = type;
    while (scanning)
      switch (previous = character2, character2 = next()) {
case 40:
          if (previous != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
              ampersand = -1;
            break;
          }
case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace(previous);
          break;
case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(comment(commenter(next(), caret()), root2, parent), declarations);
              break;
            default:
              characters2 += "/";
          }
          break;
case 123 * variable:
          points[index++] = strlen(characters2) * ampersand;
case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
case 0:
            case 125:
              scanning = 0;
case 59 + offset:
              if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
              if (property > 0 && strlen(characters2) - length2)
                append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
              break;
case 59:
              characters2 += ";";
default:
              append(reference = ruleset(characters2, root2, parent, index, offset, rules, points, type, props = [], children = [], length2), rulesets);
              if (character2 === 123)
                if (offset === 0)
                  parse(characters2, root2, reference, reference, props, rulesets, length2, points, children);
                else
                  switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                      break;
                    default:
                      parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                  }
          }
          index = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
          break;
case 58:
          length2 = 1 + strlen(characters2), property = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
case 38:
              ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
              break;
case 44:
              points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
case 64:
              if (peek() === 45)
                characters2 += delimit(next());
              atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
              break;
case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root2, parent, index, offset, rules, points, type, props, children, length2) {
    var post = offset - 1;
    var rule = offset === 0 ? rules : [""];
    var size = sizeof(rule);
    for (var i2 = 0, j = 0, k = 0; i2 < index; ++i2)
      for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i2])), z = value; x < size; ++x)
        if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
          props[k++] = z;
    return node(value, root2, parent, offset === 0 ? RULESET : type, props, children, length2);
  }
  function comment(value, root2, parent) {
    return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
  }
  function declaration(value, root2, parent, length2) {
    return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
  }
  function serialize(children, callback) {
    var output = "";
    var length2 = sizeof(children);
    for (var i2 = 0; i2 < length2; i2++)
      output += callback(children[i2], i2, children, callback) || "";
    return output;
  }
  function stringify(element, index, children, callback) {
    switch (element.type) {
      case LAYER:
        if (element.children.length) break;
      case IMPORT:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize(element.children, callback) + "}";
      case RULESET:
        element.value = element.props.join(",");
    }
    return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
  }
  function middleware(collection) {
    var length2 = sizeof(collection);
    return function(element, index, children, callback) {
      var output = "";
      for (var i2 = 0; i2 < length2; i2++)
        output += collection[i2](element, index, children, callback) || "";
      return output;
    };
  }
  function rulesheet(callback) {
    return function(element) {
      if (!element.root) {
        if (element = element.return)
          callback(element);
      }
    };
  }
  function memoize(fn) {
    var cache2 = Object.create(null);
    return function(arg) {
      if (cache2[arg] === void 0) cache2[arg] = fn(arg);
      return cache2[arg];
    };
  }
  var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
    var previous = 0;
    var character2 = 0;
    while (true) {
      previous = character2;
      character2 = peek();
      if (previous === 38 && character2 === 12) {
        points[index] = 1;
      }
      if (token(character2)) {
        break;
      }
      next();
    }
    return slice(begin, position);
  };
  var toRules = function toRules2(parsed2, points) {
    var index = -1;
    var character2 = 44;
    do {
      switch (token(character2)) {
        case 0:
          if (character2 === 38 && peek() === 12) {
            points[index] = 1;
          }
          parsed2[index] += identifierWithPointTracking(position - 1, points, index);
          break;
        case 2:
          parsed2[index] += delimit(character2);
          break;
        case 4:
          if (character2 === 44) {
            parsed2[++index] = peek() === 58 ? "&\f" : "";
            points[index] = parsed2[index].length;
            break;
          }
default:
          parsed2[index] += from(character2);
      }
    } while (character2 = next());
    return parsed2;
  };
  var getRules = function getRules2(value, points) {
    return dealloc(toRules(alloc(value), points));
  };
  var fixedElements = new WeakMap();
  var compat = function compat2(element) {
    if (element.type !== "rule" || !element.parent ||

element.length < 1) {
      return;
    }
    var value = element.value;
    var parent = element.parent;
    var isImplicitRule = element.column === parent.column && element.line === parent.line;
    while (parent.type !== "rule") {
      parent = parent.parent;
      if (!parent) return;
    }
    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
      return;
    }
    if (isImplicitRule) {
      return;
    }
    fixedElements.set(element, true);
    var points = [];
    var rules = getRules(value, points);
    var parentRules = parent.props;
    for (var i2 = 0, k = 0; i2 < rules.length; i2++) {
      for (var j = 0; j < parentRules.length; j++, k++) {
        element.props[k] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i2];
      }
    }
  };
  var removeLabel = function removeLabel2(element) {
    if (element.type === "decl") {
      var value = element.value;
      if (
value.charCodeAt(0) === 108 &&
value.charCodeAt(2) === 98
      ) {
        element["return"] = "";
        element.value = "";
      }
    }
  };
  function prefix(value, length2) {
    switch (hash(value, length2)) {
case 5103:
        return WEBKIT + "print-" + value + value;
case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return WEBKIT + value + value;
case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return WEBKIT + value + MOZ + value + MS + value + value;
case 6828:
      case 4268:
        return WEBKIT + value + MS + value + value;
case 6165:
        return WEBKIT + value + MS + "flex-" + value + value;
case 5187:
        return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
case 5443:
        return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
case 4675:
        return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
case 5548:
        return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
case 5292:
        return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
case 6060:
        return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
case 4554:
        return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
case 6187:
        return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
case 5495:
      case 3959:
        return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
case 4968:
        return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
case 4095:
      case 3583:
      case 4068:
      case 2532:
        return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
case 109:
            if (charat(value, length2 + 4) !== 45) break;
case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
case 115:
            return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
        break;
case 4949:
        if (charat(value, length2 + 1) !== 115) break;
case 6444:
        switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
case 107:
            return replace(value, ":", ":" + WEBKIT) + value;
case 101:
            return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        }
        break;
case 5936:
        switch (charat(value, length2 + 11)) {
case 114:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
case 108:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
case 45:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
        }
        return WEBKIT + value + MS + value + value;
    }
    return value;
  }
  var prefixer = function prefixer2(element, index, children, callback) {
    if (element.length > -1) {
      if (!element["return"]) switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy(element, {
            value: replace(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length) return combine(element.props, function(value) {
            switch (match(value, /(::plac\w+|:read-\w+)/)) {
case ":read-only":
              case ":read-write":
                return serialize([copy(element, {
                  props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                })], callback);
case "::placeholder":
                return serialize([copy(element, {
                  props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                }), copy(element, {
                  props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                }), copy(element, {
                  props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                })], callback);
            }
            return "";
          });
      }
    }
  };
  var defaultStylisPlugins = [prefixer];
  var createCache = function createCache2(options) {
    var key = options.key;
    if (key === "css") {
      var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(ssrStyles, function(node2) {
        var dataEmotionAttribute = node2.getAttribute("data-emotion");
        if (dataEmotionAttribute.indexOf(" ") === -1) {
          return;
        }
        document.head.appendChild(node2);
        node2.setAttribute("data-s", "");
      });
    }
    var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
    var inserted = {};
    var container;
    var nodesToHydrate = [];
    {
      container = options.container || document.head;
      Array.prototype.forEach.call(

document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
        function(node2) {
          var attrib = node2.getAttribute("data-emotion").split(" ");
          for (var i2 = 1; i2 < attrib.length; i2++) {
            inserted[attrib[i2]] = true;
          }
          nodesToHydrate.push(node2);
        }
      );
    }
    var _insert;
    var omnipresentPlugins = [compat, removeLabel];
    {
      var currentSheet;
      var finalizingPlugins = [stringify, rulesheet(function(rule) {
        currentSheet.insert(rule);
      })];
      var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
      var stylis = function stylis2(styles) {
        return serialize(compile(styles), serializer);
      };
      _insert = function insert(selector, serialized, sheet, shouldCache) {
        currentSheet = sheet;
        stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
        if (shouldCache) {
          cache2.inserted[serialized.name] = true;
        }
      };
    }
    var cache2 = {
      key,
      sheet: new StyleSheet({
        key,
        container,
        nonce: options.nonce,
        speedy: options.speedy,
        prepend: options.prepend,
        insertionPoint: options.insertionPoint
      }),
      nonce: options.nonce,
      inserted,
      registered: {},
      insert: _insert
    };
    cache2.sheet.hydrate(nodesToHydrate);
    return cache2;
  };
  var reactIs = { exports: {} };
  var reactIs_production_min = {};
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hasRequiredReactIs_production_min;
  function requireReactIs_production_min() {
    if (hasRequiredReactIs_production_min) return reactIs_production_min;
    hasRequiredReactIs_production_min = 1;
    var b = "function" === typeof Symbol && Symbol.for, c2 = b ? Symbol.for("react.element") : 60103, d2 = b ? Symbol.for("react.portal") : 60106, e2 = b ? Symbol.for("react.fragment") : 60107, f2 = b ? Symbol.for("react.strict_mode") : 60108, g2 = b ? Symbol.for("react.profiler") : 60114, h2 = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l2 = b ? Symbol.for("react.async_mode") : 60111, m2 = b ? Symbol.for("react.concurrent_mode") : 60111, n2 = b ? Symbol.for("react.forward_ref") : 60112, p2 = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r2 = b ? Symbol.for("react.memo") : 60115, t2 = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
    function z(a2) {
      if ("object" === typeof a2 && null !== a2) {
        var u2 = a2.$$typeof;
        switch (u2) {
          case c2:
            switch (a2 = a2.type, a2) {
              case l2:
              case m2:
              case e2:
              case g2:
              case f2:
              case p2:
                return a2;
              default:
                switch (a2 = a2 && a2.$$typeof, a2) {
                  case k:
                  case n2:
                  case t2:
                  case r2:
                  case h2:
                    return a2;
                  default:
                    return u2;
                }
            }
          case d2:
            return u2;
        }
      }
    }
    function A(a2) {
      return z(a2) === m2;
    }
    reactIs_production_min.AsyncMode = l2;
    reactIs_production_min.ConcurrentMode = m2;
    reactIs_production_min.ContextConsumer = k;
    reactIs_production_min.ContextProvider = h2;
    reactIs_production_min.Element = c2;
    reactIs_production_min.ForwardRef = n2;
    reactIs_production_min.Fragment = e2;
    reactIs_production_min.Lazy = t2;
    reactIs_production_min.Memo = r2;
    reactIs_production_min.Portal = d2;
    reactIs_production_min.Profiler = g2;
    reactIs_production_min.StrictMode = f2;
    reactIs_production_min.Suspense = p2;
    reactIs_production_min.isAsyncMode = function(a2) {
      return A(a2) || z(a2) === l2;
    };
    reactIs_production_min.isConcurrentMode = A;
    reactIs_production_min.isContextConsumer = function(a2) {
      return z(a2) === k;
    };
    reactIs_production_min.isContextProvider = function(a2) {
      return z(a2) === h2;
    };
    reactIs_production_min.isElement = function(a2) {
      return "object" === typeof a2 && null !== a2 && a2.$$typeof === c2;
    };
    reactIs_production_min.isForwardRef = function(a2) {
      return z(a2) === n2;
    };
    reactIs_production_min.isFragment = function(a2) {
      return z(a2) === e2;
    };
    reactIs_production_min.isLazy = function(a2) {
      return z(a2) === t2;
    };
    reactIs_production_min.isMemo = function(a2) {
      return z(a2) === r2;
    };
    reactIs_production_min.isPortal = function(a2) {
      return z(a2) === d2;
    };
    reactIs_production_min.isProfiler = function(a2) {
      return z(a2) === g2;
    };
    reactIs_production_min.isStrictMode = function(a2) {
      return z(a2) === f2;
    };
    reactIs_production_min.isSuspense = function(a2) {
      return z(a2) === p2;
    };
    reactIs_production_min.isValidElementType = function(a2) {
      return "string" === typeof a2 || "function" === typeof a2 || a2 === e2 || a2 === m2 || a2 === g2 || a2 === f2 || a2 === p2 || a2 === q || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t2 || a2.$$typeof === r2 || a2.$$typeof === h2 || a2.$$typeof === k || a2.$$typeof === n2 || a2.$$typeof === w || a2.$$typeof === x || a2.$$typeof === y || a2.$$typeof === v);
    };
    reactIs_production_min.typeOf = z;
    return reactIs_production_min;
  }
  var hasRequiredReactIs;
  function requireReactIs() {
    if (hasRequiredReactIs) return reactIs.exports;
    hasRequiredReactIs = 1;
    {
      reactIs.exports = requireReactIs_production_min();
    }
    return reactIs.exports;
  }
  var hoistNonReactStatics_cjs;
  var hasRequiredHoistNonReactStatics_cjs;
  function requireHoistNonReactStatics_cjs() {
    if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs;
    hasRequiredHoistNonReactStatics_cjs = 1;
    var reactIs2 = requireReactIs();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs2.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs2.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs2.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty2 = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i2 = 0; i2 < keys.length; ++i2) {
          var key = keys[i2];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty2(targetComponent, key, descriptor);
            } catch (e2) {
            }
          }
        }
      }
      return targetComponent;
    }
    hoistNonReactStatics_cjs = hoistNonReactStatics;
    return hoistNonReactStatics_cjs;
  }
  requireHoistNonReactStatics_cjs();
  var isBrowser$1 = true;
  function getRegisteredStyles(registered, registeredStyles, classNames) {
    var rawClassName = "";
    classNames.split(" ").forEach(function(className) {
      if (registered[className] !== void 0) {
        registeredStyles.push(registered[className] + ";");
      } else if (className) {
        rawClassName += className + " ";
      }
    });
    return rawClassName;
  }
  var registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
    var className = cache2.key + "-" + serialized.name;
    if (




(isStringTag === false ||



isBrowser$1 === false) && cache2.registered[className] === void 0
    ) {
      cache2.registered[className] = serialized.styles;
    }
  };
  var insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
    registerStyles(cache2, serialized, isStringTag);
    var className = cache2.key + "-" + serialized.name;
    if (cache2.inserted[serialized.name] === void 0) {
      var current = serialized;
      do {
        cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
        current = current.next;
      } while (current !== void 0);
    }
  };
  function murmur2(str) {
    var h2 = 0;
    var k, i2 = 0, len = str.length;
    for (; len >= 4; ++i2, len -= 4) {
      k = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
      k =
(k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
      k ^=
k >>> 24;
      h2 =
(k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^
(h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
      case 2:
        h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
      case 1:
        h2 ^= str.charCodeAt(i2) & 255;
        h2 =
(h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    h2 ^= h2 >>> 13;
    h2 =
(h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
  }
  var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };
  var hyphenateRegex = /[A-Z]|^ms/g;
  var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
  var isCustomProperty = function isCustomProperty2(property) {
    return property.charCodeAt(1) === 45;
  };
  var isProcessableValue = function isProcessableValue2(value) {
    return value != null && typeof value !== "boolean";
  };
  var processStyleName = memoize(function(styleName) {
    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
  });
  var processStyleValue = function processStyleValue2(key, value) {
    switch (key) {
      case "animation":
      case "animationName": {
        if (typeof value === "string") {
          return value.replace(animationRegex, function(match2, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
    }
    if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
      return value + "px";
    }
    return value;
  };
  function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) {
      return "";
    }
    var componentSelector = interpolation;
    if (componentSelector.__emotion_styles !== void 0) {
      return componentSelector;
    }
    switch (typeof interpolation) {
      case "boolean": {
        return "";
      }
      case "object": {
        var keyframes = interpolation;
        if (keyframes.anim === 1) {
          cursor = {
            name: keyframes.name,
            styles: keyframes.styles,
            next: cursor
          };
          return keyframes.name;
        }
        var serializedStyles = interpolation;
        if (serializedStyles.styles !== void 0) {
          var next2 = serializedStyles.next;
          if (next2 !== void 0) {
            while (next2 !== void 0) {
              cursor = {
                name: next2.name,
                styles: next2.styles,
                next: cursor
              };
              next2 = next2.next;
            }
          }
          var styles = serializedStyles.styles + ";";
          return styles;
        }
        return createStringFromObject(mergedProps, registered, interpolation);
      }
      case "function": {
        if (mergedProps !== void 0) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        }
        break;
      }
    }
    var asString = interpolation;
    if (registered == null) {
      return asString;
    }
    var cached = registered[asString];
    return cached !== void 0 ? cached : asString;
  }
  function createStringFromObject(mergedProps, registered, obj) {
    var string = "";
    if (Array.isArray(obj)) {
      for (var i2 = 0; i2 < obj.length; i2++) {
        string += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
      }
    } else {
      for (var key in obj) {
        var value = obj[key];
        if (typeof value !== "object") {
          var asString = value;
          if (registered != null && registered[asString] !== void 0) {
            string += key + "{" + registered[asString] + "}";
          } else if (isProcessableValue(asString)) {
            string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
          }
        } else {
          if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
            for (var _i = 0; _i < value.length; _i++) {
              if (isProcessableValue(value[_i])) {
                string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
              }
            }
          } else {
            var interpolated = handleInterpolation(mergedProps, registered, value);
            switch (key) {
              case "animation":
              case "animationName": {
                string += processStyleName(key) + ":" + interpolated + ";";
                break;
              }
              default: {
                string += key + "{" + interpolated + "}";
              }
            }
          }
        }
      }
    }
    return string;
  }
  var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
  var cursor;
  function serializeStyles(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
      return args[0];
    }
    var stringMode = true;
    var styles = "";
    cursor = void 0;
    var strings = args[0];
    if (strings == null || strings.raw === void 0) {
      stringMode = false;
      styles += handleInterpolation(mergedProps, registered, strings);
    } else {
      var asTemplateStringsArr = strings;
      styles += asTemplateStringsArr[0];
    }
    for (var i2 = 1; i2 < args.length; i2++) {
      styles += handleInterpolation(mergedProps, registered, args[i2]);
      if (stringMode) {
        var templateStringsArr = strings;
        styles += templateStringsArr[i2];
      }
    }
    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match2;
    while ((match2 = labelPattern.exec(styles)) !== null) {
      identifierName += "-" + match2[1];
    }
    var name = murmur2(styles) + identifierName;
    return {
      name,
      styles,
      next: cursor
    };
  }
  var syncFallback = function syncFallback2(create) {
    return create();
  };
  var useInsertionEffect = H__namespace["useInsertionEffect"] ? H__namespace["useInsertionEffect"] : false;
  var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
  var useInsertionEffectWithLayoutFallback = useInsertionEffect || H__namespace.useLayoutEffect;
  var EmotionCacheContext = H__namespace.createContext(





typeof HTMLElement !== "undefined" ? createCache({
      key: "css"
    }) : null
  );
  var CacheProvider = EmotionCacheContext.Provider;
  var withEmotionCache = function withEmotionCache2(func) {
    return H.forwardRef(function(props, ref) {
      var cache2 = H.useContext(EmotionCacheContext);
      return func(props, cache2, ref);
    });
  };
  var ThemeContext = H__namespace.createContext({});
  var hasOwn = {}.hasOwnProperty;
  var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
  var createEmotionProps = function createEmotionProps2(type, props) {
    var newProps = {};
    for (var _key in props) {
      if (hasOwn.call(props, _key)) {
        newProps[_key] = props[_key];
      }
    }
    newProps[typePropName] = type;
    return newProps;
  };
  var Insertion = function Insertion2(_ref5) {
    var cache2 = _ref5.cache, serialized = _ref5.serialized, isStringTag = _ref5.isStringTag;
    registerStyles(cache2, serialized, isStringTag);
    useInsertionEffectAlwaysWithSyncFallback(function() {
      return insertStyles(cache2, serialized, isStringTag);
    });
    return null;
  };
  var Emotion = withEmotionCache(function(props, cache2, ref) {
    var cssProp = props.css;
    if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
      cssProp = cache2.registered[cssProp];
    }
    var WrappedComponent = props[typePropName];
    var registeredStyles = [cssProp];
    var className = "";
    if (typeof props.className === "string") {
      className = getRegisteredStyles(cache2.registered, registeredStyles, props.className);
    } else if (props.className != null) {
      className = props.className + " ";
    }
    var serialized = serializeStyles(registeredStyles, void 0, H__namespace.useContext(ThemeContext));
    className += cache2.key + "-" + serialized.name;
    var newProps = {};
    for (var _key2 in props) {
      if (hasOwn.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && true) {
        newProps[_key2] = props[_key2];
      }
    }
    newProps.className = className;
    if (ref) {
      newProps.ref = ref;
    }
    return H__namespace.createElement(H__namespace.Fragment, null, H__namespace.createElement(Insertion, {
      cache: cache2,
      serialized,
      isStringTag: typeof WrappedComponent === "string"
    }), H__namespace.createElement(WrappedComponent, newProps));
  });
  var Emotion$1 = Emotion;
  var Fragment = jsxRuntimeExports.Fragment;
  var jsx$1 = function jsx(type, props, key) {
    if (!hasOwn.call(props, "css")) {
      return jsxRuntimeExports.jsx(type, props, key);
    }
    return jsxRuntimeExports.jsx(Emotion$1, createEmotionProps(type, props), key);
  };
  var jsxs = function jsxs2(type, props, key) {
    if (!hasOwn.call(props, "css")) {
      return jsxRuntimeExports.jsxs(type, props, key);
    }
    return jsxRuntimeExports.jsxs(Emotion$1, createEmotionProps(type, props), key);
  };
  const anyMap = new WeakMap();
  const eventsMap = new WeakMap();
  const producersMap = new WeakMap();
  var define_globalThis_process_env_default = {};
  const anyProducer = Symbol("anyProducer");
  const resolvedPromise = Promise.resolve();
  const listenerAdded = Symbol("listenerAdded");
  const listenerRemoved = Symbol("listenerRemoved");
  let canEmitMetaEvents = false;
  let isGlobalDebugEnabled = false;
  const isEventKeyType = (key) => typeof key === "string" || typeof key === "symbol" || typeof key === "number";
  function assertEventName(eventName) {
    if (!isEventKeyType(eventName)) {
      throw new TypeError("`eventName` must be a string, symbol, or number");
    }
  }
  function assertListener(listener) {
    if (typeof listener !== "function") {
      throw new TypeError("listener must be a function");
    }
  }
  function getListeners(instance, eventName) {
    const events2 = eventsMap.get(instance);
    if (!events2.has(eventName)) {
      return;
    }
    return events2.get(eventName);
  }
  function getEventProducers(instance, eventName) {
    const key = isEventKeyType(eventName) ? eventName : anyProducer;
    const producers = producersMap.get(instance);
    if (!producers.has(key)) {
      return;
    }
    return producers.get(key);
  }
  function enqueueProducers(instance, eventName, eventData) {
    const producers = producersMap.get(instance);
    if (producers.has(eventName)) {
      for (const producer of producers.get(eventName)) {
        producer.enqueue(eventData);
      }
    }
    if (producers.has(anyProducer)) {
      const item = Promise.all([eventName, eventData]);
      for (const producer of producers.get(anyProducer)) {
        producer.enqueue(item);
      }
    }
  }
  function iterator(instance, eventNames) {
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    let isFinished = false;
    let flush = () => {
    };
    let queue = [];
    const producer = {
      enqueue(item) {
        queue.push(item);
        flush();
      },
      finish() {
        isFinished = true;
        flush();
      }
    };
    for (const eventName of eventNames) {
      let set2 = getEventProducers(instance, eventName);
      if (!set2) {
        set2 = new Set();
        const producers = producersMap.get(instance);
        producers.set(eventName, set2);
      }
      set2.add(producer);
    }
    return {
      async next() {
        if (!queue) {
          return { done: true };
        }
        if (queue.length === 0) {
          if (isFinished) {
            queue = void 0;
            return this.next();
          }
          await new Promise((resolve) => {
            flush = resolve;
          });
          return this.next();
        }
        return {
          done: false,
          value: await queue.shift()
        };
      },
      async return(value) {
        queue = void 0;
        for (const eventName of eventNames) {
          const set2 = getEventProducers(instance, eventName);
          if (set2) {
            set2.delete(producer);
            if (set2.size === 0) {
              const producers = producersMap.get(instance);
              producers.delete(eventName);
            }
          }
        }
        flush();
        return arguments.length > 0 ? { done: true, value: await value } : { done: true };
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  function defaultMethodNamesOrAssert(methodNames) {
    if (methodNames === void 0) {
      return allEmitteryMethods;
    }
    if (!Array.isArray(methodNames)) {
      throw new TypeError("`methodNames` must be an array of strings");
    }
    for (const methodName of methodNames) {
      if (!allEmitteryMethods.includes(methodName)) {
        if (typeof methodName !== "string") {
          throw new TypeError("`methodNames` element must be a string");
        }
        throw new Error(`${methodName} is not Emittery method`);
      }
    }
    return methodNames;
  }
  const isMetaEvent = (eventName) => eventName === listenerAdded || eventName === listenerRemoved;
  function emitMetaEvent(emitter2, eventName, eventData) {
    if (!isMetaEvent(eventName)) {
      return;
    }
    try {
      canEmitMetaEvents = true;
      emitter2.emit(eventName, eventData);
    } finally {
      canEmitMetaEvents = false;
    }
  }
  class Emittery {
    static mixin(emitteryPropertyName, methodNames) {
      methodNames = defaultMethodNamesOrAssert(methodNames);
      return (target) => {
        if (typeof target !== "function") {
          throw new TypeError("`target` must be function");
        }
        for (const methodName of methodNames) {
          if (target.prototype[methodName] !== void 0) {
            throw new Error(`The property \`${methodName}\` already exists on \`target\``);
          }
        }
        function getEmitteryProperty() {
          Object.defineProperty(this, emitteryPropertyName, {
            enumerable: false,
            value: new Emittery()
          });
          return this[emitteryPropertyName];
        }
        Object.defineProperty(target.prototype, emitteryPropertyName, {
          enumerable: false,
          get: getEmitteryProperty
        });
        const emitteryMethodCaller = (methodName) => function(...args) {
          return this[emitteryPropertyName][methodName](...args);
        };
        for (const methodName of methodNames) {
          Object.defineProperty(target.prototype, methodName, {
            enumerable: false,
            value: emitteryMethodCaller(methodName)
          });
        }
        return target;
      };
    }
    static get isDebugEnabled() {
      if (typeof define_globalThis_process_env_default !== "object") {
        return isGlobalDebugEnabled;
      }
      const { env } = globalThis.process ?? { env: {} };
      return env.DEBUG === "emittery" || env.DEBUG === "*" || isGlobalDebugEnabled;
    }
    static set isDebugEnabled(newValue) {
      isGlobalDebugEnabled = newValue;
    }
    constructor(options = {}) {
      anyMap.set(this, new Set());
      eventsMap.set(this, new Map());
      producersMap.set(this, new Map());
      producersMap.get(this).set(anyProducer, new Set());
      this.debug = options.debug ?? {};
      if (this.debug.enabled === void 0) {
        this.debug.enabled = false;
      }
      if (!this.debug.logger) {
        this.debug.logger = (type, debugName, eventName, eventData) => {
          try {
            eventData = JSON.stringify(eventData);
          } catch {
            eventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(",")}`;
          }
          if (typeof eventName === "symbol" || typeof eventName === "number") {
            eventName = eventName.toString();
          }
          const currentTime = new Date();
          const logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;
          console.log(`[${logTime}][emittery:${type}][${debugName}] Event Name: ${eventName}
	data: ${eventData}`);
        };
      }
    }
    logIfDebugEnabled(type, eventName, eventData) {
      if (Emittery.isDebugEnabled || this.debug.enabled) {
        this.debug.logger(type, this.debug.name, eventName, eventData);
      }
    }
    on(eventNames, listener, { signal } = {}) {
      assertListener(listener);
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      for (const eventName of eventNames) {
        assertEventName(eventName);
        let set2 = getListeners(this, eventName);
        if (!set2) {
          set2 = new Set();
          const events2 = eventsMap.get(this);
          events2.set(eventName, set2);
        }
        set2.add(listener);
        this.logIfDebugEnabled("subscribe", eventName, void 0);
        if (!isMetaEvent(eventName)) {
          emitMetaEvent(this, listenerAdded, { eventName, listener });
        }
      }
      const off = () => {
        this.off(eventNames, listener);
        signal?.removeEventListener("abort", off);
      };
      signal?.addEventListener("abort", off, { once: true });
      if (signal?.aborted) {
        off();
      }
      return off;
    }
    off(eventNames, listener) {
      assertListener(listener);
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      for (const eventName of eventNames) {
        assertEventName(eventName);
        const set2 = getListeners(this, eventName);
        if (set2) {
          set2.delete(listener);
          if (set2.size === 0) {
            const events2 = eventsMap.get(this);
            events2.delete(eventName);
          }
        }
        this.logIfDebugEnabled("unsubscribe", eventName, void 0);
        if (!isMetaEvent(eventName)) {
          emitMetaEvent(this, listenerRemoved, { eventName, listener });
        }
      }
    }
    once(eventNames, predicate) {
      if (predicate !== void 0 && typeof predicate !== "function") {
        throw new TypeError("predicate must be a function");
      }
      let off_;
      const promise = new Promise((resolve) => {
        off_ = this.on(eventNames, (data2) => {
          if (predicate && !predicate(data2)) {
            return;
          }
          off_();
          resolve(data2);
        });
      });
      promise.off = off_;
      return promise;
    }
    events(eventNames) {
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      for (const eventName of eventNames) {
        assertEventName(eventName);
      }
      return iterator(this, eventNames);
    }
    async emit(eventName, eventData) {
      assertEventName(eventName);
      if (isMetaEvent(eventName) && !canEmitMetaEvents) {
        throw new TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");
      }
      this.logIfDebugEnabled("emit", eventName, eventData);
      enqueueProducers(this, eventName, eventData);
      const listeners2 = getListeners(this, eventName) ?? new Set();
      const anyListeners = anyMap.get(this);
      const staticListeners = [...listeners2];
      const staticAnyListeners = isMetaEvent(eventName) ? [] : [...anyListeners];
      await resolvedPromise;
      await Promise.all([
        ...staticListeners.map(async (listener) => {
          if (listeners2.has(listener)) {
            return listener(eventData);
          }
        }),
        ...staticAnyListeners.map(async (listener) => {
          if (anyListeners.has(listener)) {
            return listener(eventName, eventData);
          }
        })
      ]);
    }
    async emitSerial(eventName, eventData) {
      assertEventName(eventName);
      if (isMetaEvent(eventName) && !canEmitMetaEvents) {
        throw new TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");
      }
      this.logIfDebugEnabled("emitSerial", eventName, eventData);
      const listeners2 = getListeners(this, eventName) ?? new Set();
      const anyListeners = anyMap.get(this);
      const staticListeners = [...listeners2];
      const staticAnyListeners = [...anyListeners];
      await resolvedPromise;
      for (const listener of staticListeners) {
        if (listeners2.has(listener)) {
          await listener(eventData);
        }
      }
      for (const listener of staticAnyListeners) {
        if (anyListeners.has(listener)) {
          await listener(eventName, eventData);
        }
      }
    }
    onAny(listener, { signal } = {}) {
      assertListener(listener);
      this.logIfDebugEnabled("subscribeAny", void 0, void 0);
      anyMap.get(this).add(listener);
      emitMetaEvent(this, listenerAdded, { listener });
      const offAny = () => {
        this.offAny(listener);
        signal?.removeEventListener("abort", offAny);
      };
      signal?.addEventListener("abort", offAny, { once: true });
      if (signal?.aborted) {
        offAny();
      }
      return offAny;
    }
    anyEvent() {
      return iterator(this);
    }
    offAny(listener) {
      assertListener(listener);
      this.logIfDebugEnabled("unsubscribeAny", void 0, void 0);
      emitMetaEvent(this, listenerRemoved, { listener });
      anyMap.get(this).delete(listener);
    }
    clearListeners(eventNames) {
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      for (const eventName of eventNames) {
        this.logIfDebugEnabled("clear", eventName, void 0);
        if (isEventKeyType(eventName)) {
          const set2 = getListeners(this, eventName);
          if (set2) {
            set2.clear();
          }
          const producers = getEventProducers(this, eventName);
          if (producers) {
            for (const producer of producers) {
              producer.finish();
            }
            producers.clear();
          }
        } else {
          anyMap.get(this).clear();
          for (const [eventName2, listeners2] of eventsMap.get(this).entries()) {
            listeners2.clear();
            eventsMap.get(this).delete(eventName2);
          }
          for (const [eventName2, producers] of producersMap.get(this).entries()) {
            for (const producer of producers) {
              producer.finish();
            }
            producers.clear();
            producersMap.get(this).delete(eventName2);
          }
        }
      }
    }
    listenerCount(eventNames) {
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      let count = 0;
      for (const eventName of eventNames) {
        if (isEventKeyType(eventName)) {
          count += anyMap.get(this).size + (getListeners(this, eventName)?.size ?? 0) + (getEventProducers(this, eventName)?.size ?? 0) + (getEventProducers(this)?.size ?? 0);
          continue;
        }
        if (eventName !== void 0) {
          assertEventName(eventName);
        }
        count += anyMap.get(this).size;
        for (const value of eventsMap.get(this).values()) {
          count += value.size;
        }
        for (const value of producersMap.get(this).values()) {
          count += value.size;
        }
      }
      return count;
    }
    bindMethods(target, methodNames) {
      if (typeof target !== "object" || target === null) {
        throw new TypeError("`target` must be an object");
      }
      methodNames = defaultMethodNamesOrAssert(methodNames);
      for (const methodName of methodNames) {
        if (target[methodName] !== void 0) {
          throw new Error(`The property \`${methodName}\` already exists on \`target\``);
        }
        Object.defineProperty(target, methodName, {
          enumerable: false,
          value: this[methodName].bind(this)
        });
      }
    }
  }
  const allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter((v) => v !== "constructor");
  Object.defineProperty(Emittery, "listenerAdded", {
    value: listenerAdded,
    writable: false,
    enumerable: true,
    configurable: false
  });
  Object.defineProperty(Emittery, "listenerRemoved", {
    value: listenerRemoved,
    writable: false,
    enumerable: true,
    configurable: false
  });
  function minmax(value, min, max) {
    if (value < min) {
      return min;
    } else if (value > max) {
      return max;
    } else {
      return value;
    }
  }
  function unwrapRef(ref) {
    return ref.value;
  }
  var Dispatcher = class _Dispatcher {
    static fromConcurrency(concurrency, label = "") {
      if (!isFinite(concurrency)) throw new Error("concurrency must be finite");
      if (!(concurrency > 0)) throw new Error("concurrency must be greater than 0");
      const executors = new Array(concurrency).fill(0).map(
        (_2, index) => [label, `executors(${concurrency})`, index].map((x) => x && x.toString().trim()).filter(Boolean).join(".")
      );
      return new _Dispatcher(executors);
    }
    executorRefs;
    idleState;
    constructor(executors) {
      if (!executors.length) throw new Error("executors can not be empty");
      this.executorRefs = executors.map((x) => ({ value: x }));
      this.idleState = new WeakMap();
      this.executorRefs.forEach((x) => this.idleState.set(x, true));
    }
    aborted = false;
    abort() {
      this.aborted = true;
      this.pendingResolves = [];
    }
    pendingResolves = [];
    replenish = (executor) => {
      if (this.aborted) return;
      if (!this.pendingResolves.length) return;
      this.pendingResolves.shift()?.();
    };
    async getExecutorRef() {
      const find = () => this.executorRefs.find((x) => this.idleState.get(x));
      let executorRef = find();
      while (!executorRef) {
        const { promise, resolve } = Promise.withResolvers();
        this.pendingResolves.push(resolve);
        await promise;
        executorRef = find();
      }
      this.idleState.set(executorRef, false);
      return executorRef;
    }
    async dispatch(action2) {
      const executorRef = await this.getExecutorRef();
      const executor = unwrapRef(executorRef);
      try {
        return await action2(executor);
      } finally {
        this.idleState.set(executorRef, true);
        setTimeout(() => this.replenish(executorRef));
      }
    }
  };
  async function pmap(arr, fn, concurrency) {
    if (!arr.length) return [];
    concurrency = Math.min(concurrency, arr.length);
    const dispatcher = Dispatcher.fromConcurrency(concurrency, "pmap");
    try {
      return await Promise.all(
        arr.map((item, index) => dispatcher.dispatch(() => fn(item, index, arr)))
      );
    } catch (e2) {
      dispatcher.abort();
      throw e2;
    }
  }
  function pLimit(concurrency) {
    const dispatcher = Dispatcher.fromConcurrency(concurrency, "pLimit");
    return function limit2(fn, ...args) {
      return dispatcher.dispatch(() => fn(...args));
    };
  }
  var limitFunction = createLimitedVersionOfFn;
  function createLimitedVersionOfFn(fn, concurrency) {
    const dispatcher = Dispatcher.fromConcurrency(concurrency, "createLimitedVersionOfFn");
    return function limitedVersionOfFn(...args) {
      return dispatcher.dispatch(() => fn(...args));
    };
  }
  function subscribeKey(proxyObject, key, callback, notifyInSync) {
    let prevValue = proxyObject[key];
    return subscribe$3(
      proxyObject,
      () => {
        const nextValue = proxyObject[key];
        if (!Object.is(prevValue, nextValue)) {
          callback(prevValue = nextValue);
        }
      },
      notifyInSync
    );
  }
  const { proxyStateMap: proxyStateMap$1, snapCache: snapCache$1 } = unstable_getInternalStates();
  const isProxy$1 = (x) => proxyStateMap$1.has(x);
  function proxyMap(entries) {
    const initialData = [];
    let initialIndex = 0;
    const indexMap = new Map();
    const snapMapCache = new WeakMap();
    const registerSnapMap = () => {
      const cache2 = snapCache$1.get(vObject);
      const latestSnap = cache2 == null ? void 0 : cache2[1];
      if (latestSnap && !snapMapCache.has(latestSnap)) {
        const clonedMap = new Map(indexMap);
        snapMapCache.set(latestSnap, clonedMap);
      }
    };
    const getMapForThis = (x) => snapMapCache.get(x) || indexMap;
    if (entries) {
      if (typeof entries[Symbol.iterator] !== "function") {
        throw new TypeError(
          "proxyMap:\n	initial state must be iterable\n		tip: structure should be [[key, value]]"
        );
      }
      for (const [key, value] of entries) {
        indexMap.set(key, initialIndex);
        initialData[initialIndex++] = value;
      }
    }
    const vObject = {
      data: initialData,
      index: initialIndex,
      epoch: 0,
      get size() {
        if (!isProxy$1(this)) {
          registerSnapMap();
        }
        const map = getMapForThis(this);
        return map.size;
      },
      get(key) {
        const map = getMapForThis(this);
        const index = map.get(key);
        if (index === void 0) {
          this.epoch;
          return void 0;
        }
        return this.data[index];
      },
      has(key) {
        const map = getMapForThis(this);
        this.epoch;
        return map.has(key);
      },
      set(key, value) {
        if (!isProxy$1(this)) {
          throw new Error("Cannot perform mutations on a snapshot");
        }
        const index = indexMap.get(key);
        if (index === void 0) {
          indexMap.set(key, this.index);
          this.data[this.index++] = value;
        } else {
          this.data[index] = value;
        }
        this.epoch++;
        return this;
      },
      delete(key) {
        if (!isProxy$1(this)) {
          throw new Error("Cannot perform mutations on a snapshot");
        }
        const index = indexMap.get(key);
        if (index === void 0) {
          return false;
        }
        delete this.data[index];
        indexMap.delete(key);
        this.epoch++;
        return true;
      },
      clear() {
        if (!isProxy$1(this)) {
          throw new Error("Cannot perform mutations on a snapshot");
        }
        this.data.length = 0;
        this.index = 0;
        this.epoch++;
        indexMap.clear();
      },
      forEach(cb) {
        this.epoch;
        const map = getMapForThis(this);
        map.forEach((index, key) => {
          cb(this.data[index], key, this);
        });
      },
      *entries() {
        this.epoch;
        const map = getMapForThis(this);
        for (const [key, index] of map) {
          yield [key, this.data[index]];
        }
      },
      *keys() {
        this.epoch;
        const map = getMapForThis(this);
        for (const key of map.keys()) {
          yield key;
        }
      },
      *values() {
        this.epoch;
        const map = getMapForThis(this);
        for (const index of map.values()) {
          yield this.data[index];
        }
      },
      [Symbol.iterator]() {
        return this.entries();
      },
      get [Symbol.toStringTag]() {
        return "Map";
      },
      toJSON() {
        return new Map(this.entries());
      }
    };
    const proxiedObject = proxy(vObject);
    Object.defineProperties(proxiedObject, {
      size: { enumerable: false },
      index: { enumerable: false },
      epoch: { enumerable: false },
      data: { enumerable: false },
      toJSON: { enumerable: false }
    });
    Object.seal(proxiedObject);
    return proxiedObject;
  }
  const { proxyStateMap, snapCache } = unstable_getInternalStates();
  const maybeProxify = (x) => typeof x === "object" ? proxy({ x }).x : x;
  const isProxy = (x) => proxyStateMap.has(x);
  function proxySet(initialValues) {
    const initialData = [];
    const indexMap = new Map();
    let initialIndex = 0;
    const snapMapCache = new WeakMap();
    const registerSnapMap = () => {
      const cache2 = snapCache.get(vObject);
      const latestSnap = cache2 == null ? void 0 : cache2[1];
      if (latestSnap && !snapMapCache.has(latestSnap)) {
        const clonedMap = new Map(indexMap);
        snapMapCache.set(latestSnap, clonedMap);
      }
    };
    const getMapForThis = (x) => snapMapCache.get(x) || indexMap;
    if (initialValues) {
      if (typeof initialValues[Symbol.iterator] !== "function") {
        throw new TypeError("not iterable");
      }
      for (const value of initialValues) {
        if (!indexMap.has(value)) {
          const v = maybeProxify(value);
          indexMap.set(v, initialIndex);
          initialData[initialIndex++] = v;
        }
      }
    }
    const vObject = {
      data: initialData,
      index: initialIndex,
      epoch: 0,
      get size() {
        if (!isProxy(this)) {
          registerSnapMap();
        }
        return indexMap.size;
      },
      has(value) {
        const map = getMapForThis(this);
        const v = maybeProxify(value);
        this.epoch;
        return map.has(v);
      },
      add(value) {
        if (!isProxy(this)) {
          throw new Error("Cannot perform mutations on a snapshot");
        }
        const v = maybeProxify(value);
        if (!indexMap.has(v)) {
          indexMap.set(v, this.index);
          this.data[this.index++] = v;
          this.epoch++;
        }
        return this;
      },
      delete(value) {
        if (!isProxy(this)) {
          throw new Error("Cannot perform mutations on a snapshot");
        }
        const v = maybeProxify(value);
        const index = indexMap.get(v);
        if (index === void 0) {
          return false;
        }
        delete this.data[index];
        indexMap.delete(v);
        this.epoch++;
        return true;
      },
      clear() {
        if (!isProxy(this)) {
          throw new Error("Cannot perform mutations on a snapshot");
        }
        this.data.length = 0;
        this.index = 0;
        this.epoch++;
        indexMap.clear();
      },
      forEach(cb) {
        this.epoch;
        const map = getMapForThis(this);
        map.forEach((index) => {
          cb(this.data[index], this.data[index], this);
        });
      },
      *values() {
        this.epoch;
        const map = getMapForThis(this);
        for (const index of map.values()) {
          yield this.data[index];
        }
      },
      keys() {
        this.epoch;
        return this.values();
      },
      *entries() {
        this.epoch;
        const map = getMapForThis(this);
        for (const index of map.values()) {
          const value = this.data[index];
          yield [value, value];
        }
      },
      toJSON() {
        return new Set(this.values());
      },
      [Symbol.iterator]() {
        return this.values();
      },
      get [Symbol.toStringTag]() {
        return "Set";
      },
      intersection(other) {
        this.epoch;
        const otherSet = proxySet(other);
        const resultSet = proxySet();
        for (const value of this.values()) {
          if (otherSet.has(value)) {
            resultSet.add(value);
          }
        }
        return proxySet(resultSet);
      },
      union(other) {
        this.epoch;
        const resultSet = proxySet();
        const otherSet = proxySet(other);
        for (const value of this.values()) {
          resultSet.add(value);
        }
        for (const value of otherSet) {
          resultSet.add(value);
        }
        return proxySet(resultSet);
      },
      difference(other) {
        this.epoch;
        const resultSet = proxySet();
        const otherSet = proxySet(other);
        for (const value of this.values()) {
          if (!otherSet.has(value)) {
            resultSet.add(value);
          }
        }
        return proxySet(resultSet);
      },
      symmetricDifference(other) {
        this.epoch;
        const resultSet = proxySet();
        const otherSet = proxySet(other);
        for (const value of this.values()) {
          if (!otherSet.has(value)) {
            resultSet.add(value);
          }
        }
        for (const value of otherSet.values()) {
          if (!this.has(value)) {
            resultSet.add(value);
          }
        }
        return proxySet(resultSet);
      },
      isSubsetOf(other) {
        this.epoch;
        const otherSet = proxySet(other);
        return this.size <= other.size && [...this.values()].every((value) => otherSet.has(value));
      },
      isSupersetOf(other) {
        this.epoch;
        const otherSet = proxySet(other);
        return this.size >= other.size && [...otherSet].every((value) => this.has(value));
      },
      isDisjointFrom(other) {
        this.epoch;
        const otherSet = proxySet(other);
        return [...this.values()].every((value) => !otherSet.has(value));
      }
    };
    const proxiedObject = proxy(vObject);
    Object.defineProperties(proxiedObject, {
      size: { enumerable: false },
      data: { enumerable: false },
      index: { enumerable: false },
      epoch: { enumerable: false },
      toJSON: { enumerable: false }
    });
    Object.seal(proxiedObject);
    return proxiedObject;
  }
  const RUNNING_IN_USERSCRIPTS = GM_info?.scriptHandler === "Userscripts";
  function openNewTab(url, active = true) {
    if (url.startsWith("/")) url = location.origin + url;
    if (RUNNING_IN_USERSCRIPTS) {
      GM.openInTab(url, !active);
      return;
    }
    GM.openInTab(url, {
      active,
      insert: true,
      setParent: true
    });
  }
  function reciveGmValueUpdatesFromOtherTab({
    storageKey: storageKey2,
    onUpdate,
    setPersist
  }) {
    if (typeof GM_addValueChangeListener === "undefined") return;
    const limit2 = pLimit(1);
    GM_addValueChangeListener(storageKey2, (name, oldValue, newValue, remote) => {
      if (!remote) return;
      if (!newValue) return;
      limit2(async () => {
        setPersist(false);
        try {
          onUpdate(newValue);
        } finally {
          await Promise.resolve().then(() => {
            setPersist(true);
          });
        }
      });
    });
  }
  function valtioFactory(computeValue) {
    const state2 = proxy({
      value: computeValue()
    });
    function use() {
      return useSnapshot(state2).value;
    }
    function get2() {
      return state2.value;
    }
    function update() {
      state2.value = computeValue();
    }
    const updateThrottled = throttle$1(update, 100, {
      edges: ["leading", "trailing"]
    });
    return {
      state: state2,
      use,
      get: get2,
      update,
      updateThrottled
    };
  }
  function subscribeOnKeys(state2, keys, callback) {
    let prevVal = pick(snapshot(state2), keys);
    subscribe$3(state2, () => {
      const snap = snapshot(state2);
      const val = pick(snap, keys);
      if (!isEqual$1(prevVal, val)) {
        callback(snap);
      }
      prevVal = val;
    });
  }
  async function proxyWithGmStorage(initialVaue, storageKey2) {
    async function load() {
      const allowedKeys = Object.keys(initialVaue);
      return pick(await GM.getValue(storageKey2) || {}, allowedKeys);
    }
    const p2 = proxy({
      ...initialVaue,
      ...await load()
    });
    setTimeout(() => {
      const limit2 = pLimit(1);
      subscribe$3(p2, () => limit2(async () => {
        const existing = await load();
        const newValue = toMerged(existing, snapshot(p2));
        GM.setValue(storageKey2, newValue);
      }));
    });
    return p2;
  }
  async function proxySetWithGmStorage(storageKey2) {
    const load = async () => await GM.getValue(storageKey2) || [];
    const p2 = proxySet(await load());
    const replaceAllWith = (newVal) => {
      const newSet = new Set(newVal);
      for (const x of [...p2, ...newSet]) {
        if (!newSet.has(x)) p2.delete(x);
        else p2.add(x);
      }
    };
    setTimeout(setupSubscribe);
    let persist = true;
    function setupSubscribe() {
      subscribe$3(p2, () => {
        if (!persist) return;
        GM.setValue(storageKey2, Array.from(snapshot(p2)));
      });
      reciveGmValueUpdatesFromOtherTab({
        storageKey: storageKey2,
        setPersist: (val) => persist = val,
        onUpdate: replaceAllWith
      });
    }
    return {
      set: p2,
      replaceAllWith
    };
  }
  async function proxyMapWithGmStorage(storageKey2, beforeSave) {
    const load = async () => await GM.getValue(storageKey2) || [];
    const p2 = proxyMap(await load());
    const replaceAllWith = (newVal) => {
      const newMap = new Map(newVal);
      for (const [k, v] of [...p2, ...newMap]) {
        if (!newMap.has(k)) p2.delete(k);
        else p2.set(k, v);
      }
    };
    setTimeout(setupSubscribe);
    let persist = true;
    function setupSubscribe() {
      subscribe$3(p2, () => {
        if (!persist) return;
        let val = Array.from(snapshot(p2));
        GM.setValue(storageKey2, val);
      });
      reciveGmValueUpdatesFromOtherTab({
        storageKey: storageKey2,
        setPersist: (val) => persist = val,
        onUpdate: replaceAllWith
      });
    }
    return {
      map: p2,
      replaceAllWith
    };
  }
  const defaultHeader = () => document.querySelector(".bili-header__bar");
  function isUsingCustomHeader() {
    const el = defaultHeader();
    return Boolean(el && window.getComputedStyle(el).display === "none");
  }
  const $usingEvolevdHeader = valtioFactory(isUsingCustomHeader);
  function calcHeaderHeight() {
    if (!isUsingCustomHeader()) return 64;
    const fixed = document.body.classList.contains("fixed-navbar");
    if (!fixed) return 0;
    const heightDef = document.documentElement.style.getPropertyValue("--navbar-height");
    if (!heightDef) return 50;
    const height = Number(heightDef.replace("px", ""));
    if (Number.isNaN(height)) return 50;
    return height;
  }
  const $headerHeight = valtioFactory(calcHeaderHeight);
  function calcHeaderWidth() {
    const paddingDef = document.documentElement.style.getPropertyValue("--navbar-bounds-padding");
    if (!paddingDef) return;
    const percent = minmax(Number(paddingDef.replace("%", "")), 2, 10);
    const width = 100 - percent * 2;
    return width;
  }
  const $headerWidth = valtioFactory(calcHeaderWidth);
  function useBackToTopRight() {
    const width = $headerWidth.use();
    const {
      pureRecommend,
      style: {
        pureRecommend: {
          useCustomGrid
        }
      }
    } = useSettingsSnapshot();
    if (!pureRecommend || !useCustomGrid) return;
    if (!width) return;
    const rest = (1 - width / 100) / 2 * window.innerWidth +
10;
    const backToTopWidth = 40;
    if (rest > backToTopWidth +
24 +
5) {
      return;
    }
    if (rest < backToTopWidth) {
      return 0;
    }
    const right = Math.floor((rest - backToTopWidth) / 2);
    return right;
  }
  const $evolvedThemeColor = valtioFactory(function calcEvolvedThemeColor() {
    return window.getComputedStyle(document.documentElement).getPropertyValue("--theme-color");
  });
  function action() {
    $usingEvolevdHeader.updateThrottled();
    $headerHeight.updateThrottled();
    $headerWidth.updateThrottled();
    $evolvedThemeColor.updateThrottled();
  }
  const ob$1 = new MutationObserver(() => action());
  ob$1.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ["style"]
  });
  ob$1.observe(document.body, {
    attributes: true,
    attributeFilter: ["class"]
  });
  window.addEventListener("unload", () => {
    ob$1.disconnect();
  });
  document.body.addEventListener("click", (e2) => {
    const el = e2.target;
    const isClickOnButton = (el2) => !!el2?.matches(".be-button.ok");
    if (!isClickOnButton(el) && !isClickOnButton(el.parentElement)) return;
    if (!el.closest(".be-popup.picker.open")) return;
    setTimeout($evolvedThemeColor.updateThrottled, 1e3);
  }, {
    capture: true,
    passive: true
  });
  const messageConfig = {
maxCount: 5,
    top: $headerHeight.get() - 4
  };
  antd.message.config(messageConfig);
  function AntdStaticFunctionsSetup() {
    const h2 = $headerHeight.use();
    return jsx$1(antd.App, { message: {
      ...messageConfig,
      top: h2 - 4
    }, children: jsx$1(SetupInner, {}) });
  }
  let antStatic;
  let antMessage = antd.message;
  let antNotification = antd.notification;
  let antModal = antd.Modal;
  function SetupInner() {
    antStatic = antd.App.useApp();
    antMessage = antStatic.message;
    antNotification = antStatic.notification;
    antModal = antStatic.modal;
    return null;
  }
  function defineAntMenus(arr) {
    return arr.filter(Boolean).filter((x) => {
      if (typeof x.test === "undefined") return true;
      if (typeof x.test === "boolean") return x.test;
      return x.test();
    }).map((x) => omit(x, ["test"]));
  }
  const cuidaShuffleOutline = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M17.793 3.693a1 1 0 0 1 1.414 0l2.5 2.5a1 1 0 0 1 0 1.414l-2.5 2.5a1 1 0 1 1-1.414-1.414L19.586 6.9l-1.793-1.793a1 1 0 0 1 0-1.414m0 10.15a1 1 0 0 1 1.414 0l2.5 2.5a1 1 0 0 1 0 1.414l-2.5 2.5a1 1 0 1 1-1.414-1.414l1.793-1.793l-1.793-1.793a1 1 0 0 1 0-1.414", clipRule: "evenodd" }),
jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M19.054 5.913c.352.023.657.043.946.043a1 1 0 1 1 0 2c-.346 0-.776-.028-1.184-.054a37 37 0 0 0-.606-.037c-.614-.03-1.118-.02-1.482.065c-1.456.341-3.07 1.481-4.394 4.117c1.304 2.555 2.9 3.529 4.394 3.879c.364.085.868.094 1.482.064c.186-.009.393-.022.606-.036A19 19 0 0 1 20 15.899a1 1 0 1 1 0 2c-.289 0-.594.02-.946.044c-.227.015-.473.032-.747.045c-.63.03-1.377.04-2.035-.115c-1.812-.424-3.549-1.493-4.972-3.634c-.553 1.02-1.177 1.822-1.927 2.427c-.978.788-2.12 1.106-3.213 1.24c-.882.108-1.81.102-2.64.096L3 18a1 1 0 1 1 0-2l.582.002c.824.005 1.593.01 2.335-.08c.892-.11 1.624-.348 2.201-.813c.687-.554 1.323-1.447 1.962-2.95l.046-.109l-.046-.109c-.651-1.53-1.303-2.495-2.015-3.103c-.56-.477-1.277-.726-2.161-.845c-.763-.102-1.562-.099-2.42-.095L3 7.899a1 1 0 1 1 0-2l.445-.001c.853-.004 1.813-.01 2.724.113c1.094.146 2.234.486 3.194 1.305c.75.64 1.375 1.481 1.93 2.52c1.408-2.187 3.136-3.421 4.979-3.853c.658-.154 1.405-.145 2.035-.115c.274.013.52.03.747.045", clipRule: "evenodd" })
  ] });
  const ForwardRef$18 = H.forwardRef(cuidaShuffleOutline);
  function defineSvgComponent(render3) {
    return H.forwardRef((props, ref) => {
      return render3({
        xmlns: "http://www.w3.org/2000/svg",
        xmlnsXlink: "http://www.w3.org/1999/xlink",
        ...props,
        ref
      });
    });
  }
  function r$1(e2) {
    var t2, f2, n2 = "";
    if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
    else if ("object" == typeof e2) if (Array.isArray(e2)) {
      var o2 = e2.length;
      for (t2 = 0; t2 < o2; t2++) e2[t2] && (f2 = r$1(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
    } else for (f2 in e2) e2[f2] && (n2 && (n2 += " "), n2 += f2);
    return n2;
  }
  function clsx() {
    for (var e2, t2, f2 = 0, n2 = "", o2 = arguments.length; f2 < o2; f2++) (e2 = arguments[f2]) && (t2 = r$1(e2)) && (n2 && (n2 += " "), n2 += t2);
    return n2;
  }
  const phThumbsDownDuotone = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 256 256", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "currentColor", children: [
jsx$1("path", { d: "M80 48v104H32a8 8 0 0 1-8-8V56a8 8 0 0 1 8-8Z", opacity: 0.2 }),
jsx$1("path", { d: "m239.82 157l-12-96A24 24 0 0 0 204 40H32a16 16 0 0 0-16 16v88a16 16 0 0 0 16 16h43.06l37.78 75.58A8 8 0 0 0 120 240a40 40 0 0 0 40-40v-16h56a24 24 0 0 0 23.82-27M72 144H32V56h40Zm150 21.29a7.88 7.88 0 0 1-6 2.71h-64a8 8 0 0 0-8 8v24a24 24 0 0 1-19.29 23.54L88 150.11V56h116a8 8 0 0 1 7.94 7l12 96a7.87 7.87 0 0 1-1.94 6.29" })
    ] })
  ] });
  const ForwardRef$17 = H.forwardRef(phThumbsDownDuotone);
  const iconParkOutlineConfig = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "m24 4l-6 6h-8v8l-6 6l6 6v8h8l6 6l6-6h8v-8l6-6l-6-6v-8h-8z" }),
jsx$1("path", { d: "M24 30a6 6 0 1 0 0-12a6 6 0 0 0 0 12Z" })
    ] })
  ] });
  const ForwardRef$16 = H.forwardRef(iconParkOutlineConfig);
  const iconParkOutlinePlayTwo = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("rect", { width: 36, height: 36, x: 6, y: 6, strokeLinecap: "round", rx: 3 }),
jsx$1("path", { d: "M18.5 24v-7.794l6.75 3.897L32 24l-6.75 3.897l-6.75 3.897z" })
    ] })
  ] });
  const ForwardRef$15 = H.forwardRef(iconParkOutlinePlayTwo);
  const materialSymbolsLightOpenInNew = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M5.616 20q-.691 0-1.153-.462T4 18.384V5.616q0-.691.463-1.153T5.616 4h5.615v1H5.616q-.231 0-.424.192T5 5.616v12.769q0 .23.192.423t.423.192h12.77q.23 0 .423-.192t.192-.423v-5.616h1v5.616q0 .69-.462 1.152T18.384 20zm4.123-5.03l-.708-.709L18.292 5H14V4h6v6h-1V5.708z" })
  ] });
  const ForwardRef$14 = H.forwardRef(materialSymbolsLightOpenInNew);
  const tablerSortAscending2 = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "m14 9l3-3l3 3M5 5.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-4a.5.5 0 0 1-.5-.5zm0 9a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-4a.5.5 0 0 1-.5-.5zM17 6v12" })
  ] });
  const ForwardRef$13 = H.forwardRef(tablerSortAscending2);
  const tablerSortDescending2 = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M5 5.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-4a.5.5 0 0 1-.5-.5zm0 9a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-4a.5.5 0 0 1-.5-.5zm9 .5l3 3l3-3m-3 3V6" })
  ] });
  const ForwardRef$12 = H.forwardRef(tablerSortDescending2);
  const iconParkOutlineInfo = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", children: [
jsx$1("path", { stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, d: "M24 44a19.94 19.94 0 0 0 14.142-5.858A19.94 19.94 0 0 0 44 24a19.94 19.94 0 0 0-5.858-14.142A19.94 19.94 0 0 0 24 4A19.94 19.94 0 0 0 9.858 9.858A19.94 19.94 0 0 0 4 24a19.94 19.94 0 0 0 5.858 14.142A19.94 19.94 0 0 0 24 44Z" }),
jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M24 11a2.5 2.5 0 1 1 0 5a2.5 2.5 0 0 1 0-5", clipRule: "evenodd" }),
jsx$1("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "M24.5 34V20h-2M21 34h7" })
    ] })
  ] });
  const ForwardRef$11 = H.forwardRef(iconParkOutlineInfo);
  const materialSymbolsDeleteOutlineRounded = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M7 21q-.825 0-1.412-.587T5 19V6q-.425 0-.712-.288T4 5t.288-.712T5 4h4q0-.425.288-.712T10 3h4q.425 0 .713.288T15 4h4q.425 0 .713.288T20 5t-.288.713T19 6v13q0 .825-.587 1.413T17 21zM17 6H7v13h10zm-7 11q.425 0 .713-.288T11 16V9q0-.425-.288-.712T10 8t-.712.288T9 9v7q0 .425.288.713T10 17m4 0q.425 0 .713-.288T15 16V9q0-.425-.288-.712T14 8t-.712.288T13 9v7q0 .425.288.713T14 17M7 6v13z" })
  ] });
  const ForwardRef$10 = H.forwardRef(materialSymbolsDeleteOutlineRounded);
  const mdiShuffleDisabled = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M16 4.5V7H5v2h11v2.5L19.5 8M16 12.5V15H5v2h11v2.5l3.5-3.5" })
  ] });
  const ForwardRef$$ = H.forwardRef(mdiShuffleDisabled);
  const iconParkOutlineTime = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4S4 12.954 4 24s8.954 20 20 20Z" }),
jsx$1("path", { strokeLinecap: "round", d: "M24.008 12v12.01l8.479 8.48" })
    ] })
  ] });
  const ForwardRef$_ = H.forwardRef(iconParkOutlineTime);
  const iconParkOutlineIphone = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeWidth: 4, children: [
jsx$1("rect", { width: 26, height: 40, x: 11, y: 4, rx: 3 }),
jsx$1("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M22 10h4m-6 28h8" })
    ] })
  ] });
  const ForwardRef$Z = H.forwardRef(iconParkOutlineIphone);
  const iconParkOutlineComputer = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeWidth: 4, children: [
jsx$1("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M19 32h10v9H19z" }),
jsx$1("rect", { width: 38, height: 24, x: 5, y: 8, rx: 2 }),
jsx$1("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M22 27h4M14 41h20" })
    ] })
  ] });
  const ForwardRef$Y = H.forwardRef(iconParkOutlineComputer);
  const iconParkOutlineConcern = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", children: [
jsx$1("path", { strokeLinecap: "round", strokeWidth: 4, d: "M10.858 9.858A19.94 19.94 0 0 0 5 24a19.94 19.94 0 0 0 5.858 14.142m28.284 0A19.94 19.94 0 0 0 45 24a19.94 19.94 0 0 0-5.858-14.142M34.9 33.9A13.96 13.96 0 0 0 39 24a13.96 13.96 0 0 0-4.1-9.9m-19.8 0A13.96 13.96 0 0 0 11 24a13.96 13.96 0 0 0 4.1 9.9" }),
jsx$1("path", { strokeLinejoin: "round", strokeWidth: 3.5, d: "M28.182 20C30.29 20 32 21.612 32 23.6c0 2.588-2.546 4.8-3.818 6Q26.908 30.8 25 32q-1.909-1.2-3.182-2.4C20.545 28.4 18 26.188 18 23.6c0-1.988 1.71-3.6 3.818-3.6c1.328 0 2.498.64 3.182 1.61c.684-.97 1.854-1.61 3.182-1.61Z" })
    ] })
  ] });
  const ForwardRef$X = H.forwardRef(iconParkOutlineConcern);
  const iconParkOutlineTumblr = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", children: [
jsx$1("path", { stroke: "currentColor", strokeWidth: 4, d: "M39 6H9a3 3 0 0 0-3 3v30a3 3 0 0 0 3 3h30a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3Z" }),
jsx$1("path", { fill: "currentColor", d: "M15 22v-5h5v-3l6-2v5h5v5h-5v7s0 1.5 2 2s5-1 5-1l-2 6h-5c-3.5 0-6-3.5-6-6v-8z" })
    ] })
  ] });
  const ForwardRef$W = H.forwardRef(iconParkOutlineTumblr);
  const carbonStar = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 32 32", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "m16 6.52l2.76 5.58l.46 1l1 .15l6.16.89l-4.38 4.3l-.75.73l.18 1l1.05 6.13l-5.51-2.89L16 23l-.93.49l-5.51 2.85l1-6.13l.18-1l-.74-.77l-4.42-4.35l6.16-.89l1-.15l.46-1zM16 2l-4.55 9.22l-10.17 1.47l7.36 7.18L6.9 30l9.1-4.78L25.1 30l-1.74-10.13l7.36-7.17l-10.17-1.48Z" })
  ] });
  const ForwardRef$V = H.forwardRef(carbonStar);
  const carbonStarFilled = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 32 32", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "m16 2l-4.55 9.22l-10.17 1.47l7.36 7.18L6.9 30l9.1-4.78L25.1 30l-1.74-10.13l7.36-7.17l-10.17-1.48Z" })
  ] });
  const ForwardRef$U = H.forwardRef(carbonStarFilled);
  const iconParkOutlineFire = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, d: "M24 44c8.235 0 15-6.526 15-14.902c0-2.056-.105-4.26-1.245-7.686s-1.369-3.868-2.574-5.984c-.515 4.317-3.27 6.117-3.97 6.655c0-.56-1.666-6.747-4.193-10.45C24.537 8 21.163 5.617 19.185 4c0 3.07-.863 7.634-2.1 9.96c-1.236 2.325-1.468 2.41-3.013 4.14s-2.253 2.265-3.545 4.365S9 27.362 9 29.418C9 37.794 15.765 44 24 44Z" })
  ] });
  const ForwardRef$T = H.forwardRef(iconParkOutlineFire);
  const lineMdUploadingLoop = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsx$1("path", { strokeDasharray: "2 4", strokeDashoffset: 6, d: "M12 21c-4.97 0 -9 -4.03 -9 -9c0 -4.97 4.03 -9 9 -9", children: jsx$1("animate", { attributeName: "stroke-dashoffset", dur: "0.6s", repeatCount: "indefinite", values: "6;0" }) }),
jsx$1("path", { strokeDasharray: 32, strokeDashoffset: 32, d: "M12 3c4.97 0 9 4.03 9 9c0 4.97 -4.03 9 -9 9", children: jsx$1("animate", { fill: "freeze", attributeName: "stroke-dashoffset", begin: "0.1s", dur: "0.4s", values: "32;0" }) }),
jsx$1("path", { strokeDasharray: 10, strokeDashoffset: 10, d: "M12 16v-7.5", children: jsx$1("animate", { fill: "freeze", attributeName: "stroke-dashoffset", begin: "0.5s", dur: "0.2s", values: "10;0" }) }),
jsx$1("path", { strokeDasharray: 6, strokeDashoffset: 6, d: "M12 8.5l3.5 3.5M12 8.5l-3.5 3.5", children: jsx$1("animate", { fill: "freeze", attributeName: "stroke-dashoffset", begin: "0.7s", dur: "0.2s", values: "6;0" }) })
    ] })
  ] });
  const ForwardRef$S = H.forwardRef(lineMdUploadingLoop);
  const iconParkOutlinePeopleDelete = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M19 20a7 7 0 1 0 0-14a7 7 0 0 0 0 14Z" }),
jsx$1("path", { strokeLinecap: "round", d: "m33 31l8 8m-8 0l8-8m-14-3h-8.2c-4.48 0-6.72 0-8.432.872a8 8 0 0 0-3.496 3.496C6 34.08 6 36.32 6 40.8V42h21" })
    ] })
  ] });
  const ForwardRef$R = H.forwardRef(iconParkOutlinePeopleDelete);
  const iconParkOutlineReturn = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "m13 8l-7 6l7 7" }),
jsx$1("path", { d: "M6 14h22.994c6.883 0 12.728 5.62 12.996 12.5c.284 7.27-5.723 13.5-12.996 13.5H11.998" })
    ] })
  ] });
  const ForwardRef$Q = H.forwardRef(iconParkOutlineReturn);
  const iconParkOutlineCopy = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { strokeLinecap: "round", d: "M13 12.432v-4.62A2.813 2.813 0 0 1 15.813 5h24.374A2.813 2.813 0 0 1 43 7.813v24.375A2.813 2.813 0 0 1 40.188 35h-4.672" }),
jsx$1("path", { d: "M32.188 13H7.811A2.813 2.813 0 0 0 5 15.813v24.374A2.813 2.813 0 0 0 7.813 43h24.375A2.813 2.813 0 0 0 35 40.188V15.811A2.813 2.813 0 0 0 32.188 13Z" })
    ] })
  ] });
  const ForwardRef$P = H.forwardRef(iconParkOutlineCopy);
  const svgSpinnersBarsRotateFade = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { children: [
jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", opacity: 0.14 }),
jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", opacity: 0.29, transform: "rotate(30 12 12)" }),
jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", opacity: 0.43, transform: "rotate(60 12 12)" }),
jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", opacity: 0.57, transform: "rotate(90 12 12)" }),
jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", opacity: 0.71, transform: "rotate(120 12 12)" }),
jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", opacity: 0.86, transform: "rotate(150 12 12)" }),
jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", transform: "rotate(180 12 12)" }),
jsx$1("animateTransform", { attributeName: "transform", calcMode: "discrete", dur: "0.75s", repeatCount: "indefinite", type: "rotate", values: "0 12 12;30 12 12;60 12 12;90 12 12;120 12 12;150 12 12;180 12 12;210 12 12;240 12 12;270 12 12;300 12 12;330 12 12;360 12 12" })
    ] })
  ] });
  const ForwardRef$O = H.forwardRef(svgSpinnersBarsRotateFade);
  const materialSymbolsBarChart = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M16 20v-7h4v7zm-6 0V4h4v16zm-6 0V9h4v11z" })
  ] });
  const ForwardRef$N = H.forwardRef(materialSymbolsBarChart);
  const IconForDislike = ForwardRef$17;
  const IconForConfig = ForwardRef$16;
  const IconForPlayer = ForwardRef$15;
  const IconForOpenExternalLink = ForwardRef$14;
  const IconForAsc = ForwardRef$13;
  const IconForDesc = ForwardRef$12;
  const IconForInfo = ForwardRef$11;
  const IconForDelete = ForwardRef$10;
  const IconForDefaultOrder = ForwardRef$$;
  const IconForShuffle = ForwardRef$18;
  const IconForTimestamp = ForwardRef$_;
  const IconForPhone = ForwardRef$Z;
  const IconForPc = ForwardRef$Y;
  const IconForFollowedOnly = ForwardRef$X;
  const IconForDynamicFeed = ForwardRef$W;
  const IconForFav = ForwardRef$V;
  const IconForFaved = ForwardRef$U;
  const IconForHot = ForwardRef$T;
  const IconForSpaceUpload = ForwardRef$S;
  const IconForBlacklist = ForwardRef$R;
  const IconForReset = ForwardRef$Q;
  const IconForCopy = ForwardRef$P;
  const IconForLoading = ForwardRef$O;
  const IconForRemove = ForwardRef$10;
  const LIVE_GIF = `data:image/gif;base64,R0lGODlhGAAYAJECAP7+/v///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ4IDc5LjE2NDAzNiwgMjAxOS8wOC8xMy0wMTowNjo1NyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QTI2NTYzMDc2RTNDMTFFREJENEJEMzUxOTQzQjMxMkQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QTI2NTYzMDg2RTNDMTFFREJENEJEMzUxOTQzQjMxMkQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpBMjY1NjMwNTZFM0MxMUVEQkQ0QkQzNTE5NDNCMzEyRCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBMjY1NjMwNjZFM0MxMUVEQkQ0QkQzNTE5NDNCMzEyRCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769vLu6ubi3trW0s7KxsK+urayrqqmop6alpKOioaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhoWEg4KBgH9+fXx7enl4d3Z1dHNycXBvbm1sa2ppaGdmZWRjYmFgX15dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozo5ODc2NTQzMjEwLy4tLCsqKSgnJiUkIyIhIB8eHRwbGhkYFxYVFBMSERAPDg0MCwoJCAcGBQQDAgEAACH5BAkEAAIALAAAAAAYABgAAAI5lI+py+0Po2QhTFXrRdlu031gJgqhpI0pdJ4sacJv6j6trABeTOMcfFslgp7ar4fcDVcyX+kJjToKACH5BAkEAAIALAAAAAAYABgAAAI2lI+py+0Po5xUhFDRvdls3H0T522SaJkRikKs6qptAr+kYoOzJvc37dPBgKQco3YbdpbM5qQAACH5BAkEAAIALAAAAAAYABgAAAI3lI+py+0Po5y02hhykHqLzmkGiImfCZHkkh0qmrztOSuyt8bmzfC0Z9sJa7qZLwhEwS7MpnNSAAAh+QQJBAACACwAAAAAGAAYAAACPJSPqcvtD6OctJoQ7MFYC55dYQSKHcmZo3J+qdsmJRzO7DvbMs7HSN5b/YIqBvCkGyKJixds4/NIp1RHAQAh+QQJBAACACwAAAAAGAAYAAACOpSPqcvtD6OcLwSarMVHXy54YKhJIrmhn3K25eKmJ/vGa1bnKS3rN2IzzHC94q/jE754yNVyBI1KIQUAIfkECQQAAgAsAAAAABgAGAAAAjmUj6nL7Q+jnLSaEOzBePbLSVwmjGJYopCZfmnDxmoif6xSkzeN5ozfIuF6RBfPVhQeN66Z5gmNTgoAIfkECQQAAgAsAAAAABgAGAAAAjmUj6nL7Q+jnLRaETLSMnMfdJ4Bit8YlRgKqerauOibyCen2OGK1/Pf2wB3NOGNyPLteIfk5QmNTgoAIfkECQQAAgAsAAAAABgAGAAAAjeUj6nL7Q+jnCkEWu3FRm/uHdYUCiVUnk+qSewYvd/amrWKyF2t6DbcuwmBGZgv+OHxOMyms1kAACH5BAkEAAIALAAAAAAYABgAAAI5lI+py+0PowtBLkptwlUf7n1YaIBlF5kmpI6puz5t9tLxBLsCgCpzdxPZcjQfEajbFHVJkvMJtRQAACH5BAkEAAIALAAAAAAYABgAAAI1lI+py+0Po5wpBFrtxUZv7nGdJgqheJ5QSkasJb2bmsFmSyPyaCv73avNcC1fr1gsKZdMSAEAIfkECQQAAgAsAAAAABgAGAAAAjWUj6nL7Q+jnLRaEfI1Wd8ebKDYkR4WHqcyol7Llm4KJ+0tx69cI/i+8vGGQdUpl9sol0xIAQAh+QQJBAACACwAAAAAGAAYAAACNJSPqcvtD6OctNq7QsBCa+xtV9h8DJl5p5qaCtqJsZugNvuyN43sIlzTCXkHnJHISSqXiQIAIfkECQQAAgAsAAAAABgAGAAAAjKUj6nL7Q+jnLTai3MMPLDuLeDXkZwZKqNYsqebJqva0u86yy1e6/feQ9SGL43xiEwUAAAh+QQJBAACACwAAAAAGAAYAAACM5SPqcvtD6OctNp7Q8BCa+xtzDd6JamEp5iai2qgcEvCc2K7N5LXLi3qsXCy4pCDTCoXBQAh+QQJBAACACwAAAAAGAAYAAACNJSPqcvtD6OctNoYcrhC7+txIag1mVkuY/exp5qOayLHqVK/M5J/+9Ez/IQvF7DISSqXkAIAIfkEBQQAAgAsAAAAABgAGAAAAjKUj6nL7Q+jnFSEUNG92WzcfZ21jWJYRucJranyutwig2xSey+e5nQPnMGEMeHoiExCCgA7`;
  function IconForLive({
    active = false,
    ...props
  }) {
    if (active) {
      return jsx$1("img", { ...props, src: LIVE_GIF });
    } else {
      return jsx$1(ForwardRef$N, { ...props });
    }
  }
  const IconForWatchlater = defineSvgComponent((props) => {
    return jsxs("svg", { viewBox: "0 0 20 20", width: "20", height: "20", fill: "currentColor", ...props, children: [
jsx$1("path", { className: "circle", d: "M10 3.1248000000000005C6.20305 3.1248000000000005 3.1250083333333336 6.202841666666667 3.1250083333333336 9.999833333333335C3.1250083333333336 13.796750000000001 6.20305 16.874833333333335 10 16.874833333333335C11.898291666666667 16.874833333333335 13.615833333333333 16.106291666666667 14.860625 14.861916666666666C15.104708333333335 14.617916666666666 15.500416666666668 14.617958333333334 15.7445 14.862041666666668C15.9885 15.106166666666669 15.988416666666668 15.501916666666666 15.744333333333334 15.745958333333334C14.274750000000001 17.215041666666668 12.243041666666667 18.124833333333335 10 18.124833333333335C5.512691666666667 18.124833333333335 1.8750083333333334 14.487125 1.8750083333333334 9.999833333333335C1.8750083333333334 5.512483333333334 5.512691666666667 1.8748000000000002 10 1.8748000000000002C14.487291666666668 1.8748000000000002 18.125 5.512483333333334 18.125 9.999833333333335C18.125 10.304458333333333 18.108208333333334 10.605458333333333 18.075458333333337 10.901791666666668C18.0375 11.244916666666667 17.728625 11.492291666666667 17.385583333333333 11.454333333333334C17.0425 11.416416666666667 16.795083333333334 11.107541666666668 16.833000000000002 10.764458333333334C16.860750000000003 10.513625000000001 16.875 10.2585 16.875 9.999833333333335C16.875 6.202841666666667 13.796958333333333 3.1248000000000005 10 3.1248000000000005z", fill: "currentColor" }),
jsx$1("path", { d: "M15.391416666666666 9.141166666666667C15.635458333333334 8.897083333333335 16.031208333333332 8.897083333333335 16.275291666666668 9.141166666666667L17.5 10.365875L18.72475 9.141166666666667C18.968791666666668 8.897083333333335 19.364541666666668 8.897083333333335 19.608625 9.141166666666667C19.852666666666668 9.385291666666667 19.852666666666668 9.780958333333334 19.608625 10.025083333333333L18.08925 11.544416666666669C17.763833333333334 11.869833333333334 17.236208333333334 11.869833333333334 16.91075 11.544416666666669L15.391416666666666 10.025083333333333C15.147333333333334 9.780958333333334 15.147333333333334 9.385291666666667 15.391416666666666 9.141166666666667z", fill: "currentColor" }),
jsx$1("path", { d: "M12.499333333333334 9.278375C13.05475 9.599 13.05475 10.400666666666668 12.499333333333334 10.721291666666668L9.373916666666666 12.525791666666668C8.818541666666667 12.846416666666666 8.124274999999999 12.445583333333333 8.124274999999999 11.804291666666668L8.124274999999999 8.1954C8.124274999999999 7.554066666666667 8.818541666666667 7.153233333333334 9.373916666666666 7.473900000000001L12.499333333333334 9.278375z", fill: "currentColor" })
    ] });
  });
  const clsIconTextWrapper = "inline-flex items-center justify-center line-height-[0]";
  function withDescIcon(label) {
    return jsxs("span", { className: clsx(clsIconTextWrapper, "gap-1px"), children: [
      label,
jsx$1(IconForDesc, { className: "size-16px" })
    ] });
  }
  function withAscIcon(label) {
    return jsxs("span", { className: clsx(clsIconTextWrapper, "gap-1px"), children: [
      label,
jsx$1(IconForAsc, { className: "size-16px" })
    ] });
  }
  defineSvgComponent((props) => {
    return jsx$1("svg", { width: "16", height: "17", viewBox: "0 0 16 17", fill: "none", ...props, children: jsx$1("path", { d: "M5.00014 14.9839C4.94522 15.1219 5.12392 15.2322 5.22268 15.1212L11.5561 8.00214C11.7084 7.83093 11.5869 7.56014 11.3578 7.56014H9.13662L11.6019 3.57178C11.7112 3.39489 11.584 3.16666 11.376 3.16666H7.4475C7.22576 3.16666 7.02737 3.30444 6.94992 3.51221L4.68362 9.59189C4.61894 9.76539 4.74725 9.95014 4.93241 9.95014H7.00268L5.00014 14.9839Z", fill: "white" }) });
  });
  const parsed = UAParser();
  const isMac = parsed.os.name?.toLowerCase() === "mac os";
  const parsedBrowserName = parsed.browser.name || "";
  const isBrand = (brand) => new RegExp(String.raw`\b${brand}\b`, "i").test(parsedBrowserName);
  const isSafari = isBrand("safari");
  const isFirefox = isBrand("firefox");
  isBrand("edge");
  const materialSymbolsLightOpenInNewOff = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "m19.833 21.26l-1.298-1.298q-.096.019-.173.029q-.077.009-.173.009H5.616q-.691 0-1.153-.462T4 18.384V5.813q0-.096.01-.173t.029-.173l-1.299-1.3l.713-.713l17.092 17.092zM5.616 19h11.957l-5.933-5.933l-1.902 1.902l-.707-.708l1.902-1.902L5 6.427v11.958q0 .23.192.423t.423.192M7.813 5l-1-1h4.419v1zm5.948 5.948l-.708-.707L18.292 5H14V4h6v6h-1V5.708zm6.24 6.24l-1-1V12.77h1z" })
  ] });
  const ForwardRef$M = H.forwardRef(materialSymbolsLightOpenInNewOff);
  const riFullscreenFill = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M16 3h6v6h-2V5h-4zM2 3h6v2H4v4H2zm18 16v-4h2v6h-6v-2zM4 19h4v2H2v-6h2z" })
  ] });
  const ForwardRef$L = H.forwardRef(riFullscreenFill);
  const akarIconsMiniplayer = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsx$1("rect", { width: 20, height: 16, x: 2, y: 4, rx: 2 }),
jsx$1("rect", { width: 9, height: 7, x: 13, y: 13, rx: 2 })
    ] })
  ] });
  const ForwardRef$K = H.forwardRef(akarIconsMiniplayer);
  const eosIconsBackgroundTasks = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M6 3h8.99v1.5H6zM2.99 6h1.5v1.5h-1.5zm0-3h1.5v1.5h-1.5zm0 6.01H4.5v1.5H2.99z" }),
jsx$1("path", { fill: "currentColor", d: "M4.5 12h-3V1.49h15V6H18V2a2 2 0 0 0-2-2H2a2 2 0 0 0-2 2v9.48a2 2 0 0 0 2 2h2.5Z" }),
jsx$1("path", { fill: "currentColor", d: "M22 7.5H8a2 2 0 0 0-2 2V19a2 2 0 0 0 2 2h5.53v1.53H12V24h6v-1.49h-1.5V21H22a2 2 0 0 0 2-2V9.5a2 2 0 0 0-2-2m.51 12h-15V9h15Z" })
  ] });
  const ForwardRef$J = H.forwardRef(eosIconsBackgroundTasks);
  const STAT_NUMBER_FALLBACK = "0";
  function copyContent(content) {
    GM.setClipboard(content);
    antMessage.success(`已复制: ${content}`);
  }
  var QueryKey = ((QueryKey2) => {
    QueryKey2["PlayerScreenMode"] = `${APP_SHORT_PREFIX}-player-screen-mode`;
    QueryKey2["ForceAutoPlay"] = `${APP_SHORT_PREFIX}-force-auto-play`;
    return QueryKey2;
  })(QueryKey || {});
  var PlayerScreenMode = ((PlayerScreenMode2) => {
    PlayerScreenMode2["Normal"] = "normal";
    PlayerScreenMode2["Wide"] = "wide";
    PlayerScreenMode2["WebFullscreen"] = "web";
    PlayerScreenMode2["Fullscreen"] = "full";
    return PlayerScreenMode2;
  })(PlayerScreenMode || {});
  var ForceAutoPlay = ((ForceAutoPlay2) => {
    ForceAutoPlay2["ON"] = "on";
    ForceAutoPlay2["OFF"] = "off";
    return ForceAutoPlay2;
  })(ForceAutoPlay || {});
  var VideoLinkOpenMode = ((VideoLinkOpenMode2) => {
    VideoLinkOpenMode2["Normal"] = "Normal";
    VideoLinkOpenMode2["CurrentPage"] = "CurrentPage";
    VideoLinkOpenMode2["NormalWebFullscreen"] = "NormalWebFullscreen";
    VideoLinkOpenMode2["Popup"] = "Popup";
    VideoLinkOpenMode2["Background"] = "Background";
    VideoLinkOpenMode2["Iina"] = "Iina";
    return VideoLinkOpenMode2;
  })(VideoLinkOpenMode || {});
  const VideoLinkOpenModeKey = Object.entries(VideoLinkOpenMode).reduce((record, [key, value]) => {
    return {
      ...record,
      [value]: `LinkOpenMode.${key}`
    };
  }, {});
  const VideoLinkOpenModeConfig = {
    [
      "Normal"
]: {
      icon: jsx$1(IconForOpenExternalLink, { className: "size-16px" }),
      label: "打开",
      desc: "默认在新标签页中打开"
    },
    [
      "CurrentPage"
]: {
      icon: jsx$1(ForwardRef$M, { className: "size-16px" }),
      label: "当前页中打开",
      desc: "不打开新标签页, 使用当前标签页打开, 适用于将网站作为应用安装场景"
    },
    [
      "NormalWebFullscreen"
]: {
      icon: jsx$1(ForwardRef$L, { className: "size-15px" }),
      label: "打开-网页全屏",
      desc: jsx$1(Fragment, { children: "默认在新标签页中打开, 打开后自动网页全屏" })
    },
    [
      "Popup"
]: {
      icon: jsx$1(ForwardRef$K, { className: "size-15px" }),
      label: "小窗打开",
      desc: jsxs(Fragment, { children: [
        "当",
        " ",
jsx$1("a", { href: "https://developer.chrome.com/docs/web-platform/document-picture-in-picture", target: "_blank", children: "「文档画中画」API" }),
        " ",
        "可用时, 会使用「文档画中画」的形式: 窗口置顶 + 播放页网页全屏.",
jsx$1("br", {}),
        "当该 API 不可用时, 会使用 popup window + 播放页网页全屏 的形式."
      ] })
    },
    [
      "Background"
]: {
      icon: jsx$1(ForwardRef$J, { className: "size-15px" }),
      label: "后台打开"
    },
    [
      "Iina"
]: {
      icon: jsx$1(IconForPlayer, { className: "size-15px" }),
      label: "在 IINA 中打开",
      enabled: isMac,
      desc: jsx$1(Fragment, { children: jsx$1("a", { href: "https://github.com/magicdawn/Bilibili-Gate/blob/main/notes/iina.md", target: "_blank", children: "macOS IINA 设置教程" }) })
    }
  };
  function createVideoCardEmitter() {
    return new Emittery();
  }
  function createSharedEmitter() {
    return new Emittery();
  }
  const defaultEmitter = createVideoCardEmitter();
  const defaultSharedEmitter = createSharedEmitter();
  var ECardDisplay = ((ECardDisplay2) => {
    ECardDisplay2["Grid"] = "grid";
    ECardDisplay2["List"] = "list";
    return ECardDisplay2;
  })(ECardDisplay || {});
  const displayAsListCss = {
    card: {
      name: "18iuzk9",
      styles: "grid-column:1/-1"
    },
    cardWrap: {
      name: "k9oiqw",
      styles: "display:flex;column-gap:20px"
    },
    cover: {
      name: "1t7agkb",
      styles: "width:clamp(250px, 20%, 400px);flex-shrink:0"
    }
  };
  function isDisplayAsList(cardDisplay) {
    return cardDisplay === "list";
  }
  const clsZWatchlaterProgressBar = "z-2";
  const clsZPreviewImageWrapper = "z-3";
  const clsZMultiSelectBg = "z-4";
  const clsZLeftMarks = "z-5";
  const clsZRightActions = "z-6";
  var WatchlaterItemsOrder = ((WatchlaterItemsOrder2) => {
    WatchlaterItemsOrder2["AddTimeDesc"] = "add-time-desc";
    WatchlaterItemsOrder2["AddTimeAsc"] = "add-time-asc";
    WatchlaterItemsOrder2["Shuffle"] = "shuffle";
    return WatchlaterItemsOrder2;
  })(WatchlaterItemsOrder || {});
  function getPaths(obj, parentPath = "", result = []) {
    if (parentPath) {
      result.push(parentPath);
    }
    for (const key in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;
      const value = obj[key];
      const currentPath = parentPath ? `${parentPath}.${key}` : key;
      result.push(currentPath);
      if (value && typeof value === "object" && !Array.isArray(value) &&
!(value instanceof Date) && !(value instanceof RegExp)) {
        getPaths(value, currentPath, result);
      }
    }
    return [...new Set(result)];
  }
  function getObjectPaths(obj, parentPath = "") {
    const result = [];
    if (parentPath) {
      result.push(parentPath);
    }
    for (const key in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;
      const value = obj[key];
      const currentPath = parentPath ? `${parentPath}.${key}` : key;
      if (value && typeof value === "object" && !Array.isArray(value) && !(value instanceof Date) && !(value instanceof RegExp) && Object.getPrototypeOf(value) === Object.prototype) {
        result.push(currentPath);
        result.push(...getObjectPaths(value, currentPath));
      }
    }
    return [...new Set(result)];
  }
  function getLeafPaths(obj) {
    const allPaths = getPaths(obj);
    const objPaths = getObjectPaths(obj);
    return allPaths.filter((p2) => !objPaths.includes(p2));
  }
  const ToastClassNames = {
    default: "fixed left-50% top-50% z-gate-toast max-w-450px min-w-200px w-[max-content] translate-x--50% translate-y--50% whitespace-pre-wrap rounded-6px bg-gate-primary px-24px py-12px text-14px text-white",
    singleLine: "text-center"
  };
  function toast(msg, duration2 = 2e3, container = document.body) {
    const div = document.createElement("div");
    div.textContent = msg;
    const isSingleLine = !msg.includes("\n") && !msg.includes("<br");
    div.className = clsx(APP_CLS_ROOT, ToastClassNames.default, isSingleLine && ToastClassNames.singleLine);
    container.appendChild(div);
    setTimeout(() => div.remove(), duration2);
  }
  function toastRequestFail() {
    return toast(REQUEST_FAIL_MSG);
  }
  var msExports = requireMs();
  const ms = getDefaultExportFromCjs(msExports);
  var isAbsoluteURL;
  var hasRequiredIsAbsoluteURL;
  function requireIsAbsoluteURL() {
    if (hasRequiredIsAbsoluteURL) return isAbsoluteURL;
    hasRequiredIsAbsoluteURL = 1;
    isAbsoluteURL = function isAbsoluteURL2(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
    return isAbsoluteURL;
  }
  var combineURLs;
  var hasRequiredCombineURLs;
  function requireCombineURLs() {
    if (hasRequiredCombineURLs) return combineURLs;
    hasRequiredCombineURLs = 1;
    combineURLs = function combineURLs2(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
    return combineURLs;
  }
  var buildFullPath$1;
  var hasRequiredBuildFullPath;
  function requireBuildFullPath() {
    if (hasRequiredBuildFullPath) return buildFullPath$1;
    hasRequiredBuildFullPath = 1;
    var isAbsoluteURL2 = requireIsAbsoluteURL();
    var combineURLs2 = requireCombineURLs();
    buildFullPath$1 = function buildFullPath2(baseURL, requestedURL, allowAbsoluteUrls) {
      var isRelativeURL = !isAbsoluteURL2(requestedURL);
      if (baseURL && (isRelativeURL || allowAbsoluteUrls === false)) {
        return combineURLs2(baseURL, requestedURL);
      }
      return requestedURL;
    };
    return buildFullPath$1;
  }
  var buildFullPathExports = requireBuildFullPath();
  const buildFullPath = getDefaultExportFromCjs(buildFullPathExports);
  var bind;
  var hasRequiredBind;
  function requireBind() {
    if (hasRequiredBind) return bind;
    hasRequiredBind = 1;
    bind = function bind2(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    };
    return bind;
  }
  var utils$1;
  var hasRequiredUtils;
  function requireUtils() {
    if (hasRequiredUtils) return utils$1;
    hasRequiredUtils = 1;
    var bind2 = requireBind();
    var toString2 = Object.prototype.toString;
    var kindOf = function(cache2) {
      return function(thing) {
        var str = toString2.call(thing);
        return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
      };
    }( Object.create(null));
    function kindOfTest(type) {
      type = type.toLowerCase();
      return function isKindOf(thing) {
        return kindOf(thing) === type;
      };
    }
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString2(val) {
      return typeof val === "string";
    }
    function isNumber2(val) {
      return typeof val === "number";
    }
    function isObject2(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject2(val) {
      if (kindOf(val) !== "object") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isEmptyObject(val) {
      return val && Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
    }
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    function isFunction2(val) {
      return toString2.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject2(val) && isFunction2(val.pipe);
    }
    function isFormData(thing) {
      var pattern = "[object FormData]";
      return thing && (typeof FormData === "function" && thing instanceof FormData || toString2.call(thing) === pattern || isFunction2(thing.toString) && thing.toString() === pattern);
    }
    var isURLSearchParams = kindOfTest("URLSearchParams");
    function trim2(str) {
      return str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    }
    function isStandardBrowserEnv() {
      var product;
      if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
          fn.call(null, obj[i2], i2, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge2() {
      var result = {};
      function assignValue2(val, key) {
        if (isPlainObject2(result[key]) && isPlainObject2(val)) {
          result[key] = merge2(result[key], val);
        } else if (isPlainObject2(val)) {
          result[key] = merge2({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
        forEach(arguments[i2], assignValue2);
      }
      return result;
    }
    function extend(a2, b, thisArg) {
      forEach(b, function assignValue2(val, key) {
        if (thisArg && typeof val === "function") {
          a2[key] = bind2(val, thisArg);
        } else {
          a2[key] = val;
        }
      });
      return a2;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function inherits(constructor, superConstructor, props, descriptors) {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors);
      constructor.prototype.constructor = constructor;
      props && Object.assign(constructor.prototype, props);
    }
    function toFlatObject(sourceObj, destObj, filter, propFilter) {
      var props;
      var i2;
      var prop;
      var merged = {};
      destObj = destObj || {};
      if (sourceObj == null) return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i2 = props.length;
        while (i2-- > 0) {
          prop = props[i2];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && Object.getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    }
    function endsWith(str, searchString, position2) {
      str = String(str);
      if (position2 === void 0 || position2 > str.length) {
        position2 = str.length;
      }
      position2 -= searchString.length;
      var lastIndex = str.indexOf(searchString, position2);
      return lastIndex !== -1 && lastIndex === position2;
    }
    function toArray(thing) {
      if (!thing) return null;
      if (isArray(thing)) return thing;
      var i2 = thing.length;
      if (!isNumber2(i2)) return null;
      var arr = new Array(i2);
      while (i2-- > 0) {
        arr[i2] = thing[i2];
      }
      return arr;
    }
    var isTypedArray2 = function(TypedArray) {
      return function(thing) {
        return TypedArray && thing instanceof TypedArray;
      };
    }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
    function forEachEntry(obj, fn) {
      var generator = obj && obj[Symbol.iterator];
      var iterator2 = generator.call(obj);
      var result;
      while ((result = iterator2.next()) && !result.done) {
        var pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    }
    function matchAll(regExp, str) {
      var matches;
      var arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    }
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var hasOwnProperty = function resolver(_hasOwnProperty) {
      return function(obj, prop) {
        return _hasOwnProperty.call(obj, prop);
      };
    }(Object.prototype.hasOwnProperty);
    utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString: isString2,
      isNumber: isNumber2,
      isObject: isObject2,
      isPlainObject: isPlainObject2,
      isEmptyObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction: isFunction2,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge: merge2,
      extend,
      trim: trim2,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      isTypedArray: isTypedArray2,
      isFileList,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty
    };
    return utils$1;
  }
  var AxiosError_1;
  var hasRequiredAxiosError;
  function requireAxiosError() {
    if (hasRequiredAxiosError) return AxiosError_1;
    hasRequiredAxiosError = 1;
    var utils2 = requireUtils();
    function AxiosError2(message2, code, config, request2, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message2;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request2 && (this.request = request2);
      response && (this.response = response);
    }
    utils2.inherits(AxiosError2, Error, {
      toJSON: function toJSON() {
        return {
message: this.message,
          name: this.name,
description: this.description,
          number: this.number,
fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype = AxiosError2.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
].forEach(function(code) {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError2, descriptors);
    Object.defineProperty(prototype, "isAxiosError", { value: true });
    AxiosError2.from = function(error, code, config, request2, response, customProps) {
      var axiosError = Object.create(prototype);
      utils2.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      });
      AxiosError2.call(axiosError, error.message, code, config, request2, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    AxiosError_1 = AxiosError2;
    return AxiosError_1;
  }
  var settle$1;
  var hasRequiredSettle;
  function requireSettle() {
    if (hasRequiredSettle) return settle$1;
    hasRequiredSettle = 1;
    var AxiosError2 = requireAxiosError();
    settle$1 = function settle2(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError2(
          "Request failed with status code " + response.status,
          [AxiosError2.ERR_BAD_REQUEST, AxiosError2.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    };
    return settle$1;
  }
  var settleExports = requireSettle();
  const settle = getDefaultExportFromCjs(settleExports);
  var browser;
  var hasRequiredBrowser;
  function requireBrowser() {
    if (hasRequiredBrowser) return browser;
    hasRequiredBrowser = 1;
    browser = typeof self === "object" ? self.FormData : window.FormData;
    return browser;
  }
  var FormData$1;
  var hasRequiredFormData;
  function requireFormData() {
    if (hasRequiredFormData) return FormData$1;
    hasRequiredFormData = 1;
    FormData$1 = requireBrowser();
    return FormData$1;
  }
  var toFormData_1;
  var hasRequiredToFormData;
  function requireToFormData() {
    if (hasRequiredToFormData) return toFormData_1;
    hasRequiredToFormData = 1;
    var utils2 = requireUtils();
    var AxiosError2 = requireAxiosError();
    var envFormData = requireFormData();
    function isVisitable(thing) {
      return utils2.isPlainObject(thing) || utils2.isArray(thing);
    }
    function removeBrackets(key) {
      return utils2.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path) return key;
      return path.concat(key).map(function each(token2, i2) {
        token2 = removeBrackets(token2);
        return !dots && i2 ? "[" + token2 + "]" : token2;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils2.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils2.toFlatObject(utils2, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function isSpecCompliant(thing) {
      return thing && utils2.isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator];
    }
    function toFormData(obj, formData, options) {
      if (!utils2.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new (envFormData || FormData)();
      options = utils2.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils2.isUndefined(source[option]);
      });
      var metaTokens = options.metaTokens;
      var visitor = options.visitor || defaultVisitor;
      var dots = options.dots;
      var indexes = options.indexes;
      var _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      var useBlob = _Blob && isSpecCompliant(formData);
      if (!utils2.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null) return "";
        if (utils2.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils2.isBlob(value)) {
          throw new AxiosError2("Blob is not supported. Use a Buffer instead.");
        }
        if (utils2.isArrayBuffer(value) || utils2.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        var arr = value;
        if (value && !path && typeof value === "object") {
          if (utils2.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils2.isArray(value) && isFlatArray(value) || (utils2.isFileList(value) || utils2.endsWith(key, "[]") && (arr = utils2.toArray(value)))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils2.isUndefined(el) || el === null) && formData.append(
indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      var stack = [];
      var exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils2.isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils2.forEach(value, function each(el, key) {
          var result = !(utils2.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils2.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils2.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    toFormData_1 = toFormData;
    return toFormData_1;
  }
  var AxiosURLSearchParams_1;
  var hasRequiredAxiosURLSearchParams;
  function requireAxiosURLSearchParams() {
    if (hasRequiredAxiosURLSearchParams) return AxiosURLSearchParams_1;
    hasRequiredAxiosURLSearchParams = 1;
    var toFormData = requireToFormData();
    function encode(str) {
      var charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'\(\)~]|%20|%00/g, function replacer(match2) {
        return charMap[match2];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append2(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      var _encode = encoder ? function(value) {
        return encoder.call(this, value, encode);
      } : encode;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    AxiosURLSearchParams_1 = AxiosURLSearchParams;
    return AxiosURLSearchParams_1;
  }
  var buildURL$1;
  var hasRequiredBuildURL;
  function requireBuildURL() {
    if (hasRequiredBuildURL) return buildURL$1;
    hasRequiredBuildURL = 1;
    var utils2 = requireUtils();
    var AxiosURLSearchParams = requireAxiosURLSearchParams();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    buildURL$1 = function buildURL2(url, params, options) {
      if (!params) {
        return url;
      }
      var hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      var _encode = options && options.encode || encode;
      var serializeFn = options && options.serialize;
      var serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils2.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
    return buildURL$1;
  }
  var buildURLExports = requireBuildURL();
  const buildURL = getDefaultExportFromCjs(buildURLExports);
  var parseHeaders$1;
  var hasRequiredParseHeaders;
  function requireParseHeaders() {
    if (hasRequiredParseHeaders) return parseHeaders$1;
    hasRequiredParseHeaders = 1;
    var utils2 = requireUtils();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    parseHeaders$1 = function parseHeaders2(headers) {
      var parsed2 = {};
      var key;
      var val;
      var i2;
      if (!headers) {
        return parsed2;
      }
      utils2.forEach(headers.split("\n"), function parser(line2) {
        i2 = line2.indexOf(":");
        key = utils2.trim(line2.slice(0, i2)).toLowerCase();
        val = utils2.trim(line2.slice(i2 + 1));
        if (key) {
          if (parsed2[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed2[key] = (parsed2[key] ? parsed2[key] : []).concat([val]);
          } else {
            parsed2[key] = parsed2[key] ? parsed2[key] + ", " + val : val;
          }
        }
      });
      return parsed2;
    };
    return parseHeaders$1;
  }
  var parseHeadersExports = requireParseHeaders();
  const parseHeaders = getDefaultExportFromCjs(parseHeadersExports);
  var utilsExports = requireUtils();
  const utils = getDefaultExportFromCjs(utilsExports);
  function xhrAdapter(config) {
    return new Promise((resolve, reject) => {
      let requestData = config.data;
      const requestHeaders = config.headers ?? {};
      if (utils.isFormData(requestData)) {
        delete requestHeaders["Content-Type"];
      }
      if (config.auth) {
        const username = config.auth.username || "";
        const password = config.auth.password || "";
        requestHeaders.Authorization = "Basic " + Buffer.from(username + ":" + password).toString("base64");
      }
      const onerror = function handleError() {
        reject(new axios.AxiosError("Network Error", axios.AxiosError.ERR_NETWORK, config));
      };
      const ontimeout = function handleTimeout() {
        reject(new axios.AxiosError("timeout of " + config.timeout + "ms exceeded", axios.AxiosError.ECONNABORTED, config));
      };
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
          delete requestHeaders[key];
        }
      });
      if (requestData === void 0) {
        requestData = null;
      }
      const onload = function handleLoad(resp) {
        const responseHeaders = "responseHeaders" in resp ? parseHeaders(resp.responseHeaders) : {};
        const responseData = !config.responseType || config.responseType === "text" ? resp.responseText : resp.response;
        const response = {
          data: responseData,
          status: resp.status,
          statusText: resp.statusText,
          headers: responseHeaders,
          config,
          request: {
responseURL: resp.finalUrl,
            status: resp.status,
            statusText: resp.statusText,
            responseXML: null
          }
        };
        settle(resolve, reject, response);
      };
      if (config.cancelToken) {
        config.cancelToken.promise.then(function onCanceled(cancel) {
          reject(cancel);
        });
      }
      let responseType;
      if (config.responseType && config.responseType !== "json") {
        responseType = config.responseType;
      }
      const method = config.method.toUpperCase();
      if (method === "UNLINK" || method === "PURGE" || method === "LINK") {
        reject(new axios.AxiosError(`${method} is not a supported method by GM.xmlHttpRequest`));
      } else {
        GM.xmlHttpRequest({
          method,
          url: buildURL(buildFullPath(config.baseURL, config.url), config.params, config.paramsSerializer),
          headers: Object.fromEntries(Object.entries(requestHeaders).map(([key, val]) => [key, val.toString()])),
          responseType,
          data: requestData,
          timeout: config.timeout,
          ontimeout,
          onload,
          onerror
        });
      }
    });
  }
  const genDate = () => dayjs().format("YYYY-MM-DD");
  function dailyCache(namespace) {
    async function cleanUp() {
      const date = genDate();
      const keys = await GM.listValues();
      keys.filter((k) => k.startsWith(`${namespace}:`) && k !== `${namespace}:${date}`).forEach((k) => GM.deleteValue(k));
    }
    cleanUp();
    return {
      async set(val) {
        cleanUp();
        await GM.setValue(`${namespace}:${genDate()}`, val);
      },
      get() {
        cleanUp();
        return GM.getValue(`${namespace}:${genDate()}`);
      }
    };
  }
  const copyProperty = (to, from2, property, ignoreNonConfigurable) => {
    if (property === "length" || property === "prototype") {
      return;
    }
    if (property === "arguments" || property === "caller") {
      return;
    }
    const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
    const fromDescriptor = Object.getOwnPropertyDescriptor(from2, property);
    if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
      return;
    }
    Object.defineProperty(to, property, fromDescriptor);
  };
  const canCopyProperty = function(toDescriptor, fromDescriptor) {
    return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
  };
  const changePrototype = (to, from2) => {
    const fromPrototype = Object.getPrototypeOf(from2);
    if (fromPrototype === Object.getPrototypeOf(to)) {
      return;
    }
    Object.setPrototypeOf(to, fromPrototype);
  };
  const wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
  const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
  const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
  const changeToString = (to, from2, name) => {
    const withName = name === "" ? "" : `with ${name.trim()}() `;
    const newToString = wrappedToString.bind(null, withName, from2.toString());
    Object.defineProperty(newToString, "name", toStringName);
    const { writable, enumerable, configurable } = toStringDescriptor;
    Object.defineProperty(to, "toString", { value: newToString, writable, enumerable, configurable });
  };
  function mimicFunction(to, from2, { ignoreNonConfigurable = false } = {}) {
    const { name } = to;
    for (const property of Reflect.ownKeys(from2)) {
      copyProperty(to, from2, property, ignoreNonConfigurable);
    }
    changePrototype(to, from2);
    changeToString(to, from2, name);
    return to;
  }
  const cacheStore = new WeakMap();
  function pMemoize(fn, options) {
    const defaultCacheKey = ([firstArgument]) => firstArgument;
    const { cacheKey: cacheKey2 = defaultCacheKey, cache: cache2 = new Map() } = options ?? {};
    const promiseCache = new Map();
    const memoized = function(...arguments_) {
      const key = cacheKey2(arguments_);
      if (promiseCache.has(key)) {
        return promiseCache.get(key);
      }
      const promise = (async () => {
        try {
          if (cache2 && await cache2.has(key)) {
            return await cache2.get(key);
          }
          const promise2 = fn.apply(this, arguments_);
          const result = await promise2;
          try {
            return result;
          } finally {
            if (cache2) {
              const allow = options?.shouldCache ? await options.shouldCache(result, { key, argumentsList: arguments_ }) : true;
              if (allow) {
                await cache2.set(key, result);
              }
            }
          }
        } finally {
          promiseCache.delete(key);
        }
      })();
      promiseCache.set(key, promise);
      return promise;
    };
    mimicFunction(memoized, fn, {
      ignoreNonConfigurable: true
    });
    cacheStore.set(memoized, cache2);
    return memoized;
  }
  function reusePendingPromise(fn, generateKey) {
    generateKey ??= (...args) => JSON.stringify(args);
    return pMemoize(fn, {
      cache: false,
      cacheKey(args) {
        return generateKey(...args);
      }
    });
  }
  async function encWbi(_params) {
    const {
      img_key,
      sub_key
    } = await getWbiKeys();
    const mixin_key = getMixinKey(img_key + sub_key);
    const wts = Math.round(Date.now() / 1e3);
    const params = {
      ..._params,
      wts
    };
    const chr_filter = /[!'()*]/g;
    const query = Object.keys(params).sort().map((key) => {
      return `${encodeURIComponent(key)}=${encodeURIComponent(
params[key].toString().replaceAll(chr_filter, "")
    )}`;
    }).join("&");
    const wbi_sign = sparkMd5.hash(query + mixin_key);
    return {
      ...params,
      wts,
      w_rid: wbi_sign
    };
  }
  const keysCache = dailyCache("wbi-keys");
  const getWbiKeys = reusePendingPromise(async function() {
    const cached = await keysCache.get();
    const shouldReuse = cached?.val && cached?.ts && Date.now() - cached.ts <= ms("6h");
    if (shouldReuse) return cached.val;
    return fetchWbiKeys();
  });
  async function fetchWbiKeys() {
    const res = await axios.get("/x/web-interface/nav", {
      baseURL: HOST_API
    });
    const json = res.data;
    const img_url = json.data.wbi_img.img_url;
    const sub_url = json.data.wbi_img.sub_url;
    const keys = {
      img_key: img_url.slice(img_url.lastIndexOf("/") + 1, img_url.lastIndexOf(".")),
      sub_key: sub_url.slice(sub_url.lastIndexOf("/") + 1, sub_url.lastIndexOf("."))
    };
    await keysCache.set({
      val: keys,
      ts: Date.now()
    });
    return keys;
  }
  const mixinKeyEncTab = [46, 47, 18, 2, 53, 8, 23, 32, 15, 50, 10, 31, 58, 3, 45, 35, 27, 43, 5, 49, 33, 9, 42, 19, 29, 28, 14, 39, 12, 38, 41, 13, 37, 48, 7, 16, 24, 55, 40, 61, 26, 17, 0, 1, 60, 51, 30, 4, 22, 25, 54, 21, 56, 59, 6, 63, 57, 62, 11, 36, 20, 34, 44, 52];
  function getMixinKey(orig) {
    return mixinKeyEncTab.map((n2) => orig[n2]).join("").slice(0, 32);
  }
  function appSign(params, appkey2, appsec2) {
    params.appkey = appkey2;
    const searchParams2 = new URLSearchParams(params);
    searchParams2.sort();
    return sparkMd5.hash(searchParams2.toString() + appsec2);
  }
  const request = axios.create({
    baseURL: HOST_API,
    withCredentials: true
  });
  request.interceptors.request.use(async function(config) {
    config.params ||= {};
    if (config.url?.includes("/wbi/") && !(config.params.w_rid || config.params.wts)) {
      config.params = await encWbi(config.params);
    }
    return config;
  });
  function isWebApiSuccess(json) {
    return json?.code === 0 && (json?.message === "0" || json?.message === "success");
  }
  const gmrequest = axios.create({
adapter: xhrAdapter
  });
  const appkey = TVKeyInfo.appkey;
  const appsec = TVKeyInfo.appsec;
  gmrequest.interceptors.request.use(function(config) {
    config.params = {
      appkey,
      access_key: settings.accessKey || "",
      ...config.params
    };
    config.params.sign = appSign(config.params, appkey, appsec);
    return config;
  });
  gmrequest.interceptors.response.use((res) => {
    if (res.config.responseType === "json" && res.data && res.data instanceof ArrayBuffer) {
      const decoder = new TextDecoder();
      const u8arr = new Uint8Array(res.data);
      const text = decoder.decode(u8arr);
      res.data = text;
      try {
        res.data = JSON.parse(text);
      } catch {
      }
    }
    return res;
  });
  function parseCookie() {
    const cookies = {};
    document.cookie.split(";").map((pair) => pair.trim()).filter(Boolean).forEach((pair) => {
      const [key, val] = pair.split("=").map((s2) => s2.trim()).filter(Boolean);
      if (!key) return;
      cookies[key] = val;
    });
    return cookies;
  }
  function getCsrfToken() {
    const csrfToken = parseCookie().bili_jct;
    if (!csrfToken) {
      toast("找不到 csrf token, 请检查是否登录");
      throw new Error("找不到 csrf token, 请检查是否登录");
    }
    return csrfToken;
  }
  function getUid() {
    return parseCookie().DedeUserID;
  }
  function getHasLogined() {
    const cookies = parseCookie();
    return !!cookies.DedeUserID;
  }
  const $loginState = valtioFactory(() => {
    return {
      cookie: document.cookie,
      logined: getHasLogined()
    };
  });
  function checkLoginStatus() {
    $loginState.update();
    return $loginState.state.value.logined;
  }
  function useHasLogined() {
    return $loginState.use().logined;
  }
  async function listAll() {
    const json = (await request.get("https://member.bilibili.com/x/web/draft/list")).data;
    const drafts = json.artlist?.drafts || [];
    return drafts;
  }
  async function addupdate(payload) {
    const form = new URLSearchParams({
      title: "",
      banner_url: "",
      content: "",
      summary: "",
      words: "0",
      category: "15",
      tid: "0",
      reprint: "0",
      tags: "",
      image_urls: "",
      origin_image_urls: "",
      dynamic_intro: "",
      media_id: "0",
      spoiler: "0",
      original: "0",
      top_video_bvid: "",
      aid: "",
      csrf: getCsrfToken(),
      ...payload
    });
    const json = (await request.post("/x/article/creative/draft/addupdate", form)).data;
    const aid = json?.data?.aid?.toString();
    const success = isWebApiSuccess(json);
    if (!success) {
      toast(json.message || "addupdate error");
    }
    return {
      success,
      aid
    };
  }
  async function draftView(aid) {
    const json = (await request.get("/x/article/creative/draft/view", {
      params: {
        aid
      }
    })).data;
    return json?.data?.content || "";
  }
  class BilibiliArticleDraft {
    title;
    constructor(title) {
      this.title = title;
    }
    getData = async () => {
      const {
        title
      } = this;
      const allDrafts = await listAll();
      const draft = allDrafts.find((d2) => d2.title === title);
      if (!draft) {
        const {
          success,
          aid
        } = await addupdate({
          title
        });
        return;
      }
      const content = await draftView(draft.id);
      const parser = new DOMParser();
      const parsed2 = parser.parseFromString(content, "text/html");
      const text = (parsed2.body.textContent || "").trim();
      if (!text) return;
      try {
        return JSON.parse(text);
      } catch {
        return;
      }
    };

_aid;
    setData = async (data2) => {
      const {
        title
      } = this;
      if (!this._aid) {
        const allDrafts = await listAll();
        const draft = allDrafts.find((d2) => d2.title === title);
        if (!draft) {
          const {
            success: success2,
            aid: newDraftAid
          } = await addupdate({
            title
          });
          if (!success2) return false;
          this._aid = newDraftAid;
        } else {
          this._aid = draft.id.toString();
        }
      }
      const dataStr = JSON.stringify(data2);
      const {
        success
      } = await addupdate({
        aid: this._aid,
        title,
        content: `<p>${dataStr}</p>`,
        words: dataStr.length.toString()
      });
      return success;
    };
  }
  const debug$g = baseDebug.extend("settings");
  const articleDraft = new BilibiliArticleDraft(APP_NAME);
  const privateKeys = ["accessKey", "accessKeyExpireAt"];
  const getBackupOmitPaths = () => [
    ...privateKeys,
    ...internalBooleanPaths,
"backupSettingsToArticleDraft",
"fav.addSeparator",
    "watchlaterAddSeparator",
    "watchlaterItemsOrder",
    "popularWeeklyUseShuffle",
    "popularGeneralUseAnonymous"
  ];
  const restoreOmitPaths = [
    ...privateKeys,
"backupSettingsToArticleDraft"
  ];
  let HAS_RESTORED_SETTINGS = false;
  function set_HAS_RESTORED_SETTINGS(val) {
    HAS_RESTORED_SETTINGS = val;
  }
  let lastBackupVal;
  const setDataThrottled = throttle$1(articleDraft.setData, ms("5s"));
  async function saveToDraft(val) {
    if (!val.backupSettingsToArticleDraft) return;
    if (HAS_RESTORED_SETTINGS) return;
    const {
      pickedSettings: currentBackupVal
    } = pickSettings(val, allowedLeafSettingsPaths, getBackupOmitPaths());
    const shouldBackup = !lastBackupVal || !isEqual$1(lastBackupVal, currentBackupVal);
    if (!shouldBackup) return;
    try {
      await setDataThrottled(currentBackupVal);
      lastBackupVal = currentBackupVal;
      debug$g("backup to article draft complete");
    } catch (e2) {
      console.error(e2.stack || e2);
    }
  }
  const debug$f = baseDebug.extend("settings");
  const initialSettings = {
    accessKey: "",
    accessKeyExpireAt: 0,
useNarrowMode: false,


pureRecommend: true,
appRecommend: {
      addOtherTabContents: false
},

showModalFeedOnLoad: false,
showModalFeedEntry: false,
modalFeedFullScreen: false,
videoCard: {
actions: {
        openInPipWindow: false,
        showLargePreview: true
      },
videoPreview: {
        useMp4: true,
useScale: false,
useVideoCardAsTrigger: false,
usePreferredCdn: true,
        addTo: {
          searchPage: true
        }
      }
    },
autoPreviewWhenKeyboardSelect: false,
autoPreviewWhenHover: true,

autoPreviewUpdateInterval: 700,
useDelayForHover: false,
dynamicFeed: {
      showLive: true,
followGroup: {
        enabled: true,
forceUseMergeTimelineIds: []
      },
      whenViewAll: {
        enableHideSomeContents: false,
hideIds: []
},
      advancedSearch: false,
      __internal: {
        cacheAllItemsEntry: false,
        cacheAllItemsUpMids: [],
externalSearchInput: false
}
    },
watchlaterAddSeparator: true,
watchlaterItemsOrder: WatchlaterItemsOrder.AddTimeDesc,
watchlaterUseNormalVideoUrl: false,

fav: {
addSeparator: true,
excludedFolderIds: [],
useCustomFavPicker: {
        onPlayPage: false
      }
    },
popularGeneralUseAnonymous: false,

popularWeeklyUseShuffle: false,


spaceUpload: {
      showVol: false
    },
filter: {
      enabled: true,
minDuration: {
        enabled: false,
        value: 60
},
minPlayCount: {
        enabled: false,
        value: 1e4
      },
minDanmakuCount: {
        enabled: false,
        value: 10
      },
exemptForFollowed: {
        video: true,
picture: true
      },
hideGotoTypePicture: false,
      hideGotoTypeBangumi: false,
      byAuthor: {
        enabled: false,
        keywords: []
      },
      byTitle: {
        enabled: false,
        keywords: []
      }
    },
style: {
      general: {
        popoverBorderColorUseColorPrimary: false
      },
      pureRecommend: {
useStickyTabbar: true,
stickyTabbarShadow: false,
useCustomGrid: true,
useWhiteBackground: true,
hideTopChannel: false,
cardDisplay: ECardDisplay.Grid
      },
      videoCard: {

useBorder: true,
        useBorderOnlyOnHover: true,
        useBoxShadow: false
      }
    },
theme: "",
    colorPickerThemeSelectedColor: "",


backupSettingsToArticleDraft: false,
videoLinkOpenMode: VideoLinkOpenMode.Normal,
    pipWindow: {
      defaultLocked: true,
autoWebFullscreen: true
},
hidingTabKeys: [ETab.KeepFollowOnly, ETab.Live],
    customTabKeysOrder: [],
multiSelect: {
      clearWhenExit: true,
      showIcon: true
    },
__internalEnableCopyBvidInfo: false,
__internalAddCopyBvidButton: false,
    __internalHotSubUseDropdown: false,
    __internalShowGridListSwitcher: false,
    __internalRecTabRenderAsSegments: false
  };
  const settings = proxy(cloneDeep(initialSettings));
  const allowedLeafSettingsPaths = getLeafPaths(initialSettings);
  const internalBooleanPaths = allowedLeafSettingsPaths.filter((p2) => p2.includes("__internal") && typeof get(initialSettings, p2) === "boolean");
  debug$f("allowedLeafSettingsPaths = %O, internalBooleanPaths = %O", allowedLeafSettingsPaths, internalBooleanPaths);
  function useSettingsSnapshot() {
    return useSnapshot(settings);
  }
  function getSettingsSnapshot() {
    return snapshot(settings);
  }
  const storageKey$1 = `settings`;
  async function __pickSettingsFromGmStorage() {
    const saved = await GM.getValue(storageKey$1);
    if (!saved || typeof saved !== "object") return {};
    runSettingsMigration(saved);
    return pickSettings(saved, allowedLeafSettingsPaths).pickedSettings;
  }
  async function loadAndSetup() {
    const val = await __pickSettingsFromGmStorage();
    updateSettings(val);
    subscribe$3(settings, () => {
      _onSettingsChange();
    });
    reciveGmValueUpdatesFromOtherTab({
      storageKey: storageKey$1,
      setPersist(val2) {
        _persist = val2;
      },
      onUpdate(newValue) {
        updateSettings(newValue);
      }
    });
  }
  async function _onSettingsChange() {
    const snap = cloneDeep(snapshot(settings));
    await _saveToGmStorage(snap);
    await saveToDraft(snap);
  }
  let _persist = true;
  async function _saveToGmStorage(snap) {
    if (!_persist) return;
    await GM.setValue(storageKey$1, snap);
  }
  function updateSettings(payload) {
    const {
      pickedPaths
    } = pickSettings(payload, allowedLeafSettingsPaths);
    for (const p2 of pickedPaths) {
      const v = get(payload, p2);
      set(settings, p2, v);
    }
  }
  function resetSettings() {
    return updateSettings(initialSettings);
  }
  function runSettingsMigration(val) {
    if (!val) return;
    const config = [
      ["dynamicFeed.showLive", "dynamicFeedShowLive"],
      ["dynamicFeed.followGroup.enabled", "dynamicFeedFollowGroupEnabled"],
      ["dynamicFeed.followGroup.forceUseMergeTimelineIds", "dynamicFeedFollowGroupForceUseMergeTimelineIds"],
      ["dynamicFeed.whenViewAll.enableHideSomeContents", "dynamicFeedWhenViewAllEnableHideSomeContents"],
      ["dynamicFeed.whenViewAll.hideIds", "dynamicFeedWhenViewAllHideIds"],
      ["dynamicFeed.advancedSearch", "dynamicFeedAdvancedSearch"],
["fav.addSeparator", "favAddSeparator"],
      ["fav.excludedFolderIds", "favExcludedFolderIds"],
      ["filter.enabled", "filterEnabled"],
      ["filter.minPlayCount.enabled", "filterMinPlayCountEnabled"],
      ["filter.minPlayCount.value", "filterMinPlayCount"],
      ["filter.minDuration.enabled", "filterMinDurationEnabled"],
      ["filter.minDuration.value", "filterMinDuration"],
      ["filter.exemptForFollowed.video", "exemptForFollowedVideo"],
      ["filter.exemptForFollowed.picture", "exemptForFollowedPicture"],
      ["filter.hideGotoTypePicture", "filterOutGotoTypePicture"],
      ["filter.hideGotoTypeBangumi", "filterOutGotoTypeBangumi"],
      ["filter.byAuthor.enabled", "filterByAuthorNameEnabled"],
      ["filter.byAuthor.keywords", "filterByAuthorNameKeywords"],
      ["filter.byTitle.enabled", "filterByTitleEnabled"],
      ["filter.byTitle.keywords", "filterByTitleKeywords"],
["style.pureRecommend.useStickyTabbar", "styleUseStickyTabbarInPureRecommend"],
      ["style.pureRecommend.useCustomGrid", "styleUseCustomGrid"],
      ["style.pureRecommend.useWhiteBackground", "styleUseWhiteBackground"],
      ["style.pureRecommend.hideTopChannel", "styleHideTopChannel"],
      ["style.videoCard.useBorder", "styleUseCardBorder"],
      ["style.videoCard.useBorderOnlyOnHover", "styleUseCardBorderOnlyOnHover"],
      ["style.videoCard.useBoxShadow", "styleUseCardBoxShadow"],
["pipWindow.defaultLocked", "pipWindowDefaultLocked"]
    ];
    for (const [configPath, legacyConfigPath] of config) {
      const haveValue = (v) => !isNil(v);
      if (haveValue(get(val, configPath))) {
        continue;
      }
      if (!haveValue(get(val, legacyConfigPath))) {
        continue;
      }
      set(val, configPath, get(val, legacyConfigPath));
    }
  }
  function pickSettings(source, paths, omit2 = []) {
    const pickedSettings = {};
    const pickedPaths = paths.filter((p2) => allowedLeafSettingsPaths.includes(p2) && !omit2.includes(p2) && !isNil(get(source, p2)));
    pickedPaths.forEach((p2) => {
      const v = get(source, p2);
      set(pickedSettings, p2, v);
    });
    return {
      pickedPaths,
      pickedSettings
    };
  }
  function useSettingsInnerArray(path) {
    const snap = useSettingsSnapshot();
    return get(snap, path);
  }
  async function getNewestValueOfSettingsInnerArray(path) {
    const newest = await __pickSettingsFromGmStorage();
    return get(newest, path) || get(getSettingsSnapshot(), path);
  }
  function setSettingsInnerArray(path, value) {
    set(settings, path, value);
  }
  async function updateSettingsInnerArray(path, {
    add: add2,
    remove
  }) {
    const arr = await getNewestValueOfSettingsInnerArray(path);
    const s2 = new Set(arr);
    for (const x of add2 ?? []) s2.add(x);
    for (const x of remove ?? []) s2.delete(x);
    setSettingsInnerArray(path, Array.from(s2));
  }
  await( loadAndSetup());
  if (IN_BILIBILI_HOMEPAGE && settings.accessKey && settings.accessKeyExpireAt && Date.now() >= settings.accessKeyExpireAt) {
    toast("access_key 已过期, 请重新获取 !!!");
  }
  var client = {};
  var hasRequiredClient;
  function requireClient() {
    if (hasRequiredClient) return client;
    hasRequiredClient = 1;
    var m2 = require$$0;
    {
      client.createRoot = m2.createRoot;
      client.hydrateRoot = m2.hydrateRoot;
    }
    return client;
  }
  var clientExports = requireClient();
  function insertWithoutScoping(cache2, serialized) {
    if (cache2.inserted[serialized.name] === void 0) {
      return cache2.insert("", serialized, cache2.sheet, true);
    }
  }
  function merge(registered, css2, className) {
    var registeredStyles = [];
    var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
    if (registeredStyles.length < 2) {
      return className;
    }
    return rawClassName + css2(registeredStyles);
  }
  var createEmotion = function createEmotion2(options) {
    var cache2 = createCache(options);
    cache2.sheet.speedy = function(value) {
      this.isSpeedy = value;
    };
    cache2.compat = true;
    var css2 = function css3() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var serialized = serializeStyles(args, cache2.registered, void 0);
      insertStyles(cache2, serialized, false);
      return cache2.key + "-" + serialized.name;
    };
    var keyframes = function keyframes2() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      var serialized = serializeStyles(args, cache2.registered);
      var animation = "animation-" + serialized.name;
      insertWithoutScoping(cache2, {
        name: serialized.name,
        styles: "@keyframes " + animation + "{" + serialized.styles + "}"
      });
      return animation;
    };
    var injectGlobal = function injectGlobal2() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      var serialized = serializeStyles(args, cache2.registered);
      insertWithoutScoping(cache2, serialized);
    };
    var cx = function cx2() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return merge(cache2.registered, css2, classnames(args));
    };
    return {
      css: css2,
      cx,
      injectGlobal,
      keyframes,
      hydrate: function hydrate(ids2) {
        ids2.forEach(function(key) {
          cache2.inserted[key] = true;
        });
      },
      flush: function flush() {
        cache2.registered = {};
        cache2.inserted = {};
        cache2.sheet.flush();
      },
      sheet: cache2.sheet,
      cache: cache2,
      getRegisteredStyles: getRegisteredStyles.bind(null, cache2.registered),
      merge: merge.bind(null, cache2.registered, css2)
    };
  };
  var classnames = function classnames2(args) {
    var cls = "";
    for (var i2 = 0; i2 < args.length; i2++) {
      var arg = args[i2];
      if (arg == null) continue;
      var toAdd = void 0;
      switch (typeof arg) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(arg)) {
            toAdd = classnames2(arg);
          } else {
            toAdd = "";
            for (var k in arg) {
              if (arg[k] && k) {
                toAdd && (toAdd += " ");
                toAdd += k;
              }
            }
          }
          break;
        }
        default: {
          toAdd = arg;
        }
      }
      if (toAdd) {
        cls && (cls += " ");
        cls += toAdd;
      }
    }
    return cls;
  };
  var _createEmotion = createEmotion({
    key: "css"
  }), css$1 = _createEmotion.css, cache$4 = _createEmotion.cache;
  var jsx2 = function jsx3(type, props) {
    var args = arguments;
    if (props == null || !hasOwn.call(props, "css")) {
      return H__namespace.createElement.apply(void 0, args);
    }
    var argsLength = args.length;
    var createElementArgArray = new Array(argsLength);
    createElementArgArray[0] = Emotion$1;
    createElementArgArray[1] = createEmotionProps(type, props);
    for (var i2 = 2; i2 < argsLength; i2++) {
      createElementArgArray[i2] = args[i2];
    }
    return H__namespace.createElement.apply(null, createElementArgArray);
  };
  (function(_jsx) {
    var JSX;
(function(_JSX) {
    })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
  })(jsx2 || (jsx2 = {}));
  var Global = withEmotionCache(function(props, cache2) {
    var styles = props.styles;
    var serialized = serializeStyles([styles], void 0, H__namespace.useContext(ThemeContext));
    var sheetRef = H__namespace.useRef();
    useInsertionEffectWithLayoutFallback(function() {
      var key = cache2.key + "-global";
      var sheet = new cache2.sheet.constructor({
        key,
        nonce: cache2.sheet.nonce,
        container: cache2.sheet.container,
        speedy: cache2.sheet.isSpeedy
      });
      var rehydrating = false;
      var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
      if (cache2.sheet.tags.length) {
        sheet.before = cache2.sheet.tags[0];
      }
      if (node2 !== null) {
        rehydrating = true;
        node2.setAttribute("data-emotion", key);
        sheet.hydrate([node2]);
      }
      sheetRef.current = [sheet, rehydrating];
      return function() {
        sheet.flush();
      };
    }, [cache2]);
    useInsertionEffectWithLayoutFallback(function() {
      var sheetRefCurrent = sheetRef.current;
      var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
      if (rehydrating) {
        sheetRefCurrent[1] = false;
        return;
      }
      if (serialized.next !== void 0) {
        insertStyles(cache2, serialized.next, true);
      }
      if (sheet.tags.length) {
        var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
        sheet.before = element;
        sheet.flush();
      }
      cache2.insert("", serialized, sheet, false);
    }, [cache2, serialized.name]);
    return null;
  });
  function css() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return serializeStyles(args);
  }
  var zh_CN$6 = {};
  var interopRequireDefault = { exports: {} };
  var hasRequiredInteropRequireDefault;
  function requireInteropRequireDefault() {
    if (hasRequiredInteropRequireDefault) return interopRequireDefault.exports;
    hasRequiredInteropRequireDefault = 1;
    (function(module) {
      function _interopRequireDefault(e2) {
        return e2 && e2.__esModule ? e2 : {
          "default": e2
        };
      }
      module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(interopRequireDefault);
    return interopRequireDefault.exports;
  }
  var zh_CN$5 = {};
  var hasRequiredZh_CN$6;
  function requireZh_CN$6() {
    if (hasRequiredZh_CN$6) return zh_CN$5;
    hasRequiredZh_CN$6 = 1;
    Object.defineProperty(zh_CN$5, "__esModule", {
      value: true
    });
    zh_CN$5.default = void 0;
    var locale = {
items_per_page: "条/页",
      jump_to: "跳至",
      jump_to_confirm: "确定",
      page: "页",
prev_page: "上一页",
      next_page: "下一页",
      prev_5: "向前 5 页",
      next_5: "向后 5 页",
      prev_3: "向前 3 页",
      next_3: "向后 3 页",
      page_size: "页码"
    };
    zh_CN$5.default = locale;
    return zh_CN$5;
  }
  var zh_CN$4 = {};
  var zh_CN$3 = {};
  var zh_CN$2 = {};
  var objectSpread2 = { exports: {} };
  var defineProperty = { exports: {} };
  var toPropertyKey = { exports: {} };
  var _typeof = { exports: {} };
  var hasRequired_typeof;
  function require_typeof() {
    if (hasRequired_typeof) return _typeof.exports;
    hasRequired_typeof = 1;
    (function(module) {
      function _typeof2(o2) {
        "@babel/helpers - typeof";
        return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
          return typeof o3;
        } : function(o3) {
          return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o2);
      }
      module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(_typeof);
    return _typeof.exports;
  }
  var toPrimitive = { exports: {} };
  var hasRequiredToPrimitive;
  function requireToPrimitive() {
    if (hasRequiredToPrimitive) return toPrimitive.exports;
    hasRequiredToPrimitive = 1;
    (function(module) {
      var _typeof2 = require_typeof()["default"];
      function toPrimitive2(t2, r2) {
        if ("object" != _typeof2(t2) || !t2) return t2;
        var e2 = t2[Symbol.toPrimitive];
        if (void 0 !== e2) {
          var i2 = e2.call(t2, r2 || "default");
          if ("object" != _typeof2(i2)) return i2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === r2 ? String : Number)(t2);
      }
      module.exports = toPrimitive2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(toPrimitive);
    return toPrimitive.exports;
  }
  var hasRequiredToPropertyKey;
  function requireToPropertyKey() {
    if (hasRequiredToPropertyKey) return toPropertyKey.exports;
    hasRequiredToPropertyKey = 1;
    (function(module) {
      var _typeof2 = require_typeof()["default"];
      var toPrimitive2 = requireToPrimitive();
      function toPropertyKey2(t2) {
        var i2 = toPrimitive2(t2, "string");
        return "symbol" == _typeof2(i2) ? i2 : i2 + "";
      }
      module.exports = toPropertyKey2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(toPropertyKey);
    return toPropertyKey.exports;
  }
  var hasRequiredDefineProperty;
  function requireDefineProperty() {
    if (hasRequiredDefineProperty) return defineProperty.exports;
    hasRequiredDefineProperty = 1;
    (function(module) {
      var toPropertyKey2 = requireToPropertyKey();
      function _defineProperty(e2, r2, t2) {
        return (r2 = toPropertyKey2(r2)) in e2 ? Object.defineProperty(e2, r2, {
          value: t2,
          enumerable: true,
          configurable: true,
          writable: true
        }) : e2[r2] = t2, e2;
      }
      module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(defineProperty);
    return defineProperty.exports;
  }
  var hasRequiredObjectSpread2;
  function requireObjectSpread2() {
    if (hasRequiredObjectSpread2) return objectSpread2.exports;
    hasRequiredObjectSpread2 = 1;
    (function(module) {
      var defineProperty2 = requireDefineProperty();
      function ownKeys(e2, r2) {
        var t2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          r2 && (o2 = o2.filter(function(r3) {
            return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
          })), t2.push.apply(t2, o2);
        }
        return t2;
      }
      function _objectSpread2(e2) {
        for (var r2 = 1; r2 < arguments.length; r2++) {
          var t2 = null != arguments[r2] ? arguments[r2] : {};
          r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
            defineProperty2(e2, r3, t2[r3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
            Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
          });
        }
        return e2;
      }
      module.exports = _objectSpread2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(objectSpread2);
    return objectSpread2.exports;
  }
  var common = {};
  var hasRequiredCommon;
  function requireCommon() {
    if (hasRequiredCommon) return common;
    hasRequiredCommon = 1;
    Object.defineProperty(common, "__esModule", {
      value: true
    });
    common.commonLocale = void 0;
    common.commonLocale = {
      yearFormat: "YYYY",
      dayFormat: "D",
      cellMeridiemFormat: "A",
      monthBeforeYear: true
    };
    return common;
  }
  var hasRequiredZh_CN$5;
  function requireZh_CN$5() {
    if (hasRequiredZh_CN$5) return zh_CN$2;
    hasRequiredZh_CN$5 = 1;
    var _interopRequireDefault = requireInteropRequireDefault().default;
    Object.defineProperty(zh_CN$2, "__esModule", {
      value: true
    });
    zh_CN$2.default = void 0;
    var _objectSpread2 = _interopRequireDefault(requireObjectSpread2());
    var _common = requireCommon();
    var locale = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, _common.commonLocale), {}, {
      locale: "zh_CN",
      today: "今天",
      now: "此刻",
      backToToday: "返回今天",
      ok: "确定",
      timeSelect: "选择时间",
      dateSelect: "选择日期",
      weekSelect: "选择周",
      clear: "清除",
      week: "周",
      month: "月",
      year: "年",
      previousMonth: "上个月 (翻页上键)",
      nextMonth: "下个月 (翻页下键)",
      monthSelect: "选择月份",
      yearSelect: "选择年份",
      decadeSelect: "选择年代",
      previousYear: "上一年 (Control键加左方向键)",
      nextYear: "下一年 (Control键加右方向键)",
      previousDecade: "上一年代",
      nextDecade: "下一年代",
      previousCentury: "上一世纪",
      nextCentury: "下一世纪",
      yearFormat: "YYYY年",
      cellDateFormat: "D",
      monthBeforeYear: false
    });
    zh_CN$2.default = locale;
    return zh_CN$2;
  }
  var zh_CN$1 = {};
  var hasRequiredZh_CN$4;
  function requireZh_CN$4() {
    if (hasRequiredZh_CN$4) return zh_CN$1;
    hasRequiredZh_CN$4 = 1;
    Object.defineProperty(zh_CN$1, "__esModule", {
      value: true
    });
    zh_CN$1.default = void 0;
    const locale = {
      placeholder: "请选择时间",
      rangePlaceholder: ["开始时间", "结束时间"]
    };
    zh_CN$1.default = locale;
    return zh_CN$1;
  }
  var hasRequiredZh_CN$3;
  function requireZh_CN$3() {
    if (hasRequiredZh_CN$3) return zh_CN$3;
    hasRequiredZh_CN$3 = 1;
    var _interopRequireDefault = requireInteropRequireDefault().default;
    Object.defineProperty(zh_CN$3, "__esModule", {
      value: true
    });
    zh_CN$3.default = void 0;
    var _zh_CN = _interopRequireDefault(requireZh_CN$5());
    var _zh_CN2 = _interopRequireDefault( requireZh_CN$4());
    const locale = {
      lang: Object.assign({
        placeholder: "请选择日期",
        yearPlaceholder: "请选择年份",
        quarterPlaceholder: "请选择季度",
        monthPlaceholder: "请选择月份",
        weekPlaceholder: "请选择周",
        rangePlaceholder: ["开始日期", "结束日期"],
        rangeYearPlaceholder: ["开始年份", "结束年份"],
        rangeMonthPlaceholder: ["开始月份", "结束月份"],
        rangeQuarterPlaceholder: ["开始季度", "结束季度"],
        rangeWeekPlaceholder: ["开始周", "结束周"]
      }, _zh_CN.default),
      timePickerLocale: Object.assign({}, _zh_CN2.default)
    };
    locale.lang.ok = "确定";
    zh_CN$3.default = locale;
    return zh_CN$3;
  }
  var hasRequiredZh_CN$2;
  function requireZh_CN$2() {
    if (hasRequiredZh_CN$2) return zh_CN$4;
    hasRequiredZh_CN$2 = 1;
    var _interopRequireDefault = requireInteropRequireDefault().default;
    Object.defineProperty(zh_CN$4, "__esModule", {
      value: true
    });
    zh_CN$4.default = void 0;
    var _zh_CN = _interopRequireDefault( requireZh_CN$3());
    zh_CN$4.default = _zh_CN.default;
    return zh_CN$4;
  }
  var hasRequiredZh_CN$1;
  function requireZh_CN$1() {
    if (hasRequiredZh_CN$1) return zh_CN$6;
    hasRequiredZh_CN$1 = 1;
    var _interopRequireDefault = requireInteropRequireDefault().default;
    Object.defineProperty(zh_CN$6, "__esModule", {
      value: true
    });
    zh_CN$6.default = void 0;
    var _zh_CN = _interopRequireDefault(requireZh_CN$6());
    var _zh_CN2 = _interopRequireDefault( requireZh_CN$2());
    var _zh_CN3 = _interopRequireDefault( requireZh_CN$3());
    var _zh_CN4 = _interopRequireDefault( requireZh_CN$4());
    const typeTemplate = "${label}不是一个有效的${type}";
    const localeValues = {
      locale: "zh-cn",
      Pagination: _zh_CN.default,
      DatePicker: _zh_CN3.default,
      TimePicker: _zh_CN4.default,
      Calendar: _zh_CN2.default,
global: {
        placeholder: "请选择",
        close: "关闭"
      },
      Table: {
        filterTitle: "筛选",
        filterConfirm: "确定",
        filterReset: "重置",
        filterEmptyText: "无筛选项",
        filterCheckAll: "全选",
        filterSearchPlaceholder: "在筛选项中搜索",
        emptyText: "暂无数据",
        selectAll: "全选当页",
        selectInvert: "反选当页",
        selectNone: "清空所有",
        selectionAll: "全选所有",
        sortTitle: "排序",
        expand: "展开行",
        collapse: "关闭行",
        triggerDesc: "点击降序",
        triggerAsc: "点击升序",
        cancelSort: "取消排序"
      },
      Modal: {
        okText: "确定",
        cancelText: "取消",
        justOkText: "知道了"
      },
      Tour: {
        Next: "下一步",
        Previous: "上一步",
        Finish: "结束导览"
      },
      Popconfirm: {
        cancelText: "取消",
        okText: "确定"
      },
      Transfer: {
        titles: ["", ""],
        searchPlaceholder: "请输入搜索内容",
        itemUnit: "项",
        itemsUnit: "项",
        remove: "删除",
        selectCurrent: "全选当页",
        removeCurrent: "删除当页",
        selectAll: "全选所有",
        deselectAll: "取消全选",
        removeAll: "删除全部",
        selectInvert: "反选当页"
      },
      Upload: {
        uploading: "文件上传中",
        removeFile: "删除文件",
        uploadError: "上传错误",
        previewFile: "预览文件",
        downloadFile: "下载文件"
      },
      Empty: {
        description: "暂无数据"
      },
      Icon: {
        icon: "图标"
      },
      Text: {
        edit: "编辑",
        copy: "复制",
        copied: "复制成功",
        expand: "展开",
        collapse: "收起"
      },
      Form: {
        optional: "（可选）",
        defaultValidateMessages: {
          default: "字段验证错误${label}",
          required: "请输入${label}",
          enum: "${label}必须是其中一个[${enum}]",
          whitespace: "${label}不能为空字符",
          date: {
            format: "${label}日期格式无效",
            parse: "${label}不能转换为日期",
            invalid: "${label}是一个无效日期"
          },
          types: {
            string: typeTemplate,
            method: typeTemplate,
            array: typeTemplate,
            object: typeTemplate,
            number: typeTemplate,
            date: typeTemplate,
            boolean: typeTemplate,
            integer: typeTemplate,
            float: typeTemplate,
            regexp: typeTemplate,
            email: typeTemplate,
            url: typeTemplate,
            hex: typeTemplate
          },
          string: {
            len: "${label}须为${len}个字符",
            min: "${label}最少${min}个字符",
            max: "${label}最多${max}个字符",
            range: "${label}须在${min}-${max}字符之间"
          },
          number: {
            len: "${label}必须等于${len}",
            min: "${label}最小值为${min}",
            max: "${label}最大值为${max}",
            range: "${label}须在${min}-${max}之间"
          },
          array: {
            len: "须为${len}个${label}",
            min: "最少${min}个${label}",
            max: "最多${max}个${label}",
            range: "${label}数量须在${min}-${max}之间"
          },
          pattern: {
            mismatch: "${label}与模式不匹配${pattern}"
          }
        }
      },
      Image: {
        preview: "预览"
      },
      QRCode: {
        expired: "二维码过期",
        refresh: "点击刷新",
        scanned: "已扫描"
      },
      ColorPicker: {
        presetEmpty: "暂无",
        transparent: "无色",
        singleColor: "单色",
        gradientColor: "渐变色"
      }
    };
    zh_CN$6.default = localeValues;
    return zh_CN$6;
  }
  var zh_CN;
  var hasRequiredZh_CN;
  function requireZh_CN() {
    if (hasRequiredZh_CN) return zh_CN;
    hasRequiredZh_CN = 1;
    zh_CN = requireZh_CN$1();
    return zh_CN;
  }
  var zh_CNExports = requireZh_CN();
  const zhCN = getDefaultExportFromCjs(zh_CNExports);
  const appCustomFontId = "--bilibili-gate--font";
  const appVideoCardBorderRadiusId = "--bilibili-gate--video-card--border-radius";
  const appPrimaryColorId = "--bilibili-gate--primary-color";
  const appBorderColorId = "--bilibili-gate--border-color";
  const appTextColorId = "--bilibili-gate--text-color";
  const appBgId = "--bilibili-gate--bg";
  const appBgLv1Id = "--bilibili-gate--bg-lv1";
  const appBgLv2Id = "--bilibili-gate--bg-lv2";
  const appBgLv3Id = "--bilibili-gate--bg-lv3";
  const biliPink = "#ff6699";
  const appCustomFontValue = '"Alibaba PuHuiTi 3.0", "PingFang SC", HarmonyOS_Regular, "Helvetica Neue", "Microsoft YaHei", sans-serif';
  const appUsingFont = "var(--custom-font-family--options--font-family, var(--bilibili-gate--font))";
  const appClsRoot = "bilibili-gate-root";
  const appClsDark = "bilibili-gate-using-dark";
  const appClsDarkSelector = "html.bilibili-gate-using-dark";
  const zIndexRecHeader = "1001";
  const zIndexBaseModal = "10003";
  const zIndexAntdPopupBase = "11000";
  const zIndexVideoCardLargePreview = "11200";
  const zIndexVideoCardContextMenu = "11300";
  const zIndexToast = "90000";
  const cssVars = {
    appCustomFontId,
    appVideoCardBorderRadiusId,
    appPrimaryColorId,
    appBorderColorId,
    appTextColorId,
    appBgId,
    appBgLv1Id,
    appBgLv2Id,
    appBgLv3Id,
    biliPink,
    appCustomFontValue,
    appUsingFont,
    appClsRoot,
    appClsDark,
    appClsDarkSelector,
    zIndexRecHeader,
    zIndexBaseModal,
    zIndexAntdPopupBase,
    zIndexVideoCardLargePreview,
    zIndexVideoCardContextMenu,
    zIndexToast
  };
  const debug$e = baseDebug.extend("utility:dom");
  const DEFAULT_POLL_TIMEOUT = 10 * 1e3;
  const DEFAULT_POLL_INTERVAL = 200;
  async function poll$1(fn, options) {
    const interval = options?.interval ?? DEFAULT_POLL_INTERVAL;
    let timeout = options?.timeout ?? DEFAULT_POLL_TIMEOUT;
    if (timeout === 0) timeout = Infinity;
    const validate = options?.validate ?? ((val) => !isNil(val));
    const start = performance.now();
    let result = fn();
    while (!validate(result) && performance.now() - start < timeout) {
      await delay(interval);
      result = fn();
    }
    return result;
  }
  async function tryAction(selector, action2, moreOptions) {
    const pollTimeout = moreOptions?.pollTimeout ?? DEFAULT_POLL_TIMEOUT;
    const pollInterval = moreOptions?.pollInterval ?? DEFAULT_POLL_INTERVAL;
    const selectorPredicate = moreOptions?.selectorPredicate;
    const warnOnTimeout = moreOptions?.warnOnTimeout ?? false;
    const arr = await poll$1(() => {
      let arr2 = Array.from(document.querySelectorAll(selector));
      if (selectorPredicate) arr2 = arr2.filter(selectorPredicate);
      if (arr2.length) return arr2;
    }, {
      timeout: pollTimeout,
      interval: pollInterval
    });
    if (!arr?.length) {
      debug$e("tryAction: timeout for selector = `%s`", selector);
      if (warnOnTimeout) {
        appWarn("tryAction timeout, selector = `%s`", selector);
      }
      return;
    }
    debug$e("tryAction: selector=`%s` count=%s", selector, arr.length);
    for (const el of arr) {
      await Promise.resolve(action2(el));
    }
  }
  async function tryToRemove(selector, selectorPredicate, delayMs) {
    return tryAction(selector, (el) => el.remove(), {
      selectorPredicate,
      warnOnTimeout: false
    });
  }
  function shouldDisableShortcut() {
    const activeTagName = (document.activeElement?.tagName || "").toLowerCase();
    if (["input", "textarea"].includes(activeTagName)) {
      return true;
    }
    if (document.querySelector(".center-search__bar.is-focus")) {
      return true;
    }
    return false;
  }
  function getElementOffset(el, rect) {
    rect ??= el.getBoundingClientRect();
    const docElem = document.documentElement;
    return {
      top: rect.top + window.scrollY - docElem.clientTop,
      left: rect.left + window.scrollX - docElem.clientLeft
    };
  }
  function whenIdle(options) {
    return new Promise((resolve) => {
      if (typeof requestIdleCallback === "function") {
        requestIdleCallback(() => resolve(), options);
      } else {
        setTimeout(resolve);
      }
    });
  }
  let ORIGINAL_TITLE = "";
  function setPageTitle(title) {
    if (!ORIGINAL_TITLE) {
      ORIGINAL_TITLE = document.title;
    }
    document.title = `${title} - ${ORIGINAL_TITLE}`;
  }
  const DarkModeConfig = {
    Evolved: {
      getDetectEl: () => document.body,
      detect: (el) => el.classList.contains("dark"),
      trigger: '.custom-navbar-item[role="listitem"][data-name="darkMode"]',
      triggerInner: '.navbar-dark-mode[item="darkMode"]'
    },
    Bili: {
      getDetectEl: () => document.querySelector("#__css-map__"),
      detect: (el) => el.href.includes("dark"),
      isTrigger: (el) => {
        const a2 = el.closest(".avatar-panel-popover a.single-link-item");
        if (!a2) return false;
        return !!Array.from(a2.querySelectorAll(".link-title span")).find((span) => ["深色", "浅色"].includes(span.textContent || ""));
      }
    }
  };
  const detect = (item) => {
    const el = item.getDetectEl();
    if (!el) return false;
    return item.detect(el);
  };
  const $darkMode = valtioFactory(() => {
    return detect(DarkModeConfig.Bili) || detect(DarkModeConfig.Evolved) || document.body.classList.contains("bilibili-helper-dark-mode") || document.documentElement.classList.contains("dark");
  });
  function useIsDarkMode() {
    return $darkMode.use();
  }
  const onDarkModeChange = () => {
    $darkMode.get() ? document.documentElement.classList.add(appClsDark) : document.documentElement.classList.remove(appClsDark);
  };
  onDarkModeChange();
  subscribe$3($darkMode.state, onDarkModeChange);
  const ob = new MutationObserver(async () => {
    await delay(0);
    $darkMode.updateThrottled();
  });
  ob.observe(document.body, {
    attributes: true,
    attributeFilter: ["class"]
  });
  ob.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ["data-darkreader-scheme"]
  });
  deferBiliDefaultDetect();
  async function deferBiliDefaultDetect() {
    const link = await poll$1(DarkModeConfig.Bili.getDetectEl);
    if (!link) return;
    ob.observe(link, {
      attributes: true
    });
  }
  document.addEventListener("click", darkModeTriggerClickHandler, {
    passive: true
  });
  async function darkModeTriggerClickHandler(e2) {
    const t2 = e2.target;
    const isClickOnTrigger = DarkModeConfig.Bili.isTrigger(t2) || t2.closest(DarkModeConfig.Evolved.trigger);
    if (!isClickOnTrigger) return;
    await delay(0);
    $darkMode.updateThrottled();
  }
  window.addEventListener("unload", () => {
    ob.disconnect();
    document.removeEventListener("click", darkModeTriggerClickHandler);
  });
  const debug$d = baseDebug.extend("components:css-vars");
  debug$d(":export = %O", cssVars);
  const cssVar = (id) => {
    if (!id.startsWith("--")) id = `--${id}`;
    return `var(${id})`;
  };
  const videoCardBorderRadiusValue = cssVar(cssVars.appVideoCardBorderRadiusId);
  const primaryColorValue = cssVar(cssVars.appPrimaryColorId);
  const borderColorValue = cssVar(cssVars.appBorderColorId);
  cssVar(cssVars.appTextColorId);
  const bgValue = cssVar(cssVars.appBgId);
  const bgLv1Value = cssVar(cssVars.appBgLv1Id);
  const bgLv2Value = cssVar(cssVars.appBgLv2Id);
  cssVar(cssVars.appBgLv3Id);
  const buttonOpenCss = {
    name: "rmyi3a",
    styles: "color:var(--ant-button-default-hover-color);border-color:var(--ant-button-default-hover-border-color);background:var(--ant-button-default-hover-bg)"
  };
  function useButtonOpenColor() {
    return antd.theme.useToken().token.colorPrimaryHover;
  }
  function usePopoverBorderColor() {
    const {
      popoverBorderColorUseColorPrimary
    } = useSnapshot(settings.style.general);
    const buttonOpenColor = useButtonOpenColor();
    return popoverBorderColorUseColorPrimary ? buttonOpenColor : borderColorValue;
  }
  function useAntLinkCss() {
    const {
      colorLink,
      colorLinkActive,
      colorLinkHover
    } = antd.theme.useToken().token;
    return H.useMemo(() => css("color:", colorLink, ";&:visited{color:", colorLink, ";}&:hover{color:", colorLinkHover, ";}&:active{color:", colorLinkActive, ";}", ""), [colorLink, colorLinkActive, colorLinkHover]);
  }
  const APP_CLS_USE_ANT_LINK_COLOR = `${APP_NAMESPACE}--use-ant-link-color`;
  function useAntLinkColorGlobalStyle() {
    const s2 = useAntLinkCss();
    return css(":root .", APP_CLS_USE_ANT_LINK_COLOR, "{", s2, ";}", "");
  }
  function e(e2) {
    return Array.from(new Set(e2));
  }
  function t(e2, t2) {
    if (!e2) throw Error(t2);
  }
  const n$1 = String.raw, r = (e2, ...t2) => new RegExp(n$1(e2, ...t2)), i = n$1`(\d+(\.\d+)?)?(xs|sm|md|lg|xl)`, a = `(solid|dashed|dotted|double|none|hidden)`, o = [[[...[`block`, `flex`, `grid`, `table`].flatMap((e2) => [e2, `inline-${e2}`]), `inline`, `flow-root`, `contents`, `list-item`, `hidden`, ...m(`table-`, [`row`, `column`, `cell`, `caption`, `row-group`, `column-group`, `header-group`, `footer-group`])], `display`], [[`isolate`, `isolation-auto`], `isolation`], [[`static`, `fixed`, `absolute`, `relative`, `sticky`], `position`], [[`visible`, `invisible`, `collapse`], `visibility`], [m(`flex-`, [`row`, `row-reverse`, `col`, `col-reverse`]), `flex-direction`], [m(`flex-`, [`wrap`, `wrap-reverse`, `nowrap`]), `flex-wrap`], [m(`object-`, [`contain`, `cover`, `fill`, `none`, `scale-down`]), `object-fit`], [m(`object-`, [`bottom`, `center`, `left`, `left-bottom`, `left-top`, `right`, `right-bottom`, `right-top`, `top`]), `object-position`], [[`antialiased`, `subpixel-antialiased`], `font-smoothing`], [[`italic`, `not-italic`, `oblique`, `not-oblique`], `font-style`], [m(`font-`, [`mono`, `sans`, `serif`]), `font-family`], [/^(?:font|fw)-?(thin|extralight|light|normal|medium|semibold|bold|extrabold|black|\d+)$/, `font-weight`], [[`normal-nums`, `ordinal`, `slashed-zero`, `lining-nums`, `oldstyle-nums`, `proportional-nums`, `tabular-nums`, `diagonal-fractions`, `stacked-fractions`], `font-variant-numeric`], [r`^(text|text-size|font-size)-(\d+|${i}$)`, `font-size`], [m(`list-`, [`inside`, `outside`]), `list-style-position`], [m(`list-`, [`none`, `disc`, `decimal`]), `list-style-type`], [m(`text-`, [`left`, `center`, `right`, `justify`, `start`, `end`]), `text-align`], [[`underline`, `overline`, `line-through`, `no-underline`], `text-decoration-line`], [m(`decoration-`, [`solid`, `double`, `dotted`, `dashed`, `wavy`]), `text-decoration-style`], [/^decoration-(\d+|(auto|from-font)$)/, `text-decoration-thickness`], [[`truncate`, `text-ellipsis`, `text-clip`], `text-overflow`], [m(`text-`, [`wrap`, `nowrap`, `balance`, `pretty`]), `text-wrap`], [m(`bg-`, [`bottom`, `center`, `left`, `left-bottom`, `left-top`, `right`, `right-bottom`, `right-top`, `top`]), `background-position`], [/^bg(-no)?-repeat($|-)/, `background-repeat`], [m(`bg-`, [`auto`, `cover`, `contain`]), `background-size`], [[`bg-none`, /^bg-gradient-to-/], `background-image`], [/^(?:border-|b-)?(?:rounded|rd)(?:-(.+))?$/, `rounded`], [r`^b(?:order)?-${a}$`, `border-style`], [r`^b(?:order)?-([tblrxyse])-${a}$`, (e2, t2) => `border-${t2?.[1]}-style`], [/^b(?:order)?($|-\d+)/, `border-width`], [/^b(?:order)?-([tblrxyse])($|-\d+)/, (e2, t2) => `border-${t2?.[1]}-width`], [/^(?:border|b)-(?:color-)?(.+)$/, `border-color`], [/^(?:border|b)-([rltbse])-(?:color-)?(.+)$/, (e2, t2) => `border-${t2?.[1]}-color`], [/^outline-\d+/, `outline-width`], [[`outline`, r`^outline-${a}$`], `outline-style`], [r`^divide-${a}$`, `divide-style`], [/^divide-(x|y)($|-\d+)/, (e2, t2) => `divide-${t2?.[1]}-width`], [[`ring`, /^ring-\d+/], `ring-width`], [[/^ring-offset-\d+/], `ring-offset-width`], [[`shadow`, ...m(`shadow-`, [`inner`, `none`]), r`^shadow-${i}$`], `box-shadow`], [m(`border-`, [`collapse`, `separate`]), `border-collapse`], [m(`table-`, [`auto`, `fixed`]), `table-layout`], [m(`caption-`, [`top`, `bottom`]), `caption-side`], [m(`scroll-`, [`auto`, `smooth`]), `scroll-behavior`], [m(`snap-`, [`start`, `end`, `center`, `align-none`]), `scroll-snap-align`], [m(`snap-`, [`normal`, `always`]), `scroll-snap-stop`], [m(`snap-`, [`none`, `x`, `y`, `both`, `mandatory`, `proximity`]), `scroll-snap-type`], [/^stroke-\d+/, `stroke-width`], [[`sr-only`, `not-sr-only`], `Screen-Readers`], [/^(flex-)?grow($|-\d+$)/, `flex-grow`], [/^(flex-)?shrink($|-\d+$)/, `flex-shrink`], ...[`ring-inset`, `divide-x-reverse`, `divide-y-reverse`].map((e2) => [e2, e2]), ...[`resize`, `blur`, `drop-shadow`, `grayscale`, `invert`, `sepia`, `backdrop-blur`, `backdrop-grayscale`, `backdrop-invert`, `backdrop-sepia`].map((e2) => [r`^${e2}($|-)`, e2])], s = new Map(), c$1 = new Map();
  for (let [e2, t2] of o) {
    let n2 = [e2].flat(), r2 = n2.filter((e3) => typeof e3 == `string`), i2 = n2.filter((e3) => typeof e3 == `object` && e3 instanceof RegExp);
    r2.forEach((e3) => {
      let n3 = typeof t2 == `string` ? t2 : t2(e3);
      s.set(e3, n3);
    }), i2.forEach((e3) => {
      c$1.set(e3, t2);
    });
  }
  function l(e2) {
    if (s.has(e2)) return s.get(e2);
    for (let [t2, n2] of c$1.entries()) if (t2.test(e2)) {
      let r2 = t2.exec(e2), i2 = typeof n2 == `string` ? n2 : n2(e2, r2);
      return i2;
    }
  }
  function u(e2) {
    return d$1.map((e3) => typeof e3 == `string` ? [e3, e3] : e3).find(([t2, n2]) => e2.startsWith(`${t2}-`));
  }
  const d$1 = [`break-after`, `break-before`, `break-inside`, `grid-flow`, `align`, `whitespace`, `mix-blend`, `bg-blend`, `ease`, `origin`, `cursor`, `touch`, `color`, [`text`, `color`], [`c`, `color`], [`bg`, `background-color`], [`decoration`, `text-decoration-color`], [`from`, `gradient-color-stops`], [`divide`, `divide-color`], [`outline`, `outline-color`], [`ring`, `ring-color`], [`ring-offset`, `ring-offset-color`], [`shadow`, `box-shadow-color`], [`accent`, `accent-color`], [`caret`, `caret-color`], `fill`, `stroke`];
  function f(e2) {
    return p.has(e2) ? p.get(e2) : e2;
  }
  const p = new Map(Object.entries({ leading: `line-height`, col: `grid-column`, "col-span": `grid-column`, "col-start": `grid-column-start`, "col-end": `grid-column-end`, row: `grid-row`, "row-span": `grid-row`, "row-start": `grid-row-start`, "row-end": `grid-row-end`, m: [`mt`, `mb`, `ml`, `mr`], mx: [`ml`, `mr`], my: [`mt`, `mb`], p: [`pt`, `pb`, `pl`, `pr`], px: [`pl`, `pr`], py: [`pt`, `pb`] }));
  function m(e2, n2) {
    return t(e2.endsWith(`-`), "prefix must end with `-`"), n2.map((t2) => e2 + t2);
  }
  function h(t2) {
    return typeof t2 == `boolean` ? [] : e((t2 || ``).split(` `).map((e2) => e2.trim()).filter(Boolean));
  }
  function g(...t2) {
    let n2 = new Map(), r2 = t2.map(h).flat().filter(Boolean);
    return r2.forEach((e2) => _(e2, n2)), e(Array.from(n2.values())).join(` `);
  }
  function _(e2, t2) {
    let n2 = e2, r2;
    function i2(e3) {
      [e3].flat().forEach((e4) => {
        t2.set(r2 ? r2 + e4 : e4, n2);
      });
    }
    function a2() {
      let t3 = l(e2);
      if (t3) return i2(t3), true;
    }
    function o2() {
      let t3 = u(e2);
      if (!t3) return;
      let [n3, r3] = t3, a3 = f(r3);
      return i2(a3), true;
    }
    function s2() {
      let t3 = e2, n3 = /(\[[\w,()/-]+\])$/;
      n3.test(e2) && (t3 = e2.replace(n3, function(e3, t4) {
        return `*`.repeat(t4.length);
      })), t3 = t3.replaceAll(/--(?=\d)/g, `-*`);
      let r3 = t3.lastIndexOf(`-`);
      if (r3 === -1) return;
      let a3 = f(e2.slice(0, r3));
      return i2(a3), true;
    }
    function c2() {
      return i2(f(e2));
    }
    function d2() {
      let t3 = /^(?:(?:[\w-]+|\[[^\s[\]]+\]):)+/, n3 = t3.exec(e2);
      n3 && (r2 = n3[0].split(new RegExp("(?<=:)(?:\\b|$)")).filter(Boolean).sort().join(``), e2 = e2.slice(r2.length));
    }
    function p2() {
      if (e2.startsWith(`!`)) {
        e2 = `important:` + e2.slice(1);
        return;
      }
      if (e2.endsWith(`!`)) {
        e2 = `important:` + e2.slice(0, -1);
        return;
      }
    }
    a2() || o2() || (p2(), d2(), a2() || o2() || s2() || c2());
  }
  function n(...n2) {
    return H.useMemo(() => g(...n2), [...n2]);
  }
  var createUpdateEffect = function(hook) {
    return function(effect, deps) {
      var isMounted = H.useRef(false);
      hook(function() {
        return function() {
          isMounted.current = false;
        };
      }, []);
      hook(function() {
        if (!isMounted.current) {
          isMounted.current = true;
        } else {
          return effect();
        }
      }, deps);
    };
  };
  var __assign = function() {
    __assign = Object.assign || function __assign2(t2) {
      for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  function __rest(s2, e2) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1) throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f2, y, t2, g2 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g2.next = verb(0), g2["throw"] = verb(1), g2["return"] = verb(2), typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
      return this;
    }), g2;
    function verb(n2) {
      return function(v) {
        return step([n2, v]);
      };
    }
    function step(op) {
      if (f2) throw new TypeError("Generator is already executing.");
      while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
        if (f2 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
        if (y = 0, t2) op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2]) _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y = 0;
      } finally {
        f2 = t2 = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __values(o2) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
    if (m2) return m2.call(o2);
    if (o2 && typeof o2.length === "number") return {
      next: function() {
        if (o2 && i2 >= o2.length) o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o2, n2) {
    var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
    if (!m2) return o2;
    var i2 = m2.call(o2), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
      } finally {
        if (e2) throw e2.error;
      }
    }
    return ar;
  }
  function __spreadArray(to, from2, pack) {
    if (arguments.length === 2) for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar) ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from2));
  }
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
    var e2 = new Error(message2);
    return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
  };
  var isFunction = function(value) {
    return typeof value === "function";
  };
  var isString = function(value) {
    return typeof value === "string";
  };
  var isNumber = function(value) {
    return typeof value === "number";
  };
  var useMemoizedFn = function(fn) {
    var fnRef = H.useRef(fn);
    fnRef.current = H.useMemo(function() {
      return fn;
    }, [fn]);
    var memoizedFn = H.useRef(void 0);
    if (!memoizedFn.current) {
      memoizedFn.current = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return fnRef.current.apply(this, args);
      };
    }
    return memoizedFn.current;
  };
  const useUpdateEffect = createUpdateEffect(H.useEffect);
  var useAutoRunPlugin = function(fetchInstance, _a) {
    var manual = _a.manual, _b = _a.ready, ready = _b === void 0 ? true : _b, _c = _a.defaultParams, defaultParams = _c === void 0 ? [] : _c, _d = _a.refreshDeps, refreshDeps = _d === void 0 ? [] : _d, refreshDepsAction = _a.refreshDepsAction;
    var hasAutoRun = H.useRef(false);
    hasAutoRun.current = false;
    useUpdateEffect(function() {
      if (!manual && ready) {
        hasAutoRun.current = true;
        fetchInstance.run.apply(fetchInstance, __spreadArray([], __read(defaultParams), false));
      }
    }, [ready]);
    useUpdateEffect(function() {
      if (hasAutoRun.current) {
        return;
      }
      if (!manual) {
        hasAutoRun.current = true;
        if (refreshDepsAction) {
          refreshDepsAction();
        } else {
          fetchInstance.refresh();
        }
      }
    }, __spreadArray([], __read(refreshDeps), false));
    return {
      onBefore: function() {
        if (!ready) {
          return {
            stopNow: true
          };
        }
      }
    };
  };
  useAutoRunPlugin.onInit = function(_a) {
    var _b = _a.ready, ready = _b === void 0 ? true : _b, manual = _a.manual;
    return {
      loading: !manual && ready
    };
  };
  function depsAreSame(oldDeps, deps) {
    if (oldDeps === deps) {
      return true;
    }
    for (var i2 = 0; i2 < oldDeps.length; i2++) {
      if (!Object.is(oldDeps[i2], deps[i2])) {
        return false;
      }
    }
    return true;
  }
  var useCreation = function(factory, deps) {
    var current = H.useRef({
      deps,
      obj: void 0,
      initialized: false
    }).current;
    if (current.initialized === false || !depsAreSame(current.deps, deps)) {
      current.deps = deps;
      current.obj = factory();
      current.initialized = true;
    }
    return current.obj;
  };
  function useLatest(value) {
    var ref = H.useRef(value);
    ref.current = value;
    return ref;
  }
  var useUnmount = function(fn) {
    var fnRef = useLatest(fn);
    H.useEffect(function() {
      return function() {
        fnRef.current();
      };
    }, []);
  };
  var cache$3 = new Map();
  var setCache = function(key, cacheTime, cachedData) {
    var currentCache = cache$3.get(key);
    if (currentCache === null || currentCache === void 0 ? void 0 : currentCache.timer) {
      clearTimeout(currentCache.timer);
    }
    var timer = void 0;
    if (cacheTime > -1) {
      timer = setTimeout(function() {
        cache$3.delete(key);
      }, cacheTime);
    }
    cache$3.set(key, __assign(__assign({}, cachedData), { timer }));
  };
  var getCache = function(key) {
    return cache$3.get(key);
  };
  var cachePromise = new Map();
  var getCachePromise = function(cacheKey2) {
    return cachePromise.get(cacheKey2);
  };
  var setCachePromise = function(cacheKey2, promise) {
    cachePromise.set(cacheKey2, promise);
    promise.then(function(res) {
      cachePromise.delete(cacheKey2);
      return res;
    }).catch(function() {
      cachePromise.delete(cacheKey2);
    });
  };
  var listeners$2 = {};
  var trigger = function(key, data2) {
    if (listeners$2[key]) {
      listeners$2[key].forEach(function(item) {
        return item(data2);
      });
    }
  };
  var subscribe$2 = function(key, listener) {
    if (!listeners$2[key]) {
      listeners$2[key] = [];
    }
    listeners$2[key].push(listener);
    return function unsubscribe() {
      var index = listeners$2[key].indexOf(listener);
      listeners$2[key].splice(index, 1);
    };
  };
  var useCachePlugin = function(fetchInstance, _a) {
    var cacheKey2 = _a.cacheKey, _b = _a.cacheTime, cacheTime = _b === void 0 ? 5 * 60 * 1e3 : _b, _c = _a.staleTime, staleTime = _c === void 0 ? 0 : _c, customSetCache = _a.setCache, customGetCache = _a.getCache;
    var unSubscribeRef = H.useRef(void 0);
    var currentPromiseRef = H.useRef(void 0);
    var _setCache = function(key, cachedData) {
      if (customSetCache) {
        customSetCache(cachedData);
      } else {
        setCache(key, cacheTime, cachedData);
      }
      trigger(key, cachedData.data);
    };
    var _getCache = function(key, params) {
      if (params === void 0) {
        params = [];
      }
      if (customGetCache) {
        return customGetCache(params);
      }
      return getCache(key);
    };
    useCreation(function() {
      if (!cacheKey2) {
        return;
      }
      var cacheData = _getCache(cacheKey2);
      if (cacheData && Object.hasOwnProperty.call(cacheData, "data")) {
        fetchInstance.state.data = cacheData.data;
        fetchInstance.state.params = cacheData.params;
        if (staleTime === -1 || Date.now() - cacheData.time <= staleTime) {
          fetchInstance.state.loading = false;
        }
      }
      unSubscribeRef.current = subscribe$2(cacheKey2, function(data2) {
        fetchInstance.setState({ data: data2 });
      });
    }, []);
    useUnmount(function() {
      var _a2;
      (_a2 = unSubscribeRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unSubscribeRef);
    });
    if (!cacheKey2) {
      return {};
    }
    return {
      onBefore: function(params) {
        var cacheData = _getCache(cacheKey2, params);
        if (!cacheData || !Object.hasOwnProperty.call(cacheData, "data")) {
          return {};
        }
        if (staleTime === -1 || Date.now() - cacheData.time <= staleTime) {
          return {
            loading: false,
            data: cacheData === null || cacheData === void 0 ? void 0 : cacheData.data,
            error: void 0,
            returnNow: true
          };
        } else {
          return {
            data: cacheData === null || cacheData === void 0 ? void 0 : cacheData.data,
            error: void 0
          };
        }
      },
      onRequest: function(service, args) {
        var servicePromise = getCachePromise(cacheKey2);
        if (servicePromise && servicePromise !== currentPromiseRef.current) {
          return { servicePromise };
        }
        servicePromise = service.apply(void 0, __spreadArray([], __read(args), false));
        currentPromiseRef.current = servicePromise;
        setCachePromise(cacheKey2, servicePromise);
        return { servicePromise };
      },
      onSuccess: function(data2, params) {
        var _a2;
        if (cacheKey2) {
          (_a2 = unSubscribeRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unSubscribeRef);
          _setCache(cacheKey2, {
            data: data2,
            params,
            time: Date.now()
          });
          unSubscribeRef.current = subscribe$2(cacheKey2, function(d2) {
            fetchInstance.setState({ data: d2 });
          });
        }
      },
      onMutate: function(data2) {
        var _a2;
        if (cacheKey2) {
          (_a2 = unSubscribeRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unSubscribeRef);
          _setCache(cacheKey2, {
            data: data2,
            params: fetchInstance.state.params,
            time: Date.now()
          });
          unSubscribeRef.current = subscribe$2(cacheKey2, function(d2) {
            fetchInstance.setState({ data: d2 });
          });
        }
      }
    };
  };
  var isObject_1;
  var hasRequiredIsObject;
  function requireIsObject() {
    if (hasRequiredIsObject) return isObject_1;
    hasRequiredIsObject = 1;
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    isObject_1 = isObject2;
    return isObject_1;
  }
  var _freeGlobal;
  var hasRequired_freeGlobal;
  function require_freeGlobal() {
    if (hasRequired_freeGlobal) return _freeGlobal;
    hasRequired_freeGlobal = 1;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    _freeGlobal = freeGlobal;
    return _freeGlobal;
  }
  var _root;
  var hasRequired_root;
  function require_root() {
    if (hasRequired_root) return _root;
    hasRequired_root = 1;
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    _root = root2;
    return _root;
  }
  var now_1;
  var hasRequiredNow;
  function requireNow() {
    if (hasRequiredNow) return now_1;
    hasRequiredNow = 1;
    var root2 = require_root();
    var now = function() {
      return root2.Date.now();
    };
    now_1 = now;
    return now_1;
  }
  var _trimmedEndIndex;
  var hasRequired_trimmedEndIndex;
  function require_trimmedEndIndex() {
    if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;
    hasRequired_trimmedEndIndex = 1;
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    _trimmedEndIndex = trimmedEndIndex;
    return _trimmedEndIndex;
  }
  var _baseTrim;
  var hasRequired_baseTrim;
  function require_baseTrim() {
    if (hasRequired_baseTrim) return _baseTrim;
    hasRequired_baseTrim = 1;
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    _baseTrim = baseTrim;
    return _baseTrim;
  }
  var _Symbol;
  var hasRequired_Symbol;
  function require_Symbol() {
    if (hasRequired_Symbol) return _Symbol;
    hasRequired_Symbol = 1;
    var root2 = require_root();
    var Symbol2 = root2.Symbol;
    _Symbol = Symbol2;
    return _Symbol;
  }
  var _getRawTag;
  var hasRequired_getRawTag;
  function require_getRawTag() {
    if (hasRequired_getRawTag) return _getRawTag;
    hasRequired_getRawTag = 1;
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    _getRawTag = getRawTag;
    return _getRawTag;
  }
  var _objectToString;
  var hasRequired_objectToString;
  function require_objectToString() {
    if (hasRequired_objectToString) return _objectToString;
    hasRequired_objectToString = 1;
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString2(value) {
      return nativeObjectToString.call(value);
    }
    _objectToString = objectToString2;
    return _objectToString;
  }
  var _baseGetTag;
  var hasRequired_baseGetTag;
  function require_baseGetTag() {
    if (hasRequired_baseGetTag) return _baseGetTag;
    hasRequired_baseGetTag = 1;
    var Symbol2 = require_Symbol(), getRawTag = require_getRawTag(), objectToString2 = require_objectToString();
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
    }
    _baseGetTag = baseGetTag;
    return _baseGetTag;
  }
  var isObjectLike_1;
  var hasRequiredIsObjectLike;
  function requireIsObjectLike() {
    if (hasRequiredIsObjectLike) return isObjectLike_1;
    hasRequiredIsObjectLike = 1;
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    isObjectLike_1 = isObjectLike;
    return isObjectLike_1;
  }
  var isSymbol_1;
  var hasRequiredIsSymbol;
  function requireIsSymbol() {
    if (hasRequiredIsSymbol) return isSymbol_1;
    hasRequiredIsSymbol = 1;
    var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
    var symbolTag2 = "[object Symbol]";
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag2;
    }
    isSymbol_1 = isSymbol2;
    return isSymbol_1;
  }
  var toNumber_1;
  var hasRequiredToNumber;
  function requireToNumber() {
    if (hasRequiredToNumber) return toNumber_1;
    hasRequiredToNumber = 1;
    var baseTrim = require_baseTrim(), isObject2 = requireIsObject(), isSymbol2 = requireIsSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber2(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    toNumber_1 = toNumber2;
    return toNumber_1;
  }
  var debounce_1;
  var hasRequiredDebounce;
  function requireDebounce() {
    if (hasRequiredDebounce) return debounce_1;
    hasRequiredDebounce = 1;
    var isObject2 = requireIsObject(), now = requireNow(), toNumber2 = requireToNumber();
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max, nativeMin = Math.min;
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber2(wait) || 0;
      if (isObject2(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    debounce_1 = debounce2;
    return debounce_1;
  }
  var debounceExports = requireDebounce();
  const debounce = getDefaultExportFromCjs(debounceExports);
  var useDebouncePlugin = function(fetchInstance, _a) {
    var debounceWait = _a.debounceWait, debounceLeading = _a.debounceLeading, debounceTrailing = _a.debounceTrailing, debounceMaxWait = _a.debounceMaxWait;
    var debouncedRef = H.useRef(void 0);
    var options = H.useMemo(function() {
      var ret = {};
      if (debounceLeading !== void 0) {
        ret.leading = debounceLeading;
      }
      if (debounceTrailing !== void 0) {
        ret.trailing = debounceTrailing;
      }
      if (debounceMaxWait !== void 0) {
        ret.maxWait = debounceMaxWait;
      }
      return ret;
    }, [debounceLeading, debounceTrailing, debounceMaxWait]);
    H.useEffect(function() {
      if (debounceWait) {
        var _originRunAsync_1 = fetchInstance.runAsync.bind(fetchInstance);
        debouncedRef.current = debounce(function(callback) {
          callback();
        }, debounceWait, options);
        fetchInstance.runAsync = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return new Promise(function(resolve, reject) {
            var _a2;
            (_a2 = debouncedRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(debouncedRef, function() {
              _originRunAsync_1.apply(void 0, __spreadArray([], __read(args), false)).then(resolve).catch(reject);
            });
          });
        };
        return function() {
          var _a2;
          (_a2 = debouncedRef.current) === null || _a2 === void 0 ? void 0 : _a2.cancel();
          fetchInstance.runAsync = _originRunAsync_1;
        };
      }
    }, [debounceWait, options]);
    if (!debounceWait) {
      return {};
    }
    return {
      onCancel: function() {
        var _a2;
        (_a2 = debouncedRef.current) === null || _a2 === void 0 ? void 0 : _a2.cancel();
      }
    };
  };
  var useLoadingDelayPlugin = function(fetchInstance, _a) {
    var loadingDelay = _a.loadingDelay, ready = _a.ready;
    var timerRef = H.useRef(void 0);
    if (!loadingDelay) {
      return {};
    }
    var cancelTimeout = function() {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
    return {
      onBefore: function() {
        cancelTimeout();
        if (ready !== false) {
          timerRef.current = setTimeout(function() {
            fetchInstance.setState({
              loading: true
            });
          }, loadingDelay);
        }
        return {
          loading: false
        };
      },
      onFinally: function() {
        cancelTimeout();
      },
      onCancel: function() {
        cancelTimeout();
      }
    };
  };
  var isBrowser = !!(typeof window !== "undefined" && window.document && window.document.createElement);
  function isDocumentVisible() {
    if (isBrowser) {
      return document.visibilityState !== "hidden";
    }
    return true;
  }
  var listeners$1 = new Set();
  function subscribe$1(listener) {
    listeners$1.add(listener);
    return function unsubscribe() {
      listeners$1.has(listener) && listeners$1.delete(listener);
    };
  }
  if (isBrowser) {
    var revalidate$1 = function() {
      if (!isDocumentVisible())
        return;
      listeners$1.forEach(function(listener) {
        return listener();
      });
    };
    window.addEventListener("visibilitychange", revalidate$1, false);
  }
  var usePollingPlugin = function(fetchInstance, _a) {
    var pollingInterval = _a.pollingInterval, _b = _a.pollingWhenHidden, pollingWhenHidden = _b === void 0 ? true : _b, _c = _a.pollingErrorRetryCount, pollingErrorRetryCount = _c === void 0 ? -1 : _c;
    var timerRef = H.useRef(void 0);
    var unsubscribeRef = H.useRef(void 0);
    var countRef = H.useRef(0);
    var stopPolling = function() {
      var _a2;
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
      (_a2 = unsubscribeRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unsubscribeRef);
    };
    useUpdateEffect(function() {
      if (!pollingInterval) {
        stopPolling();
      }
    }, [pollingInterval]);
    if (!pollingInterval) {
      return {};
    }
    return {
      onBefore: function() {
        stopPolling();
      },
      onError: function() {
        countRef.current += 1;
      },
      onSuccess: function() {
        countRef.current = 0;
      },
      onFinally: function() {
        if (pollingErrorRetryCount === -1 ||
pollingErrorRetryCount !== -1 && countRef.current <= pollingErrorRetryCount) {
          timerRef.current = setTimeout(function() {
            if (!pollingWhenHidden && !isDocumentVisible()) {
              unsubscribeRef.current = subscribe$1(function() {
                fetchInstance.refresh();
              });
            } else {
              fetchInstance.refresh();
            }
          }, pollingInterval);
        } else {
          countRef.current = 0;
        }
      },
      onCancel: function() {
        stopPolling();
      }
    };
  };
  function limit(fn, timespan) {
    var pending = false;
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (pending)
        return;
      pending = true;
      fn.apply(void 0, __spreadArray([], __read(args), false));
      setTimeout(function() {
        pending = false;
      }, timespan);
    };
  }
  var isOnline = function() {
    if (isBrowser && typeof navigator.onLine !== "undefined") {
      return navigator.onLine;
    }
    return true;
  };
  var listeners = new Set();
  function subscribe(listener) {
    listeners.add(listener);
    return function unsubscribe() {
      listeners.has(listener) && listeners.delete(listener);
    };
  }
  if (isBrowser) {
    var revalidate = function() {
      if (!isDocumentVisible() || !isOnline())
        return;
      listeners.forEach(function(listener) {
        return listener();
      });
    };
    window.addEventListener("visibilitychange", revalidate, false);
    window.addEventListener("focus", revalidate, false);
  }
  var useRefreshOnWindowFocusPlugin = function(fetchInstance, _a) {
    var refreshOnWindowFocus = _a.refreshOnWindowFocus, _b = _a.focusTimespan, focusTimespan = _b === void 0 ? 5e3 : _b;
    var unsubscribeRef = H.useRef(void 0);
    var stopSubscribe = function() {
      var _a2;
      (_a2 = unsubscribeRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unsubscribeRef);
    };
    H.useEffect(function() {
      if (refreshOnWindowFocus) {
        var limitRefresh_1 = limit(fetchInstance.refresh.bind(fetchInstance), focusTimespan);
        unsubscribeRef.current = subscribe(function() {
          limitRefresh_1();
        });
      }
      return function() {
        stopSubscribe();
      };
    }, [refreshOnWindowFocus, focusTimespan]);
    useUnmount(function() {
      stopSubscribe();
    });
    return {};
  };
  var useRetryPlugin = function(fetchInstance, _a) {
    var retryInterval = _a.retryInterval, retryCount = _a.retryCount;
    var timerRef = H.useRef(void 0);
    var countRef = H.useRef(0);
    var triggerByRetry = H.useRef(false);
    if (!retryCount) {
      return {};
    }
    return {
      onBefore: function() {
        if (!triggerByRetry.current) {
          countRef.current = 0;
        }
        triggerByRetry.current = false;
        if (timerRef.current) {
          clearTimeout(timerRef.current);
        }
      },
      onSuccess: function() {
        countRef.current = 0;
      },
      onError: function() {
        countRef.current += 1;
        if (retryCount === -1 || countRef.current <= retryCount) {
          var timeout = retryInterval !== null && retryInterval !== void 0 ? retryInterval : Math.min(1e3 * Math.pow(2, countRef.current), 3e4);
          timerRef.current = setTimeout(function() {
            triggerByRetry.current = true;
            fetchInstance.refresh();
          }, timeout);
        } else {
          countRef.current = 0;
        }
      },
      onCancel: function() {
        countRef.current = 0;
        if (timerRef.current) {
          clearTimeout(timerRef.current);
        }
      }
    };
  };
  var throttle_1;
  var hasRequiredThrottle;
  function requireThrottle() {
    if (hasRequiredThrottle) return throttle_1;
    hasRequiredThrottle = 1;
    var debounce2 = requireDebounce(), isObject2 = requireIsObject();
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle2(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject2(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce2(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    throttle_1 = throttle2;
    return throttle_1;
  }
  var throttleExports = requireThrottle();
  const throttle = getDefaultExportFromCjs(throttleExports);
  var useThrottlePlugin = function(fetchInstance, _a) {
    var throttleWait = _a.throttleWait, throttleLeading = _a.throttleLeading, throttleTrailing = _a.throttleTrailing;
    var throttledRef = H.useRef(void 0);
    var options = {};
    if (throttleLeading !== void 0) {
      options.leading = throttleLeading;
    }
    if (throttleTrailing !== void 0) {
      options.trailing = throttleTrailing;
    }
    H.useEffect(function() {
      if (throttleWait) {
        var _originRunAsync_1 = fetchInstance.runAsync.bind(fetchInstance);
        throttledRef.current = throttle(function(callback) {
          callback();
        }, throttleWait, options);
        fetchInstance.runAsync = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return new Promise(function(resolve, reject) {
            var _a2;
            (_a2 = throttledRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(throttledRef, function() {
              _originRunAsync_1.apply(void 0, __spreadArray([], __read(args), false)).then(resolve).catch(reject);
            });
          });
        };
        return function() {
          var _a2;
          fetchInstance.runAsync = _originRunAsync_1;
          (_a2 = throttledRef.current) === null || _a2 === void 0 ? void 0 : _a2.cancel();
        };
      }
    }, [throttleWait, throttleLeading, throttleTrailing]);
    if (!throttleWait) {
      return {};
    }
    return {
      onCancel: function() {
        var _a2;
        (_a2 = throttledRef.current) === null || _a2 === void 0 ? void 0 : _a2.cancel();
      }
    };
  };
  var useMount = function(fn) {
    H.useEffect(function() {
      var result = fn === null || fn === void 0 ? void 0 : fn();
      if (result && typeof result === "object" && typeof result.then === "function") {
        return;
      }
      return result;
    }, []);
  };
  var useUpdate = function() {
    var _a = __read(H.useState({}), 2), setState = _a[1];
    return H.useCallback(function() {
      return setState({});
    }, []);
  };
  var Fetch = (
function() {
      function Fetch2(serviceRef, options, subscribe2, initState) {
        if (initState === void 0) {
          initState = {};
        }
        this.serviceRef = serviceRef;
        this.options = options;
        this.subscribe = subscribe2;
        this.initState = initState;
        this.count = 0;
        this.state = {
          loading: false,
          params: void 0,
          data: void 0,
          error: void 0
        };
        this.state = __assign(__assign(__assign({}, this.state), { loading: !options.manual }), initState);
      }
      Fetch2.prototype.setState = function(s2) {
        if (s2 === void 0) {
          s2 = {};
        }
        this.state = __assign(__assign({}, this.state), s2);
        this.subscribe();
      };
      Fetch2.prototype.runPluginHandler = function(event) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          rest[_i - 1] = arguments[_i];
        }
        var r2 = this.pluginImpls.map(function(i2) {
          var _a;
          return (_a = i2[event]) === null || _a === void 0 ? void 0 : _a.call.apply(_a, __spreadArray([i2], __read(rest), false));
        }).filter(Boolean);
        return Object.assign.apply(Object, __spreadArray([{}], __read(r2), false));
      };
      Fetch2.prototype.runAsync = function() {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          params[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function() {
          var currentCount, _a, _b, stopNow, _c, returnNow, state2, servicePromise, res, error_1;
          var _d;
          var _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
          return __generator(this, function(_q) {
            switch (_q.label) {
              case 0:
                this.count += 1;
                currentCount = this.count;
                _a = this.runPluginHandler("onBefore", params), _b = _a.stopNow, stopNow = _b === void 0 ? false : _b, _c = _a.returnNow, returnNow = _c === void 0 ? false : _c, state2 = __rest(_a, ["stopNow", "returnNow"]);
                if (stopNow) {
                  return [2, new Promise(function() {
                  })];
                }
                this.setState(__assign({ loading: true, params }, state2));
                if (returnNow) {
                  return [2, Promise.resolve(state2.data)];
                }
                (_f = (_e = this.options).onBefore) === null || _f === void 0 ? void 0 : _f.call(_e, params);
                _q.label = 1;
              case 1:
                _q.trys.push([1, 3, , 4]);
                servicePromise = this.runPluginHandler("onRequest", this.serviceRef.current, params).servicePromise;
                if (!servicePromise) {
                  servicePromise = (_d = this.serviceRef).current.apply(_d, __spreadArray([], __read(params), false));
                }
                return [4, servicePromise];
              case 2:
                res = _q.sent();
                if (currentCount !== this.count) {
                  return [2, new Promise(function() {
                  })];
                }
                this.setState({
                  data: res,
                  error: void 0,
                  loading: false
                });
                (_h = (_g = this.options).onSuccess) === null || _h === void 0 ? void 0 : _h.call(_g, res, params);
                this.runPluginHandler("onSuccess", res, params);
                (_k = (_j = this.options).onFinally) === null || _k === void 0 ? void 0 : _k.call(_j, params, res, void 0);
                if (currentCount === this.count) {
                  this.runPluginHandler("onFinally", params, res, void 0);
                }
                return [2, res];
              case 3:
                error_1 = _q.sent();
                if (currentCount !== this.count) {
                  return [2, new Promise(function() {
                  })];
                }
                this.setState({
                  error: error_1,
                  loading: false
                });
                (_m = (_l = this.options).onError) === null || _m === void 0 ? void 0 : _m.call(_l, error_1, params);
                this.runPluginHandler("onError", error_1, params);
                (_p = (_o = this.options).onFinally) === null || _p === void 0 ? void 0 : _p.call(_o, params, void 0, error_1);
                if (currentCount === this.count) {
                  this.runPluginHandler("onFinally", params, void 0, error_1);
                }
                throw error_1;
              case 4:
                return [
                  2
];
            }
          });
        });
      };
      Fetch2.prototype.run = function() {
        var _this = this;
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          params[_i] = arguments[_i];
        }
        this.runAsync.apply(this, __spreadArray([], __read(params), false)).catch(function(error) {
          if (!_this.options.onError) {
            console.error(error);
          }
        });
      };
      Fetch2.prototype.cancel = function() {
        this.count += 1;
        this.setState({
          loading: false
        });
        this.runPluginHandler("onCancel");
      };
      Fetch2.prototype.refresh = function() {
        this.run.apply(this, __spreadArray([], __read(this.state.params || []), false));
      };
      Fetch2.prototype.refreshAsync = function() {
        return this.runAsync.apply(this, __spreadArray([], __read(this.state.params || []), false));
      };
      Fetch2.prototype.mutate = function(data2) {
        var targetData = isFunction(data2) ? data2(this.state.data) : data2;
        this.runPluginHandler("onMutate", targetData);
        this.setState({
          data: targetData
        });
      };
      return Fetch2;
    }()
  );
  function useRequestImplement(service, options, plugins) {
    if (options === void 0) {
      options = {};
    }
    if (plugins === void 0) {
      plugins = [];
    }
    var _a = options.manual, manual = _a === void 0 ? false : _a, _b = options.ready, ready = _b === void 0 ? true : _b, rest = __rest(options, ["manual", "ready"]);
    var fetchOptions = __assign({ manual, ready }, rest);
    var serviceRef = useLatest(service);
    var update = useUpdate();
    var fetchInstance = useCreation(function() {
      var initState = plugins.map(function(p2) {
        var _a2;
        return (_a2 = p2 === null || p2 === void 0 ? void 0 : p2.onInit) === null || _a2 === void 0 ? void 0 : _a2.call(p2, fetchOptions);
      }).filter(Boolean);
      return new Fetch(serviceRef, fetchOptions, update, Object.assign.apply(Object, __spreadArray([{}], __read(initState), false)));
    }, []);
    fetchInstance.options = fetchOptions;
    fetchInstance.pluginImpls = plugins.map(function(p2) {
      return p2(fetchInstance, fetchOptions);
    });
    useMount(function() {
      if (!manual && ready) {
        var params = fetchInstance.state.params || options.defaultParams || [];
        fetchInstance.run.apply(fetchInstance, __spreadArray([], __read(params), false));
      }
    });
    useUnmount(function() {
      fetchInstance.cancel();
    });
    return {
      loading: fetchInstance.state.loading,
      data: fetchInstance.state.data,
      error: fetchInstance.state.error,
      params: fetchInstance.state.params || [],
      cancel: useMemoizedFn(fetchInstance.cancel.bind(fetchInstance)),
      refresh: useMemoizedFn(fetchInstance.refresh.bind(fetchInstance)),
      refreshAsync: useMemoizedFn(fetchInstance.refreshAsync.bind(fetchInstance)),
      run: useMemoizedFn(fetchInstance.run.bind(fetchInstance)),
      runAsync: useMemoizedFn(fetchInstance.runAsync.bind(fetchInstance)),
      mutate: useMemoizedFn(fetchInstance.mutate.bind(fetchInstance))
    };
  }
  function useRequest(service, options, plugins) {
    return useRequestImplement(service, options, __spreadArray(__spreadArray([], __read([]), false), [
      useDebouncePlugin,
      useLoadingDelayPlugin,
      usePollingPlugin,
      useRefreshOnWindowFocusPlugin,
      useThrottlePlugin,
      useAutoRunPlugin,
      useCachePlugin,
      useRetryPlugin
    ], false));
  }
  function useToggle(defaultValue2, reverseValue) {
    if (defaultValue2 === void 0) {
      defaultValue2 = false;
    }
    var _a = __read(H.useState(defaultValue2), 2), state2 = _a[0], setState = _a[1];
    var actions = H.useMemo(function() {
      var reverseValueOrigin = !defaultValue2;
      var toggle = function() {
        return setState(function(s2) {
          return s2 === defaultValue2 ? reverseValueOrigin : defaultValue2;
        });
      };
      var set2 = function(value) {
        return setState(value);
      };
      var setLeft = function() {
        return setState(defaultValue2);
      };
      var setRight = function() {
        return setState(reverseValueOrigin);
      };
      return {
        toggle,
        set: set2,
        setLeft,
        setRight
      };
    }, []);
    return [state2, actions];
  }
  function useBoolean(defaultValue2) {
    var _a = __read(useToggle(false), 2), state2 = _a[0], _b = _a[1], toggle = _b.toggle, set2 = _b.set;
    var actions = H.useMemo(function() {
      var setTrue = function() {
        return set2(true);
      };
      var setFalse = function() {
        return set2(false);
      };
      return {
        toggle,
        set: function(v) {
          return set2(!!v);
        },
        setTrue,
        setFalse
      };
    }, []);
    return [state2, actions];
  }
  function getTargetElement(target, defaultElement) {
    if (!isBrowser) {
      return void 0;
    }
    if (!target) {
      return defaultElement;
    }
    var targetElement;
    if (isFunction(target)) {
      targetElement = target();
    } else if ("current" in target) {
      targetElement = target.current;
    } else {
      targetElement = target;
    }
    return targetElement;
  }
  var checkIfAllInShadow = function(targets) {
    return targets.every(function(item) {
      var targetElement = getTargetElement(item);
      if (!targetElement) {
        return false;
      }
      if (targetElement.getRootNode() instanceof ShadowRoot) {
        return true;
      }
      return false;
    });
  };
  var getShadow = function(node2) {
    if (!node2) {
      return document;
    }
    return node2.getRootNode();
  };
  var getDocumentOrShadow = function(target) {
    if (!target || !document.getRootNode) {
      return document;
    }
    var targets = Array.isArray(target) ? target : [target];
    if (checkIfAllInShadow(targets)) {
      return getShadow(getTargetElement(targets[0]));
    }
    return document;
  };
  var createEffectWithTarget = function(useEffectType) {
    var useEffectWithTarget2 = function(effect, deps, target) {
      var hasInitRef = H.useRef(false);
      var lastElementRef = H.useRef([]);
      var lastDepsRef = H.useRef([]);
      var unLoadRef = H.useRef(void 0);
      useEffectType(function() {
        var _a;
        var targets = Array.isArray(target) ? target : [target];
        var els = targets.map(function(item) {
          return getTargetElement(item);
        });
        if (!hasInitRef.current) {
          hasInitRef.current = true;
          lastElementRef.current = els;
          lastDepsRef.current = deps;
          unLoadRef.current = effect();
          return;
        }
        if (els.length !== lastElementRef.current.length || !depsAreSame(lastElementRef.current, els) || !depsAreSame(lastDepsRef.current, deps)) {
          (_a = unLoadRef.current) === null || _a === void 0 ? void 0 : _a.call(unLoadRef);
          lastElementRef.current = els;
          lastDepsRef.current = deps;
          unLoadRef.current = effect();
        }
      });
      useUnmount(function() {
        var _a;
        (_a = unLoadRef.current) === null || _a === void 0 ? void 0 : _a.call(unLoadRef);
        hasInitRef.current = false;
      });
    };
    return useEffectWithTarget2;
  };
  var useEffectWithTarget = createEffectWithTarget(H.useEffect);
  function useClickAway(onClickAway, target, eventName) {
    if (eventName === void 0) {
      eventName = "click";
    }
    var onClickAwayRef = useLatest(onClickAway);
    useEffectWithTarget(function() {
      var handler = function(event) {
        var targets = Array.isArray(target) ? target : [target];
        if (targets.some(function(item) {
          var targetElement = getTargetElement(item);
          return !targetElement || targetElement.contains(event.target);
        })) {
          return;
        }
        onClickAwayRef.current(event);
      };
      var documentOrShadow = getDocumentOrShadow(target);
      var eventNames = Array.isArray(eventName) ? eventName : [eventName];
      eventNames.forEach(function(event) {
        return documentOrShadow.addEventListener(event, handler);
      });
      return function() {
        eventNames.forEach(function(event) {
          return documentOrShadow.removeEventListener(event, handler);
        });
      };
    }, Array.isArray(eventName) ? eventName : [eventName], target);
  }
  var reactFastCompare;
  var hasRequiredReactFastCompare;
  function requireReactFastCompare() {
    if (hasRequiredReactFastCompare) return reactFastCompare;
    hasRequiredReactFastCompare = 1;
    var hasElementType = typeof Element !== "undefined";
    var hasMap = typeof Map === "function";
    var hasSet = typeof Set === "function";
    var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
    function equal(a2, b) {
      if (a2 === b) return true;
      if (a2 && b && typeof a2 == "object" && typeof b == "object") {
        if (a2.constructor !== b.constructor) return false;
        var length2, i2, keys;
        if (Array.isArray(a2)) {
          length2 = a2.length;
          if (length2 != b.length) return false;
          for (i2 = length2; i2-- !== 0; )
            if (!equal(a2[i2], b[i2])) return false;
          return true;
        }
        var it;
        if (hasMap && a2 instanceof Map && b instanceof Map) {
          if (a2.size !== b.size) return false;
          it = a2.entries();
          while (!(i2 = it.next()).done)
            if (!b.has(i2.value[0])) return false;
          it = a2.entries();
          while (!(i2 = it.next()).done)
            if (!equal(i2.value[1], b.get(i2.value[0]))) return false;
          return true;
        }
        if (hasSet && a2 instanceof Set && b instanceof Set) {
          if (a2.size !== b.size) return false;
          it = a2.entries();
          while (!(i2 = it.next()).done)
            if (!b.has(i2.value[0])) return false;
          return true;
        }
        if (hasArrayBuffer && ArrayBuffer.isView(a2) && ArrayBuffer.isView(b)) {
          length2 = a2.length;
          if (length2 != b.length) return false;
          for (i2 = length2; i2-- !== 0; )
            if (a2[i2] !== b[i2]) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b.source && a2.flags === b.flags;
        if (a2.valueOf !== Object.prototype.valueOf && typeof a2.valueOf === "function" && typeof b.valueOf === "function") return a2.valueOf() === b.valueOf();
        if (a2.toString !== Object.prototype.toString && typeof a2.toString === "function" && typeof b.toString === "function") return a2.toString() === b.toString();
        keys = Object.keys(a2);
        length2 = keys.length;
        if (length2 !== Object.keys(b).length) return false;
        for (i2 = length2; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i2])) return false;
        if (hasElementType && a2 instanceof Element) return false;
        for (i2 = length2; i2-- !== 0; ) {
          if ((keys[i2] === "_owner" || keys[i2] === "__v" || keys[i2] === "__o") && a2.$$typeof) {
            continue;
          }
          if (!equal(a2[keys[i2]], b[keys[i2]])) return false;
        }
        return true;
      }
      return a2 !== a2 && b !== b;
    }
    reactFastCompare = function isEqual2(a2, b) {
      try {
        return equal(a2, b);
      } catch (error) {
        if ((error.message || "").match(/stack|recursion/i)) {
          console.warn("react-fast-compare cannot handle circular refs");
          return false;
        }
        throw error;
      }
    };
    return reactFastCompare;
  }
  var reactFastCompareExports = requireReactFastCompare();
  const isEqual = getDefaultExportFromCjs(reactFastCompareExports);
  var depsEqual = function(aDeps, bDeps) {
    if (aDeps === void 0) {
      aDeps = [];
    }
    if (bDeps === void 0) {
      bDeps = [];
    }
    return isEqual(aDeps, bDeps);
  };
  function useEventListener(eventName, handler, options) {
    if (options === void 0) {
      options = {};
    }
    var _a = options.enable, enable = _a === void 0 ? true : _a;
    var handlerRef = useLatest(handler);
    useEffectWithTarget(function() {
      if (!enable) {
        return;
      }
      var targetElement = getTargetElement(options.target, window);
      if (!(targetElement === null || targetElement === void 0 ? void 0 : targetElement.addEventListener)) {
        return;
      }
      var eventListener = function(event) {
        return handlerRef.current(event);
      };
      var eventNameArray = Array.isArray(eventName) ? eventName : [eventName];
      eventNameArray.forEach(function(event) {
        targetElement.addEventListener(event, eventListener, {
          capture: options.capture,
          once: options.once,
          passive: options.passive
        });
      });
      return function() {
        eventNameArray.forEach(function(event) {
          targetElement.removeEventListener(event, eventListener, {
            capture: options.capture
          });
        });
      };
    }, [eventName, options.capture, options.once, options.passive, enable], options.target);
  }
  const useHover = function(target, options) {
    var _a = {}, onEnter = _a.onEnter, onLeave = _a.onLeave, onChange = _a.onChange;
    var _b = __read(useBoolean(), 2), state2 = _b[0], _c = _b[1], setTrue = _c.setTrue, setFalse = _c.setFalse;
    useEventListener("mouseenter", function() {
      onEnter === null || onEnter === void 0 ? void 0 : onEnter();
      setTrue();
      onChange === null || onChange === void 0 ? void 0 : onChange(true);
    }, {
      target
    });
    useEventListener("mouseleave", function() {
      onLeave === null || onLeave === void 0 ? void 0 : onLeave();
      setFalse();
      onChange === null || onChange === void 0 ? void 0 : onChange(false);
    }, {
      target
    });
    return state2;
  };
  var useDeepCompareEffectWithTarget = function(effect, deps, target) {
    var ref = H.useRef(void 0);
    var signalRef = H.useRef(0);
    if (!depsEqual(deps, ref.current)) {
      signalRef.current += 1;
    }
    ref.current = deps;
    useEffectWithTarget(effect, [signalRef.current], target);
  };
  var isAppleDevice = /(mac|iphone|ipod|ipad)/i.test(typeof navigator !== "undefined" ? navigator === null || navigator === void 0 ? void 0 : navigator.platform : "");
  var aliasKeyCodeMap = {
    "0": 48,
    "1": 49,
    "2": 50,
    "3": 51,
    "4": 52,
    "5": 53,
    "6": 54,
    "7": 55,
    "8": 56,
    "9": 57,
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    ctrl: 17,
    alt: 18,
    pausebreak: 19,
    capslock: 20,
    esc: 27,
    space: 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    leftarrow: 37,
    uparrow: 38,
    rightarrow: 39,
    downarrow: 40,
    insert: 45,
    delete: 46,
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    leftwindowkey: 91,
    rightwindowkey: 92,
    meta: isAppleDevice ? [91, 93] : [91, 92],
    selectkey: 93,
    numpad0: 96,
    numpad1: 97,
    numpad2: 98,
    numpad3: 99,
    numpad4: 100,
    numpad5: 101,
    numpad6: 102,
    numpad7: 103,
    numpad8: 104,
    numpad9: 105,
    multiply: 106,
    add: 107,
    subtract: 109,
    decimalpoint: 110,
    divide: 111,
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    numlock: 144,
    scrolllock: 145,
    semicolon: 186,
    equalsign: 187,
    comma: 188,
    dash: 189,
    period: 190,
    forwardslash: 191,
    graveaccent: 192,
    openbracket: 219,
    backslash: 220,
    closebracket: 221,
    singlequote: 222
  };
  var modifierKey = {
    ctrl: function(event) {
      return event.ctrlKey;
    },
    shift: function(event) {
      return event.shiftKey;
    },
    alt: function(event) {
      return event.altKey;
    },
    meta: function(event) {
      if (event.type === "keyup") {
        return aliasKeyCodeMap.meta.includes(event.keyCode);
      }
      return event.metaKey;
    }
  };
  function isValidKeyType(value) {
    return isString(value) || isNumber(value);
  }
  function countKeyByEvent(event) {
    var countOfModifier = Object.keys(modifierKey).reduce(function(total, key) {
      if (modifierKey[key](event)) {
        return total + 1;
      }
      return total;
    }, 0);
    return [16, 17, 18, 91, 92].includes(event.keyCode) ? countOfModifier : countOfModifier + 1;
  }
  function genFilterKey(event, keyFilter, exactMatch) {
    var e_1, _a;
    if (!event.key) {
      return false;
    }
    if (isNumber(keyFilter)) {
      return event.keyCode === keyFilter ? keyFilter : false;
    }
    var genArr = keyFilter.split(".");
    var genLen = 0;
    try {
      for (var genArr_1 = __values(genArr), genArr_1_1 = genArr_1.next(); !genArr_1_1.done; genArr_1_1 = genArr_1.next()) {
        var key = genArr_1_1.value;
        var genModifier = modifierKey[key];
        var aliasKeyCode = aliasKeyCodeMap[key.toLowerCase()];
        if (genModifier && genModifier(event) || aliasKeyCode && aliasKeyCode === event.keyCode) {
          genLen++;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (genArr_1_1 && !genArr_1_1.done && (_a = genArr_1.return)) _a.call(genArr_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    if (exactMatch) {
      return genLen === genArr.length && countKeyByEvent(event) === genArr.length ? keyFilter : false;
    }
    return genLen === genArr.length ? keyFilter : false;
  }
  function genKeyFormatter(keyFilter, exactMatch) {
    if (isFunction(keyFilter)) {
      return keyFilter;
    }
    if (isValidKeyType(keyFilter)) {
      return function(event) {
        return genFilterKey(event, keyFilter, exactMatch);
      };
    }
    if (Array.isArray(keyFilter)) {
      return function(event) {
        return keyFilter.find(function(item) {
          return genFilterKey(event, item, exactMatch);
        });
      };
    }
    return function() {
      return Boolean(keyFilter);
    };
  }
  var defaultEvents = ["keydown"];
  function useKeyPress(keyFilter, eventHandler, option) {
    var _a = option || {}, _b = _a.events, events2 = _b === void 0 ? defaultEvents : _b, target = _a.target, _c = _a.exactMatch, exactMatch = _c === void 0 ? false : _c, _d = _a.useCapture, useCapture = _d === void 0 ? false : _d;
    var eventHandlerRef = useLatest(eventHandler);
    var keyFilterRef = useLatest(keyFilter);
    useDeepCompareEffectWithTarget(function() {
      var e_2, _a2;
      var _b2;
      var el = getTargetElement(target, window);
      if (!el) {
        return;
      }
      var callbackHandler = function(event) {
        var _a3;
        var genGuard = genKeyFormatter(keyFilterRef.current, exactMatch);
        var keyGuard = genGuard(event);
        var firedKey = isValidKeyType(keyGuard) ? keyGuard : event.key;
        if (keyGuard) {
          return (_a3 = eventHandlerRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(eventHandlerRef, event, firedKey);
        }
      };
      try {
        for (var events_1 = __values(events2), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
          var eventName = events_1_1.value;
          (_b2 = el === null || el === void 0 ? void 0 : el.addEventListener) === null || _b2 === void 0 ? void 0 : _b2.call(el, eventName, callbackHandler, useCapture);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (events_1_1 && !events_1_1.done && (_a2 = events_1.return)) _a2.call(events_1);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
      return function() {
        var e_3, _a3;
        var _b3;
        try {
          for (var events_2 = __values(events2), events_2_1 = events_2.next(); !events_2_1.done; events_2_1 = events_2.next()) {
            var eventName2 = events_2_1.value;
            (_b3 = el === null || el === void 0 ? void 0 : el.removeEventListener) === null || _b3 === void 0 ? void 0 : _b3.call(el, eventName2, callbackHandler, useCapture);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (events_2_1 && !events_2_1.done && (_a3 = events_2.return)) _a3.call(events_2);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
      };
    }, [events2], target);
  }
  function useLockFn(fn) {
    var _this = this;
    var lockRef = H.useRef(false);
    return H.useCallback(function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return __awaiter(_this, void 0, void 0, function() {
        var ret, e_1;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (lockRef.current) {
                return [
                  2
];
              }
              lockRef.current = true;
              _a.label = 1;
            case 1:
              _a.trys.push([1, 3, 4, 5]);
              return [4, fn.apply(void 0, __spreadArray([], __read(args), false))];
            case 2:
              ret = _a.sent();
              return [2, ret];
            case 3:
              e_1 = _a.sent();
              throw e_1;
            case 4:
              lockRef.current = false;
              return [
                7
];
            case 5:
              return [
                2
];
          }
        });
      });
    }, [fn]);
  }
  function useRafState(initialState) {
    var ref = H.useRef(0);
    var _a = __read(H.useState(initialState), 2), state2 = _a[0], setState = _a[1];
    var setRafState = H.useCallback(function(value) {
      cancelAnimationFrame(ref.current);
      ref.current = requestAnimationFrame(function() {
        setState(value);
      });
    }, []);
    useUnmount(function() {
      cancelAnimationFrame(ref.current);
    });
    return [state2, setRafState];
  }
  var defaultShouldUpdate = function(a2, b) {
    return !Object.is(a2, b);
  };
  function usePrevious$1(state2, shouldUpdate) {
    if (shouldUpdate === void 0) {
      shouldUpdate = defaultShouldUpdate;
    }
    var prevRef = H.useRef(void 0);
    var curRef = H.useRef(void 0);
    if (shouldUpdate(curRef.current, state2)) {
      prevRef.current = curRef.current;
      curRef.current = state2;
    }
    return prevRef.current;
  }
  var useUnmountedRef = function() {
    var unmountedRef = H.useRef(false);
    H.useEffect(function() {
      unmountedRef.current = false;
      return function() {
        unmountedRef.current = true;
      };
    }, []);
    return unmountedRef;
  };
  const useUpdateLayoutEffect = createUpdateEffect(H.useLayoutEffect);
  const iconParkOutlineClose = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "m8 8l32 32M8 40L40 8" })
  ] });
  const ForwardRef$I = H.forwardRef(iconParkOutlineClose);
  const BaseModalClassNames = {
    modalMask: "fixed inset-0 z-gate-base-modal flex items-center justify-center bg-black/50",
    modal: "max-h-[calc(90vh-50px)] w-500px flex flex-col overflow-hidden b-1px b-transparent rounded-10px b-solid bg-gate-bg px-15px pb-15px text-gate-text dark:b-gate-border",
    modalHeader: "flex items-center justify-between border-b-0 py-10px",
    modalTitle: "mb-0 flex items-center text-[1.5rem] line-height-1.5",
    modalBody: "flex-grow-1 overflow-y-auto pt-0"
  };
  const APP_CLS_MODAL_VISIBLE = `${APP_NAMESPACE}-modal-visible`;
  const modalGlobalStyle = css("body:has(.", APP_CLS_MODAL_VISIBLE, "){overflow-y:hidden;}", "");
  function BaseModal({
    show,
    onHide: onHide2,
    children,
    clsModalMask,
    clsModal,
    width,
    hideWhenMaskOnClick = false,
    hideWhenEsc = false
  }) {
    const wrapperRef = H.useRef(null);
    const onMaskClick = useMemoizedFn((e2) => {
      const target = e2.target;
      if (wrapperRef.current?.contains(target)) return;
      const selectors = [
        '.ant-tooltip-inner[role="tooltip"]',
'.ant-popover-inner[role="tooltip"]',
".ant-select-dropdown"
];
      if (target.closest(selectors.join(","))) return;
      if (hideWhenMaskOnClick) {
        onHide2();
      }
    });
    useKeyPress("esc", (e2) => {
      if (!show) return;
      if (hideWhenEsc) {
        e2.preventDefault();
        e2.stopImmediatePropagation();
        setTimeout(onHide2);
      }
    }, {
      exactMatch: true
    });
    const _clsModalMask = n(BaseModalClassNames.modalMask, clsModalMask);
    const _clsModal = n(BaseModalClassNames.modal, clsModal);
    if (!show) {
      return null;
    }
    return require$$0.createPortal( jsx$1("div", { className: clsx(APP_CLS_ROOT, {
      [APP_CLS_MODAL_VISIBLE]: show
    }), "data-role": "base-modal", children: jsx$1("div", { className: _clsModalMask, onClick: onMaskClick, children: jsx$1("div", { className: _clsModal, style: {
      width
    }, ref: wrapperRef, children }) }) }), document.body);
  }
  const ModalClose = ({
    className,
    ...props
  }) => {
    const _className = n("ml-10px size-18px cursor-pointer", className);
    return jsx$1(ForwardRef$I, { ...props, className: _className });
  };
  let PurpleColors = function(PurpleColors$1) {
    PurpleColors$1["Lavender"] = "#e6e6fa";
    PurpleColors$1["Thistle"] = "#d8bfd8";
    PurpleColors$1["Plum"] = "#dda0dd";
    PurpleColors$1["Mauve"] = "#e0b0ff";
    PurpleColors$1["Wisteria"] = "#c9a0dc";
    PurpleColors$1["Orchid"] = "#da70d6";
    PurpleColors$1["MediumOrchid"] = "#ba55d3";
    PurpleColors$1["MediumPurple"] = "#9370db";
    PurpleColors$1["Amethyst"] = "#9966cc";
    PurpleColors$1["BlueViolet"] = "#8a2be2";
    PurpleColors$1["Purple"] = "#800080";
    PurpleColors$1["Violet"] = "#8f00ff";
    PurpleColors$1["Magenta"] = "#ff00ff";
    PurpleColors$1["Grape"] = "#6f2da8";
    PurpleColors$1["Indigo"] = "#4b0082";
    PurpleColors$1["Eggplant"] = "#301934";
    return PurpleColors$1;
  }({});
  const PURPLE_COLORS = [
    {
      name: "Lavender",
      nameZh: "薰衣草",
      hex: PurpleColors.Lavender,
      desc: "淡紫偏粉"
    },
    {
      name: "Thistle",
      nameZh: "蓟紫色",
      hex: PurpleColors.Thistle,
      desc: "带灰调"
    },
    {
      name: "Plum",
      nameZh: "李子紫",
      hex: PurpleColors.Plum,
      desc: "柔和温暖"
    },
    {
      name: "Mauve",
      nameZh: "淡紫色",
      hex: PurpleColors.Mauve,
      desc: "烟粉色调"
    },
    {
      name: "Wisteria",
      nameZh: "紫藤色",
      hex: PurpleColors.Wisteria,
      desc: "温柔浅紫"
    },
    {
      name: "Orchid",
      nameZh: "兰花紫",
      hex: PurpleColors.Orchid,
      desc: "偏红亮紫"
    },
    {
      name: "Medium Orchid",
      nameZh: "中兰花紫",
      hex: PurpleColors.MediumOrchid,
      desc: "稍深更艳"
    },
    {
      name: "Medium Purple",
      nameZh: "中紫色",
      hex: PurpleColors.MediumPurple,
      desc: "柔和略蓝"
    },
    {
      name: "Amethyst",
      nameZh: "紫水晶色",
      hex: PurpleColors.Amethyst,
      desc: "经典冷紫"
    },
    {
      name: "Blue Violet",
      nameZh: "蓝紫色",
      hex: PurpleColors.BlueViolet,
      desc: "较冷"
    },
    {
      name: "Purple",
      nameZh: "标准紫色",
      hex: PurpleColors.Purple,
      desc: "饱和且暗"
    },
    {
      name: "Violet",
      nameZh: "紫罗兰",
      hex: PurpleColors.Violet,
      desc: "更偏蓝光谱"
    },
    {
      name: "Magenta",
      nameZh: "洋红色",
      hex: PurpleColors.Magenta,
      desc: "红紫交界"
    },
    {
      name: "Grape",
      nameZh: "葡萄紫",
      hex: PurpleColors.Grape,
      desc: "饱和深紫"
    },
    {
      name: "Indigo",
      nameZh: "靛青色",
      hex: PurpleColors.Indigo,
      desc: "蓝紫之间"
    },
    {
      name: "Eggplant",
      nameZh: "茄子紫",
      hex: PurpleColors.Eggplant,
      desc: "极深紫红"
    }
  ];
  const LX_THEMES = [
    {
      id: "green",
      name: "绿意盎然",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(77, 175, 124)",
      colorTheme: "rgb(77, 175, 124)"
    },
    {
      id: "blue",
      name: "蓝田生玉",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(52, 152, 219)",
      colorTheme: "rgb(52, 152, 219)"
    },
    {
      id: "blue_plus",
      name: "蛋雅深蓝",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(77, 131, 175)",
      colorTheme: "rgb(77, 131, 175)"
    },
    {
      id: "orange",
      name: "橙黄橘绿",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(245, 171, 53)",
      colorTheme: "rgb(245, 171, 53)"
    },
    {
      id: "red",
      name: "热情似火",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(214, 69, 65)",
      colorTheme: "rgb(214, 69, 65)"
    },
    {
      id: "pink",
      name: "粉装玉琢",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(241, 130, 141)",
      colorTheme: "rgb(241, 130, 141)"
    },
    {
      id: "purple",
      name: "重斤球紫",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(155, 89, 182)",
      colorTheme: "rgb(155, 89, 182)"
    },
    {
      id: "grey",
      name: "灰常美丽",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(108, 122, 137)",
      colorTheme: "rgb(108, 122, 137)"
    },
    {
      id: "ming",
      name: "青出于黑",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(51, 110, 123)",
      colorTheme: "rgb(51, 110, 123)"
    },
    {
      id: "blue2",
      name: "清热板蓝",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(79, 98, 208)",
      colorTheme: "rgb(79, 98, 208)"
    },
    {
      id: "black",
      name: "黑灯瞎火",
      isDark: true,
      isCustom: false,
      colorPrimary: "rgb(150, 150, 150)",
      colorTheme: "rgb(59,59,59)"
    },
    {
      id: "mid_autumn",
      name: "月里嫦娥",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(74, 55, 82)",
      colorTheme: "rgb(74, 55, 82)"
    },
    {
      id: "naruto",
      name: "木叶之村",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(87, 144, 167)",
      colorTheme: "rgb(87, 144, 167)"
    },
    {
      id: "china_ink",
      name: "近墨者黑",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgba(47, 47, 47, 1)",
      colorTheme: "rgba(47, 47, 47, 1)"
    },
    {
      id: "happy_new_year",
      name: "新年快乐",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(192, 57, 43)",
      colorTheme: "rgb(192, 57, 43)"
    }
  ];
  const DEFAULT_BILI_PINK_THEME = {
    id: "default-bili-pink",
    name: "B站粉",
    colorPrimary: "#f69",
    tooltip: "B站品牌色"
  };
  const COLOR_PICKER_THEME = {
    id: "color-picker",
    name: "自定义",
    isCustom: true,
    colorPrimary: DEFAULT_BILI_PINK_THEME.colorPrimary
  };
  function toThemes(groupName, definitionStr) {
    return definitionStr.split("\n").map((s2) => s2.trim()).filter(Boolean).map((line2) => {
      const [colorPrimary, name] = line2.split(" ").filter(Boolean);
      return {
        id: `${groupName}:${name}`,
        name,
        colorPrimary
      };
    });
  }
  const LongwashingGroupName = "UP长期洗涤";
  const LongwashingThemes = toThemes(LongwashingGroupName, `
  #0545b2 理想之蓝
  #f4cd00 柠檬黄
  #ef2729 石榴红
  #f89c00 鹿箭
  #233728 黛绿
  #f2b9b7 和熙粉
  #f3cc91 芝士黄
  #6b4c68 葡萄紫
  #ff7227 落日橙
  #004d62 碧海天
  #23909b 洗碧空
  #aeb400 芥丝绿
  #425a17 箬叶青

  #002fa7 克莱因蓝
  #003153 普鲁士蓝
  #01847f 马尔斯绿
  #fbd26a 申布伦黄
  #470024 勃艮第红
  #492d22 凡戴克棕
  `);
  const BIBIBILI_EVOLVED_SYNC_ID = "bilibili-evolved-sync";
  const ThemeGroups = [{
    name: "预设",
    themes: [DEFAULT_BILI_PINK_THEME, {
      id: "bilibili-blue",
      name: "B站蓝",
      colorPrimary: "#00aeec",
      tooltip: "B站品牌色"
    }, {
      id: "app-custom-高能红",
      name: "高能红",
      colorPrimary: "#fd453e"
    }, {
      id: "app-custom-咸蛋黄",
      name: "咸蛋黄",
      colorPrimary: "#ffc034"
    }, {
      id: "app-custom-早苗绿",
      name: "早苗绿",
      colorPrimary: "#85c255"
    }, {
      id: "app-custom-宝石蓝",
      name: "宝石蓝",
      colorPrimary: "#0095ef"
    }, {
      id: "app-custom-罗兰紫",
      name: "罗兰紫",
      colorPrimary: "#a029ac"
    }, {
      id: BIBIBILI_EVOLVED_SYNC_ID,
      name: "B-Evolved",
      colorPrimary: "var(--theme-color, #f69)",
      tooltip: jsxs(Fragment, { children: [
        "使用 Bilibili-Evolved 的主题色",
jsx$1("br", {}),
        "在 Bilibili-Evolved 设置中修改主题色后可能需要刷新页面同步"
      ] })
    }, COLOR_PICKER_THEME]
  }, {
    name: "LX Themes",
    themes: LX_THEMES,
    tooltip: jsxs(Fragment, { children: [
      "提取自",
      " ",
jsx$1("a", { target: "_blank", href: "https://github.com/lyswhut/lx-music-desktop/", children: "lx-music-desktop" }),
jsx$1("br", {}),
      "Apache License 2.0"
    ] })
  }, {
    name: LongwashingGroupName,
    themes: LongwashingThemes,
    tooltip: jsxs(Fragment, { children: [
      "提取自",
      " ",
jsx$1("a", { target: "_blank", href: "https://www.bilibili.com/video/BV1g3411u7Lg/", children: "BV1g3411u7Lg" }),
      " ",
      "&",
      " ",
jsx$1("a", { target: "_blank", href: "https://www.bilibili.com/video/BV1xu411q7sU/", children: "BV1xu411q7sU" })
    ] })
  }, {
    name: "紫定能行",
    themes: PURPLE_COLORS.map((color) => ({
      id: `purple-colors-${color.name}`,
      name: color.nameZh,
      colorPrimary: color.hex,
      tooltip: jsxs(Fragment, { children: [
        color.name,
        " ",
        color.nameZh,
        " ",
jsx$1("br", {}),
        color.desc
      ] })
    })),
    tooltip: jsxs(Fragment, { children: [
      "提取自",
      " ",
jsx$1("a", { target: "_blank", href: "https://magicdawn.github.io/purple-colors/", children: "purple-colors" }),
      " "
    ] })
  }];
  const ALL_THEMES = ThemeGroups.map((x) => x.themes).flat();
  const EXTRA_TOOLTIP = {
    [`${LongwashingGroupName}:马尔斯绿`]: jsxs(Fragment, { children: [
      "马尔斯绿 MARRS GREEN ",
jsx$1("br", {}),
      "2017年英国的百年造纸商G.F SMITH和英国城市文化节联合发起了「选出全世界最受欢迎的颜色」的活动， ",
jsx$1("br", {}),
      "在为期半年由来自100多个约3万名用户的投票后，由来自苏格兰的联合国教科文组织工作人员 ",
jsx$1("br", {}),
      "安妮•马尔斯（ANNIE MARRS）提交的一种蓝绿色当选。 ",
jsx$1("br", {}),
      "马尔斯绿也因此由ANNIE MARRS的姓氏和主色调组合而得名。 ",
jsx$1("br", {}),
      "马尔斯绿的灵感来源于ANNIE家乡苏格兰的泰勒河畔自然景观的一种蓝绿色调。 ",
jsx$1("br", {})
    ] })
  };
  function useCurrentTheme() {
    let {
      theme: themeId,
      colorPickerThemeSelectedColor
    } = useSettingsSnapshot();
    themeId ||= DEFAULT_BILI_PINK_THEME.id;
    return H.useMemo(() => {
      const theme2 = ALL_THEMES.find((t2) => t2.id === themeId) || DEFAULT_BILI_PINK_THEME;
      if (theme2.id === COLOR_PICKER_THEME.id && colorPickerThemeSelectedColor) {
        return {
          ...theme2,
          colorPrimary: colorPickerThemeSelectedColor
        };
      }
      return theme2;
    }, [themeId, colorPickerThemeSelectedColor]);
  }
  function useColorPrimaryHex() {
    const currentTheme = useCurrentTheme();
    const evolvedThemeColor = $evolvedThemeColor.use();
    let colorPrimary = currentTheme.colorPrimary;
    if (currentTheme.id === BIBIBILI_EVOLVED_SYNC_ID) {
      colorPrimary = evolvedThemeColor || DEFAULT_BILI_PINK_THEME.colorPrimary;
    }
    return colorPrimary;
  }
  var _ref$5 = {
    name: "1ughwg6",
    styles: ".bili-feed4 .bili-header{min-height:64px!important;}"
  };
  var _ref2$2 = {
    name: "19h4ou9",
    styles: "body,.large-header,#i_cecream,.bili-header .bili-header__channel{background-color:var(--bg2);}.bili-header .bili-header__channel .channel-entry-more__link,.bili-header .bili-header__channel .channel-link{background-color:var(--bg1);}"
  };
  var _ref3$1 = {
    name: "ykj9m0",
    styles: "body{background-color:var(--bg1);}"
  };
  var _ref4 = {
    name: "xrkb6a",
    styles: "#i_cecream .bili-feed4-layout{display:none;}.desktop-download-tip,.vip-login-tip,.palette-button-adcard{display:none!important;}"
  };
  function GlobalStyle() {
    const colorPrimary = useColorPrimaryHex();
    const {
      pureRecommend,
      style
    } = useSettingsSnapshot();
    const dark = useIsDarkMode();
    const backToTopRight = useBackToTopRight();
    const usingEvolevdHeader = $usingEvolevdHeader.use();
    const antLinkColorGlobalStyle = useAntLinkColorGlobalStyle();
    const width = $headerWidth.use() ?? 90;
    const padding = "0 10px";
    const {
      useWhiteBackground
    } = style.pureRecommend;
    const config = H.useMemo(() => {
      return {
        text: dark ? "#fff" : "#333",
        bgSrc: dark ? "--bg1" : useWhiteBackground ? "--bg1" : "--bg2",
        bgFallback: dark ? "#222" : useWhiteBackground ? "#fff" : "#f6f7f8"
      };
    }, [dark, useWhiteBackground]);
    return jsxs(Fragment, { children: [
jsx$1(Global, { styles: [antLinkColorGlobalStyle, modalGlobalStyle, css`
            :root {
              ${appPrimaryColorId}: ${colorPrimary};
              ${appBgId}: var(${config.bgSrc}, ${config.bgFallback});
              ${appTextColorId}: var(--text1, ${config.text});
            }
          `, "", ""] }),
      IN_BILIBILI_HOMEPAGE && pureRecommend && jsx$1(Global, { styles: [
        _ref4,
        style.pureRecommend.useCustomGrid && css("#i_cecream,.bili-feed4 .bili-header,.bili-feed4 .bili-header .bili-header__bar{max-width:unset;}.bili-feed4-layout,.bili-feed4 .bili-header .bili-header__channel{max-width:", width, "%;padding:", padding, ";}", ""),
        style.pureRecommend.useCustomGrid && typeof backToTopRight === "number" && css(".", APP_CLS_ROOT, "{--back-top-right:", backToTopRight, "px;}", ""),
style.pureRecommend.useWhiteBackground ? _ref3$1 : _ref2$2,
        style.pureRecommend.hideTopChannel && css(".bili-header__channel,.bili-header__banner{display:none!important;}", !usingEvolevdHeader && _ref$5, " .bili-feed4 .bili-header .bili-header__bar{&.slide-down,&:not(.slide-down){animation:headerSlideDown 0.3s linear forwards!important;box-shadow:0 2px 4px ", dark ? "rgb(255 255 255 / 5%)" : "rgb(0 0 0 / 8%)", "!important;}}.bili-header__bar:not(.slide-down){background-color:var(--bg1);color:var(--text1);transition:background-color 0.2s linear;animation-name:headerSlideDown;.left-entry{.mini-header__title,.entry-title,.default-entry,.loc-mc-box__text,.download-entry,.loc-entry{color:var(--text1);}}.right-entry .right-entry__outside{.right-entry-text,.right-entry-icon{color:var(--text2);}}}.area-header-wrapper{margin-top:10px;}", ""),
        "",
        ""
      ] })
    ] });
  }
  cache$4.compat = true;
  function compose(...fns) {
    return function(c2) {
      return fns.reduceRight((content, fn) => fn(content), c2);
    };
  }
  function AppRoot({
    children,
    injectGlobalStyle = false,
    antdSetup = false,
    emotionCache = cache$4,
    styleProviderProps
  }) {
    const dark = useIsDarkMode();
    const colorPrimary = useColorPrimaryHex();
    const wrap = compose(
(c2) => jsx$1(CacheProvider, { value: emotionCache, children: c2 }),
(c2) => jsx$1(cssinjs.StyleProvider, { ...styleProviderProps, children: c2 }),
(c2) => jsx$1(antd.ConfigProvider, { locale: zhCN, button: {
        autoInsertSpace: false
      }, theme: {
        cssVar: true,
        algorithm: dark ? antd.theme.darkAlgorithm : antd.theme.defaultAlgorithm,
        token: {
          colorPrimary,
          colorBgSpotlight: colorPrimary,
zIndexPopupBase: Number(zIndexAntdPopupBase),
          fontFamily: appUsingFont
        },
        components: {
          Notification: {
            zIndexPopup: Number(zIndexAntdPopupBase)
          },
          Button: {
defaultShadow: "none",
            primaryShadow: "none"
          }
        }
      }, children: c2 })
    );
    return wrap( jsxs(Fragment, { children: [
      antdSetup && jsx$1(AntdStaticFunctionsSetup, {}),
      injectGlobalStyle && jsx$1(GlobalStyle, {}),
      children
    ] }));
  }
  var observerMap = new Map();
  var RootIds = new WeakMap();
  var rootId = 0;
  var unsupportedValue = void 0;
  function getRootId(root2) {
    if (!root2) return "0";
    if (RootIds.has(root2)) return RootIds.get(root2);
    rootId += 1;
    RootIds.set(root2, rootId.toString());
    return RootIds.get(root2);
  }
  function optionsToId(options) {
    return Object.keys(options).sort().filter(
      (key) => options[key] !== void 0
    ).map((key) => {
      return `${key}_${key === "root" ? getRootId(options.root) : options[key]}`;
    }).toString();
  }
  function createObserver(options) {
    const id = optionsToId(options);
    let instance = observerMap.get(id);
    if (!instance) {
      const elements = new Map();
      let thresholds;
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          var _a;
          const inView = entry.isIntersecting && thresholds.some((threshold) => entry.intersectionRatio >= threshold);
          if (options.trackVisibility && typeof entry.isVisible === "undefined") {
            entry.isVisible = inView;
          }
          (_a = elements.get(entry.target)) == null ? void 0 : _a.forEach((callback) => {
            callback(inView, entry);
          });
        });
      }, options);
      thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);
      instance = {
        id,
        observer,
        elements
      };
      observerMap.set(id, instance);
    }
    return instance;
  }
  function observe(element, callback, options = {}, fallbackInView = unsupportedValue) {
    if (typeof window.IntersectionObserver === "undefined" && fallbackInView !== void 0) {
      const bounds = element.getBoundingClientRect();
      callback(fallbackInView, {
        isIntersecting: fallbackInView,
        target: element,
        intersectionRatio: typeof options.threshold === "number" ? options.threshold : 0,
        time: 0,
        boundingClientRect: bounds,
        intersectionRect: bounds,
        rootBounds: bounds
      });
      return () => {
      };
    }
    const { id, observer, elements } = createObserver(options);
    const callbacks = elements.get(element) || [];
    if (!elements.has(element)) {
      elements.set(element, callbacks);
    }
    callbacks.push(callback);
    observer.observe(element);
    return function unobserve() {
      callbacks.splice(callbacks.indexOf(callback), 1);
      if (callbacks.length === 0) {
        elements.delete(element);
        observer.unobserve(element);
      }
      if (elements.size === 0) {
        observer.disconnect();
        observerMap.delete(id);
      }
    };
  }
  function useInView({
    threshold,
    delay: delay2,
    trackVisibility,
    rootMargin,
    root: root2,
    triggerOnce,
    skip,
    initialInView,
    fallbackInView,
    onChange
  } = {}) {
    var _a;
    const [ref, setRef] = H__namespace.useState(null);
    const callback = H__namespace.useRef(onChange);
    const [state2, setState] = H__namespace.useState({
      inView: !!initialInView,
      entry: void 0
    });
    callback.current = onChange;
    H__namespace.useEffect(
      () => {
        if (skip || !ref) return;
        let unobserve;
        unobserve = observe(
          ref,
          (inView, entry) => {
            setState({
              inView,
              entry
            });
            if (callback.current) callback.current(inView, entry);
            if (entry.isIntersecting && triggerOnce && unobserve) {
              unobserve();
              unobserve = void 0;
            }
          },
          {
            root: root2,
            rootMargin,
            threshold,
trackVisibility,
delay: delay2
          },
          fallbackInView
        );
        return () => {
          if (unobserve) {
            unobserve();
          }
        };
      },

[
Array.isArray(threshold) ? threshold.toString() : threshold,
        ref,
        root2,
        rootMargin,
        triggerOnce,
        skip,
        trackVisibility,
        fallbackInView,
        delay2
      ]
    );
    const entryTarget = (_a = state2.entry) == null ? void 0 : _a.target;
    const previousEntryTarget = H__namespace.useRef(void 0);
    if (!ref && entryTarget && !triggerOnce && !skip && previousEntryTarget.current !== entryTarget) {
      previousEntryTarget.current = entryTarget;
      setState({
        inView: !!initialInView,
        entry: void 0
      });
    }
    const result = [setRef, state2.inView, state2.entry];
    result.ref = result[0];
    result.inView = result[1];
    result.entry = result[2];
    return result;
  }
  function useEmitterOn(emitter2, type, handler) {
    const fn = useMemoizedFn(handler);
    H.useEffect(() => {
      emitter2.on(type, fn);
      return () => {
        emitter2.off(type, fn);
      };
    }, [emitter2, type]);
  }
  function useRefState(initialValue2) {
    const [state2, setState] = H.useState(initialValue2);
    const ref = H.useRef(state2);
    const setStateWraped = H.useCallback((payload) => {
      const nextState = typeof payload === "function" ? payload(ref.current) : payload;
      ref.current = nextState;
      setState(nextState);
    }, [setState]);
    const getState = H.useCallback(() => ref.current, []);
    return [state2, setStateWraped, getState];
  }
  function useRefStateBox(initialValue2) {
    const [state2, set2, get2] = useRefState(initialValue2);
    const box = H.useMemo(() => ({
      state: state2,
get: get2,
      set: set2,
      get val() {
        return get2();
      },
      set val(newValue) {
        set2(newValue);
      }
    }), [get2, set2]);
    box.state = state2;
    return box;
  }
  function useRefBox(initialValue2) {
    const ref = H.useRef(initialValue2);
    const get2 = H.useCallback(() => ref.current, []);
    const set2 = H.useCallback((newValue) => ref.current = newValue, []);
    return H.useMemo(() => ({
      get: get2,
      set: set2,
      get val() {
        return get2();
      },
      set val(newValue) {
        set2(newValue);
      }
    }), [get2, set2]);
  }
  const kbdClassName = "cursor-pointer rounded bg-gate-bg-lv-3 p-x-1 text-gate-primary";
  const antSpinIndicator = jsx$1(ForwardRef$O, { className: "text-gate-primary [.ant-spin_.ant-spin-dot&]:size-25px" });
  function AntdTooltip(props) {
    return jsx$1(antd.Tooltip, { ...props, styles: {
      ...props.styles,
      root: {
        width: "max-content",
        maxWidth: "50vw",
        ...props.styles?.root
      }
    }, children: props.children });
  }
  const iconParkOutlineTips = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M40 20c0 6.808-4.252 12.622-10.244 14.934H18.244C12.252 32.622 8 26.808 8 20c0-8.837 7.163-16 16-16s16 7.163 16 16" }),
jsx$1("path", { d: "m29.756 34.934l-.68 8.15a1 1 0 0 1-.996.916h-8.16a1 1 0 0 1-.996-.917l-.68-8.15M18 17v6l6-3l6 3v-6" })
    ] })
  ] });
  const ForwardRef$H = H.forwardRef(iconParkOutlineTips);
  const DefaultIconComponent = ForwardRef$H;
  const TOOLTIP_BLACK_BG_COLOR = "rgb(0 0 0 / 0.85)";
  function HelpInfo({
    children,
    tooltipProps,
    IconComponent,
    className,
    useBlackBg,
    ...restSvgProps
  }) {
    IconComponent ??= DefaultIconComponent;
    const icon = jsx$1(IconComponent, { ...restSvgProps, className: n("ml-4px size-16px cursor-pointer", className) });
    return !!children && jsx$1(AntdTooltip, { color: useBlackBg ? TOOLTIP_BLACK_BG_COLOR : void 0, ...tooltipProps, title: children, children: icon });
  }
  function IconAnimatedChecked({
    size = 18,
    useAnimation = false,
    color = "currentColor",
    ...restProps
  }) {
    return jsx$1("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: size, height: size, ...restProps, children: jsx$1(framerMotion.motion.path, { fill: "transparent", stroke: color, strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M5 11L11 17L21 7", ...useAnimation ? {
      initial: {
        pathLength: 0
      },
      animate: {
        pathLength: 1
      },
      transition: {
        duration: 0.2,
        ease: "easeInOut"
      }
    } : void 0 }) });
  }
  function wrapComponent({
    Component,
    defaultProps: defaultProps2,
    containerClassName
  }) {
    const proxyProps2 = proxy(defaultProps2);
    function WrappedComponent() {
      const props = useSnapshot(proxyProps2);
      return jsx$1(Component, { ...props });
    }
    const mount = once(() => {
      const div = document.createElement("div");
      div.className = clsx(APP_CLS_ROOT, containerClassName);
      document.body.appendChild(div);
      clientExports.createRoot(div).render( jsx$1(AppRoot, { children: jsx$1(WrappedComponent, {}) }));
    });
    function wrapAction(action2) {
      return (...args) => {
        mount();
        return action2(...args);
      };
    }
    const updateProps2 = wrapAction((newProps) => {
      Object.assign(proxyProps2, newProps);
    });
    return {
      WrappedComponent,
      proxyProps: proxyProps2,
      mount,
      wrapAction,
      updateProps: updateProps2
    };
  }
  const dislikedIds = proxyMap();
  function useDislikedIds() {
    return useSnapshot(dislikedIds);
  }
  function useDislikedReason(id) {
    const map = useDislikedIds();
    return id ? map.get(id) : void 0;
  }
  function delDislikeId(id) {
    dislikedIds.delete(id);
  }
  const defaultProps$1 = {
    show: false,
    reasons: [],
    onHide: onHide$1,
    okAction: void 0
  };
  const {
    proxyProps: proxyProps$1,
    updateProps: updateProps$1
  } = wrapComponent({
    Component: ModalDislike,
    containerClassName: "show-dislike-container",
    defaultProps: defaultProps$1
  });
  const emitter$2 = new Emittery();
  function onHide$1() {
    emitter$2.emit("modal-close");
    updateProps$1({
      show: false,
      reasons: [],
      okAction: void 0
    });
  }
  async function pickDislikeReason(reasons, okAction) {
    updateProps$1({
      show: true,
      reasons,
      okAction
    });
    await emitter$2.once("modal-close");
  }
  const useModalDislikeVisible = function() {
    return useSnapshot(proxyProps$1).show;
  };
  function ModalDislike({
    show,
    reasons,
    onHide: onHide2,
    okAction
  }) {
    const modalBodyRef = H.useRef(null);
    const keyPressEnabled = () => !!show && !!reasons?.length;
    const $req = useRequest(async (reason) => okAction?.(reason), {
      manual: true
    });
    const okActionLoading = $req.loading;
    const [activeIndex, setActiveIndex] = H.useState(reasons.length - 1);
    useUpdateLayoutEffect(() => {
      setActiveIndex(reasons.length - 1);
    }, [reasons]);
    const KEYS = ["1", "2", "3", "4", "5", "6"];
    useKeyPress(KEYS, (e2) => {
      if (!keyPressEnabled()) return;
      if (!KEYS.includes(e2.key)) return;
      if (!reasons?.length) return;
      const index = Number(e2.key) - 1;
      if (!(index >= 0 && index < reasons.length)) return;
      setActiveIndex(index);
    });
    const increaseIndex = useMemoizedFn((by) => {
      if (!keyPressEnabled()) return;
      if (shouldDisableShortcut()) return;
      const len = reasons.length;
      let newIndex = activeIndex + by;
      if (newIndex < 0) newIndex = newIndex % len + len;
      if (newIndex > len - 1) newIndex = newIndex % len;
      setActiveIndex(newIndex);
    });
    useKeyPress("uparrow", () => increaseIndex(-1), {
      exactMatch: true
    });
    useKeyPress("downarrow", () => increaseIndex(1), {
      exactMatch: true
    });
    const onOk = useLockFn(async (e2) => {
      if (!keyPressEnabled()) return;
      if (activeIndex < 0 || activeIndex > reasons.length - 1) return;
      const reason = reasons[activeIndex];
      if (!reason) return;
      e2.preventDefault();
      e2.stopPropagation();
      const result = await $req.runAsync(reason);
      if (result) onHide2();
    });
    useKeyPress("enter", onOk, {
      exactMatch: true
    });
    return jsxs(BaseModal, { show, onHide: onHide2, hideWhenMaskOnClick: true, hideWhenEsc: true, width: 350, clsModal: "rounded-15px", children: [
jsxs("div", { className: BaseModalClassNames.modalHeader, children: [
jsxs("div", { className: BaseModalClassNames.modalTitle, children: [
jsx$1(IconForDislike, { className: "size-25px" }),
jsx$1("span", { className: "ml-5px", children: "我不想看" }),
jsxs(HelpInfo, { children: [
            "选择后将减少相似内容推荐 ",
jsx$1("br", {}),
            "操作说明: ",
jsx$1("br", {}),
jsxs("div", { className: "ml-10px", children: [
              "1. 使用删除键打开弹窗, Esc 关闭 ",
jsx$1("br", {}),
              "2. 数字键 或 方向键选择 ",
jsx$1("br", {}),
              "3. 回车键 或 确定按钮提交 ",
jsx$1("br", {})
            ] })
          ] })
        ] }),
jsx$1(ModalClose, { onClick: onHide2 })
      ] }),
jsx$1("div", { className: BaseModalClassNames.modalBody, ref: modalBodyRef, children: jsx$1(antd.Spin, { spinning: okActionLoading, indicator: antSpinIndicator, children: jsx$1("div", { className: "reason-list mb-20px mt-20px flex flex-col gap-y-10px", children: reasons.map((reason, index) => {
        const active = index === activeIndex;
        return jsxs("button", { "data-id": reason.id, className: clsx("reason", {
          active
        }, "relative flex items-center b-2px rounded-6px b-solid py-12px", active ? "b-gate-primary" : "b-gate-border"), disabled: okActionLoading, onClick: () => {
          setActiveIndex(index);
        }, children: [
jsx$1("span", { "data-cls": "reason-no", className: "ml-6px size-20px flex flex-none items-center justify-center rounded-full bg-gate-primary color-white", children: index + 1 }),
jsx$1("span", { className: "flex-1 px-4px", children: reason.name }),
jsx$1("span", { className: "mr-6px size-20px flex-none", children: active && jsx$1(IconAnimatedChecked, { className: "h-100% w-100% color-gate-primary", useAnimation: true }) })
        ] }, reason.id);
      }) }) }) }),
jsxs("div", { className: "mt-2 flex items-center justify-end gap-x-10px", children: [
jsx$1(antd.Button, { onClick: onHide2, children: "取消" }),
jsx$1(antd.Button, { type: "primary", onClick: onOk, loading: okActionLoading, children: "确定" })
      ] })
    ] });
  }
  const IN_BILIBILI_VIDEO_PLAY_PAGE = IN_BILIBILI_MAIN && ["/video/", "/list/watchlater", "/bangumi/play/"].some((prefix2) => location.pathname.startsWith(prefix2));
  const handlers = [["/video/", () => {
    return /^\/video\/(?<bvid>BV\w+)\//.exec(location.pathname)?.groups?.bvid;
  }], ["/list/watchlater", () => {
    return new URLSearchParams(location.search).get("bvid") || void 0;
  }], ["/bangumi/play/", () => {
    return void 0;
  }]];
  function getCurrentPageBvid() {
    const config = handlers.find(([prefix2]) => location.pathname.startsWith(prefix2));
    return config?.[1]();
  }
  async function fetchFavCollections(page) {
    const res = await request.get("/x/v3/fav/folder/collected/list", {
      params: {
        up_mid: getUid(),
        platform: "web",
        ps: 20,
        pn: page
      }
    });
    const json = res.data;
    return json.data;
  }
  async function fetchAllFavCollections() {
    let page = 1;
    let hasMore = true;
    let items = [];
    while (hasMore) {
      const data2 = await fetchFavCollections(page);
      items.push(...data2.list);
      hasMore = data2.has_more;
      page++;
    }
    items = items.filter((x) => {
      if (x.title === "该合集已失效" && x.upper.mid === 0) return false;
      return true;
    });
    items = uniqBy(items, (x) => x.id);
    return items;
  }
  async function fetchCollectionDetail(collectionId, page) {
    const res = await request.get("/x/space/fav/season/list", {
      params: {
        season_id: collectionId,
        ps: 20,
        pn: page
      }
    });
    const json = res.data;
    return json.data;
  }
  var FavItemsOrder = ((FavItemsOrder2) => {
    FavItemsOrder2["Initial"] = "initial";
    FavItemsOrder2["Shuffle"] = "shuffle";
    FavItemsOrder2["PubTimeDesc"] = "pub-time-desc";
    FavItemsOrder2["PubTimeAsc"] = "pub-time-asc";
    FavItemsOrder2["PlayCountDesc"] = "play-count-desc";
    FavItemsOrder2["CollectCountDesc"] = "collect-count-desc";
    FavItemsOrder2["FavTimeDesc"] = "fav-time-desc";
    FavItemsOrder2["FavTimeAsc"] = "fav-time-asc";
    return FavItemsOrder2;
  })(FavItemsOrder || {});
  function handleItemsOrder(items, itemsOrder) {
    if (itemsOrder === "initial") {
      return items;
    }
    if (itemsOrder === "shuffle") {
      return shuffle(items);
    }
    if (itemsOrder === "pub-time-desc" || itemsOrder === "pub-time-asc") {
      const order = itemsOrder === "pub-time-desc" ? "desc" : "asc";
      return orderBy(items, [(x) => x.pubtime], [order]);
    }
    if ((itemsOrder === "fav-time-desc" || itemsOrder === "fav-time-asc") && items.every((x) => x.from === "fav-folder")) {
      const order = itemsOrder === "fav-time-desc" ? "desc" : "asc";
      return orderBy(items, [(x) => x.fav_time], [order]);
    }
    if (itemsOrder === "play-count-desc") {
      return orderBy(items, [(x) => x.cnt_info.play], ["desc"]);
    }
    if (itemsOrder === "collect-count-desc") {
      return orderBy(items, [(x) => x.cnt_info.collect], ["desc"]);
    }
    return items;
  }
  const styled = {
    createClass: css$1,
    c: css$1
  };
  class BaseTabService {
    qs;
    constructor(qsPageSize) {
      this.qs = new QueueStrategy(qsPageSize);
    }
    get hasMore() {
      return !!this.qs.bufferQueue.length || this.hasMoreExceptQueue;
    }
    restore() {
      this.qs.restore();
    }
    async loadMore(abortSignal) {
      if (!this.hasMore) return;
      if (this.qs.bufferQueue.length) return this.qs.sliceFromQueue();
      const more = await this.fetchMore(abortSignal);
      if (more?.length) this.qs.bufferQueue.push(...more);
      return this.qs.sliceFromQueue();
    }
  }
  class QueueStrategy {
returnQueue = [];
    bufferQueue = [];
    get hasCache() {
      return !!this.returnQueue.length;
    }
    ps;
    constructor(ps = 20) {
      this.ps = ps;
    }
    sliceCountFromQueue(count) {
      if (this.bufferQueue.length) {
        const sliced = this.bufferQueue.slice(0, count);
        this.bufferQueue = this.bufferQueue.slice(count);
        return this.doReturnItems(sliced) ?? [];
      } else {
        return [];
      }
    }
    sliceFromQueue(page = 1) {
      return this.sliceCountFromQueue(this.ps * page);
    }
doReturnItems(items) {
      this.returnQueue = [...this.returnQueue, ...items ?? []];
      return items;
    }
restore() {
      this.bufferQueue = [...this.returnQueue, ...this.bufferQueue];
      this.returnQueue = [];
    }
    get fetchedCount() {
      return this.returnQueue.length + this.bufferQueue.length;
    }
  }
  function usePopupContainer() {
    const ref = H.useRef(null);
    const getPopupContainer = H.useCallback(() => {
      return ref.current?.closest(`.${APP_CLS_TAB_BAR}`) || document.body;
    }, []);
    return {
      ref,
      getPopupContainer
    };
  }
  function useBooleanSettingsPath(configPath, extraAction) {
    const snap = useSettingsSnapshot();
    const checked = !!get(snap, configPath, false);
    const onChange = H.useCallback((val) => {
      set(settings, configPath, val);
      extraAction?.(val);
    }, []);
    const checkboxOnChange = H.useCallback((e2) => {
      onChange(e2.target.checked);
    }, []);
    const onToggle = H.useCallback(() => {
      onChange(!get(settings, configPath, false));
    }, []);
    return {
      checked,
      onChange,
      checkboxOnChange,
      onToggle
    };
  }
  function __FlagSettingItem({
    configPath,
    label,
    extraAction,
    tooltip,
    tooltipProps,
    as,
    checkboxProps,
    switchProps
  }) {
    const {
      checked,
      onChange,
      checkboxOnChange
    } = useBooleanSettingsPath(configPath, extraAction);
    const wrapTooltip = (children) => {
      if (!tooltip) return children;
      return jsx$1(AntdTooltip, { ...tooltipProps, title: tooltip, children });
    };
    let usingLabel;
    if (typeof label === "function") {
      usingLabel = label(checked);
    } else {
      usingLabel = label || configPath;
    }
    if (as === "checkbox") {
      let inner = jsx$1("span", { style: {
        userSelect: "none"
      }, children: usingLabel });
      if (tooltip) inner = wrapTooltip(inner);
      return jsx$1(antd.Checkbox, { ...checkboxProps, checked, onChange: checkboxOnChange, children: inner });
    }
    if (as === "switch") {
      let content = jsx$1(antd.Switch, { ...switchProps, checked, onChange });
      if (tooltip) content = wrapTooltip(content);
      return content;
    }
  }
  function CheckboxSettingItem({
    configPath,
    label,
    extraAction,
    tooltip,
    tooltipProps,
    ...otherProps
  }) {
    return jsx$1(__FlagSettingItem, { ...{
      configPath,
      label,
      extraAction,
      tooltip,
      tooltipProps,
      as: "checkbox",
      checkboxProps: otherProps
    } });
  }
  function SwitchSettingItem({
    configPath,
    extraAction,
    tooltip,
    tooltipProps,
    ...otherProps
  }) {
    return jsx$1(__FlagSettingItem, { ...{
      configPath,
      extraAction,
      tooltip,
      tooltipProps,
      as: "switch",
      switchProps: otherProps
    } });
  }
  var EApiType = ((EApiType2) => {
    EApiType2["Separator"] = "separator";
    EApiType2["AppRecommend"] = "app-recommend";
    EApiType2["PcRecommend"] = "pc-recommend";
    EApiType2["DynamicFeed"] = "dynamic-feed";
    EApiType2["Watchlater"] = "watchlater";
    EApiType2["Fav"] = "fav";
    EApiType2["PopularGeneral"] = "popular-general";
    EApiType2["PopularWeekly"] = "popular-weekly";
    EApiType2["Rank"] = "ranking";
    EApiType2["Live"] = "live";
    EApiType2["SpaceUpload"] = "space-upload";
    return EApiType2;
  })(EApiType || {});
  class PopularGeneralRecService {
    constructor(anonymous) {
      this.anonymous = anonymous;
    }
    hasMore = true;
    page = 1;
    async loadMore() {
      if (!this.hasMore) return;
      const res = await request.get("/x/web-interface/popular", {
        params: {
          ps: 20,
          pn: this.page
        },
        withCredentials: !this.anonymous
      });
      const json = res.data;
      if (!isWebApiSuccess(json)) {
        return toast(json.message || REQUEST_FAIL_MSG), void 0;
      }
      this.page++;
      this.hasMore = !json.data.no_more;
      const items = (json.data.list || []).map((item) => {
        return {
          ...item,
          api: EApiType.PopularGeneral,
          uniqId: `${EApiType.PopularGeneral}-${item.bvid}`
        };
      });
      return items;
    }
    get usageInfo() {
      return jsx$1(PopularGeneralUsageInfo, {});
    }
  }
  function PopularGeneralUsageInfo() {
    const onRefresh = useOnRefreshContext();
    const tooltip = jsx$1(Fragment, { children: "✅ 匿名访问: 使用游客身份访问" });
    const extraAction = async () => {
      await delay(100);
      onRefresh?.();
    };
    const checkbox = jsx$1(CheckboxSettingItem, { configPath: "popularGeneralUseAnonymous", tooltip, label: "匿名访问", extraAction });
    return checkbox;
  }
  function getBiliPlayerConfig() {
    const key = "bpx_player_profile";
    const str = localStorage.getItem(key);
    if (!str) return;
    try {
      const val = JSON.parse(str);
      return val;
    } catch {
      return;
    }
  }
  function getBiliPlayerConfigAutoPlay() {
    const config = getBiliPlayerConfig();
    return !!config?.media.autoplay;
  }
  function getIdbCache(tableName) {
    const db = localforage.createInstance({
      driver: localforage.INDEXEDDB,
      name: APP_NAMESPACE,
      storeName: tableName
    });
    return {
      db,
      get(key) {
        return db.getItem(key.toString());
      },
      set(key, entry) {
        return db.setItem(key.toString(), entry);
      },
      delete(key) {
        return db.removeItem(key.toString());
      }
    };
  }
  function wrapWithIdbCache({
    fn,
    generateKey,
    tableName,
    ttl,
    concurrency,
autoCleanUp = true
  }) {
    const cache2 = typeof tableName === "string" ? getIdbCache(tableName) : tableName;
    const cleanUp = throttle$1(() => {
      cache2.db.iterate((cached, key) => {
        if (!shouldReuseCached(cached)) {
          cache2.db.removeItem(key);
        }
      });
    }, 1e3);
    if (autoCleanUp) {
      whenIdle().then(cleanUp);
    }
    function shouldReuseCached(cached) {
      return Boolean(cached && cached.val && cached.ts && Date.now() - cached.ts <= ttl);
    }
    async function queryCache(...args) {
      const key = generateKey(...args);
      const cached = await cache2.get(key);
      if (cached && shouldReuseCached(cached)) {
        return cached.val;
      }
    }
    const fnLimited = concurrency && concurrency > 0 ? limitFunction(fn, concurrency) : fn;
    const fnMemoized = pMemoize(fnLimited, {
      cacheKey(args) {
        return generateKey(...args);
      },
      cache: {
        async has(key) {
          const cached = await cache2.get(key);
          return shouldReuseCached(cached);
        },
        async get(key) {
          const cached = await cache2.get(key);
          if (cached && shouldReuseCached(cached)) return cached.val;
        },
        async set(key, val) {
          if (isNil(val)) return;
          await cache2.set(key, {
            val,
            ts: Date.now()
          });
        },
        async delete(key) {
          await cache2.delete(key);
        }
      }
    });
    Object.defineProperties(fnMemoized, {
      cache: {
        value: cache2
      },
      cleanUp: {
        value: cleanUp
      },
      generateKey: {
        value: generateKey
      },
      shouldReuseCached: {
        value: shouldReuseCached
      },
      queryCache: {
        value: queryCache
      }
    });
    return fnMemoized;
  }
  async function __fetchVideoDetail(bvid) {
    const res = await request.get("/x/web-interface/view", {
      params: {
        bvid
      }
    });
    const json = res.data;
    const data2 = json.data;
    return data2;
  }
  const getVideoDetail = wrapWithIdbCache({
    fn: __fetchVideoDetail,
    generateKey: (bvid) => bvid,
    tableName: "video-detail",
    ttl: ms("3M"),
    concurrency: 3
  });
  async function __fetchVideoPageList(bvid) {
    const res = await request.get("/x/player/pagelist", {
      params: {
        bvid
      }
    });
    const json = res.data;
    return json?.data || [];
  }
  const getVideoPageList = wrapWithIdbCache({
    fn: __fetchVideoPageList,
    generateKey: (bvid) => bvid,
    tableName: "video-page-list",
    ttl: ms("3M"),
    concurrency: 3
  });
  async function fetchKvData({
    appKey,
    nscode,
    versionId
  }) {
    const params = {
      appKey,
      nscode,
      versionId
    };
    const res = await request.get("/x/kv-frontend/namespace/data", {
      params
    });
    const json = res.data;
    return json;
  }
  function generateCacheKey({
    appKey,
    nscode
  }) {
    return new URLSearchParams([["appKey", appKey], ["nscode", nscode.toString()]]).toString();
  }
  const kvVersionCache = getIdbCache("kv-latest-version");
  const revalidateKvData = reusePendingPromise(async ({
    appKey,
    nscode
  }) => {
    const cacheKey2 = generateCacheKey({
      appKey,
      nscode
    });
    const entry = await kvVersionCache.get(cacheKey2);
    let versionId = "0";
    if (entry && entry.versionId && entry.data && Object.keys(entry.data).length) {
      versionId = entry.versionId;
    }
    const fetched = await fetchKvData({
      appKey,
      nscode,
      versionId
    });
    if (entry?.data && fetched.code === -304 && fetched.message === "Not Modified") {
      return entry.data;
    }
    await kvVersionCache.set(cacheKey2, fetched.data);
    return fetched.data.data;
  });
  const getKvData = wrapWithIdbCache({
    fn: revalidateKvData,
    tableName: "get-kv-data",
    generateKey: ({
      appKey,
      nscode
    }) => generateCacheKey({
      appKey,
      nscode
    }),
    ttl: ms("1h")
  });
  function getGroupFromKvRecord(data2 = {}, prefix2) {
    if (!prefix2.endsWith(".")) prefix2 += ".";
    const grouped = {};
    if (data2) {
      Object.keys(data2).filter((k) => k.startsWith(prefix2)).forEach((k) => {
        const key = k.slice(prefix2.length);
        const val = data2[k] || "";
        grouped[key] = val;
      });
    }
    return grouped;
  }
  const STATIC_RANK_TABS = [{
    tid: 0,
    name: "全部",
    slug: "all",
    season_type: 0,
    type: "all"
  }, {
    tid: 0,
    name: "番剧",
    slug: "anime",
    season_type: 1,
    type: "anime"
  }, {
    tid: 0,
    name: "国创",
    slug: "guochuang",
    season_type: 4,
    type: "guochuang"
  }, {
    tid: 0,
    name: "纪录片",
    slug: "documentary",
    season_type: 3,
    type: "documentary"
  }, {
    tid: 0,
    name: "电影",
    slug: "movie",
    season_type: 2,
    type: "movie"
  }, {
    tid: 0,
    name: "电视剧",
    slug: "tv",
    season_type: 5,
    type: "tv"
  }, {
    tid: 0,
    name: "综艺",
    slug: "variety",
    season_type: 7,
    type: "variety"
  }, {
    tid: 1005,
    name: "动画",
    slug: "douga",
    season_type: 0,
    type: "douga"
  }, {
    tid: 1008,
    name: "游戏",
    slug: "game",
    season_type: 0,
    type: "game"
  }, {
    tid: 1007,
    name: "鬼畜",
    slug: "kichiku",
    season_type: 0,
    type: "kichiku"
  }, {
    tid: 1003,
    name: "音乐",
    slug: "music",
    season_type: 0,
    type: "music"
  }, {
    tid: 1004,
    name: "舞蹈",
    slug: "dance",
    season_type: 0,
    type: "dance"
  }, {
    tid: 1001,
    name: "影视",
    slug: "cinephile",
    season_type: 0,
    type: "cinephile"
  }, {
    tid: 1002,
    name: "娱乐",
    slug: "ent",
    season_type: 0,
    type: "ent"
  }, {
    tid: 1010,
    name: "知识",
    slug: "knowledge",
    season_type: 0,
    type: "knowledge"
  }, {
    tid: 1012,
    name: "科技数码",
    slug: "tech",
    season_type: 0,
    type: "tech"
  }, {
    tid: 1020,
    name: "美食",
    slug: "food",
    season_type: 0,
    type: "food"
  }, {
    tid: 1013,
    name: "汽车",
    slug: "car",
    season_type: 0,
    type: "car"
  }, {
    tid: 1014,
    name: "时尚美妆",
    slug: "fashion",
    season_type: 0,
    type: "fashion"
  }, {
    tid: 1018,
    name: "体育运动",
    slug: "sports",
    season_type: 0,
    type: "sports"
  }, {
    tid: 1024,
    name: "动物",
    slug: "animal",
    season_type: 0,
    type: "animal"
  }];
  const defaultRankTab = {
    name: "全站",
    tid: 0,
    slug: "all"
  };
  async function getRankTabsConfig() {
    try {
      return await parseRankTabsConfig() || STATIC_RANK_TABS;
    } catch (e2) {
      appError("parseRankTabsConfig failed", e2);
      return STATIC_RANK_TABS;
    }
  }
  async function parseRankTabsConfig() {
    const _raw = await getKvData({
      appKey: "333.1339",
      nscode: 10
    });
    const record = getGroupFromKvRecord(_raw, "channel_list");
    const popular_page_sort = JSON.parse(record.popular_page_sort || "");
    if (!popular_page_sort.length) return;
    const list2 = [];
    const push = (obj) => {
      list2.push({
        tid: obj.tid || 0,
        name: obj.name,
        slug: obj.route,
        season_type: obj.seasonType || 0,
        type: obj.route
      });
    };
    for (const slug of popular_page_sort) {
      if (!record[slug]) continue;
      const obj = JSON.parse(record[slug]);
      push(obj);
    }
    return uniqBy(list2, (x) => x.slug);
  }
  var ERankApiType = ((ERankApiType2) => {
    ERankApiType2["Normal"] = "normal";
    ERankApiType2["PgcSeason"] = "pgc/season";
    ERankApiType2["PgcWeb"] = "pgc/web";
    return ERankApiType2;
  })(ERankApiType || {});
  function getRankTabRequestConfig(rankTab) {
    if (!["anime", "guochuang", "documentary", "movie", "tv", "variety"].includes(rankTab.type || "")) {
      return {
        apiType: "normal",
        url: `/x/web-interface/ranking/v2?rid=${rankTab.tid}&type=all`
      };
    }
    const {
      season_type
    } = rankTab;
    const query = `?day=3&season_type=${season_type}`;
    let url = `/pgc/web/rank/list${query}`;
    let apiType = "pgc/web";
    if (season_type && [2, 3, 4, 5, 7].includes(season_type)) {
      url = `/pgc/season/rank/web/list${query}`;
      apiType = "pgc/season";
    }
    return {
      apiType,
      url
    };
  }
  function isNormalRankItem(item) {
    return item.from === "normal";
  }
  function isPgcSeasonRankItem(item) {
    return item.from === "pgc/season";
  }
  function isPgcWebRankItem(item) {
    return item.from === "pgc/web";
  }
  function setForwardedRef(forwardedRef, value) {
    if (!forwardedRef) return;
    if (typeof forwardedRef === "function") {
      forwardedRef(value);
    } else {
      forwardedRef.current = value;
    }
  }
  function useMixedRef(forwardedRef) {
    const ref = H.useRef(null);
    return H.useMemo(() => {
      return {
        get current() {
          return ref.current;
        },
        set current(val) {
          ref.current = val;
          setForwardedRef(forwardedRef, val);
        }
      };
    }, [ref]);
  }
  const C = {
    top: (inlinePosition) => clsx("absolute top-8px", inlinePosition === "left" ? "left-8px" : "right-8px", inlinePosition === "left" ? clsZLeftMarks : clsZRightActions),
    topContainer: (inlinePosition) => clsx(C.top(inlinePosition), "flex items-center gap-x-5px", inlinePosition === "left" ? "flex-row" : "flex-row-reverse"),
    tooltip: (inlinePosition) => clsx("pointer-events-none absolute bottom--6px translate-y-100% select-none whitespace-nowrap rounded-4px bg-gate-primary px-8px py-4px text-12px text-white line-height-18px", inlinePosition === "left" ? "left--5px" : "right--5px")
  };
  const VideoCardActionButton = H.memo(H.forwardRef(({
    inlinePosition,
    icon,
    tooltip,
    visible = true,
    active = false,
    className,
    useMotion = false,
    motionProps,
    ...divProps
  }, forwardedRef) => {
    const {
      triggerRef,
      tooltipEl
    } = useTooltip({
      inlinePosition,
      tooltip
    });
    const _className = H.useMemo(() => {
      return g("action-button", "relative size-28px cursor-pointer rounded-6px bg-[rgb(33_33_33_/_0.7)] color-white", "b-1px b-solid", active ? "b-gate-primary" : "b-#444", "hover:b-gate-primary", useMotion ? "inline-flex" : visible ? "inline-flex" : "hidden", "items-center justify-center", "[&_svg]:pointer-events-none [&_svg]:select-none", className);
    }, [active, className, visible, useMotion]);
    const sharedProps = {
      ...divProps,
      className: _className,
      ref: (el) => {
        triggerRef.current = el;
        setForwardedRef(forwardedRef, el);
      },
      children: jsxs(Fragment, { children: [
        icon,
        tooltipEl
      ] })
    };
    if (!useMotion) {
      return jsx$1("div", { ...sharedProps });
    } else {
      return jsx$1(framerMotion.AnimatePresence, { children: visible && jsx$1(framerMotion.motion.div, { ...sharedProps, ...motionProps }, "action-button") });
    }
  }));
  function useTooltip({
    inlinePosition,
    tooltip,
    tooltipClassName
  }) {
    const triggerRef = H.useRef(null);
    const hovering = useHover(triggerRef);
    const tooltipEl = jsx$1("span", { style: {
      display: hovering ? "block" : "none"
    }, className: n(C.tooltip(inlinePosition), tooltipClassName), children: tooltip });
    return {
      triggerRef,
      tooltipEl
    };
  }
  function createLessFrequentFn(fn, initialTargetTimes, harder = true) {
    let times2 = 0;
    let targetTimes = initialTargetTimes;
    return (...args) => {
      times2++;
      if (times2 === targetTimes) {
        times2 = 0;
        if (harder) targetTimes++;
        return fn(...args);
      }
    };
  }
  function useLessFrequentFn(fn, initialTargetTimes, harder = true) {
    const _fn = useMemoizedFn(fn);
    return H.useMemo(() => {
      return createLessFrequentFn(_fn, initialTargetTimes, harder);
    }, [_fn, initialTargetTimes, harder]);
  }
  const radixIconsOpenInNewWindow = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 15 15", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M8.5 6q.049 0 .098.009q.076.017.142.054q.061.034.114.083q.05.052.082.113A.5.5 0 0 1 9 6.5v3a.5.5 0 0 1-1 0V7.707l-5.146 5.147a.5.5 0 1 1-.708-.707L7.293 7H5.5a.5.5 0 0 1 0-1zM12 2a1 1 0 0 1 1 1v9a1 1 0 0 1-1 1H8.5a.5.5 0 0 1 0-1H12V3H3v3.5a.5.5 0 0 1-1 0V3a1 1 0 0 1 1-1z" })
  ] });
  const ForwardRef$G = H.forwardRef(radixIconsOpenInNewWindow);
  const radixIconsCross2 = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 15 15", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M10.969 3.219a.574.574 0 1 1 .812.812L8.313 7.5l3.468 3.469l.074.09a.575.575 0 0 1-.796.796l-.09-.074L7.5 8.312l-3.469 3.47a.574.574 0 1 1-.812-.813L6.688 7.5l-3.47-3.469l-.073-.09a.575.575 0 0 1 .796-.797l.09.075L7.5 6.687z" })
  ] });
  const ForwardRef$F = H.forwardRef(radixIconsCross2);
  const radixIconsLockClosed = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 15 15", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M7.501.978c1.074 0 1.968.345 2.59 1.014c.616.664.909 1.587.909 2.642V6h1a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h1V4.636c0-1.055.293-1.979.91-2.643c.622-.67 1.517-1.015 2.591-1.015M3 13h9V7H3zM7.501 1.978c-.855 0-1.461.27-1.857.696C5.243 3.105 5 3.76 5 4.636V6h5V4.634c0-.877-.241-1.531-.642-1.962c-.395-.426-1.001-.694-1.857-.694" })
  ] });
  const ForwardRef$E = H.forwardRef(radixIconsLockClosed);
  const radixIconsLockOpen1 = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 15 15", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M7.499 0c1.072 0 1.966.338 2.589 1.002c.619.66.912 1.58.912 2.634V6h1a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h7V3.636c0-.876-.242-1.524-.642-1.95C8.963 1.267 8.357 1 7.5 1c-.888 0-1.502.269-1.895.715l-.077.092C5.197 2.233 5 2.843 5 3.633H4c0-.95.237-1.795.737-2.44l.121-.145C5.482.342 6.4 0 7.5 0M3 13h9V7H3z" })
  ] });
  const ForwardRef$D = H.forwardRef(radixIconsLockOpen1);
  function renderInPipWindow(newHref, pipWindow) {
    const cssInsertContainer = pipWindow.document.head;
    const {
      cache: cache2
    } = createEmotion({
      key: "pip-window",
      container: cssInsertContainer
    });
    Array.from(document.querySelectorAll("style")).filter((s2) => {
      return s2.textContent?.includes(APP_NAMESPACE);
    }).forEach((s2) => {
      const style = pipWindow.document.createElement("style");
      style.textContent = s2.textContent;
      pipWindow.document.head.appendChild(style);
    });
    const container = document.createElement("div");
    container.classList.add(APP_CLS_ROOT);
    container.style.lineHeight = "0";
    pipWindow.document.body.appendChild(container);
    const root2 = clientExports.createRoot(container);
    root2.render( jsx$1(AppRoot, { emotionCache: cache2, styleProviderProps: {
      container: cssInsertContainer
    }, injectGlobalStyle: true, children: jsx$1(antd.App, { message: {
      getContainer: () => pipWindow.document.body
    }, children: jsx$1(PipWindowContent, { newHref, pipWindow }) }) }));
  }
  var _ref$4 = {
    name: "pb1257",
    styles: "*{box-sizing:border-box;}:root,body,iframe{margin:0;padding:0;overscroll-behavior:none;}"
  };
  function PipWindowContent({
    newHref,
    pipWindow
  }) {
    const hovering = useHover(pipWindow.document.documentElement);
    const [locked, setLocked] = H.useState(() => settings.pipWindow.defaultLocked);
    return jsxs(Fragment, { children: [
jsx$1(Global, { styles: [_ref$4, "", ""] }),
jsx$1("iframe", { src: newHref, className: "h-100vh w-full border-none" }),
jsx$1(LockOverlay, { locked }),
jsxs("div", { className: clsx("fixed right-10px top-10px z-9999 flex-row-reverse items-center gap-x-6px", hovering ? "flex" : "hidden"), children: [
jsx$1(CloseThenOpenButton, { pipWindow, newHref }),
jsx$1(LockButton, { locked, setLocked })
      ] })
    ] });
  }
  const actionButtonExtraClassName = "[&_svg]:size-14px";
  function LockOverlay({
    locked
  }) {
    const {
      message: message2
    } = antd.App.useApp();
    const onOverlayClick = useLessFrequentFn(() => {
      message2.info("请先点击右上角 🔓解锁按钮 解锁");
    }, 3);
    return locked && jsx$1("div", { className: clsx("locked-overlay", "fixed inset-0 z-9999 select-none bg-transparent"), onClick: onOverlayClick });
  }
  function CloseThenOpenButton({
    newHref,
    pipWindow
  }) {
    const onClick = () => {
      pipWindow.close();
      const u2 = new URL(newHref);
      u2.searchParams.delete(QueryKey.PlayerScreenMode);
      u2.searchParams.delete(QueryKey.ForceAutoPlay);
      openNewTab(u2.href);
    };
    return jsx$1(VideoCardActionButton, { inlinePosition: "right", icon: jsx$1(ForwardRef$G, {}), tooltip: "新窗口打开", onClick, className: actionButtonExtraClassName });
  }
  function LockButton({
    locked,
    setLocked
  }) {
    return jsx$1(VideoCardActionButton, { inlinePosition: "right", icon: locked ? jsx$1(ForwardRef$E, {}) : jsx$1(ForwardRef$D, {}), tooltip: locked ? "已锁定, 点击解锁" : "已解锁, 点击锁定", className: actionButtonExtraClassName, onClick: () => setLocked((x) => !x) });
  }
  const debug$c = baseDebug.extend("VideoCard:useOpenRelated");
  function useOpenRelated({
    href,
    item,
    cardData,
    actionButtonVisible,
    hasOpenInPopupActionButton,
    getLargePreviewCurrentTime,
    hideLargePreview,
    shouldUseLargePreviewCurrentTime
  }) {
    const {
      videoLinkOpenMode
    } = useSettingsSnapshot();
    function getHref(action2) {
      const u2 = new URL(href, location.href);
      action2?.(u2);
      const newHref = u2.href;
      return newHref;
    }
    const handleVideoLinkClick = useMemoizedFn((e2) => {
      e2.stopPropagation();
      e2.preventDefault();
      onOpenWithMode(void 0, e2);
    });
    const onOpenWithMode = useMemoizedFn((mode, e2) => {
      mode ||= settings.videoLinkOpenMode;
      const newHref = getHref((u2) => {
        if (mode === VideoLinkOpenMode.NormalWebFullscreen || mode === VideoLinkOpenMode.Popup && settings.pipWindow.autoWebFullscreen) {
          u2.searchParams.set(QueryKey.PlayerScreenMode, PlayerScreenMode.WebFullscreen);
          if (mode === VideoLinkOpenMode.Popup && !getBiliPlayerConfigAutoPlay()) {
            u2.searchParams.set(QueryKey.ForceAutoPlay, ForceAutoPlay.ON);
          }
        }
        if (shouldUseLargePreviewCurrentTime()) {
          const largePreviewT = getLargePreviewCurrentTime();
          if (largePreviewT) {
            hideLargePreview();
            u2.searchParams.set("t", largePreviewT.toString());
          }
        }
      });
      const handleCommon = () => {
        const backgroud = mode === VideoLinkOpenMode.Background || !!(e2?.metaKey || e2?.ctrlKey);
        const active = !backgroud;
        openNewTab(newHref, active);
      };
      const handleCurrentPage = () => {
        location.href = newHref;
      };
      const handlers2 = {
        [VideoLinkOpenMode.Normal]: handleCommon,
        [VideoLinkOpenMode.Background]: handleCommon,
        [VideoLinkOpenMode.CurrentPage]: handleCurrentPage,
        [VideoLinkOpenMode.NormalWebFullscreen]: handleCommon,
        [VideoLinkOpenMode.Popup]: () => handlePopup(newHref),
        [VideoLinkOpenMode.Iina]: handleIINA
      };
      handlers2[mode]?.();
    });
    function handlePopup(newHref) {
      const {
        width,
        height
      } = getRecItemDimension({
        item
      });
      return openInPipOrPopup(newHref, cardData.bvid, width, height);
    }
    function handleIINA() {
      let usingHref = href;
      if (item.api === EApiType.Watchlater) usingHref = `/video/${item.bvid}`;
      const fullHref = new URL(usingHref, location.href).href;
      const iinaUrl = `iina://open?url=${encodeURIComponent(fullHref)}`;
      window.open(iinaUrl, "_self");
    }
    const consistentOpenMenus = H.useMemo(() => {
      return Object.values(VideoLinkOpenMode).filter((mode) => typeof VideoLinkOpenModeConfig[mode].enabled === "undefined").map((mode) => {
        return {
          key: VideoLinkOpenModeKey[mode],
          label: VideoLinkOpenModeConfig[mode].label,
          icon: VideoLinkOpenModeConfig[mode].icon,
          onClick: () => onOpenWithMode(mode)
        };
      });
    }, []);
    const conditionalOpenMenus = H.useMemo(() => {
      return Object.values(VideoLinkOpenMode).filter((mode) => typeof VideoLinkOpenModeConfig[mode].enabled === "boolean" && VideoLinkOpenModeConfig[mode].enabled).length ? Object.values(VideoLinkOpenMode).filter((mode) => typeof VideoLinkOpenModeConfig[mode].enabled === "boolean" && VideoLinkOpenModeConfig[mode].enabled).map((mode) => {
        return {
          key: VideoLinkOpenModeKey[mode],
          label: VideoLinkOpenModeConfig[mode].label,
          icon: VideoLinkOpenModeConfig[mode].icon,
          onClick: () => onOpenWithMode(mode)
        };
      }) : [];
    }, []);
    const openInPopupActionButtonEl = H.useMemo(() => {
      if (videoLinkOpenMode === VideoLinkOpenMode.Popup) return;
      if (item.api === EApiType.Live) return;
      if (!hasDocumentPictureInPicture) return;
      if (!hasOpenInPopupActionButton) return;
      return jsx$1(VideoCardActionButton, { visible: actionButtonVisible, inlinePosition: "right", icon: VideoLinkOpenModeConfig.Popup.icon, tooltip: VideoLinkOpenModeConfig.Popup.label, onClick: (e2) => {
        e2.preventDefault();
        e2.stopPropagation();
        onOpenWithMode(VideoLinkOpenMode.Popup);
      } });
    }, [videoLinkOpenMode, actionButtonVisible]);
    const onOpenInPopup = useMemoizedFn(() => {
      onOpenWithMode(VideoLinkOpenMode.Popup);
    });
    return {
      onOpenWithMode,
      handleVideoLinkClick,
      consistentOpenMenus,
      conditionalOpenMenus,
      openInPopupActionButtonEl,
      onOpenInPopup
    };
  }
  function getRecItemDimension({
    item,
    dimensionFromApi
  }) {
    let width;
    let height;
    let aspectRatio;
    if (dimensionFromApi) {
      [width, height] = [dimensionFromApi.width, dimensionFromApi.height];
      if (dimensionFromApi.rotate === 1) [width, height] = [height, width];
      aspectRatio = width / height;
    } else if (item?.api === EApiType.AppRecommend && item.uri?.startsWith("bilibili://")) {
      const searchParams2 = new URL(item.uri).searchParams;
      const playerWidth = Number(searchParams2.get("player_width") || 0);
      const playerHeight = Number(searchParams2.get("player_height") || 0);
      const playerRotate = Number(searchParams2.get("player_rotate") || 0);
      if (playerWidth && playerHeight && !Number.isNaN(playerWidth) && !Number.isNaN(playerHeight)) {
        [width, height] = [playerWidth, playerHeight];
        if (playerRotate === 1) [width, height] = [height, width];
        aspectRatio = width / height;
      }
    } else if (item?.api === EApiType.Rank && isNormalRankItem(item)) {
      const w = item.dimension.width;
      const h2 = item.dimension.height;
      const rotate = item.dimension.rotate;
      if (w && h2 && !Number.isNaN(w) && !Number.isNaN(h2)) {
        [width, height] = [w, h2];
        if (rotate === 1) [width, height] = [height, width];
        aspectRatio = width / height;
      }
    }
    return {
      width,
      height,
      aspectRatio
    };
  }
  const hasDocumentPictureInPicture = !!window.documentPictureInPicture?.requestWindow;
  async function openInPipOrPopup(newHref, bvid, videoWidth, videoHeight) {
    let popupWidth = 1e3;
    let popupHeight = Math.ceil(popupWidth / 16 * 9);
    const MAX_API_WAIT = 200;
    if ((!videoWidth || !videoHeight) && bvid) {
      const videoPages = await Promise.race([getVideoPageList(bvid), delay(MAX_API_WAIT)]);
      if (videoPages?.[0]?.dimension) {
        const {
          dimension
        } = videoPages[0];
        videoWidth = dimension.width;
        videoHeight = dimension.height;
      }
    }
    if (videoWidth && videoHeight && videoWidth < videoHeight) {
      const maxHeight = Math.min(Math.floor(window.screen.availHeight * 0.8), 1e3);
      const maxWidth = Math.floor(maxHeight / videoHeight * videoWidth);
      popupWidth = Math.min(720, maxWidth);
      popupHeight = Math.floor(popupWidth / videoWidth * videoHeight);
    }
    debug$c("openInPipOrPopup newHref=%s size=%sx%s", newHref, popupWidth, popupHeight);
    let pipWindow;
    if (hasDocumentPictureInPicture) {
      try {
        pipWindow = await window.documentPictureInPicture?.requestWindow({
          width: popupWidth,
          height: popupHeight,
          disallowReturnToOpener: true
        });
      } catch {
      }
    }
    if (pipWindow) {
      renderInPipWindow(newHref, pipWindow);
    } else {
      openPopupWindow(newHref, popupWidth, popupHeight);
    }
  }
  function openPopupWindow(newHref, popupWidth, popupHeight) {
    const left = (window.innerWidth - popupWidth) / 2;
    const top = (window.innerHeight - popupHeight) / 2 - 50;
    const features = ["popup=true", `width=${popupWidth}`, `height=${popupHeight}`, `left=${left}`, `top=${top}`].join(",");
    debug$c("openInPopup: features -> %s", features);
    window.open(newHref, "_blank", features);
  }
  function useLinkNewTab() {
    const {
      videoLinkOpenMode
    } = useSettingsSnapshot();
    return videoLinkOpenMode !== VideoLinkOpenMode.CurrentPage;
  }
  function useLinkTarget() {
    const newTab = useLinkNewTab();
    return newTab ? "_blank" : "_self";
  }
  function getLinkTarget() {
    const newTab = settings.videoLinkOpenMode !== VideoLinkOpenMode.CurrentPage;
    return newTab ? "_blank" : "_self";
  }
  function CustomTargetLink(props) {
    const target = useLinkTarget();
    return jsx$1("a", { ...props, target, children: props.children });
  }
  let episodes = [];
  let cacheKey = "";
  function genCacheKey() {
    const now = dayjs();
    return [now.format("YYYYMMDD"), now.hour() < 18 ? "lt-18" : "gte-18"].join("_");
  }
  async function getEpisodeList() {
    const useCache = episodes.length && cacheKey && cacheKey === genCacheKey();
    if (useCache) return episodes;
    const res = await request.get("/x/web-interface/popular/series/list");
    const json = res.data;
    const list2 = json.data.list;
    episodes = list2;
    cacheKey = genCacheKey();
    return episodes;
  }
  class PopularWeeklyRecService {
    constructor(useShuffle) {
      this.useShuffle = useShuffle;
    }
    static PAGE_SIZE = 20;
    episodesLoaded = false;
    episodes = [];
qs = new QueueStrategy(PopularWeeklyRecService.PAGE_SIZE);
    get hasMore() {
      if (!this.episodesLoaded) return true;
      return !!this.qs.bufferQueue.length || !!this.episodes.length;
    }
    async loadMore() {
      if (!this.episodesLoaded) {
        this.episodes = await getEpisodeList();
        this.episodesLoaded = true;
        if (this.useShuffle) this.episodes = shuffle(this.episodes);
      }
      if (!this.hasMore) return;
      if (!this.useShuffle) {
        if (this.qs.bufferQueue.length) return this.qs.sliceFromQueue();
        const ep = this.episodes[0];
        const epNum = ep.number;
        const items = await fetchWeeklyItems(epNum);
        this.qs.bufferQueue.push({
          api: EApiType.Separator,
          uniqId: `popular-weekly-separator-${epNum}`,
          content: jsx$1(CustomTargetLink, { href: `https://www.bilibili.com/v/popular/weekly?num=${epNum}`, children: ep.name })
        }, ...items);
        this.episodes = this.episodes.slice(1);
        return this.qs.sliceFromQueue();
      }
      const prefetchPage = 5;
      while (this.qs.bufferQueue.length < PopularWeeklyRecService.PAGE_SIZE * prefetchPage && this.episodes.length) {
        this.episodes = shuffle(this.episodes);
        const episodes2 = this.episodes.slice(0, prefetchPage);
        this.episodes = this.episodes.slice(prefetchPage);
        const fetched = await pmap(episodes2.map((x) => x.number), (episodeNum) => fetchWeeklyItems(episodeNum), 2);
        this.qs.bufferQueue = shuffle([...this.qs.bufferQueue, ...fetched.flat()]);
      }
      return this.qs.sliceFromQueue();
    }
    get usageInfo() {
      return jsx$1(PopularWeeklyUsageInfo, {});
    }
  }
  const cache$2 = {};
  async function fetchWeeklyItems(episodeNum) {
    if (!cache$2[episodeNum]?.length) {
      const res = await request.get("/x/web-interface/popular/series/one", {
        params: {
          number: episodeNum
        }
      });
      const json = res.data;
      const items2 = (json.data.list || []).map((item) => {
        return {
          ...item,
          api: EApiType.PopularWeekly,
          uniqId: `${EApiType.PopularWeekly}-${item.bvid}`
        };
      });
      cache$2[episodeNum] = items2;
    }
    const items = cache$2[episodeNum];
    return items;
  }
  function PopularWeeklyUsageInfo() {
    const onRefresh = useOnRefreshContext();
    return jsx$1(Fragment, { children: jsx$1(SwitchSettingItem, { configPath: "popularWeeklyUseShuffle", checkedChildren: "随机顺序: 开", unCheckedChildren: "随机顺序: 关", extraAction: async () => {
      await delay(100);
      onRefresh?.();
    } }) });
  }
  const storageKey = "rank-store-slug";
  const initialSlug = await( GM.getValue(storageKey)) || defaultRankTab.slug;
  const rankStore = proxy({
    slug: initialSlug,
    tabs: [],
    get currentTab() {
      return this.tabs.find((x) => x.slug === this.slug) || defaultRankTab;
    }
  });
  const updateRankTabs = reusePendingPromise(async () => {
    if (rankStore.tabs.length) return;
    const rankTabs = await getRankTabsConfig();
    rankStore.tabs = rankTabs;
  });
  subscribeKey(rankStore, "slug", () => {
    GM.setValue(storageKey, rankStore.slug);
  });
  class RankRecService {
    constructor(slug) {
      this.slug = slug;
    }
    loaded = false;
    qs = new QueueStrategy(20);
    get hasMore() {
      if (!this.loaded) return true;
      return !!this.qs.bufferQueue.length;
    }
    get rankTab() {
      return snapshot(rankStore).tabs.find((x) => x.slug === this.slug) || defaultRankTab;
    }
    async loadMore(abortSignal) {
      if (!this.hasMore) return;
      if (!this.loaded) {
        await updateRankTabs();
        const {
          url,
          apiType
        } = getRankTabRequestConfig(this.rankTab);
        const res = await request.get(url, {
          signal: abortSignal
        });
        const json = res.data;
        this.loaded = true;
        if (!isWebApiSuccess(json)) {
          toast(json.message || REQUEST_FAIL_MSG);
          return;
        }
        const list2 = json?.data?.list || json?.result?.list || [];
        const items = list2.map((item, index) => {
          const rankingNo = index + 1;
          return {
            ...item,
            api: EApiType.Rank,
            uniqId: `${EApiType.Rank}-${this.rankTab.slug}-rankingNo:${rankingNo}`,
            rankingNo,
            slug: this.rankTab.slug,
            rankTab: this.rankTab,
            from: apiType
          };
        });
        this.qs.bufferQueue = items;
      }
      return this.qs.sliceFromQueue();
    }
    get usageInfo() {
      return jsx$1(RankUsageInfo, {});
    }
  }
  function RankUsageInfo() {
    const {
      ref,
      getPopupContainer
    } = usePopupContainer();
    const onRefresh = useOnRefreshContext();
    const {
      slug,
      currentTab,
      tabs
    } = useSnapshot(rankStore);
    const renderRankTabList = (list2, label, helpInfoContent) => {
      if (!list2.length) return null;
      return jsxs("div", { className: "mt-15px max-w-350px first:mt-0", children: [
jsxs("p", { className: "mb-5px flex-v-center rounded-5px bg-gate-primary py-5px pl-6px text-white", children: [
          label,
          !!helpInfoContent && jsx$1(HelpInfo, { children: helpInfoContent })
        ] }),
jsx$1("div", { className: "grid grid-cols-4 gap-x-10px gap-y-8px px-2px", children: list2.map((c2) => {
          const active = c2.slug === slug;
          return jsx$1(antd.Button, { className: clsx({
            "b-gate-primary": active,
            "color-gate-primary": active
          }), onClick: (e2) => {
            setPopoverOpen(false);
            rankStore.slug = c2.slug;
            onRefresh?.();
          }, children: jsx$1("span", { children: c2.name }) }, c2.slug);
        }) })
      ] });
    };
    const {
      normalList,
      pgcList
    } = H.useMemo(() => {
      const listWithApiType = tabs.map((x) => ({
        ...x,
        apiType: getRankTabRequestConfig(x).apiType
      }));
      const pgcList2 = listWithApiType.filter((x) => [ERankApiType.PgcSeason, ERankApiType.PgcWeb].includes(x.apiType));
      const normalList2 = listWithApiType.filter((x) => x.apiType === ERankApiType.Normal);
      return {
        normalList: normalList2,
        pgcList: pgcList2
      };
    }, [tabs]);
    const handleDropdownButtonClick = useMemoizedFn((e2) => {
      const list2 = [...normalList, ...pgcList];
      if (!list2.length) return;
      const index = list2.findIndex((x) => x.slug === slug);
      if (index === -1) return;
      const offset = e2.shiftKey ? -1 : 1;
      const nextIndex = (index + offset + list2.length) % list2.length;
      rankStore.slug = list2[nextIndex].slug;
      onRefresh?.();
    });
    const popoverContent = jsxs(Fragment, { children: [
      renderRankTabList(normalList, "视频"),
      renderRankTabList(pgcList, "PGC内容", "不能提供预览")
    ] });
    const [popoverOpen, setPopoverOpen] = H.useState(false);
    const popover = jsx$1(antd.Popover, { arrow: false, open: popoverOpen, onOpenChange: setPopoverOpen, placement: "bottomLeft", getPopupContainer, content: popoverContent, styles: {
      body: {
        border: `1px solid ${usePopoverBorderColor()}`
      }
    }, children: jsx$1(antd.Button, { css: [popoverOpen && buttonOpenCss, "", ""], onClick: handleDropdownButtonClick, className: "outline-none!", children: currentTab.name }) });
    return jsx$1("div", { ref, children: popover });
  }
  const subtabServiceCreators = {
    [EHotSubTab.PopularGeneral]: () => new PopularGeneralRecService(settings.popularGeneralUseAnonymous),
    [EHotSubTab.PopularWeekly]: () => new PopularWeeklyRecService(settings.popularWeeklyUseShuffle),
    [EHotSubTab.Rank]: () => new RankRecService(rankStore.slug)
  };
  function isHotTabUsingShuffle(shuffleForPopularWeekly) {
    const {
      subtab
    } = hotStore;
    shuffleForPopularWeekly ??= settings.popularWeeklyUseShuffle;
    const change = subtab === EHotSubTab.PopularWeekly && shuffleForPopularWeekly;
    return change;
  }
  const imgOf = (src) => jsx$1("img", { src, alt: "", className: "size-18px" });
  const HotSubTabConfig = {
    [EHotSubTab.PopularGeneral]: {
icon: imgOf("https://s1.hdslb.com/bfs/static/jinkela/popular/assets/icon_popular.png"),
      label: "综合热门",
      desc: "各个领域中新奇好玩的优质内容都在这里~",
      swr: true,
      anonymousUsage: true
    },
    [EHotSubTab.PopularWeekly]: {
icon: imgOf("https://s1.hdslb.com/bfs/static/jinkela/popular/assets/icon_weekly.png"),
      label: "每周必看",
      desc: "每周五晚 18:00 更新",
      anonymousUsage: true
    },
    [EHotSubTab.Rank]: {
icon: imgOf("https://s1.hdslb.com/bfs/static/jinkela/popular/assets/icon_rank.png"),
      label: "排行榜",
      desc: "排行榜根据稿件内容质量，近期的数据综合展示，动态更新",
      anonymousUsage: true,
      swr: true
    }
  };
  class HotRecService extends BaseTabService {
    subtab;
    service;
    constructor() {
      super(20);
      this.subtab = hotStore.subtab;
      this.service = subtabServiceCreators[hotStore.subtab]();
    }
    get usageInfo() {
      return jsx$1(HotUsageInfo, { children: this.service.usageInfo });
    }
    get hasMoreExceptQueue() {
      return this.service.hasMore;
    }
    fetchMore(abortSignal) {
      return this.service.loadMore(abortSignal);
    }
  }
  const hotStore = await( proxyWithGmStorage({
    subtab: EHotSubTab.PopularGeneral
  }, "hot-store"));
  if (!Object.values(EHotSubTab).includes(hotStore.subtab)) {
    hotStore.subtab = EHotSubTab.PopularGeneral;
  }
  function HotUsageInfo({
    children
  }) {
    const {
      subtab: activeSubtab
    } = useSnapshot(hotStore);
    const {
      icon,
      label
    } = HotSubTabConfig[activeSubtab];
    const onRefresh = useOnRefreshContext();
    const {
      ref,
      getPopupContainer
    } = usePopupContainer();
    const {
      __internalHotSubUseDropdown
    } = useSettingsSnapshot();
    const menus = H.useMemo(() => [EHotSubTab.PopularGeneral, EHotSubTab.PopularWeekly, EHotSubTab.Rank].map((subtab, index) => {
      const config = HotSubTabConfig[subtab];
      const active = subtab === activeSubtab;
      return [index > 0 && {
        type: "divider"
      }, {
        key: subtab,
        label: jsx$1("span", { className: clsx({
          "color-gate-primary": active
        }), children: config.label }),
        icon: config.icon,
        onClick() {
          if (subtab === hotStore.subtab) return;
          hotStore.subtab = subtab;
          onRefresh?.();
        }
      }].filter(Boolean);
    }).flat(), [activeSubtab]);
    const dropdownMenu = jsx$1(antd.Dropdown, { menu: {
      items: menus
    }, getPopupContainer, rootClassName: styled.createClass`
        .ant-dropdown-menu-item-divider {
          margin: 2px 0 !important;
        }
      `, children: jsxs(antd.Button, { ref, className: "w-114px flex items-center justify-start gap-0 pl-16px", children: [
      icon,
jsx$1("span", { className: "ml-8px", children: label })
    ] }) });
    const tab2 = H.useMemo(() => {
      return jsx$1(antd.Space.Compact, { children: [EHotSubTab.PopularGeneral, EHotSubTab.PopularWeekly, EHotSubTab.Rank].map((subtab, index) => {
        const {
          icon: icon2,
          label: label2,
          desc
        } = HotSubTabConfig[subtab];
        const active = subtab === activeSubtab;
        return jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
          label2,
          ": ",
          desc
        ] }), children: jsx$1(antd.Button, { className: "[&_.ant-btn-icon]:line-height-0", icon: icon2, variant: active ? "solid" : "outlined", color: active ? "primary" : "default", onClick: () => {
          if (subtab === hotStore.subtab) return;
          hotStore.subtab = subtab;
          onRefresh?.();
        }, children: label2 }) }, subtab);
      }) });
    }, [activeSubtab]);
    return jsxs(Fragment, { children: [
      __internalHotSubUseDropdown ? dropdownMenu : tab2,
      children
    ] });
  }
  const advancedSearchHelpInfo = jsxs(Fragment, { children: [
    "1. 可以使用多个搜索词, 用空格分隔, 逻辑关系为且 (AND) ",
jsx$1("br", {}),
    '2. 可以使用引号包裹搜索词, 如 "word or sentence" ',
jsx$1("br", {}),
    '3. 可以使用 -"word or sentence" 排除关键词; 必须使用引号(单引号 或 双引号) ',
jsx$1("br", {})
  ] });
  function parseSearchInput(input) {
    const includes = [];
    const excludes = [];
    if (!input.trim()) {
      return {
        includes,
        excludes
      };
    }
    let currentPos = 0;
    const inputLength = input.length;
    while (currentPos < inputLength) {
      while (currentPos < inputLength && input[currentPos] === " ") {
        currentPos++;
      }
      if (currentPos >= inputLength) break;
      let isExclude = false;
      let word = "";
      if (input[currentPos] === "-") {
        const nextChar = input[currentPos + 1];
        if (nextChar === '"' || nextChar === "'") {
          isExclude = true;
          currentPos++;
        }
      }
      if (input[currentPos] === '"' || input[currentPos] === "'") {
        const startQuoteChar = input[currentPos];
        currentPos++;
        let escaped = false;
        while (currentPos < inputLength) {
          const char2 = input[currentPos];
          if (escaped) {
            word += char2;
            escaped = false;
            currentPos++;
            continue;
          }
          if (char2 === "\\") {
            const nextChar = input[currentPos + 1];
            if (nextChar === '"' || nextChar === "'") {
              escaped = true;
              currentPos++;
              continue;
            }
            word += char2;
            currentPos++;
            continue;
          }
          if (char2 === startQuoteChar) {
            currentPos++;
            break;
          }
          word += char2;
          currentPos++;
        }
      } else {
        while (currentPos < inputLength && input[currentPos] !== " ") {
          if (input[currentPos] === "\\") {
            currentPos++;
            if (currentPos < inputLength) {
              word += input[currentPos];
              currentPos++;
            }
            continue;
          }
          word += input[currentPos];
          currentPos++;
        }
      }
      if (word) {
        if (isExclude) {
          excludes.push(word);
        } else {
          includes.push(word);
        }
      }
    }
    return {
      includes,
      excludes
    };
  }
  const TabConfig = {
    [ETab.AppRecommend]: {
      icon: jsx$1(IconForPhone, { className: "size-18px" }),
      label: "推荐",
      desc: "使用 Bilibili App 端推荐 API",
      anonymousUsage: true
    },
    [ETab.PcRecommend]: {
      icon: jsx$1(IconForPc, { className: "size-18px" }),
      label: "推荐",
      desc: "使用新版首页顶部推荐 API",
      anonymousUsage: true
    },
    [ETab.KeepFollowOnly]: {
      icon: jsx$1(IconForFollowedOnly, { className: "size-18px" }),
      label: "已关注",
      desc: "从PC端推荐中筛选出「已关注」,可能比较慢; 关注的UP更新在动态~"
    },
    [ETab.DynamicFeed]: {
      icon: jsx$1(IconForDynamicFeed, { className: "size-16px" }),
      label: "动态",
      desc: "视频投稿动态",
      swr: true
    },
    [ETab.Watchlater]: {
      icon: (

jsx$1(IconForWatchlater, { className: "size-17px [&_.circle]:stroke-current" })
      ),
      label: "稍后再看",
      desc: "你添加的稍后再看; 默认随机乱序, 可在设置中关闭乱序",
      swr: true
    },
    [ETab.Fav]: {
      icon: jsx$1(IconForFav, { className: "mt--1px size-16px" }),
      label: "收藏",
      desc: "你添加的收藏; 默认随机乱序, 可在设置中关闭乱序",
      get swr() {
        return !favStore.usingShuffle;
      }
    },
    [ETab.Hot]: {
      icon: jsx$1(IconForHot, { className: "size-16px" }),
      label: "热门",
      desc: "各个领域中新奇好玩的优质内容都在这里~",
      anonymousUsage: true,
      get swr() {
        return !isHotTabUsingShuffle();
      }
    },
    [ETab.Live]: {
      icon: jsx$1(IconForLive, { className: "size-16px" }),
      label: "直播",
      desc: "直播~",
      swr: true
    },
    [ETab.SpaceUpload]: {
      icon: jsx$1(IconForSpaceUpload, { className: "size-16px" }),
      label: "投稿",
      desc: "UP 视频投稿",
      anonymousUsage: true,
extraHelpInfo: jsxs("div", { className: "ml-20px", children: [
        "搜索词: 搜索相关作品 ",
jsx$1("br", {}),
        "本地过滤词: 本地过滤搜索结果; 本地过滤词支持高级规则:",
jsx$1("div", { className: "ml-20px", children: advancedSearchHelpInfo })
      ] })
    }
  };
  function TabIcon({
    tabKey,
    active,
    className
  }) {
    const {
      icon
    } = TabConfig[tabKey];
    const newClassName = n(icon.props.className, className);
    const cloned = H.cloneElement(icon, {
      css: icon.props.css,
      active: tabKey === ETab.Live ? active : void 0,
className: newClassName
    });
    return cloned;
  }
  const NEED_LOGIN_MESSAGE = "你需要登录B站后使用该功能! 如已完成登录, 请刷新网页重试~";
  function toastNeedLogin() {
    return toast(NEED_LOGIN_MESSAGE);
  }
  function useShortcut({
    enabled,
    refresh,
    minIndex = 0,
    maxIndex,
    containerRef,
    getScrollerRect,
    changeScrollY,
    videoCardEmitters,
    activeLargePreviewItemIndex
  }) {
    const [activeIndex, setActiveIndex] = H.useState(void 0);
    const isEnabled = useMemoizedFn(() => {
      if (!enabled) return false;
      if (shouldDisableShortcut()) return false;
      return true;
    });
    const activeIndexIsValid = useMemoizedFn(() => {
      if (typeof activeIndex !== "number") return false;
      if (!containerRef.current) return false;
      const scrollerRect = getScrollerRect();
      const rect = containerRef.current.querySelector(`.${APP_CLS_CARD}.${APP_CLS_CARD_ACTIVE}`)?.getBoundingClientRect();
      if (!scrollerRect || !rect) return false;
      if (rect.top - scrollerRect.top < -(scrollerRect.height + rect.height)) {
        return false;
      }
      if (rect.top - scrollerRect.top > scrollerRect.height * 2 + rect.height) {
        return false;
      }
      return true;
    });
    function getStep(direction) {
      const card = getCardAt(activeIndex);
      const activeLeft = card.getBoundingClientRect().left;
      const isLeftSame = (left) => Math.abs(activeLeft - left) < 1;
      {
        const col = getColumnCount(containerRef.current);
        const step2 = direction === "down" ? col : -col;
        const newCard = getCardAt(activeIndex + step2);
        if (newCard) {
          const left = newCard.getBoundingClientRect().left;
          if (isLeftSame(left)) {
            return step2;
          }
        }
      }
      let step = 0;
      let cur = card;
      const next2 = () => direction === "down" ? cur.nextElementSibling : cur.previousElementSibling;
      while (next2()) {
        cur = next2();
        if (!cur.classList.contains(APP_CLS_CARD)) continue;
        direction === "down" ? step++ : step--;
        const left = cur.getBoundingClientRect().left;
        if (isLeftSame(left)) {
          return step;
        }
      }
      return 0;
    }
    const addActiveIndex = (step) => (e2) => {
      if (!isEnabled()) return;
      e2?.preventDefault();
      let newActiveIndex;
      if (activeIndexIsValid()) {
        const _step = typeof step === "number" ? step : getStep(step);
        newActiveIndex = activeIndex + _step;
      } else {
        newActiveIndex = getInitialIndex();
      }
      if (newActiveIndex < minIndex) {
        makeVisible(minIndex);
        return;
      }
      if (newActiveIndex > maxIndex) {
        makeVisible(maxIndex);
        return;
      }
      setActiveIndex(newActiveIndex);
      makeVisible(newActiveIndex);
    };
    const useKey = (keyFilter, eventHandler) => {
      useKeyPress(keyFilter, (event, key) => {
        if (!isEnabled()) return;
        eventHandler(event, key);
      }, {
        exactMatch: true
      });
    };
    useKey("leftarrow", addActiveIndex(-1));
    useKey("rightarrow", addActiveIndex(1));
    useKey("tab", addActiveIndex(1));
    useKey("shift.tab", addActiveIndex(-1));
    useKey("uparrow", addActiveIndex("up"));
    useKey("downarrow", addActiveIndex("down"));
    const clearActiveIndex = () => {
      if (!isEnabled()) return;
      setActiveIndex(void 0);
    };
    const getActiveEmitter = () => {
      if (!isEnabled() || typeof activeIndex !== "number") return;
      return videoCardEmitters[activeIndex];
    };
    useKey("esc", clearActiveIndex);
    useKey("enter", (e2) => {
      if (!isEnabled()) return;
      if (typeof activeIndex === "number") {
        e2.preventDefault();
        return videoCardEmitters[activeIndex]?.emit("open");
      }
      if (typeof activeLargePreviewItemIndex === "number") {
        e2.preventDefault();
        return videoCardEmitters[activeLargePreviewItemIndex]?.emit("open-with-large-preview-visible");
      }
    });
    useKey("x", () => getActiveEmitter()?.emit("open-in-popup"));
    useKey("backspace", () => getActiveEmitter()?.emit("trigger-dislike"));
    useKey(["s", "w"], () => getActiveEmitter()?.emit("toggle-watch-later"));
    useKey(["period", "p"], () => getActiveEmitter()?.emit("hotkey-preview-animation"));
    function getInitialIndex() {
      const scrollerRect = getScrollerRect();
      if (!scrollerRect) return 0;
      const cards = getCards();
      for (const [i2, card] of cards.entries()) {
        const rect = card.getBoundingClientRect();
        if (rect.top >= scrollerRect.top) {
          return i2;
        }
      }
      return 0;
    }
    const CARDS_SELECTOR = `.${APP_CLS_CARD}`;
    function getCards() {
      return [...containerRef.current?.querySelectorAll(CARDS_SELECTOR) || []];
    }
    function getCardAt(index) {
      return getCards()[index];
    }
    function makeVisible(index) {
      const card = getCardAt(index);
      card?.scrollIntoViewIfNeeded?.(false);
      const scrollerRect = getScrollerRect();
      const rect = card.getBoundingClientRect();
      if (!scrollerRect || !rect) return;
      if (rect.top <= scrollerRect.top) {
        const offset = -(scrollerRect.top - rect.top + 10);
        changeScrollY?.({
          offset
        });
        return;
      }
      if (scrollerRect.bottom - rect.bottom < 20) {
        const offset = 20 - (scrollerRect.bottom - rect.bottom);
        changeScrollY?.({
          offset
        });
        return;
      }
    }
    return {
      activeIndex,
      clearActiveIndex
    };
  }
  const countCache1 = new Map();
  const countCache2 = new Map();
  function getColumnCount(container, mayHaveNarrowMode = true) {
    if (mayHaveNarrowMode && settings.useNarrowMode) return 2;
    const countCache = settings.style.pureRecommend.useCustomGrid ? countCache1 : countCache2;
    {
      const count2 = countCache.get(Math.trunc(window.innerWidth));
      if (count2) return count2;
    }
    container ||= document.querySelector(`.${videoGrid}`);
    if (!container) return 0;
    const style = window.getComputedStyle(container);
    if (style.display !== "grid") return 0;
    const count = style.gridTemplateColumns.split(" ").length;
    countCache.set(window.innerWidth, count);
    return count;
  }
  async function modifyRelations(upMid, act) {
    const uid = getUid();
    const csrf = getCsrfToken();
    const params = new URLSearchParams({
      fid: upMid,
      act: String(act),
      re_src: "11",
      gaia_source: "web_main",
      spmid: "333.999.0.0",
      extend_content: JSON.stringify({
        entity: "user",
        entity_id: uid,
        fp: d()
      }),
      csrf
    });
    const res = await request.post("/x/relation/modify", params);
    const json = res.data;
    const success = isWebApiSuccess(json);
    if (!success) {
      toast(json.message || "未知错误");
    }
    return success;
  }
  function d() {
    let t2;
    let e2;
    const i2 = (
(null === (t2 = window.reportObserver) || void 0 === t2 || null === (e2 = t2.cache) || void 0 === e2 ? void 0 : e2.fpriskMsg) || {}
    );
    let n2 = "empty";
    return i2 && (n2 = `${i2.webdriver}${i2.screenResolution}${i2.platform}${i2.hardwareConcurrency}${i2.deviceMemory}${i2.colorDepth}${i2.indexedDb}${i2.language}${i2.openDatabase}${i2.touchSupport}${i2.userAgent}`), decodeURIComponent(n2);
  }
  const debug$b = baseDebug.extend("service:user:relations:blacklist");
  const blacklistAdd = blacklistActionFactory("follow");
  const blacklistRemove = blacklistActionFactory("remove");
  const UserBlacklistService = {
    add: blacklistAdd,
    remove: blacklistRemove
  };
  const {
    set: blacklistMids,
    replaceAllWith: blacklistMidsReplaceAllWith
  } = await( proxySetWithGmStorage("blacklist-mids"));
  function useInBlacklist(upMid) {
    const set2 = useSnapshot(blacklistMids);
    return !!upMid && set2.has(upMid);
  }
  function blacklistActionFactory(action2) {
    const act = action2 === "follow" ? 5 : 6;
    return async function blacklistAction(upMid) {
      const success = await modifyRelations(upMid, act);
      if (success) {
        const set2 = blacklistMids;
        if (action2 === "follow") {
          set2.add(upMid);
        } else if (action2 === "remove") {
          set2.delete(upMid);
        }
      }
      return success;
    };
  }
  async function getUserBlacklist() {
    const ps = 20;
    const getPage = async (pn) => {
      const res = await request.get("/x/relation/blacks", {
        params: {
          re_version: 0,
          ps,
          pn
        }
      });
      const json = res.data;
      if (!isWebApiSuccess(json)) return;
      const total2 = json.data.total;
      const mids22 = json.data.list.map((x) => x.mid);
      return {
        total: total2,
        mids: mids22
      };
    };
    const ret = await getPage(1);
    if (!ret) return;
    const {
      total,
      mids: mids2 = []
    } = ret;
    let blackMids = mids2;
    if (total) {
      const maxPn = Math.ceil(total / ps);
      for (let pn = 2; pn <= maxPn; pn++) {
        const {
          mids: mids22 = []
        } = await getPage(pn) || {};
        blackMids = blackMids.concat(mids22);
      }
    }
    return blackMids;
  }
  (async () => {
    if (!IN_BILIBILI_HOMEPAGE) return;
    await whenIdle();
    const ids2 = await getUserBlacklist();
    debug$b("user blocklist fetched: %o", ids2);
    if (ids2) {
      blacklistMidsReplaceAllWith(ids2.map((x) => x.toString()));
    }
  })();
  var XOR_CODE = 23442827791579n;
  var MASK_CODE = 2251799813685247n;
  var MAX_AID = 1n << 51n;
  var BASE = 58n;
  var data = "FcwAPNKTMug3GV5Lj7EJnHpWsx4tb8haYeviqBz6rkCy12mUSDQX9RdoZf";
  function av2bv(aid) {
    const bytes = ["B", "V", "1", "0", "0", "0", "0", "0", "0", "0", "0", "0"];
    let bvIndex = bytes.length - 1;
    let tmp = (MAX_AID | BigInt(aid)) ^ XOR_CODE;
    while (tmp > 0) {
      bytes[bvIndex] = data[Number(tmp % BigInt(BASE))];
      tmp = tmp / BASE;
      bvIndex -= 1;
    }
    [bytes[3], bytes[9]] = [bytes[9], bytes[3]];
    [bytes[4], bytes[7]] = [bytes[7], bytes[4]];
    return bytes.join("");
  }
  function bv2av(bvid) {
    const bvidArr = Array.from(bvid);
    [bvidArr[3], bvidArr[9]] = [bvidArr[9], bvidArr[3]];
    [bvidArr[4], bvidArr[7]] = [bvidArr[7], bvidArr[4]];
    bvidArr.splice(0, 3);
    const tmp = bvidArr.reduce((pre, bvidChar) => pre * BASE + BigInt(data.indexOf(bvidChar)), 0n);
    return Number(tmp & MASK_CODE ^ XOR_CODE);
  }
  var BvCode = { av2bv, bv2av };
  const IconForStatPlay = defineSvgComponent((props) => {
    return jsxs("svg", { viewBox: "0 0 24 24", width: "24", height: "24", fill: "#fff", ...props, children: [
jsx$1("path", { d: "M12 4.99805C9.48178 4.99805 7.283 5.12616 5.73089 5.25202C4.65221 5.33949 3.81611 6.16352 3.72 7.23254C3.60607 8.4998 3.5 10.171 3.5 11.998C3.5 13.8251 3.60607 15.4963 3.72 16.76355C3.81611 17.83255 4.65221 18.6566 5.73089 18.7441C7.283 18.8699 9.48178 18.998 12 18.998C14.5185 18.998 16.7174 18.8699 18.2696 18.74405C19.3481 18.65655 20.184 17.8328 20.2801 16.76405C20.394 15.4973 20.5 13.82645 20.5 11.998C20.5 10.16965 20.394 8.49877 20.2801 7.23205C20.184 6.1633 19.3481 5.33952 18.2696 5.25205C16.7174 5.12618 14.5185 4.99805 12 4.99805zM5.60965 3.75693C7.19232 3.62859 9.43258 3.49805 12 3.49805C14.5677 3.49805 16.8081 3.62861 18.3908 3.75696C20.1881 3.90272 21.6118 5.29278 21.7741 7.09773C21.8909 8.3969 22 10.11405 22 11.998C22 13.88205 21.8909 15.5992 21.7741 16.8984C21.6118 18.7033 20.1881 20.09335 18.3908 20.23915C16.8081 20.3675 14.5677 20.498 12 20.498C9.43258 20.498 7.19232 20.3675 5.60965 20.2392C3.81206 20.0934 2.38831 18.70295 2.22603 16.8979C2.10918 15.5982 2 13.8808 2 11.998C2 10.1153 2.10918 8.39787 2.22603 7.09823C2.38831 5.29312 3.81206 3.90269 5.60965 3.75693z", fill: "currentColor" }),
jsx$1("path", { d: "M14.7138 10.96875C15.50765 11.4271 15.50765 12.573 14.71375 13.0313L11.5362 14.8659C10.74235 15.3242 9.75 14.7513 9.75001 13.8346L9.75001 10.1655C9.75001 9.24881 10.74235 8.67587 11.5362 9.13422L14.7138 10.96875z", fill: "currentColor" })
    ] });
  });
  const IconForStatDanmaku = defineSvgComponent((props) => {
    return jsxs("svg", { viewBox: "0 0 24 24", width: "24", height: "24", fill: "#ffffff", ...props, children: [
jsx$1("path", { d: "M12 4.99805C9.48178 4.99805 7.283 5.12616 5.73089 5.25202C4.65221 5.33949 3.81611 6.16352 3.72 7.23254C3.60607 8.4998 3.5 10.171 3.5 11.998C3.5 13.8251 3.60607 15.4963 3.72 16.76355C3.81611 17.83255 4.65221 18.6566 5.73089 18.7441C7.283 18.8699 9.48178 18.998 12 18.998C14.5185 18.998 16.7174 18.8699 18.2696 18.74405C19.3481 18.65655 20.184 17.8328 20.2801 16.76405C20.394 15.4973 20.5 13.82645 20.5 11.998C20.5 10.16965 20.394 8.49877 20.2801 7.23205C20.184 6.1633 19.3481 5.33952 18.2696 5.25205C16.7174 5.12618 14.5185 4.99805 12 4.99805zM5.60965 3.75693C7.19232 3.62859 9.43258 3.49805 12 3.49805C14.5677 3.49805 16.8081 3.62861 18.3908 3.75696C20.1881 3.90272 21.6118 5.29278 21.7741 7.09773C21.8909 8.3969 22 10.11405 22 11.998C22 13.88205 21.8909 15.5992 21.7741 16.8984C21.6118 18.7033 20.1881 20.09335 18.3908 20.23915C16.8081 20.3675 14.5677 20.498 12 20.498C9.43258 20.498 7.19232 20.3675 5.60965 20.2392C3.81206 20.0934 2.38831 18.70295 2.22603 16.8979C2.10918 15.5982 2 13.8808 2 11.998C2 10.1153 2.10918 8.39787 2.22603 7.09823C2.38831 5.29312 3.81206 3.90269 5.60965 3.75693z", fill: "currentColor" }),
jsx$1("path", { d: "M15.875 10.75L9.875 10.75C9.46079 10.75 9.125 10.4142 9.125 10C9.125 9.58579 9.46079 9.25 9.875 9.25L15.875 9.25C16.2892 9.25 16.625 9.58579 16.625 10C16.625 10.4142 16.2892 10.75 15.875 10.75z", fill: "currentColor" }),
jsx$1("path", { d: "M17.375 14.75L11.375 14.75C10.9608 14.75 10.625 14.4142 10.625 14C10.625 13.5858 10.9608 13.25 11.375 13.25L17.375 13.25C17.7892 13.25 18.125 13.5858 18.125 14C18.125 14.4142 17.7892 14.75 17.375 14.75z", fill: "currentColor" }),
jsx$1("path", { d: "M7.875 10C7.875 10.4142 7.53921 10.75 7.125 10.75L6.625 10.75C6.21079 10.75 5.875 10.4142 5.875 10C5.875 9.58579 6.21079 9.25 6.625 9.25L7.125 9.25C7.53921 9.25 7.875 9.58579 7.875 10z", fill: "currentColor" }),
jsx$1("path", { d: "M9.375 14C9.375 14.4142 9.03921 14.75 8.625 14.75L8.125 14.75C7.71079 14.75 7.375 14.4142 7.375 14C7.375 13.5858 7.71079 13.25 8.125 13.25L8.625 13.25C9.03921 13.25 9.375 13.5858 9.375 14z", fill: "currentColor" })
    ] });
  });
  const IconForRoll = defineSvgComponent(function(props) {
    return jsxs("svg", { viewBox: "0 0 16 16", width: "16", height: "16", fill: "currentColor", ...props, children: [
jsx$1("path", { d: "M8.624933333333333 13.666666666666666C8.624933333333333 14.011849999999999 8.345125 14.291666666666666 7.999933333333333 14.291666666666666C4.525166666666666 14.291666666666666 1.7082933333333332 11.474791666666665 1.7082933333333332 8C1.7082933333333332 6.013308333333333 2.629825 4.2414233333333335 4.066321666666667 3.089385C4.335603333333333 2.8734283333333335 4.728959999999999 2.9166533333333335 4.944915 3.1859349999999997C5.160871666666666 3.4552099999999997 5.1176466666666665 3.848573333333333 4.848366666666666 4.0645283333333335C3.694975 4.98953 2.9582933333333328 6.40852 2.9582933333333328 8C2.9582933333333328 10.784416666666667 5.215528333333333 13.041666666666666 7.999933333333333 13.041666666666666C8.345125 13.041666666666666 8.624933333333333 13.321483333333333 8.624933333333333 13.666666666666666zM11.060475 12.810558333333333C10.844225000000002 12.541558333333331 10.887033333333335 12.148125 11.156041666666667 11.931875C12.306858333333333 11.006775 13.041599999999999 9.589424999999999 13.041599999999999 8C13.041599999999999 5.215561666666666 10.784408333333332 2.958333333333333 7.999933333333333 2.958333333333333C7.6548083333333325 2.958333333333333 7.374933333333333 2.6785083333333333 7.374933333333333 2.333333333333333C7.374933333333333 1.9881533333333332 7.6548083333333325 1.7083333333333333 7.999933333333333 1.7083333333333333C11.474725000000001 1.7083333333333333 14.291599999999999 4.525206666666667 14.291599999999999 8C14.291599999999999 9.984108333333333 13.372483333333332 11.753958333333332 11.939225 12.906125C11.670166666666663 13.122375 11.276725 13.079625 11.060475 12.810558333333333z", fill: "currentColor" }),
jsx$1("path", { d: "M1.375 3.4130866666666666C1.375 3.0679066666666666 1.654825 2.7880866666666666 2 2.7880866666666666L4.333333333333333 2.7880866666666666C4.862608333333333 2.7880866666666666 5.291666666666666 3.2171449999999995 5.291666666666666 3.7464199999999996L5.291666666666666 6.079753333333334C5.291666666666666 6.424928333333334 5.011841666666666 6.704736666666666 4.666666666666666 6.704736666666666C4.321491666666667 6.704736666666666 4.041666666666666 6.424928333333334 4.041666666666666 6.079753333333334L4.041666666666666 4.038086666666667L2 4.038086666666667C1.654825 4.038086666666667 1.375 3.7582616666666664 1.375 3.4130866666666666z", fill: "currentColor" }),
jsx$1("path", { d: "M14.625 12.5864C14.625 12.931591666666666 14.345183333333333 13.2114 14 13.2114L11.666666666666666 13.2114C11.137408333333335 13.2114 10.708333333333332 12.782383333333332 10.708333333333332 12.253066666666665L10.708333333333332 9.919733333333333C10.708333333333332 9.574608333333334 10.98815 9.294733333333333 11.333333333333332 9.294733333333333C11.678516666666667 9.294733333333333 11.958333333333332 9.574608333333334 11.958333333333332 9.919733333333333L11.958333333333332 11.9614L14 11.9614C14.345183333333333 11.9614 14.625 12.241275000000002 14.625 12.5864z", fill: "currentColor" })
    ] });
  });
  function parseDuration(d2) {
    if (!d2) return 0;
    const units = [1, 60, 360];
    const splited = d2.split(":").map((s2) => Number(s2)).reverse();
    const total = splited.reduce((total2, cur, index) => {
      return total2 + cur * units[index];
    }, 0);
    return total;
  }
  function formatDuration(d2) {
    d2 ||= 0;
    return dayjs.duration(d2 || 0, "seconds").format(d2 >= 3600 ? "HH:mm:ss" : "mm:ss");
  }
  function formatCount(count) {
    if (!count) {
      if (typeof count === "number") return "0";
      else return count;
    }
    if (count <= 9999) {
      return count.toString();
    }
    const trimDotZero = (s2) => s2.replace(/\.0$/, "");
    count /= 1e4;
    if (count <= 9999) {
      const c2 = trimDotZero(count.toFixed(1));
      return `${c2}万`;
    }
    count /= 1e4;
    if (count <= 9999) {
      const c2 = trimDotZero(count.toFixed(1));
      return `${c2}亿`;
    }
    console.warn(`formatCount(count = ${count}); can not handle input`);
  }
  function parseCount(str) {
    if (!str) return void 0;
    if (str === "-") return 0;
    if (/^\d+$/.test(str)) return Number(str);
    if (/^\d+(?:\.\d+)?万$/.test(str)) return Number(str.slice(0, -1)) * 1e4;
    if (/^\d+(?:\.\d+)?亿$/.test(str)) return Number(str.slice(0, -1)) * 1e8;
  }
  const currentYear = dayjs().format("YYYY");
  function formatTimeStamp(unixTs, includeTime = false) {
    if (!unixTs) return "";
    const t2 = dayjs.unix(unixTs);
    const extraFormat = includeTime ? " HH:mm" : "";
    if (t2.format("YYYY") === currentYear) {
      return t2.format(`M-D${extraFormat}`);
    } else {
      return t2.format(`YY-M-D${extraFormat}`);
    }
  }
  function isRecentTimeStamp(ts) {
    const yesterdayStart = dayjs().subtract(1, "day").startOf("day").unix();
    return ts >= yesterdayStart;
  }
  function formatRecentTimeStamp(ts, zhDate) {
    if (!ts) return void 0;
    const t2 = dayjs.unix(ts);
    const isToday = t2.format(
      "YYYY-MM-DD"
) === dayjs().format(
      "YYYY-MM-DD"
);
    const isTodayRecent = isToday && Date.now() - ts * 1e3 <= ms("12h");
    const isYesterday = t2.format(
      "YYYY-MM-DD"
) === dayjs().subtract(1, "day").format(
      "YYYY-MM-DD"
);
    const isCurrentYear = t2.format(
      "YYYY"
) === dayjs().format(
      "YYYY"
);
    if (isTodayRecent) {
      const minutes = dayjs().diff(t2, "minutes");
      const hours = dayjs().diff(t2, "hours");
      if (minutes < 1) {
        return "刚刚";
      } else if (minutes < 60) {
        return `${minutes}分钟前`;
      } else {
        return `${hours}小时前`;
      }
    }
    if (isToday) return t2.format(
      "今天 HH:mm"
);
    if (isYesterday) return t2.format(
      "昨天 HH:mm"
);
    if (isCurrentYear) {
      return t2.format(
        "M月D日"

);
    } else {
      return t2.format(
        "YYYY年M月D日"

);
    }
  }
  const VideoStateMap = {
    "1": "橙色通过",
    "0": "开放浏览",
    "-1": "待审",
    "-2": "被打回",
    "-3": "网警锁定",
    "-4": "被锁定",
    "-5": "管理员锁定",
    "-6": "修复待审",
    "-7": "暂缓审核",
    "-8": "补档待审",
    "-9": "等待转码",
    "-10": "延迟审核",
    "-11": "视频源待修",
    "-12": "转储失败",
    "-13": "允许评论待审",
    "-14": "临时回收站",
    "-15": "分发中",
    "-16": "转码失败",
    "-20": "创建未提交",
    "-30": "创建已提交",
    "-40": "定时发布",
    "-100": "用户删除"
  };
  function getVideoInvalidReason(state2) {
    if (typeof state2 === "undefined") return;
    if (state2 >= 0) return;
    return VideoStateMap[state2];
  }
  const iconParkOutlineThumbsUp = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, d: "M27.6 18.6v-7.2A5.4 5.4 0 0 0 22.2 6L15 22.2V42h20.916a3.6 3.6 0 0 0 3.6-3.06L42 22.74a3.6 3.6 0 0 0-3.6-4.14zM15 22h-4.806C8.085 21.963 6.283 23.71 6 25.8v12.6a4.16 4.16 0 0 0 4.194 3.6H15z" })
  ] });
  const ForwardRef$C = H.forwardRef(iconParkOutlineThumbsUp);
  const tablerHeartFilled = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M6.979 3.074a6 6 0 0 1 4.988 1.425l.037.033l.034-.03a6 6 0 0 1 4.733-1.44l.246.036a6 6 0 0 1 3.364 10.008l-.18.185l-.048.041l-7.45 7.379a1 1 0 0 1-1.313.082l-.094-.082l-7.493-7.422A6 6 0 0 1 6.979 3.074" })
  ] });
  const ForwardRef$B = H.forwardRef(tablerHeartFilled);
  const tablerCoinYen = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsx$1("path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 1 0-18 0m6 0h6m-6 3h6M9 8l3 4.5" }),
jsx$1("path", { d: "m15 8l-3 4.5V17" })
    ] })
  ] });
  const ForwardRef$A = H.forwardRef(tablerCoinYen);
  const iconParkOutlinePreviewOpen = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M24 36c11.046 0 20-12 20-12s-8.954-12-20-12S4 24 4 24s8.954 12 20 12Z" }),
jsx$1("path", { d: "M24 29a5 5 0 1 0 0-10a5 5 0 0 0 0 10Z" })
    ] })
  ] });
  const ForwardRef$z = H.forwardRef(iconParkOutlinePreviewOpen);
  function defineStatItems(items) {
    return items;
  }
  const clsForBiliIcon = "size-18px";
  const clsForThirdPartyIcon = "size-16px";
  const StatFieldIconConfig = {
    "play": jsx$1(IconForStatPlay, { className: clsForBiliIcon }),
"danmaku": jsx$1(IconForStatDanmaku, { className: clsForBiliIcon }),
    "like": jsx$1(ForwardRef$C, { className: clsForThirdPartyIcon }),
    "bangumi:follow": jsx$1(ForwardRef$B, { className: clsForThirdPartyIcon }),
    "favorite": jsx$1(IconForFav, { className: clsForThirdPartyIcon }),
    "coin": jsx$1(ForwardRef$A, { className: clsForThirdPartyIcon }),
    "live:viewed-by": jsx$1(ForwardRef$z, { className: clsForThirdPartyIcon })
  };
  const StatItemDisplay = H.memo(function({
    field,
    value
  }) {
    const text = H.useMemo(() => {
      if (typeof value === "number" || value && /^\d+$/.test(value)) {
        return formatCount(Number(value)) ?? STAT_NUMBER_FALLBACK;
      } else {
        return value ?? STAT_NUMBER_FALLBACK;
      }
    }, [value]);
    const icon = StatFieldIconConfig[field];
    return jsxs("span", { "data-field": field, className: "bili-video-card__stats--item gap-x-2px mr-0!", children: [
      icon,
jsx$1("span", { className: clsx("bili-video-card__stats--text line-height-18px"), children: text })
    ] });
  });
  function isAppRecommend(item) {
    return item.api === EApiType.AppRecommend;
  }
  function isPcRecommend(item) {
    return item.api === EApiType.PcRecommend;
  }
  function isDynamicFeed(item) {
    return item.api === EApiType.DynamicFeed;
  }
  function isWatchlater(item) {
    return item.api === EApiType.Watchlater;
  }
  function isFav(item) {
    return item.api === EApiType.Fav;
  }
  function isPopularGeneral(item) {
    return item.api === EApiType.PopularGeneral;
  }
  function isPopularWeekly(item) {
    return item.api === EApiType.PopularWeekly;
  }
  function isRank(item) {
    return item.api === EApiType.Rank;
  }
  function isLive(item) {
    return item.api === EApiType.Live;
  }
  function isSpaceUpload(item) {
    return item.api === EApiType.SpaceUpload;
  }
  var PcRecGoto = ((PcRecGoto2) => {
    PcRecGoto2["AV"] = "av";
    PcRecGoto2["Ad"] = "ad";
    PcRecGoto2["Live"] = "live";
    return PcRecGoto2;
  })(PcRecGoto || {});
  const radixIconsPerson = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 15 15", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M7.5.875A3.626 3.626 0 0 1 11.127 4.5A3.624 3.624 0 0 1 8.5 7.983c1.197.145 2.224.568 2.997 1.33c.981.967 1.478 2.408 1.478 4.288a.475.475 0 0 1-.949 0c0-1.72-.453-2.88-1.196-3.613c-.745-.733-1.856-1.113-3.33-1.113c-1.472 0-2.584.38-3.328 1.113s-1.197 1.893-1.197 3.613a.475.475 0 0 1-.949 0c0-1.88.497-3.32 1.479-4.289c.772-.76 1.799-1.183 2.995-1.328a3.627 3.627 0 0 1 1-7.109m0 .95a2.676 2.676 0 1 0 0 5.35a2.676 2.676 0 0 0 0-5.35" })
  ] });
  const ForwardRef$y = H.forwardRef(radixIconsPerson);
  const mynauiUsersGroup = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.5, d: "M17 19.5c0-1.657-2.239-3-5-3s-5 1.343-5 3m14-3c0-1.23-1.234-2.287-3-2.75M3 16.5c0-1.23 1.234-2.287 3-2.75m12-4.014a3 3 0 1 0-4-4.472M6 9.736a3 3 0 0 1 4-4.472m2 8.236a3 3 0 1 1 0-6a3 3 0 0 1 0 6" })
  ] });
  const ForwardRef$x = H.forwardRef(mynauiUsersGroup);
  const tablerPlus = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 5v14m-7-7h14" })
  ] });
  const ForwardRef$w = H.forwardRef(tablerPlus);
  const IconForUp = ForwardRef$y;
  const IconForGroup = ForwardRef$x;
  const IconForPopoverTrigger = ForwardRef$w;
  function formatFollowGroupUrl(followGroupId) {
    return `https://space.bilibili.com/${getUid()}/fans/follow?tagid=${followGroupId}`;
  }
  function formatSpaceUrl(mid) {
    return `https://space.bilibili.com/${mid}`;
  }
  const cache$1 = dailyCache("w_webid");
  const get_w_webId = reusePendingPromise(async () => {
    const cached = await cache$1.get();
    if (cached) return cached;
    return fetch_w_webId();
  });
  async function fetch_w_webId() {
    const mid = getUid();
    if (!mid) return;
    const spacePageUrl = formatSpaceUrl(mid);
    const res = await request.get(spacePageUrl, {
      responseType: "text",
      withCredentials: true
    });
    const html = res.data;
    const parser = new DOMParser();
    const parsed2 = parser.parseFromString(html, "text/html");
    const jsonText = decodeURIComponent(parsed2.getElementById("__RENDER_DATA__")?.textContent?.trim() || "");
    if (!jsonText) return;
    const id = JSON.parse(jsonText)?.access_id;
    if (id) await cache$1.set(id);
    return id;
  }
  async function getAllFollowGroups({
    removeEmpty = true
  } = {}) {
    const params = await encWbi({
      web_location: "0.0",
      w_webid: await get_w_webId() || ""
    });
    const res = await request.get("/x/relation/tags", {
      params
    });
    const json = res.data;
    const groups = json.data || [];
    if (removeEmpty) {
      return groups.filter((x) => !!x.count);
    }
    return groups;
  }
  async function getFollowGroupContent(tagid) {
    const ps = 20;
    const singleRequest = async (page) => {
      const res = await request.get("/x/relation/tag", {
        params: {
          mid: getUid(),
          tagid,
          pn: page,
          ps
        }
      });
      const json = res.data;
      return json.data || [];
    };
    let pn = 1;
    let items = [];
    let currentPageItems = [];
    do {
      currentPageItems = await singleRequest(pn++);
      items = items.concat(currentPageItems);
    } while (currentPageItems.length > 0);
    const mids2 = uniq(items.map((x) => x.mid));
    return mids2;
  }
  async function getRecentUpdateUpList() {
    const res = await request.get("/x/polymer/web-dynamic/v1/portal");
    const json = res.data;
    const list2 = json?.data?.up_list || [];
    return list2;
  }
  var DynamicFeedQueryKey = ((DynamicFeedQueryKey2) => {
    DynamicFeedQueryKey2["Mid"] = "dyn-mid";
    DynamicFeedQueryKey2["SearchTextFull"] = "dyn-search-text";
    DynamicFeedQueryKey2["SearchTextShort"] = "dyn-search";
    DynamicFeedQueryKey2["Offset"] = "dyn-offset";
    DynamicFeedQueryKey2["MinId"] = "dyn-min-id";
    DynamicFeedQueryKey2["MinTs"] = "dyn-min-ts";
    return DynamicFeedQueryKey2;
  })(DynamicFeedQueryKey || {});
  const searchParams$2 = new URLSearchParams(location.search);
  const QUERY_DYNAMIC_UP_MID = searchParams$2.get(
    "dyn-mid"
)?.trim();
  const QUERY_DYNAMIC_OFFSET = searchParams$2.get(
    "dyn-offset"
) || void 0;
  const QUERY_DYNAMIC_SEARCH_TEXT = QUERY_DYNAMIC_UP_MID ? searchParams$2.get(
    "dyn-search-text"
) || searchParams$2.get(
    "dyn-search"
) || void 0 : void 0;
  const QUERY_DYNAMIC_MIN_ID = QUERY_DYNAMIC_UP_MID ? searchParams$2.get(
    "dyn-min-id"
) : void 0;
  const QUERY_DYNAMIC_MIN_TS = QUERY_DYNAMIC_MIN_ID ? searchParams$2.get(
    "dyn-min-ts"
) : void 0;
  const SHOW_DYNAMIC_FEED_ONLY = IN_BILIBILI_HOMEPAGE && !!QUERY_DYNAMIC_UP_MID;
  let upMidInitial = void 0;
  let upNameInitial = void 0;
  if (SHOW_DYNAMIC_FEED_ONLY) {
    upMidInitial = QUERY_DYNAMIC_UP_MID;
    upNameInitial = searchParams$2.get("dyn-name") ?? upMidInitial?.toString() ?? void 0;
  }
  var DynamicFeedVideoType = ((DynamicFeedVideoType2) => {
    DynamicFeedVideoType2["All"] = "all";
    DynamicFeedVideoType2["UploadOnly"] = "upload-only";
    DynamicFeedVideoType2["DynamicOnly"] = "dynamic-only";
    return DynamicFeedVideoType2;
  })(DynamicFeedVideoType || {});
  var DynamicFeedBadgeText = ((DynamicFeedBadgeText2) => {
    DynamicFeedBadgeText2["Upload"] = "投稿视频";
    DynamicFeedBadgeText2["Dynamic"] = "动态视频";
    DynamicFeedBadgeText2["ChargeOnly"] = "充电专属";
    return DynamicFeedBadgeText2;
  })(DynamicFeedBadgeText || {});
  const DynamicFeedVideoTypeLabel = {
    [
      "all"
]: "全部",
    [
      "upload-only"
]: "仅投稿视频",
    [
      "dynamic-only"
]: "仅动态视频"
  };
  var DynamicFeedVideoMinDuration = ((DynamicFeedVideoMinDuration2) => {
    DynamicFeedVideoMinDuration2["All"] = "all";
    DynamicFeedVideoMinDuration2["_5m"] = "5min";
    DynamicFeedVideoMinDuration2["_2m"] = "2min";
    DynamicFeedVideoMinDuration2["_1m"] = "1min";
    DynamicFeedVideoMinDuration2["_30s"] = "30s";
    DynamicFeedVideoMinDuration2["_10s"] = "10s";
    return DynamicFeedVideoMinDuration2;
  })(DynamicFeedVideoMinDuration || {});
  const DynamicFeedVideoMinDurationConfig = {
[
      "all"
]: {
      label: "全部时长",
      duration: 0
    },
    [
      "5min"
]: {
      label: "5分钟",
      duration: 5 * 60
    },
    [
      "2min"
]: {
      label: "2分钟",
      duration: 2 * 60
    },
    [
      "1min"
]: {
      label: "1分钟",
      duration: 60
    },
    [
      "30s"
]: {
      label: "30秒",
      duration: 30
    },
    [
      "10s"
]: {
      label: "10秒",
      duration: 10
    }
  };
  const DF_SELECTED_KEY_ALL = "all";
  const DF_SELECTED_KEY_PREFIX_UP = "up:";
  const DF_SELECTED_KEY_PREFIX_GROUP = "group:";
  const hideChargeOnlyVideosForKeysSet = (await( proxySetWithGmStorage("dynamic-feed:hide-charge-only-videos-for-keys"))).set;
  const addSeparatorsMap = (await( proxyMapWithGmStorage("dynamic-feed:add-separators"))).map;
  const dfStore = createDfStore();
  function createDfStore() {
    return proxy({
      upMid: upMidInitial,
      upName: upNameInitial,
      upFace: void 0,
      upList: [],
      upListUpdatedAt: 0,
      groups: [],
      groupsUpdatedAt: 0,
      selectedGroupId: void 0,
      get selectedGroup() {
        if (typeof this.selectedGroupId !== "number") return;
        return this.groups.find((x) => x.tagid === this.selectedGroupId);
      },
      dynamicFeedVideoType: "all",
      searchText: QUERY_DYNAMIC_SEARCH_TEXT ?? void 0,
get viewingAll() {
        return this.selectedKey === DF_SELECTED_KEY_ALL;
      },
      get viewingSomeUp() {
        return !!this.upMid;
      },
      get viewingSomeGroup() {
        return typeof this.selectedGroupId === "number";
      },
get selectedKey() {
        if (this.upMid) return `${DF_SELECTED_KEY_PREFIX_UP}${this.upMid}`;
        if (this.selectedGroup) return `${DF_SELECTED_KEY_PREFIX_GROUP}${this.selectedGroup.tagid}`;
        return DF_SELECTED_KEY_ALL;
      },
      hideChargeOnlyVideosForKeysSet,
      get hideChargeOnlyVideos() {
        return this.hideChargeOnlyVideosForKeysSet.has(this.selectedKey);
      },
      addSeparatorsMap,
      get addSeparators() {
        return this.addSeparatorsMap.get("global") ?? false;
      },
      filterMinDuration: "all",
      get filterMinDurationValue() {
        return DynamicFeedVideoMinDurationConfig[this.filterMinDuration].duration;
      },
updateUpList,
      updateGroups
    });
  }
  proxy({
    followGroupInfo: {}
  });
  async function updateUpList(force = false) {
    const cacheHit = !force && dfStore.upList.length && dfStore.upListUpdatedAt && dfStore.upListUpdatedAt - Date.now() < ms("5min");
    if (cacheHit) return;
    const list2 = await getRecentUpdateUpList();
    dfStore.upList = list2;
    dfStore.upListUpdatedAt = Date.now();
  }
  async function updateGroups(force = false) {
    {
      const {
        followGroup,
        whenViewAll
      } = settings.dynamicFeed;
      const enabled = followGroup.enabled || !!whenViewAll.hideIds.filter((x) => x.startsWith(DF_SELECTED_KEY_PREFIX_GROUP)).length;
      if (!enabled) return;
    }
    const cacheHit = !force && dfStore.groups.length && dfStore.groupsUpdatedAt && dfStore.groupsUpdatedAt - Date.now() < ms("1h");
    if (cacheHit) return;
    dfStore.groups = await getAllFollowGroups({
      removeEmpty: true
    });
    dfStore.groupsUpdatedAt = Date.now();
  }
  function updateFilterData() {
    if (!getUid()) return;
    return Promise.all([updateUpList(), updateGroups()]);
  }
  void (async () => {
    if (!IN_BILIBILI_HOMEPAGE) return;
    await delay(5e3);
    if (!dfStore.upList.length || !dfStore.groups.length) {
      await whenIdle();
      updateFilterData();
    }
  })();
  if (QUERY_DYNAMIC_UP_MID) {
    subscribeOnKeys(dfStore, ["upName", "searchText", "selectedGroup", "viewingSomeUp", "viewingAll"], ({
      upName,
      searchText,
      selectedGroup,
      viewingSomeUp,
      viewingAll
    }) => {
      let title = viewingAll ? "动态" : viewingSomeUp ? `「${upName}」的动态` : `「${selectedGroup?.name}」分组动态`;
      if (searchText) {
        title = `🔍【${searchText}】 - ${title}`;
      }
      setPageTitle(title);
    });
  }
  function isFavFolderDefault(attr) {
    return attr.toString(2).at(-2) === "0";
  }
  function isFavFolderPrivate(attr) {
    return attr.toString(2).at(-1) === "1";
  }
  var castComparer = function(comparer) {
    return function(a2, b, order) {
      return comparer(a2, b, order) * order;
    };
  };
  var throwInvalidConfigErrorIfTrue = function(condition, context) {
    if (condition)
      throw Error("Invalid sort config: " + context);
  };
  var unpackObjectSorter = function(sortByObj) {
    var _a = sortByObj || {}, asc = _a.asc, desc = _a.desc;
    var order = asc ? 1 : -1;
    var sortBy = asc || desc;
    throwInvalidConfigErrorIfTrue(!sortBy, "Expected `asc` or `desc` property");
    throwInvalidConfigErrorIfTrue(asc && desc, "Ambiguous object with `asc` and `desc` config properties");
    var comparer = sortByObj.comparer && castComparer(sortByObj.comparer);
    return { order, sortBy, comparer };
  };
  var multiPropertySorterProvider = function(defaultComparer2) {
    return function multiPropertySorter(sortBy, sortByArr, depth, order, comparer, a2, b) {
      var valA;
      var valB;
      if (typeof sortBy === "string") {
        valA = a2[sortBy];
        valB = b[sortBy];
      } else if (typeof sortBy === "function") {
        valA = sortBy(a2);
        valB = sortBy(b);
      } else {
        var objectSorterConfig = unpackObjectSorter(sortBy);
        return multiPropertySorter(objectSorterConfig.sortBy, sortByArr, depth, objectSorterConfig.order, objectSorterConfig.comparer || defaultComparer2, a2, b);
      }
      var equality = comparer(valA, valB, order);
      if ((equality === 0 || valA == null && valB == null) && sortByArr.length > depth) {
        return multiPropertySorter(sortByArr[depth], sortByArr, depth + 1, order, comparer, a2, b);
      }
      return equality;
    };
  };
  function getSortStrategy(sortBy, comparer, order) {
    if (sortBy === void 0 || sortBy === true) {
      return function(a2, b) {
        return comparer(a2, b, order);
      };
    }
    if (typeof sortBy === "string") {
      throwInvalidConfigErrorIfTrue(sortBy.includes("."), "String syntax not allowed for nested properties.");
      return function(a2, b) {
        return comparer(a2[sortBy], b[sortBy], order);
      };
    }
    if (typeof sortBy === "function") {
      return function(a2, b) {
        return comparer(sortBy(a2), sortBy(b), order);
      };
    }
    if (Array.isArray(sortBy)) {
      var multiPropSorter_1 = multiPropertySorterProvider(comparer);
      return function(a2, b) {
        return multiPropSorter_1(sortBy[0], sortBy, 1, order, comparer, a2, b);
      };
    }
    var objectSorterConfig = unpackObjectSorter(sortBy);
    return getSortStrategy(objectSorterConfig.sortBy, objectSorterConfig.comparer || comparer, objectSorterConfig.order);
  }
  var sortArray = function(order, ctx, sortBy, comparer) {
    var _a;
    if (!Array.isArray(ctx)) {
      return ctx;
    }
    if (Array.isArray(sortBy) && sortBy.length < 2) {
      _a = sortBy, sortBy = _a[0];
    }
    return ctx.sort(getSortStrategy(sortBy, comparer, order));
  };
  function createNewSortInstance(opts) {
    var comparer = castComparer(opts.comparer);
    return function(arrayToSort) {
      var ctx = Array.isArray(arrayToSort) && !opts.inPlaceSorting ? arrayToSort.slice() : arrayToSort;
      return {
        asc: function(sortBy) {
          return sortArray(1, ctx, sortBy, comparer);
        },
        desc: function(sortBy) {
          return sortArray(-1, ctx, sortBy, comparer);
        },
        by: function(sortBy) {
          return sortArray(1, ctx, sortBy, comparer);
        }
      };
    };
  }
  var defaultComparer = function(a2, b, order) {
    if (a2 == null)
      return order;
    if (b == null)
      return -order;
    if (typeof a2 !== typeof b) {
      return typeof a2 < typeof b ? -1 : 1;
    }
    if (a2 < b)
      return -1;
    if (a2 > b)
      return 1;
    return 0;
  };
  var sort = createNewSortInstance({
    comparer: defaultComparer
  });
  createNewSortInstance({
    comparer: defaultComparer,
    inPlaceSorting: true
  });
  function fastOrderBy(list2, props, orders) {
    if (props.length !== orders.length) throw new Error("props & orders length not match");
    const _by = props.map((prop, index) => {
      const order = orders[index];
      if (order === "asc") return { asc: prop };
      else if (order === "desc") return { desc: prop };
      return {
        asc: prop,
        comparer: order
      };
    });
    return sort(list2).by(_by);
  }
  function fastSortWithOrders(list2, orders) {
    const _by = orders.map(({ order, prop }) => {
      if (order === "asc") return { asc: prop };
      else if (order === "desc") return { desc: prop };
      return {
        asc: prop,
        comparer: order
      };
    });
    return sort(list2).by(_by);
  }
  const multiSelectStore = proxy({
    multiSelecting: false,
    selectedIdSet: proxySet(),
shiftMultiSelectAnchorUniqId: void 0
  });
  function useMultiSelecting() {
    const {
      multiSelecting
    } = useSnapshot(multiSelectStore);
    return multiSelecting;
  }
  function useMultiSelectState(uniqId) {
    const {
      multiSelecting,
      selectedIdSet
    } = useSnapshot(multiSelectStore);
    return multiSelecting && !!uniqId && selectedIdSet.has(uniqId);
  }
  let currentGridItems = [];
  let currentGridSharedEmitter = defaultSharedEmitter;
  function setCurrentGridItems(items) {
    currentGridItems = items;
  }
  function setCurrentGridSharedEmitter(sharedEmitter) {
    currentGridSharedEmitter = sharedEmitter;
  }
  function getMultiSelectedItems() {
    const {
      multiSelecting,
      selectedIdSet
    } = multiSelectStore;
    return multiSelecting ? currentGridItems.filter((item) => selectedIdSet.has(item.uniqId)) : [];
  }
  function getMultiSelectedCardDatas() {
    return getMultiSelectedItems().map(normalizeCardData);
  }
  function getGenericCardDatas() {
    const {
      multiSelecting
    } = multiSelectStore;
    const items = multiSelecting ? getMultiSelectedItems() : currentGridItems;
    const cardDatas = items.map(normalizeCardData);
    return cardDatas;
  }
  function copyBvidsSingleLine() {
    const bvids = getGenericCardDatas().map((cardData) => cardData.bvid);
    const content = bvids.join(" ");
    copyContent(content);
  }
  function getBvidInfo(cardData) {
    let {
      bvid,
      authorName,
      pubts,
      title
    } = cardData;
    const date = dayjs.unix(pubts ?? 0).format("YYYY-MM-DD");
    title = title.replaceAll(/\n+/g, " ");
    return `${bvid} ;; [${authorName}] ${date} ${title}`;
  }
  function copyBvidInfos() {
    const lines = getGenericCardDatas().map(getBvidInfo);
    const content = lines.join("\n");
    copyContent(content);
  }
  function copyVideoLinks() {
    const lines = getMultiSelectedCardDatas().map((cardData) => {
      let href = cardData.href;
      if (!href) return void 0;
      if (href.startsWith("/")) href = new URL(href, location.href).href;
      return href;
    }).filter(Boolean);
    const content = lines.join("\n");
    copyContent(content);
  }
  function handleMultiSelectWithShiftKey(anchorUniqId, toUniqId) {
    const {
      multiSelecting,
      selectedIdSet
    } = multiSelectStore;
    if (!multiSelecting) return;
    if (!anchorUniqId || !toUniqId || anchorUniqId === toUniqId) return;
    const list2 = currentGridItems;
    const anchorIndex = list2.findIndex((item) => item.uniqId === anchorUniqId);
    const toIndex = list2.findIndex((item) => item.uniqId === toUniqId);
    const isIndexValid = (index) => index >= 0 && index <= list2.length - 1;
    if (!isIndexValid(anchorIndex) || !isIndexValid(toIndex)) return;
    const range2 = [anchorIndex, toIndex];
    const [start, end] = fastOrderBy(range2, [(x) => x], ["asc"]);
    const selected = selectedIdSet.has(anchorUniqId);
    for (let i2 = start; i2 <= end; i2++) {
      selected ? selectedIdSet.add(currentGridItems[i2].uniqId) : selectedIdSet.delete(currentGridItems[i2].uniqId);
    }
  }
  const biUiChecksGrid = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M2 10h3a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1v-3a1 1 0 0 1 1-1m9-9h3a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1h-3a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1m0 9a1 1 0 0 0-1 1v3a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1v-3a1 1 0 0 0-1-1zm0-10a2 2 0 0 0-2 2v3a2 2 0 0 0 2 2h3a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zM2 9a2 2 0 0 0-2 2v3a2 2 0 0 0 2 2h3a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2zm7 2a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2h-3a2 2 0 0 1-2-2zM0 2a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2zm5.354.854a.5.5 0 1 0-.708-.708L3 3.793l-.646-.647a.5.5 0 1 0-.708.708l1 1a.5.5 0 0 0 .708 0z" })
  ] });
  const ForwardRef$v = H.forwardRef(biUiChecksGrid);
  const fluentSelectAllOn16Regular = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M9.854 5.854a.5.5 0 0 0-.708-.708L6.5 7.793L5.354 6.646a.5.5 0 1 0-.708.708l1.5 1.5a.5.5 0 0 0 .708 0zM2 4.5A2.5 2.5 0 0 1 4.5 2h5A2.5 2.5 0 0 1 12 4.5v5A2.5 2.5 0 0 1 9.5 12h-5A2.5 2.5 0 0 1 2 9.5zM4.5 3A1.5 1.5 0 0 0 3 4.5v5A1.5 1.5 0 0 0 4.5 11h5A1.5 1.5 0 0 0 11 9.5v-5A1.5 1.5 0 0 0 9.5 3zM7 14a2.5 2.5 0 0 1-2-1h4.5A3.5 3.5 0 0 0 13 9.5V4c.607.456 1 1.182 1 2v3.5A4.5 4.5 0 0 1 9.5 14z" })
  ] });
  const ForwardRef$u = H.forwardRef(fluentSelectAllOn16Regular);
  const icOutlineSwapHoriz = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M6.99 11L3 15l3.99 4v-3H14v-2H6.99zM21 9l-3.99-4v3H10v2h7.01v3z" })
  ] });
  const ForwardRef$t = H.forwardRef(icOutlineSwapHoriz);
  const ionExitOutline = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 512 512", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 32, d: "M320 176v-40a40 40 0 0 0-40-40H88a40 40 0 0 0-40 40v240a40 40 0 0 0 40 40h192a40 40 0 0 0 40-40v-40m64-160l80 80l-80 80m-193-80h273" })
  ] });
  const ForwardRef$s = H.forwardRef(ionExitOutline);
  function MultiSelectButton({
    iconOnly,
    addCopyActions = false
  }) {
    const {
      multiSelecting
    } = useSnapshot(multiSelectStore);
    const popoverBorderColor = usePopoverBorderColor();
    const exitCheck = useMemoizedFn(() => {
      const isExit = !multiSelectStore.multiSelecting;
      if (!isExit) return;
      multiSelectStore.shiftMultiSelectAnchorUniqId = void 0;
      if (settings.multiSelect.clearWhenExit) {
        multiSelectStore.selectedIdSet.clear();
      }
    });
    const btn = jsxs(antd.Button, { type: multiSelecting ? "primary" : "default", className: clsx(iconOnly ? "icon-only-round-button" : "inline-flex-center"), onClick: () => {
      multiSelectStore.multiSelecting = !multiSelectStore.multiSelecting;
      exitCheck();
    }, children: [
jsx$1(ForwardRef$v, { className: "size-12px" }),
      !iconOnly && jsxs(Fragment, { children: [
        "多选",
        multiSelectStore.multiSelecting ? "中" : ""
      ] })
    ] });
    const wrapPopoverActions = (btn2) => {
      return jsx$1(antd.Popover, { styles: {
        body: {
          border: `1px solid ${popoverBorderColor}`
        }
      }, content: jsxs("div", { className: "max-w-288px", children: [
jsxs("div", { className: "flex flex-wrap items-center gap-x-15px gap-y-2px", children: [
jsxs(antd.Button, { className: "inline-flex items-center", onClick: () => multiSelectStore.selectedIdSet.clear(), children: [
jsx$1(ForwardRef$10, { className: "size-18px" }),
            "清空"
          ] }),
jsxs(antd.Button, { className: "inline-flex items-center", onClick: () => {
            const newIdList = currentGridItems.map((x) => x.uniqId);
            multiSelectStore.selectedIdSet = proxySet(newIdList);
          }, children: [
jsx$1(ForwardRef$u, { className: "size-18px" }),
            "全选"
          ] }),
jsxs(antd.Button, { className: "inline-flex items-center", onClick: () => {
            const newIdList = currentGridItems.filter((x) => !multiSelectStore.selectedIdSet.has(x.uniqId)).map((x) => x.uniqId);
            multiSelectStore.selectedIdSet = proxySet(newIdList);
          }, children: [
jsx$1(ForwardRef$t, { className: "size-18px" }),
            "反选"
          ] }),
jsx$1("div", { className: "flex-basis-100%" }),
jsxs(antd.Button, { className: "inline-flex items-center", onClick: () => {
            multiSelectStore.multiSelecting = false;
            exitCheck();
          }, children: [
jsx$1(ForwardRef$s, { className: "size-18px" }),
            "退出"
          ] }),
jsx$1(CheckboxSettingItem, { configPath: "multiSelect.clearWhenExit", label: "退出时清空", tooltip: "退出多选时, 清空所有已选择项" })
        ] }),
        addCopyActions && jsxs(Fragment, { children: [
jsx$1(antd.Divider, { variant: "solid", className: "my-7px" }),
jsx$1("div", { className: "flex flex-wrap gap-x-10px gap-y-5px", children: jsx$1(CopyBvidButtons, {}) })
        ] })
      ] }), children: btn2 });
    };
    if (multiSelecting) {
      return wrapPopoverActions(btn);
    } else {
      return iconOnly ? jsx$1(AntdTooltip, { title: "多选", arrow: false, children: btn }) : btn;
    }
  }
  function CopyBvidButtons() {
    const {
      __internalEnableCopyBvidInfo: bvidInfo
    } = useSettingsSnapshot();
    return jsxs(Fragment, { children: [
jsxs(antd.Button, { onClick: copyBvidsSingleLine, className: "inline-flex-center", children: [
jsx$1(IconForCopy, {}),
        " 复制 BVID"
      ] }),
      bvidInfo && jsxs(antd.Button, { onClick: copyBvidInfos, className: "inline-flex-center", children: [
jsx$1(IconForCopy, {}),
        " 复制 BVID 信息"
      ] })
    ] });
  }
  function CopyBvidButtonsUsageInfo() {
    const {
      __internalAddCopyBvidButton: enabled
    } = useSettingsSnapshot();
    if (!enabled) return null;
    return jsxs(Fragment, { children: [
jsx$1(CopyBvidButtons, {}),
jsx$1(MultiSelectButton, { iconOnly: false })
    ] });
  }
  function mapNameForSort(name) {
    return name.replace(/([A-Z])/, "999999$1").replace(/([a-z])/, "999998$1");
  }
  function localeComparer(a2, b) {
    return a2.localeCompare(b, "zh-CN");
  }
  function sortListByName(entries, prop) {
    return fastSortWithOrders(entries, [{
      prop: (item) => {
        const val = typeof prop === "function" ? prop(item) : item[prop];
        return mapNameForSort(val);
      },
      order: localeComparer
    }]);
  }
  const dropdownMenuStyle = {
    overscrollBehavior: "contain",
    maxHeight: "60vh",
    overflowY: "scroll",
    scrollbarWidth: "thin",
    paddingRight: "12px"
  };
  const lucideList = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M3 5h.01M3 12h.01M3 19h.01M8 5h13M8 12h13M8 19h13" })
  ] });
  const ForwardRef$r = H.forwardRef(lucideList);
  const lucideFolderLock = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsx$1("rect", { width: 8, height: 5, x: 14, y: 17, rx: 1 }),
jsx$1("path", { d: "M10 20H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H20a2 2 0 0 1 2 2v2.5" }),
jsx$1("path", { d: "M20 17v-2a2 2 0 1 0-4 0v2" })
    ] })
  ] });
  const ForwardRef$q = H.forwardRef(lucideFolderLock);
  const lucideFolder = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z" })
  ] });
  const ForwardRef$p = H.forwardRef(lucideFolder);
  const ionLayersOutline = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 512 512", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 32, d: "m434.8 137.65l-149.36-68.1c-16.19-7.4-42.69-7.4-58.88 0L77.3 137.65c-17.6 8-17.6 21.09 0 29.09l148 67.5c16.89 7.7 44.69 7.7 61.58 0l148-67.5c17.52-8 17.52-21.1-.08-29.09M160 308.52l-82.7 37.11c-17.6 8-17.6 21.1 0 29.1l148 67.5c16.89 7.69 44.69 7.69 61.58 0l148-67.5c17.6-8 17.6-21.1 0-29.1l-79.94-38.47" }),
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 32, d: "m160 204.48l-82.8 37.16c-17.6 8-17.6 21.1 0 29.1l148 67.49c16.89 7.7 44.69 7.7 61.58 0l148-67.49c17.7-8 17.7-21.1.1-29.1L352 204.48" })
  ] });
  const ForwardRef$o = H.forwardRef(ionLayersOutline);
  const IconForAll = ForwardRef$r;
  const IconForPrivateFolder = ForwardRef$q;
  const IconForPublicFolder = ForwardRef$p;
  const IconForCollection = ForwardRef$o;
  function FavUsageInfo({
    extraContent
  }) {
    const {
      fav
    } = useSettingsSnapshot();
    const {
      folders,
      selectedFavFolder,
      collections,
      selectedFavCollection,
      selectedLabel,
      selectedKey
    } = useSnapshot(favStore);
    const onRefresh = useOnRefreshContext();
    const {
      ref,
      getPopupContainer
    } = usePopupContainer();
    useMount(() => {
      updateFavList();
    });
    useUpdateEffect(() => {
      void (async () => {
        await delay(100);
        onRefresh?.();
      })();
    }, [fav.addSeparator]);
    const scopeSelectionDropdownMenus = H.useMemo(() => {
      const collectionSubMenus = [];
      const collectionGrouped = groupBy(collections, (x) => x.upper.name);
      let entries = Object.entries(collectionGrouped).map(([upName, collections2]) => ({
        upName,
        collections: sortListByName(collections2, "title")
      }));
      entries = sortListByName(entries, "upName");
      for (const {
        upName,
        collections: collections2
      } of entries) {
        const upMid = collections2[0]?.upper.mid;
        const upSpaceUrl = upMid ? formatSpaceUrl(upMid) : "#";
        collectionSubMenus.push(...defineAntMenus([{
          type: "group",
          label: jsxs("span", { className: "flex items-center gap-x-2px", children: [
jsx$1(IconForOpenExternalLink, { className: "mt-2px size-15px" }),
jsxs("a", { target: "_blank", href: upSpaceUrl, children: [
              "@",
              upName
            ] })
          ] }),
          children: collections2.map((f2) => {
            const key = `fav-collection:${f2.id}`;
            const label = jsxs("span", { className: "ml-8px flex items-center gap-x-2px", children: [
jsx$1(IconForCollection, { className: "size-15px" }),
              f2.title,
              " (",
              f2.media_count,
              ")"
            ] });
            return {
              key,
              label,
              async onClick() {
                favStore.selectedFavFolderId = void 0;
                favStore.selectedFavCollectionId = f2.id;
                setScopeDropdownOpen(false);
                await delay(100);
                onRefresh?.();
              }
            };
          })
        }]));
      }
      return defineAntMenus([{
        key: "all",
        icon: jsx$1(IconForAll, {}),
        label: "全部",
        async onClick() {
          favStore.selectedFavFolderId = void 0;
          favStore.selectedFavCollectionId = void 0;
          setScopeDropdownOpen(false);
          await delay(100);
          onRefresh?.();
        }
      }, !!folders.length && {
        type: "group",
        label: "收藏夹",
        children: folders.map((f2) => {
          isFavFolderDefault(f2.attr);
          const isPrivate = isFavFolderPrivate(f2.attr);
          const key = `fav-folder:${f2.id}`;
          const icon = isPrivate ? jsx$1(IconForPrivateFolder, {}) : jsx$1(IconForPublicFolder, {});
          const label = `${f2.title} (${f2.media_count})`;
          return {
            key,
            icon,
            label,
            async onClick() {
              favStore.selectedFavFolderId = f2.id;
              favStore.selectedFavCollectionId = void 0;
              setScopeDropdownOpen(false);
              await delay(100);
              onRefresh?.();
            }
          };
        })
      }, !!collections.length && {
        type: "group",
        label: "合集",
        children: collectionSubMenus
      }]);
    }, [folders, collections]);
    const [scopeDropdownOpen, setScopeDropdownOpen] = H.useState(false);
    const dropdownButtonClassName = "relative top-[-0.5px] size-15px";
    const dropdownButtonIcon = selectedFavFolder ? isFavFolderPrivate(selectedFavFolder.attr) ? jsx$1(IconForPrivateFolder, { className: dropdownButtonClassName }) : jsx$1(IconForPublicFolder, { className: dropdownButtonClassName }) : selectedFavCollection ? jsx$1(IconForCollection, { className: dropdownButtonClassName }) : jsx$1(IconForAll, { className: dropdownButtonClassName });
    const dropdownButtonLabel = selectedLabel;
    const scopeSelectionDropdown = jsx$1(antd.Dropdown, { open: scopeDropdownOpen, onOpenChange: setScopeDropdownOpen, placement: "bottomLeft", getPopupContainer, menu: {
      items: scopeSelectionDropdownMenus,
      style: {
        ...dropdownMenuStyle,
        border: `1px solid ${usePopoverBorderColor()}`
      },
      selectedKeys: [selectedKey]
    }, children: jsx$1(antd.Button, { css: [scopeDropdownOpen && buttonOpenCss, "", ""], children: jsxs("span", { className: "h-full flex items-center gap-x-4px", children: [
      dropdownButtonIcon,
      dropdownButtonLabel
    ] }) }) });
    return jsxs("div", { ref, className: "flex items-center gap-x-10px", children: [
      scopeSelectionDropdown,
      extraContent,
jsx$1(CopyBvidButtonsUsageInfo, {})
    ] });
  }
  function ViewingAllExcludeFolderConfig({
    allFavFolderServices,
    state: state2
  }) {
    const {
      fav
    } = useSettingsSnapshot();
    const onRefresh = useOnRefreshContext();
    const {
      ref,
      getPopupContainer
    } = usePopupContainer();
    const {
      totalCountInFavFolders
    } = useSnapshot(state2);
    const [excludeFavFolderIdsChanged, setExcludeFavFolderIdsChanged] = H.useState(false);
    const handleChange = useMemoizedFn((newTargetKeys, direction, moveKeys) => {
      setExcludeFavFolderIdsChanged(true);
      settings.fav.excludedFolderIds = newTargetKeys.map((k) => k.toString());
    });
    const foldersCount = H.useMemo(() => allFavFolderServices.filter((x) => !fav.excludedFolderIds.includes(x.entry.id.toString())).length, [allFavFolderServices, fav.excludedFolderIds]);
    const onPopupOpenChange = useMemoizedFn((open) => {
      if (open) {
        setExcludeFavFolderIdsChanged(false);
      } else if (excludeFavFolderIdsChanged) {
        onRefresh?.();
      }
    });
    return jsx$1(antd.Popover, { getTooltipContainer: getPopupContainer, trigger: "click", placement: "bottom", onOpenChange: onPopupOpenChange, getPopupContainer: (el) => el.parentElement || document.body, content: jsx$1(Fragment, { children: jsx$1(antd.Transfer, { dataSource: allFavFolderServices, rowKey: (row) => row.entry.id.toString(), titles: ["收藏夹", "忽略"], targetKeys: fav.excludedFolderIds, onChange: handleChange, render: (item) => item.entry.title, oneWay: true, style: {
      marginBottom: 10
    } }) }), children: jsxs(antd.Tag, { ref, color: "success", className: "mx-0 cursor-pointer text-size-12px", children: [
      "收藏夹(",
      foldersCount,
      ") 收藏(",
      totalCountInFavFolders,
      ")"
    ] }) });
  }
  var ELiveStatus = ((ELiveStatus2) => {
    ELiveStatus2[ELiveStatus2["Offline"] = 0] = "Offline";
    ELiveStatus2[ELiveStatus2["Streaming"] = 1] = "Streaming";
    ELiveStatus2[ELiveStatus2["Rolling"] = 2] = "Rolling";
    return ELiveStatus2;
  })(ELiveStatus || {});
  class QuickLRU extends Map {
    #size = 0;
    #cache = new Map();
    #oldCache = new Map();
    #maxSize;
    #maxAge;
    #onEviction;
    constructor(options = {}) {
      super();
      if (!(options.maxSize && options.maxSize > 0)) {
        throw new TypeError("`maxSize` must be a number greater than 0");
      }
      if (typeof options.maxAge === "number" && options.maxAge === 0) {
        throw new TypeError("`maxAge` must be a number greater than 0");
      }
      this.#maxSize = options.maxSize;
      this.#maxAge = options.maxAge || Number.POSITIVE_INFINITY;
      this.#onEviction = options.onEviction;
    }
get __oldCache() {
      return this.#oldCache;
    }
    #emitEvictions(cache2) {
      if (typeof this.#onEviction !== "function") {
        return;
      }
      for (const [key, item] of cache2) {
        this.#onEviction(key, item.value);
      }
    }
    #deleteIfExpired(key, item) {
      if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
        if (typeof this.#onEviction === "function") {
          this.#onEviction(key, item.value);
        }
        return this.delete(key);
      }
      return false;
    }
    #getOrDeleteIfExpired(key, item) {
      const deleted = this.#deleteIfExpired(key, item);
      if (deleted === false) {
        return item.value;
      }
    }
    #getItemValue(key, item) {
      return item.expiry ? this.#getOrDeleteIfExpired(key, item) : item.value;
    }
    #peek(key, cache2) {
      const item = cache2.get(key);
      return this.#getItemValue(key, item);
    }
    #set(key, value) {
      this.#cache.set(key, value);
      this.#size++;
      if (this.#size >= this.#maxSize) {
        this.#size = 0;
        this.#emitEvictions(this.#oldCache);
        this.#oldCache = this.#cache;
        this.#cache = new Map();
      }
    }
    #moveToRecent(key, item) {
      this.#oldCache.delete(key);
      this.#set(key, item);
    }
    *#entriesAscending() {
      for (const item of this.#oldCache) {
        const [key, value] = item;
        if (!this.#cache.has(key)) {
          const deleted = this.#deleteIfExpired(key, value);
          if (deleted === false) {
            yield item;
          }
        }
      }
      for (const item of this.#cache) {
        const [key, value] = item;
        const deleted = this.#deleteIfExpired(key, value);
        if (deleted === false) {
          yield item;
        }
      }
    }
    get(key) {
      if (this.#cache.has(key)) {
        const item = this.#cache.get(key);
        return this.#getItemValue(key, item);
      }
      if (this.#oldCache.has(key)) {
        const item = this.#oldCache.get(key);
        if (this.#deleteIfExpired(key, item) === false) {
          this.#moveToRecent(key, item);
          return item.value;
        }
      }
    }
    set(key, value, { maxAge = this.#maxAge } = {}) {
      const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
      if (this.#cache.has(key)) {
        this.#cache.set(key, {
          value,
          expiry
        });
      } else {
        this.#set(key, { value, expiry });
      }
      return this;
    }
    has(key) {
      if (this.#cache.has(key)) {
        return !this.#deleteIfExpired(key, this.#cache.get(key));
      }
      if (this.#oldCache.has(key)) {
        return !this.#deleteIfExpired(key, this.#oldCache.get(key));
      }
      return false;
    }
    peek(key) {
      if (this.#cache.has(key)) {
        return this.#peek(key, this.#cache);
      }
      if (this.#oldCache.has(key)) {
        return this.#peek(key, this.#oldCache);
      }
    }
    expiresIn(key) {
      const item = this.#cache.get(key) ?? this.#oldCache.get(key);
      if (item) {
        return item.expiry ? item.expiry - Date.now() : Number.POSITIVE_INFINITY;
      }
    }
    delete(key) {
      const deleted = this.#cache.delete(key);
      if (deleted) {
        this.#size--;
      }
      return this.#oldCache.delete(key) || deleted;
    }
    clear() {
      this.#cache.clear();
      this.#oldCache.clear();
      this.#size = 0;
    }
    resize(newSize) {
      if (!(newSize && newSize > 0)) {
        throw new TypeError("`maxSize` must be a number greater than 0");
      }
      const items = [...this.#entriesAscending()];
      const removeCount = items.length - newSize;
      if (removeCount < 0) {
        this.#cache = new Map(items);
        this.#oldCache = new Map();
        this.#size = items.length;
      } else {
        if (removeCount > 0) {
          this.#emitEvictions(items.slice(0, removeCount));
        }
        this.#oldCache = new Map(items.slice(removeCount));
        this.#cache = new Map();
        this.#size = 0;
      }
      this.#maxSize = newSize;
    }
    evict(count = 1) {
      const requested = Number(count);
      if (!requested || requested <= 0) {
        return;
      }
      const items = [...this.#entriesAscending()];
      const evictCount = Math.trunc(Math.min(requested, Math.max(items.length - 1, 0)));
      if (evictCount <= 0) {
        return;
      }
      this.#emitEvictions(items.slice(0, evictCount));
      this.#oldCache = new Map(items.slice(evictCount));
      this.#cache = new Map();
      this.#size = 0;
    }
    *keys() {
      for (const [key] of this) {
        yield key;
      }
    }
    *values() {
      for (const [, value] of this) {
        yield value;
      }
    }
    *[Symbol.iterator]() {
      for (const item of this.#cache) {
        const [key, value] = item;
        const deleted = this.#deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
      for (const item of this.#oldCache) {
        const [key, value] = item;
        if (!this.#cache.has(key)) {
          const deleted = this.#deleteIfExpired(key, value);
          if (deleted === false) {
            yield [key, value.value];
          }
        }
      }
    }
    *entriesDescending() {
      let items = [...this.#cache];
      for (let i2 = items.length - 1; i2 >= 0; --i2) {
        const item = items[i2];
        const [key, value] = item;
        const deleted = this.#deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
      items = [...this.#oldCache];
      for (let i2 = items.length - 1; i2 >= 0; --i2) {
        const item = items[i2];
        const [key, value] = item;
        if (!this.#cache.has(key)) {
          const deleted = this.#deleteIfExpired(key, value);
          if (deleted === false) {
            yield [key, value.value];
          }
        }
      }
    }
    *entriesAscending() {
      for (const [key, value] of this.#entriesAscending()) {
        yield [key, value.value];
      }
    }
    get size() {
      if (!this.#size) {
        return this.#oldCache.size;
      }
      let oldCacheSize = 0;
      for (const key of this.#oldCache.keys()) {
        if (!this.#cache.has(key)) {
          oldCacheSize++;
        }
      }
      return Math.min(this.#size + oldCacheSize, this.#maxSize);
    }
    get maxSize() {
      return this.#maxSize;
    }
    get maxAge() {
      return this.#maxAge;
    }
    entries() {
      return this.entriesAscending();
    }
    forEach(callbackFunction, thisArgument = this) {
      for (const [key, value] of this.entriesAscending()) {
        callbackFunction.call(thisArgument, value, key, this);
      }
    }
    get [Symbol.toStringTag]() {
      return "QuickLRU";
    }
    toString() {
      return `QuickLRU(${this.size}/${this.maxSize})`;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.toString();
    }
  }
  const tablerFaceIdError = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 8V6a2 2 0 0 1 2-2h2M4 16v2a2 2 0 0 0 2 2h2m8-16h2a2 2 0 0 1 2 2v2m-4 12h2a2 2 0 0 0 2-2v-2M9 10h.01M15 10h.01M9.5 15.05a3.5 3.5 0 0 1 5 0" })
  ] });
  const ForwardRef$n = H.forwardRef(tablerFaceIdError);
  function isAxiosError(err) {
    return err instanceof Error && err.name === "AxiosError";
  }
  function wrapWithParagraph(node2) {
    if (!node2) return node2;
    return jsx$1("p", { className: "mt-10px", children: node2 });
  }
  function inspectErrDetail(err) {
    if (!(err instanceof Error)) {
      return wrapWithParagraph(JSON.stringify(err));
    }
    let errSelf;
    let errCause;
    let errAxiosErrorDetail;
    if (err.stack) {
      errSelf = jsxs(Fragment, { children: [
        "Error Stack: ",
jsx$1("br", {}),
        err.stack
      ] });
    } else {
      errSelf = jsxs(Fragment, { children: [
        "Error Message: ",
        err.message
      ] });
    }
    if (err.cause) {
      errCause = jsxs(Fragment, { children: [
        "Error Cause: ",
        inspectErrDetail(err.cause)
      ] });
    }
    if (isAxiosError(err)) {
      const _err = cloneDeep(err);
      if (_err.config?.params?.access_key) {
        _err.config.params.access_key = "*".repeat(_err.config.params.access_key.length);
      }
      errAxiosErrorDetail = jsxs(Fragment, { children: [
        "axios config: ",
        JSON.stringify(_err.config, null, 2)
      ] });
    }
    return jsxs(Fragment, { children: [
      wrapWithParagraph(errSelf),
      wrapWithParagraph(errCause),
      wrapWithParagraph(errAxiosErrorDetail)
    ] });
  }
  function getErrLabel(err) {
    if (err && err instanceof ShowMessageError && err.message) return err.message;
    return "出错了, 请刷新重试!";
  }
  class ShowMessageError extends Error {
    constructor(message2) {
      super(message2);
      this.name = "ShowMessageError";
    }
  }
  function ErrorDetail({
    err,
    tab: tab2
  }) {
    const target = useLinkTarget();
    const errLabel = H.useMemo(() => getErrLabel(err), [err]);
    const errDetail = H.useMemo(() => inspectErrDetail(err), [err]);
    return jsxs("div", { className: "p-20px text-center text-size-20px", children: [
jsx$1(AntdTooltip, { title: jsxs("div", { className: "py-10px", children: [
jsx$1("h3", { children: "错误详情" }),
jsx$1("div", { className: "max-h-50vh overflow-hidden overflow-y-auto whitespace-pre-wrap break-normal", children: errDetail })
      ] }), children: jsxs("p", { className: "flex cursor-pointer items-center justify-center", children: [
jsx$1(ForwardRef$n, { className: "mr-4px" }),
        errLabel
      ] }) }),
      tab2 === ETab.Hot && hotStore.subtab === EHotSubTab.PopularWeekly && jsxs("p", { className: "mt-8px flex items-center justify-center", children: [
        "可能需手动输入验证码",
jsx$1(IconForOpenExternalLink, { className: "ml-12px" }),
jsx$1("a", { href: "https://www.bilibili.com/v/popular/weekly", target, className: "ml-2px", children: "每周必看" })
      ] })
    ] });
  }
  async function __fetchSpaceAccInfo(mid) {
    const res = await request.get("/x/space/wbi/acc/info", {
      params: {
        mid,
        w_webid: await get_w_webId() || ""
      }
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      appWarn("space acc info error for %s: %o", mid, json);
      return;
    }
    const info = json.data;
    return info;
  }
  const getSpaceAccInfo = wrapWithIdbCache({
    fn: __fetchSpaceAccInfo,
    generateKey: (mid) => mid.toString(),
    tableName: "space-acc-info",
    ttl: ms("10d"),
    concurrency: 2
});
  async function __fetchUserNickname(mid) {
    const info = await getSpaceAccInfo(mid);
    const nickname = info?.name;
    return nickname;
  }
  const getUserNickname = wrapWithIdbCache({
    fn: __fetchUserNickname,
    generateKey: (mid) => mid.toString(),
    tableName: "user-nickname",
    ttl: ms("10d")
  });
  async function setNicknameCache(mid, nickname) {
    await getUserNickname.cache.set(mid.toString(), {
      val: nickname,
      ts: Date.now()
    });
  }
  const objectToString = Object.prototype.toString;
  const isError = (value) => objectToString.call(value) === "[object Error]";
  const errorMessages = new Set([
    "network error",
"Failed to fetch",
"NetworkError when attempting to fetch resource.",
"The Internet connection appears to be offline.",
"Load failed",
"Network request failed",
"fetch failed",
"terminated"
]);
  function isNetworkError(error) {
    const isValid = error && isError(error) && error.name === "TypeError" && typeof error.message === "string";
    if (!isValid) {
      return false;
    }
    if (error.message === "Load failed") {
      return error.stack === void 0;
    }
    return errorMessages.has(error.message);
  }
  function validateRetries(retries) {
    if (typeof retries === "number") {
      if (retries < 0) {
        throw new TypeError("Expected `retries` to be a non-negative number.");
      }
      if (Number.isNaN(retries)) {
        throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
      }
    } else if (retries !== void 0) {
      throw new TypeError("Expected `retries` to be a number or Infinity.");
    }
  }
  function validateNumberOption(name, value, { min = 0, allowInfinity = false } = {}) {
    if (value === void 0) {
      return;
    }
    if (typeof value !== "number" || Number.isNaN(value)) {
      throw new TypeError(`Expected \`${name}\` to be a number${allowInfinity ? " or Infinity" : ""}.`);
    }
    if (!allowInfinity && !Number.isFinite(value)) {
      throw new TypeError(`Expected \`${name}\` to be a finite number.`);
    }
    if (value < min) {
      throw new TypeError(`Expected \`${name}\` to be ≥ ${min}.`);
    }
  }
  class AbortError2 extends Error {
    constructor(message2) {
      super();
      if (message2 instanceof Error) {
        this.originalError = message2;
        ({ message: message2 } = message2);
      } else {
        this.originalError = new Error(message2);
        this.originalError.stack = this.stack;
      }
      this.name = "AbortError";
      this.message = message2;
    }
  }
  function calculateDelay(retriesConsumed, options) {
    const attempt2 = Math.max(1, retriesConsumed + 1);
    const random2 = options.randomize ? Math.random() + 1 : 1;
    let timeout = Math.round(random2 * options.minTimeout * options.factor ** (attempt2 - 1));
    timeout = Math.min(timeout, options.maxTimeout);
    return timeout;
  }
  function calculateRemainingTime(start, max) {
    if (!Number.isFinite(max)) {
      return max;
    }
    return max - (performance.now() - start);
  }
  async function onAttemptFailure({ error, attemptNumber, retriesConsumed, startTime, options }) {
    const normalizedError = error instanceof Error ? error : new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
    if (normalizedError instanceof AbortError2) {
      throw normalizedError.originalError;
    }
    const retriesLeft = Number.isFinite(options.retries) ? Math.max(0, options.retries - retriesConsumed) : options.retries;
    const maxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;
    const context = Object.freeze({
      error: normalizedError,
      attemptNumber,
      retriesLeft,
      retriesConsumed
    });
    await options.onFailedAttempt(context);
    if (calculateRemainingTime(startTime, maxRetryTime) <= 0) {
      throw normalizedError;
    }
    const consumeRetry = await options.shouldConsumeRetry(context);
    const remainingTime = calculateRemainingTime(startTime, maxRetryTime);
    if (remainingTime <= 0 || retriesLeft <= 0) {
      throw normalizedError;
    }
    if (normalizedError instanceof TypeError && !isNetworkError(normalizedError)) {
      if (consumeRetry) {
        throw normalizedError;
      }
      options.signal?.throwIfAborted();
      return false;
    }
    if (!await options.shouldRetry(context)) {
      throw normalizedError;
    }
    if (!consumeRetry) {
      options.signal?.throwIfAborted();
      return false;
    }
    const delayTime = calculateDelay(retriesConsumed, options);
    const finalDelay = Math.min(delayTime, remainingTime);
    if (finalDelay > 0) {
      await new Promise((resolve, reject) => {
        const onAbort = () => {
          clearTimeout(timeoutToken);
          options.signal?.removeEventListener("abort", onAbort);
          reject(options.signal.reason);
        };
        const timeoutToken = setTimeout(() => {
          options.signal?.removeEventListener("abort", onAbort);
          resolve();
        }, finalDelay);
        if (options.unref) {
          timeoutToken.unref?.();
        }
        options.signal?.addEventListener("abort", onAbort, { once: true });
      });
    }
    options.signal?.throwIfAborted();
    return true;
  }
  async function pRetry(input, options = {}) {
    options = { ...options };
    validateRetries(options.retries);
    if (Object.hasOwn(options, "forever")) {
      throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
    }
    options.retries ??= 10;
    options.factor ??= 2;
    options.minTimeout ??= 1e3;
    options.maxTimeout ??= Number.POSITIVE_INFINITY;
    options.maxRetryTime ??= Number.POSITIVE_INFINITY;
    options.randomize ??= false;
    options.onFailedAttempt ??= () => {
    };
    options.shouldRetry ??= () => true;
    options.shouldConsumeRetry ??= () => true;
    validateNumberOption("factor", options.factor, { min: 0, allowInfinity: false });
    validateNumberOption("minTimeout", options.minTimeout, { min: 0, allowInfinity: false });
    validateNumberOption("maxTimeout", options.maxTimeout, { min: 0, allowInfinity: true });
    validateNumberOption("maxRetryTime", options.maxRetryTime, { min: 0, allowInfinity: true });
    if (!(options.factor > 0)) {
      options.factor = 1;
    }
    options.signal?.throwIfAborted();
    let attemptNumber = 0;
    let retriesConsumed = 0;
    const startTime = performance.now();
    while (Number.isFinite(options.retries) ? retriesConsumed <= options.retries : true) {
      attemptNumber++;
      try {
        options.signal?.throwIfAborted();
        const result = await input(attemptNumber);
        options.signal?.throwIfAborted();
        return result;
      } catch (error) {
        if (await onAttemptFailure({
          error,
          attemptNumber,
          retriesConsumed,
          startTime,
          options
        })) {
          retriesConsumed++;
        }
      }
    }
    throw new Error("Retry attempts exhausted without throwing an error.");
  }
  var SpaceUploadOrder = ((SpaceUploadOrder2) => {
    SpaceUploadOrder2["Latest"] = "pubdate";
    SpaceUploadOrder2["View"] = "click";
    SpaceUploadOrder2["Fav"] = "stow";
    return SpaceUploadOrder2;
  })(SpaceUploadOrder || {});
  const SpaceUploadOrderConfig = {
    [
      "pubdate"
]: {
      icon: jsx$1(IconForTimestamp, {}),
      label: "最新发布"
    },
    [
      "click"
]: {
      icon: jsx$1(IconForPlayer, {}),
      label: "最多播放"
    },
    [
      "stow"
]: {
      icon: jsx$1(IconForFav, {}),
      label: "最多收藏"
    }
  };
  const SPACE_UPLOAD_API_PAGE_SIZE = 40;
  async function getSpaceUpload({
    mid,
    order = "pubdate",
    keyword = "",
    pagenum = 1
  }) {
    const res = await request.get("/x/space/wbi/arc/search", {
      params: {
        mid,
        order,
        keyword,
        ps: SPACE_UPLOAD_API_PAGE_SIZE,
        pn: pagenum
      }
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      throw new Error(`request json error: ${json.message}` || OPERATION_FAIL_MSG);
    }
    const items = json.data.list.vlist || [];
    const count = json.data.page.count;
    let hasMore;
    let endVol;
    {
      const {
        count: count2,
        pn,
        ps
      } = json.data.page;
      hasMore = pn * ps < count2;
      endVol = count2 - (pn - 1) * ps;
    }
    return {
      items,
      hasMore,
      count,
      endVol
    };
  }
  async function tryGetSpaceUpload(...args) {
    return await pRetry(() => getSpaceUpload(...args), {
      retries: 5,
      factor: 1.5,
      onFailedAttempt: (err) => console.error(err)
    });
  }
  var SpaceUploadQueryKey = ((SpaceUploadQueryKey2) => {
    SpaceUploadQueryKey2["Mid"] = "space-mid";
    SpaceUploadQueryKey2["GroupId"] = "space-group-id";
    SpaceUploadQueryKey2["SearchText"] = "space-search-text";
    SpaceUploadQueryKey2["FilterText"] = "space-filter-text";
    SpaceUploadQueryKey2["InitialPage"] = "space-initial-page";
    return SpaceUploadQueryKey2;
  })(SpaceUploadQueryKey || {});
  const searchParams$1 = new URLSearchParams(location.search);
  const QUERY_SPACE_UPLOAD_MID = searchParams$1.get(
    "space-mid"
) || void 0;
  const QUERY_SPACE_UPLOAD_GROUP_ID = searchParams$1.get(
    "space-group-id"
) || void 0;
  const QUERY_SPACE_UPLOAD_SEARCH_TEXT = searchParams$1.get(
    "space-search-text"
) || void 0;
  const QUERY_SPACE_UPLOAD_FILTER_TEXT = searchParams$1.get(
    "space-filter-text"
) || void 0;
  const QUERY_SPACE_UPLOAD_INITIAL_PAGE = searchParams$1.get(
    "space-initial-page"
) || void 0;
  const mids = (QUERY_SPACE_UPLOAD_MID || "").split(/[,_-]/).map((x) => x.trim()).filter(Boolean).filter((x) => /^\d+$/.test(x));
  const groupId = QUERY_SPACE_UPLOAD_GROUP_ID ? Number(QUERY_SPACE_UPLOAD_GROUP_ID) : void 0;
  const SHOW_SPACE_UPLOAD_ONLY = !!(mids.length || groupId);
  const store$3 = proxy({
    mids,
    groupId,
    order: SpaceUploadOrder.Latest,
    searchText: QUERY_SPACE_UPLOAD_SEARCH_TEXT,
    filterText: QUERY_SPACE_UPLOAD_FILTER_TEXT,
    get isMultipleTraget() {
      return this.mids.length > 1 || !!this.groupId;
    },
    get allowedOrders() {
      return [SpaceUploadOrder.Latest, SpaceUploadOrder.View, !this.isMultipleTraget && SpaceUploadOrder.Fav].filter(Boolean);
    },
    get usingOrder() {
      return this.allowedOrders.includes(this.order) ? this.order : this.allowedOrders[0];
    }
  });
  const clsMenuRoot = styled.createClass`
  .ant-dropdown &.ant-dropdown-menu .ant-dropdown-menu-item {
    font-size: 13px; // same as Button
    justify-content: flex-start;
    .ant-dropdown-menu-title-content {
      flex-shrink: 0;
    }
  }
`;
  const GenericOrderSwitcher = function({
    value,
    onChange,
    disabled,
    list: list2,
    listDisplayConfig,
    dropdownProps,
    extraHelpInfo: extraHelpInfo2,
    $ref
  }) {
    const {
      icon,
      label
    } = listDisplayConfig[value];
    const onToggle = useMemoizedFn((e2) => {
      const allowed = list2.filter((x) => x !== "divider");
      const index = allowed.indexOf(value);
      if (index === -1) return;
      const nextIndex = (index + (e2.shiftKey ? -1 : 1) + allowed.length) % allowed.length;
      const next2 = allowed[nextIndex];
      onChange(next2);
    });
    const dropdownMenuItems = H.useMemo(() => {
      return defineAntMenus(list2.map((x) => {
        if (x === "divider") return {
          type: "divider"
        };
        const {
          icon: icon2,
          label: label2
        } = listDisplayConfig[x];
        return {
          key: x,
          icon: icon2,
          label: label2,
          onClick: () => onChange(x)
        };
      }));
    }, [list2, listDisplayConfig, onChange]);
    const dropdownStyle = {
overscrollBehavior: "contain",
      border: `1px solid ${usePopoverBorderColor()}`
    };
    const [open, setOpen] = H.useState(false);
    return jsxs("span", { className: "inline-flex items-center", ref: $ref, children: [
jsx$1(
        antd.Dropdown,
        {
          open,
          onOpenChange: setOpen,
          disabled,
          menu: {
            items: dropdownMenuItems,
            style: dropdownStyle,
            className: clsMenuRoot,
            selectedKeys: [value.toString()]
          },
          placement: "bottomRight",
          ...dropdownProps,
          children: jsx$1(antd.Button, { onClick: onToggle, css: [open && buttonOpenCss, "", ""], icon, className: "gap-8px px-16px", disabled, children: label })
        }
      ),
jsxs(HelpInfo, { children: [
        extraHelpInfo2,
        extraHelpInfo2 && jsx$1(antd.Divider, { variant: "solid", className: "my-7px" }),
        "操作说明: ",
jsx$1("br", {}),
        "1. 点击/下拉切换 ",
jsx$1("br", {}),
        "2. 按住 ",
jsx$1("kbd", { children: "Shift" }),
        " 键点击逆序切换 ",
jsx$1("br", {})
      ] })
    ] });
  };
  function SpaceUploadUsageInfo() {
    const {
      searchText,
      filterText,
      allowedOrders,
      usingOrder
    } = useSnapshot(store$3, {
      sync: true
    });
    const {
      order
    } = useSnapshot(store$3);
    const onRefresh = useOnRefreshContext();
    const onSyncStoreToUrl = useMemoizedFn(() => {
      const u2 = new URL(location.href);
      const {
        searchText: searchText2,
        filterText: filterText2
      } = store$3;
      searchText2 ? u2.searchParams.set(SpaceUploadQueryKey.SearchText, searchText2) : u2.searchParams.delete(SpaceUploadQueryKey.SearchText);
      filterText2 ? u2.searchParams.set(SpaceUploadQueryKey.FilterText, filterText2) : u2.searchParams.delete(SpaceUploadQueryKey.FilterText);
      history.replaceState({}, "", u2.href);
    });
    return jsxs("div", { className: "flex items-center gap-x-10px", children: [
jsx$1(GenericOrderSwitcher, { value: usingOrder, list: allowedOrders, listDisplayConfig: SpaceUploadOrderConfig, onChange: (value) => {
        store$3.order = value;
        onRefresh?.();
      } }),
jsx$1(antd.Input.Search, { style: {
        width: 200
      }, placeholder: "搜索词", allowClear: true, value: searchText, onChange: (e2) => store$3.searchText = e2.target.value, onSearch: (value) => {
        store$3.searchText = value;
        onSyncStoreToUrl();
        onRefresh?.();
      } }),
jsx$1(antd.Input.Search, { style: {
        width: 200
      }, placeholder: "本地过滤词", allowClear: true, value: filterText, onChange: (e2) => store$3.filterText = e2.target.value, onSearch: (value) => {
        store$3.filterText = value;
        onSyncStoreToUrl();
        onRefresh?.();
      } }),
jsx$1(CheckboxSettingItem, { configPath: "spaceUpload.showVol", label: "显示序号", className: "flex-none" }),
jsx$1(CopyBvidButtonsUsageInfo, {})
    ] });
  }
  function isSpaceUploadItemChargeOnly(item) {
    if (item.elec_arc_type === 1 || !item.elec_arc_type && item.is_charging_arc) return true;
    if (item.elec_arc_type === 2) return true;
    return false;
  }
  const spaceUploadAvatarCache = new QuickLRU({
    maxSize: 100
  });
  function getSpaceUploadServiceConfig() {
    const snap = snapshot(store$3);
    return {
      mids: snap.mids,
      groupId: snap.groupId,
      order: snap.usingOrder,
      searchText: snap.searchText,
      filterText: snap.filterText,
      initialPage: QUERY_SPACE_UPLOAD_INITIAL_PAGE ? Number(QUERY_SPACE_UPLOAD_INITIAL_PAGE) : void 0
    };
  }
  class SpaceUploadService extends BaseTabService {
    static PAGE_SIZE = 20;
mids;
    groupId;
    order;
    searchText;
    filterText;
    initialPage;
    constructor(config) {
      super(SpaceUploadService.PAGE_SIZE);
      Object.assign(this, config);
      this.mids = config.mids;
      this.order = config.order;
      invariant(this.mids.length || this.groupId, "mid & groupId can not both be empty");
      this.searchText = this.searchText?.trim();
      if (this.initialPage && (this.groupId || this.mids.length > 1)) {
        throw new Error("initialPage not supported when merging");
      }
    }
    usageInfo = jsx$1(SpaceUploadUsageInfo, {});
    get hasMoreExceptQueue() {
      if (this.isAnonymous) return false;
      if (!this.service) return true;
      return this.service.hasMore;
    }
    async fetchAvatars(mids2) {
      await Promise.all(mids2.map(async (mid) => {
        const info = await getSpaceAccInfo(mid);
        if (!info) return;
        spaceUploadAvatarCache.set(mid, info.face);
      }));
    }
pageTitleSet = false;
    async setPageTitle() {
      if (this.pageTitleSet) return;
      const prefixes = [];
      if (this.searchText) prefixes.push(`🔍【${this.searchText}】`);
      if (this.filterText) prefixes.push(`⏳【${this.filterText}】`);
      let author;
      if (this.mids.length) {
        const nicknames = await pmap(this.mids, getUserNickname, 3);
        author = nicknames.map((x) => x?.trim()).filter(Boolean).map((name) => `「${name}」`).join("、");
      } else {
        const tags = await getAllFollowGroups();
        const name = tags.find((x) => x.tagid === this.groupId)?.name || "";
        author = name ? `「${name}」` : "";
      }
      const title = [prefixes.join(""), `${author}的投稿`].map((x) => x.trim()).filter(Boolean).join(" - ");
      setPageTitle(title);
      this.pageTitleSet = true;
    }
    singleUpService;
    mergeTimelineService;
    async setupServices() {
      if (this.singleUpService || this.mergeTimelineService) return;
      if (this.mids.length === 1) {
        this.singleUpService = new SingleUpService(this.mids[0], this.order, this.searchText, this.initialPage);
        return;
      }
      if (this.mids.length) {
        this.mergeTimelineService = new MergeTimeService(this.mids, this.order, this.searchText);
        return;
      }
      if (this.groupId) {
        const mids2 = await getFollowGroupContent(this.groupId);
        this.mergeTimelineService = new MergeTimeService(mids2.map((x) => x.toString()), this.order, this.searchText);
        return;
      }
    }
    get service() {
      return this.singleUpService || this.mergeTimelineService;
    }
    isAnonymous = false;
    warnNeedLoginOnce = once(() => {
      toastNeedLogin();
    });
    async fetchMore(abortSignal) {
      if (!checkLoginStatus()) {
        this.isAnonymous = true;
        this.warnNeedLoginOnce();
        throw new ShowMessageError(NEED_LOGIN_MESSAGE);
      }
      this.setPageTitle();
      await this.setupServices();
      invariant(this.service, "no service available after setupServices");
      const items = await this.service.loadMore(abortSignal) || [];
      const endVol = this.singleUpService ? this.singleUpService.endVol : this.mergeTimelineService.count - this.qs.fetchedCount;
      let list2 = items.map((item, index) => {
        return {
          ...item,
          api: EApiType.SpaceUpload,
          uniqId: `${EApiType.SpaceUpload}-${item.bvid}`,
          vol: endVol - index,
          page: this.singleUpService ? this.singleUpService.page - 1 : void 0
        };
      });
      list2 = list2.filter((item) => !isSpaceUploadItemChargeOnly(item));
      if (this.filterText) {
        const {
          includes,
          excludes
        } = parseSearchInput(this.filterText);
        list2 = list2.filter((item) => {
          return includes.every((include) => item.title.includes(include)) && excludes.every((exclude) => !item.title.includes(exclude));
        });
      }
      {
        const mids2 = uniq(list2.filter((item) => item.author.trim() !== "账号已注销").map((item) => item.mid.toString()));
        await this.fetchAvatars(mids2);
      }
      return list2;
    }
  }
  class MergeTimeService {
    constructor(mids2, order, searchText) {
      this.mids = mids2;
      this.order = order;
      this.searchText = searchText;
      invariant(this.mids.length === 1 || this.mids.length > 1 && this.order !== SpaceUploadOrder.Fav, "SpaceUploadItem.Fav not supported when merging");
      this.singleUpServices = mids2.map((mid) => new SingleUpService(mid, this.order, this.searchText));
    }
    singleUpServices;
    get hasMore() {
      return this.singleUpServices.some((service) => service.hasMore);
    }
    get count() {
      return this.singleUpServices.reduce((total, service) => total + service.count, 0);
    }
    async refillQueues(abortSignal) {
      await pmap(this.singleUpServices, (s2) => s2.refillQueue(1, abortSignal), 5);
    }
    async loadMore(abortSignal) {
      if (!this.hasMore) return;
      if (this.mids.length === 1) {
        return this.singleUpServices[0].loadMore(abortSignal);
      }
      const pickedItems = [];
      const expectSize = 10;
      while (this.hasMore && pickedItems.length < expectSize) {
        await this.refillQueues(abortSignal);
        const restServices = this.singleUpServices.filter((s2) => s2.bufferQueue.length > 0);
        const pickedService = orderBy(restServices.map((service) => {
          const item = service.bufferQueue[0];
          const valueForSort = {
            [SpaceUploadOrder.Latest]: item.created,
            [SpaceUploadOrder.View]: item.play,
            [SpaceUploadOrder.Fav]: item.play
}[this.order];
          return {
            service,
            item,
            valueForSort
          };
        }), ["valueForSort"], ["desc"]).map((x) => x.service)[0];
        if (!pickedService) break;
        const head = pickedService.bufferQueue[0];
        pickedService.bufferQueue = pickedService.bufferQueue.slice(1);
        pickedItems.push(head);
      }
      return pickedItems;
    }
  }
  class SingleUpService {
    constructor(mid, order, searchText, initialPage) {
      this.mid = mid;
      this.order = order;
      this.searchText = searchText;
      this.initialPage = initialPage;
      this.page = this.initialPage ?? 1;
    }
    bufferQueue = [];
    hasMoreForApi = true;
    count = 0;
    endVol = 0;
    get hasMore() {
      return !!this.bufferQueue.length || this.hasMoreForApi;
    }
    async refillQueue(minimalQueueSize, abortSignal) {
      if (!this.hasMore) return;
      while (!abortSignal?.aborted && this.hasMoreForApi && this.bufferQueue.length < minimalQueueSize) {
        const items = await this.loadMore(abortSignal) || [];
        this.bufferQueue.push(...items);
      }
    }
    page;
    async loadMore(abortSignal) {
      const {
        items,
        hasMore,
        count,
        endVol
      } = await tryGetSpaceUpload({
        mid: this.mid,
        order: this.order,
        pagenum: this.page,
        keyword: this.searchText || ""
      });
      this.hasMoreForApi = hasMore;
      this.page++;
      this.count = count;
      this.endVol = endVol;
      return items;
    }
  }
  const toHttps = (url) => (url || "").replace(/^http:\/\//, "https://");
  const DESC_SEPARATOR = " · ";
  function lookinto(item, opts) {
    if (isAppRecommend(item)) return opts[EApiType.AppRecommend](item);
    if (isPcRecommend(item)) return opts[EApiType.PcRecommend](item);
    if (isDynamicFeed(item)) return opts[EApiType.DynamicFeed](item);
    if (isWatchlater(item)) return opts[EApiType.Watchlater](item);
    if (isFav(item)) return opts[EApiType.Fav](item);
    if (isPopularGeneral(item)) return opts[EApiType.PopularGeneral](item);
    if (isPopularWeekly(item)) return opts[EApiType.PopularWeekly](item);
    if (isRank(item)) return opts[EApiType.Rank](item);
    if (isLive(item)) return opts[EApiType.Live](item);
    if (isSpaceUpload(item)) return opts[EApiType.SpaceUpload](item);
    throw new Error(`unknown api type`);
  }
  function normalizeCardData(item) {
    const ret = lookinto(item, {
      [EApiType.AppRecommend]: apiAppAdapter,
      [EApiType.PcRecommend]: apiPcAdapter,
      [EApiType.DynamicFeed]: apiDynamicAdapter,
      [EApiType.Watchlater]: apiWatchlaterAdapter,
      [EApiType.Fav]: apiFavAdapter,
      [EApiType.PopularGeneral]: apiPopularGeneralAdapter,
      [EApiType.PopularWeekly]: apiPopularWeeklyAdapter,
      [EApiType.Rank]: apiRankAdapter,
      [EApiType.Live]: apiLiveAdapter,
      [EApiType.SpaceUpload]: apiSpaceUploadAdapter
    });
    if (ret.authorFace) ret.authorFace = toHttps(ret.authorFace);
    ret.cover = toHttps(ret.cover);
    return ret;
  }
  function apiAppAdapter(item) {
    return apiIpadAppAdapter(item);
  }
  function apiIpadAppAdapter(item) {
    const extractCountFor = (target) => {
      const {
        cover_left_text_1,
        cover_left_text_2,
        cover_left_text_3
      } = item;
      const arr = [cover_left_text_1, cover_left_text_2, cover_left_text_3].filter(Boolean);
      if (target === "play") {
        const text = arr.find((text2) => /观看|播放$/.test(text2));
        if (!text) return;
        const rest = text.replace(/观看|播放$/, "");
        return parseCount(rest);
      }
      if (target === "danmaku") {
        const text = arr.find((text2) => text2.endsWith("弹幕"));
        if (!text) return;
        const rest = text.replace(/弹幕$/, "");
        return parseCount(rest);
      }
      if (target === "bangumi:follow") {
        const text = arr.find((text2) => /追[剧番]$/.test(text2));
        if (!text) return;
        const rest = text.replace(/追[剧番]$/, "");
        return parseCount(rest);
      }
    };
    const avid = item.param;
    const bvid = item.bvid || BvCode.av2bv(Number(item.param));
    const cid = item.player_args?.cid;
    const href = (() => {
      if (item.uri.startsWith("http://") || item.uri.startsWith("https://")) {
        return item.uri;
      }
      if (item.goto === "av") {
        return `/video/${bvid}/`;
      }
      if (item.goto === "bangumi") {
        appWarn(`bangumi uri should not starts with 'bilibili://': %s`, item.uri);
        return item.uri;
      }
      if (item.goto === "picture") {
        const id = /^bilibili:\/\/article\/(\d+)$/.exec(item.uri)?.[1];
        if (id) return `/read/cv${id}`;
        return item.uri;
      }
      return item.uri;
    })();
    const play = extractCountFor("play");
    const like = void 0;
    const coin = void 0;
    const danmaku = extractCountFor("danmaku");
    const favorite = void 0;
    const bangumiFollow = extractCountFor("bangumi:follow");
    const statItems = [{
      field: "play",
      value: play
    }, typeof danmaku === "number" ? {
      field: "danmaku",
      value: danmaku
    } : {
      field: "bangumi:follow",
      value: bangumiFollow
    }];
    const desc = item.desc || "";
    const [descAuthorName = void 0, descDate = void 0] = desc.split(DESC_SEPARATOR);
    return {
avid,
      bvid,
      cid,
      goto: item.goto,
      href,
      title: item.title,
      cover: item.cover,
      pubts: void 0,
      pubdateDisplay: descDate,
      duration: item.player_args?.duration || 0,
      durationStr: formatDuration(item.player_args?.duration),
      recommendReason: item.bottom_rcmd_reason || item.top_rcmd_reason,
play,
      like,
      coin,
      danmaku,
      favorite,
      bangumiFollow,
      statItems,
authorName: item.args.up_name || descAuthorName,
      authorFace: item.avatar.cover,
      authorMid: String(item.args.up_id || ""),
      appBadge: item.cover_badge,
      appBadgeDesc: item.desc
    };
  }
  function apiPcAdapter(item) {
    item.goto === PcRecGoto.AV;
    const _isLive = item.goto === PcRecGoto.Live;
    return {
avid: _isLive ? void 0 : String(item.id),
      bvid: _isLive ? void 0 : item.bvid,
      cid: _isLive ? void 0 : item.cid,
      goto: item.goto,
      href: item.goto === "av" ? `/video/${item.bvid}/` : item.uri,
      title: item.title,
      cover: item.pic,
      pubts: item.pubdate,
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason: _isLive ? item.room_info?.area.area_name : item.rcmd_reason?.content,
play: item.stat?.view,
      like: item.stat?.like,
      coin: void 0,
      danmaku: item.stat?.danmaku,
      favorite: void 0,
      statItems: _isLive ? defineStatItems([{
        field: "live:viewed-by",
        value: item.room_info?.watched_show.num
      }]) : defineStatItems([{
        field: "play",
        value: item.stat?.view
      }, {
        field: "danmaku",
        value: item.stat?.danmaku
      }]),
authorName: item.owner?.name,
      authorFace: item.owner?.face,
      authorMid: String(item.owner?.mid)
    };
  }
  function apiDynamicAdapter(item) {
    const v = item.modules.module_dynamic.major.archive;
    const author = item.modules.module_author;
    return {
avid: v.aid,
      bvid: v.bvid,
goto: "av",
      href: `/video/${v.bvid}/`,
      title: v.title,
      cover: v.cover,
      pubts: author.pub_ts,
      duration: parseDuration(v.duration_text) || 0,
      durationStr: v.duration_text,
recommendReason: v.badge.text === DynamicFeedBadgeText.Upload ? v.badge.text : void 0,
      dynBadge: v.badge,
statItems: defineStatItems([{
        field: "play",
        value: v.stat.play
      }, {
        field: "danmaku",
        value: v.stat.danmaku
      }]),
      play: parseCount(v.stat.play),
      danmaku: parseCount(v.stat.danmaku),
authorName: author.name,
      authorFace: author.face,
      authorMid: author.mid.toString()
    };
  }
  function apiWatchlaterAdapter(item) {
    const invalidReason = getVideoInvalidReason(item.state);
    const viewed = item.progress > 0;
    const title = `${viewed ? "【已观看】· " : ""}${item.title}`;
    const titleRender = invalidReason ? jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
      "视频已失效, 原因: ",
      invalidReason
    ] }), align: {
      offset: [0, -5]
    }, placement: "topLeft", children: jsxs("del", { children: [
      viewed ? "【已观看】· " : "",
      item.title,
      "`"
    ] }) }) : void 0;
    const {
      watchlaterUseNormalVideoUrl,
      watchlaterItemsOrder
    } = getSettingsSnapshot();
    const href = (() => {
      if (watchlaterUseNormalVideoUrl) return `https://www.bilibili.com/video/${item.bvid}/`;
      let autoListUrl = `https://www.bilibili.com/list/watchlater?bvid=${item.bvid}&oid=${item.aid}`;
      if (watchlaterItemsOrder === WatchlaterItemsOrder.AddTimeAsc) autoListUrl += "&desc=0";
      return autoListUrl;
    })();
    return {
avid: String(item.aid),
      bvid: item.bvid,
      cid: item.cid,
      goto: "av",
      href,
      title,
      titleRender,
      cover: item.pic,
      pubts: item.pubdate,
      pubdateDisplayForTitleAttr: `${formatTimeStamp(item.pubdate, true)} 发布, ${formatTimeStamp(item.add_at, true)} 添加稍后再看`,
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason: `${formatTimeStamp(item.add_at)} · 稍后再看`,
statItems: defineStatItems([
        {
          field: "play",
          value: item.stat.view
        },
        {
          field: "like",
          value: item.stat.like
        },
{
          field: "favorite",
          value: item.stat.favorite
        }
      ]),
      play: item.stat.view,
      like: item.stat.like,
      danmaku: item.stat.danmaku,
authorName: item.owner.name,
      authorFace: item.owner.face,
      authorMid: String(item.owner.mid)
    };
  }
  function apiFavAdapter(item) {
    const belongsToTitle = item.from === "fav-folder" ? item.folder.title : item.collection.title;
    const iconInTitleStyle = {
      display: "inline-block",
      verticalAlign: "middle",
      marginRight: 4,
      marginTop: -2
    };
    const fillWithColorPrimary = "[&_path]:fill-gate-primary";
    const iconInTitle = item.from === "fav-folder" ? isFavFolderPrivate(item.folder.attr) ? jsx$1(IconForPrivateFolder, { className: clsx("size-15px", fillWithColorPrimary), style: iconInTitleStyle }) : jsx$1(IconForPublicFolder, { className: clsx("size-15px", fillWithColorPrimary), style: iconInTitleStyle }) : jsx$1(IconForCollection, { className: clsx("size-15px", fillWithColorPrimary), style: iconInTitleStyle });
    return {
avid: String(item.id),
      bvid: item.bvid,
goto: "av",
      href: `/video/${item.bvid}/`,
      title: `【${belongsToTitle}】· ${item.title}`,
      titleRender: jsxs(Fragment, { children: [
        "【",
        iconInTitle,
        belongsToTitle,
        "】· ",
        item.title
      ] }),
      cover: item.cover,
      pubts: item.pubtime,
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason: item.from === "fav-folder" ? `${formatTimeStamp(item.fav_time)} · 收藏` : void 0,
play: item.cnt_info.play,
      danmaku: item.cnt_info.danmaku,
      favorite: item.cnt_info.collect,
      statItems: defineStatItems([{
        field: "play",
        value: item.cnt_info.play
      }, {
        field: "danmaku",
        value: item.cnt_info.danmaku
      }, {
        field: "favorite",
        value: item.cnt_info.collect
      }]),
authorName: item.upper.name,
      authorFace: item.upper.face,
      authorMid: String(item.upper.mid)
    };
  }
  function apiPopularGeneralAdapter(item) {
    return {
avid: String(item.aid),
      bvid: item.bvid,
      cid: item.cid,
      goto: "av",
      href: `/video/${item.bvid}/`,
      title: item.title,
      cover: item.pic,
      pubts: item.pubdate,
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason: item.rcmd_reason?.content,
play: item.stat.view,
      like: item.stat.like,
      coin: void 0,
      danmaku: item.stat.danmaku,
      favorite: void 0,
      statItems: defineStatItems([
        {
          field: "play",
          value: item.stat.view
        },
        {
          field: "like",
          value: item.stat.like
        }
]),
authorName: item.owner.name,
      authorFace: item.owner.face,
      authorMid: String(item.owner.mid)
    };
  }
  function apiPopularWeeklyAdapter(item) {
    return {
avid: String(item.aid),
      bvid: item.bvid,
      cid: item.cid,
      goto: "av",
      href: `/video/${item.bvid}/`,
      title: item.title,
      cover: item.pic,
      pubts: item.pubdate,
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason: item.rcmd_reason,
play: item.stat.view,
      like: item.stat.like,
      danmaku: item.stat.danmaku,
      statItems: defineStatItems([
        {
          field: "play",
          value: item.stat.view
        },
        {
          field: "like",
          value: item.stat.like
        }
]),
authorName: item.owner.name,
      authorFace: item.owner.face,
      authorMid: String(item.owner.mid)
    };
  }
  function apiRankAdapter(item) {
    if (isPgcWebRankItem(item) || isPgcSeasonRankItem(item)) {
      const cover = item.new_ep.cover;
      const rankingDesc = item.new_ep.index_show;
      return {
avid: "",
        bvid: "",
        goto: "bangumi",
        href: item.url,
        title: item.title,
        cover,
        pubts: void 0,
        pubdateDisplay: void 0,
        duration: 0,
        durationStr: "",
play: item.stat.view,
        like: item.stat.follow,
        danmaku: item.stat.danmaku,
        statItems: defineStatItems([
          {
            field: "play",
            value: item.stat.view
          },
          {
            field: "bangumi:follow",
            value: item.stat.follow
          }
]),
        rankingDesc
      };
    }
    let recommendReason = (item.dynamic || item.desc)?.trim();
    if (recommendReason === "-") recommendReason = void 0;
    if (recommendReason && item.title.includes(recommendReason)) recommendReason = void 0;
    return {
avid: String(item.aid),
      bvid: item.bvid,
      cid: item.cid,
      goto: "av",
      href: `/video/${item.bvid}/`,
      title: item.title,
      cover: item.pic,
      pubts: item.pubdate,
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason,
play: item.stat.view,
      like: item.stat.like,
      danmaku: item.stat.danmaku,
      statItems: defineStatItems([
        {
          field: "play",
          value: item.stat.view
        },
        {
          field: "like",
          value: item.stat.like
        }
]),
authorName: item.owner.name,
      authorFace: item.owner.face,
      authorMid: String(item.owner.mid)
    };
  }
  function apiLiveAdapter(item) {
    const area = `${item.area_name_v2}`;
    const liveExtraDesc = item.live_status === ELiveStatus.Streaming ? "" : `${DESC_SEPARATOR}${formatLiveTime(item.record_live_time)} 直播过`;
    function formatLiveTime(ts) {
      const today = dayjs().format("YYYYMMDD");
      const yesterday = dayjs().subtract(1, "day").format("YYYYMMDD");
      const d2 = dayjs.unix(ts);
      if (d2.format("YYYYMMDD") === today) {
        return d2.format("HH:mm");
      }
      if (d2.format("YYYYMMDD") === yesterday) {
        return `昨天 ${d2.format("HH:mm")}`;
      }
      return d2.format("MM-DD HH:mm");
    }
    return {
goto: "live",
      href: `https://live.bilibili.com/${item.roomid}`,
      title: item.title,
      cover: item.room_cover,
      recommendReason: area,
      liveExtraDesc,
statItems: defineStatItems([{
        field: "live:viewed-by",
        value: item.text_small
      }]),
authorName: item.uname,
      authorFace: item.face,
      authorMid: String(item.uid)
    };
  }
  function apiSpaceUploadAdapter(item) {
    const duration2 = parseDuration(item.length);
    const durationStr = formatDuration(duration2);
    let recommendReason = item.description?.trim();
    if (recommendReason === "-") recommendReason = void 0;
    if (recommendReason && item.title.includes(recommendReason)) recommendReason = void 0;
    return {
avid: item.aid.toString(),
      bvid: item.bvid,
      cid: void 0,
      goto: "av",
      href: `/video/${item.bvid}/`,
      title: item.title,
      cover: item.pic,
      pubts: item.created,
      duration: duration2,
      durationStr,
      recommendReason,
play: item.play,
      like: void 0,
      coin: void 0,
      danmaku: item.video_review,
      favorite: void 0,
      statItems: defineStatItems([{
        field: "play",
        value: item.play
      }, {
        field: "danmaku",
        value: item.video_review
      }]),
authorName: item.author,
      authorFace: spaceUploadAvatarCache.get(item.mid.toString()),
      authorMid: item.mid.toString()
    };
  }
  const REG_MID_WITH_REMARK = /^(?<mid>\d+)\((?<remark>[\S ]+)\)$/;
  const REG_MID = /^\d+$/;
  function parseUpRepresent(author) {
    if (REG_MID_WITH_REMARK.test(author)) {
      const groups = REG_MID_WITH_REMARK.exec(author)?.groups;
      const mid = groups?.mid;
      const remark = groups?.remark;
      return {
        mid,
        remark
      };
    }
    if (REG_MID.test(author)) {
      return {
        mid: author,
        remark: void 0
      };
    }
    return {};
  }
  function parseFilterByAuthor(keywords) {
    const blockUpMids = new Set();
    const blockUpNames = new Set();
    keywords.forEach((keyword) => {
      const {
        mid
      } = parseUpRepresent(keyword);
      mid ? blockUpMids.add(mid) : blockUpNames.add(keyword);
    });
    return {
      blockUpMids,
      blockUpNames
    };
  }
  function parseFilterByTitle(keywords) {
    const titleRegexList = [];
    const titleKeywordList = [];
    keywords.forEach((keyword) => {
      if (keyword.startsWith("/") && keyword.endsWith("/")) {
        const regex = new RegExp(keyword.slice(1, -1), "i");
        titleRegexList.push(regex);
      } else {
        titleKeywordList.push(keyword);
      }
    });
    return {
      titleKeywordList,
      titleRegexList
    };
  }
  const debug$a = baseDebug.extend("modules:filter");
  function getFollowedStatus$1(recommendReason) {
    return !!recommendReason && ["已关注", "新关注"].includes(recommendReason);
  }
  function anyFilterEnabled(tab2) {
    if (tab2 === ETab.KeepFollowOnly) {
      return true;
    }
    const mayNeedCheck_blacklist_filterByUp_filterByTitle = [ETab.AppRecommend, ETab.PcRecommend, ETab.Hot].includes(tab2);
    if (mayNeedCheck_blacklist_filterByUp_filterByTitle && (blacklistMids.size || settings.filter.enabled && (settings.filter.byAuthor.enabled && !!settings.filter.byAuthor.keywords.length || settings.filter.byTitle.enabled && !!settings.filter.byTitle.keywords.length))) {
      return true;
    }
    if ((tab2 === ETab.AppRecommend || tab2 === ETab.PcRecommend) && settings.filter.enabled) {
      return true;
    }
    return false;
  }
  function isApiRecLike(api) {
    return [EApiType.AppRecommend, EApiType.PcRecommend, EApiType.Rank, EApiType.PopularGeneral, EApiType.PopularWeekly].includes(api);
  }
  function filterRecItems(items, tab2) {
    if (!anyFilterEnabled(tab2)) {
      return items;
    }
    const filter = getSettingsSnapshot().filter;
    const {
      minDuration,
      minPlayCount,
      minDanmakuCount,
      byAuthor,
      byTitle
    } = filter;
    const {
      blockUpMids,
      blockUpNames
    } = parseFilterByAuthor(byAuthor.keywords);
    const {
      titleKeywordList,
      titleRegexList
    } = parseFilterByTitle(byTitle.keywords);
    return items.filter((item) => {
      if (item.api === EApiType.Separator) return true;
      const {
        play,
        duration: duration2,
        danmaku,
        recommendReason,
        goto,
        authorName,
        authorMid,
        title,
        bvid,
        href
      } = normalizeCardData(item);
      const followed = getFollowedStatus$1(recommendReason);
      if (tab2 === "keep-follow-only" && !followed) return false;
      function check_blacklist_filterByUp_filterByTitle() {
        if (authorMid && blacklistMids.size && blacklistMids.has(authorMid)) {
          debug$a("filter out by blacklist-rule: %s %o", authorMid, {
            bvid,
            title
          });
          return false;
        }
        if (filter.enabled && byAuthor.enabled && (blockUpMids.size || blockUpNames.size) && (authorName || authorMid) && (authorName && blockUpNames.has(authorName) || authorMid && blockUpMids.has(authorMid))) {
          debug$a("filter out by author-rule: %o", {
            authorName,
            authorMid,
            rules: byAuthor.keywords,
            blockUpMids,
            blockUpNames,
            bvid,
            title
          });
          return false;
        }
        let possibleTitles = [title];
        if (item.api === EApiType.Rank && isNormalRankItem(item) && item.desc) {
          possibleTitles.push(item.desc);
        }
        possibleTitles = possibleTitles.filter(Boolean);
        if (filter.enabled && byTitle.enabled && byTitle.keywords.length && possibleTitles.length) {
          const titleHit = (title2) => titleKeywordList.some((keyword) => title2.includes(keyword)) || titleRegexList.some((regex) => regex.test(title2));
          if (possibleTitles.some(titleHit)) {
            debug$a("filter out by title-rule: %o", {
              possibleTitles,
              rules: byTitle.keywords,
              bvid
            });
            return false;
          }
        }
      }
      if (isApiRecLike(item.api) && check_blacklist_filterByUp_filterByTitle() === false) {
        return false;
      }
      if ((item.api === EApiType.AppRecommend || item.api === EApiType.PcRecommend) && filter.enabled) {
        const isVideo = goto === "av";
        const isPicture = goto === "picture";
        const isBangumi = goto === "bangumi";
        if (isVideo) return filterVideo();
        if (isPicture) return filterPicture();
        if (isBangumi) return filterBangumi();
      }
      function filterVideo() {
        if (followed && filter.exemptForFollowed.video) return true;
        if (recommendReason === "关注了你") {
          debug$a("filter out by recommendReason-rule: %s %o", recommendReason, {
            bvid,
            title
          });
          return false;
        }
        if (minDuration.enabled && minDuration.value && duration2 && duration2 < minDuration.value) {
          debug$a("filter out by min-duration-rule: %s < %s %o", duration2, minDuration.value, {
            bvid,
            title
          });
          return false;
        }
        if (minPlayCount.enabled && minPlayCount.value && typeof play === "number" && play < minPlayCount.value) {
          debug$a("filter out by min-play-count-rule: %s < %s, %o", play, minPlayCount.value, {
            bvid,
            title
          });
          return false;
        }
        if (minDanmakuCount.enabled && minDanmakuCount.value && typeof danmaku === "number" && danmaku < minDanmakuCount.value) {
          debug$a("filter out by min-danmaku-count-rule: %s < %s, %o", danmaku, minDanmakuCount.value, {
            bvid,
            title
          });
          return false;
        }
        return true;
      }
      function filterPicture() {
        if (filter.hideGotoTypePicture) {
          if (followed && filter.exemptForFollowed.picture) {
            return true;
          }
          debug$a("filter out by goto-type-picture-rule: %s %o", goto, {
            bvid,
            title
          });
          return false;
        } else {
          return true;
        }
      }
      function filterBangumi() {
        if (filter.hideGotoTypeBangumi) {
          debug$a("filter out by goto-type-bangumi-rule: %s %o", goto, {
            title,
            href
          });
          return false;
        }
        return true;
      }
      return true;
    });
  }
  async function getLiveList(page) {
    const res = await request.get("https://api.live.bilibili.com/xlive/web-ucenter/user/following", {
      params: {
        page,
        page_size: LiveRecService.PAGE_SIZE,
        ignoreRecord: 1,
        hit_ab: true
      }
    });
    const json = res.data;
    return json;
  }
  class LiveRecService extends BaseTabService {
    constructor(streamingOnly = false) {
      super(LiveRecService.PAGE_SIZE);
      this.streamingOnly = streamingOnly;
    }
    static PAGE_SIZE = 20;
    usageInfo = void 0;
    hasMoreExceptQueue = true;
    separatorAdded = false;
    liveCount = -1;
    page = 1;
    totalPage = Infinity;
    async fetchMore(abortSignal) {
      if (this.page > this.totalPage) {
        this.hasMoreExceptQueue = false;
        return;
      }
      const json = await getLiveList(this.page);
      if (!isWebApiSuccess(json)) {
        toast(json.message || REQUEST_FAIL_MSG);
        this.hasMoreExceptQueue = false;
      }
      this.page++;
      const {
        count,
        live_count,
        totalPage
      } = json.data;
      this.totalPage = totalPage;
      this.liveCount = live_count;
      const items = json.data.list.map((item) => {
        const _item = {
          ...item,
          api: EApiType.Live,
          uniqId: `${EApiType.Live}-${item.roomid}`
        };
        return _item;
      });
      const last = items.at(-1);
      const gateTime = dayjs().subtract(2, "weeks").unix();
      if (last) {
        const lastStatus = last.live_status;
        const lastLiveTime = last.record_live_time;
        if (lastStatus !== ELiveStatus.Streaming && lastLiveTime && lastLiveTime < gateTime) {
          this.hasMoreExceptQueue = false;
        }
      }
      let ret = items;
      if (!this.streamingOnly && !this.separatorAdded && items.some((x) => x.live_status !== ELiveStatus.Streaming)) {
        this.separatorAdded = true;
        const index = items.findIndex((x) => x.live_status !== ELiveStatus.Streaming);
        ret.splice(index, 0, {
          api: EApiType.Separator,
          uniqId: "live-separator-recent",
          content: "最近直播过"
        });
      }
      if (this.streamingOnly && items.some((x) => x.live_status !== ELiveStatus.Streaming)) {
        this.hasMoreExceptQueue = false;
        ret = items.filter((x) => x.live_status === ELiveStatus.Streaming);
      }
      return ret;
    }
  }
  async function fetchVideoDynamicFeeds({
    offset,
    page,
    upMid,
    abortSignal
  }) {
    const params = {
      "timezone_offset": "-480",
      "type": "video",
      "platform": "web",
      "features": "itemOpusStyle",
      "web_location": "0.0",
      "x-bili-device-req-json": JSON.stringify({
        platform: "web",
        device: "pc"
      }),
      "x-bili-web-req-json": JSON.stringify({
        spm_id: "0.0"
      }),
      "page": page
    };
    if (offset) {
      params.offset = offset;
    }
    const apiPath = "/x/polymer/web-dynamic/v1/feed/all";
    if (upMid) {
      params.host_mid = upMid;
    }
    const res = await request.get(apiPath, {
      signal: abortSignal,
      params
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      const msg = json.message || REQUEST_FAIL_MSG;
      toast(msg);
      throw new Error(msg, {
        cause: json
      });
    }
    const data2 = json.data;
    if (data2?.items?.length) {
      data2.items = data2.items.filter((x) => x.type === "DYNAMIC_TYPE_AV");
    }
    return data2;
  }
  const cache = getIdbCache("dynamic-feed-items");
  const infoCache = getIdbCache("dynamic-feed-items-info");
  async function hasLocalDynamicFeedCache(upMid) {
    const existing = await infoCache.get(upMid);
    return !!existing?.count;
  }
  function createUpdateSearchCacheNotifyFns(upMid, upName) {
    const notiKey = (mid) => `update-search-cache-${mid}`;
    const _onProgress = (page, total) => {
      antNotification.info({
        icon: jsx$1(ForwardRef$O, { className: "size-16px" }),
        key: notiKey(upMid),
        message: `搜索缓存更新中...`,
        description: `「${upName}」更新中: Page(${page}) Total(${total})`,
        duration: null
});
    };
    const onProgress = throttle$1(_onProgress, 200);
    const onSuccess = () => {
      onProgress.flush();
      antNotification.success({
        key: notiKey(upMid),
        message: `缓存更新成功`,
        description: `「${upName}」的搜索缓存更新成功`,
        duration: null
});
    };
    return {
      notifyOnProgress: onProgress,
      notifyOnSuccess: onSuccess
    };
  }
  async function updateLocalDynamicFeedCache(upMid, onProgress) {
    if (await hasLocalDynamicFeedCache(upMid)) {
      await performIncrementalUpdate(upMid);
    } else {
      await performFullUpdate(upMid, void 0, onProgress);
    }
  }
  async function performIncrementalUpdateIfNeed(upMid, force = false) {
    const info = await infoCache.get(upMid);
    if (!force && info && info.count && info.updatedAt && Date.now() - info.updatedAt < 60 * 1e3) {
      return;
    }
    return performIncrementalUpdate(upMid);
  }
  async function performIncrementalUpdate(upMid) {
    if (!await hasLocalDynamicFeedCache(upMid)) return;
    const existing = await cache.get(upMid) || [];
    const existingIds = new Set(existing.map((x) => x.id_str));
    let page = 1;
    let offset = "";
    let hasMore = true;
    let newItems = [];
    while (hasMore) {
      const data2 = await fetchVideoDynamicFeeds({
        upMid,
        page,
        offset
      });
      const items = data2.items;
      newItems = [...newItems, ...items];
      offset = data2.offset;
      hasMore = data2.has_more;
      page++;
      if (hasMore && existingIds.size) {
        const allIncluded = items.every((item) => existingIds.has(item.id_str));
        if (allIncluded) {
          hasMore = false;
        }
      }
    }
    const allItems = uniqBy([...newItems, ...existing], (x) => x.id_str);
    await cache.set(upMid, allItems);
    await infoCache.set(upMid, {
      count: allItems.length,
      updatedAt: Date.now()
    });
  }
  const fullUpdateInProgressCache = getIdbCache("dynamic-feed-items-in-progress");
  async function performFullUpdate(upMid, skipCache = false, onProgress) {
    const inProgressCached = skipCache ? void 0 : await fullUpdateInProgressCache.get(upMid);
    let page = inProgressCached?.page ?? 1;
    let offset = inProgressCached?.offset ?? "";
    let allItems = inProgressCached?.items ?? [];
    let hasMore = true;
    while (hasMore) {
      const data2 = await fetchVideoDynamicFeeds({
        upMid,
        page,
        offset
      });
      const items = data2.items;
      allItems = [...allItems, ...items];
      offset = data2.offset;
      hasMore = data2.has_more;
      page++;
      await fullUpdateInProgressCache.set(upMid, {
        page,
        offset,
        items: allItems
      });
      onProgress?.(page, allItems.length);
    }
    const _allItems = uniqBy(allItems, (x) => x.id_str);
    await cache.set(upMid, _allItems);
    await infoCache.set(upMid, {
      count: _allItems.length,
      updatedAt: Date.now()
    });
    await fullUpdateInProgressCache.delete(upMid);
  }
  const fetchVideoDynamicFeedsWithCache = wrapWithIdbCache({
    fn: fetchVideoDynamicFeeds,
    generateKey: ({
      upMid
    }) => `${upMid}`,
    tableName: "dynamic-feed-newest-items",
ttl: 5 * 60 * 1e3
});
  class FollowGroupUpService {
    constructor(upMid, enableHeadCache = false) {
      this.upMid = upMid;
      this.enableHeadCache = enableHeadCache;
    }
    bufferQueue = [];
    hasMoreForApi = true;
    offset = "";
    page = 1;
get hasMore() {
      return !!this.bufferQueue.length || this.hasMoreForApi;
    }
    async loadMore() {
      const enableCache = this.page === 1 && !this.offset && this.enableHeadCache;
      const fn = enableCache ? fetchVideoDynamicFeedsWithCache : fetchVideoDynamicFeeds;
      const data2 = await fn({
        upMid: this.upMid,
        page: this.page,
        offset: this.offset
      });
      this.offset = data2.offset;
      this.hasMoreForApi = data2.has_more;
      this.page++;
      if (isEqual$1(data2, {
        has_more: true,
        items: [],
        offset: "",
        update_baseline: "",
        update_num: 0
      })) {
        this.hasMoreForApi = false;
      }
      return data2.items;
    }
    async fillQueue(minimalQueueSize, abortSignal) {
      while (!abortSignal?.aborted && this.hasMoreForApi && this.bufferQueue.length < minimalQueueSize) {
        const items = await this.loadMore();
        this.bufferQueue.push(...items);
      }
    }
  }
  class FollowGroupMergeTimelineService {
    constructor(upMids) {
      this.upMids = upMids;
      const enableHeadCache = upMids.length > FollowGroupMergeTimelineService.ENABLE_HEAD_CACHE_UPMID_COUNT_THRESHOLD;
      this.upServices = upMids.map((upMid) => new FollowGroupUpService(upMid, enableHeadCache));
    }
static ENABLE_MERGE_TIMELINE_UPMID_COUNT_THRESHOLD = 20;
static ENABLE_HEAD_CACHE_UPMID_COUNT_THRESHOLD = 10;
    upServices = [];
    get hasMore() {
      return this.upServices.some((s2) => s2.hasMore);
    }
    async loadMore(abortSignal) {
      if (!this.hasMore) return [];
      const refillQueues = async () => {
        const minimalQueueSize = 1;
        await pmap(this.upServices, (s2) => s2.fillQueue(minimalQueueSize, abortSignal), 5);
      };
      const pickedItems = [];
      const expectSize = 10;
      while (this.hasMore && pickedItems.length < expectSize) {
        await refillQueues();
        const restServices = this.upServices.filter((s2) => s2.hasMore);
        const pickedService = orderBy(restServices.map((service) => {
          const item = service.bufferQueue[0];
          const id = BigInt(item.id_str);
          return {
            service,
            item,
            id
          };
        }), ["id"], ["desc"]).map((x) => x.service)[0];
        if (!pickedService) break;
        const head = pickedService.bufferQueue[0];
        pickedService.bufferQueue = pickedService.bufferQueue.slice(1);
        pickedItems.push(head);
      }
      return pickedItems;
    }
  }
  function supportAvif() {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(true);
      img.onerror = (err) => resolve(false);
      img.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";
    });
  }
  const shouldUseAvif = !isSafari && await( supportAvif());
  function getAvatarSrc(avatar) {
    const suffix = shouldUseAvif ? ".avif" : ".webp";
    return `${avatar}@96w_96h_1c_1s_!web-avatar${suffix}`;
  }
  function preloadImg(src) {
    return new Promise((resolve) => {
      const img = new Image();
      img.src = src;
      img.onload = () => resolve(true);
      img.onerror = () => resolve(false);
    });
  }
  function usePopoverRelated({
    externalSearchInput,
    onRefresh,
    getPopupContainer
  }) {
    const {
      upMid,
      dynamicFeedVideoType,
      filterMinDuration,
      searchText,
      hideChargeOnlyVideos
    } = useSnapshot(dfStore);
    const searchInput = jsx$1(
      antd.Input.Search,
      {
        style: {
          width: externalSearchInput ? "250px" : void 0
        },
        placeholder: "按标题关键字过滤",
        type: "search",
        autoCorrect: "off",
        autoCapitalize: "off",
        name: `searchText_${upMid}`,
        variant: "outlined",
        defaultValue: dfStore.searchText,
        autoComplete: "off",
        allowClear: true,
        onChange: (e2) => {
          tryInstantSearchWithCache({
            searchText: e2.target.value,
            upMid,
            onRefresh
          });
        },
        onSearch: async (val) => {
          dfStore.searchText = val || void 0;
          await delay(100);
          onRefresh?.();
        }
      }
    );
    const popoverContent = jsx$1(PopoverContent, { externalSearchInput, searchInput, onRefresh });
    const [popoverOpen, setPopoverOpen] = H.useState(
      false
);
    const onPopoverOpenChange = setPopoverOpen;
    const showPopoverBadge = H.useMemo(() => {
      return !!(dynamicFeedVideoType !== DynamicFeedVideoType.All || hideChargeOnlyVideos || searchText || filterMinDuration !== DynamicFeedVideoMinDuration.All);
    }, [dynamicFeedVideoType, hideChargeOnlyVideos, searchText, filterMinDuration]);
    const popoverTrigger = jsx$1(antd.Popover, { open: popoverOpen, onOpenChange: onPopoverOpenChange, arrow: false, placement: "bottomLeft", getPopupContainer, content: popoverContent, styles: {
      body: {
        border: `1px solid ${usePopoverBorderColor()}`
      }
    }, children: jsx$1(antd.Badge, { dot: showPopoverBadge, color: primaryColorValue, offset: [-5, 5], children: jsx$1(antd.Button, { className: "icon-only-round-button", css: popoverOpen && buttonOpenCss, children: jsx$1(IconForPopoverTrigger, { className: "ml-1px" }) }) }) });
    return {
      searchInput,
      popoverContent,
      popoverTrigger
    };
  }
  const classes = {
    wrapper: "max-w-350px",
    section: "mt-10px first:mt-0px min-w-300px",
    sectionTilte: "flex items-center text-20px pl-2px pb-2px",
    sectionContent: "flex flex-col items-start gap-x-10px gap-y-6px"
  };
  function PopoverContent({
    externalSearchInput,
    searchInput,
    onRefresh
  }) {
    const {
      viewingSomeUp,
      selectedGroup,
      viewingSomeGroup,
      selectedKey,
      dynamicFeedVideoType,
      filterMinDuration,
      hideChargeOnlyVideos,
      addSeparators,
      searchText
    } = useSnapshot(dfStore);
    let linkToReflectSearchTextEl;
    {
      const show = SHOW_DYNAMIC_FEED_ONLY && !!searchText;
      const disabled = searchText === QUERY_DYNAMIC_SEARCH_TEXT;
      const {
        href,
        path
      } = H.useMemo(() => {
        const u2 = new URL(location.href);
        if (u2.searchParams.has(DynamicFeedQueryKey.SearchTextFull)) {
          u2.searchParams.set(DynamicFeedQueryKey.SearchTextFull, searchText || "");
        } else if (u2.searchParams.has(DynamicFeedQueryKey.SearchTextShort)) {
          u2.searchParams.set(DynamicFeedQueryKey.SearchTextShort, searchText || "");
        } else {
          u2.searchParams.set(DynamicFeedQueryKey.SearchTextFull, searchText || "");
        }
        return {
          href: u2.href,
          path: `${u2.pathname}?${u2.search}`
        };
      }, [searchText]);
      linkToReflectSearchTextEl = show && jsx$1(AntdTooltip, { title: href, children: jsxs(antd.Button, { disabled, href, children: [
        "转到搜索词为「",
        searchText || "空",
        "」的链接"
      ] }) });
    }
    return jsxs("div", { className: classes.wrapper, children: [
jsxs("div", { className: classes.section, children: [
jsxs("div", { className: classes.sectionTilte, children: [
          "视频类型",
jsxs(HelpInfo, { children: [
            "「",
            DynamicFeedBadgeText.ChargeOnly,
            "」在此程序中归类为「投稿视频」",
jsx$1("br", {}),
            "「动态视频」时长通常较短"
          ] })
        ] }),
jsx$1("div", { children: jsx$1(antd.Radio.Group, { buttonStyle: "solid", value: dynamicFeedVideoType, onChange: async (v) => {
          dfStore.dynamicFeedVideoType = v.target.value;
          await delay(100);
          onRefresh?.();
        }, children: Object.values(DynamicFeedVideoType).map((v) => {
          return jsx$1(antd.Radio.Button, { value: v, children: DynamicFeedVideoTypeLabel[v] }, v);
        }) }) })
      ] }),
      dynamicFeedVideoType !== DynamicFeedVideoType.DynamicOnly && jsxs("div", { className: classes.section, children: [
jsx$1("div", { className: classes.sectionTilte, children: "充电专属" }),
jsx$1("div", { className: classes.sectionContent, children: jsx$1(antd.Checkbox, { className: "ml-5px", checked: hideChargeOnlyVideos, onChange: async (e2) => {
          const val = e2.target.checked;
          const set2 = dfStore.hideChargeOnlyVideosForKeysSet;
          if (val) {
            set2.add(selectedKey);
          } else {
            set2.delete(selectedKey);
          }
          await delay(100);
          onRefresh?.();
        }, children: jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
          "隐藏「",
          DynamicFeedBadgeText.ChargeOnly,
          "」视频 ",
jsx$1("br", {}),
          "仅对当前 UP 或 分组生效"
        ] }), children: jsxs("span", { style: {
          userSelect: "none"
        }, children: [
          "隐藏「",
          DynamicFeedBadgeText.ChargeOnly,
          "」"
        ] }) }) }) })
      ] }),
jsxs("div", { className: classes.section, children: [
jsx$1("div", { className: classes.sectionTilte, children: "最短时长" }),
jsx$1("div", { children: jsx$1(
          antd.Radio.Group,
          {
            className: "overflow-hidden [&_.ant-radio-button-wrapper]:px-10px",
            buttonStyle: "solid",
            value: filterMinDuration,
            onChange: async (v) => {
              dfStore.filterMinDuration = v.target.value;
              await delay(100);
              onRefresh?.();
            },
            children: Object.values(DynamicFeedVideoMinDuration).map((k) => {
              const {
                label
              } = DynamicFeedVideoMinDurationConfig[k];
              return jsx$1(antd.Radio.Button, { value: k, children: label }, k);
            })
          }
        ) })
      ] }),
      (!externalSearchInput || linkToReflectSearchTextEl) && jsxs("div", { className: classes.section, children: [
jsx$1("div", { className: classes.sectionTilte, children: "搜索" }),
jsxs("div", { className: classes.sectionContent, children: [
          !externalSearchInput && searchInput,
          linkToReflectSearchTextEl
        ] })
      ] }),
jsx$1(SearchCacheRelated, {}),
jsxs("div", { className: classes.section, children: [
jsxs("div", { className: classes.sectionTilte, children: [
          viewingSomeGroup ? "分组" : viewingSomeUp ? "UP" : "全部",
jsxs(HelpInfo, { children: [
            "当前",
            viewingSomeGroup ? "分组" : viewingSomeUp ? "UP" : "范围",
            "的一些操作~"
          ] }),
          viewingSomeGroup && selectedGroup && jsxs("span", { className: "ml-15px inline-flex items-center text-size-14px", children: [
            "(",
jsxs("a", { href: formatFollowGroupUrl(selectedGroup?.tagid || ""), target: "_blank", className: `mx-4px inline-flex items-center text-size-16px ${APP_CLS_USE_ANT_LINK_COLOR}`, children: [
jsx$1(IconForOpenExternalLink, { className: "mr-2px size-18px" }),
              selectedGroup?.name
            ] }),
            ")"
          ] })
        ] }),
jsxs("div", { className: classes.sectionContent, children: [
jsx$1(antd.Checkbox, { checked: addSeparators, onChange: async (v) => {
            dfStore.addSeparatorsMap.set("global", v.target.checked);
            await delay(100);
            onRefresh?.();
          }, children: jsx$1(AntdTooltip, { title: "添加今日/更早分割线", children: "添加分割线" }) }),
          viewingSomeGroup && !!selectedGroup && jsx$1(FollowGroupActions, { followGroup: selectedGroup, onRefresh })
        ] })
      ] })
    ] });
  }
  function SearchCacheRelated() {
    const {
      cacheAllItemsEntry,
      cacheAllItemsUpMids
    } = useSettingsSnapshot().dynamicFeed.__internal;
    const {
      viewingSomeUp,
      upMid,
      upName
    } = useSnapshot(dfStore);
    const $req = useRequest(async (upMid2, upName2) => {
      const {
        notifyOnProgress,
        notifyOnSuccess
      } = createUpdateSearchCacheNotifyFns(upMid2, upName2);
      await updateLocalDynamicFeedCache(upMid2, notifyOnProgress);
      notifyOnSuccess();
    }, {
      manual: true
    });
    const checked = H.useMemo(() => !!upMid && cacheAllItemsUpMids.includes(upMid.toString()), [upMid, cacheAllItemsUpMids]);
    const onChange = H.useCallback(async (e2) => {
      if (!upMid) return;
      const val = e2.target.checked;
      const args = val ? {
        add: [upMid]
      } : {
        remove: [upMid]
      };
      await updateSettingsInnerArray("dynamicFeed.__internal.cacheAllItemsUpMids", args);
    }, []);
    return jsx$1(Fragment, { children: cacheAllItemsEntry && viewingSomeUp && upMid && upName && jsxs("div", { className: classes.section, children: [
jsxs("div", { className: classes.sectionTilte, children: [
        "搜索缓存",
jsxs(HelpInfo, { children: [
          "开启搜索缓存后, 会加载并缓存 UP 所有的动态 ",
jsx$1("br", {}),
          "当本地有缓存且总条数 <= 5000时, 搜索框成为及时搜索, 无需点击搜索按钮"
        ] })
      ] }),
jsxs("div", { className: classes.sectionContent, children: [
jsxs("div", { className: "flex flex-wrap items-center gap-x-10px gap-y-3px", children: [
jsx$1(antd.Checkbox, { className: "inline-flex items-center", checked, onChange, children: jsx$1(AntdTooltip, { title: "只有开启此项, 搜索时才会使用缓存", children: jsxs("span", { children: [
            "为「",
            upName,
            "」开启"
          ] }) }) }),
jsx$1(antd.Button, { loading: $req.loading, onClick: async () => {
            await $req.runAsync(upMid, upName);
          }, children: "更新缓存" })
        ] }),
jsx$1(CheckboxSettingItem, { configPath: "dynamicFeed.advancedSearch", label: "使用高级搜索", tooltip: advancedSearchHelpInfo })
      ] })
    ] }) });
  }
  const tryInstantSearchWithCache = throttle$1(async function({
    searchText,
    upMid,
    onRefresh
  }) {
    if (!upMid) return;
    if (!(searchText || !searchText && dfStore.searchText)) return;
    if (!settings.dynamicFeed.__internal.cacheAllItemsEntry) return;
    if (!settings.dynamicFeed.__internal.cacheAllItemsUpMids.includes(upMid.toString())) return;
    if (!await hasLocalDynamicFeedCache(upMid)) return;
    const info = await infoCache.get(upMid);
    if (!info || !info.count) return;
    if (info.count >= 5e3) return;
    dfStore.searchText = searchText;
    await delay(0);
    onRefresh?.();
  }, 100);
  function FollowGroupMechanismNote() {
    return jsxs(Fragment, { children: [
jsx$1("p", { children: "机制介绍:" }),
jsxs("ul", { children: [
jsxs("li", { className: "flex items-start gap-x-10px", children: [
jsx$1("div", { children: "「从全部过滤」:" }),
jsx$1("div", { children: '基于全部动态 + 分组UP过滤, 速度可能巨慢, 且过滤后的数量取决于B站记录的"全部"动态范围' })
        ] }),
jsxs("li", { className: "flex items-start gap-x-10px", children: [
jsx$1("div", { children: "「拼接时间线」:" }),
jsxs("div", { children: [
            "可以理解为: 去看一遍分组所有 UP 的动态, 然后将它们拼接起来 ",
jsx$1("br", {}),
            "启动慢, 但可以加载所有动态; 且分组 UP 越多, 启动越慢 ",
jsx$1("br", {}),
            "默认分组 UP 数量不超过 ",
            FollowGroupMergeTimelineService.ENABLE_MERGE_TIMELINE_UPMID_COUNT_THRESHOLD,
            " ",
            "时会使用「拼接时间线」 ",
jsx$1("br", {}),
            "详见",
jsx$1("a", { className: "mx-5px", href: "https://magicdawn.fun/2024/12/01/bilibili-gate-dynamic-feed-merge-timeline/", target: "_blank", children: "介绍博客" })
          ] })
        ] })
      ] })
    ] });
  }
  function FollowGroupActions({
    followGroup,
    onRefresh
  }) {
    const {
      whenViewAll
    } = useSnapshot(settings.dynamicFeed);
    const midCount = followGroup.count;
    let forceMergeTimelineCheckbox;
    const forceMergeTimelineHandle = useValueInSettingsCollection(followGroup.tagid, "dynamicFeed.followGroup.forceUseMergeTimelineIds");
    {
      const {
        checked,
        onChange
      } = forceMergeTimelineHandle;
      const disabled = midCount <= FollowGroupMergeTimelineService.ENABLE_MERGE_TIMELINE_UPMID_COUNT_THRESHOLD;
      forceMergeTimelineCheckbox = jsx$1(antd.Checkbox, { checked, onChange: (e2) => {
        onChange(e2);
        onRefresh?.();
      }, disabled, children: jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
jsx$1(FollowGroupMechanismNote, {}),
        disabled && jsxs("p", { className: "text-yellow-400 italic", children: [
          "当前分组 UP 数量: ",
          midCount,
          ", 无需设置"
        ] })
      ] }), children: "分组动态: 强制使用「拼接时间线」" }) });
    }
    let clearMergeTimelineHeadCacheButton;
    {
      const usingMergeTimeline = midCount <= FollowGroupMergeTimelineService.ENABLE_MERGE_TIMELINE_UPMID_COUNT_THRESHOLD || forceMergeTimelineHandle.checked;
      const usingMergeTimelineHeadCache = usingMergeTimeline && midCount > FollowGroupMergeTimelineService.ENABLE_HEAD_CACHE_UPMID_COUNT_THRESHOLD;
      clearMergeTimelineHeadCacheButton = usingMergeTimelineHeadCache && jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
        "当分组 UP 数量",
        " >  ",
        FollowGroupMergeTimelineService.ENABLE_HEAD_CACHE_UPMID_COUNT_THRESHOLD,
        "时, 「拼接时间线」功能会缓存每个 UP 的最新动态5分钟. ",
jsx$1("br", {}),
        "这里可以手动清除缓存"
      ] }), children: jsx$1(antd.Button, { onClick: () => {
        fetchVideoDynamicFeedsWithCache.cache.db.clear();
        antMessage.success("已清除缓存");
      }, children: "清除「拼接时间线」- 队头缓存" }) });
    }
    let addTo_dynamicFeedWhenViewAllHideIds_checkbox;
    {
      const {
        checked,
        onChange
      } = useValueInSettingsCollection(`${DF_SELECTED_KEY_PREFIX_GROUP}${followGroup.tagid}`, "dynamicFeed.whenViewAll.hideIds");
      addTo_dynamicFeedWhenViewAllHideIds_checkbox = whenViewAll.enableHideSomeContents && jsx$1(antd.Checkbox, { checked, onChange, children: jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
        "在「全部」动态中隐藏来自此 ",
        followGroup.name,
        " 的动态"
      ] }), children: "在「全部」动态中隐藏来自此分组的动态" }) });
    }
    return jsxs(Fragment, { children: [
      addTo_dynamicFeedWhenViewAllHideIds_checkbox,
      forceMergeTimelineCheckbox,
      clearMergeTimelineHeadCacheButton
    ] });
  }
  function useValueInSettingsCollection(value, listSettingsPath) {
    const list2 = useSettingsInnerArray(listSettingsPath);
    const checked = H.useMemo(() => list2.includes(value), [list2]);
    const setChecked = useMemoizedFn(async (checked2) => {
      const arg = checked2 ? {
        add: [value]
      } : {
        remove: [value]
      };
      await updateSettingsInnerArray(listSettingsPath, arg);
    });
    const onChange = H.useCallback((e2) => {
      setChecked(e2.target.checked);
    }, []);
    return {
      checked,
      setChecked,
      onChange
    };
  }
  function dynamicFeedFilterSelectUp(payload) {
    Object.assign(dfStore, payload);
    if (payload.upMid) {
      const item = dfStore.upList.find((x) => x.mid.toString() === payload.upMid);
      if (item) item.has_update = false;
    }
  }
  const clearPayload = {
    upMid: void 0,
    upName: void 0,
    upFace: void 0,
    searchText: void 0,
    selectedGroupId: void 0,
    dynamicFeedVideoType: DynamicFeedVideoType.All,
    filterMinDuration: DynamicFeedVideoMinDuration.All
  };
  function DynamicFeedUsageInfo() {
    const {
      ref,
      getPopupContainer
    } = usePopupContainer();
    const onRefresh = useOnRefreshContext();
    const dfSettings = useSettingsSnapshot().dynamicFeed;
    const {
      externalSearchInput
    } = dfSettings.__internal;
    const {
      viewingSomeUp,
      upName,
      upFace,
      upList,
      groups,
      selectedGroup,
      selectedKey
    } = useSnapshot(dfStore);
    useMount(() => {
      updateFilterData();
    });
    const onSelect = useMemoizedFn(async (payload) => {
      dynamicFeedFilterSelectUp(payload);
      await delay(100);
      onRefresh?.();
    });
    const onClear = useMemoizedFn(() => {
      onSelect({
        ...clearPayload
      });
    });
    const menuItems = H.useMemo(() => {
      const itemAll = {
        key: "all",
        icon: jsx$1(antd.Avatar, { size: "small", children: "全" }),
        label: "全部",
        onClick: onClear
      };
      let groupItems = [];
      if (dfSettings.followGroup.enabled) {
        groupItems = groups.map((group) => {
          return {
            key: `group:${group.tagid}`,
            label: `${group.name} (${group.count})`,
            icon: jsx$1(antd.Avatar, { size: "small", children: "组" }),
            onClick() {
              onSelect({
                ...clearPayload,
                selectedGroupId: group.tagid
              });
            }
          };
        });
      }
      const upListSorted = fastSortWithOrders(upList, [{
        prop: (item) => item.has_update ? 1 : 0,
        order: "desc"
      }, {
        prop: (item) => mapNameForSort(item.uname),
        order: localeComparer
      }]);
      const items = upListSorted.map((up) => {
        let avatar = jsx$1(antd.Avatar, { size: "small", src: getAvatarSrc(up.face) });
        if (up.has_update) {
          avatar = jsx$1(antd.Badge, { dot: true, children: avatar });
        }
        return {
          key: `up:${up.mid}`,
          icon: avatar,
label: jsx$1("span", { title: up.uname, className: "block max-w-130px overflow-hidden text-ellipsis whitespace-nowrap", children: up.uname }),
          onClick() {
            onSelect({
              ...clearPayload,
              upMid: up.mid.toString(),
              upName: up.uname,
              upFace: up.face
            });
          }
        };
      });
      return [itemAll, ...groupItems, ...items];
    }, [upList, dfSettings.followGroup.enabled, groups]);
    const followGroupMidsCount = selectedGroup?.count;
    const upIcon = jsx$1(IconForUp, { className: "mt--2px size-14px" });
    const upAvtar = upFace ? jsx$1(antd.Avatar, { size: 20, src: getAvatarSrc(upFace) }) : void 0;
    const dropdownButtonIcon = viewingSomeUp ? upAvtar || upIcon : selectedGroup ? jsx$1(IconForGroup, { className: "size-18px" }) : void 0;
    const dropdownButtonLabel = viewingSomeUp ? upName : selectedGroup ? selectedGroup.name + (followGroupMidsCount ? ` (${followGroupMidsCount})` : "") : "全部";
    const [scopeDropdownOpen, setScopeDropdownOpen] = H.useState(false);
    const scopeDropdownMenu = jsx$1(antd.Dropdown, { open: scopeDropdownOpen, onOpenChange: setScopeDropdownOpen, placement: "bottomLeft", getPopupContainer, menu: {
      items: menuItems,
      style: {
        ...dropdownMenuStyle,
        border: `1px solid ${usePopoverBorderColor()}`
      },
      selectedKeys: [selectedKey]
    }, children: jsx$1(antd.Button, { icon: dropdownButtonIcon, className: "gap-4px", css: [scopeDropdownOpen && buttonOpenCss, "", ""], children: dropdownButtonLabel }) });
    const {
      popoverTrigger,
      searchInput
    } = usePopoverRelated({
      externalSearchInput,
      onRefresh,
      getPopupContainer
    });
    return jsx$1(Fragment, { children: jsxs("div", { ref, className: "inline-flex items-center gap-x-8px", children: [
      scopeDropdownMenu,
      (viewingSomeUp || selectedGroup) && jsxs(antd.Button, { onClick: onClear, className: "gap-0", children: [
jsx$1(IconForReset, { className: "mr-5px size-14px" }),
jsx$1("span", { children: "清除" })
      ] }),
      popoverTrigger,
      externalSearchInput && searchInput,
jsx$1(CopyBvidButtonsUsageInfo, {})
    ] }) });
  }
  function getDynamicFeedServiceConfig(usingDfStore = dfStore) {
    const snap = snapshot(usingDfStore);
    return {

upMid: snap.upMid,
      groupId: snap.selectedGroup?.tagid,
searchText: snap.searchText,
dynamicFeedVideoType: snap.dynamicFeedVideoType,
      hideChargeOnlyVideos: snap.hideChargeOnlyVideos,
filterMinDuration: snap.filterMinDuration,
      filterMinDurationValue: snap.filterMinDurationValue,
selectedKey: snap.selectedKey,
      viewingAll: snap.viewingAll,
      viewingSomeUp: snap.viewingSomeUp,
      viewingSomeGroup: snap.viewingSomeGroup,
      addSeparators: snap.addSeparators,
showLiveInDynamicFeed: settings.dynamicFeed.showLive,
      whenViewAllEnableHideSomeContents: settings.dynamicFeed.whenViewAll.enableHideSomeContents,
      whenViewAllHideIds: new Set(settings.dynamicFeed.whenViewAll.hideIds),
      advancedSearch: settings.dynamicFeed.advancedSearch,
      searchCacheEnabled: !!snap.upMid && settings.dynamicFeed.__internal.cacheAllItemsEntry &&
settings.dynamicFeed.__internal.cacheAllItemsUpMids.includes(snap.upMid.toString()),
forceUseMergeTime: !!snap.selectedGroup && settings.dynamicFeed.followGroup.forceUseMergeTimelineIds.includes(snap.selectedGroup.tagid),
startingOffset: QUERY_DYNAMIC_OFFSET,
      minId: isValidNumber(QUERY_DYNAMIC_MIN_ID) ? BigInt(QUERY_DYNAMIC_MIN_ID) : void 0,
      minTs: isValidNumber(QUERY_DYNAMIC_MIN_TS) ? Number(QUERY_DYNAMIC_MIN_TS) : void 0
    };
  }
  function isValidNumber(str) {
    return !!str && /^\d+$/.test(str);
  }
  const debug$9 = baseDebug.extend("modules:rec-services:dynamic-feed");
  class DynamicFeedRecService extends BaseTabService {
    constructor(config) {
      super(DynamicFeedRecService.PAGE_SIZE);
      this.config = config;
      if (this.config.showLiveInDynamicFeed) {
        const filterEmpty = !this.upMid && typeof this.groupId === "undefined" && !this.searchText && this.dynamicFeedVideoType === DynamicFeedVideoType.All && this.filterMinDuration === DynamicFeedVideoMinDuration.All;
        if (filterEmpty) {
          this.liveRecService = new LiveRecService(true);
        }
      }
      if (this.config.startingOffset) {
        this.offset = this.config.startingOffset;
      }
    }
    static PAGE_SIZE = 15;
    usageInfo = jsx$1(DynamicFeedUsageInfo, {});
    hasMoreExceptQueue = true;
    get hasMore() {
      if (this.qs.bufferQueue.length) return true;
      if (this.liveRecService?.hasMore) return true;
      if (this.viewingSomeGroup && this.groupMergeTimelineService) {
        return this.groupMergeTimelineService.hasMore;
      }
      if (this.hasMoreExceptQueue) return true;
      return false;
    }
    async shouldReduceMinCount() {
      if (this.viewingAll) ;
      if (this.viewingSomeGroup) {
        await this.loadGroupMids();
        return !this.groupMergeTimelineService;
      }
      if (this.searchText || this.dynamicFeedVideoType === DynamicFeedVideoType.DynamicOnly || this.filterMinDuration !== DynamicFeedVideoMinDuration.All) {
        return true;
      }
      return false;
    }
    offset = "";
    page = 0;
liveRecService;
get upMid() {
      return this.config.upMid;
    }
get groupId() {
      return this.config.groupId;
    }
    get searchText() {
      return this.config.searchText;
    }
    get dynamicFeedVideoType() {
      return this.config.dynamicFeedVideoType;
    }
    get hideChargeOnlyVideos() {
      return this.config.hideChargeOnlyVideos;
    }
    get filterMinDuration() {
      return this.config.filterMinDuration;
    }
    get filterMinDurationValue() {
      return this.config.filterMinDurationValue;
    }
    get viewingSomeUp() {
      return this.config.viewingSomeUp;
    }
get viewingSomeGroup() {
      return this.config.viewingSomeGroup;
    }
    shouldEnableMergeTimeline(midCount) {
      return this.config.forceUseMergeTime || midCount > 0 && midCount <= FollowGroupMergeTimelineService.ENABLE_MERGE_TIMELINE_UPMID_COUNT_THRESHOLD;
    }
    groupMergeTimelineService;
    groupMids = new Set();
    groupMidsLoaded = false;
    async loadGroupMids() {
      if (typeof this.groupId !== "number") return;
      if (this.groupMidsLoaded) return;
      try {
        const mids2 = await getFollowGroupContent(this.groupId);
        this.groupMids = new Set(mids2);
        if (this.shouldEnableMergeTimeline(mids2.length)) {
          this.groupMergeTimelineService = new FollowGroupMergeTimelineService(mids2.map((x) => x.toString()));
        }
      } finally {
        this.groupMidsLoaded = true;
      }
    }
get viewingAll() {
      return this.config.viewingAll;
    }
    whenViewAllHideMids = new Set();
    whenViewAllHideMidsLoaded = false;
    async loadWhenViewAllHideMids() {
      if (!this.viewingAll) return;
      if (!this.config.whenViewAllEnableHideSomeContents) return;
      if (!this.config.whenViewAllHideIds.size) return;
      if (this.whenViewAllHideMidsLoaded) return;
      const mids2 = Array.from(this.config.whenViewAllHideIds).filter((x) => x.startsWith(DF_SELECTED_KEY_PREFIX_UP)).map((x) => x.slice(DF_SELECTED_KEY_PREFIX_UP.length));
      const groupIds = Array.from(this.config.whenViewAllHideIds).filter((x) => x.startsWith(DF_SELECTED_KEY_PREFIX_GROUP)).map((x) => x.slice(DF_SELECTED_KEY_PREFIX_GROUP.length));
      const set2 = this.whenViewAllHideMids;
      mids2.forEach((x) => set2.add(x));
      const midsInGroup = (await pmap(groupIds, (id) => getFollowGroupContent(id), 3)).flat();
      midsInGroup.forEach((x) => set2.add(x.toString()));
      this.whenViewAllHideMidsLoaded = true;
    }
    async fetchMore(abortSignal) {
      const items = await this._fetchMore(abortSignal);
      return this.handleAddSeparators(items);
    }
    _queueForSearchCache;
    async _fetchMore(abortSignal) {
      if (this.liveRecService?.hasMore) {
        const items2 = await this.liveRecService.loadMore(abortSignal) || [];
        return items2.filter((x) => x.api !== EApiType.Separator);
      }
      let rawItems;
      if (this.viewingSomeGroup) {
        await this.loadGroupMids();
      }
      if (this.viewingAll) {
        await this.loadWhenViewAllHideMids();
        debug$9("viewingAll: hide-mids = %o", this.whenViewAllHideMids);
      }
      const useSearchCache = !!(this.upMid && this.searchText && this.config.searchCacheEnabled && await hasLocalDynamicFeedCache(this.upMid));
      const useAdvancedSearch = useSearchCache && this.config.advancedSearch;
      const useAdvancedSearchParsed = useAdvancedSearch ? parseSearchInput((this.searchText || "").toLowerCase()) : void 0;
      if (useSearchCache) {
        if (!this._queueForSearchCache) {
          await performIncrementalUpdateIfNeed(this.upMid);
          this._queueForSearchCache = new QueueStrategy(20);
          this._queueForSearchCache.bufferQueue = (await cache.get(this.upMid) || []).filter((x) => {
            const title = x?.modules?.module_dynamic?.major?.archive?.title || "";
            return filterBySearchText({
              searchText: this.searchText,
              title,
              useAdvancedSearch,
              useAdvancedSearchParsed
            });
          });
        }
        rawItems = this._queueForSearchCache.sliceFromQueue(this.page + 1) || [];
        this.page++;
        this.hasMoreExceptQueue = !!this._queueForSearchCache.bufferQueue.length;
      } else if (this.viewingSomeGroup && this.groupMergeTimelineService) {
        rawItems = await this.groupMergeTimelineService.loadMore(abortSignal);
      } else {
        const data2 = await fetchVideoDynamicFeeds({
          abortSignal,
          page: this.page + 1,
offset: this.offset,
          upMid: this.upMid
        });
        this.page++;
        this.hasMoreExceptQueue = data2.has_more;
        this.offset = data2.offset;
        rawItems = data2.items;
        if (this.config.minId) {
          const minId = this.config.minId;
          const idx = rawItems.findIndex((x) => BigInt(x.id_str) <= minId);
          if (idx !== -1) {
            this.hasMoreExceptQueue = false;
            rawItems = rawItems.slice(0, idx + 1);
          }
        }
        if (this.config.minTs) {
          const minTs = this.config.minTs;
          const idx = rawItems.findIndex((x) => x.modules.module_author.pub_ts <= minTs);
          if (idx !== -1) {
            this.hasMoreExceptQueue = false;
            rawItems = rawItems.slice(0, idx + 1);
          }
        }
      }
      const items = rawItems.filter((x) => {
        if (!this.viewingSomeGroup) return true;
        if (!this.groupMids.size) return true;
        const mid = x?.modules?.module_author?.mid;
        if (!mid) return true;
        return this.groupMids.has(mid);
      }).filter((x) => {
        if (this.dynamicFeedVideoType === DynamicFeedVideoType.All) return true;
        const currentLabel = x.modules.module_dynamic.major.archive.badge.text;
        if (this.dynamicFeedVideoType === DynamicFeedVideoType.DynamicOnly) {
          return currentLabel === DynamicFeedBadgeText.Dynamic;
        }
        if (this.dynamicFeedVideoType === DynamicFeedVideoType.UploadOnly) {
          return currentLabel === DynamicFeedBadgeText.Upload || currentLabel === DynamicFeedBadgeText.ChargeOnly;
        }
        return false;
      }).filter((x) => {
        if (!this.hideChargeOnlyVideos) return true;
        const chargeOnly = x.modules?.module_dynamic?.major?.archive?.badge?.text === DynamicFeedBadgeText.ChargeOnly;
        return !chargeOnly;
      }).filter((x) => {
        if (this.filterMinDuration === DynamicFeedVideoMinDuration.All) return true;
        const v = x.modules.module_dynamic.major.archive;
        const duration2 = parseDuration(v.duration_text);
        return duration2 >= this.filterMinDurationValue;
      }).filter((x) => {
        if (!this.searchText) return true;
        const title = x?.modules?.module_dynamic?.major?.archive?.title || "";
        return filterBySearchText({
          searchText: this.searchText,
          title,
          useAdvancedSearch,
          useAdvancedSearchParsed
        });
      }).filter((x) => {
        if (this.config.selectedKey !== DF_SELECTED_KEY_ALL) return true;
        const set2 = this.whenViewAllHideMids;
        if (!set2.size) return true;
        const mid = x?.modules?.module_author?.mid;
        if (!mid) return true;
        return !set2.has(mid.toString());
      }).map((item) => {
        return {
          ...item,
          api: EApiType.DynamicFeed,
          uniqId: `${EApiType.DynamicFeed}-${item.id_str || crypto.randomUUID()}`
        };
      });
      function filterBySearchText({
        title,
        searchText,
        useAdvancedSearch: useAdvancedSearch2,
        useAdvancedSearchParsed: useAdvancedSearchParsed2
      }) {
        title = title.toLowerCase();
        searchText = searchText.toLowerCase();
        const simpleSearch = () => title.includes(searchText);
        const advancedSearch = () => {
          return (useAdvancedSearchParsed2?.includes ?? []).every((x) => title.includes(x)) && (useAdvancedSearchParsed2?.excludes ?? []).every((x) => !title.includes(x));
        };
        return useAdvancedSearch2 ? advancedSearch() : simpleSearch();
      }
      const {
        upMid,
        upName
      } = dfStore;
      if (
QUERY_DYNAMIC_UP_MID && upMid && upName && upName === upMid.toString() && items[0]
      ) {
        const authorName = items[0].modules.module_author.name;
        const authorFace = items[0].modules.module_author.face;
        dfStore.upName = authorName;
        dfStore.upFace = authorFace;
      }
      if (this.viewingSomeGroup && dfStore.groups.length) {
        const group = dfStore.groups.find((x) => x.tagid === this.groupId);
        if (group) group.count = this.groupMids.size;
      }
      return items;
    }
    separatorsConfig = (() => {
      return {
        today: {
          added: false,
          content: "今日",
          getInsertIndex: getTodaySeparatorInsertIndex
        },
        earlier: {
          added: false,
          content: "更早",
          getInsertIndex: insertIndexFinderViaPubTsRange(-Infinity, dayjs().startOf("day").unix())
        }
      };
    })();
    handleAddSeparators(items) {
      if (!this.config.addSeparators) return items;
      const ret = items;
      {
        const config = this.separatorsConfig.today;
        const {
          getInsertIndex,
          content,
          added
        } = config;
        if (!added) {
          const idx = getInsertIndex(items);
          if (idx !== -1) {
            ret.splice(idx, 0, {
              api: EApiType.Separator,
              uniqId: `dynamic-feed-separator-today`,
              content
            });
            config.added = true;
          }
        }
      }
      {
        const config = this.separatorsConfig.earlier;
        const {
          getInsertIndex,
          content,
          added
        } = config;
        if (!added) {
          const idx = getInsertIndex(items);
          if (idx !== -1) {
            ret.splice(idx, 0, {
              api: EApiType.Separator,
              uniqId: "dynamic-feed-separator-earlier",
              content
            });
            config.added = true;
          }
        }
      }
      return ret;
    }
  }
  function insertIndexFinderViaPubTsRange(lower, upper) {
    return (items) => {
      return items.findIndex((x) => {
        if (x.api !== EApiType.DynamicFeed) return false;
        const pubTs = x.modules.module_author.pub_ts;
        return pubTs >= lower && pubTs < upper;
      });
    };
  }
  function getTodaySeparatorInsertIndex(items) {
    const index = items.findIndex((x) => x.api === EApiType.Live && x.live_status === ELiveStatus.Streaming);
    if (index !== -1) return index;
    const todayInsertIndexFinder = insertIndexFinderViaPubTsRange(dayjs().startOf("day").unix(), dayjs().endOf("day").unix());
    return todayInsertIndexFinder(items);
  }
  const FAV_PAGE_SIZE = 20;
  const clsFavSeparator = "ml-30px inline-flex items-center text-15px [&_svg]:mr-5px [&_svg]:mt--1px first:ml-0";
  function formatFavFolderUrl(id, ctype = 21) {
    return `https://space.bilibili.com/${getUid()}/favlist?fid=${id}&ftype=create`;
  }
  function formatFavCollectionUrl(id, ctype = 21) {
    return `https://space.bilibili.com/${getUid()}/favlist?fid=${id}&ftype=collect&ctype=${ctype}`;
  }
  function formatFavPlaylistUrl(id) {
    return `https://www.bilibili.com/list/ml${id}`;
  }
  function formatBvidUrl(bvid) {
    return `https://www.bilibili.com/video/${bvid}`;
  }
  class FavCollectionService {
    constructor(collectionId, addSeparator, itemsOrder) {
      this.collectionId = collectionId;
      this.addSeparator = addSeparator;
      this.itemsOrder = itemsOrder;
    }
    get hasMore() {
      if (this.addSeparator && !this.separatorAdded) return true;
      if (!this.loaded) return true;
      return !!this.bufferQueue.length;
    }
loaded = false;
    bufferQueue = [];
    separatorAdded = false;
    get separator() {
      return {
        api: EApiType.Separator,
        uniqId: `fav-collection-separator-${this.collectionId}`,
        content: jsx$1(FavCollectionSeparator, { service: this })
      };
    }
state = proxy({
      firstBvid: void 0,
      info: void 0
    });
    async loadMore(abortSignal) {
      if (!this.hasMore) return;
      if (this.addSeparator && !this.separatorAdded) {
        this.separatorAdded = true;
        return [this.separator];
      }
      if (!this.loaded) {
        const data2 = await fetchCollectionDetail(this.collectionId, 1);
        const medias = data2?.medias || [];
        const info = data2?.info;
        await attemptAsync(() => this.loadUserAvatarFromSpaceAccInfo(medias, abortSignal));
        let items = medias.map((x) => {
          return {
            ...x,
            api: EApiType.Fav,
            uniqId: `${EApiType.Fav}-collection:${this.collectionId}-${x.bvid}`,
            collection: data2.info,
            from: "fav-collection"
          };
        });
        items = handleItemsOrder(items, this.itemsOrder);
        items.forEach((item, index, arr) => {
          item.vol = arr.length - index;
        });
        this.bufferQueue = items;
        this.loaded = true;
        this.state.firstBvid = items[0]?.bvid;
        this.state.info = cloneDeep(info);
        favStore.selectedFavCollectionDetailInfo = cloneDeep(info);
      }
      if (this.itemsOrder === FavItemsOrder.Shuffle) {
        this.bufferQueue = shuffle(this.bufferQueue);
      }
      let sliced;
      [sliced, this.bufferQueue] = [this.bufferQueue.slice(0, FAV_PAGE_SIZE), this.bufferQueue.slice(FAV_PAGE_SIZE)];
      return sliced;
    }
async loadUserAvatarFromSpaceAccInfo(items, abortSignal) {
      if (!items.length) return;
      const midsCount = countBy(items, (x) => x.upper.mid);
      const list2 = Object.entries(midsCount).map(([mid, count]) => ({
        mid,
        count
      }));
      const topMids = orderBy(list2, [(x) => x.count], ["desc"]).slice(0, 3).map((x) => x.mid);
      await Promise.all(topMids.map(async (mid) => {
        if (abortSignal?.aborted) return;
        const info = await getSpaceAccInfo(mid);
        const face = info?.face;
        if (face) {
          items.filter((x) => x.upper.mid.toString() === mid).forEach((x) => {
            x.upper.face ||= face;
          });
        }
      }));
    }
    get extraUsageInfo() {
      return jsx$1(FavItemsOrderSwitcher, {});
    }
  }
  function FavCollectionSeparator({
    service
  }) {
    const {
      firstBvid,
      info
    } = useSnapshot(service.state);
    return jsxs(Fragment, { children: [
jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
        "UP: ",
        info?.upper.name,
        " ",
jsx$1("br", {}),
        info?.intro || "简介: N/A"
      ] }), children: jsxs(CustomTargetLink, { href: formatFavCollectionUrl(service.collectionId), className: clsFavSeparator, children: [
jsx$1(IconForOpenExternalLink, { className: "size-16px" }),
        info?.title
      ] }) }),
      firstBvid && jsxs(CustomTargetLink, { href: formatBvidUrl(firstBvid), className: clsFavSeparator, children: [
jsx$1(IconForPlayer, { className: "size-16px" }),
        "播放全部"
      ] })
    ] });
  }
  function FavFolderSeparator({
    service
  }) {
    return jsxs(Fragment, { children: [
jsxs(CustomTargetLink, { href: formatFavFolderUrl(service.entry.id, service.entry.attr), className: clsFavSeparator, children: [
jsx$1(IconForOpenExternalLink, { className: "size-16px" }),
        service.entry.title
      ] }),
jsxs(CustomTargetLink, { href: formatFavPlaylistUrl(service.entry.id), className: clsFavSeparator, children: [
jsx$1(IconForPlayer, { className: "size-16px" }),
        "播放全部"
      ] })
    ] });
  }
  const FAV_FOLDER_API_SUPPOETED_ORDER = [FavItemsOrder.FavTimeDesc, FavItemsOrder.PlayCountDesc, FavItemsOrder.PubTimeDesc];
  function isFavFolderApiSuppoetedOrder(order) {
    return FAV_FOLDER_API_SUPPOETED_ORDER.includes(order);
  }
  const favFolderAllItemsCache = getIdbCache("fav-folder-all-items");
  async function clearFavFolderAllItemsCache(folderId) {
    await favFolderAllItemsCache.delete(folderId);
  }
  class FavFolderService {
    constructor(folderId, addSeparator, itemsOrder) {
      this.folderId = folderId;
      this.addSeparator = addSeparator;
      this.itemsOrder = itemsOrder;
      if (this.itemsOrder === FavItemsOrder.Initial) {
        throw new Error("this should not happen!");
      }
      if (isFavFolderApiSuppoetedOrder(this.itemsOrder)) {
        this.needLoadAll = false;
      } else {
        this.needLoadAll = true;
      }
    }
    needLoadAll;
    get hasMore() {
      if (this.addSeparator && !this.separatorAdded) return true;
      if (this.needLoadAll) {
        if (!this.allItemsLoaded) return true;
        return !!this.bufferQueue.length;
      } else {
        if (!this.innerService) return true;
        return this.innerService.hasMore;
      }
    }
    separatorAdded = false;
    get separator() {
      this.assertInnerService();
      return {
        api: EApiType.Separator,
        uniqId: `fav-folder-separator-${this.folderId}`,
        content: jsx$1(FavFolderSeparator, { service: this.innerService })
      };
    }
    entry;
    innerService;
assertInnerService() {
      invariant(this.innerService, "this.innerService should not be undefined");
      invariant(this.entry, "this.entry should not be undefined");
    }
    async createService() {
      if (this.innerService) return;
      await updateFavList();
      const entry = snapshot(favStore.folders).find((f2) => f2.id === this.folderId);
      invariant(entry, `favStore.favFolders should have this entry[fid=${this.folderId}]`);
      this.entry = entry;
      if (isFavFolderApiSuppoetedOrder(this.itemsOrder)) {
        this.innerService = new FavFolderBasicService(entry, this.itemsOrder);
      } else {
        this.innerService = new FavFolderBasicService(entry);
      }
    }
    async loadMore(abortSignal) {
      if (!this.innerService) await this.createService();
      if (!this.hasMore) return;
      if (this.addSeparator && !this.separatorAdded) {
        this.separatorAdded = true;
        return [this.separator];
      }
      if (this.needLoadAll) {
        if (!this.allItemsLoaded) await this.loadAllItems(abortSignal);
        if (this.itemsOrder === FavItemsOrder.Shuffle) {
          this.bufferQueue = shuffle(this.bufferQueue);
        }
        const sliced = this.bufferQueue.slice(0, FAV_PAGE_SIZE);
        this.bufferQueue = this.bufferQueue.slice(FAV_PAGE_SIZE);
        return sliced;
      } else {
        const ret = await this.innerService?.loadMore(abortSignal);
        this.runSideEffects();
        return ret;
      }
    }
    allItemsLoaded = false;
    bufferQueue = [];
    async loadAllItems(abortSignal) {
      const allItems = await this.fetchAllItems(abortSignal);
      this.bufferQueue = handleItemsOrder(allItems, this.itemsOrder);
      this.allItemsLoaded = true;
      this.runSideEffects();
    }
    _fetchAllItems = async (abortSignal) => {
      this.assertInnerService();
      const allItems = [];
      while (this.innerService.hasMore && !abortSignal.aborted) {
        const items = await this.innerService.loadMore(abortSignal) || [];
        allItems.push(...items);
      }
      return allItems;
    };
_fetchAllItemsWithCache = wrapWithIdbCache({
      fn: this._fetchAllItems,
      tableName: favFolderAllItemsCache,
      generateKey: () => `${this.folderId}`,
      ttl: ms("5min")
    });
    fetchAllItems = (abortSignal) => {
      this.assertInnerService();
      const shouldUseCache = this.entry.media_count > FavFolderBasicService.PAGE_SIZE * 3;
      return shouldUseCache ? this._fetchAllItemsWithCache(abortSignal) : this._fetchAllItems(abortSignal);
    };
    runSideEffects() {
      this.assertInnerService();
      if (typeof this.innerService.info?.media_count === "number") {
        updateFavFolderMediaCount(this.folderId, this.innerService.info.media_count);
      }
    }
    get extraUsageInfo() {
      return jsx$1(FavItemsOrderSwitcher, {});
    }
  }
  class FavFolderBasicService {
    constructor(entry, itemsOrder = FavItemsOrder.FavTimeDesc) {
      this.entry = entry;
      this.itemsOrder = itemsOrder;
      this.hasMore = entry.media_count > 0;
    }
    static PAGE_SIZE = 20;
    hasMore;
    info;
    page = 0;
async loadMore(abortSignal) {
      if (!this.hasMore) return;
      const order = {
        [FavItemsOrder.FavTimeDesc]: "mtime",
        [FavItemsOrder.PlayCountDesc]: "view",
        [FavItemsOrder.PubTimeDesc]: "pubtime"
      }[this.itemsOrder];
      const res = await request.get("/x/v3/fav/resource/list", {
        params: {
          media_id: this.entry.id,
          pn: this.page + 1,
ps: FavFolderBasicService.PAGE_SIZE,
          keyword: "",
          order,
type: "0",
tid: "0",
platform: "web"
        }
      });
      const json = res.data;
      if (!isWebApiSuccess(json)) {
        toast(json.message || REQUEST_FAIL_MSG);
        return;
      }
      this.page++;
      this.hasMore = json.data.has_more;
      this.info = json.data.info;
      let items = json.data.medias || [];
      items = items.filter((item) => {
        if (item.title === "已失效视频") return false;
        return true;
      });
      return items.map((item) => {
        return {
          ...item,
          from: "fav-folder",
          folder: this.info,
          api: EApiType.Fav,
          uniqId: `${EApiType.Fav}-folder:${this.info?.id || this.entry.id}-${item.bvid}`
        };
      });
    }
  }
  class FavAllService {
    constructor(addSeparator, itemsOrder, excludedFolderIds) {
      this.addSeparator = addSeparator;
      this.itemsOrder = itemsOrder;
      this.excludedFolderIds = excludedFolderIds;
      if (![FavItemsOrder.Initial, FavItemsOrder.Shuffle].includes(this.itemsOrder)) {
        throw new Error("invalid items order");
      }
    }
    get useShuffle() {
      return this.itemsOrder === FavItemsOrder.Shuffle;
    }
    shuffleBufferQueue = [];
    get hasMoreInService() {
      if (!this.serviceCreated) return true;
      return this.allServices.some((s2) => s2.hasMore);
    }
    get hasMore() {
      if (this.useShuffle) {
        return !!this.shuffleBufferQueue.length || this.hasMoreInService;
      } else {
        return this.hasMoreInService;
      }
    }
    get extraUsageInfo() {
      return jsxs(Fragment, { children: [
jsx$1(FavItemsOrderSwitcher, {}),
jsx$1(ViewingAllExcludeFolderConfig, { allFavFolderServices: this.allFolderServices, state: this.state })
      ] });
    }
    async loadMore(abortSignal) {
      if (!this.serviceCreated) await this.createServices();
      if (!this.hasMore) return;
      if (!this.useShuffle) {
        const service = this.allServices.find((s2) => s2.hasMore);
        return service?.loadMore(abortSignal);
      }
      if (this.shuffleBufferQueue.length < FAV_PAGE_SIZE) {
        const count = 6;
        const batch = 2;
        while (this.hasMoreInService && this.shuffleBufferQueue.length < FAV_PAGE_SIZE * 3) {
          const restServices = this.allServices.filter((s2) => s2.hasMore);
          const pickedServices = shuffle(restServices).slice(0, count);
          const fetched = (await pmap(pickedServices, async (s2) => await s2.loadMore(abortSignal) || [], batch)).flat().filter((x) => x.api !== EApiType.Separator);
          this.shuffleBufferQueue = shuffle([...this.shuffleBufferQueue, ...shuffle(fetched)]);
        }
      }
      const sliced = this.shuffleBufferQueue.slice(0, FAV_PAGE_SIZE);
      this.shuffleBufferQueue = this.shuffleBufferQueue.slice(FAV_PAGE_SIZE);
      return sliced;
    }
allFolderServices = [];
state = proxy({
      totalCountInFavFolders: 0
    });
    serviceCreated = false;
    allServices = [];
    async createServices() {
      await updateFavList();
      const {
        folders,
        collections
      } = cloneDeep(snapshot(favStore));
      this.allFolderServices = folders.map((f2) => new FavFolderBasicService(f2));
      this.state.totalCountInFavFolders = folders.filter((f2) => !this.excludedFolderIds.includes(f2.id.toString())).reduce((count, f2) => count + f2.media_count, 0);
      {
        const _folders = folders.filter((f2) => !this.excludedFolderIds.includes(f2.id.toString()));
        let itemsOrder = this.itemsOrder;
        if (itemsOrder === FavItemsOrder.Initial) itemsOrder = FavItemsOrder.FavTimeDesc;
        this.allServices.push(..._folders.map((f2) => new FavFolderService(f2.id, this.addSeparator, itemsOrder)));
      }
      {
        this.allServices.push(...collections.map((c2) => new FavCollectionService(c2.id, this.addSeparator, this.itemsOrder)));
      }
      this.serviceCreated = true;
    }
  }
  function getFavServiceConfig() {
    const snap = snapshot(favStore);
    return {
      selectedKey: snap.selectedKey,
      itemsOrder: getSavedOrder(snap.selectedKey, snap.savedOrderMap),
      selectedFavFolderId: snap.selectedFavFolderId,
      selectedFavCollectionId: snap.selectedFavCollectionId,
addSeparator: settings.fav.addSeparator,
      excludedFolderIds: settings.fav.excludedFolderIds
    };
  }
  function getFavServiceConfigExtra(config) {
    const ret = {
      ...config,
      get viewingAll() {
        return config.selectedKey === "all";
      },
      get viewingSomeFolder() {
        return typeof config.selectedFavFolderId === "number";
      },
      get viewingSomeCollection() {
        return typeof config.selectedFavCollectionId === "number";
      }
    };
    return ret;
  }
  class FavRecService extends BaseTabService {
    static PAGE_SIZE = FAV_PAGE_SIZE;
    config;
    innerService;
    constructor(config) {
      super(FavRecService.PAGE_SIZE);
      this.config = getFavServiceConfigExtra(config);
      const {
        viewingAll,
        viewingSomeFolder,
        viewingSomeCollection
      } = this.config;
      if (viewingAll) {
        this.innerService = new FavAllService(this.config.addSeparator, this.config.itemsOrder, this.config.excludedFolderIds);
      } else if (viewingSomeFolder) {
        this.innerService = new FavFolderService(this.config.selectedFavFolderId, this.config.addSeparator, this.config.itemsOrder);
      } else if (viewingSomeCollection) {
        this.innerService = new FavCollectionService(this.config.selectedFavCollectionId, this.config.addSeparator, this.config.itemsOrder);
      } else {
        throw new Error("unexpected case!");
      }
    }
    get usageInfo() {
      const {
        usageInfo,
        extraUsageInfo
      } = this.innerService;
      if (usageInfo) return usageInfo;
      return jsx$1(FavUsageInfo, { extraContent: extraUsageInfo });
    }
    get hasMoreExceptQueue() {
      return this.innerService.hasMore;
    }
    fetchMore(abortSignal) {
      return this.innerService.loadMore(abortSignal);
    }
decreaseTotal() {
      if (this.config.viewingAll) {
        this.innerService.state.totalCountInFavFolders -= 1;
      } else if (this.config.viewingSomeFolder && this.config.selectedFavFolderId) {
        updateFavFolderMediaCount(this.config.selectedFavFolderId, (x) => x - 1);
      } else if (this.config.viewingSomeCollection && this.config.selectedFavCollectionId) ;
    }
  }
  async function fetchWatchlaterItems({
    asc = false,
    searchText = "",
    abortSignal,
    extraParams
  } = {}) {
    const res = await request.get("/x/v2/history/toview/web", {
      signal: abortSignal,
      params: await encWbi({
        asc,
        key: searchText,
        viewed: 0,
web_location: 333.881,
        ...extraParams
      })
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      appWarn("getAllWatchlaterItems error %s, fulljson %o", json.message, json);
      return {
        err: json.message
      };
    }
    return {
      total: json.data.count,
      items: filterOutApiReturnedRecent(json.data.list || [])
    };
  }
  function filterOutApiReturnedRecent(items) {
    return items.filter((item) => !(item.title === "以下为更早添加的视频" && item.aid === 0 && item.bvid === "" && item.add_at === 0));
  }
  async function batchRemoveWatchlater(avids) {
    const form = new FormData();
    form.append("resources", avids.join(","));
    form.append("csrf", getCsrfToken());
    const params = await encWbi({});
    const res = await request.post("/x/v2/history/toview/v2/dels", form, {
      params
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      toast(json?.message || "出错了");
      return false;
    }
    return true;
  }
  const store$2 = proxy({
    searchText: void 0
  });
  function WatchlaterUsageInfo({
    service
  }) {
    const {
      watchlaterAddSeparator,
      watchlaterItemsOrder,
      watchlaterUseNormalVideoUrl
    } = useSettingsSnapshot();
    const onRefresh = useOnRefreshContext();
    const {
      searchText
    } = useSnapshot(store$2, {
      sync: true
    });
    const multiSelecting = useMultiSelecting();
    useUpdateEffect(() => {
      void (async () => {
        await delay(100);
        onRefresh?.();
      })();
    }, [watchlaterAddSeparator, watchlaterItemsOrder, watchlaterUseNormalVideoUrl]);
    const {
      total
    } = useSnapshot(service.state);
    const title = searchText ? `共 ${total} 条搜索结果` : `共 ${total} 个视频`;
    const totalTag = typeof total === "number" && jsx$1(antd.Tag, { color: "success", style: {
      marginRight: 0,
      marginTop: 1,
      cursor: "pointer"
    }, title, onClick: () => {
      toast(`稍后再看: ${title}`);
    }, children: total });
    return jsxs("div", { className: "flex items-center gap-x-12px", children: [
jsx$1(WatchlaterOrderSwitcher, {}),
jsx$1(antd.Input.Search, { allowClear: true, placeholder: "搜索稍后再看", style: {
        width: 180
      }, value: searchText, onChange: (e2) => store$2.searchText = e2.target.value, onSearch: (val) => {
        store$2.searchText = val;
        onRefresh?.();
      } }),
      totalTag,
      multiSelecting && jsx$1(AntdTooltip, { arrow: false, title: "移除稍后再看 (多选)", children: jsx$1(antd.Button, { className: "icon-only-round-button", onClick: removeMultiSelectedWatchlaterItems, children: jsx$1(IconForRemove, {}) }) }),
jsx$1(CopyBvidButtonsUsageInfo, {})
    ] });
  }
  const WatchlaterItemsOrderConfig = {
    [WatchlaterItemsOrder.AddTimeDesc]: {
      icon: jsx$1(IconForTimestamp, {}),
      label: withDescIcon("最近添加"),
      helpInfo: "按添加时间倒序"
    },
    [WatchlaterItemsOrder.AddTimeAsc]: {
      icon: jsx$1(IconForTimestamp, {}),
      label: withAscIcon("最早添加"),
      helpInfo: "按添加时间增序"
    },
    [WatchlaterItemsOrder.Shuffle]: {
      icon: jsx$1(IconForShuffle, {}),
      label: "随机顺序",
      helpInfo: "不包括近期添加的稍后再看, 近期: 最近48小时内"
    }
  };
  const list = Object.values(WatchlaterItemsOrder);
  const extraHelpInfo = jsx$1("div", { className: "flex flex-col gap-y-4px", children: list.map((x) => {
    const {
      icon,
      label,
      helpInfo
    } = WatchlaterItemsOrderConfig[x];
    return jsxs("div", { className: "flex items-center justify-left gap-x-4px line-height-[0]", children: [
      icon,
      " ",
jsx$1("span", { className: "min-w-80px", children: label }),
      " :   ",
      helpInfo
    ] }, x);
  }) });
  function WatchlaterOrderSwitcher() {
    const onRefresh = useOnRefreshContext();
    const {
      ref,
      getPopupContainer
    } = usePopupContainer();
    const {
      watchlaterItemsOrder
    } = useSettingsSnapshot();
    const {
      searchText
    } = useSnapshot(store$2);
    const disabled = !!searchText;
    return jsx$1(GenericOrderSwitcher, { disabled, value: disabled ? WatchlaterItemsOrder.AddTimeDesc : watchlaterItemsOrder, onChange: async (next2) => {
      settings.watchlaterItemsOrder = next2;
      await delay(100);
      onRefresh?.();
    }, list, listDisplayConfig: WatchlaterItemsOrderConfig, $ref: ref, dropdownProps: {
      getPopupContainer
    }, extraHelpInfo });
  }
  const watchlaterState = proxy({
    updatedAt: 0,
    bvidSet: proxySet()
  });
  function useWatchlaterState(bvid) {
    const set2 = useSnapshot(watchlaterState).bvidSet;
    return !!bvid && set2.has(bvid);
  }
  function replaceWatchlaterStateBvidSet(newSet) {
    watchlaterState.updatedAt = Date.now();
    watchlaterState.bvidSet = proxySet(newSet);
  }
  function updateWatchlaterStateBvidSet(action2, bvid) {
    if (!watchlaterState.updatedAt) return;
    watchlaterState.bvidSet.add(bvid);
  }
  async function initWatchlaterState() {
    if (!getHasLogined() || !getUid()) return;
    const {
      items: allWatchlaterItems = []
    } = await fetchWatchlaterItems();
    if (!allWatchlaterItems.length) return;
    replaceWatchlaterStateBvidSet(allWatchlaterItems.map((x) => x.bvid));
  }
  if (IN_BILIBILI_HOMEPAGE) {
    void (async () => {
      await whenIdle();
      await pRetry(initWatchlaterState, {
        retries: 3,
        onFailedAttempt(error) {
          appWarn(`Try updateWatchlaterState ${error.attemptNumber} failed. There are ${error.retriesLeft} retries left`);
        }
      });
    })();
  }
  async function removeMultiSelectedWatchlaterItems() {
    const selected = getMultiSelectedItems().map((item) => ({
      item,
      cardData: normalizeCardData(item)
    })).filter((x) => x.cardData.avid).map((x) => [x.cardData.avid, x.item.uniqId, x.cardData.title]).filter(Boolean);
    const avids = selected.map((x) => x[0]);
    const uniqIds = selected.map((x) => x[1]);
    const titles = selected.map((x) => x[2]);
    if (!avids.length) {
      return toast("没有选中的视频");
    }
    const success = await batchRemoveWatchlater(avids);
    if (!success) return;
    currentGridSharedEmitter.emit("remove-cards", [uniqIds, titles]);
  }
  class WatchlaterRecService extends BaseTabService {
    constructor(order, addSeparator, prevShuffleBvidIndexMap, searchText) {
      super(WatchlaterRecService.PAGE_SIZE);
      this.searchText = searchText;
      this.innerService = order === WatchlaterItemsOrder.Shuffle && !this.searchText ? new ShuffleOrderService(addSeparator, prevShuffleBvidIndexMap) : new NormalOrderService(order, addSeparator, this.searchText);
    }
    static PAGE_SIZE = 10;
    innerService;
    get hasMoreExceptQueue() {
      return this.innerService.hasMore;
    }
    fetchMore(abortSignal) {
      return this.innerService.loadMore(abortSignal);
    }
    get usageInfo() {
      return jsx$1(WatchlaterUsageInfo, { service: this });
    }
    get state() {
      return this.innerService.state;
    }
decreaseTotal() {
      if (typeof this.innerService.state.total === "undefined") return;
      this.innerService.state.total--;
    }
    getServiceSnapshot() {
      const bvidIndexMap = this.innerService instanceof ShuffleOrderService ? this.innerService.currentBvidIndexMap : void 0;
      return {
        bvidIndexMap
      };
    }
  }
  function extendItem(item) {
    return {
      ...item,
      api: EApiType.Watchlater,
      uniqId: `${EApiType.Watchlater}-${item.bvid}`
    };
  }
  const getRecentGate = () => dayjs().subtract(2, "days").unix();
  const recentSeparator = {
    api: EApiType.Separator,
    uniqId: "watchlater-separator-recent",
    content: "近期"
  };
  const earlierSeparator = {
    api: EApiType.Separator,
    uniqId: "watchlater-separator-earlier",
    content: "更早"
  };
  function showApiRequestError(err) {
    toast(`获取稍后再看失败: ${err}`);
    throw new Error(`获取稍后再看失败: ${err}`, {
      cause: err
    });
  }
  class ShuffleOrderService {
    constructor(addSeparator, prevBvidIndexMap) {
      this.addSeparator = addSeparator;
      if (prevBvidIndexMap?.size) {
        this.keepOrder = true;
        this.prevBvidIndexMap = prevBvidIndexMap;
      } else {
        this.keepOrder = false;
      }
    }
    hasMore = true;
    state = proxy({
      total: void 0
    });
keepOrder;
    prevBvidIndexMap;
    async loadMore(abortSignal) {
      if (!this.hasMore) return;
      const items = await this.fetch(abortSignal);
      this.hasMore = false;
      return items;
    }
    currentBvidIndexMap;
    async fetch(abortSignal) {
      const {
        items: rawItems = [],
        err
      } = await fetchWatchlaterItems({
        asc: false,
        searchText: void 0,
        abortSignal
      });
      if (typeof err !== "undefined") {
        showApiRequestError(err);
      }
      replaceWatchlaterStateBvidSet(rawItems.map((x) => x.bvid).filter(Boolean));
      const items = rawItems.map(extendItem);
      const recentGate = getRecentGate();
      const firstNotRecentIndex = items.findIndex((item) => item.add_at < recentGate);
      let itemsWithSeparator = items;
      if (firstNotRecentIndex !== -1) {
        const recent = items.slice(0, firstNotRecentIndex);
        let earlier = items.slice(firstNotRecentIndex);
        if (this.keepOrder && this.prevBvidIndexMap?.size) {
          earlier = orderBy(earlier, [(item) => {
            return this.prevBvidIndexMap?.get(item.bvid) ?? -1;
          }], ["asc"]);
        } else {
          earlier = shuffle(earlier);
        }
        itemsWithSeparator = [!!recent.length && this.addSeparator && recentSeparator, ...recent, !!earlier.length && this.addSeparator && earlierSeparator, ...earlier].filter(Boolean);
      }
      this.state.total = rawItems.length;
      this.currentBvidIndexMap = new Map(itemsWithSeparator.filter((x) => x.api !== EApiType.Separator).map((x, index) => [x.bvid, index]));
      return itemsWithSeparator;
    }
  }
  class NormalOrderService {
constructor(order, addSeparator, searchText) {
      this.order = order;
      this.addSeparator = addSeparator;
      this.searchText = searchText;
      if (!this.searchText) {
        invariant(order !== WatchlaterItemsOrder.Shuffle, "shuffle not supported in NormalOrderService");
      }
    }
    firstPageLoaded = false;
    state = proxy({
      total: void 0
    });
    hasMore = true;
    page = 1;
    async loadMore() {
      if (!this.hasMore) return;
      const result = await fetchWatchlaterItems({
        asc: this.order === WatchlaterItemsOrder.AddTimeAsc,
        searchText: this.searchText,
        extraParams: {
          need_split: "true",
          ps: 20,
          pn: this.page
        }
      });
      if (typeof result.err !== "undefined") {
        this.hasMore = false;
        showApiRequestError(result.err);
        return;
      }
      const {
        items,
        total
      } = result;
      const maxPage = Math.ceil(total / 20);
      this.firstPageLoaded = true;
      this.state.total = result.total;
      this.hasMore = this.page < maxPage;
      this.page++;
      items.forEach((item) => {
        if (item.bvid) {
          updateWatchlaterStateBvidSet("add", item.bvid);
        }
      });
      const extendedItems = items.map(extendItem);
      return this.insertSeparator(extendedItems);
    }
    recentSeparatorInserted = false;
    earlierSeparatorInserted = false;
    insertSeparator(items) {
      if (!this.addSeparator) return items;
      let newItems = [...items];
      const recentGate = getRecentGate();
      const needEarlierSeparator = items.some((item) => item.add_at < recentGate);
      const needRecentSeparator = items.some((item) => item.add_at >= recentGate);
      if (this.order === WatchlaterItemsOrder.AddTimeAsc) {
        if (!this.earlierSeparatorInserted && needEarlierSeparator) {
          newItems = [earlierSeparator, ...newItems];
          this.earlierSeparatorInserted = true;
        }
        if (!this.recentSeparatorInserted && needRecentSeparator) {
          const idx = newItems.findIndex((item) => item.api === EApiType.Watchlater && item.add_at >= recentGate);
          newItems = [...newItems.slice(0, idx), recentSeparator, ...newItems.slice(idx)];
          this.recentSeparatorInserted = true;
        }
      } else {
        if (!this.recentSeparatorInserted && needRecentSeparator) {
          newItems = [recentSeparator, ...items];
          this.recentSeparatorInserted = true;
        }
        if (!this.earlierSeparatorInserted && needEarlierSeparator) {
          const idx = newItems.findIndex((item) => item.api === EApiType.Watchlater && item.add_at < recentGate);
          newItems = [...newItems.slice(0, idx), earlierSeparator, ...newItems.slice(idx)];
          this.earlierSeparatorInserted = true;
        }
      }
      return newItems;
    }
  }
  function getAppRecServiceConfig() {
    const snap = getSettingsSnapshot().appRecommend;
    return {
      addOtherTabContents: snap.addOtherTabContents
    };
  }
  const appRecShowContentFromOtherTabEl = (onRefresh) => jsx$1(CheckboxSettingItem, { configPath: "appRecommend.addOtherTabContents", label: "显示来自其他 Tab 的内容", tooltip: jsxs(Fragment, { children: [
    "显示来自其他 Tab 的内容 ",
jsx$1("br", {}),
    "如动态 / 收藏 / 稍后再看 ",
jsx$1("br", {}),
    "但是: 刷新时间会更长"
  ] }), extraAction: async () => {
    await delay(100);
    onRefresh?.();
  } });
  function AppRecUsageInfo() {
    const onRefresh = useOnRefreshContext();
    return jsx$1(Fragment, { children: appRecShowContentFromOtherTabEl(onRefresh) });
  }
  class AppRecService extends BaseTabService {
    constructor(config) {
      super(AppRecService.PAGE_SIZE);
      this.config = config;
      this.innerService = new AppRecInnerService();
      this.allServices = [this.innerService];
      this.initOtherTabServices();
    }
    static PAGE_SIZE = 20;
    usageInfo = jsx$1(AppRecUsageInfo, {});
    innerService;
    allServices = [];
    otherTabServices = [];
    initOtherTabServices() {
      if (!getHasLogined()) return;
      if (!this.config.addOtherTabContents) return;
      let dynamicFeedService;
      let favService;
      let watchlaterService;
      {
        const store2 = createDfStore();
        store2.upMid = void 0;
        store2.selectedGroupId = void 0;
        const config = getDynamicFeedServiceConfig(store2);
        Object.assign(config, {
          showLiveInDynamicFeed: true,
          whenViewAllEnableHideSomeContents: false,
          searchCacheEnabled: false
        });
        dynamicFeedService = new DynamicFeedRecService(config);
      }
      {
        const config = Object.assign(getFavServiceConfig(), {
          selectedKey: "all",
          itemsOrder: FavItemsOrder.Shuffle,
          selectedFavFolderId: void 0,
          selectedFavCollectionId: void 0,
          addSeparator: false
        });
        favService = new FavRecService(config);
      }
      {
        watchlaterService = new WatchlaterRecService(WatchlaterItemsOrder.AddTimeDesc, false);
      }
      this.otherTabServices = [dynamicFeedService, favService, watchlaterService];
      const allServices = [];
      const rate = 7 / 3;
      allServices.push(...this.otherTabServices);
      times(Math.round(rate * this.otherTabServices.length), () => allServices.push(this.innerService));
      this.allServices = shuffle(allServices);
    }
    get hasMore() {
      return !!this.qs.bufferQueue.length || this.innerService.hasMore || this.otherTabServices.some((s2) => s2.hasMore);
    }
    hasMoreExceptQueue = true;
fetchMore(abortSignal) {
      throw new Error("Method not implemented.");
    }
    async loadMore(abortSignal) {
      if (!this.hasMore) return;
      while (this.hasMore && this.qs.bufferQueue.length < AppRecService.PAGE_SIZE * 3) {
        const restServices = this.allServices.filter((s2) => s2.hasMore);
        if (!restServices.length) break;
        const pickedServices = shuffle(restServices).slice(0, 3);
        const more = (await Promise.all(pickedServices.map(async (s2) => await s2.loadMore(abortSignal) || []))).flat().filter((x) => x.api !== EApiType.Separator);
        this.qs.bufferQueue.push(...more);
        this.qs.bufferQueue = shuffle(this.qs.bufferQueue);
      }
      return this.qs.sliceFromQueue();
    }
async loadMoreBatch(abortSignal, times2) {
      if (!this.hasMore) return;
      if (this.qs.bufferQueue.length) return this.qs.sliceFromQueue(times2);
      return this.qs.doReturnItems(await this.innerService.getRecommendTimes(abortSignal, times2));
    }
  }
  class AppRecInnerService {
static PAGE_SIZE = 16;
    hasMore = true;
    async getRecommend() {
      const res = await gmrequest.get(`${HOST_APP}/x/v2/feed/index`, {
        timeout: 2e4,
        responseType: "json",
        params: {
          build: "1",
          mobi_app: "iphone",
          device: "pad",
idx: Math.floor(Date.now() / 1e3) + randomInt(1e3)
        }
      });
      const json = res.data;
      if (!json.data) {
        throw new Error("Request fail with none invalid json", {
          cause: {
            type: "invalid-json",
            statusCode: res.status,
            json
          }
        });
      }
      const items = json?.data?.items || [];
      return items;
    }
    loadMore(abortSignal, times2 = 2) {
      return this.getRecommendTimes(abortSignal, times2);
    }
async getRecommendTimes(abortSignal, times2) {
      let list2 = (await Promise.all(range(times2).map(() => this.getRecommend()))).flat();
      list2 = list2.filter((item) => {
        if (item.card_goto?.includes("ad")) return false;
        if (item.goto?.includes("ad")) return false;
        if (item.ad_info) return false;
        if (item.card_goto === "banner") return false;
        if (item.goto === "av" && typeof item.player_args === "undefined") return false;
        return true;
      });
      list2 = uniqBy(list2, (item) => item.param);
      const extendedList = list2.map((item) => {
        return {
          ...item,
          api: EApiType.AppRecommend,
          uniqId: `${EApiType.AppRecommend}-${item.param}`
        };
      });
      return extendedList;
    }
  }
  async function fetchAppRecommendFollowedPubDate(item, cardData) {
    const {
      bvid,
      goto,
      recommendReason
    } = cardData;
    const isNormalVideo = goto === "av";
    const shouldFetch = isAppRecommend(item) && isNormalVideo && !!bvid && getFollowedStatus$1(recommendReason);
    if (!shouldFetch) return;
    const detail = await getVideoDetail(bvid);
    const ts = detail?.pubdate;
    return ts;
  }
  const debug$8 = baseDebug.extend("modules:rec-services:pc");
  let _id = 0;
  const genUniqId = () => Date.now() + _id++;
  class PcRecService extends BaseTabService {
    constructor(isKeepFollowOnly) {
      super(PcRecService.PAGE_SIZE);
      this.isKeepFollowOnly = isKeepFollowOnly;
    }
    static PAGE_SIZE = 14;
    usageInfo = void 0;
    fetchMore(abortSignal) {
      const times2 = this.isKeepFollowOnly ? 5 : 2;
      return this.getRecommendTimes(times2, abortSignal);
    }
async loadMoreBatch(times2, abortSignal) {
      if (!this.hasMore) return;
      if (this.qs.bufferQueue.length) return this.qs.sliceFromQueue(times2);
      return this.qs.doReturnItems(await this.getRecommendTimes(times2, abortSignal));
    }
    async getRecommendTimes(times2, abortSignal) {
      let list2 = (await Promise.all(range(times2).map(() => this.getRecommend(abortSignal)))).flat();
      list2 = list2.filter((item) => {
        const allowedGotoList = [PcRecGoto.AV, PcRecGoto.Live];
        if (!allowedGotoList.includes(item.goto)) {
          const knownDisabledGotoList = [PcRecGoto.Ad];
          if (!knownDisabledGotoList.includes(item.goto)) {
            debug$8("uknown goto: %s %o", item.goto, item);
          }
          return false;
        }
        return true;
      });
      list2 = uniqBy(list2, (item) => item.id);
      list2.forEach((item) => {
        if (item.rcmd_reason?.reason_type === 1) {
          item.rcmd_reason.content ||= "已关注";
        }
      });
      const _list = list2.map((item) => {
        return {
          ...item,
          uniqId: `${EApiType.PcRecommend}-${item.bvid || item.room_info?.room_id || crypto.randomUUID()}`,
          api: EApiType.PcRecommend
        };
      });
      return _list;
    }
    page = 0;
    hasMoreExceptQueue = true;
    async getRecommend(abortSignal) {
      const curpage = ++this.page;
      const url = "/x/web-interface/wbi/index/top/feed/rcmd";
      const params = {
        web_location: 1430650,
        feed_version: "V8",
        homepage_ver: 1,
        fresh_type: 4,
        y_num: 5,
        last_y_num: 5,
        fresh_idx_1h: curpage,
        fresh_idx: curpage,
        uniq_id: genUniqId(),
        ps: 12
      };
      const res = await request.get(url, {
        signal: abortSignal,
        params
      });
      const json = res.data;
      if (!isWebApiSuccess(json) && json.code === -62011 && json.message === "暂时没有更多内容了") {
        this.hasMoreExceptQueue = false;
        return [];
      }
      if (!json.data?.item) {
        toast(json.message || "API 请求没有返回结果");
      }
      const items = json.data?.item || [];
      return items;
    }
  }
  const REC_TABS = [ETab.KeepFollowOnly, ETab.PcRecommend, ETab.AppRecommend];
  const createServiceMap = {
    [ETab.AppRecommend]: () => new AppRecService(getAppRecServiceConfig()),
    [ETab.PcRecommend]: () => new PcRecService(false),
    [ETab.KeepFollowOnly]: () => new PcRecService(true),
    [ETab.DynamicFeed]: () => new DynamicFeedRecService(getDynamicFeedServiceConfig()),
    [ETab.Watchlater]: ({
      existingService
    }) => {
      const {
        watchlaterAddSeparator,
        watchlaterItemsOrder
      } = settings;
      const prevShuffleBvidIndexMap = existingService && existingService instanceof WatchlaterRecService ? existingService.getServiceSnapshot().bvidIndexMap : void 0;
      return new WatchlaterRecService(watchlaterItemsOrder, watchlaterAddSeparator, prevShuffleBvidIndexMap, snapshot(store$2).searchText);
    },
    [ETab.Fav]: () => new FavRecService(getFavServiceConfig()),
    [ETab.Hot]: () => new HotRecService(),
    [ETab.Live]: () => new LiveRecService(),
    [ETab.SpaceUpload]: () => new SpaceUploadService(getSpaceUploadServiceConfig())
  };
  function getServiceFromRegistry(servicesRegistry, tab2) {
    const service = servicesRegistry.val[tab2];
    invariant(service, `servicesRegistry.val[tab=${tab2}] should not be nil`);
    return service;
  }
  const debug$7 = baseDebug.extend("service");
  const recItemUniqer = (item) => item.api === EApiType.Separator ? item.uniqId : lookinto(item, {
    [EApiType.AppRecommend]: (item2) => item2.param,
    [EApiType.PcRecommend]: (item2) => item2.bvid,
    [EApiType.DynamicFeed]: (item2) => item2.modules.module_dynamic.major.archive.bvid,
    [EApiType.Watchlater]: (item2) => item2.bvid,
    [EApiType.Fav]: (item2) => item2.bvid,
    [EApiType.PopularGeneral]: (item2) => item2.bvid,
    [EApiType.PopularWeekly]: (item2) => item2.bvid,
    [EApiType.Rank]: (item2) => item2.uniqId,
    [EApiType.Live]: (item2) => item2.roomid,
    [EApiType.SpaceUpload]: (item2) => item2.bvid
  });
  function concatThenUniq(existing, newItems) {
    return uniqBy([...existing, ...newItems], recItemUniqer);
  }
  const willUsePcApi = (tab2) => tab2 === ETab.PcRecommend || tab2 === ETab.KeepFollowOnly;
  async function fetchMinCount(count, fetcherOptions, filterMultiplier = 5) {
    const {
      tab: tab2,
      abortSignal,
      servicesRegistry
    } = fetcherOptions;
    let items = [];
    let hasMore = true;
    const addMore = async (restCount) => {
      let cur = [];
      if (!REC_TABS.includes(tab2)) {
        const service = getServiceFromRegistry(servicesRegistry, tab2);
        cur = await service.loadMore(abortSignal) || [];
        hasMore = service.hasMore;
        cur = filterRecItems(cur, tab2);
        items = concatThenUniq(items, cur);
        return;
      }
      let times2;
      if (tab2 === ETab.KeepFollowOnly) {
        times2 = 8;
        debug$7("getMinCount: addMore(restCount = %s) times=%s", restCount, times2);
      } else {
        const pagesize = willUsePcApi(tab2) ? PcRecService.PAGE_SIZE : AppRecService.PAGE_SIZE;
        const multipler = anyFilterEnabled(tab2) ? filterMultiplier : 1.2;
        times2 = Math.ceil(restCount * multipler / pagesize);
        debug$7("getMinCount: addMore(restCount = %s) multipler=%s pagesize=%s times=%s", restCount, multipler, pagesize, times2);
      }
      if (willUsePcApi(tab2)) {
        const service = getServiceFromRegistry(servicesRegistry, tab2);
        cur = await service.loadMoreBatch(times2, abortSignal) || [];
        hasMore = service.hasMore;
      } else {
        const service = getServiceFromRegistry(servicesRegistry, ETab.AppRecommend);
        cur = await (service.config.addOtherTabContents ? service.loadMore(abortSignal) : service.loadMoreBatch(abortSignal, times2)) || [];
        hasMore = service.hasMore;
      }
      cur = filterRecItems(cur, tab2);
      items = concatThenUniq(items, cur);
    };
    await addMore(count);
    while (true) {
      if (abortSignal?.aborted) {
        debug$7("getMinCount: break for abortSignal");
        break;
      }
      if (!hasMore) {
        debug$7("getMinCount: break for tab=%s hasMore=false", tab2);
        break;
      }
      const len = items.filter((x) => x.api !== EApiType.Separator).length;
      if (len >= count) break;
      await addMore(count - items.length);
    }
    return items;
  }
  async function refreshForHome(fetcherOptions) {
    let items = await fetchMinCount(getColumnCount(void 0, false) * 2, fetcherOptions, 5);
    if (fetcherOptions.tab === ETab.Watchlater) {
      items = items.slice(0, 20);
    }
    return items;
  }
  const getGridRefreshCount = () => getColumnCount() * 4;
  async function refreshForGrid(fetcherOptions) {
    let minCount = getGridRefreshCount();
    if (fetcherOptions.tab === ETab.DynamicFeed) {
      const service = getServiceFromRegistry(fetcherOptions.servicesRegistry, ETab.DynamicFeed);
      if (await service.shouldReduceMinCount()) {
        minCount = 1;
      }
    }
    return fetchMinCount(minCount, fetcherOptions, 5);
  }
  const win = typeof unsafeWindow !== "undefined" ? unsafeWindow : globalThis;
  const setGlobalValue = (key, val) => void attempt(() => win[key] = val);
  const gridItemsKey = `${APP_KEY_PREFIX}_gridItems`;
  function setGlobalGridItems(itemsWithSep) {
    const items = itemsWithSep.filter((x) => x.api !== EApiType.Separator);
    setCurrentGridItems(items);
    setGlobalValue(gridItemsKey, currentGridItems);
  }
  const BIND_TO_UNSAFE_WINDOW_FNS = {
    getGenericCardDatas,
    copyBvidsSingleLine,
    copyBvidInfos
  };
  setTimeout(() => {
    Object.entries(BIND_TO_UNSAFE_WINDOW_FNS).forEach(([fnName, fn]) => {
      setGlobalValue(`${APP_KEY_PREFIX}_${fnName}`, fn);
    });
  });
  const OnRefreshContext = H.createContext(void 0);
  function useOnRefreshContext() {
    return H.useContext(OnRefreshContext);
  }
  function useRefresh({
    tab: tab2,
    servicesRegistry,
    debug: debug2,
    fetcher,
    preAction,
    postAction,
    updateExtraInfo
  }) {
    const hasMoreBox = useRefStateBox(true);
    const itemsBox = useRefStateBox([]);
    H.useEffect(() => setGlobalGridItems(itemsBox.state), [itemsBox.state]);
    const refreshingBox = useRefStateBox(false);
    const refreshTsBox = useRefStateBox(() => Date.now());
    const [refreshAbortController, setRefreshAbortController] = H.useState(() => new AbortController());
    const [showSkeleton, setShowSkeleton] = H.useState(false);
    const [error, setError] = H.useState(void 0);
    const [beforeMount, setBeforeMount] = H.useState(true);
    useMount(() => {
      setBeforeMount(false);
      refresh(true);
    });
    useUnmount(() => {
      refreshAbortController.abort();
    });
    const refresh = useMemoizedFn(async (reuse = false) => {
      const start = performance.now();
      if (refreshingBox.val) {
        let s2;
        const debugSameTabConditionsChange = () => debug2("refresh(): tab=%s [start], current refreshing, sametab but conditions change, abort existing", tab2);
        if (tab2 === ETab.DynamicFeed && (s2 = servicesRegistry.val[ETab.DynamicFeed]) && !isEqual$1(s2.config, getDynamicFeedServiceConfig())) {
          debugSameTabConditionsChange();
          refreshAbortController.abort();
        } else if (tab2 === ETab.Fav && (s2 = servicesRegistry.val[ETab.Fav]) && !isEqual$1(s2.config, getFavServiceConfig())) {
          debugSameTabConditionsChange();
          refreshAbortController.abort();
        } else if (tab2 === ETab.Hot && (s2 = servicesRegistry.val[ETab.Hot]) && s2.subtab !== hotStore.subtab) {
          debug2("refresh(): tab=%s [start], current refreshing, sametab but subtab changed, abort existing", tab2);
          refreshAbortController.abort();
        } else {
          debug2("refresh() tab=%s [start], current refreshing, prevent same tab refresh()", tab2);
          return;
        }
      } else {
        debug2("refresh(): tab=%s [start]", tab2);
      }
      refreshTsBox.set(Date.now());
      refreshingBox.set(true);
      setError(void 0);
      itemsBox.set([]);
      hasMoreBox.set(true);
      await preAction?.();
      const _abortController = new AbortController();
      const _signal = _abortController.signal;
      setRefreshAbortController(_abortController);
      function _onAny() {
        refreshingBox.set(false);
        setShowSkeleton(false);
      }
      function onError(err) {
        _onAny();
        hasMoreBox.set(false);
        console.error(err);
        setError(err);
      }
      function onSuccess() {
        _onAny();
        hasMoreBox.set(getServiceFromRegistry(servicesRegistry, tab2).hasMore);
      }
      async function doFetch() {
        const [err, currentItems] = await attemptAsync(() => fetcher({
          tab: tab2,
          abortSignal: _signal,
          servicesRegistry
        }));
        if (_signal.aborted) return debug2("refresh(): tab=%s [aborted], ignoring rest code", tab2);
        if (err) return onError(err);
        itemsBox.set(currentItems ?? []);
        return true;
      }
      let willRefresh;
      const existingService = reuse ? servicesRegistry.val[tab2] : void 0;
      if (existingService) {
        existingService.restore();
        itemsBox.set(existingService.qs.bufferQueue.slice(0, getGridRefreshCount()));
        const success = !!await doFetch();
        willRefresh = success && !!TabConfig[tab2].swr;
      } else {
        setShowSkeleton(true);
        willRefresh = true;
      }
      if (willRefresh) {
        const [err, service] = attempt(() => createServiceMap[tab2]({
          existingService
        }));
        if (err) return onError(err);
        servicesRegistry.set({
          ...servicesRegistry.val,
          [tab2]: service
        });
        updateExtraInfo?.();
        const success = await doFetch();
        if (!success) return;
      }
      onSuccess();
      await postAction?.();
      const cost = performance.now() - start;
      debug2("refresh(): tab=%s [success] cost %s ms", tab2, cost.toFixed(0));
    });
    return {
      itemsBox,
      error,
      refresh,
      hasMoreBox,
      refreshingBox,
      refreshTsBox,
      refreshAbortController,
      showSkeleton,
      beforeMount
    };
  }
  const clsIconSize = "size-16px";
  const FavItemsOrderConfig = {
    [FavItemsOrder.Initial]: {
      icon: jsx$1(IconForDefaultOrder, { className: clsIconSize }),
      label: "初始顺序"
    },
    [FavItemsOrder.Shuffle]: {
      icon: jsx$1(IconForShuffle, { className: clsIconSize }),
      label: "随机顺序"
    },
    [FavItemsOrder.PubTimeDesc]: {
      icon: jsx$1(IconForTimestamp, { className: clsIconSize }),
      label: withDescIcon("最新投稿")
    },
    [FavItemsOrder.PubTimeAsc]: {
      icon: jsx$1(IconForTimestamp, { className: clsIconSize }),
      label: withAscIcon("最早投稿")
    },
    [FavItemsOrder.PlayCountDesc]: {
      icon: jsx$1(IconForPlayer, { className: clsIconSize }),
      label: withDescIcon("最多播放")
    },
    [FavItemsOrder.CollectCountDesc]: {
      icon: jsx$1(IconForFav, { className: clsx(clsIconSize, "mt--1px") }),
      label: withDescIcon("最多收藏")
    },
    [FavItemsOrder.FavTimeDesc]: {
      icon: jsx$1(IconForFav, { className: clsx(clsIconSize, "mt--1px") }),
      label: withDescIcon("最近收藏")
    },
    [FavItemsOrder.FavTimeAsc]: {
      icon: jsx$1(IconForFav, { className: clsx(clsIconSize, "mt--1px") }),
      label: withAscIcon("最早收藏")
    }
  };
  const MenuItemsConfig = {
    "all": [FavItemsOrder.Initial, FavItemsOrder.Shuffle],
    "fav-folder": [FavItemsOrder.FavTimeDesc, FavItemsOrder.PubTimeDesc, FavItemsOrder.PlayCountDesc, FavItemsOrder.CollectCountDesc, "divider", FavItemsOrder.FavTimeAsc, FavItemsOrder.PubTimeAsc, "divider", FavItemsOrder.Shuffle],
    "fav-collection": [FavItemsOrder.Initial, FavItemsOrder.PubTimeDesc, FavItemsOrder.PlayCountDesc, FavItemsOrder.CollectCountDesc, "divider", FavItemsOrder.PubTimeAsc, "divider", FavItemsOrder.Shuffle]
  };
  function _getSelectedKeyPrefix(selectedKey) {
    const prefix2 = selectedKey.split(":")[0];
    return prefix2;
  }
  function getMenuItemsFor(selectedKey) {
    const prefix2 = _getSelectedKeyPrefix(selectedKey);
    return MenuItemsConfig[prefix2] || Object.values(FavItemsOrder);
  }
  function _getFallbackOrder(selectedKey) {
    const prefix2 = _getSelectedKeyPrefix(selectedKey);
    if (prefix2 === "fav-folder") return FavItemsOrder.FavTimeDesc;
    if (prefix2 === "fav-collection") return FavItemsOrder.PubTimeDesc;
    return FavItemsOrder.Initial;
  }
  function getSavedOrder(selectedKey, savedOrderMap) {
    const allowed = getMenuItemsFor(selectedKey).filter((x) => x !== "divider");
    const current = savedOrderMap.get(selectedKey) || _getFallbackOrder(selectedKey);
    if (allowed.includes(current)) return current;
    return _getFallbackOrder(selectedKey);
  }
  function useSavedOrder(selectedKey, savedOrderMap) {
    return H.useMemo(() => getSavedOrder(selectedKey, savedOrderMap), [savedOrderMap, selectedKey]);
  }
  function FavItemsOrderSwitcher() {
    const onRefresh = useOnRefreshContext();
    const {
      ref,
      getPopupContainer
    } = usePopupContainer();
    const {
      selectedKey,
      savedOrderMap
    } = useSnapshot(favStore);
    const value = useSavedOrder(selectedKey, savedOrderMap);
    const menuItems = H.useMemo(() => getMenuItemsFor(selectedKey), [selectedKey]);
    return jsx$1(GenericOrderSwitcher, { value, onChange: async (next2) => {
      favStore.savedOrderMap.set(selectedKey, next2);
      await delay(100);
      onRefresh?.();
    }, list: menuItems, listDisplayConfig: FavItemsOrderConfig, $ref: ref, dropdownProps: {
      getPopupContainer
    } });
  }
  const UserFavService = {
    getVideoFavState,
    removeFavs,
    moveFavs,
    addFav
  };
  async function removeFavs(folderId, resources) {
    const form = new URLSearchParams({
      resources: [resources].flat().join(","),
      media_id: folderId.toString(),
      platform: "web",
      csrf: getCsrfToken()
    });
    const res = await request.post("/x/v3/fav/resource/batch-del", form);
    const json = res.data;
    const success = isWebApiSuccess(json);
    if (!success) {
      toast(json.message || OPERATION_FAIL_MSG);
    }
    return success;
  }
  async function moveFavs(resources, src, target) {
    const form = new URLSearchParams({
      resources: [resources].flat().join(","),
      src_media_id: src.toString(),
      tar_media_id: target.toString(),
      mid: getUid(),
      platform: "web",
      csrf: getCsrfToken()
    });
    const res = await request.post("/x/v3/fav/resource/move", form);
    const json = res.data;
    const success = isWebApiSuccess(json);
    if (!success) {
      toast(json?.message || "fav deal api fail");
    }
    return success;
  }
  async function getVideoFavState(avid) {
    if (!getHasLogined()) return;
    const res = await request.get("/x/v3/fav/folder/created/list-all", {
      params: {
        up_mid: getUid(),
        type: 2,
        rid: avid
      }
    });
    const json = res.data;
    const favFolders = json.data.list.filter((folder) => folder.fav_state > 0);
    const favFolderNames = favFolders.map((f2) => f2.title);
    const favFolderUrls = favFolders.map((f2) => formatFavFolderUrl(f2.id));
    const favFolderIds = favFolders.map((f2) => f2.id);
    return {
      favFolders,
      favFolderNames,
      favFolderUrls,
      favFolderIds
    };
  }
  async function favDeal({
    avid,
    add_media_ids = "",
    del_media_ids = ""
  }) {
    const form = new URLSearchParams({
      rid: avid.toString(),
      type: "2",
      add_media_ids,
      del_media_ids,
      platform: "web",
      eab_x: "2",
      ramval: "0",
      ga: "1",
      gaia_source: "web_normal",
      csrf: getCsrfToken()
    });
    const res = await request.post("/x/v3/fav/resource/deal", form);
    const json = res.data;
    const success = isWebApiSuccess(json);
    if (!success) {
      toast(json?.message || "fav deal api fail");
    }
    return success;
  }
  let defaultFavFolderId;
  let defaultFavFolderTitle;
  async function addFav(avid, folderId) {
    if (!folderId && (!defaultFavFolderId || !defaultFavFolderTitle)) {
      await updateFavFolderList();
      const {
        folders
      } = favStore;
      const defaultFolder = folders.find((f2) => isFavFolderDefault(f2.attr)) ?? folders[0];
      if (!defaultFolder) return toast("没有找到默认收藏夹!");
      defaultFavFolderId = defaultFolder.id;
      defaultFavFolderTitle = defaultFolder.title;
    }
    folderId ||= defaultFavFolderId;
    if (!folderId) {
      return toast("没有找到默认收藏夹!");
    }
    return await favDeal({
      avid,
      add_media_ids: folderId.toString()
    });
  }
  async function fetchAllFavFolders() {
    const res = await request.get("/x/v3/fav/folder/created/list-all", {
      params: {
        up_mid: getUid()
      }
    });
    const json = res.data;
    const folders = json.data.list;
    return folders;
  }
  const debug$6 = baseDebug.extend("modules:rec-services:fav:store");
  var FavQueryKey = ((FavQueryKey2) => {
    FavQueryKey2["CollectionIdFull"] = "fav-collection-id";
    FavQueryKey2["CollectionId"] = "fav-cid";
    FavQueryKey2["FolderIdFull"] = "fav-folder-id";
    FavQueryKey2["FolderId"] = "fav-fid";
    return FavQueryKey2;
  })(FavQueryKey || {});
  const parseId = (text) => {
    if (!text) return;
    const num = Number(text);
    if (Number.isNaN(num)) return;
    return num;
  };
  const searchParams = new URLSearchParams(location.search);
  const QUERY_FAV_COLLECTION_ID = parseId(searchParams.get(
    "fav-collection-id"
) ?? searchParams.get(
    "fav-cid"
));
  const QUERY_FAV_FOLDER_ID = parseId(searchParams.get(
    "fav-folder-id"
) ?? searchParams.get(
    "fav-fid"
));
  const SHOW_FAV_TAB_ONLY = IN_BILIBILI_HOMEPAGE && (typeof QUERY_FAV_FOLDER_ID === "number" || typeof QUERY_FAV_COLLECTION_ID === "number");
  const favStore = proxy({
    folders: [],
    foldersUpdateAt: 0,
    selectedFavFolderId: QUERY_FAV_FOLDER_ID,
    get selectedFavFolder() {
      if (typeof this.selectedFavFolderId !== "number") return;
      return this.folders.find((x) => x.id === this.selectedFavFolderId);
    },
    collections: [],
    collectionsUpdateAt: 0,
    selectedFavCollectionId: QUERY_FAV_COLLECTION_ID,
    selectedFavCollectionDetailInfo: void 0,
    get selectedFavCollection() {
      if (typeof this.selectedFavCollectionId !== "number") return;
      return this.collections.find((x) => x.id === this.selectedFavCollectionId);
    },
    get selectedKey() {
      let prefix2;
      let id;
      if (typeof this.selectedFavFolderId !== "undefined") {
        prefix2 = "fav-folder";
        id = this.selectedFavFolderId;
      } else if (typeof this.selectedFavCollectionId !== "undefined") {
        prefix2 = "fav-collection";
        id = this.selectedFavCollectionId;
      } else {
        return "all";
      }
      return `${prefix2}:${id}`;
    },
    get selectedLabel() {
      if (this.selectedFavFolder) {
        return `${this.selectedFavFolder.title} (${this.selectedFavFolder.media_count})`;
      }
      if (typeof this.selectedFavCollectionId === "number") {
        if (this.selectedFavCollection) {
          return `${this.selectedFavCollection.title} (${this.selectedFavCollection.media_count})`;
        }
        const info = this.selectedFavCollectionDetailInfo;
        if (info?.id === this.selectedFavCollectionId) {
          return `${info.title} (${info.media_count})`;
        }
        return;
      }
      return "全部";
    },
savedOrderMap: (await( proxyMapWithGmStorage("fav-saved-order"))).map,
    get usingShuffle() {
      const curret = getSavedOrder(this.selectedKey, this.savedOrderMap);
      return curret === FavItemsOrder.Shuffle;
    }
  });
  function updateFavFolderMediaCount(targetFavFolderId, count) {
    const folder = favStore.folders.find((x) => x.id === targetFavFolderId);
    if (!folder) return;
    const newCount = typeof count === "function" ? count(folder.media_count) : count;
    if (newCount === folder.media_count) return;
    folder.media_count = newCount;
    debug$6("update folder(id=%s title=%s) media_count to %s", folder.id, folder.title, newCount);
  }
  function updateFavList(force = false) {
    return Promise.all([updateFavFolderList(force), updateFavCollectionList(force)]);
  }
  const _updateFavFolderList = reusePendingPromise(async () => {
    const folders = await fetchAllFavFolders();
    favStore.folders = folders;
    favStore.foldersUpdateAt = Date.now();
  });
  async function updateFavFolderList(force = false) {
    if (!force) {
      const {
        folders,
        foldersUpdateAt
      } = favStore;
      const cacheValid = folders.length && foldersUpdateAt && Date.now() - foldersUpdateAt < ms("5min");
      if (cacheValid) return;
    }
    return _updateFavFolderList();
  }
  const _updateFavCollectionList = reusePendingPromise(async () => {
    const collections = await fetchAllFavCollections();
    favStore.collections = collections;
    favStore.collectionsUpdateAt = Date.now();
  });
  async function updateFavCollectionList(force = false) {
    if (!force) {
      const {
        collections,
        collectionsUpdateAt
      } = favStore;
      const cacheValid = collections.length && collectionsUpdateAt && Date.now() - collectionsUpdateAt < ms("5min");
      if (cacheValid) return;
    }
    return _updateFavCollectionList();
  }
  if (SHOW_FAV_TAB_ONLY) {
    subscribeKey(favStore, "selectedLabel", () => {
      if (!favStore.selectedLabel) return;
      setPageTitle(favStore.selectedLabel);
    });
  }
  setupFavStore();
  async function setupFavStore() {
    if (!(IN_BILIBILI_HOMEPAGE || IN_BILIBILI_VIDEO_PLAY_PAGE)) return;
    if (SHOW_FAV_TAB_ONLY) return;
    const storageKey2 = "fav-store";
    const persistStoreKeys = ["selectedFavFolderId", "selectedFavCollectionId", "folders"];
    const val = await GM.getValue(storageKey2);
    if (val) {
      for (const key of persistStoreKeys) {
        if (!isNil(val[key])) {
          favStore[key] = val[key];
        }
      }
    }
    const runInSequence = pLimit(1);
    subscribeOnKeys(favStore, persistStoreKeys, (snap) => {
      if (SHOW_FAV_TAB_ONLY) return;
      const val2 = pick(snap, persistStoreKeys);
      runInSequence(async () => {
        await GM.setValue(storageKey2, val2);
      });
    });
  }
  const iconParkOutlineTransferData = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "m10 8l-6 6l6 6m28 8l6 6l-6 6M4 14h40M4 34h40" })
  ] });
  const ForwardRef$m = H.forwardRef(iconParkOutlineTransferData);
  const defaultProps = {
    show: false,
    srcFavFolderId: void 0,
    onHide,
    okAction: void 0
  };
  const {
    proxyProps,
    updateProps
  } = wrapComponent({
    Component: ModalMoveFav,
    containerClassName: "ModalMoveFav",
    defaultProps
  });
  function useModalMoveFavVisible() {
    return useSnapshot(proxyProps).show;
  }
  const emitter$1 = new Emittery();
  function onHide() {
    updateProps({
      show: false
    });
    emitter$1.emit("modal-close");
  }
  async function pickFavFolder(srcFavFolderId, okAction) {
    updateProps({
      show: true,
      srcFavFolderId,
      okAction
    });
    await emitter$1.once("modal-close");
  }
  function ModalMoveFav({
    show,
    onHide: onHide2,
    srcFavFolderId,
    okAction
  }) {
    const $updateFoldersReq = useRequest(updateFavFolderList, {
      manual: true
    });
    const $okActionReq = useRequest(async (result) => okAction?.(result), {
      manual: true
    });
    const [selectedFolder, setSelectedFolder] = H.useState(void 0);
    const [filterText, setFilterText] = H.useState(void 0);
    H.useEffect(() => {
      if (show) {
        $updateFoldersReq.run();
      }
    }, [show]);
    useKeyPress("r", () => {
      if (!show) return;
      if (shouldDisableShortcut()) return;
      $updateFoldersReq.run(true);
    }, {
      exactMatch: true
    });
    const {
      folders
    } = useSnapshot(favStore);
    const filteredFolders = H.useMemo(() => {
      const mapped = folders.map((folder, index) => ({
        ...folder,
        vol: index + 1
      }));
      if (!filterText) return mapped;
      const included = mapped.filter((folder) => folder.title.includes(filterText));
      const includedIgnoreCase = mapped.filter((folder) => folder.title.toLowerCase().includes(filterText.toLowerCase()));
      const pinyinMatched = mapped.filter((folder) => PinyinMatch.match(folder.title, filterText));
      return uniqBy([...included, ...includedIgnoreCase, ...pinyinMatched], (x) => x.id);
    }, [folders, filterText]);
    const onOk = useMemoizedFn(async () => {
      if (!selectedFolder) return antMessage.error("请选择一个收藏夹");
      const success = await $okActionReq.runAsync(selectedFolder);
      if (success) onHide2();
    });
    return jsxs(BaseModal, { show, onHide: onHide2, hideWhenMaskOnClick: true, hideWhenEsc: true, width: 900, clsModal: "rounded-15px", children: [
jsxs("div", { className: BaseModalClassNames.modalHeader, children: [
jsxs("div", { className: "flex shrink-0 items-center", children: [
jsxs("div", { className: BaseModalClassNames.modalTitle, children: [
jsx$1(ForwardRef$m, { className: "size-25px" }),
jsx$1("span", { className: "ml-5px", children: "选择目标收藏夹" })
          ] }),
jsx$1(antd.Input, { className: "ml-15px", style: {
            width: 200
          }, allowClear: true, placeholder: "过滤: 支持拼音 / 首字母", value: filterText, onChange: (e2) => setFilterText(e2.target.value) }),
          !!filterText && jsxs("span", { className: "ml-5px", children: [
jsx$1("span", { className: clsx({
              "text-red": folders.length && !filteredFolders.length
            }), children: filteredFolders.length }),
            " ",
            "/ ",
jsx$1("span", { children: folders.length })
          ] }),
jsxs(HelpInfo, { className: "ml-5px", children: [
            "1. 使用 ",
jsx$1("kbd", { className: kbdClassName, children: "r" }),
            " 刷新收藏夹 ",
jsx$1("br", {}),
            "2. 使用 ",
jsx$1("kbd", { className: kbdClassName, children: "esc" }),
            " 取消操作, 关闭窗口 ",
jsx$1("br", {}),
            "3. 使用 拼音 / 首字母 过滤收藏夹标题 ",
jsx$1("br", {})
          ] })
        ] }),
jsx$1(ModalClose, { onClick: onHide2 })
      ] }),
jsx$1("div", { className: clsx(BaseModalClassNames.modalBody), children: jsx$1(antd.Spin, { spinning: $updateFoldersReq.loading || $okActionReq.loading, indicator: antSpinIndicator, children: jsx$1("div", { className: "grid grid-cols-4 mb-10px min-h-100px items-start gap-10px pr-15px", children: filteredFolders.length ? filteredFolders.map((f2) => {
        const disabled = f2.id === srcFavFolderId;
        const active = !disabled && f2.id === selectedFolder?.id;
        return jsxs("button", { "data-id": f2.id, className: clsx({
          active
        }, "relative flex items-center b-2px b-gate-border rounded-6px b-solid bg-transparent py-12px", !disabled && "hover:bg-gate-bg-lv1", disabled ? "cursor-not-allowed" : "cursor-pointer", active && "b-gate-primary color-white bg-gate-primary!"), disabled, onClick: () => {
          setSelectedFolder({
            id: f2.id,
            title: f2.title
          });
        }, children: [
jsx$1("span", { className: "ml-6px size-24px flex-center flex-none rounded-full bg-gate-bg-lv-2 text-center text-size-12px color-gate-text", children: f2.vol }),
jsxs("span", { className: "flex-1 px-4px", children: [
            f2.title,
            " (",
            f2.media_count,
            ")"
          ] }),
jsx$1("span", { className: "mr-6px size-20px flex-none", children: active && jsx$1(IconAnimatedChecked, { className: "h-100% w-100% color-white", useAnimation: true }) })
        ] }, f2.id);
      }) : jsx$1(antd.Empty, { className: "grid-col-span-full", image: antd.Empty.PRESENTED_IMAGE_SIMPLE, description: "未找到收藏夹", children: "无过滤结果, 请清除过滤词!" }) }) }) }),
jsxs("div", { className: "mt-2 flex items-center justify-between", children: [
jsx$1("div", { className: "flex-v-center gap-x-10px", children: jsxs("a", { href: `https://space.bilibili.com/${getUid()}/favlist`, target: "_blank", className: "flex-v-center gap-x-1", children: [
jsx$1(IconForOpenExternalLink, { className: "relative top--1px size-13px" }),
          "去个人空间新建收藏夹"
        ] }) }),
jsxs("div", { className: "flex-v-center gap-x-10px", children: [
jsx$1(antd.Button, { onClick: onHide2, children: "取消" }),
jsx$1(antd.Button, { type: "primary", onClick: onOk, loading: $okActionReq.loading, children: "确定" })
        ] })
      ] })
    ] });
  }
  const videoSourceTabState = await( proxyWithGmStorage({
    value: ETab.AppRecommend
  }, `video-source-tab`));
  if (SHOW_DYNAMIC_FEED_ONLY) {
    videoSourceTabState.value = ETab.DynamicFeed;
  }
  if (SHOW_FAV_TAB_ONLY) {
    videoSourceTabState.value = ETab.Fav;
  }
  if (SHOW_SPACE_UPLOAD_ONLY) {
    videoSourceTabState.value = ETab.SpaceUpload;
  }
  function getSortedTabKeys(customTabKeysOrder) {
    return CONFIGURABLE_TAB_KEYS.slice().sort((a2, b) => {
      let aIndex = customTabKeysOrder.indexOf(a2);
      let bIndex = customTabKeysOrder.indexOf(b);
      if (aIndex === -1) aIndex = ALL_TAB_KEYS.indexOf(a2);
      if (bIndex === -1) bIndex = ALL_TAB_KEYS.indexOf(b);
      return aIndex - bIndex;
    });
  }
  function useSortedTabKeys() {
    const {
      customTabKeysOrder
    } = useSettingsSnapshot();
    return H.useMemo(() => getSortedTabKeys(customTabKeysOrder), [customTabKeysOrder]);
  }
  function useCurrentDisplayingTabKeys() {
    const {
      hidingTabKeys,
      customTabKeysOrder
    } = useSettingsSnapshot();
    const logined = useHasLogined();
    const keys = H.useMemo(() => {
      const tabkeys = getSortedTabKeys(customTabKeysOrder);
      return tabkeys.filter((key) => {
        if (key === ETab.AppRecommend && !logined) {
          return true;
        }
        if (key === ETab.DynamicFeed && SHOW_DYNAMIC_FEED_ONLY) {
          return true;
        }
        if (key === ETab.Fav && SHOW_FAV_TAB_ONLY) {
          return true;
        }
        if (key === ETab.SpaceUpload && !SHOW_SPACE_UPLOAD_ONLY) {
          return false;
        }
        return !hidingTabKeys.includes(key);
      });
    }, [hidingTabKeys, customTabKeysOrder, logined]);
    if (SHOW_DYNAMIC_FEED_ONLY && keys.includes(ETab.DynamicFeed)) {
      return [ETab.DynamicFeed];
    }
    if (SHOW_FAV_TAB_ONLY && keys.includes(ETab.Fav)) {
      return [ETab.Fav];
    }
    if (SHOW_SPACE_UPLOAD_ONLY) {
      return [ETab.SpaceUpload];
    }
    return keys;
  }
  function useCurrentDisplayingTabConfigList() {
    const keys = useCurrentDisplayingTabKeys();
    return H.useMemo(() => keys.map((key) => ({
      key,
      ...TabConfig[key]
    })), [keys]);
  }
  function useCurrentUsingTab() {
    const tab2 = useSnapshot(videoSourceTabState).value;
    const displayTabKeys = useCurrentDisplayingTabKeys();
    const logined = useHasLogined();
    const fallbackTab = ETab.AppRecommend;
    if (!displayTabKeys.includes(tab2)) return fallbackTab;
    if (!logined &&
!TabConfig[tab2].anonymousUsage) {
      return fallbackTab;
    }
    return tab2;
  }
  const radioBtnCss = {
    name: "700njw",
    styles: "height:32px;line-height:unset;&:has(:focus-visible){outline:none;outline-offset:unset;}>.ant-radio-button+span{height:100%;}"
  };
  function VideoSourceTab({
    onRefresh
  }) {
    const logined = useHasLogined();
    const tab2 = useCurrentUsingTab();
    const currentTabConfigList = useCurrentDisplayingTabConfigList();
    const {
      __internalRecTabRenderAsSegments
    } = useSettingsSnapshot();
    const onChangeTab = useMemoizedFn((newTab) => {
      if (!logined && !TabConfig[newTab].anonymousUsage && !checkLoginStatus()) {
        return toastNeedLogin();
      }
      videoSourceTabState.value = newTab;
    });
    const renderAsRadio = jsx$1(antd.Radio.Group, { optionType: "button", buttonStyle: "solid", size: "middle", value: tab2, className: "inline-flex items-center overflow-hidden", onFocus: (e2) => {
      const target = e2.target;
      target.blur();
    }, onChange: (e2) => {
      const newValue = e2.target.value;
      onChangeTab(newValue);
    }, children: currentTabConfigList.map(({
      key,
      label
    }) => jsx$1(
      antd.Radio.Button,
      {
        css: radioBtnCss,
        className: "video-source-tab",
        tabIndex: -1,
        value: key,
        children: jsxs("span", { className: "h-full flex items-center line-height-unset", children: [
jsx$1(TabIcon, { tabKey: key, className: "mr-4px", active: key === tab2 }),
          label
        ] })
      },
      key
    )) });
    let renderAsSegment;
    {
      const options = H.useMemo(() => {
        return currentTabConfigList.map(({
          key,
          label
        }) => {
          return {
            value: key,
            label: jsxs("div", { className: "flex items-center gap-x-6px", children: [
jsx$1(TabIcon, { tabKey: key, active: key === tab2 }),
              label
            ] })
          };
        });
      }, [currentTabConfigList, tab2]);
      renderAsSegment = jsx$1(antd.Segmented, { size: "middle", options, value: tab2, onChange: onChangeTab });
    }
    return jsxs("div", { className: "flex-v-center", children: [
      __internalRecTabRenderAsSegments ? renderAsSegment : renderAsRadio,
jsx$1(HelpInfo, { className: "ml-6px size-16px", children: jsx$1(Fragment, { children: currentTabConfigList.map(({
        key,
        label,
        desc,
        extraHelpInfo: extraHelpInfo2
      }) => jsxs(H.Fragment, { children: [
jsxs("div", { className: "h-22px flex items-center", children: [
jsx$1(TabIcon, { tabKey: key, className: "mr-4px", active: true }),
          label,
          ": ",
          desc
        ] }),
        !!extraHelpInfo2 && extraHelpInfo2
      ] }, key)) }) })
    ] });
  }
  function isEmptyFragment(fragment) {
    const fragChildren = H.Children.toArray(fragment.props.children);
    return !fragChildren.length;
  }
  function Picture({
    src,
    avif,
    webp,
    imgProps,
    className,
    ...props
  }) {
    avif ??= !isSafari;
    webp ??= true;
    return jsxs("picture", { className: n("h-full w-full object-cover", className), ...props, children: [
      avif && jsx$1("source", { srcSet: `${src}.avif`, type: "image/avif" }),
      webp && jsx$1("source", { srcSet: `${src}.webp`, type: "image/webp" }),
jsx$1("img", { src, loading: "lazy", className: "block h-full w-full", ...imgProps })
    ] });
  }
  function useInFilterByAuthorList(authorMid) {
    const {
      enabled,
      keywords
    } = useSnapshot(settings.filter.byAuthor);
    const {
      blockUpMids
    } = H.useMemo(() => parseFilterByAuthor(keywords), [keywords]);
    if (!authorMid) return false;
    return enabled && blockUpMids.has(authorMid);
  }
  async function getVideoPlayUrl(videoId, cid, useMp4 = false, usePreferredCdn = false) {
    const params = {
      cid,
      fnver: 0,
      fnval: useMp4 ? 1 : 16
};
    const _videoId = videoId.toString();
    if (_videoId.startsWith("BV")) {
      params.bvid = _videoId;
    } else if (/^\d+$/.test(_videoId)) {
      params.avid = _videoId;
    } else {
      throw new Error("Invalid videoId provided, must be avid | bvid");
    }
    const res = await request.get("/x/player/wbi/playurl", {
      params
    });
    const json = res.data;
    function reOrderUrls(urls) {
      return fastOrderBy(urls, [(u2) => getUrlPriority(u2, usePreferredCdn)], ["desc"]);
    }
    if (json?.data?.durl) {
      const urls = (json.data.durl || []).map((x) => [x.url, ...x.backup_url || []]).flat().filter(Boolean);
      if (urls.length) return reOrderUrls(urls);
    }
    const video = fastOrderBy(json.data?.dash?.video || [], ["id", "codecid"], ["desc", "desc"]);
    const dashUrls = video.map((x) => reOrderUrls([x.baseUrl, ...x.backupUrl || []])[0]).filter(Boolean);
    return dashUrls;
  }
  function getUrlPriority(url, usePreferredCdn) {
    if (!usePreferredCdn) return 10;
    const {
      hostname: hostname2,
      searchParams: searchParams2,
      pathname: pathname2
    } = new URL(url);
    if (hostname2.includes("mcdn") || searchParams2.get("os") === "mcdn") return 2;
    if (pathname2.startsWith("/v1/resource/")) return 1;
    if (hostname2.includes("-mirror")) return 100;
    return 10;
  }
  function isVideoshotDataValid(videoshotData) {
    return Boolean(videoshotData?.image?.length && videoshotData?.index?.length);
  }
  function isVideoshotJsonCacheable(json) {
    const success = isWebApiSuccess(json);
    if (!success) {
      return true;
    } else {
      return isVideoshotDataValid(json.data);
    }
  }
  async function __fetchVideoshotJson(bvid) {
    const res = await request.get("/x/player/videoshot", {
      params: {
        bvid,
        index: "1"
      }
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      appWarn("videoshot error for %s: %o", bvid, json);
    }
    if (!isVideoshotDataValid(json.data)) {
      appWarn("videoshot data invalid bvid=%s: %o", bvid, json.data);
    }
    return json;
  }
  const videoshotCache = new QuickLRU({
    maxSize: 1e4
  });
  const getVideoshotJson = reusePendingPromise(async (bvid) => {
    if (videoshotCache.has(bvid)) {
      const cached = videoshotCache.get(bvid);
      if (cached) return cached;
    }
    const MAX_RETRY = 5;
    const DELAY = 200;
    let retryTimes = 0;
    let videoshotJson;
    do {
      retryTimes++;
      videoshotJson = await __fetchVideoshotJson(bvid);
      if (isVideoshotJsonCacheable(videoshotJson)) {
        break;
      } else {
        await delay(DELAY);
      }
    } while (retryTimes < MAX_RETRY);
    if (isVideoshotJsonCacheable(videoshotJson)) {
      videoshotCache.set(bvid, videoshotJson);
    }
    const videoshotData = videoshotJson.data;
    if (settings.autoPreviewWhenHover) {
      const imgs = videoshotData?.image || [];
      await preloadImg(imgs[0]);
      (async () => {
        for (const src of imgs.slice(1)) {
          await preloadImg(src);
        }
      })();
    }
    return videoshotJson;
  });
  const debug$5 = baseDebug.extend("VideoCard:services");
  function watchlaterFactory(action2) {
    return async function watchlaterOp(avid) {
      const form = new URLSearchParams({
        aid: avid,
        csrf: getCsrfToken()
      });
      const res = await request.post(`/x/v2/history/toview/${action2}`, form);
      const json = res.data;
      const success = isWebApiSuccess(json);
      if (!success) {
        toast(json?.message || "出错了");
      }
      return success;
    };
  }
  const watchlaterAdd = watchlaterFactory("add");
  const watchlaterDel = watchlaterFactory("del");
  const dislikeFactory = (type) => {
    const pathname2 = {
      dislike: "/x/feed/dislike",
      cancel: "/x/feed/dislike/cancel"
    }[type];
    return async function(item, reasonId) {
      const res = await gmrequest.get(HOST_APP + pathname2, {
        params: {
          goto: item.goto,
          id: item.param,


reason_id: reasonId,
build: "1",
          mobi_app: "android",
          idx: (Date.now() / 1e3).toFixed(0)
        }
      });
      const json = res.data;
      const success = isWebApiSuccess(json);
      let message2 = json.message;
      if (!success) {
        message2 ||= OPERATION_FAIL_MSG;
        message2 += `(code ${json.code})`;
        message2 += "\n请重新获取 access_key 后重试";
      }
      return {
        success,
        json,
        message: message2
      };
    };
  };
  const dislike = dislikeFactory("dislike");
  const cancelDislike = dislikeFactory("cancel");
  async function fetchImagePreviewData(bvid) {
    const videoshotJson = await getVideoshotJson(bvid);
    return {
      videoshotJson
    };
  }
  function isImagePreviewDataValid(data2) {
    return isVideoshotDataValid(data2?.videoshotJson?.data);
  }
  const isVideoPreviewDataValid = (data2) => {
    return !!data2?.playUrls?.length;
  };
  const videoPreviewCache = new QuickLRU({
    maxSize: 1e4,
    maxAge: ms("1h")
  });
  const fetchVideoPreviewData = reusePendingPromise(async ({
    bvid,
    cid,
    useMp4,
    usePreferredCdn,
    aspectRatioFromItem
  }) => {
    const cacheKey2 = JSON.stringify([bvid, useMp4, usePreferredCdn]);
    const cached = videoPreviewCache.get(cacheKey2);
    if (cached) return cached;
    let playUrls = [];
    let dimension;
    if (typeof cid === "undefined" || typeof aspectRatioFromItem === "undefined") {
      const pages = await getVideoPageList(bvid);
      cid = pages[0]?.cid;
      dimension = pages[0]?.dimension;
      if (typeof cid === "undefined") {
        throw new TypeError(`can not get cid by bvid=${bvid}`);
      }
    }
    playUrls = await getVideoPlayUrl(bvid, cid, useMp4, usePreferredCdn);
    debug$5("playUrl: bvid=%s cid=%s %s", bvid, cid, playUrls);
    if (playUrls) {
      videoPreviewCache.set(cacheKey2, {
        playUrls,
        dimension
      });
    }
    return {
      playUrls,
      dimension
    };
  });
  const store$1 = await( proxyWithGmStorage({
    volume: void 0,
muted: void 0
  }, "large-preview-store"));
  const RecoverableVideo = H.forwardRef(({
    currentTimeRef,
    ...videoProps
  }, forwardedRef) => {
    const ref = useMixedRef(forwardedRef);
    const mountedRef = H.useRef(false);
    useMount(() => {
      if (ref.current) {
        if (typeof currentTimeRef.current === "number") {
          ref.current.currentTime = currentTimeRef.current;
        }
        if (typeof store$1.volume === "number") {
          ref.current.volume = store$1.volume;
        }
        if (typeof store$1.muted === "boolean") {
          ref.current.muted = store$1.muted;
        }
      }
      mountedRef.current = true;
    });
    const onTimeUpdate = useMemoizedFn(() => {
      if (!mountedRef.current) return;
      currentTimeRef.current = ref.current?.currentTime;
    });
    const onVolumeChange = useMemoizedFn(() => {
      if (!mountedRef.current) return;
      if (!ref.current) return;
      store$1.volume = ref.current.volume;
      store$1.muted = ref.current.muted;
    });
    return jsx$1("video", { ref, ...videoProps, onTimeUpdate, onVolumeChange });
  });
  const debug$4 = baseDebug.extend("VideoCard:LargePreview");
  const DirectionConfig = {
    right: {
      multiplier: 1,
      axis: "x",
      reverse: "left"
    },
    left: {
      multiplier: -1,
      axis: "x",
      reverse: "right"
    },
    bottom: {
      multiplier: 1,
      axis: "y",
      reverse: "top"
    },
    top: {
      multiplier: -1,
      axis: "y",
      reverse: "bottom"
    }
  };
  const VisualPadding = {
    border: 40,
    card: 10
  };
  function getCoverRectDefaultImpl(placeholder) {
    return (
placeholder.closest(`.${APP_CLS_CARD}`)?.querySelector(`.${APP_CLS_CARD_COVER}`)?.getBoundingClientRect() ??
placeholder.closest(".bili-video-card")?.querySelector(".bili-video-card__image")?.getBoundingClientRect()
    );
  }
  const LargePreview = H.forwardRef(({
    children,
    aspectRatio = 1.7777777777777777,
    getCoverRect = getCoverRectDefaultImpl,
    ...restProps
  }, forwardedRef) => {
    const placeholderRef = H.useRef(null);
    const popoverRef = useMixedRef(forwardedRef);
    const [visible, setVisible] = H.useState(false);
    const [position2, setPosition] = H.useState(void 0);
    const hide = useMemoizedFn(() => {
      setVisible(false);
      setPosition(void 0);
    });
    const calculatePostion = useMemoizedFn(() => {
      const placeholder = placeholderRef.current;
      if (!placeholder) return hide();
      const cardCoverRect = getCoverRect(placeholder);
      if (!cardCoverRect) return hide();
      const viewportWidth = document.documentElement.clientWidth;
      const viewportHeight = document.documentElement.clientHeight;
      const tolerance = 40;
      if (cardCoverRect.top > viewportHeight - tolerance || cardCoverRect.bottom < 0 + tolerance || cardCoverRect.left > viewportWidth - tolerance || cardCoverRect.right < 0 + tolerance) {
        return hide();
      }
      const possibleBoundingBox = {
        top: {
          x: 0,
          y: 0,
          width: viewportWidth,
          height: cardCoverRect.top
        },
        bottom: {
          x: 0,
          y: cardCoverRect.bottom,
          width: viewportWidth,
          height: viewportHeight - cardCoverRect.bottom
        },
        left: {
          x: 0,
          y: 0,
          width: cardCoverRect.left,
          height: viewportHeight
        },
        right: {
          x: cardCoverRect.right,
          y: 0,
          width: viewportWidth - cardCoverRect.right,
          height: viewportHeight
        }
      };
      const getScaleInBox = (bbox2) => {
        const w = aspectRatio;
        const h2 = 1;
        const scaleX = bbox2.width / w;
        const scaleY = bbox2.height / h2;
        const scale2 = Math.min(scaleX, scaleY);
        return {
          scale: scale2,
          scaleLimit: scaleX > scaleY ? "height" : "width"
        };
      };
      const picked = orderBy(Object.entries(possibleBoundingBox).map(([direction2, bbox2]) => ({
        direction: direction2,
        bbox: bbox2,
        ...getScaleInBox(bbox2)
      })), ["scale", (x) => {
        switch (x.direction) {
          case "top":
            return cardCoverRect.top;
          case "bottom":
            return viewportHeight - cardCoverRect.bottom;
          case "left":
            return cardCoverRect.left;
          case "right":
            return viewportWidth - cardCoverRect.right;
        }
      }], ["desc", "desc"])[0];
      debug$4("picked direction", picked);
      const {
        direction,
        bbox,
        scale,
        scaleLimit
      } = picked;
      let elWidth;
      let elHeight;
      if (scaleLimit === "width") {
        elWidth = Math.floor(bbox.width - (VisualPadding.card + VisualPadding.border));
        elHeight = elWidth / aspectRatio;
      } else if (scaleLimit === "height") {
        elHeight = Math.floor(bbox.height - (VisualPadding.card + VisualPadding.border));
        elWidth = elHeight * aspectRatio;
      } else {
        throw new Error("unexpected scaleLimit");
      }
      let elPosX = 0;
      let elPosY = 0;
      let arrowTop = 0;
      let arrowLeft = 0;
      const setArrowTop = () => {
        arrowTop = cardCoverRect.y + cardCoverRect.height / 2 - elPosY;
      };
      const setArrowLeft = () => {
        arrowLeft = cardCoverRect.x + cardCoverRect.width / 2 - elPosX;
      };
      const fixX = () => {
        if (elPosX < VisualPadding.border) {
          elPosX = VisualPadding.border;
          return;
        }
        if (elPosX + elWidth > viewportWidth - VisualPadding.border) {
          elPosX = viewportWidth - VisualPadding.border - elWidth;
          return;
        }
      };
      const fixY = () => {
        if (elPosY < VisualPadding.border) {
          elPosY = VisualPadding.border;
          return;
        }
        if (elPosY + elHeight > viewportHeight - VisualPadding.border) {
          elPosY = viewportHeight - VisualPadding.border - elHeight;
          return;
        }
      };
      switch (direction) {
        case "top":
          elPosX = cardCoverRect.x + cardCoverRect.width / 2 - elWidth / 2;
          elPosY = cardCoverRect.top - VisualPadding.card - elHeight;
          fixX();
          setArrowLeft();
          break;
        case "bottom":
          elPosX = cardCoverRect.x + cardCoverRect.width / 2 - elWidth / 2;
          elPosY = cardCoverRect.bottom + VisualPadding.card;
          fixX();
          setArrowLeft();
          break;
        case "right":
          elPosX = cardCoverRect.right + VisualPadding.card;
          elPosY = cardCoverRect.y + cardCoverRect.height / 2 - elHeight / 2;
          fixY();
          setArrowTop();
          break;
        case "left":
          elPosX = cardCoverRect.left - VisualPadding.card - elWidth;
          elPosY = cardCoverRect.y + cardCoverRect.height / 2 - elHeight / 2;
          fixY();
          setArrowTop();
          break;
      }
      elPosX = Math.floor(elPosX);
      elPosY = Math.floor(elPosY);
      setVisible(true);
      setPosition({
        direction,
        elWidth,
        elHeight,
        elPosX,
        elPosY,
        arrowTop,
        arrowLeft
      });
    });
    const calculatePostionThrottled = H.useMemo(() => throttle$1(calculatePostion, 100), [calculatePostion]);
    useMount(calculatePostionThrottled);
    useEventListener("resize", calculatePostionThrottled, {
      target: window
    });
    useEventListener("scroll", calculatePostionThrottled, {
      target: window
    });
    const {
      useScale
    } = useSettingsSnapshot().videoCard.videoPreview;
    const animationDuration = useScale ? 0.2 : 0.3;
    const initial = H.useMemo(() => {
      const direction = position2?.direction;
      if (!direction) return;
      const {
        axis,
        multiplier,
        reverse
      } = DirectionConfig[direction];
      if (!useScale) {
        let animateDistance = 30;
        if (direction === "top") animateDistance = 20;
        if (axis === "x") {
          return {
            x: -multiplier * animateDistance,
            y: 0
          };
        } else {
          return {
            x: 0,
            y: -multiplier * animateDistance
          };
        }
      } else if (axis === "x") {
        return {
          scale: 0.5,
          transformOrigin: `${reverse} ${position2.arrowTop}px`
        };
      } else {
        return {
          scale: 0.5,
          transformOrigin: `${position2.arrowLeft}px ${reverse}`
        };
      }
    }, [position2, useScale]);
    const placeholderEl = jsx$1("div", { ref: placeholderRef, "data-role": "video-card-descendant" });
    const popoverEl = jsx$1("div", { ...restProps, ref: popoverRef, css: [ css("display:", visible ? "block" : "none", ";", ""), position2 && css("position:fixed;z-index:", zIndexVideoCardLargePreview, ";width:", position2.elWidth, "px;height:", position2.elHeight, "px;top:", position2.elPosY, "px;left:", position2.elPosX, "px;", ""), "", ""], children: visible && jsxs(framerMotion.motion.div, { className: "relative h-100%", initial: {
      opacity: 0,
      ...initial
    }, animate: {
      opacity: 1,
      x: 0,
      y: 0,
      scale: 1
    }, transition: {
      bounce: 0,
      duration: animationDuration
    }, children: [
      position2?.direction && jsx$1(PopoverArrow, { size: 7, direction: position2.direction, arrowTop: position2.arrowTop, arrowLeft: position2.arrowLeft }),
jsx$1("div", { className: "h-full overflow-hidden rounded-20px bg-white/50% backdrop-blur-10px", css: css("box-shadow:0px 0px 1px 1px ", primaryColorValue, ";", ""), children })
    ] }) });
    return jsxs(Fragment, { children: [
      placeholderEl,
      isSafari ? require$$0.createPortal(popoverEl, document.body) : popoverEl
    ] });
  });
  function PopoverArrow({
    size,
    direction,
    arrowTop,
    arrowLeft
  }) {
    const {
      axis,
      multiplier,
      reverse
    } = DirectionConfig[direction];
    const extra = H.useMemo(() => {
      if (axis === "x") {
        return css`
        ${direction}: 100%;
        margin-${direction}: -1px;
        top: ${arrowTop}px;
        margin-top: -${size / 2}px;
      `;
      } else {
        return css`
        ${direction}: 100%;
        margin-${direction}: -1px;
        left: ${arrowLeft}px;
        margin-left: -${size / 2}px;
      `;
      }
    }, [size, direction, axis, arrowTop, arrowLeft]);
    return jsx$1("div", { className: "absolute box-content h-0 w-0", css: [ css("border:", size, "px solid transparent;", ""), extra, css`
          border-${direction}-color: ${primaryColorValue};
        `, "", ""] });
  }
  const iconParkOutlinePin = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, d: "M10.696 17.504c2.639-2.638 5.774-2.565 9.182-.696L32.62 9.745l-.721-4.958L43.213 16.1l-4.947-.71l-7.074 12.73c1.783 3.638 1.942 6.544-.697 9.182l-7.778-7.778L6.443 41.556l11.995-16.31z" })
  ] });
  const ForwardRef$l = H.forwardRef(iconParkOutlinePin);
  const iconParkOutlineVideoTwo = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M39 6H9a3 3 0 0 0-3 3v30a3 3 0 0 0 3 3h30a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3" }),
jsx$1("path", { d: "M20.5 28v-6.062l5.25 3.03L31 28l-5.25 3.031l-5.25 3.031zM6 15h36m-9-9l-6 9m-6-9l-6 9" })
    ] })
  ] });
  const ForwardRef$k = H.forwardRef(iconParkOutlineVideoTwo);
  function clearTimerRef(timerRef) {
    if (typeof timerRef.current === "undefined") return;
    clearTimeout(timerRef.current);
    timerRef.current = void 0;
  }
  function useLargePreviewRelated({
shouldFetchPreviewData,
hasLargePreviewActionButton,
    actionButtonVisible,
    actionButtonProps,
    actionButtonCss,
bvid,
    cid,
    uniqId,
    sharedEmitter,
aspectRatioFromItem,
    cover,
    cardRef,
    videoCardAsTriggerRef
  }) {
    const {
      useMp4,
      useVideoCardAsTrigger,
      usePreferredCdn
    } = useSnapshot(settings.videoCard.videoPreview);
    const videoPreviewDataBox = useRefStateBox(void 0);
    const tryFetchVideoPreviewData = useLockFn(async () => {
      if (!shouldFetchPreviewData) return;
      if (isVideoPreviewDataValid(videoPreviewDataBox.val)) return;
      const data2 = await fetchVideoPreviewData({
        bvid,
        cid,
        useMp4,
        usePreferredCdn,
        aspectRatioFromItem
      });
      videoPreviewDataBox.set(data2);
    });
    useUpdateEffect(() => {
      videoPreviewDataBox.set(void 0);
    }, [useMp4, usePreferredCdn]);
    const $req = useRequest(tryFetchVideoPreviewData, {
      manual: true,
      loadingDelay: 100
});
    const [visible, setVisible] = H.useState(false);
    const triggerAction = useRefStateBox(void 0);
    const triggerElement = useRefStateBox(void 0);
    const hideAt = useRefStateBox(void 0);
    const hoveringRef = useRefBox({});
    const isRecentlyHidden = useMemoizedFn(() => {
      if (!hideAt.val) return false;
      return Date.now() - hideAt.val < 1200;
    });
    const enterTimer = H.useRef(void 0);
    const leaveTimer = H.useRef(void 0);
    const clearTimers = useMemoizedFn(() => {
      clearTimerRef(enterTimer);
      clearTimerRef(leaveTimer);
    });
    const showBy = useMemoizedFn((action2, el) => {
      setVisible(true);
      triggerAction.set(action2);
      triggerElement.set(el);
      sharedEmitter.emit("show-large-preview", uniqId);
      hideAt.set(void 0);
    });
    const hide = useMemoizedFn(() => {
      setVisible(false);
      triggerAction.set(void 0);
      triggerElement.set(void 0);
      hideAt.set(Date.now());
    });
    useEmitterOn(sharedEmitter, "show-large-preview", (srcUniqId) => {
      if (srcUniqId === uniqId) return;
      clearTimers();
      hide();
    });
    const onMouseEnter = useMemoizedFn((triggerEl) => {
      hoveringRef.set({
        ...hoveringRef.val,
        [triggerEl]: true
      });
      if (triggerAction.val === "click") return;
      $req.run();
      clearTimers();
      let delayMs = 0;
      if (triggerEl === "video-card-action-button") delayMs = 200;
      if (triggerEl === "video-card") delayMs = 1e3;
      if (!delayMs) {
        showBy("hover", triggerEl);
      } else {
        enterTimer.current = setTimeout(() => showBy("hover", triggerEl), delayMs);
      }
    });
    const onMouseLeave = useMemoizedFn((triggerEl) => {
      hoveringRef.set({
        ...hoveringRef.val,
        [triggerEl]: false
      });
      if (triggerAction.val === "click") return;
      const checkHide = () => {
        if (hoveringRef.val.popover) return;
        if (hoveringRef.val["video-card-action-button"]) return;
        hide();
      };
      clearTimers();
      if (triggerEl === "video-card-action-button" || triggerEl === "video-card" || triggerEl === "popover") {
        leaveTimer.current = setTimeout(checkHide, 250);
      } else {
        checkHide();
      }
    });
    const onClick = useMemoizedFn((el) => {
      clearTimers();
      if (triggerAction.val === "click") {
        hide();
      } else {
        showBy("click", el);
      }
    });
    const getLargePreviewCurrentTime = useMemoizedFn(() => {
      if (!currentTimeRef.current) return;
      return Math.floor(currentTimeRef.current);
    });
    const shouldUseLargePreviewCurrentTime = useMemoizedFn(() => {
      if (visible) return true;
      if (isRecentlyHidden()) return true;
      return false;
    });
    const onOpenInNewTab = useMemoizedFn(() => {
      if (!bvid) return;
      const u2 = new URL(`https://${BiliDomain.Main}/video/${bvid}`);
      const t2 = getLargePreviewCurrentTime();
      if (t2) u2.searchParams.set("t", t2.toString());
      openNewTab(u2.href);
      videoRef.current?.pause();
      hide();
    });
    const usingAspectRatio = H.useMemo(() => {
      return getRecItemDimension({
        dimensionFromApi: videoPreviewDataBox.state?.dimension
      })?.aspectRatio ?? aspectRatioFromItem;
    }, [videoPreviewDataBox.state?.dimension]);
    const videoRef = H.useRef(null);
    const currentTimeRef = H.useRef(void 0);
    const largePreviewRef = H.useRef(null);
    const willRenderLargePreview = visible && !!videoPreviewDataBox.state?.playUrls?.length;
    const largePreviewEl = willRenderLargePreview && jsxs(LargePreview, { ref: largePreviewRef, aspectRatio: usingAspectRatio, onMouseEnter: (e2) => onMouseEnter("popover"), onMouseLeave: (e2) => onMouseLeave("popover"), children: [
jsx$1(
        RecoverableVideo,
        {
          ref: videoRef,
          currentTimeRef,
          autoPlay: true,
          controls: true,
          loop: true,
          poster: cover,
          className: "size-full object-contain",
          children: videoPreviewDataBox.state?.playUrls?.map((url, i2) => jsx$1("source", { src: url }, i2))
        }
      ),
jsxs("div", { className: "absolute right-10px top-10px flex flex-row-reverse items-center justify-start gap-x-5px", children: [
        triggerAction.state === "click" ? jsx$1(VideoCardActionButton, { inlinePosition: "right", icon: jsx$1(ForwardRef$F, { className: "size-14px" }), tooltip: "关闭", onClick: (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
          hide();
        } }) : jsx$1(VideoCardActionButton, { inlinePosition: "right", icon: jsx$1(ForwardRef$l, { className: "size-14px" }), tooltip: "固定", onClick: (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
          onClick("popover-action-button");
        } }),
jsx$1(VideoCardActionButton, { inlinePosition: "right", icon: jsx$1(ForwardRef$G, { className: "size-14px" }), tooltip: "新窗口打开", onClick: (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
          onOpenInNewTab();
        } })
      ] })
    ] });
    const largePreviewActionButtonEl = hasLargePreviewActionButton && shouldFetchPreviewData && jsx$1(VideoCardActionButton, { css: actionButtonCss, ...actionButtonProps, visible: actionButtonVisible, active: willRenderLargePreview, inlinePosition: "right", icon: $req.loading ? jsx$1(IconForLoading, { className: "size-16px" }) : jsx$1(ForwardRef$k, { className: "size-15px" }), tooltip: triggerAction.state === "click" ? visible ? "关闭浮动预览" : "浮动预览" : "浮动预览", onMouseEnter: (e2) => onMouseEnter("video-card-action-button"), onMouseLeave: (e2) => onMouseLeave("video-card-action-button"), onClick: (e2) => {
      e2.preventDefault();
      e2.stopPropagation();
      onClick("video-card-action-button");
    } }, "video-card-action-button");
    useKeyPress("esc", () => {
      if (shouldDisableShortcut()) return;
      hide();
    }, {
      exactMatch: true
    });
    useClickAway(() => hide(), [
      cardRef ? () => cardRef?.current?.closest(`.${APP_CLS_CARD}`) : void 0,
largePreviewRef
].filter(Boolean));
    useEventListener("fullscreenchange", () => {
      if (!document.fullscreenElement) return;
      if (!visible || triggerAction.val === "click") return;
      if (document.fullscreenElement === videoRef.current) {
        showBy("click", "popover-video-fullscreen-button");
      }
    }, {
      target: document
    });
    const emptyRef = H.useRef(null);
    const target = videoCardAsTriggerRef || emptyRef;
    useEventListener("mouseenter", () => {
      if (!useVideoCardAsTrigger || !videoCardAsTriggerRef) return;
      onMouseEnter("video-card");
    }, {
      target
    });
    useEventListener("mouseleave", () => {
      if (!useVideoCardAsTrigger || !videoCardAsTriggerRef) return;
      onMouseLeave("video-card");
    }, {
      target
    });
    return {
      largePreviewActionButtonEl,
      largePreviewEl,
      getLargePreviewCurrentTime,
      shouldUseLargePreviewCurrentTime,
      largePreviewVisible: visible,
      hideLargePreview: hide
    };
  }
  function tweakColorWithOklch(originalColor, {
    l: l2,
    c: c2,
    h: h2,
    alpha,
    deltaL,
    deltaC,
    deltaH,
    deltaAlpha
  } = {}) {
    const lValue = l2 ?? (deltaL ? `calc(l + ${deltaL})` : "l");
    const cValue = c2 ?? (deltaC ? `calc(c + ${deltaC})` : "c");
    const hValue = h2 ?? (deltaH ? `calc(h + ${deltaH})` : "h");
    const alphaValue = alpha ?? (deltaAlpha ? `calc(alpha + ${deltaAlpha})` : "");
    const alphaComponent = alphaValue ? `/ ${alphaValue}` : "";
    return `oklch(from ${originalColor} ${[lValue, cValue, hValue, alphaComponent].filter(Boolean).join(" ")})`;
  }
  function tweakLightness(originalColor, delta) {
    return tweakColorWithOklch(originalColor, {
      deltaL: delta
    });
  }
  const c = tweakLightness(primaryColorValue, 0.1);
  const Styles = {
    normalBorder: css("border-color:", borderColorValue, ";", ""),
    activeBorder: css("border-color:", primaryColorValue, ";box-shadow:0px 0px 9px 4px ", c, ";", ""),
    rounded: css("border-radius:", videoCardBorderRadiusValue, ";", ""),
    bgLv1: css("background-color:", bgLv1Value, ";", ""),
coverZoomEffect: {
      name: "dj03ws",
      styles: ".bili-video-card__cover{transform-origin:center center;transition:transform 0.2s ease-out;transform:scale(1.05);}"
    }
  };
  const multiSelectedCss = css(Styles.activeBorder, " &:hover{", Styles.activeBorder, ";}", "");
  function useBlockedCardCss(isBlockedCard) {
    const sepIdentifier = `--${APP_NAMESPACE}-separator-color`;
    return H.useMemo(() => {
      if (!isBlockedCard) return void 0;
      return css`
      ${Styles.rounded}
      ${Styles.normalBorder}

      background-color: ${bgValue};
      ${sepIdentifier}:  ${bgLv1Value};
      &:hover {
        background-color: ${bgLv1Value};
        ${sepIdentifier}: ${bgLv2Value};
      }

      /* disable padding */
      margin-inline: 0;
      .bili-video-card__wrap {
        padding: 0;
      }
    `;
    }, [isBlockedCard]);
  }
  var _ref$3 = {
    name: "7dle4o",
    styles: "border:1px solid transparent;transition-property:border-color,box-shadow,background-color;transition-duration:0.3s;transition-timing-function:ease-in-out"
  };
  function useCardBorderCss() {
    const {
      useDelayForHover,
      style: {
        videoCard: {
          useBorder,
          useBorderOnlyOnHover,
          useBoxShadow
        },
        pureRecommend: {
          cardDisplay
        }
      }
    } = useSettingsSnapshot();
    const {
      multiSelecting
    } = useSnapshot(multiSelectStore);
    return H.useMemo(() => {
      return [_ref$3, (multiSelecting || useBorder && !isDisplayAsList(cardDisplay)) && [
css("cursor:pointer;", Styles.rounded, " &:hover{", Styles.bgLv1, " ", Styles.normalBorder, " ", useBoxShadow && Styles.activeBorder, " ", useDelayForHover && Styles.coverZoomEffect, ";}", ""),
(multiSelecting || !useBorderOnlyOnHover) && Styles.normalBorder
      ]];
    }, [useBorder, useBorderOnlyOnHover, useBoxShadow, useDelayForHover, cardDisplay, multiSelecting]);
  }
  function getActiveCardBorderCss(active) {
    return active && [Styles.rounded, Styles.activeBorder];
  }
  const skeletonActive = "_skeleton-active_wlycr_12";
  const follow = followActionFactory("follow");
  const unfollow = followActionFactory("unfollow");
  const UserfollowService = {
    follow,
    unfollow
  };
  function followActionFactory(action2) {
    const act = action2 === "follow" ? 1 : 2;
    return async function followAction(upMid) {
      const success = await modifyRelations(upMid, act);
      return success;
    };
  }
  function useInitFavContext(item, avid) {
    const [folderNames, setFolderNames] = H.useState(void 0);
    const [folderUrls, setFolderUrls] = H.useState(void 0);
    const [folderIds, setFolderIds] = H.useState(void 0);
    const updateFavFolderNames = useMemoizedFn(async () => {
      if (item.api !== "watchlater") return;
      if (!avid) return;
      const result = await UserFavService.getVideoFavState(avid);
      if (result) {
        setFolderNames(result.favFolderNames);
        setFolderUrls(result.favFolderUrls);
        setFolderIds(result.favFolderIds);
      }
    });
    return H.useMemo(() => ({
      folderNames,
      folderUrls,
      folderIds,
      updateFavFolderNames
    }), [folderNames, folderUrls, folderIds, updateFavFolderNames]);
  }
  function getWatchlaterTabFavMenus(ctx, item, avid) {
    if (!isWatchlater(item) || !avid) return [];
    const folderNames = ctx.folderNames ?? [];
    const folderUrls = ctx.folderUrls ?? [];
    const folderIds = ctx.folderIds ?? [];
    const favedMenus = defineAntMenus([{
key: "watchlater-faved:browse-fav-folder",
      icon: jsx$1(IconForFaved, { className: "size-15px color-gate-primary" }),
      label: `已收藏在 ${(folderNames || []).map((n2) => `「${n2}」`).join("")}`,
      onClick() {
        folderUrls.forEach((u2) => {
          window.open(u2, getLinkTarget());
        });
      }
    }, {
key: "watchlater-faved:move-fav",
      icon: jsx$1(ForwardRef$m, { className: "size-13px" }),
      label: "移动到其他收藏夹",
      async onClick() {
        const resource = `${avid}:2`;
        const srcFavFolderId = folderIds[0];
        if (folderIds.length > 1) {
          const otherFolderIds = folderIds.slice(1);
          const otherFolderNames = folderNames.slice(1);
          for (const [index, fid] of otherFolderIds.entries()) {
            const success = await UserFavService.removeFavs(fid, resource);
            if (!success) {
              const fname = otherFolderNames[index];
              antMessage.warning(`从收藏夹「${fname}」移除失败!`);
            }
          }
        }
        await pickFavFolder(srcFavFolderId, async (targetFolder) => {
          const success = await UserFavService.moveFavs(resource, srcFavFolderId, targetFolder.id);
          if (!success) return;
          clearFavFolderAllItemsCache(srcFavFolderId);
          clearFavFolderAllItemsCache(targetFolder.id);
          antMessage.success(`已移动到「${targetFolder.title}」收藏夹`);
          return success;
        });
      }
    }]);
    const unfavedMenus = defineAntMenus([{
key: "watchlater:add-quick-fav",
      icon: jsx$1(IconForFav, { className: "size-15px" }),
      label: "收藏到「默认收藏夹」",
      async onClick() {
        const success = await UserFavService.addFav(avid);
        if (success) {
          antMessage.success(`已加入收藏夹「${defaultFavFolderTitle}」`);
        }
      }
    }, {
key: "watchlater:add-fav",
      icon: jsx$1(IconForFav, { className: "size-15px" }),
      label: "收藏到",
      async onClick() {
        await pickFavFolder(void 0, async (targetFolder) => {
          const success = await UserFavService.addFav(avid, targetFolder.id);
          if (success) antMessage.success(`已加入收藏夹「${targetFolder.title}」`);
          return success;
        });
      }
    }]);
    const faved = !!folderNames.length;
    return faved ? favedMenus : unfavedMenus;
  }
  function getFavTabMenus({
    item,
    cardData,
    tab: tab2,
    multiSelectingAppendix,
    onRemoveCurrent
  }) {
    if (!isFav(item)) return [];
    if (item.from === "fav-folder") {
      return defineAntMenus([{
        key: "open-fav-folder",
        label: "浏览收藏夹",
        icon: jsx$1(IconForOpenExternalLink, { className: "size-15px" }),
        onClick() {
          const {
            id
          } = item.folder;
          const url = tab2 !== ETab.Fav || favStore.selectedKey === "all" && favStore.usingShuffle ? `/?${FavQueryKey.FolderIdFull}=${id}` : formatFavFolderUrl(id);
          window.open(url, getLinkTarget());
        }
      }, {
        key: "move-fav",
        label: `移动到其他收藏夹${multiSelectingAppendix}`,
        icon: jsx$1(ForwardRef$m, { className: "size-13px" }),
        async onClick() {
          let resources;
          let srcFavFolderId;
          let uniqIds;
          let titles;
          if (multiSelectStore.multiSelecting) {
            const selectedFavItems = getMultiSelectedItems().filter((x) => isFav(x) && x.from === "fav-folder");
            const folderIds = new Set(selectedFavItems.map((i2) => i2.folder.id));
            if (!folderIds.size) {
              return toast("至少选择一项视频");
            }
            if (folderIds.size > 1) {
              return toast("多选移动: 只能批量移动同一源收藏夹下的视频");
            }
            srcFavFolderId = selectedFavItems[0].folder.id;
            resources = selectedFavItems.map((x) => `${x.id}:${x.type}`);
            uniqIds = selectedFavItems.map((x) => x.uniqId);
            titles = selectedFavItems.map((x) => x.title);
          } else {
            resources = `${item.id}:${item.type}`;
            srcFavFolderId = item.folder.id;
            uniqIds = [item.uniqId];
            titles = [item.title];
          }
          await pickFavFolder(item.folder.id, async (targetFolder) => {
            const success = await UserFavService.moveFavs(resources, srcFavFolderId, targetFolder.id);
            if (!success) return;
            clearFavFolderAllItemsCache(item.folder.id);
            clearFavFolderAllItemsCache(targetFolder.id);
            currentGridSharedEmitter.emit("remove-cards", [uniqIds, titles, true]);
            antMessage.success(`已移动 ${uniqIds.length} 个视频到「${targetFolder.title}」收藏夹`);
            return success;
          });
        }
      }, {
        key: "remove-fav",
        label: "移除收藏",
        icon: jsx$1(ForwardRef$10, { className: "size-15px" }),
        async onClick() {
          const confirm = await antModal.confirm({
            centered: true,
            title: "移除收藏",
            content: jsxs(Fragment, { children: [
              "确定将视频「",
              item.title,
              "」",
jsx$1("br", {}),
              "从收藏夹「",
              item.folder.title,
              "」中移除?"
            ] })
          });
          if (!confirm) return;
          const resource = `${item.id}:${item.type}`;
          const success = await UserFavService.removeFavs(item.folder.id, resource);
          if (!success) return;
          clearFavFolderAllItemsCache(item.folder.id);
          onRemoveCurrent?.(item, cardData);
        }
      }]);
    }
    if (item.from === "fav-collection") {
      return defineAntMenus([{
        key: "open-fav-collection",
        label: "浏览合集",
        icon: jsx$1(IconForOpenExternalLink, { className: "size-15px" }),
        onClick() {
          const {
            id
          } = item.collection;
          const url = tab2 !== ETab.Fav || favStore.selectedKey === "all" && favStore.usingShuffle ? `/?${FavQueryKey.CollectionIdFull}=${id}` : formatFavCollectionUrl(id);
          window.open(url, getLinkTarget());
        }
      }]);
    }
    return [];
  }
  const iconParkOutlineAddTwo = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M33 7.263A18.9 18.9 0 0 0 24 5C13.507 5 5 13.507 5 24s8.507 19 19 19a18.9 18.9 0 0 0 8-1.761" }),
jsx$1("path", { strokeLinejoin: "round", d: "M31 30h12m-28-8l7 7l19-18m-4 13v12" })
    ] })
  ] });
  const ForwardRef$j = H.forwardRef(iconParkOutlineAddTwo);
  const iconParkOutlinePeopleMinus = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", children: [
jsx$1("path", { stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, d: "M19 20a7 7 0 1 0 0-14a7 7 0 0 0 0 14Z" }),
jsx$1("path", { d: "M30 35h12z", clipRule: "evenodd" }),
jsx$1("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "M30 35h12m-15-7h-8.2c-4.48 0-6.72 0-8.432.872a8 8 0 0 0-3.496 3.496C6 34.08 6 36.32 6 40.8V42h21" })
    ] })
  ] });
  const ForwardRef$i = H.forwardRef(iconParkOutlinePeopleMinus);
  const letsIconsViewHide = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", children: [
jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M15.92 12.799Q16 12.41 16 12a4 4 0 0 0-4.799-3.92zM8.667 9.788a4 4 0 0 0 5.545 5.545l-1.474-1.474a2 2 0 0 1-2.597-2.597z", clipRule: "evenodd" }),
jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "m16.52 17.64l-1.47-1.469c-.972.51-2.002.829-3.05.829c-1.526 0-3.014-.678-4.34-1.632c-1.32-.95-2.396-2.112-3.076-2.938c-.1-.121-.174-.212-.236-.291a2 2 0 0 1-.1-.139q.028-.045.1-.139c.062-.08.136-.17.236-.291c.665-.808 1.71-1.938 2.99-2.875l-1.43-1.43C4.797 8.297 3.723 9.47 3.04 10.3l-.073.088c-.314.375-.737.883-.737 1.613s.423 1.238.737 1.613l.073.088c.74.899 1.94 2.203 3.451 3.29C7.994 18.073 9.891 19 12 19c1.67 0 3.206-.581 4.52-1.36M8.806 5.686C9.79 5.269 10.864 5 12 5c2.11 0 4.006.927 5.509 2.009c1.51 1.087 2.711 2.391 3.45 3.29l.074.088c.314.375.737.883.737 1.613s-.423 1.238-.737 1.613l-.073.088a20.5 20.5 0 0 1-2.015 2.123l-1.416-1.416a18.5 18.5 0 0 0 2.123-2.27a2 2 0 0 0 .1-.138a2 2 0 0 0-.1-.139a14 14 0 0 0-.236-.291c-.68-.826-1.756-1.989-3.075-2.938C15.014 7.678 13.526 7 12 7c-.551 0-1.097.088-1.632.246z", clipRule: "evenodd" }),
jsx$1("path", { stroke: "currentColor", strokeWidth: 2, d: "m5 2l16 16" })
    ] })
  ] });
  const ForwardRef$h = H.forwardRef(letsIconsViewHide);
  function useContextMenus({
    item,
    cardData,
    tab: tab2,
    isNormalVideo,
    onRefresh,
    favContext,
    watchlaterContext,
    hasDislikeEntry,
    onTriggerDislike,
    onMoveToFirst,
    onRemoveCurrent,
    consistentOpenMenus,
    conditionalOpenMenus,
    multiSelecting
  }) {
    const {
      avid,
      bvid,
      cover,
      href,
      recommendReason,
authorName,
      authorMid
    } = cardData;
    const {
      enableHideSomeContents
    } = useSnapshot(settings.dynamicFeed.whenViewAll);
    const onCopyLink = useMemoizedFn(() => {
      let content = href;
      if (href.startsWith("/")) {
        content = new URL(href, location.href).href;
      }
      copyContent(content);
    });
    const hasBlacklistEntry = !!authorMid && isApiRecLike(item.api) && tab2 !== ETab.KeepFollowOnly;
    const onBlacklistUp = useMemoizedFn(async () => {
      if (!authorMid) return antMessage.error("UP mid 为空!");
      const success = await UserBlacklistService.add(authorMid);
      if (success) {
        antMessage.success(`已加入黑名单: ${authorName}`);
      }
    });
    const onAddUpToFilterList = useMemoizedFn(async () => {
      if (!authorMid) return antMessage.error("UP mid 为空!");
      const content = `${authorMid}`;
      if (settings.filter.byAuthor.keywords.includes(content)) {
        return toast(`已在过滤名单中: ${content}`);
      }
      await updateSettingsInnerArray("filter.byAuthor.keywords", {
        add: [content]
      });
      if (authorName) setNicknameCache(authorMid, authorName);
      antMessage.success(`已加入过滤名单: ${authorName || authorMid}`);
    });
    const followed = item.api === EApiType.DynamicFeed || (item.api === EApiType.AppRecommend || item.api === EApiType.PcRecommend) && getFollowedStatus$1(recommendReason);
    const hasUnfollowEntry = followed;
    const onUnfollowUp = useMemoizedFn(async () => {
      if (!authorMid) return;
      const confirm = await antModal.confirm({
        centered: true,
        title: "取消关注",
        content: jsxs(Fragment, { children: [
          "确定取消关注「",
          authorName,
          "」?"
        ] })
      });
      if (!confirm) return;
      const success = await UserfollowService.unfollow(authorMid);
      if (success) {
        antMessage.success("已取消关注");
      }
    });
    const hasViewUpVideoListEntry = (isNormalVideo || isLive(item)) && !!authorMid && !!authorName;
    const onViewUpDyn = useMemoizedFn(() => {
      if (!hasViewUpVideoListEntry) return;
      const u2 = `/?${DynamicFeedQueryKey.Mid}=${authorMid}`;
      openNewTab(u2);
    });
    const onViewUpSpaceUpload = useMemoizedFn(() => {
      if (!hasViewUpVideoListEntry) return;
      const u2 = `/?${SpaceUploadQueryKey.Mid}=${authorMid}`;
      openNewTab(u2);
    });
    const hasEntry_addMidTo_dynamicFeedWhenViewAllHideIds = enableHideSomeContents && isDynamicFeed(item) && dfStore.selectedKey === DF_SELECTED_KEY_ALL && !!authorMid;
    const onAddMidTo_dynamicFeedWhenViewAllHideIds = useMemoizedFn(async () => {
      if (!hasEntry_addMidTo_dynamicFeedWhenViewAllHideIds) return;
      await updateSettingsInnerArray("dynamicFeed.whenViewAll.hideIds", {
        add: [DF_SELECTED_KEY_PREFIX_UP + authorMid]
      });
      setNicknameCache(authorMid, authorName || "");
      antMessage.success(`在「全部」动态中隐藏【${authorName}】的动态`);
    });
    const hasEntry_dynamicFeed_offsetAndMinId = !!(isDynamicFeed(item) && QUERY_DYNAMIC_UP_MID && dfStore.viewingSomeUp && authorMid);
    const dynamicViewStartFromHere = H.useMemo(() => hasEntry_dynamicFeed_offsetAndMinId && {
      label: "动态: 从此项开始查看",
      key: "动态: 从此项开始查看",
      icon: jsx$1(ForwardRef$12, { className: "size-17px" }),
      onClick() {
        const u2 = new URL("/", location.href);
        u2.searchParams.set(DynamicFeedQueryKey.Mid, authorMid);
        const currentIndexInGrid = currentGridItems.findIndex((x) => x.api === EApiType.DynamicFeed && x.id_str === item.id_str);
        const prevIdStr = currentGridItems[currentIndexInGrid - 1]?.id_str || item.id_str;
        u2.searchParams.set(DynamicFeedQueryKey.Offset, prevIdStr);
        openNewTab(u2.href);
      }
    }, [hasEntry_dynamicFeed_offsetAndMinId, item]);
    const dynamicViewUpdateSinceThis = H.useMemo(() => hasEntry_dynamicFeed_offsetAndMinId && {
      icon: jsx$1(ForwardRef$13, { className: "size-17px" }),
      label: "动态: 从此项开始截止",
      key: "动态: 从此项开始截止",
      onClick() {
        const u2 = new URL("/", location.href);
        u2.searchParams.set(DynamicFeedQueryKey.Mid, authorMid);
        u2.searchParams.set(DynamicFeedQueryKey.MinId, item.id_str);
        openNewTab(u2.href);
      }
    }, [hasEntry_dynamicFeed_offsetAndMinId, item]);
    const spaceUploadViewStartFromHere = H.useMemo(() => SHOW_SPACE_UPLOAD_ONLY && isSpaceUpload(item) && !!item.page && {
      key: "space-upload-view-start-from-here",
      label: `投稿: 从此页开始查看 (当前第${item.page}页)`,
      icon: jsx$1(ForwardRef$12, { className: "size-17px" }),
      onClick() {
        const u2 = new URL(location.href);
        u2.searchParams.set(SpaceUploadQueryKey.InitialPage, item.page.toString());
        openNewTab(u2.href);
      }
    }, [SHOW_SPACE_UPLOAD_ONLY, item]);
    return H.useMemo(() => {
      const {
        watchlaterAdded,
        hasWatchlaterEntry,
        onToggleWatchlater
      } = watchlaterContext;
      const divider = {
        type: "divider"
      };
      const multiSelectingAppendix = multiSelecting ? " (多选)" : "";
      const copyMenus = defineAntMenus([{
        key: "copy-link",
        label: `复制视频链接${multiSelectingAppendix}`,
        icon: jsx$1(IconForCopy, { className: "size-15px" }),
        onClick() {
          if (multiSelectStore.multiSelecting) {
            copyVideoLinks();
          } else {
            onCopyLink();
          }
        }
      }, {
        test: !!bvid,
        key: "copy-bvid",
        label: `复制 BVID${multiSelectingAppendix}`,
        icon: jsx$1(IconForCopy, { className: "size-15px" }),
        onClick() {
          if (multiSelectStore.multiSelecting) {
            copyBvidsSingleLine();
          } else {
            copyContent(bvid);
          }
        }
      }, {
        test: !!bvid && settings.__internalEnableCopyBvidInfo,
        key: "copy-bvid-info",
        label: `复制 BVID 信息${multiSelectingAppendix}`,
        icon: jsx$1(IconForCopy, { className: "size-15px" }),
        onClick() {
          if (multiSelectStore.multiSelecting) {
            copyBvidInfos();
          } else {
            copyContent(getBvidInfo(cardData));
          }
        }
      }, {
        test: !!cover,
        key: "view-cover",
        label: "查看封面",
        icon: jsx$1(IconForOpenExternalLink, { className: "size-16px" }),
        onClick() {
          if (!cover) return;
          const url = cover;
          openNewTab(url);
        }
      }]);
      const interestedMenus = defineAntMenus([
        {
          test: hasViewUpVideoListEntry,
          key: "view-up-space-upload",
          label: `查看 UP 的投稿`,
          icon: jsx$1(IconForSpaceUpload, { className: "size-15px" }),
          onClick: onViewUpSpaceUpload
        },
spaceUploadViewStartFromHere,
        {
          test: hasViewUpVideoListEntry && followed,
          key: "view-up-dyn",
          label: `查看 UP 的动态`,
          icon: jsx$1(IconForDynamicFeed, { className: "size-15px" }),
          onClick: onViewUpDyn
        },
        {
          test: hasWatchlaterEntry,
          key: "watchlater",
          label: watchlaterAdded ? "移除稍后再看" : "稍后再看",
          icon: watchlaterAdded ? jsx$1(IconForRemove, { className: "size-15px" }) : jsx$1(IconForWatchlater, { className: "size-15px" }),
          onClick() {
            onToggleWatchlater();
          }
        },
        {
          test: hasWatchlaterEntry && watchlaterAdded,
          key: "watchlater-readd",
          label: `重新添加稍候再看${tab2 === ETab.Watchlater ? " (移到最前)" : ""}`,
          icon: jsx$1(ForwardRef$j, { className: "size-15px" }),
          async onClick() {
            const {
              success
            } = await onToggleWatchlater(void 0, watchlaterAdd);
            if (!success) return;
            antMessage.success("已重新添加");
            if (tab2 === ETab.Watchlater) {
              onMoveToFirst?.(item, cardData);
            }
          }
        },
        ...getWatchlaterTabFavMenus(favContext, item, avid),
dynamicViewUpdateSinceThis,
        dynamicViewStartFromHere
      ]);
      const dislikeMenus = defineAntMenus([{
        test: hasDislikeEntry,
        key: "dislike",
        label: "我不想看",
        icon: jsx$1(IconForDislike, { width: 15, height: 15 }),
        onClick() {
          onTriggerDislike();
        }
      }, {
        test: hasUnfollowEntry,
        key: "unfollow-up",
        label: "取消关注",
        icon: jsx$1(ForwardRef$i, { className: "size-15px" }),
        onClick: onUnfollowUp
      }, {
        test: hasEntry_addMidTo_dynamicFeedWhenViewAllHideIds,
        key: "hasEntry_addMidTo_dynamicFeedWhenViewAllHideIds",
        label: "在「全部」动态中隐藏 UP 的动态",
        icon: jsx$1(ForwardRef$h, { className: "size-15px" }),
        onClick: onAddMidTo_dynamicFeedWhenViewAllHideIds
      }, {
        test: hasBlacklistEntry,
        key: "blacklist-up",
        label: "将 UP 加入黑名单",
        icon: jsx$1(IconForBlacklist, { className: "size-15px" }),
        onClick: onBlacklistUp
      }, {
        test: hasBlacklistEntry,
        key: "add-up-to-filterlist",
        label: "将 UP 加入过滤列表",
        icon: jsx$1(IconForBlacklist, { className: "size-15px" }),
        onClick: onAddUpToFilterList
      }]);
      const favTabMenus = getFavTabMenus({
        item,
        cardData,
        tab: tab2,
        multiSelectingAppendix,
        onRemoveCurrent
      });
      return defineAntMenus([...consistentOpenMenus, !!copyMenus.length && divider, ...copyMenus, !!interestedMenus.length && divider, ...interestedMenus, !!dislikeMenus.length && divider, ...dislikeMenus, !!favTabMenus.length && divider, ...favTabMenus, !!conditionalOpenMenus.length && divider, ...conditionalOpenMenus]);
    }, [
      item,
      cardData,
      tab2,
watchlaterContext,
      favContext,
hasDislikeEntry,
      hasUnfollowEntry,
      hasBlacklistEntry,
      hasViewUpVideoListEntry,
      hasEntry_addMidTo_dynamicFeedWhenViewAllHideIds,
consistentOpenMenus,
      conditionalOpenMenus,
multiSelecting
    ]);
  }
  function showNativeContextMenuWhenAltKeyPressed(e2) {
    if (e2.altKey) {
      e2.stopPropagation();
      return true;
    }
  }
  const $now = valtioFactory(() => Date.now());
  const firstTimeout = (dayjs().add(1, "minute").startOf("minute").valueOf() - $now.get()) % 3e4;
  setTimeout(() => {
    $now.update();
    setInterval($now.update, 3e4);
  }, firstTimeout);
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState !== "visible") return;
    $now.update();
  });
  const UnixTsDisplay = H.memo(function UnixTsDisplay2({
    ts
  }) {
    if (!ts) return null;
    return isRecentTimeStamp(ts) ? jsx$1(ReactiveImpl, { ts }) : jsx$1(PlainImpl, { ts });
  });
  function PlainImpl({
    ts
  }) {
    return H.useMemo(() => formatRecentTimeStamp(ts), [ts]);
  }
  function ReactiveImpl({
    ts
  }) {
    const now = $now.use();
    return jsx$1(PlainImpl, { ts }, now);
  }
  const S = {
    recommendReason: {
      name: "svh8ho",
      styles: "display:inline-block;cursor:default;color:var(--Or5);background-color:var(--Or1);border-radius:4px;font-size:var(--follow-icon-font-size);line-height:var(--follow-icon-line-height);height:var(--follow-icon-line-height);width:max-content;max-width:calc(100% - 6px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-block:0;padding-inline:2px"
    },
    recommendReasonInList: {
      name: "125ka3i",
      styles: "margin-top:10px;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;text-overflow:ellipsis;height:auto;white-space:normal"
    },
    appBadge: {
      name: "1atx64h",
      styles: "color:#fa6a9d;border-radius:2px;border:1px #fa6a9d solid;line-height:20px;padding:0 10px;transform:scale(0.8);transform-origin:center left"
    }
  };
  const descOwnerCss = {
    name: "nux2qa",
    styles: "font-size:var(--subtitle-font-size);line-height:var(--subtitle-line-height);color:var(--text3);a&:visited{color:var(--text3);}display:inline-flex;width:max-content;max-width:100%;align-items:center;justify-content:flex-start"
  };
  var _ref$2 = {
    name: "15xw6zv",
    styles: "display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1;overflow:hidden;text-overflow:ellipsis;max-width:100%"
  };
  var _ref2$1 = {
    name: "feo88y",
    styles: ".bili-video-card .bili-video-card__info--tit>a&{font-family:inherit;font-weight:initial;}"
  };
  var _ref3 = {
    name: "1eyh0r6",
    styles: "text-indent:0!important;.bili-video-card &.bili-video-card__info--tit{padding-right:0;height:auto;max-height:calc(2 * var(--title-line-height));}"
  };
  const VideoCardBottom = H.memo(function({
    item,
    cardData,
    handleVideoLinkClick,
    className,
    cardDisplay
  }) {
    const {
      useBorder
    } = useSnapshot(settings.style.videoCard);
    const target = useLinkTarget();
    const displayingAsList = isDisplayAsList(cardDisplay);
    const {
goto,
      href,
      title,
      titleRender,
      pubts,
      pubdateDisplay,
      pubdateDisplayForTitleAttr,
      recommendReason,
authorName,
      authorFace,
      authorMid,
appBadge,
      appBadgeDesc,
      rankingDesc,
      liveExtraDesc
    } = cardData;
    const isNormalVideo = goto === "av";
    const authorHref = authorMid ? formatSpaceUrl(authorMid) : href;
    const streaming = item.api === EApiType.Live && item.live_status === ELiveStatus.Streaming;
    const {
      data: pubtsFromApi
    } = useRequest(() => fetchAppRecommendFollowedPubDate(item, cardData), {
      refreshDeps: [item, cardData]
    });
    const descTitleAttribute = H.useMemo(() => {
      if (isNormalVideo && (authorName || pubts || pubtsFromApi || pubdateDisplay || pubdateDisplayForTitleAttr)) {
        let datePartForTitleAttribute;
        if (pubts || pubtsFromApi) {
          datePartForTitleAttribute = dayjs.unix(pubts || pubtsFromApi).format("YYYY年M月D日 HH:mm");
        } else {
          datePartForTitleAttribute = pubdateDisplay;
        }
        return [authorName, pubdateDisplayForTitleAttr || datePartForTitleAttribute].filter(Boolean).join(" · ");
      }
    }, [isNormalVideo, authorName, pubts, pubtsFromApi, pubdateDisplay, pubdateDisplayForTitleAttr]);
    return jsxs("div", { className: clsx(!displayingAsList ? "pt-15px" : "pt-5px", "flex gap-x-5px overflow-hidden px-5px", useBorder ? "mb-10px" : "mb-5px", className), children: [
      !!authorMid && jsxs("a", { href: authorHref, target, className: clsx("relative flex-center self-start rounded-full p-1px ring-1px", streaming ? "ring-gate-primary" : "ring-gate-border"), children: [
        authorFace ? jsx$1(antd.Avatar, { src: getAvatarSrc(authorFace) }) : jsx$1(antd.Avatar, { children: authorName?.[0] || appBadgeDesc?.[0] || "" }),
        streaming && jsx$1(IconForLive, { active: true, className: "absolute bottom-0 right-0 size-12px rounded-full bg-gate-primary" })
      ] }),
jsxs(
        "div",
        {
          className: "ml-5px flex flex-1 flex-col gap-y-4px overflow-hidden",
          children: [
jsx$1("h3", { className: "bili-video-card__info--tit", title, css: _ref3, children: jsx$1("a", { onClick: handleVideoLinkClick, onContextMenu: showNativeContextMenuWhenAltKeyPressed, href, target, rel: "noopener", css: _ref2$1, children: titleRender ?? title }) }),
            renderDesc()
          ]
        }
      )
    ] });
    function renderDesc() {
      const recommendReasonEl = !!recommendReason && jsx$1("span", { className: APP_CLS_CARD_RECOMMEND_REASON, css: [S.recommendReason, displayingAsList && S.recommendReasonInList, "", ""], title: recommendReason, children: recommendReason });
      if (isNormalVideo) {
        let date;
        if (pubts || pubtsFromApi) {
          date = jsx$1(UnixTsDisplay, { ts: pubts || pubtsFromApi });
        } else if (pubdateDisplay) {
          date = pubdateDisplay;
        }
        return jsxs(Fragment, { children: [
jsxs("a", { className: "bili-video-card__info--owner", href: authorHref, target, title: descTitleAttribute, css: descOwnerCss, onContextMenu: showNativeContextMenuWhenAltKeyPressed, children: [
jsx$1("span", { className: "bili-video-card__info--author", children: authorName }),
            !!date && jsxs("span", { className: "bili-video-card__info--date", children: [
              DESC_SEPARATOR,
              date
            ] })
          ] }),
          recommendReasonEl
        ] });
      }
      if (appBadge || appBadgeDesc) {
        return jsxs("a", { className: "bili-video-card__info--owner", css: descOwnerCss, href, target, onContextMenu: showNativeContextMenuWhenAltKeyPressed, children: [
          !!appBadge && jsx$1("span", { css: S.appBadge, children: appBadge }),
          !!appBadgeDesc && jsx$1("span", { children: appBadgeDesc })
        ] });
      }
      if (isRank(item) && rankingDesc) {
        return jsx$1("div", { css: descOwnerCss, children: rankingDesc });
      }
      if (isLive(item) || isPcRecommend(item) && item.goto === PcRecGoto.Live) {
        return jsxs(Fragment, { children: [
jsxs("a", { css: [descOwnerCss, _ref$2, "", ""], href: authorHref, target, title: (authorName || "") + (liveExtraDesc || ""), onContextMenu: showNativeContextMenuWhenAltKeyPressed, children: [
            authorName,
            liveExtraDesc && jsx$1("span", { className: "ml-4px", children: liveExtraDesc })
          ] }),
          recommendReasonEl
        ] });
      }
    }
  });
  const iconParkOutlineDistraughtFace = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4S4 12.954 4 24s8.954 20 20 20Z" }),
jsx$1("path", { strokeLinecap: "round", d: "M24 29c5 0 7 4 7 4H17s2-4 7-4m8-12l-3 3l3 3m-16-6l3 3l-3 3" })
    ] })
  ] });
  const ForwardRef$g = H.forwardRef(iconParkOutlineDistraughtFace);
  const SkeletonCard = H.memo(function SkeletonCard2({
    loading
  }) {
    return jsxs("div", { className: clsx("bili-video-card__skeleton", {
      hide: !loading,
      [skeletonActive]: loading
    }), children: [
jsx$1("div", { className: "bili-video-card__skeleton--cover", style: {
        borderRadius: videoCardBorderRadiusValue
      } }),
jsxs("div", { className: "bili-video-card__skeleton--info px-5px", children: [
jsx$1("div", { className: "bili-video-card__skeleton--avatar size-32px rounded-full" }),
jsxs("div", { className: "bili-video-card__skeleton--right ml-10px flex-1", children: [
jsx$1("p", { className: "bili-video-card__skeleton--text" }),
jsx$1("p", { className: "bili-video-card__skeleton--text short" }),
jsx$1("p", { className: "bili-video-card__skeleton--light" }),
jsx$1("p", { className: "bili-video-card__skeleton--text tiny" })
        ] })
      ] })
    ] });
  });
  const blockedCardClassNames = {
wrapper: "h-full flex flex-col overflow-hidden",
    cover: "relative aspect-16/9 rounded-t-6px",
    coverInner: "absolute left-0 top-0 h-full w-full flex flex-col items-center justify-center",
    dislikeReason: "text-center font-size-20px",
    dislikeDesc: "text-center text-16px",
    action: "relative flex-1",
    actionInner: "absolute left-0 top-0 h-full w-full flex items-center justify-center b-t-1px b-t-[var(--bilibili-gate-separator-color)] b-t-solid transition-duration-300 transition-property-[border-color]",
    actionButton: "flex items-center p-15px text-16px color-inherit"
  };
  const DislikedCard = H.memo(function DislikedCard2({
    item,
    cardData,
    dislikedReason,
    emitter: emitter2 = defaultEmitter
  }) {
    const onCancelDislike = useMemoizedFn(async () => {
      if (!dislikedReason?.id) return;
      let success = false;
      let message2 = "";
      let err;
      try {
        ;
        ({
          success,
          message: message2
        } = await cancelDislike(item, dislikedReason.id));
      } catch (e2) {
        err = e2;
      }
      if (err) {
        console.error(err.stack || err);
        return toastRequestFail();
      }
      if (success) {
        antMessage.success("已撤销");
        delDislikeId(item.param);
      } else {
        antMessage.error(message2 || OPERATION_FAIL_MSG);
      }
    });
    useEmitterOn(emitter2, "cancel-dislike", onCancelDislike);
    return jsxs("div", { className: blockedCardClassNames.wrapper, children: [
jsx$1("div", { className: blockedCardClassNames.cover, children: jsxs("div", { className: blockedCardClassNames.coverInner, children: [
jsx$1(ForwardRef$g, { className: "mb-5px size-32px" }),
jsx$1("div", { className: blockedCardClassNames.dislikeReason, children: dislikedReason?.name }),
jsx$1("div", { className: blockedCardClassNames.dislikeDesc, children: dislikedReason?.toast || "将减少此类内容推荐" })
      ] }) }),
jsx$1(__BottomRevertAction, { item, cardData, onClick: onCancelDislike })
    ] });
  });
  function __BottomRevertAction({
    item,
    cardData,
    onClick
  }) {
    return jsxs("div", { className: blockedCardClassNames.action, children: [
jsx$1(VideoCardBottom, { item, cardData, className: "invisible" }),
jsx$1("div", { className: blockedCardClassNames.actionInner, children: jsxs("button", { className: blockedCardClassNames.actionButton, onClick, children: [
jsx$1(IconForReset, { className: "mr-4px mt--2px size-16px" }),
        "撤销"
      ] }) })
    ] });
  }
  const BlockedCard = H.memo(function BlockedCardInner({
    item,
    cardData,
    blockType
  }) {
    const {
      authorMid,
      authorName
    } = cardData;
    const label = blockType === "blacklist" ? "已拉黑" : "已加入过滤列表";
    const onCancel = useMemoizedFn(() => {
      return blockType === "blacklist" ? onCancelBlacklist() : onCancelFilter();
    });
    const onCancelBlacklist = useMemoizedFn(async () => {
      if (!authorMid) return;
      const success = await UserBlacklistService.remove(authorMid);
      if (success) antMessage.success(`已移出黑名单: ${authorName}`);
    });
    const onCancelFilter = useMemoizedFn(() => {
      if (!authorMid) return;
      const toRemove = settings.filter.byAuthor.keywords.filter((keyword) => parseUpRepresent(keyword).mid === authorMid);
      updateSettingsInnerArray("filter.byAuthor.keywords", {
        remove: toRemove
      });
      antMessage.success(`已移出过滤列表: ${authorName}`);
    });
    return jsxs("div", { className: blockedCardClassNames.wrapper, children: [
jsx$1("div", { className: blockedCardClassNames.cover, children: jsxs("div", { className: blockedCardClassNames.coverInner, children: [
jsx$1(IconForBlacklist, { className: "mb-5px size-32px" }),
jsx$1("div", { className: blockedCardClassNames.dislikeReason, children: label }),
jsxs("div", { className: blockedCardClassNames.dislikeDesc, children: [
          "UP: ",
          authorName
        ] })
      ] }) }),
jsx$1(__BottomRevertAction, { item, cardData, onClick: onCancel })
    ] });
  });
  const clsPreviewImageWrapper = clsx(
    "pointer-events-none absolute inset-0 overflow-hidden",
    clsZPreviewImageWrapper,
    "rounded-b-none rounded-t-gate-video-card"
);
  const PreviewImage = H.memo(H.forwardRef(function({
    videoDuration,
    pvideo,
    progress,
    t: t2,
    className,
    ...restProps
  }, ref) {
    const rootElRef = H.useRef(null);
    const [size, setSize] = H.useState(() => ({
      width: 0,
      height: 0
    }));
    useMount(() => {
      const rect = rootElRef.current?.getBoundingClientRect();
      if (!rect) return;
      setSize({
        width: rect.width,
        height: rect.height
      });
    });
    const usingProgress = H.useMemo(() => {
      function getProgress() {
        if (typeof progress === "number" && !Number.isNaN(progress)) return progress;
        return 0;
      }
      return minmax(getProgress() ?? 0, 0, 1);
    }, [progress]);
    const usingT = H.useMemo(() => t2 ?? Math.floor((videoDuration || 0) * usingProgress), [t2, videoDuration, usingProgress]);
    const getT = useMemoizedFn(() => usingT);
    H.useImperativeHandle(ref, () => ({
      getT
    }), [getT]);
    const innerProps = {
      progress: usingProgress,
      t: usingT,
      pvideo,
      elWidth: size.width,
      elHeight: size.height
    };
    return jsx$1("div", { ...restProps, ref: rootElRef, className: clsx(clsPreviewImageWrapper, className), children: !!(pvideo && size.width && size.height && usingProgress) && jsx$1(PreviewImageInner, { ...innerProps }) });
  }));
  const PreviewImageInner = H.memo(function PreviewImageInner2({
    t: t2,
    progress,
    pvideo,
    elWidth,
    elHeight
  }) {
    let index = H.useMemo(() => {
      return calcIndex(pvideo?.index || [], t2) ?? 0;
    }, [pvideo, t2]);
    const {
      img_x_len: colCount,
      img_y_len: rowCount,
      img_x_size: w,
      img_y_size: h2
    } = pvideo;
    const countPerPreview = rowCount * colCount;
    index = index + 1;
    const snapshotIndex = Math.floor(index / countPerPreview);
    const indexInSnapshot = index - snapshotIndex * countPerPreview;
    const snapshotUrl = pvideo.image?.[snapshotIndex] || "";
    const indexRow = Math.floor(indexInSnapshot / colCount) + 1;
    const indexCol = indexInSnapshot - (indexRow - 1) * colCount;
    const newImgWidth = elWidth * colCount;
    const newImgHeight = elHeight * rowCount;
    const startY = (indexRow - 1) * elHeight;
    const startX = (indexCol - 1) * elWidth;
    return jsx$1("div", { className: "size-full", style: {
      backgroundColor: "black",
backgroundImage: `url(${snapshotUrl})`,
      backgroundPosition: `-${startX}px -${startY}px`,
      backgroundSize: `${newImgWidth}px ${newImgHeight}px`
    }, children: jsx$1(SimpleProgressBar, { progress }) });
  });
  function SimpleProgressBar({
    progress,
    className,
    ...props
  }) {
    return jsx$1("div", { ...props, "data-role": "track", className: clsx("absolute inset-x-0 bottom-0 h-2px bg-gate-bg-lv1", className), children: jsx$1("div", { "data-role": "bar", className: "h-full bg-gate-primary", style: {
      width: `${progress * 100}%`
    } }) });
  }
  function calcIndex(arr, t2) {
    let index = findIndex(arr, t2);
    if (index !== -1) {
      return index;
    }
    if (t2 > arr.at(-1)) {
      index = arr.length - 1;
    }
  }
  function findIndex(arr, target) {
    let l2 = 0;
    let r2 = arr.length - 1;
    let possible = -1;
    while (l2 <= r2) {
      const mid = Math.floor((l2 + r2) / 2);
      const mv = arr[mid];
      if (target === mv) {
        return mid;
      }
      if (mv < target) {
        l2 = mid + 1;
        possible = mid;
      } else {
        r2 = mid - 1;
      }
    }
    if (possible === -1) return -1;
    const v = arr[possible];
    const v1 = arr[possible + 1] ?? 0;
    if (v < target && target < v1) {
      return possible;
    } else {
      return -1;
    }
  }
  const phCrownFill = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 256 256", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M248 80a28 28 0 1 0-51.12 15.77l-26.79 33L146 73.4a28 28 0 1 0-36.06 0l-24.03 55.34l-26.79-33a28 28 0 1 0-26.6 12L47 194.63A16 16 0 0 0 62.78 208h130.44A16 16 0 0 0 209 194.63l14.47-86.85A28 28 0 0 0 248 80M128 40a12 12 0 1 1-12 12a12 12 0 0 1 12-12M24 80a12 12 0 1 1 12 12a12 12 0 0 1-12-12m196 12a12 12 0 1 1 12-12a12 12 0 0 1-12 12" })
  ] });
  const ForwardRef$f = H.forwardRef(phCrownFill);
  const iconParkOutlineMore = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("circle", { cx: 12, cy: 24, r: 3, fill: "currentColor" }),
jsx$1("circle", { cx: 24, cy: 24, r: 3, fill: "currentColor" }),
jsx$1("circle", { cx: 36, cy: 24, r: 3, fill: "currentColor" })
  ] });
  const ForwardRef$e = H.forwardRef(iconParkOutlineMore);
  const clsBadgeContainer = "pointer-events-none h-19px flex-center whitespace-nowrap rounded-2px bg-gate-primary px-4px text-center text-12px color-white";
  function SomeBadge({
    children,
    className
  }) {
    return jsx$1("span", { className: n(clsBadgeContainer, className), children });
  }
  function shouldShowDynamicFeedBadge(item) {
    if (item.api !== EApiType.DynamicFeed) return false;
    const badge = item.modules?.module_dynamic?.major?.archive?.badge;
    if (!badge || !badge.text) return false;
    if (badge.text === DynamicFeedBadgeText.Upload) return false;
    return true;
  }
  function DynamicFeedBadgeDisplay({
    item
  }) {
    if (!shouldShowDynamicFeedBadge(item)) return null;
    if (item.api !== EApiType.DynamicFeed) return null;
    const badge = item.modules?.module_dynamic?.major?.archive?.badge;
    const hasIcon = !!badge.icon_url;
    return jsxs(SomeBadge, { className: clsx(
      "min-w-32px",
      hasIcon ? "pl-4px pr-6px" : "px-4px"
), children: [
      hasIcon && jsx$1(Picture, { src: `${badge.icon_url}@!web-dynamic`, className: "h-16px w-16px" }),
      badge.text
    ] });
  }
  function getColor(no) {
    const medalColors = ["#FFD700", "#C0C0C0", "#B36700"];
    return medalColors[no - 1] ?? primaryColorValue;
  }
  function RankNumMark({
    item
  }) {
    const hasMedal = item.rankingNo <= 3;
    const medalIcon = jsx$1(ForwardRef$f, {});
    let hasOthers = false;
    let others = [];
    if (isNormalRankItem(item) && item.others?.length) {
      hasOthers = true;
      others = item.others;
    }
    const tooltip = `「${item.rankTab.name}」排行第 ${item.rankingNo} 名`;
    const {
      triggerRef,
      tooltipEl
    } = useTooltip({
      inlinePosition: "left",
      tooltip,
      tooltipClassName: "left--2px"
    });
    const roundButtonClassName = "relative size-28px flex-center whitespace-nowrap rounded-full color-white";
    const roundButtonStyle = H.useMemo(() => ({
      backgroundColor: getColor(item.rankingNo)
    }), [item.rankingNo]);
    const newTab = useLinkNewTab();
    return jsxs(Fragment, { children: [
jsxs("div", { ref: triggerRef, className: roundButtonClassName, style: roundButtonStyle, children: [
        hasMedal ? medalIcon : jsx$1("span", { style: {
          marginLeft: -1
        }, children: item.rankingNo }),
        tooltipEl
      ] }),
      hasOthers && jsx$1(antd.Dropdown, { placement: "bottomLeft", menu: {
        items: [{
          type: "group",
          label: "「其他上榜视频」",
          children: others.map((x) => {
            return {
              key: x.bvid,
              label: x.title,
              onClick() {
                const href = new URL(`/video/${x.bvid}`, location.href).href;
                if (newTab) {
                  openNewTab(href);
                } else {
                  location.href = href;
                }
              }
            };
          })
        }]
      }, children: jsx$1("div", { className: roundButtonClassName, style: roundButtonStyle, children: jsx$1(ForwardRef$e, {}) }) })
    ] });
  }
  function LiveBadge() {
    return jsxs(SomeBadge, { children: [
jsx$1(IconForLive, { active: true, className: "size-14px" }),
      "直播中"
    ] });
  }
  function ApiTypeTag({
    item
  }) {
    const text = (() => {
      if (isDynamicFeed(item)) return "动态";
      if (isWatchlater(item)) return "稍后再看";
      if (isFav(item)) return item.from === "fav-folder" ? "收藏夹" : "合集";
      return item.api;
    })();
    return jsx$1(SomeBadge, { children: text });
  }
  function VolMark({
    vol
  }) {
    return jsx$1("div", { className: "relative h-24px min-w-24px flex-center whitespace-nowrap rounded-8px bg-gate-primary px-6px color-white", children: vol });
  }
  const dislikeIcon = jsx$1(IconForDislike, { className: "size-16px" });
  function useDislikeRelated({
    item,
    authed,
    actionButtonVisible
  }) {
    const hasDislikeEntry = isAppRecommend(item) && !!item.three_point?.dislike_reasons?.length;
    const onTriggerDislike = useMemoizedFn(async (e2) => {
      e2?.preventDefault();
      e2?.stopPropagation();
      if (!hasDislikeEntry) {
        if (item.api !== EApiType.AppRecommend) {
          return antMessage.error("当前视频不支持提交「我不想看」");
        }
        return;
      }
      if (!authed) {
        return toast("请先获取 access_key !");
      }
      if (item?.param && dislikedIds.has(item.param)) {
        return;
      }
      await pickDislikeReason(item.three_point?.dislike_reasons || [], handleConfirmDislike);
    });
    const handleConfirmDislike = useLockFn(async (reason) => {
      if (!isAppRecommend(item)) return;
      let success = false;
      let message2 = "";
      let err;
      try {
        ;
        ({
          success,
          message: message2
        } = await dislike(item, reason.id));
      } catch (e2) {
        err = e2;
      }
      if (err) {
        console.error(err.stack || err);
        return toastRequestFail();
      }
      if (success) {
        antMessage.success("已标记不想看");
        dislikedIds.set(item.param, {
          ...reason
        });
      } else {
        antMessage.error(message2 || OPERATION_FAIL_MSG);
      }
      return success;
    });
    const dislikeButtonEl = hasDislikeEntry && jsx$1(VideoCardActionButton, { visible: actionButtonVisible, inlinePosition: "left", icon: dislikeIcon, tooltip: "我不想看", onClick: onTriggerDislike });
    return {
      dislikeButtonEl,
      hasDislikeEntry,
      onTriggerDislike
    };
  }
  const lucideCircle = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("circle", { cx: 12, cy: 12, r: 10, fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2 })
  ] });
  const ForwardRef$d = H.forwardRef(lucideCircle);
  const lucideCircleCheck = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsx$1("circle", { cx: 12, cy: 12, r: 10 }),
jsx$1("path", { d: "m9 12l2 2l4-4" })
    ] })
  ] });
  const ForwardRef$c = H.forwardRef(lucideCircleCheck);
  const IconForMultiSelectUnchecked = ForwardRef$d;
  const IconForMultiSelectChecked = ForwardRef$c;
  function useMultiSelectRelated({
    multiSelecting,
    multiSelected,
    uniqId
  }) {
    const toggleMultiSelect = useMemoizedFn((e2) => {
      const {
        selectedIdSet,
        multiSelecting: multiSelecting2
      } = multiSelectStore;
      if (!multiSelecting2) return;
      e2?.preventDefault();
      e2?.stopPropagation();
      const shiftSelecting = !!e2?.shiftKey;
      multiSelectStore.shiftMultiSelectAnchorUniqId ??= uniqId;
      if (!shiftSelecting) {
        multiSelectStore.shiftMultiSelectAnchorUniqId = uniqId;
      }
      if (shiftSelecting) {
        handleMultiSelectWithShiftKey(multiSelectStore.shiftMultiSelectAnchorUniqId, uniqId);
      } else {
        multiSelected ? selectedIdSet.delete(uniqId) : selectedIdSet.add(uniqId);
      }
    });
    const multiSelectBgEl = multiSelecting && jsx$1("div", { onClick: toggleMultiSelect, className: clsx("absolute inset-0 flex items-center justify-center bg-black/10", clsZMultiSelectBg) });
    const Icon = multiSelected ? IconForMultiSelectChecked : IconForMultiSelectUnchecked;
    const multiSelectEl = multiSelecting && jsx$1(Icon, { onClick: toggleMultiSelect, className: clsx("size-30px cursor-pointer text-white [&_g]:fill-inherit", multiSelected ? "fill-gate-primary" : "fill-none") });
    return {
      toggleMultiSelect,
      multiSelectBgEl,
      multiSelectEl
    };
  }
  function debugAnimation(...args) {
    return;
  }
  function usePreviewRelated({
    uniqId,
    sharedEmitter,
    title,
    active,
    videoDuration,
    tryFetchImagePreviewData,
    imagePreviewDataBox,
    autoPreviewWhenHover,
    videoPreviewWrapperRef
  }) {
    const hasVideoData = useMemoizedFn(() => {
      const data2 = imagePreviewDataBox.val?.videoshotJson?.data;
      return Boolean(data2?.index?.length && data2?.image?.length);
    });
    const [autoPreviewing, setAutoPreviewing] = H.useState(false);
    const [previewProgress, setPreviewProgress] = useRafState();
    const [previewT, setPreviewT] = useRafState();
    const getProgress = useMemoizedFn(() => previewProgress || 0);
    const [mouseMoved, setMouseMoved] = H.useState(false);
    const isHoveringBox = useRefStateBox(false);
    const isHoveringAfterDelayBox = useRefStateBox(false);
    const startByHoverBox = useRefBox(false);
    const [mouseProgress, setMouseProgress] = H.useState(void 0);
    const updateMouseProgress = (e2) => {
      const rect = videoPreviewWrapperRef.current?.getBoundingClientRect();
      if (!rect) return;
      const {
        x,
        width
      } = rect;
      const relativeX = e2.pageX - window.scrollX - x;
      setMouseProgress(relativeX / width);
    };
    useEventListener("mouseenter", async (e2) => {
      sharedEmitter.emit("mouseenter", uniqId);
      isHoveringBox.set(true);
      updateMouseProgress(e2);
      const p2 = tryFetchImagePreviewData();
      const HOVER_DELAY = 800;
      let delayPromise;
      if (settings.useDelayForHover) {
        delayPromise = delay(HOVER_DELAY);
      }
      await Promise.all([p2, delayPromise].filter(Boolean));
      if (!isHoveringBox.val) return;
      isHoveringAfterDelayBox.set(true);
      if (autoPreviewWhenHover && !idBox.val && hasVideoData()) {
        onStartPreviewAnimation(true);
      }
    }, {
      target: videoPreviewWrapperRef
    });
    const _mouseleaveAction = useMemoizedFn(() => {
      isHoveringBox.set(false);
      isHoveringAfterDelayBox.set(false);
    });
    useEventListener("mouseleave", _mouseleaveAction, {
      target: videoPreviewWrapperRef
    });
    useEmitterOn(sharedEmitter, "mouseenter", (srcUniqId) => {
      if (srcUniqId === uniqId) return;
      _mouseleaveAction();
    });
    useEventListener("mousemove", (e2) => {
      setMouseMoved(true);
      if (isHoveringBox.val && (!isHoveringAfterDelayBox.val || !autoPreviewWhenHover)) {
        updateMouseProgress(e2);
      }
      if (!autoPreviewWhenHover) {
        animationController.stop();
      }
    }, {
      target: videoPreviewWrapperRef
    });
    const idBox = useRefBox(void 0);
    const onResume = H.useRef(void 0);
    const animationController = useAnimationController({
      startByHoverBox,
      isHoveringBox,
      active,
      mouseMoved,
      idBox,
      autoPreviewWhenHover,
      setAutoPreviewing,
      setPreviewT,
      setPreviewProgress,
      onResume() {
        onResume.current?.();
      }
    });
    const onHotkeyPreviewAnimation = useMemoizedFn(async () => {
      if (!idBox.val) {
        await tryFetchImagePreviewData();
        if (hasVideoData()) {
          onStartPreviewAnimation(false);
        }
        return;
      }
      animationController.togglePaused();
    });
    const onStartPreviewAnimation = useMemoizedFn((startByHover) => {
      startByHoverBox.set(startByHover);
      setMouseMoved(false);
      animationController.reset();
      animationController.stop(true);
      setAutoPreviewing(true);
      setPreviewProgress((val) => typeof val === "undefined" ? 0 : val);
      setPreviewT(void 0);
      const RUN_DURATION = 8e3;
      let start = performance.now();
      let updateAt = 0;
      onResume.current = () => {
        start = performance.now() - getProgress() * RUN_DURATION;
      };
      function frame(t2) {
        if (animationController.shouldStop()) {
          return animationController.stop();
        }
        if (!animationController.paused) {
          const now = performance.now();
          const elapsed = now - start;
          const p2 = minmax(elapsed % RUN_DURATION / RUN_DURATION, 0, 1);
          setPreviewProgress(p2);
          if (!updateAt || now - updateAt >= settings.autoPreviewUpdateInterval) {
            setPreviewProgress(p2);
            updateAt = now;
            if (videoDuration) {
              const t22 = minmax(Math.round(p2 * videoDuration), 0, videoDuration);
              setPreviewT(t22);
            }
          }
        }
        idBox.val = requestAnimationFrame(frame);
      }
      idBox.val = requestAnimationFrame(frame);
    });
    const isHovering = isHoveringBox.state;
    const isHoveringAfterDelay = isHoveringAfterDelayBox.state;
    const videoshotData = imagePreviewDataBox.state?.videoshotJson?.data;
    const shouldShowPreview = !!videoshotData?.image?.length && !!videoDuration && (isHoveringAfterDelay || active) && (autoPreviewWhenHover ? autoPreviewing : true);
    const previewImageRef = H.useRef(null);
    let previewImgProps;
    let previewImageEl;
    if (shouldShowPreview) {
      const sharedProps = {
        videoDuration,
        pvideo: videoshotData
      };
      if (autoPreviewWhenHover) {
        previewImgProps = {
          ...sharedProps,
          progress: previewProgress,
          t: previewT
        };
      } else {
        previewImgProps = {
          ...sharedProps,
          progress: mouseProgress
        };
      }
      previewImageEl = jsx$1(PreviewImage, { ref: previewImageRef, ...previewImgProps });
    }
    return {
      onHotkeyPreviewAnimation,
      onStartPreviewAnimation,
      autoPreviewing,
      mouseProgress,
      previewProgress,
      previewT,
isHovering,
      isHoveringAfterDelay,
shouldShowPreview,
      previewImageRef,
      previewImgProps,
      previewImageEl
    };
  }
  function useAnimationController({
    startByHoverBox,
    isHoveringBox,
    idBox,
    active,
    mouseMoved,
    autoPreviewWhenHover,
    setAutoPreviewing,
    setPreviewT,
    setPreviewProgress,
    onResume
  }) {
    const unmounted = useUnmountedRef();
    const shouldStop = useMemoizedFn(() => {
      if (unmounted.current) return true;
      if (startByHoverBox.val) {
        if (!isHoveringBox.val) return true;
      } else {
        if (!active) return true;
        if (mouseMoved) return true;
      }
      return false;
    });
    const stop = useMemoizedFn((isClear = false) => {
      if (!isClear) {
        debugAnimation(`stopAnimation: %o`, {
          autoPreviewWhenHover,
          unmounted: unmounted.current,
          isHovering: isHoveringBox.val,
          active,
          mouseMoved
        });
      }
      if (idBox.val) cancelAnimationFrame(idBox.val);
      idBox.val = void 0;
      setAutoPreviewing(false);
      setPreviewProgress(void 0);
      setPreviewT(void 0);
      controller.reset();
    });
    const _paused = H.useRef(false);
    const controller = H.useMemo(() => {
      return {
        shouldStop,
        stop,
        get paused() {
          return _paused.current;
        },
        set paused(val) {
          _paused.current = val;
        },
        togglePaused() {
          const prev2 = this.paused;
          this.paused = !this.paused;
          if (prev2) {
            onResume?.();
          }
        },
        reset() {
          this.paused = false;
        }
      };
    }, [shouldStop, stop, _paused, onResume]);
    return controller;
  }
  function useWatchlaterRelated({
    item,
    cardData,
    onRemoveCurrent,
    actionButtonVisible,
    watchlaterAdded
  }) {
    const {
      avid,
      bvid
    } = cardData;
    const hasWatchlaterEntry = H.useMemo(() => {
      if (isAppRecommend(item) || isPcRecommend(item)) {
        return item.goto === "av";
      }
      if (item.api === EApiType.Rank) {
        return cardData.goto === "av";
      }
      if (item.api === EApiType.Live) {
        return false;
      }
      return true;
    }, [item, cardData]);
    const $req = useRequest((usingAction, avid2) => usingAction(avid2), {
      manual: true
    });
    const watchlaterAddedPrevious = usePrevious$1(watchlaterAdded);
    const onToggleWatchlater = useMemoizedFn(async (e2, usingAction) => {
      e2?.preventDefault();
      e2?.stopPropagation();
      if ($req.loading) return {
        success: false
      };
      if (!avid || !bvid) {
        return {
          success: false
        };
      }
      usingAction ??= watchlaterAdded ? watchlaterDel : watchlaterAdd;
      const success = await $req.runAsync(usingAction, avid);
      const targetState = usingAction === watchlaterAdd ? true : false;
      if (success) {
        if (targetState) {
          watchlaterState.bvidSet.add(bvid);
        } else {
          watchlaterState.bvidSet.delete(bvid);
        }
        if (item.api === EApiType.Watchlater) {
          if (!targetState) {
            await delay(250);
            onRemoveCurrent?.(item, cardData);
          }
        } else {
          antMessage.success(`已${targetState ? "添加" : "移除"}稍后再看`);
        }
      }
      return {
        success,
        targetState
      };
    });
    const addedSize = 18;
    const icon = (() => {
      if ($req.loading) {
        return jsx$1(IconForLoading, { className: "size-16px" });
      }
      if (item.api === EApiType.Watchlater) {
        return watchlaterAdded ? jsx$1(IconForDelete, { className: "size-16px" }) : jsx$1(IconAnimatedChecked, { size: addedSize, useAnimation: watchlaterAddedPrevious === true });
      }
      return watchlaterAdded ? jsx$1(IconAnimatedChecked, { size: addedSize, useAnimation: watchlaterAddedPrevious === false }) : jsx$1(IconForWatchlater, { className: "size-20px" });
    })();
    const tooltip = item.api === EApiType.Watchlater ? watchlaterAdded ? "已添加稍后再看, 点击移除" : "已移除稍后再看" : watchlaterAdded ? "已添加稍后再看, 点击移除" : "稍后再看";
    const watchlaterButtonEl = hasWatchlaterEntry && jsx$1(VideoCardActionButton, { visible: actionButtonVisible, inlinePosition: "right", icon, tooltip, onClick: onToggleWatchlater });
    const context = H.useMemo(() => {
      return {
        watchlaterAdded,
        hasWatchlaterEntry,
        onToggleWatchlater
      };
    }, [onToggleWatchlater, watchlaterAdded, hasWatchlaterEntry]);
    return {
      context,
      watchlaterButtonEl
    };
  }
  const VideoCard = H.memo(function VideoCard2({
    style,
    className,
    item,
    loading,
    active,
    onRemoveCurrent,
    onMoveToFirst,
    onRefresh,
    emitter: emitter2,
    sharedEmitter,
    tab: tab2,
    baseCss,
    cardDisplay,
    multiSelecting,
    ...restProps
  }) {
    loading = loading ?? !item;
    const cardData = H.useMemo(() => item && normalizeCardData(item), [item]);
    const dislikedReason = useDislikedReason(item?.api === EApiType.AppRecommend ? item.param : void 0);
    const blacklisted = useInBlacklist(cardData?.authorMid);
    const blocked = useInFilterByAuthorList(cardData?.authorMid);
    const watchlaterAdded = useWatchlaterState(cardData?.bvid);
    const multiSelected = useMultiSelectState(item?.uniqId);
    const showingDislikeCard = !!dislikedReason;
    const showingBlacklistCard = blacklisted;
    const showingBlockedCard = blocked;
    const isBlockedCard = showingDislikeCard || showingBlacklistCard || showingBlockedCard;
    const blockedCardCss = useBlockedCardCss(isBlockedCard);
    const _className = clsx("bili-video-card", APP_CLS_CARD, {
      [APP_CLS_CARD_ACTIVE]: active
    }, "relative", className);
    const _css = [baseCss, blockedCardCss, isDisplayAsList(cardDisplay) && displayAsListCss.card, multiSelecting && multiSelected && multiSelectedCss];
    return jsx$1("div", { "data-bvid": cardData?.bvid, style, className: _className, css: _css, ...restProps, children: loading ? jsx$1(SkeletonCard, { loading }) : item && cardData && (showingDislikeCard ? jsx$1(DislikedCard, { item, cardData, emitter: emitter2, dislikedReason }) : showingBlacklistCard ? jsx$1(BlockedCard, { item, cardData, blockType: "blacklist" }) : showingBlockedCard ? jsx$1(BlockedCard, { item, cardData, blockType: "filter" }) : jsx$1(VideoCardInner, { item, cardData, active, emitter: emitter2, sharedEmitter, tab: tab2, onRemoveCurrent, onMoveToFirst, onRefresh, watchlaterAdded, cardDisplay, multiSelecting, multiSelected })) });
  });
  var _ref$1 = {
    name: "vpmszz",
    styles: "background-color:unset;position:static;height:100%"
  };
  var _ref2 = {
    name: "he9puu",
    styles: "display:block;position:relative;overflow:hidden;isolation:isolate"
  };
  const VideoCardInner = H.memo(function VideoCardInner2({
    item,
    cardData,
    tab: tab2,
    active = false,
    onRemoveCurrent,
    onMoveToFirst,
    onRefresh,
    emitter: emitter2 = defaultEmitter,
    sharedEmitter = defaultSharedEmitter,
    watchlaterAdded,
    cardDisplay,
    multiSelecting = false,
    multiSelected
  }) {
    const {
      autoPreviewWhenHover,
      accessKey,
      style: {
        videoCard: {
          useBorder: cardUseBorder,
          useBorderOnlyOnHover: cardUseBorderOnlyOnHover
        }
      },
      videoCard: {
        actions: videoCardActions
      },
      spaceUpload: {
        showVol
      },
      __internalEnableCopyBvidInfo
    } = useSettingsSnapshot();
    const authed = !!accessKey;
    const {
avid,
      bvid,
      cid,
      goto,
      href,
      title,
      cover,
      duration: duration2,
      durationStr,
      recommendReason,
statItems,
authorName,
      authorMid
    } = cardData;
    const isNormalVideo = goto === "av";
    const allowed = ["av", "bangumi", "picture", "live"];
    if (!allowed.includes(goto)) {
      appWarn(`none (${allowed.join(",")}) goto type %s`, goto, item);
    }
    const displayingAsList = isDisplayAsList(cardDisplay);
    const aspectRatioFromItem = H.useMemo(() => getRecItemDimension({
      item
    })?.aspectRatio, [item]);
    const imagePreviewDataBox = useRefStateBox(void 0);
    const shouldFetchPreviewData = H.useMemo(() => {
      if (!bvid) return false;
      if (!bvid.startsWith("BV")) return false;
      if (goto !== "av") return false;
      return true;
    }, [bvid, goto]);
    const tryFetchImagePreviewData = useLockFn(async () => {
      if (!shouldFetchPreviewData) return;
      if (multiSelecting) return;
      if (isImagePreviewDataValid(imagePreviewDataBox.val)) return;
      const data2 = await fetchImagePreviewData(bvid);
      imagePreviewDataBox.set(data2);
      if (!isWebApiSuccess(data2.videoshotJson)) {
        warnNoPreview(data2.videoshotJson);
      }
    });
    const warnNoPreview = useLessFrequentFn((json) => {
      antNotification.warning({
        message: `${json.message} (code: ${json.code})`,
        description: `${title} (${bvid})`,
        duration: 2
      });
    }, 3, false);
    const cardRef = H.useRef(null);
    const coverRef = H.useRef(null);
    const videoPreviewWrapperRef = cardUseBorder && !displayingAsList ? cardRef : coverRef;
    const {
      onStartPreviewAnimation,
      onHotkeyPreviewAnimation,
isHovering,
      previewImageEl
    } = usePreviewRelated({
      uniqId: item.uniqId,
      sharedEmitter,
      title,
      active,
      videoDuration: duration2,
      tryFetchImagePreviewData,
      imagePreviewDataBox,
      autoPreviewWhenHover,
      videoPreviewWrapperRef
    });
    useUpdateEffect(() => {
      if (!active) return;
      setGlobalValue(`${APP_KEY_PREFIX}_activeItem`, item);
      if (settings.autoPreviewWhenKeyboardSelect) {
        tryFetchImagePreviewData().then(() => {
          onStartPreviewAnimation(false);
        });
      }
    }, [active]);
    const actionButtonVisible = active || isHovering;
    const {
      watchlaterButtonEl,
      context: watchlaterContext
    } = useWatchlaterRelated({
      item,
      cardData,
      onRemoveCurrent,
      actionButtonVisible,
      watchlaterAdded
    });
    const {
      dislikeButtonEl,
      hasDislikeEntry,
      onTriggerDislike
    } = useDislikeRelated({
      item,
      authed,
      actionButtonVisible
    });
    const {
      largePreviewActionButtonEl,
      largePreviewEl,
      shouldUseLargePreviewCurrentTime,
      getLargePreviewCurrentTime,
      largePreviewVisible,
      hideLargePreview
    } = useLargePreviewRelated({
      shouldFetchPreviewData,
      actionButtonVisible,
      hasLargePreviewActionButton: videoCardActions.showLargePreview,
bvid,
      cid,
      uniqId: item.uniqId,
      sharedEmitter,
aspectRatioFromItem,
      cover,
      cardRef,
      videoCardAsTriggerRef: videoPreviewWrapperRef
});
    const favContext = useInitFavContext(item, avid);
    const {
      onOpenWithMode,
      handleVideoLinkClick,
      consistentOpenMenus,
      conditionalOpenMenus,
      openInPopupActionButtonEl,
      onOpenInPopup
    } = useOpenRelated({
      href,
      item,
      cardData,
      actionButtonVisible,
      hasOpenInPopupActionButton: videoCardActions.openInPipWindow,
      getLargePreviewCurrentTime,
      hideLargePreview,
      shouldUseLargePreviewCurrentTime
    });
    const {
      multiSelectBgEl,
      multiSelectEl,
      toggleMultiSelect
    } = useMultiSelectRelated({
      multiSelecting,
      multiSelected,
      uniqId: item.uniqId
    });
    const handleCardClick = useMemoizedFn((e2) => {
      if (!cardUseBorder) return;
      if (e2.target.closest(".ant-dropdown-menu")) return;
      if (e2.target.closest("a")) return;
      onOpenWithMode();
    });
    useEmitterOn(emitter2, "open", () => onOpenWithMode());
    useEmitterOn(emitter2, "open-in-popup", onOpenInPopup);
    useEmitterOn(emitter2, "open-with-large-preview-visible", () => {
      if (!largePreviewVisible) return;
      hideLargePreview();
      onOpenWithMode();
    });
    useEmitterOn(emitter2, "toggle-watch-later", () => void watchlaterContext.onToggleWatchlater());
    useEmitterOn(emitter2, "trigger-dislike", () => void onTriggerDislike());
    useEmitterOn(emitter2, "start-preview-animation", onStartPreviewAnimation);
    useEmitterOn(emitter2, "hotkey-preview-animation", onHotkeyPreviewAnimation);
    const contextMenus = useContextMenus({
      item,
      cardData,
      tab: tab2,
      isNormalVideo,
      onRefresh,
      watchlaterContext,
      favContext,
      onMoveToFirst,
      hasDislikeEntry,
      onTriggerDislike,
      onRemoveCurrent,
      consistentOpenMenus,
      conditionalOpenMenus,
      multiSelecting
    });
    const onContextMenuOpenChange = useMemoizedFn((open) => {
      if (!open) return;
      favContext.updateFavFolderNames();
    });
    const hasDynmaicFeedBadge = shouldShowDynamicFeedBadge(item);
    const _isRank = isRank(item);
    const _isStreaming = (
isLive(item) && item.live_status === ELiveStatus.Streaming || isPcRecommend(item) && item.goto === PcRecGoto.Live
    );
    const hasApiTypeTag = tab2 === ETab.AppRecommend && !isAppRecommend(item) && !isLive(item);
    const hasVolMark = isSpaceUpload(item) && showVol || item.api === EApiType.Fav && !!item.vol && !hasApiTypeTag;
    const copyBvidInfoButtonEl = __internalEnableCopyBvidInfo && jsx$1(VideoCardActionButton, { visible: actionButtonVisible, inlinePosition: "right", icon: jsx$1(IconForCopy, { className: "size-14px" }), tooltip: "复制 BVID 信息", onClick: (e2) => {
      e2.stopPropagation();
      e2.preventDefault();
      copyContent(getBvidInfo(cardData));
    } });
    const topLeftMarksEl = jsxs(Fragment, { children: [
      multiSelecting && multiSelectEl,
      dislikeButtonEl,
      hasDynmaicFeedBadge && jsx$1(DynamicFeedBadgeDisplay, { item }),
      _isRank && jsx$1(RankNumMark, { item }),
      _isStreaming && jsx$1(LiveBadge, {}),
      hasApiTypeTag && jsx$1(ApiTypeTag, { item }),
      hasVolMark && !!item.vol && jsx$1(VolMark, { vol: item.vol })
    ] });
    const topRightActionsEl = jsxs(Fragment, { children: [
      watchlaterButtonEl,
      copyBvidInfoButtonEl,
      openInPopupActionButtonEl,
      largePreviewActionButtonEl
    ] });
    const hasTopLeftMarks = !isEmptyFragment(topLeftMarksEl);
    const hasTopRightActions = !isEmptyFragment(topRightActionsEl);
    const clsTopLeftMarksContainer = n("left-top-marks", C.topContainer("left"), multiSelecting ? "gap-x-10px" : void 0);
    const watchlaterProgressBar = isWatchlater(item) && item.progress > 0 ? jsx$1(SimpleProgressBar, { progress: item.progress / item.duration, className: clsx("h-3px", clsZWatchlaterProgressBar) }) : void 0;
    const prefixCls = `.${APP_CLS_ROOT} .${APP_CLS_CARD}`;
    const coverRoundCss = H.useMemo(() => {
      return [ css(prefixCls, " &{overflow:hidden;border-radius:", videoCardBorderRadiusValue, ";transition:border-radius 0.2s ease-in-out;}", ""), !displayingAsList && (isHovering || active || multiSelecting || cardUseBorder && !cardUseBorderOnlyOnHover) && css(prefixCls, " &{border-bottom-left-radius:0;border-bottom-right-radius:0;}", "")];
    }, [displayingAsList, isHovering, active, multiSelecting, cardUseBorder, cardUseBorderOnlyOnHover]);
    const shouldMakeCoverClear = H.useMemo(() => {
      if (cardUseBorder && !cardUseBorderOnlyOnHover) return false;
      if (multiSelecting) return false;
      return !cardUseBorder || cardUseBorder && cardUseBorderOnlyOnHover && !isHovering;
    }, [cardUseBorder, cardUseBorderOnlyOnHover, isHovering, multiSelecting]);
    const target = useLinkTarget();
    const coverContent = jsxs("a", { ref: (el) => coverRef.current = el, href, target, className: clsx(APP_CLS_CARD_COVER, shouldMakeCoverClear && "ring-1px ring-gate-border"), css: [_ref2, coverRoundCss, displayingAsList && displayAsListCss.cover, "", ""], onClick: handleVideoLinkClick, onContextMenu: (e2) => {
      const handled = showNativeContextMenuWhenAltKeyPressed(e2);
      if (handled) return;
      e2.preventDefault();
    }, children: [
jsx$1("div", { className: "bili-video-card__image", style: {
        aspectRatio: "16 / 9"
      }, children: jsx$1("div", { className: "bili-video-card__image--wrap", children: jsx$1(Picture, { src: `${cover}@672w_378h_1c_!web-home-common-cover`, className: "bili-video-card__cover v-img", style: {
        borderRadius: 0
      }, imgProps: {
alt: isFirefox ? "" : title
      } }) }) }),
jsxs("div", { className: "bili-video-card__stats", css: [ css(prefixCls, " &{pointer-events:none;border-radius:0;}", ""), "", ""], children: [
jsx$1("div", { className: "bili-video-card__stats--left gap-x-4px xl:gap-x-8px", children: statItems.map(({
          field,
          value
        }) => jsx$1(StatItemDisplay, { field, value }, field)) }),
jsx$1("span", { className: "bili-video-card__stats__duration relative top-0.5px", children: isNormalVideo && durationStr })
      ] }),
      watchlaterProgressBar,
      !multiSelecting && previewImageEl,
      multiSelectBgEl,
      hasTopLeftMarks && jsx$1("div", { className: clsTopLeftMarksContainer, children: topLeftMarksEl }),
      hasTopRightActions && jsx$1("div", { className: clsx("right-actions", C.topContainer("right")), children: topRightActionsEl })
    ] });
    const bottomContent = jsx$1(VideoCardBottom, { item, cardData, cardDisplay, handleVideoLinkClick: multiSelecting ? toggleMultiSelect : handleVideoLinkClick });
    const extraContent = jsx$1(Fragment, { children: largePreviewEl });
    function wrapDropdown(c2) {
      return jsx$1(antd.Dropdown, { getPopupContainer: () => {
        if (isSafari) return document.body;
        return cardRef.current || document.body;
      }, overlayStyle: {
        zIndex: Number(zIndexVideoCardContextMenu)
      }, menu: {
        items: contextMenus,
        style: {
width: "max-content"
        }
      }, trigger: ["contextMenu"], onOpenChange: onContextMenuOpenChange, children: c2 });
    }
    function wrapCardWrapper(c2) {
      return jsx$1("div", { className: "bili-video-card__wrap", ref: (el) => cardRef.current = el, css: [_ref$1, displayingAsList && displayAsListCss.cardWrap, "", ""], onClick: multiSelecting ? toggleMultiSelect : handleCardClick, onContextMenu: (e2) => {
        if (cardUseBorder) {
          e2.preventDefault();
        }
      }, children: c2 });
    }
    const wrappedContent = cardUseBorder && !displayingAsList ? wrapDropdown(wrapCardWrapper( jsxs(Fragment, { children: [
      coverContent,
      bottomContent
    ] }))) : wrapCardWrapper( jsxs(Fragment, { children: [
      wrapDropdown(coverContent),
      bottomContent
    ] }));
    return jsxs(Fragment, { children: [
      wrappedContent,
      extraContent
    ] });
  });
  ({
    List: H.forwardRef(({
      context: ctx,
      children,
      ...props
    }, ref) => {
      function setForwardedRef2(el) {
        if (!ref) return;
        if (typeof ref === "function") {
          ref(el);
        } else {
          ref.current = el;
        }
      }
      return jsx$1("div", { ref: (el) => {
        setForwardedRef2(el);
        ctx.containerRef.current = el;
      }, ...props, className: ctx.gridClassName, children });
    })
  });
  const iconParkOutlineLoading = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M4 24c0 11.046 8.954 20 20 20v0c11.046 0 20-8.954 20-20S35.046 4 24 4" }),
jsx$1("path", { d: "M36 24c0-6.627-5.373-12-12-12s-12 5.373-12 12s5.373 12 12 12v0" })
    ] })
  ] });
  const ForwardRef$b = H.forwardRef(iconParkOutlineLoading);
  const debug$3 = baseDebug.extend("components:RecGrid");
  const initHeaderState = () => ({
    refreshing: false,
    onRefresh: noop$1,
    extraInfo: null
  });
  const RecGrid = H.forwardRef(function(props, ref) {
    const servicesRegistry = useRefStateBox(() => ({}));
    const tab2 = H.useDeferredValue(useCurrentUsingTab());
    const prevTab = usePrevious$1(tab2);
    const tabOrders = useSortedTabKeys();
    const direction = H.useMemo(() => {
      return prevTab ? tabOrders.indexOf(tab2) > tabOrders.indexOf(prevTab) ? "right" : "left" : void 0;
    }, [tabOrders, tab2]);
    return jsx$1(RecGridInner, { tab: tab2, direction, handlersRef: ref, servicesRegistry, ...props }, tab2);
  });
  const RecGridInner = H.memo(function({
    shortcutEnabled,
    className,
    tab: tab2,
    handlersRef,
    servicesRegistry,
    infiniteScrollUseWindow,
    onScrollToTop,
    scrollerRef,
    onSyncHeaderState
  }) {
    const unmountedRef = useUnmountedRef();
    const {
      cardDisplay
    } = useSnapshot(settings.style.pureRecommend);
    const {
      multiSelecting
    } = useSnapshot(multiSelectStore);
    const loadCompleteCountBox = useRefStateBox(0);
    const [extraInfo, setExtraInfo] = H.useState(void 0);
    const updateExtraInfo = useMemoizedFn(() => {
      setExtraInfo(servicesRegistry.val[tab2]?.usageInfo);
    });
    const preAction = useMemoizedFn(() => {
      clearActiveIndex();
      updateExtraInfo();
      onScrollToTop?.();
    });
    const postAction = useMemoizedFn(() => {
      clearActiveIndex();
      updateExtraInfo();
      loadCompleteCountBox.set(1);
      setTimeout(checkShouldLoadMore);
    });
    const {
      itemsBox,
      error: refreshError,
      refresh,
      hasMoreBox,
      refreshingBox,
      refreshTsBox,
      refreshAbortController,
      showSkeleton,
      beforeMount
    } = useRefresh({
      tab: tab2,
      servicesRegistry,
      debug: debug$3,
      fetcher: refreshForGrid,
preAction,
      postAction,
      updateExtraInfo
    });
    H.useImperativeHandle(handlersRef, () => ({
      refresh
    }), [refresh]);
    const refreshing = refreshingBox.state;
    const hasMore = hasMoreBox.state;
    H.useEffect(() => {
      if (unmountedRef.current) return;
      onSyncHeaderState?.({
        refreshing,
        onRefresh: refresh,
        extraInfo
      });
    }, [refreshing, refresh, extraInfo, onSyncHeaderState]);
    const goOutAt = H.useRef();
    useEventListener("visibilitychange", (e2) => {
      const visible = document.visibilityState === "visible";
      if (!visible) {
        goOutAt.current = Date.now();
        return;
      }
      if (refreshingBox.val) return;
      if (loadMoreLocker.current[refreshTsBox.val]) return;
      if (tab2 === ETab.Watchlater && goOutAt.current && Date.now() - goOutAt.current > ms("1h")) {
        refresh(true);
      }
    }, {
      target: document
    });
    const checkShouldLoadMore = useMemoizedFn(async () => {
      await delay(isSafari ? 100 : 0);
      debug$3("checkShouldLoadMore(): footerInView = %s", footerInViewRef.current);
      if (footerInViewRef.current) {
        loadMore();
      }
    });
    const loadMoreLocker = H.useRef({});
    const lock = H.useCallback((lockKey) => loadMoreLocker.current = {
      [lockKey]: true
    }, []);
    const unlock = H.useCallback((lockKey) => loadMoreLocker.current[lockKey] = false, []);
    const isLocked = useMemoizedFn((lockKey) => !!loadMoreLocker.current[lockKey]);
    const loadMore = useMemoizedFn(async () => {
      if (unmountedRef.current) return;
      if (!hasMoreBox.val) return;
      if (refreshAbortController.signal.aborted) return;
      if (refreshingBox.val) return;
      const getState = () => ({
        refreshTs: refreshTsBox.val
      });
      const startingState = getState();
      const lockKey = startingState.refreshTs;
      if (isLocked(lockKey)) return;
      lock(lockKey);
      let newItems = itemsBox.val;
      let newHasMore = true;
      let err;
      try {
        const service = getServiceFromRegistry(servicesRegistry, tab2);
        let more = await service.loadMore(refreshAbortController.signal) || [];
        more = filterRecItems(more, tab2);
        newItems = concatThenUniq(newItems, more);
        newHasMore = service.hasMore;
      } catch (e2) {
        err = e2;
      }
      if (err) {
        unlock(lockKey);
        throw err;
      }
      {
        const currentState = getState();
        if (!isEqual$1(startingState, currentState)) {
          debug$3("loadMore: skip update for mismatch refresh state, %o != %o", startingState, currentState);
          unlock(lockKey);
          return;
        }
      }
      debug$3("loadMore: seq(%s) len %s -> %s", loadCompleteCountBox.val + 1, itemsBox.val.length, newItems.length);
      hasMoreBox.set(newHasMore);
      itemsBox.set(newItems);
      loadCompleteCountBox.set((c2) => c2 + 1);
      unlock(lockKey);
      checkShouldLoadMore();
    });
    const usingItems = itemsBox.state;
    const containerRef = H.useRef(null);
    const getScrollerRect = useMemoizedFn(() => {
      if (infiniteScrollUseWindow) {
        const yStart = $headerHeight.get() + 50;
        return new DOMRect(0, yStart, window.innerWidth, window.innerHeight - yStart);
      } else {
        return scrollerRef?.current?.getBoundingClientRect();
      }
    });
    useModalDislikeVisible();
    useModalMoveFavVisible();
    const usingVideoItems = H.useMemo(() => {
      return usingItems.filter((x) => x.api !== EApiType.Separator);
    }, [usingItems]);
    const emitterCache = H.useMemo(() => new Map(), [refreshTsBox.state]);
    const videoCardEmitters = H.useMemo(() => {
      return usingVideoItems.map(({
        uniqId
      }) => {
        const cacheKey2 = uniqId;
        return emitterCache.get(cacheKey2) || (() => {
          const instance = new Emittery();
          emitterCache.set(cacheKey2, instance);
          return instance;
        })();
      });
    }, [usingVideoItems]);
    const sharedEmitter = H.useMemo(() => createSharedEmitter(), []);
    H.useEffect(() => setCurrentGridSharedEmitter(sharedEmitter), [sharedEmitter]);
    const [activeLargePreviewUniqId, setActiveLargePreviewUniqId] = H.useState(void 0);
    useEmitterOn(sharedEmitter, "show-large-preview", setActiveLargePreviewUniqId);
    const activeLargePreviewItemIndex = H.useMemo(() => {
      if (!activeLargePreviewUniqId) return;
      return usingVideoItems.findIndex((item) => item.uniqId === activeLargePreviewUniqId);
    }, [usingItems, activeLargePreviewUniqId]);
    const {
      activeIndex,
      clearActiveIndex
    } = useShortcut({
      enabled: shortcutEnabled,
      refresh,
      maxIndex: usingVideoItems.length - 1,
      containerRef,
      getScrollerRect,
      videoCardEmitters,
      activeLargePreviewItemIndex,
      changeScrollY: infiniteScrollUseWindow ? function({
        offset,
        absolute
      }) {
        const scroller = document.documentElement;
        if (typeof offset === "number") {
          scroller.scrollTop += offset;
          return;
        }
        if (typeof absolute === "number") {
          scroller.scrollTop = absolute;
          return;
        }
      } : void 0
    });
    const setItems = itemsBox.set;
    const handleRemoveCards = useMemoizedFn((uniqIds, titles, silent) => {
      setItems((items) => {
        const newItems = items.slice();
        const removedTitles = [];
        for (const [i2, uniqId] of uniqIds.entries()) {
          const index = newItems.findIndex((x) => x.uniqId === uniqId);
          if (index === -1) continue;
          newItems.splice(index, 1);
          const title = titles?.[i2];
          if (title) removedTitles.push(title);
          if (tab2 === ETab.Watchlater) {
            servicesRegistry.val[tab2]?.decreaseTotal();
          }
          if (tab2 === ETab.Fav) {
            servicesRegistry.val[tab2]?.decreaseTotal();
          }
        }
        if (!silent && removedTitles.length) {
          if (removedTitles.length <= 3) {
            removedTitles.forEach((t2) => antMessage.success(`已移除: ${removedTitles.join(", ")}`));
          } else {
            antMessage.success(`已移除: ${removedTitles.length}个视频`);
          }
        }
        return newItems;
      });
    });
    const handleMoveCardToFirst = useMemoizedFn((item, data2) => {
      setItems((items) => {
        const currentItem = items.find((x) => x.uniqId === item.uniqId);
        if (!currentItem) return items;
        const index = items.indexOf(currentItem);
        const newItems = items.slice();
        newItems.splice(index, 1);
        const newIndex = newItems.findIndex((x) => x.api !== EApiType.Separator);
        newItems.splice(newIndex, 0, currentItem);
        return newItems;
      });
    });
    useEmitterOn(sharedEmitter, "remove-cards", ([uniqIds, titles, silent]) => handleRemoveCards(uniqIds, titles, silent));
    const {
      ref: footerRef,
      inView: __footerInView
    } = useInView({
      root: infiniteScrollUseWindow ? null : scrollerRef?.current || null,
      rootMargin: `0px 0px ${window.innerHeight}px 0px`,
      onChange(inView) {
        if (inView) {
          debug$3("footerInView change to visible", inView);
          setTimeout(checkShouldLoadMore);
        }
      }
    });
    const footerInViewRef = useLatest(__footerInView);
    const footer = jsx$1("div", { ref: footerRef, className: "grid-col-span-full flex items-center justify-center py-30px text-size-120%", children: !refreshing && jsx$1(Fragment, { children: hasMore ? jsxs(Fragment, { children: [
jsx$1(ForwardRef$b, { className: "mr-10px size-40px animate-spin color-gate-primary" }),
      "加载中~"
    ] }) : jsx$1(Fragment, { children: "没有更多了~" }) }) });
    const {
      useNarrowMode,
      style
    } = useSettingsSnapshot();
    const gridClassName = clsx(
      APP_CLS_GRID,
videoGrid,
      style.pureRecommend.useCustomGrid ? videoGridCustom : videoGridBiliFeed4,
      useNarrowMode && narrowMode,
className
    );
    const cardBorderCss = useCardBorderCss();
    H.useMemo(() => {
      return {
        footerContent: footer,
        containerRef,
        gridClassName
};
    }, [footer, containerRef, gridClassName]);
    const render3 = ({
      gridChildren,
      gridSiblings
    } = {}) => {
      return jsxs("div", { ref: containerRef, className: clsx("min-h-100vh", videoGridContainer), "data-tab": tab2, children: [
jsx$1("div", { className: gridClassName, "data-tab": tab2, children: gridChildren }),
        gridSiblings
      ] });
    };
    if (beforeMount) {
      return render3();
    }
    if (refreshError) {
      console.error("RecGrid.refresh error:", refreshError.stack || refreshError);
      return render3({
        gridSiblings: jsx$1(ErrorDetail, { tab: tab2, err: refreshError })
      });
    }
    if (refreshing && showSkeleton) {
      const cardCount = getGridRefreshCount();
      return render3({
        gridChildren: Array.from({
          length: cardCount
        }).fill(0).map((_2, index) => {
          return jsx$1(VideoCard, { loading: true, tab: tab2 }, index);
        })
      });
    }
    const renderItem = (item) => {
      if (item.api === EApiType.Separator) {
        return jsx$1(antd.Divider, { className: clsx("grid-col-span-full", clsGateVideoGridDivider), orientation: "left", children: item.content }, item.uniqId);
      } else {
        const index = usingVideoItems.findIndex((x) => x.uniqId === item.uniqId);
        const active = index === activeIndex;
        return jsx$1(VideoCard, { baseCss: [cardBorderCss, getActiveCardBorderCss(active)], tab: tab2, item, active, onRemoveCurrent: (item2, data2, silent) => handleRemoveCards([item2.uniqId], [data2.title], silent), onMoveToFirst: handleMoveCardToFirst, onRefresh: refresh, emitter: videoCardEmitters[index], sharedEmitter, cardDisplay, multiSelecting }, item.uniqId);
      }
    };
    return render3({
      gridChildren: usingItems.map((item) => renderItem(item)),
      gridSiblings: footer
    });
  });
  function useSizeExpression(target, fn, initialValue2) {
    const _fn = useMemoizedFn(fn);
    const box = useRefStateBox(initialValue2);
    H.useEffect(() => {
      const observer = new ResizeObserver((entries) => {
        for (const entry of entries) {
          if (entry.target === target && entry.contentRect) {
            const val = _fn(entry);
            if (!isEqual$1(box.val, val)) {
              box.set(val);
            }
          }
        }
      });
      observer.observe(target);
      return () => {
        observer.disconnect();
      };
    }, [target, _fn]);
    return box.state;
  }
  function useSticky() {
    const stickyRef = H.useRef(null);
    const [sticky, setSticky] = H.useState(false);
    H.useEffect(() => {
      const observe2 = throttle$1(() => {
        if (!stickyRef.current) return;
        const refPageOffset = Math.trunc(stickyRef.current.getBoundingClientRect().top * 10) / 10;
        const stickyOffset = Number.parseInt(getComputedStyle(stickyRef.current).top);
        const stickyActive = refPageOffset <= stickyOffset;
        setSticky(stickyActive);
      }, 16);
      observe2();
      document.addEventListener("scroll", observe2);
      window.addEventListener("resize", observe2);
      window.addEventListener("orientationchange", observe2);
      return () => {
        document.removeEventListener("scroll", observe2);
        window.removeEventListener("resize", observe2);
        window.removeEventListener("orientationchange", observe2);
      };
    }, [sticky]);
    return [stickyRef, sticky];
  }
  function CollapsePanel({
    expanded,
    children,
    ...props
  }) {
    return jsx$1("div", { ...props, "data-classname": "wrapper", css: css("transition:grid-template-rows 0.2s ease-out;display:grid;grid-template-rows:", expanded ? 1 : 0, "fr;", ""), children: jsx$1("div", { "data-classname": "inner", className: "overflow-hidden", children }) });
  }
  async function toastAndReload(msg = "即将刷新网页!") {
    antMessage.info(msg);
    await delay(500);
    location.reload();
  }
  function explainForFlag(checked, unchecked) {
    return jsxs(Fragment, { children: [
      "✅: ",
      checked,
      " ",
jsx$1("br", {}),
      "❎: ",
      unchecked,
      " ",
jsx$1("br", {})
    ] });
  }
  let lastUrl;
  function genUrl() {
    attempt(() => {
      if (lastUrl) URL.revokeObjectURL(lastUrl);
      lastUrl = void 0;
    });
    const val = getSettingsSnapshot();
    const json = JSON.stringify(val, null, 2);
    const blob = new Blob([json], {
      type: "application/json"
    });
    lastUrl = URL.createObjectURL(blob);
    return lastUrl;
  }
  function exportSettings() {
    const url = genUrl();
    const filename = `${APP_NAME}-settings ${dayjs().format("YYYY-MM-DD HH:mm:ss")}.json`;
    if (typeof GM_download !== "undefined") {
      GM_download?.({
        url,
        name: filename
      });
    } else {
      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      link.click();
    }
  }
  async function importSettings() {
    const file = await chooseSingleJsonFile();
    if (!file) return;
    const text = await file.text();
    if (!text) return toast("文件内容为空!");
    let settingsFromFile;
    try {
      settingsFromFile = JSON.parse(text);
    } catch {
      return toast("无法解析文件内容!");
    }
    runSettingsMigration(settingsFromFile);
    const {
      pickedPaths,
      pickedSettings
    } = pickSettings(settingsFromFile, allowedLeafSettingsPaths);
    if (!pickedPaths.length) {
      return toast("没有有效的设置!");
    }
    set_HAS_RESTORED_SETTINGS(true);
    updateSettings(pickedSettings);
    antMessage.success("导入成功!");
    return toastAndReload();
  }
  function chooseSingleJsonFile() {
    return chooseFile({
      accept: ".json",
      multiple: false
    });
  }
  function chooseFile(options) {
    return new Promise((resolve) => {
      const input = document.createElement("input");
      input.type = "file";
      Object.assign(input, options);
      input.addEventListener("change", () => {
        resolve(input.files?.[0] || null);
      });
      input.click();
    });
  }
  const sharedClassNames = {
    tabPane: "max-h-[max(362px,calc(90vh-50px-56px-15px))] min-h-362px overflow-y-auto pr-12px",
    settingsGroup: "mb-10px",
    settingsGroupTitle: "flex items-center text-2em",
    settingsGroupSubTitle: "mt-15px flex items-center text-1.3em"
  };
  function SettingsGroup({
    children,
    title,
    titleClassName,
    contentClassName,
    ...rest
  }) {
    return jsxs("div", { className: sharedClassNames.settingsGroup, "data-role": "settings-group", ...rest, children: [
jsx$1("div", { "data-role": "settings-group-title", className: n(sharedClassNames.settingsGroupTitle, titleClassName), children: title }),
jsx$1("div", { "data-role": "settings-group-content", className: n("flex flex-col gap-y-5px", contentClassName), children })
    ] });
  }
  function resetPartialSettings(paths) {
    const {
      pickedSettings
    } = pickSettings(initialSettings, paths);
    updateSettings(pickedSettings);
  }
  function ResetPartialSettingsButton({
    paths,
    className
  }) {
    return jsx$1(antd.Popconfirm, { title: "确定重置下面的设置项?", onConfirm: () => resetPartialSettings(paths), children: jsxs(antd.Button, { className: clsx("gap-x-4px", className), children: [
jsx$1(ForwardRef$Q, { className: "mt--1px size-12px" }),
jsx$1("span", { children: "重置" })
    ] }) });
  }
  const tablerRestore = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsx$1("path", { d: "M3.06 13a9 9 0 1 0 .49-4.087" }),
jsx$1("path", { d: "M3 4.001v5h5M11 12a1 1 0 1 0 2 0a1 1 0 1 0-2 0" })
    ] })
  ] });
  const ForwardRef$a = H.forwardRef(tablerRestore);
  const tablerFileExport = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsx$1("path", { d: "M14 3v4a1 1 0 0 0 1 1h4" }),
jsx$1("path", { d: "M11.5 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v5m-5 6h7m-3-3l3 3l-3 3" })
    ] })
  ] });
  const ForwardRef$9 = H.forwardRef(tablerFileExport);
  const tablerFileImport = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsx$1("path", { d: "M14 3v4a1 1 0 0 0 1 1h4" }),
jsx$1("path", { d: "M5 13V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2h-5.5M2 19h7m-3-3l3 3l-3 3" })
    ] })
  ] });
  const ForwardRef$8 = H.forwardRef(tablerFileImport);
  const icOutlineCloud = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M12 6c2.62 0 4.88 1.86 5.39 4.43l.3 1.5l1.53.11A2.98 2.98 0 0 1 22 15c0 1.65-1.35 3-3 3H6c-2.21 0-4-1.79-4-4c0-2.05 1.53-3.76 3.56-3.97l1.07-.11l.5-.95A5.47 5.47 0 0 1 12 6m0-2C9.11 4 6.6 5.64 5.35 8.04A5.994 5.994 0 0 0 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5c0-2.64-2.05-4.78-4.65-4.96A7.49 7.49 0 0 0 12 4" })
  ] });
  const ForwardRef$7 = H.forwardRef(icOutlineCloud);
  const iconParkOutlineDownC = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4S4 12.954 4 24s8.954 20 20 20Z" }),
jsx$1("path", { strokeLinecap: "round", d: "m33 21l-9 9l-9-9" })
    ] })
  ] });
  const ForwardRef$6 = H.forwardRef(iconParkOutlineDownC);
  function onResetSettings() {
    resetSettings();
    return toastAndReload();
  }
  async function onRestoreSettings() {
    const remoteSettings = await articleDraft.getData();
    runSettingsMigration(remoteSettings);
    const {
      pickedPaths,
      pickedSettings
    } = pickSettings(remoteSettings, allowedLeafSettingsPaths, restoreOmitPaths);
    if (!pickedPaths.length) {
      return antMessage.error("备份不存在或没有有效的配置");
    }
    set_HAS_RESTORED_SETTINGS(true);
    updateSettings(pickedSettings);
    return toastAndReload();
  }
  function TabPaneAdvance() {
    const {
      autoPreviewUpdateInterval
    } = useSettingsSnapshot();
    const [internalKeysExpanded, setInternalKeysExpanded] = H.useState(false);
    return jsxs("div", { className: sharedClassNames.tabPane, children: [
jsx$1(SettingsGroup, { title: "设置项", children: jsxs(antd.Space, { size: 20, children: [
jsx$1(antd.Popconfirm, { title: "确定", description: "确定恢复默认设置? 此操作不可逆!", onConfirm: onResetSettings, children: jsxs(antd.Button, { danger: true, type: "primary", children: [
jsx$1(ForwardRef$a, {}),
          "恢复默认设置"
        ] }) }),
jsxs(antd.Space, { size: 5, children: [
jsx$1(AntdTooltip, { title: "导出所有设置项到文件中, 包含 access_key 等数据, 请妥善保存", children: jsxs(antd.Button, { onClick: () => exportSettings(), children: [
jsx$1(ForwardRef$9, {}),
            "导出设置"
          ] }) }),
jsx$1(AntdTooltip, { title: "从文件中导入设置项, 将覆盖当前设置, 此操作不可逆!", children: jsxs(antd.Button, { onClick: () => importSettings(), children: [
jsx$1(ForwardRef$8, {}),
            "导入设置"
          ] }) })
        ] })
      ] }) }),
jsx$1(SettingsGroup, { title: jsxs(Fragment, { children: [
jsx$1(ForwardRef$7, { className: "mr-4px size-28px" }),
        "备份"
      ] }), children: jsxs("div", { className: "flex items-center gap-x-40px", children: [
jsxs("span", { className: "flex items-center gap-x-8px", children: [
jsx$1(CheckboxSettingItem, { configPath: "backupSettingsToArticleDraft", label: "备份设置到专栏草稿箱中", tooltip: `专栏 - 草稿箱 - ${APP_NAME}` }),
jsxs("a", { className: "inline-flex items-center", href: "https://member.bilibili.com/platform/upload/text/draft", target: "_blank", children: [
jsx$1(IconForOpenExternalLink, { className: "mr-4px size-16px" }),
            "去草稿箱浏览"
          ] })
        ] }),
jsx$1(antd.Popconfirm, { title: "确定", description: "将覆盖本地设置? 此操作不可逆!", onConfirm: onRestoreSettings, children: jsxs(antd.Button, { danger: true, type: "primary", children: [
jsx$1(ForwardRef$a, {}),
          "从专栏草稿箱中恢复"
        ] }) })
      ] }) }),
jsx$1(SettingsGroup, { titleClassName: "justify-between", title: jsxs(Fragment, { children: [
        "预览",
jsx$1(ResetPartialSettingsButton, { paths: ["autoPreviewUpdateInterval"] })
      ] }), children: jsxs("div", { className: "flex-v-center", children: [
        "自动预览更新间隔",
jsx$1(antd.Slider, { style: {
          flex: 1,
          margin: "0 15px"
        }, min: 0, max: 1e3, keyboard: true, onChange: (val) => settings.autoPreviewUpdateInterval = val, value: autoPreviewUpdateInterval }),
jsxs("span", { style: {
          width: "65px"
        }, children: [
          "(",
          autoPreviewUpdateInterval,
          "ms)"
        ] })
      ] }) }),
jsx$1(SettingsGroup, { title: jsxs(Fragment, { children: [
        "其他",
jsx$1(HelpInfo, { children: "这里是一些作者不愿意解释的设置项 😬" }),
jsx$1(antd.Button, { onClick: () => setInternalKeysExpanded((v) => !v), className: "ml-10px inline-icon-only-round-button", css: internalKeysExpanded && buttonOpenCss, children: jsx$1(ForwardRef$6, { className: clsx("size-16px transition-300 transition-transform", internalKeysExpanded ? "rotate-180" : "rotate-0") }) })
      ] }), children: jsx$1(CollapsePanel, { expanded: internalKeysExpanded, children: jsxs("div", { className: "w-full flex gap-x-20px b-1px b-gate-border rounded-6px b-solid p-10px", children: [
jsx$1(ResetPartialSettingsButton, { paths: internalBooleanPaths, className: "flex-none" }),
jsx$1("div", { className: "flex flex-1 flex-wrap items-start gap-x-20px gap-y-10px", children: internalBooleanPaths.map((k) => jsx$1(CheckboxSettingItem, { configPath: k, tooltip: jsxs(Fragment, { children: [
          k,
          INTERNAL_BOOLEAN_TOOLTIPS[k] && jsxs(Fragment, { children: [
jsx$1("br", {}),
            INTERNAL_BOOLEAN_TOOLTIPS[k]
          ] })
        ] }), label: startCase(k.startsWith("__internal") ? k.slice("__internal".length) : k.replaceAll("__internal.", "")) }, k)) })
      ] }) }) })
    ] });
  }
  const INTERNAL_BOOLEAN_TOOLTIPS = {};
  const newSignedForm = (params) => {
    const sign = appSign(params, TVKeyInfo.appkey, TVKeyInfo.appsec);
    return new URLSearchParams({
      ...params,
      sign
    });
  };
  async function getQrCodeInfo() {
    const res = await request.post(
      "https://passport.bilibili.com/x/passport-tv-login/qrcode/auth_code",
      newSignedForm({
        appkey: TVKeyInfo.appkey,
        local_id: "0",
        ts: "0"
      })
);
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      toast(json?.message || "获取 auth_code 失败");
      return;
    }
    return json.data;
  }
  async function poll(auth_code) {
    const res = await request.post("https://passport.bilibili.com/x/passport-tv-login/qrcode/poll", newSignedForm({
      appkey: TVKeyInfo.appkey,
      auth_code,
      local_id: "0",
      ts: "0"
    }));
    const json = res.data;
    const msgMap = {
      "0": "成功",
      "-3": "API校验密匙错误",
      "-400": "请求错误",
      "-404": "啥都木有",
      "86038": "二维码已失效",
      "86039": "二维码尚未确认",
      "86090": "二维码已扫码未确认"
    };
    if (!isWebApiSuccess(json)) {
      const code = json.code.toString();
      const message2 = json.message || msgMap[code] || "未知错误";
      if (code === "86038") {
        return {
          success: false,
          message: message2,
          action: "refresh"
        };
      }
      if (code === "86039" || code === "86090") {
        return {
          success: false,
          message: message2,
          action: "wait"
        };
      }
      return {
        success: false,
        message: message2,
        action: void 0
      };
    }
    const accessKey = json.data.access_token;
    const accessKeyExpireAt = Date.now() + json.data.expires_in * 1e3;
    return {
      success: true,
      message: "获取成功",
      accessKey,
      accessKeyExpireAt
    };
  }
  const initialValue = {
    show: false,
    qrcodeUrl: "",
    auth_code: "",
    message: ""
  };
  const store = proxy({
    ...initialValue
  });
  function updateStore(data2) {
    renderOnce$1();
    Object.assign(store, data2);
  }
  function showQrCodeModal(data2) {
    updateStore({
      ...initialValue,
      ...data2,
      show: true
    });
  }
  const emitter = new Emittery();
  function hideQrCodeModal() {
    updateStore({
      ...initialValue
    });
    emitter.emit("hide");
  }
  function whenQrCodeModalHide() {
    return emitter.once("hide");
  }
  function TvQrCodeAuth() {
    const {
      qrcodeUrl,
      show,
      message: message2
    } = useSnapshot(store);
    const onHide2 = hideQrCodeModal;
    return jsxs(BaseModal, { show, onHide: onHide2, hideWhenMaskOnClick: false, hideWhenEsc: false, clsModalMask: "backdrop-blur-10px", clsModal: "aspect-ratio-10/16", width: 260, children: [
jsxs("div", { className: BaseModalClassNames.modalHeader, children: [
jsx$1("div", { className: BaseModalClassNames.modalTitle }),
jsx$1(ModalClose, { onClick: onHide2 })
      ] }),
jsxs("div", { className: clsx(BaseModalClassNames.modalBody, "flex flex-col items-center justify-center text-center"), children: [
jsx$1("div", { className: "mb-2px min-h-25px flex-center text-size-14px", children: message2 || "" }),
        qrcodeUrl && jsx$1(antd.QRCode, { className: "mx-auto mb-40px flex-shrink-0 p-8px", value: qrcodeUrl, size: 200, icon: "https://is1-ssl.mzstatic.com/image/thumb/Purple211/v4/72/9c/b6/729cb6d8-75f5-0a56-0508-3a26cbba69ae/AppIcon-1x_U007emarketing-0-6-0-0-85-220-0.png/230x0w.webp" }),
jsxs("div", { className: "footnote text-size-13px", children: [
          "打开「哔哩哔哩」或「bilibili」App ",
jsx$1("br", {}),
          "扫码获取 access_key"
        ] })
      ] })
    ] });
  }
  const renderOnce$1 = once(function render() {
    const container = document.createElement("div");
    container.classList.add("modal-tv-qrcode-auth", APP_CLS_ROOT);
    document.body.appendChild(container);
    const r2 = clientExports.createRoot(container);
    r2.render( jsx$1(AppRoot, { children: jsx$1(TvQrCodeAuth, {}) }));
  });
  async function refreshQrCode() {
    const qrinfo = await getQrCodeInfo();
    if (!qrinfo) return;
    showQrCodeModal({
      qrcodeUrl: qrinfo.url,
      auth_code: qrinfo.auth_code
    });
    return true;
  }
  async function getAccessKeyByQrCode() {
    const next2 = await refreshQrCode();
    if (!next2) return;
    let res;
    let pollfor = store.auth_code;
    function shouldBreak() {
      if (!store.show) return true;
      if (!store.auth_code) return true;
      if (pollfor !== store.auth_code) return true;
    }
    function shouldContinue() {
      return !shouldBreak();
    }
    while (shouldContinue()) {
      const p1 = delay(1500);
      const p2 = whenQrCodeModalHide();
      await Promise.race([p1, p2]);
      p2.off();
      if (shouldBreak()) return;
      res = await poll(store.auth_code);
      const {
        success,
        accessKey,
        accessKeyExpireAt,
        message: message2,
        action: action2
      } = res;
      if (shouldBreak()) return;
      updateStore({
        message: message2
      });
      if (success) {
        await delay(1e3);
        hideQrCodeModal();
        return {
          accessKey,
          accessKeyExpireAt
        };
      }
      if (action2 === "refresh") {
        await delay(2e3);
        if (shouldBreak()) return;
        await refreshQrCode();
        pollfor = store.auth_code;
        updateStore({
          message: "已刷新二维码"
        });
        continue;
      }
      if (action2 === "wait") {
        continue;
      }
      updateStore({
        message: message2
      });
      toast(message2);
      return;
    }
  }
  async function getAccessKey() {
    const {
      accessKey,
      accessKeyExpireAt
    } = await getAccessKeyByQrCode() || {};
    if (!accessKey || !accessKeyExpireAt) return;
    settings.accessKey = accessKey;
    settings.accessKeyExpireAt = accessKeyExpireAt;
    toast("获取成功");
  }
  function deleteAccessKey() {
    settings.accessKey = "";
    settings.accessKeyExpireAt = 0;
    toast("已删除 access_key");
  }
  const btnAccessKeyHelpLink = jsx$1(antd.Button, { target: "_blank", href: "https://github.com/indefined/UserScripts/tree/master/bilibiliHome#%E6%8E%88%E6%9D%83%E8%AF%B4%E6%98%8E", children: "access_key 说明" });
  function AccessKeyManage({
    style,
    className
  }) {
    const {
      runAsync,
      loading
    } = useRequest(getAccessKey, {
      manual: true
    });
    const {
      accessKey
    } = useSettingsSnapshot();
    const onDeleteAccessKey = deleteAccessKey;
    return jsx$1(antd.Space, { size: "small", style, className, children: !accessKey ? jsxs(Fragment, { children: [
jsx$1(antd.Button, { onClick: runAsync, loading, children: "获取 access_key" }),
      btnAccessKeyHelpLink
    ] }) : jsxs(Fragment, { children: [
jsx$1(antd.Button, { onClick: runAsync, loading, children: "重新获取 access_key" }),
jsx$1(antd.Popconfirm, { onConfirm: onDeleteAccessKey, title: "确定删除 access_key?", children: jsx$1(antd.Button, { children: "删除 access_key" }) }),
      btnAccessKeyHelpLink
    ] }) });
  }
  const iconParkOutlineHelp = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", children: [
jsx$1("path", { stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, d: "M24 44a19.94 19.94 0 0 0 14.142-5.858A19.94 19.94 0 0 0 44 24a19.94 19.94 0 0 0-5.858-14.142A19.94 19.94 0 0 0 24 4A19.94 19.94 0 0 0 9.858 9.858A19.94 19.94 0 0 0 4 24a19.94 19.94 0 0 0 5.858 14.142A19.94 19.94 0 0 0 24 44Z" }),
jsx$1("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "M24 28.625v-4a6 6 0 1 0-6-6" }),
jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M24 37.625a2.5 2.5 0 1 0 0-5a2.5 2.5 0 0 0 0 5", clipRule: "evenodd" })
    ] })
  ] });
  const ForwardRef$5 = H.forwardRef(iconParkOutlineHelp);
  function TabPaneBasic() {
    const {
      videoLinkOpenMode,
      videoCard: {
        actions: {
          showLargePreview,
          openInPipWindow: openInPipWindow2
        }
      }
    } = useSettingsSnapshot();
    const openModeOptions = H.useMemo(() => {
      return Object.values(VideoLinkOpenMode).filter((mode) => VideoLinkOpenModeConfig[mode].enabled ?? true).map((mode) => {
        const config = VideoLinkOpenModeConfig[mode];
        return {
          config,
          value: mode,
          label: jsxs("span", { className: "flex-v-center gap-x-8px", children: [
            config.icon,
jsx$1("span", { children: config.label })
          ] })
        };
      });
    }, []);
    const handleCopyScriptVersion = useMemoizedFn(() => {
      const content = `v${"0.33.9"}`;
      GM.setClipboard(content);
      antMessage.success(`已复制当前版本: ${content}`);
    });
    return jsxs("div", { className: sharedClassNames.tabPane, children: [
jsx$1(SettingsGroup, { title: jsxs(Fragment, { children: [
jsx$1(TabIcon, { tabKey: ETab.AppRecommend, className: "mr-5px mt-2px size-30px" }),
        "推荐 access_key",
jsxs(HelpInfo, { className: "ml-5px mt-6px size-18px", IconComponent: ForwardRef$5, children: [
jsxs("span", { className: "inline-flex items-center", children: [
            "用于「",
jsx$1(TabIcon, { tabKey: ETab.AppRecommend, className: "mr-5px" }),
            "推荐」Tab"
          ] }),
jsx$1("br", {}),
          "用于 获取推荐 / 提交不喜欢等操作"
        ] })
      ] }), children: jsx$1(AccessKeyManage, {}) }),
jsx$1(SettingsGroup, { titleClassName: "justify-between", title: jsxs(Fragment, { children: [
        "开关",
jsx$1(ResetPartialSettingsButton, { paths: ["pureRecommend", "useNarrowMode", "showModalFeedOnLoad", "showModalFeedEntry", "multiSelect.showIcon"] })
      ] }), children: jsxs(antd.Space, { size: 10, wrap: true, children: [
jsx$1(CheckboxSettingItem, { configPath: "pureRecommend", label: "全屏模式", tooltip: jsxs(Fragment, { children: [
          "清空自带推荐内容, 只显示脚本推荐",
jsx$1("br", {}),
          "P.S 需要刷新网页~",
jsx$1("br", {}),
          "P.S 之前版本称 (纯推荐模式)"
        ] }), extraAction: () => toastAndReload() }),
jsx$1(CheckboxSettingItem, { configPath: "useNarrowMode", label: "居中模式", tooltip: jsxs(Fragment, { children: [
          "居中两列",
jsx$1("br", {}),
          "切换设置快捷键: ",
jsx$1(antd.Tag, { color: "green", children: "shift+c" })
        ] }) }),
jsx$1(CheckboxSettingItem, { configPath: "showModalFeedOnLoad", label: "自动「查看更多」", tooltip: "打开首页时自动打开「查看更多」弹窗", extraAction: (val) => {
          if (val) {
            antMessage.success("已开启自动「查看更多」: 下次打开首页时将自动打开「查看更多」弹窗");
          }
        } }),
jsx$1(CheckboxSettingItem, { configPath: "showModalFeedEntry", label: "「查看更多」按钮", tooltip: "是否显示「查看更多」按钮" }),
jsx$1(CheckboxSettingItem, { configPath: "multiSelect.showIcon", label: "「多选」按钮", tooltip: "是否显示「多选」按钮" })
      ] }) }),
jsx$1(SettingsGroup, { titleClassName: "justify-between", title: jsxs(Fragment, { children: [
        "视频链接",
jsx$1(ResetPartialSettingsButton, { paths: ["videoLinkOpenMode"] })
      ] }), children: jsx$1(antd.Space, { size: 20, children: jsxs("div", { className: "flex-v-center", children: [
        "默认打开模式",
jsxs(HelpInfo, { useBlackBg: true, children: [
          "选择点击视频(封面图片 或 标题)时打开的模式 ",
jsx$1("br", {}),
          openModeOptions.map(({
            value,
            config
          }) => {
            return !!config.desc && jsxs("div", { className: "mt-10px flex items-start first:mt-0", children: [
jsxs("span", { className: "inline-flex items-center", children: [
                config.icon,
jsx$1("span", { className: "ml-4px mr-10px min-w-95px", children: config.label })
              ] }),
jsx$1("span", { className: "desc", children: config.desc })
            ] }, value);
          })
        ] }),
jsx$1(antd.Select, { className: "ml-8px w-160px", options: openModeOptions, value: videoLinkOpenMode, onChange: (v) => {
          updateSettings({
            videoLinkOpenMode: v
          });
        } })
      ] }) }) }),
jsx$1(SettingsGroup, { titleClassName: "justify-between", title: jsxs(Fragment, { children: [
jsxs("span", { className: "flex items-center", children: [
          "视频卡片操作 ",
jsx$1(HelpInfo, { children: "视频卡片右上角「稍后再看」按钮旁" })
        ] }),
jsx$1(ResetPartialSettingsButton, { paths: ["videoCard.actions.showLargePreview", "videoCard.actions.openInPipWindow", "videoCard.videoPreview.useMp4", "videoCard.videoPreview.usePreferredCdn", "videoCard.videoPreview.useScale", "videoCard.videoPreview.useVideoCardAsTrigger", "pipWindow.defaultLocked", "pipWindow.autoWebFullscreen"] })
      ] }), children: jsxs("div", { className: "grid grid-cols-[repeat(2,max-content)_1fr] items-start gap-x-20px", children: [
jsx$1(CheckboxSettingItem, { configPath: "videoCard.actions.showLargePreview", label: "浮动预览", tooltip: jsxs(Fragment, { children: [
          "创意来源「浮图秀」, 但使用视频预览 ",
jsx$1("br", {}),
          "操作说明: ",
jsx$1("br", {}),
          "1. 鼠标悬浮打开 「浮动预览」, 离开关闭 ",
jsx$1("br", {}),
          "2. 点击固定「浮动预览」, 固定指: 不再随鼠标移出关闭预览 ",
jsx$1("br", {}),
          "3. 可使用以下方式关闭固定的「浮动预览」",
jsxs("ul", { className: "ml-30px list-circle", children: [
jsx$1("li", { children: "再次点击视频卡片按钮" }),
jsx$1("li", { children: "点击预览视频右上方的「关闭」按钮" }),
jsx$1("li", { children: "触发其他卡片的「浮动预览」" }),
jsx$1("li", { children: "Esc键" }),
jsx$1("li", { children: "点击页面空白处" })
          ] })
        ] }) }),
jsx$1(CheckboxSettingItem, { configPath: "videoCard.actions.openInPipWindow", label: "小窗打开", tooltip: jsx$1(Fragment, { children: "仅当「文档画中画」API 可用时, 勾选生效" }) }),
jsx$1(antd.Divider, { className: "grid-col-span-full my-2px py-0" }),
jsxs("div", { className: "flex flex-col", children: [
jsx$1(CheckboxSettingItem, { configPath: "videoCard.videoPreview.useMp4", disabled: !showLargePreview, label: "浮动预览: 使用 mp4", tooltip: explainForFlag("使用 mp4, 最高 720p, 有声音", "使用 dash, 最高 1080p, 无声音, 理论上更快") }),
jsx$1(CheckboxSettingItem, { configPath: "videoCard.videoPreview.usePreferredCdn", disabled: !showLargePreview, label: "浮动预览: 使用优选 CDN", tooltip: explainForFlag("使用优选 CDN (降低 MCDN & PCDN 优先级)", "使用默认 CDN") }),
jsx$1(CheckboxSettingItem, { configPath: "videoCard.videoPreview.useScale", disabled: !showLargePreview, label: "浮动预览: 使用放大效果", tooltip: explainForFlag("浮动预览面板: 放大展开 (类似浮图秀)", "浮动预览面板: 滑动展开") }),
jsx$1(CheckboxSettingItem, { configPath: "videoCard.videoPreview.useVideoCardAsTrigger", disabled: !showLargePreview, label: "浮动预览: 使用视频卡片作为触发器", tooltip: jsxs(Fragment, { children: [
            "使用视频卡片作为触发器 ",
jsx$1("br", {}),
jsxs("ul", { className: "list-circle pl-25px", children: [
jsx$1("li", { children: "悬浮视频卡片 1 秒后展开「浮动预览」" }),
jsx$1("li", { children: "与视频卡片右上角按钮相比, 更容易触发, 但也容易非预览意图误触发" }),
jsx$1("li", { children: "与视频卡片右上角按钮独立, 关掉视频卡片按钮, 此选项仍然生效" })
            ] })
          ] }) })
        ] }),
jsxs("div", { className: "flex flex-col", children: [
jsx$1(CheckboxSettingItem, { configPath: "pipWindow.defaultLocked", disabled: !openInPipWindow2, label: "小窗: 默认锁定", tooltip: explainForFlag("小窗打开时: 默认锁定", "小窗打开时: 不锁定") }),
jsx$1(CheckboxSettingItem, { configPath: "pipWindow.autoWebFullscreen", disabled: !openInPipWindow2, label: "小窗: 自动网页全屏", tooltip: explainForFlag("自动网页全屏", "不启用") })
        ] })
      ] }) }),
jsxs(SettingsGroup, { titleClassName: "justify-between", title: jsxs(Fragment, { children: [
        "预览",
jsx$1(ResetPartialSettingsButton, { paths: ["autoPreviewWhenKeyboardSelect", "autoPreviewWhenHover"] })
      ] }), contentClassName: "flex-row flex-wrap items-center gap-x-10px", children: [
jsx$1(CheckboxSettingItem, { configPath: "autoPreviewWhenKeyboardSelect", label: "键盘选中后自动开始预览", tooltip: jsxs(Fragment, { children: [
          "手动预览快捷键: ",
jsx$1(antd.Tag, { color: "green", children: "." }),
          " or ",
jsx$1(antd.Tag, { color: "green", children: "p" }),
jsx$1("br", {}),
          "切换设置快捷键: ",
jsx$1(antd.Tag, { color: "green", children: "shift+p" })
        ] }) }),
jsx$1(CheckboxSettingItem, { configPath: "autoPreviewWhenHover", label: "鼠标悬浮后自动开始预览", tooltip: jsxs(Fragment, { children: [
          "鼠标悬浮后自动开始预览, 预览不再跟随鼠标位置 ",
jsx$1("br", {}),
          "切换设置快捷键: ",
jsx$1(antd.Tag, { color: "green", children: "shift+m" })
        ] }) })
      ] }),
jsxs(SettingsGroup, { title: jsxs(Fragment, { children: [
        "帮助",
jsxs("span", { className: "relative top-4px ml-8px mr-4px inline-flex items-center text-size-14px", children: [
          "当前版本",
jsxs(antd.Tag, { color: "green", className: "mx-4px cursor-pointer", onClick: handleCopyScriptVersion, children: [
            APP_NAME,
            " v",
            "0.33.9"
          ] }),
jsx$1(IconForCopy, { className: "size-16px cursor-pointer", onClick: handleCopyScriptVersion })
        ] })
      ] }), contentClassName: "flex-row gap-x-10px", children: [
jsx$1(AntdTooltip, { title: "来个 Star 支持一下", children: jsx$1(antd.Button, { href: "https://github.com/magicdawn/Bilibili-Gate", target: "_blank", children: "GitHub 主页" }) }),
jsx$1(antd.Button, { href: "https://afdian.com/a/magicdawn", target: "_blank", children: "「爱发电」支持" }),
jsx$1(antd.Button, { href: "https://greasyfork.org/zh-CN/scripts/443530-bilibili-gate", target: "_blank", children: "GreasyFork 主页" }),
jsx$1(antd.Button, { href: "https://github.com/magicdawn/Bilibili-Gate/#%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AF%B4%E6%98%8E", target: "_blank", children: "查看可用的快捷键" }),
jsx$1(antd.Button, { href: "https://github.com/magicdawn/Bilibili-Gate/releases", target: "_blank", children: "更新日志" })
      ] })
    ] });
  }
  const borderCycleList = [
    {
      useBorder: false
    },
{
      useBorder: true,
      useBorderOnlyOnHover: true
    },
{
      useBorder: true,
      useBorderOnlyOnHover: false
    }
];
  const borderCycleListLabels = ["「卡片边框」: 禁用", "「卡片边框」: 仅在悬浮时显示", "「卡片边框」: 总是显示"];
  function useHotkeyForConfigBorder() {
    return useKeyPress(["shift.b"], (e2) => {
      if (shouldDisableShortcut()) return;
      const curState = pick(settings.style.videoCard, ["useBorder", "useBorderOnlyOnHover"]);
      const curIndex = borderCycleList.findIndex((state2) => {
        return isEqual$1(state2, pick(curState, Object.keys(state2)));
      });
      if (curIndex === -1) throw new Error("unexpected curIndex = -1");
      const nextIndex = (curIndex + 1) % borderCycleList.length;
      const nextState = borderCycleList[nextIndex];
      Object.assign(settings.style.videoCard, nextState);
      const nextLabel = borderCycleListLabels[nextIndex];
      antMessage.success(nextLabel);
    }, {
      exactMatch: true
    });
  }
  function TabPaneCustomUI() {
    const {
      style
    } = useSettingsSnapshot();
    const rootClassName = n(sharedClassNames.tabPane, "flex flex-col flex-wrap content-start gap-x-30px gap-y-10px");
    const itemsContainerClassName = "flex flex-col gap-y-4px";
    return jsxs("div", { className: rootClassName, children: [
jsx$1(SettingsGroup, { title: jsxs(Fragment, { children: [
        "通用",
jsx$1(ResetPartialSettingsButton, { className: "ml-10px", paths: ["style.general.popoverBorderColorUseColorPrimary"] })
      ] }), children: jsx$1("div", { className: itemsContainerClassName, children: jsx$1(CheckboxSettingItem, { configPath: "style.general.popoverBorderColorUseColorPrimary", label: "下拉面板使用主题色边框" }) }) }),
jsx$1(SettingsGroup, { title: jsxs(Fragment, { children: [
        "全屏模式",
jsx$1(ResetPartialSettingsButton, { className: "ml-10px", paths: ["style.pureRecommend.useStickyTabbar", "style.pureRecommend.stickyTabbarShadow", "style.pureRecommend.useCustomGrid", "style.pureRecommend.useWhiteBackground", "style.pureRecommend.hideTopChannel"] })
      ] }), children: jsxs("div", { className: itemsContainerClassName, children: [
jsx$1(CheckboxSettingItem, { configPath: "style.pureRecommend.useStickyTabbar", label: "全屏模式: 固定 Tab 栏", tooltip: explainForFlag("Tab 栏会吸附在顶栏下方", "Tab 栏会随页面一起滚动") }),
jsx$1(CheckboxSettingItem, { disabled: !style.pureRecommend.useStickyTabbar, configPath: "style.pureRecommend.stickyTabbarShadow", label: "全屏模式: 固定 Tab 栏 : 添加边框 & 阴影", tooltip: explainForFlag("Tab 栏在吸附状态下: 加宽, 添加边框 & 阴影", "不改变") }),
jsx$1(CheckboxSettingItem, { configPath: "style.pureRecommend.useCustomGrid", label: "全屏模式: 使用自定义网格配置", tooltip: jsxs(Fragment, { children: [
          "网格配置指: 网格宽度, 间距, 列数等. ",
jsx$1("br", {}),
          "自定义网格配置: 宽度为90%; 可跟随 Bilibili-Evolved 自定义顶栏配置; 列数: 4 - 10列; 由 ",
          APP_NAME,
          " 自定义; ",
jsx$1("br", {}),
          "默认网格配置: bili-feed4 版本B站首页默认的网格配置; 在 Safari 中使用建议取消勾选此项."
        ] }) }),
jsx$1(CheckboxSettingItem, { configPath: "style.pureRecommend.useWhiteBackground", label: "全屏模式: 使用纯白背景", tooltip: explainForFlag("纯白背景", "浅灰色背景") }),
jsx$1(CheckboxSettingItem, { configPath: "style.pureRecommend.hideTopChannel", label: "全屏模式: 隐藏顶部分区和Banner" })
      ] }) }),
jsx$1(SettingsGroup, { title: jsxs(Fragment, { children: [
        "视频卡片",
jsx$1(ResetPartialSettingsButton, { className: "ml-10px", paths: ["style.videoCard.useBorder", "style.videoCard.useBorderOnlyOnHover", "style.videoCard.useBoxShadow", "useDelayForHover"] })
      ] }), children: jsxs("div", { className: itemsContainerClassName, children: [
jsx$1(CheckboxSettingItem, { configPath: "style.videoCard.useBorder", label: "使用卡片边框", tooltip: jsxs(Fragment, { children: [
          "勾选后, 视频卡片会有边框包裹, 更像是一个卡片~ ",
jsx$1("br", {}),
          "整个卡片区域可点击 / 可触发预览 / 可使用右键菜单 ",
jsx$1("br", {}),
          "否则只是封面区域可以 ",
jsx$1("br", {}),
          "使用快捷键 ",
jsx$1(antd.Tag, { color: "green", children: "shift+b" }),
          " 切换状态",
jsx$1("br", {}),
          borderCycleListLabels.map((label) => jsx$1(antd.Tag, { color: "success", children: label }, label))
        ] }) }),
jsx$1(CheckboxSettingItem, { configPath: "style.videoCard.useBorderOnlyOnHover", label: "仅在悬浮时显示", disabled: !style.videoCard.useBorder, tooltip: explainForFlag("仅在悬浮时显示", "一直显示") }),
jsx$1(CheckboxSettingItem, { configPath: "style.videoCard.useBoxShadow", disabled: !style.videoCard.useBorder, label: "悬浮卡片时使用发光效果", tooltip: jsx$1(Fragment, { children: "悬浮卡片时使用发光效果, 看起来比较花哨~" }) }),
jsx$1(CheckboxSettingItem, { configPath: "useDelayForHover", label: "延迟悬浮预览", tooltip: jsx$1(Fragment, { children: "延迟悬浮预览" }) })
      ] }) })
    ] });
  }
  function exportFilterByAuthor() {
    return _exportForPath("filter.byAuthor.keywords");
  }
  function importFilterByAuthor() {
    return _importForPath("filter.byAuthor.keywords");
  }
  function exportFilterByTitle() {
    return _exportForPath("filter.byTitle.keywords");
  }
  function importFilterByTitle() {
    return _importForPath("filter.byTitle.keywords");
  }
  function getJsonKey(p2) {
    return `__${APP_NAME}:${p2}__`;
  }
  async function _exportForPath(listSettingsPath) {
    const key = getJsonKey(listSettingsPath);
    const val = await getNewestValueOfSettingsInnerArray(listSettingsPath);
    GM.setClipboard(JSON.stringify({
      [key]: val
    }, null, 2));
    antMessage.success("已复制到剪贴板!");
  }
  async function _importForPath(listSettingsPath) {
    const [errClip, text] = await attemptAsync(() => navigator.clipboard.readText());
    if (errClip) return antMessage.error("读取剪贴板失败!");
    if (!text) return antMessage.error("剪贴板内容为空!");
    const [errJson, json] = attempt(() => JSON.parse(text));
    if (errJson) return antMessage.error("无法解析剪贴板内容!");
    if (!json) return antMessage.error("剪贴板内容为空!");
    const key = getJsonKey(listSettingsPath);
    const val = json?.[key];
    if (!val?.length) return antMessage.error("没有符合条件的数据!");
    const currentList = await getNewestValueOfSettingsInnerArray(listSettingsPath);
    const toAdd = difference(val, currentList);
    if (!toAdd.length) return antMessage.warning("没有可导入内容, 已全部存在!");
    updateSettingsInnerArray(listSettingsPath, {
      add: toAdd
    });
    antMessage.success(`已导入 ${toAdd.length} 条数据!`);
  }
  const iconParkOutlineCloseSmall = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "m14 14l20 20m-20 0l20-20" })
  ] });
  const ForwardRef$4 = H.forwardRef(iconParkOutlineCloseSmall);
  const {
    Search
  } = antd.Input;
  var _ref = {
    name: "2vv6yp",
    styles: "color:var(--ant-color-text-disabled);background-color:var(--ant-color-bg-container-disabled);border-color:var(--ant-color-border);box-shadow:none;opacity:1;pointer-events:none;cursor:not-allowed"
  };
  function EditableListSettingItem({
    configPath,
    searchProps,
    disabled
  }) {
    const rawList = useSettingsInnerArray(configPath);
    const list2 = H.useMemo(() => uniq(rawList).toReversed(), [rawList]);
    return jsxs(Fragment, { children: [
jsx$1(Search, { className: "my-5px", enterButton: "添加", allowClear: true, disabled, ...searchProps, onSearch: async (val, e2) => {
        if (!val) return;
        const set2 = new Set(await getNewestValueOfSettingsInnerArray(configPath));
        if (set2.has(val)) {
          antMessage.warning(`${val} 已存在`);
          return;
        }
        await updateSettingsInnerArray(configPath, {
          add: [val]
        });
        if (e2?.target) {
          const el = e2.target;
          const clearBtn = el.closest(".ant-input-wrapper")?.querySelector(".ant-input-clear-icon");
          clearBtn?.click();
        }
      } }),
jsx$1("div", { css: [ css("min-height:82px;border-radius:6px;border:1px solid ", borderColorValue, ";margin-top:3px;", ""), disabled && _ref, "", ""], children: list2.length ? jsx$1("div", { className: "max-h-250px flex flex-wrap items-start gap-x-10px gap-y-5px overflow-y-auto py-5px pl-5px pr-10px", children: list2.map((t2) => {
        return jsx$1(TagItemDisplay, { tag: t2.toString(), onDelete: async (tag) => {
          await updateSettingsInnerArray(configPath, {
            remove: [tag]
          });
        }, renderTag: configPath === "filter.byAuthor.keywords" ? (tag) => jsx$1(UpTagItemDisplay, { tag }) : void 0 }, t2);
      }) }) : jsx$1(antd.Empty, { image: antd.Empty.PRESENTED_IMAGE_SIMPLE, description: "空空如也", className: "[&.ant-empty-normal]:my-5px" }) })
    ] });
  }
  const TagItemDisplay = H.forwardRef(({
    tag,
    renderTag,
    onDelete,
    className,
    ...restProps
  }, ref) => {
    return jsxs("div", { ref, className: clsx("relative inline-flex items-center b-1px b-gate-border rounded-5px b-solid px-6px py-2px hover:b-gate-primary hover:color-gate-primary", className), ...restProps, children: [
      renderTag ? renderTag(tag) : tag,
jsx$1(ForwardRef$4, { className: "ml-2px size-16px cursor-pointer text-size-12px", onClick: () => {
        onDelete?.(tag);
      } })
    ] });
  });
  function UpTagItemDisplay({
    tag
  }) {
    const {
      mid,
      remark
    } = H.useMemo(() => parseUpRepresent(tag), [tag]);
    const [nicknameByMid, setNicknameByMid] = H.useState(void 0);
    H.useEffect(() => {
      void (async () => {
        if (!mid) return;
        const nickname = await getUserNickname(mid);
        if (nickname) setNicknameByMid(nickname);
      })();
    }, [mid]);
    const label = mid ? (
nicknameByMid || remark || mid
    ) : tag;
    const tooltip = jsxs(Fragment, { children: [
      !!mid && jsxs(Fragment, { children: [
        "mid: ",
        mid,
        " ",
jsx$1("br", {})
      ] }),
      !!remark && jsxs(Fragment, { children: [
        "备注: ",
        remark,
        " ",
jsx$1("br", {}),
        remark === nicknameByMid && jsxs(Fragment, { children: [
          'P.S "备注" 与 "用户昵称" 相同, 是之前的数据, 现在你只需要填写 mid, 会自动获取昵称 ',
jsx$1("br", {})
        ] })
      ] }),
      !mid && jsxs(Fragment, { children: [
        "使用用户名过滤: 用户可能改名, 建议使用 mid 过滤 ",
jsx$1("br", {})
      ] })
    ] });
    return jsx$1(Fragment, { children: jsx$1(AntdTooltip, { title: tooltip, children: jsxs("span", { className: clsx("inline-flex items-center justify-center", mid ? "cursor-pointer" : "cursor-[edit]"), children: [
      mid && jsx$1(ForwardRef$y, { className: "mr-2px size-12px" }),
      mid ? jsx$1("a", { href: formatSpaceUrl(mid), target: "_blank", style: {
        color: "inherit"
      }, children: label }) : label
    ] }) }) });
  }
  function TabPaneFilter() {
    const {
      enabled,
      minDuration,
      minPlayCount,
      minDanmakuCount,
      hideGotoTypeBangumi,
      hideGotoTypePicture,
      byAuthor,
      byTitle
    } = useSettingsSnapshot().filter;
    const getExemptFollowedTooltipProps = (label) => {
      return {
        label: "「已关注」豁免",
        tooltipProps: {
          color: TOOLTIP_BLACK_BG_COLOR
        },
        tooltip: jsxs(Fragment, { children: [
          "「已关注」内容不考虑过滤条件, 总是展示",
jsx$1("br", {}),
          '"豁免" 一词来源',
          " ",
jsx$1("a", { target: "_blank", href: "https://github.com/magicdawn/Bilibili-Gate/issues/1#issuecomment-2197868587", children: "pilipala" })
        ] })
      };
    };
    return jsx$1("div", { className: clsx(sharedClassNames.tabPane, "pr-15px"), children: jsx$1(SettingsGroup, { title: jsxs(Fragment, { children: [
      "内容过滤",
jsxs(HelpInfo, { children: [
        "启用过滤会降低加载速度! ",
jsx$1("br", {}),
        "视频/图文/影视: 仅推荐类 Tab 生效 ",
jsx$1("br", {}),
        "UP/标题: 推荐类 / 热门 等Tab 生效"
      ] }),
jsx$1(SwitchSettingItem, { configPath: "filter.enabled", className: "ml-10px" })
    ] }), children: jsxs("div", { className: "grid grid-cols-2 gap-x-15px", children: [
jsxs("div", { className: "col", children: [
jsx$1("div", { className: sharedClassNames.settingsGroupSubTitle, children: "视频" }),
jsxs("div", { className: "flex flex-col gap-y-5px", children: [
jsxs("div", { className: "flex items-center", children: [
jsx$1(CheckboxSettingItem, { configPath: "filter.minDuration.enabled", label: "按视频时长过滤", tooltip: jsx$1(Fragment, { children: "不显示短视频" }), disabled: !enabled, className: "min-w-130px" }),
jsx$1(antd.InputNumber, { className: "w-130px", size: "small", min: 1, step: 10, addonAfter: "秒", value: minDuration.value, onChange: (val) => !isNil(val) && (settings.filter.minDuration.value = val), disabled: !enabled || !minDuration.enabled })
          ] }),
jsxs("div", { className: "flex items-center", children: [
jsx$1(CheckboxSettingItem, { disabled: !enabled, configPath: "filter.minPlayCount.enabled", label: "按播放次数过滤", tooltip: jsx$1(Fragment, { children: "不显示播放次数很少的视频" }), className: "min-w-130px" }),
jsx$1(antd.InputNumber, { className: "w-130px", size: "small", min: 1, step: 1e3, value: minPlayCount.value, onChange: (val) => !isNil(val) && (settings.filter.minPlayCount.value = val), disabled: !enabled || !minPlayCount.enabled, addonAfter: "次" })
          ] }),
jsxs("div", { className: "flex items-center", children: [
jsx$1(CheckboxSettingItem, { disabled: !enabled, configPath: "filter.minDanmakuCount.enabled", label: "按弹幕条数过滤", tooltip: jsx$1(Fragment, { children: "不显示弹幕条数很少的视频" }), className: "min-w-130px" }),
jsx$1(antd.InputNumber, { className: "w-130px", size: "small", min: 1, step: 100, value: minDanmakuCount.value, onChange: (val) => !isNil(val) && (settings.filter.minDanmakuCount.value = val), disabled: !enabled || !minDanmakuCount.enabled, addonAfter: "条" })
          ] }),
jsx$1(CheckboxSettingItem, { configPath: "filter.exemptForFollowed.video", disabled: !enabled, ...getExemptFollowedTooltipProps() })
        ] })
      ] }),
jsxs("div", { className: "col", children: [
jsx$1("div", { className: sharedClassNames.settingsGroupSubTitle, children: "图文" }),
jsx$1(CheckboxSettingItem, { configPath: "filter.hideGotoTypePicture", label: "过滤图文类型推荐", disabled: !enabled, className: "flex", tooltip: jsxs(Fragment, { children: [
          "过滤 ",
jsx$1("kbd", { children: "goto = picture" }),
          " 的内容: 包括 (动态 & 专栏) 等"
        ] }) }),
jsx$1(CheckboxSettingItem, { className: "flex", disabled: !enabled || !hideGotoTypePicture, configPath: "filter.exemptForFollowed.picture", ...getExemptFollowedTooltipProps() }),
jsx$1("div", { className: sharedClassNames.settingsGroupSubTitle, children: "影视" }),
jsx$1(CheckboxSettingItem, { configPath: "filter.hideGotoTypeBangumi", label: "过滤影视类型推荐", tooltip: jsxs(Fragment, { children: [
          "过滤 ",
jsx$1("kbd", { children: "goto = bangumi" }),
          " 的内容: 包括 (番剧 / 电影 / 国创 / 纪录片) 等"
        ] }), disabled: !enabled })
      ] }),
jsxs("div", { className: "col", children: [
jsxs("div", { className: sharedClassNames.settingsGroupSubTitle, children: [
          "UP",
jsxs(HelpInfo, { children: [
            "根据 UP 过滤视频 ",
jsx$1("br", {}),
            "使用 mid 屏蔽时支持备注, 格式: ",
jsx$1(antd.Tag, { color: "success", children: "mid(备注)" }),
            "  ",
            "如 ",
jsx$1(antd.Tag, { color: "success", children: "8047632(B站官方)" }),
            " ",
jsx$1("br", {}),
            "作用范围: 推荐 / 热门 ",
jsx$1("br", {}),
jsxs("div", { className: "mt-4px flex items-start", children: [
jsx$1(IconForInfo, { className: "mt-3px" }),
jsxs("div", { className: "ml-8px flex-1", children: [
                "B站官方支持黑名单, 对于不喜欢的 UP 可以直接拉黑 ",
jsx$1("br", {}),
                "此脚本会拉取官方黑名单, 并无视此页开关, 总是会过滤掉 ",
jsx$1("br", {}),
                "这里是客户端过滤, 与黑名单功能重复, 优先使用黑名单功能 ",
jsx$1("br", {})
              ] })
            ] })
          ] }),
jsx$1(SwitchSettingItem, { configPath: "filter.byAuthor.enabled", disabled: !enabled, className: "ml-10px" }),
jsx$1("div", { className: "flex-1" }),
jsx$1(antd.Popover, { placement: "left", content: jsxs("div", { className: "flex flex-col gap-x-10px gap-y-5px", children: [
jsxs(antd.Button, { onClick: clear_filterByAuthor_uselessRemarkData, children: [
jsx$1(IconForDelete, {}),
              "清理无效备注数据"
            ] }),
jsxs(antd.Button, { onClick: exportFilterByAuthor, children: [
jsx$1(ForwardRef$9, {}),
              "导出"
            ] }),
jsxs(antd.Button, { onClick: importFilterByAuthor, children: [
jsx$1(ForwardRef$8, {}),
              "导入"
            ] })
          ] }), children: jsx$1(antd.Button, { className: "icon-only-round-button size-26px", children: jsx$1(IconForPopoverTrigger, { className: "size-16px" }) }) })
        ] }),
jsx$1(EditableListSettingItem, { configPath: "filter.byAuthor.keywords", searchProps: {
          placeholder: "添加UP: 全名 / mid / mid(备注)"
        }, disabled: !enabled || !byAuthor.enabled })
      ] }),
jsxs("div", { className: "col", children: [
jsxs("div", { className: sharedClassNames.settingsGroupSubTitle, children: [
jsx$1("span", { children: "标题" }),
jsxs(HelpInfo, { children: [
            "根据标题关键词过滤视频 ",
jsx$1("br", {}),
            "支持普通关键字和正则(i), 语法：/abc|\\d+/ ",
jsx$1("br", {}),
            "作用范围: 推荐 / 热门"
          ] }),
jsx$1(SwitchSettingItem, { configPath: "filter.byTitle.enabled", disabled: !enabled, className: "ml-10px" }),
jsx$1("div", { className: "flex-1" }),
jsx$1(antd.Popover, { placement: "left", content: jsxs("div", { className: "flex flex-col gap-x-10px gap-y-5px", children: [
jsxs(antd.Button, { onClick: exportFilterByTitle, children: [
jsx$1(ForwardRef$9, {}),
              "导出"
            ] }),
jsxs(antd.Button, { onClick: importFilterByTitle, children: [
jsx$1(ForwardRef$8, {}),
              "导入"
            ] })
          ] }), children: jsx$1(antd.Button, { className: "icon-only-round-button size-26px", children: jsx$1(IconForPopoverTrigger, { className: "size-16px" }) }) })
        ] }),
jsx$1(EditableListSettingItem, { configPath: "filter.byTitle.keywords", searchProps: {
          placeholder: "添加过滤关键词"
        }, disabled: !enabled || !byTitle.enabled })
      ] })
    ] }) }) });
  }
  async function clear_filterByAuthor_uselessRemarkData() {
    const list2 = settings.filter.byAuthor.keywords;
    const newList = await pmap(
      list2,
      async (item) => {
        const {
          mid,
          remark
        } = parseUpRepresent(item);
        if (!mid || !remark) return item;
        const nickname = await getUserNickname(mid);
        if (nickname !== remark) return item;
        return mid;
      },
      Infinity
);
    if (isEqual$1(newList, list2)) {
      return antMessage.warning("没有「无效备注」数据!");
    }
    settings.filter.byAuthor.keywords = newList;
    return antMessage.success("已清理「无效备注」数据!");
  }
  function TabPaneOtherPages() {
    return jsxs("div", { className: sharedClassNames.tabPane, children: [
jsx$1(SettingsGroup, { title: "视频播放页", children: jsx$1(CheckboxSettingItem, { configPath: "fav.useCustomFavPicker.onPlayPage", label: `使用自定义收藏弹窗`, tooltip: jsxs(Fragment, { children: [
        "使用「",
        APP_NAME,
        "」提供的选择收藏夹弹窗 ",
jsx$1("br", {}),
jsxs("ul", { className: "ml-20px list-circle", children: [
jsx$1("li", { children: "支持拼音搜索, 帮你快速找到收藏夹" }),
jsx$1("li", { children: jsxs("span", { className: "flex-v-center", children: [
            "支持从收藏夹图标 或 快捷键",
jsx$1("kbd", { className: clsx(kbdClassName, "mx-1 h-14px py-0 line-height-14px"), children: "e" }),
            "触发"
          ] }) })
        ] })
      ] }) }) }),
jsx$1(SettingsGroup, { title: "搜索页", children: jsx$1(CheckboxSettingItem, { configPath: "videoCard.videoPreview.addTo.searchPage", label: "浮动预览: 添加到「搜索页」", tooltip: jsx$1(Fragment, { children: "在搜索页的视频也添加「浮动预览」" }) }) })
    ] });
  }
  function useCombinedRefs() {
    for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
      refs[_key] = arguments[_key];
    }
    return H.useMemo(
      () => (node2) => {
        refs.forEach((ref) => ref(node2));
      },
refs
    );
  }
  const canUseDOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
  function isWindow(element) {
    const elementString = Object.prototype.toString.call(element);
    return elementString === "[object Window]" ||
elementString === "[object global]";
  }
  function isNode(node2) {
    return "nodeType" in node2;
  }
  function getWindow(target) {
    var _target$ownerDocument, _target$ownerDocument2;
    if (!target) {
      return window;
    }
    if (isWindow(target)) {
      return target;
    }
    if (!isNode(target)) {
      return window;
    }
    return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;
  }
  function isDocument(node2) {
    const {
      Document
    } = getWindow(node2);
    return node2 instanceof Document;
  }
  function isHTMLElement(node2) {
    if (isWindow(node2)) {
      return false;
    }
    return node2 instanceof getWindow(node2).HTMLElement;
  }
  function isSVGElement(node2) {
    return node2 instanceof getWindow(node2).SVGElement;
  }
  function getOwnerDocument(target) {
    if (!target) {
      return document;
    }
    if (isWindow(target)) {
      return target.document;
    }
    if (!isNode(target)) {
      return document;
    }
    if (isDocument(target)) {
      return target;
    }
    if (isHTMLElement(target) || isSVGElement(target)) {
      return target.ownerDocument;
    }
    return document;
  }
  const useIsomorphicLayoutEffect = canUseDOM ? H.useLayoutEffect : H.useEffect;
  function useEvent(handler) {
    const handlerRef = H.useRef(handler);
    useIsomorphicLayoutEffect(() => {
      handlerRef.current = handler;
    });
    return H.useCallback(function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return handlerRef.current == null ? void 0 : handlerRef.current(...args);
    }, []);
  }
  function useInterval() {
    const intervalRef = H.useRef(null);
    const set2 = H.useCallback((listener, duration2) => {
      intervalRef.current = setInterval(listener, duration2);
    }, []);
    const clear = H.useCallback(() => {
      if (intervalRef.current !== null) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    }, []);
    return [set2, clear];
  }
  function useLatestValue(value, dependencies) {
    if (dependencies === void 0) {
      dependencies = [value];
    }
    const valueRef = H.useRef(value);
    useIsomorphicLayoutEffect(() => {
      if (valueRef.current !== value) {
        valueRef.current = value;
      }
    }, dependencies);
    return valueRef;
  }
  function useLazyMemo(callback, dependencies) {
    const valueRef = H.useRef();
    return H.useMemo(
      () => {
        const newValue = callback(valueRef.current);
        valueRef.current = newValue;
        return newValue;
      },
[...dependencies]
    );
  }
  function useNodeRef(onChange) {
    const onChangeHandler = useEvent(onChange);
    const node2 = H.useRef(null);
    const setNodeRef = H.useCallback(
      (element) => {
        if (element !== node2.current) {
          onChangeHandler == null ? void 0 : onChangeHandler(element, node2.current);
        }
        node2.current = element;
      },
[]
    );
    return [node2, setNodeRef];
  }
  function usePrevious(value) {
    const ref = H.useRef();
    H.useEffect(() => {
      ref.current = value;
    }, [value]);
    return ref.current;
  }
  let ids = {};
  function useUniqueId(prefix2, value) {
    return H.useMemo(() => {
      if (value) {
        return value;
      }
      const id = ids[prefix2] == null ? 0 : ids[prefix2] + 1;
      ids[prefix2] = id;
      return prefix2 + "-" + id;
    }, [prefix2, value]);
  }
  function createAdjustmentFn(modifier) {
    return function(object) {
      for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        adjustments[_key - 1] = arguments[_key];
      }
      return adjustments.reduce((accumulator, adjustment) => {
        const entries = Object.entries(adjustment);
        for (const [key, valueAdjustment] of entries) {
          const value = accumulator[key];
          if (value != null) {
            accumulator[key] = value + modifier * valueAdjustment;
          }
        }
        return accumulator;
      }, {
        ...object
      });
    };
  }
  const add = createAdjustmentFn(1);
  const subtract = createAdjustmentFn(-1);
  function hasViewportRelativeCoordinates(event) {
    return "clientX" in event && "clientY" in event;
  }
  function isKeyboardEvent(event) {
    if (!event) {
      return false;
    }
    const {
      KeyboardEvent
    } = getWindow(event.target);
    return KeyboardEvent && event instanceof KeyboardEvent;
  }
  function isTouchEvent(event) {
    if (!event) {
      return false;
    }
    const {
      TouchEvent
    } = getWindow(event.target);
    return TouchEvent && event instanceof TouchEvent;
  }
  function getEventCoordinates(event) {
    if (isTouchEvent(event)) {
      if (event.touches && event.touches.length) {
        const {
          clientX: x,
          clientY: y
        } = event.touches[0];
        return {
          x,
          y
        };
      } else if (event.changedTouches && event.changedTouches.length) {
        const {
          clientX: x,
          clientY: y
        } = event.changedTouches[0];
        return {
          x,
          y
        };
      }
    }
    if (hasViewportRelativeCoordinates(event)) {
      return {
        x: event.clientX,
        y: event.clientY
      };
    }
    return null;
  }
  const CSS = Object.freeze({
    Translate: {
      toString(transform) {
        if (!transform) {
          return;
        }
        const {
          x,
          y
        } = transform;
        return "translate3d(" + (x ? Math.round(x) : 0) + "px, " + (y ? Math.round(y) : 0) + "px, 0)";
      }
    },
    Scale: {
      toString(transform) {
        if (!transform) {
          return;
        }
        const {
          scaleX,
          scaleY
        } = transform;
        return "scaleX(" + scaleX + ") scaleY(" + scaleY + ")";
      }
    },
    Transform: {
      toString(transform) {
        if (!transform) {
          return;
        }
        return [CSS.Translate.toString(transform), CSS.Scale.toString(transform)].join(" ");
      }
    },
    Transition: {
      toString(_ref5) {
        let {
          property,
          duration: duration2,
          easing
        } = _ref5;
        return property + " " + duration2 + "ms " + easing;
      }
    }
  });
  const SELECTOR = "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]";
  function findFirstFocusableNode(element) {
    if (element.matches(SELECTOR)) {
      return element;
    }
    return element.querySelector(SELECTOR);
  }
  const hiddenStyles = {
    display: "none"
  };
  function HiddenText(_ref5) {
    let {
      id,
      value
    } = _ref5;
    return H.createElement("div", {
      id,
      style: hiddenStyles
    }, value);
  }
  function LiveRegion(_ref5) {
    let {
      id,
      announcement,
      ariaLiveType = "assertive"
    } = _ref5;
    const visuallyHidden = {
      position: "fixed",
      top: 0,
      left: 0,
      width: 1,
      height: 1,
      margin: -1,
      border: 0,
      padding: 0,
      overflow: "hidden",
      clip: "rect(0 0 0 0)",
      clipPath: "inset(100%)",
      whiteSpace: "nowrap"
    };
    return H.createElement("div", {
      id,
      style: visuallyHidden,
      role: "status",
      "aria-live": ariaLiveType,
      "aria-atomic": true
    }, announcement);
  }
  function useAnnouncement() {
    const [announcement, setAnnouncement] = H.useState("");
    const announce = H.useCallback((value) => {
      if (value != null) {
        setAnnouncement(value);
      }
    }, []);
    return {
      announce,
      announcement
    };
  }
  const DndMonitorContext = H.createContext(null);
  function useDndMonitor(listener) {
    const registerListener = H.useContext(DndMonitorContext);
    H.useEffect(() => {
      if (!registerListener) {
        throw new Error("useDndMonitor must be used within a children of <DndContext>");
      }
      const unsubscribe = registerListener(listener);
      return unsubscribe;
    }, [listener, registerListener]);
  }
  function useDndMonitorProvider() {
    const [listeners2] = H.useState(() => new Set());
    const registerListener = H.useCallback((listener) => {
      listeners2.add(listener);
      return () => listeners2.delete(listener);
    }, [listeners2]);
    const dispatch = H.useCallback((_ref5) => {
      let {
        type,
        event
      } = _ref5;
      listeners2.forEach((listener) => {
        var _listener$type;
        return (_listener$type = listener[type]) == null ? void 0 : _listener$type.call(listener, event);
      });
    }, [listeners2]);
    return [dispatch, registerListener];
  }
  const defaultScreenReaderInstructions = {
    draggable: "\n    To pick up a draggable item, press the space bar.\n    While dragging, use the arrow keys to move the item.\n    Press space again to drop the item in its new position, or press escape to cancel.\n  "
  };
  const defaultAnnouncements = {
    onDragStart(_ref5) {
      let {
        active
      } = _ref5;
      return "Picked up draggable item " + active.id + ".";
    },
    onDragOver(_ref22) {
      let {
        active,
        over
      } = _ref22;
      if (over) {
        return "Draggable item " + active.id + " was moved over droppable area " + over.id + ".";
      }
      return "Draggable item " + active.id + " is no longer over a droppable area.";
    },
    onDragEnd(_ref32) {
      let {
        active,
        over
      } = _ref32;
      if (over) {
        return "Draggable item " + active.id + " was dropped over droppable area " + over.id;
      }
      return "Draggable item " + active.id + " was dropped.";
    },
    onDragCancel(_ref42) {
      let {
        active
      } = _ref42;
      return "Dragging was cancelled. Draggable item " + active.id + " was dropped.";
    }
  };
  function Accessibility(_ref5) {
    let {
      announcements = defaultAnnouncements,
      container,
      hiddenTextDescribedById,
      screenReaderInstructions = defaultScreenReaderInstructions
    } = _ref5;
    const {
      announce,
      announcement
    } = useAnnouncement();
    const liveRegionId = useUniqueId("DndLiveRegion");
    const [mounted, setMounted] = H.useState(false);
    H.useEffect(() => {
      setMounted(true);
    }, []);
    useDndMonitor(H.useMemo(() => ({
      onDragStart(_ref22) {
        let {
          active
        } = _ref22;
        announce(announcements.onDragStart({
          active
        }));
      },
      onDragMove(_ref32) {
        let {
          active,
          over
        } = _ref32;
        if (announcements.onDragMove) {
          announce(announcements.onDragMove({
            active,
            over
          }));
        }
      },
      onDragOver(_ref42) {
        let {
          active,
          over
        } = _ref42;
        announce(announcements.onDragOver({
          active,
          over
        }));
      },
      onDragEnd(_ref52) {
        let {
          active,
          over
        } = _ref52;
        announce(announcements.onDragEnd({
          active,
          over
        }));
      },
      onDragCancel(_ref6) {
        let {
          active,
          over
        } = _ref6;
        announce(announcements.onDragCancel({
          active,
          over
        }));
      }
    }), [announce, announcements]));
    if (!mounted) {
      return null;
    }
    const markup = H.createElement(H.Fragment, null, H.createElement(HiddenText, {
      id: hiddenTextDescribedById,
      value: screenReaderInstructions.draggable
    }), H.createElement(LiveRegion, {
      id: liveRegionId,
      announcement
    }));
    return container ? require$$0.createPortal(markup, container) : markup;
  }
  var Action;
  (function(Action2) {
    Action2["DragStart"] = "dragStart";
    Action2["DragMove"] = "dragMove";
    Action2["DragEnd"] = "dragEnd";
    Action2["DragCancel"] = "dragCancel";
    Action2["DragOver"] = "dragOver";
    Action2["RegisterDroppable"] = "registerDroppable";
    Action2["SetDroppableDisabled"] = "setDroppableDisabled";
    Action2["UnregisterDroppable"] = "unregisterDroppable";
  })(Action || (Action = {}));
  function noop() {
  }
  function useSensor(sensor, options) {
    return H.useMemo(
      () => ({
        sensor,
        options: {}
      }),
[sensor, options]
    );
  }
  function useSensors() {
    for (var _len = arguments.length, sensors = new Array(_len), _key = 0; _key < _len; _key++) {
      sensors[_key] = arguments[_key];
    }
    return H.useMemo(
      () => [...sensors].filter((sensor) => sensor != null),
[...sensors]
    );
  }
  const defaultCoordinates = Object.freeze({
    x: 0,
    y: 0
  });
  function distanceBetween(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
  }
  function sortCollisionsAsc(_ref5, _ref22) {
    let {
      data: {
        value: a2
      }
    } = _ref5;
    let {
      data: {
        value: b
      }
    } = _ref22;
    return a2 - b;
  }
  function sortCollisionsDesc(_ref32, _ref42) {
    let {
      data: {
        value: a2
      }
    } = _ref32;
    let {
      data: {
        value: b
      }
    } = _ref42;
    return b - a2;
  }
  function getFirstCollision(collisions, property) {
    if (!collisions || collisions.length === 0) {
      return null;
    }
    const [firstCollision] = collisions;
    return firstCollision[property];
  }
  function centerOfRectangle(rect, left, top) {
    if (left === void 0) {
      left = rect.left;
    }
    if (top === void 0) {
      top = rect.top;
    }
    return {
      x: left + rect.width * 0.5,
      y: top + rect.height * 0.5
    };
  }
  const closestCenter = (_ref5) => {
    let {
      collisionRect,
      droppableRects,
      droppableContainers
    } = _ref5;
    const centerRect = centerOfRectangle(collisionRect, collisionRect.left, collisionRect.top);
    const collisions = [];
    for (const droppableContainer of droppableContainers) {
      const {
        id
      } = droppableContainer;
      const rect = droppableRects.get(id);
      if (rect) {
        const distBetween = distanceBetween(centerOfRectangle(rect), centerRect);
        collisions.push({
          id,
          data: {
            droppableContainer,
            value: distBetween
          }
        });
      }
    }
    return collisions.sort(sortCollisionsAsc);
  };
  function getIntersectionRatio(entry, target) {
    const top = Math.max(target.top, entry.top);
    const left = Math.max(target.left, entry.left);
    const right = Math.min(target.left + target.width, entry.left + entry.width);
    const bottom = Math.min(target.top + target.height, entry.top + entry.height);
    const width = right - left;
    const height = bottom - top;
    if (left < right && top < bottom) {
      const targetArea = target.width * target.height;
      const entryArea = entry.width * entry.height;
      const intersectionArea = width * height;
      const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
      return Number(intersectionRatio.toFixed(4));
    }
    return 0;
  }
  const rectIntersection = (_ref5) => {
    let {
      collisionRect,
      droppableRects,
      droppableContainers
    } = _ref5;
    const collisions = [];
    for (const droppableContainer of droppableContainers) {
      const {
        id
      } = droppableContainer;
      const rect = droppableRects.get(id);
      if (rect) {
        const intersectionRatio = getIntersectionRatio(rect, collisionRect);
        if (intersectionRatio > 0) {
          collisions.push({
            id,
            data: {
              droppableContainer,
              value: intersectionRatio
            }
          });
        }
      }
    }
    return collisions.sort(sortCollisionsDesc);
  };
  function adjustScale(transform, rect1, rect2) {
    return {
      ...transform,
      scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,
      scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1
    };
  }
  function getRectDelta(rect1, rect2) {
    return rect1 && rect2 ? {
      x: rect1.left - rect2.left,
      y: rect1.top - rect2.top
    } : defaultCoordinates;
  }
  function createRectAdjustmentFn(modifier) {
    return function adjustClientRect(rect) {
      for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        adjustments[_key - 1] = arguments[_key];
      }
      return adjustments.reduce((acc, adjustment) => ({
        ...acc,
        top: acc.top + modifier * adjustment.y,
        bottom: acc.bottom + modifier * adjustment.y,
        left: acc.left + modifier * adjustment.x,
        right: acc.right + modifier * adjustment.x
      }), {
        ...rect
      });
    };
  }
  const getAdjustedRect = createRectAdjustmentFn(1);
  function parseTransform(transform) {
    if (transform.startsWith("matrix3d(")) {
      const transformArray = transform.slice(9, -1).split(/, /);
      return {
        x: +transformArray[12],
        y: +transformArray[13],
        scaleX: +transformArray[0],
        scaleY: +transformArray[5]
      };
    } else if (transform.startsWith("matrix(")) {
      const transformArray = transform.slice(7, -1).split(/, /);
      return {
        x: +transformArray[4],
        y: +transformArray[5],
        scaleX: +transformArray[0],
        scaleY: +transformArray[3]
      };
    }
    return null;
  }
  function inverseTransform(rect, transform, transformOrigin) {
    const parsedTransform = parseTransform(transform);
    if (!parsedTransform) {
      return rect;
    }
    const {
      scaleX,
      scaleY,
      x: translateX,
      y: translateY
    } = parsedTransform;
    const x = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin);
    const y = rect.top - translateY - (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(" ") + 1));
    const w = scaleX ? rect.width / scaleX : rect.width;
    const h2 = scaleY ? rect.height / scaleY : rect.height;
    return {
      width: w,
      height: h2,
      top: y,
      right: x + w,
      bottom: y + h2,
      left: x
    };
  }
  const defaultOptions = {
    ignoreTransform: false
  };
  function getClientRect(element, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    let rect = element.getBoundingClientRect();
    if (options.ignoreTransform) {
      const {
        transform,
        transformOrigin
      } = getWindow(element).getComputedStyle(element);
      if (transform) {
        rect = inverseTransform(rect, transform, transformOrigin);
      }
    }
    const {
      top,
      left,
      width,
      height,
      bottom,
      right
    } = rect;
    return {
      top,
      left,
      width,
      height,
      bottom,
      right
    };
  }
  function getTransformAgnosticClientRect(element) {
    return getClientRect(element, {
      ignoreTransform: true
    });
  }
  function getWindowClientRect(element) {
    const width = element.innerWidth;
    const height = element.innerHeight;
    return {
      top: 0,
      left: 0,
      right: width,
      bottom: height,
      width,
      height
    };
  }
  function isFixed(node2, computedStyle) {
    if (computedStyle === void 0) {
      computedStyle = getWindow(node2).getComputedStyle(node2);
    }
    return computedStyle.position === "fixed";
  }
  function isScrollable(element, computedStyle) {
    if (computedStyle === void 0) {
      computedStyle = getWindow(element).getComputedStyle(element);
    }
    const overflowRegex = /(auto|scroll|overlay)/;
    const properties2 = ["overflow", "overflowX", "overflowY"];
    return properties2.some((property) => {
      const value = computedStyle[property];
      return typeof value === "string" ? overflowRegex.test(value) : false;
    });
  }
  function getScrollableAncestors(element, limit2) {
    const scrollParents = [];
    function findScrollableAncestors(node2) {
      if (limit2 != null && scrollParents.length >= limit2) {
        return scrollParents;
      }
      if (!node2) {
        return scrollParents;
      }
      if (isDocument(node2) && node2.scrollingElement != null && !scrollParents.includes(node2.scrollingElement)) {
        scrollParents.push(node2.scrollingElement);
        return scrollParents;
      }
      if (!isHTMLElement(node2) || isSVGElement(node2)) {
        return scrollParents;
      }
      if (scrollParents.includes(node2)) {
        return scrollParents;
      }
      const computedStyle = getWindow(element).getComputedStyle(node2);
      if (node2 !== element) {
        if (isScrollable(node2, computedStyle)) {
          scrollParents.push(node2);
        }
      }
      if (isFixed(node2, computedStyle)) {
        return scrollParents;
      }
      return findScrollableAncestors(node2.parentNode);
    }
    if (!element) {
      return scrollParents;
    }
    return findScrollableAncestors(element);
  }
  function getFirstScrollableAncestor(node2) {
    const [firstScrollableAncestor] = getScrollableAncestors(node2, 1);
    return firstScrollableAncestor != null ? firstScrollableAncestor : null;
  }
  function getScrollableElement(element) {
    if (!canUseDOM || !element) {
      return null;
    }
    if (isWindow(element)) {
      return element;
    }
    if (!isNode(element)) {
      return null;
    }
    if (isDocument(element) || element === getOwnerDocument(element).scrollingElement) {
      return window;
    }
    if (isHTMLElement(element)) {
      return element;
    }
    return null;
  }
  function getScrollXCoordinate(element) {
    if (isWindow(element)) {
      return element.scrollX;
    }
    return element.scrollLeft;
  }
  function getScrollYCoordinate(element) {
    if (isWindow(element)) {
      return element.scrollY;
    }
    return element.scrollTop;
  }
  function getScrollCoordinates(element) {
    return {
      x: getScrollXCoordinate(element),
      y: getScrollYCoordinate(element)
    };
  }
  var Direction;
  (function(Direction2) {
    Direction2[Direction2["Forward"] = 1] = "Forward";
    Direction2[Direction2["Backward"] = -1] = "Backward";
  })(Direction || (Direction = {}));
  function isDocumentScrollingElement(element) {
    if (!canUseDOM || !element) {
      return false;
    }
    return element === document.scrollingElement;
  }
  function getScrollPosition(scrollingContainer) {
    const minScroll = {
      x: 0,
      y: 0
    };
    const dimensions = isDocumentScrollingElement(scrollingContainer) ? {
      height: window.innerHeight,
      width: window.innerWidth
    } : {
      height: scrollingContainer.clientHeight,
      width: scrollingContainer.clientWidth
    };
    const maxScroll = {
      x: scrollingContainer.scrollWidth - dimensions.width,
      y: scrollingContainer.scrollHeight - dimensions.height
    };
    const isTop = scrollingContainer.scrollTop <= minScroll.y;
    const isLeft = scrollingContainer.scrollLeft <= minScroll.x;
    const isBottom = scrollingContainer.scrollTop >= maxScroll.y;
    const isRight = scrollingContainer.scrollLeft >= maxScroll.x;
    return {
      isTop,
      isLeft,
      isBottom,
      isRight,
      maxScroll,
      minScroll
    };
  }
  const defaultThreshold = {
    x: 0.2,
    y: 0.2
  };
  function getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, _ref5, acceleration, thresholdPercentage) {
    let {
      top,
      left,
      right,
      bottom
    } = _ref5;
    if (acceleration === void 0) {
      acceleration = 10;
    }
    if (thresholdPercentage === void 0) {
      thresholdPercentage = defaultThreshold;
    }
    const {
      isTop,
      isBottom,
      isLeft,
      isRight
    } = getScrollPosition(scrollContainer);
    const direction = {
      x: 0,
      y: 0
    };
    const speed = {
      x: 0,
      y: 0
    };
    const threshold = {
      height: scrollContainerRect.height * thresholdPercentage.y,
      width: scrollContainerRect.width * thresholdPercentage.x
    };
    if (!isTop && top <= scrollContainerRect.top + threshold.height) {
      direction.y = Direction.Backward;
      speed.y = acceleration * Math.abs((scrollContainerRect.top + threshold.height - top) / threshold.height);
    } else if (!isBottom && bottom >= scrollContainerRect.bottom - threshold.height) {
      direction.y = Direction.Forward;
      speed.y = acceleration * Math.abs((scrollContainerRect.bottom - threshold.height - bottom) / threshold.height);
    }
    if (!isRight && right >= scrollContainerRect.right - threshold.width) {
      direction.x = Direction.Forward;
      speed.x = acceleration * Math.abs((scrollContainerRect.right - threshold.width - right) / threshold.width);
    } else if (!isLeft && left <= scrollContainerRect.left + threshold.width) {
      direction.x = Direction.Backward;
      speed.x = acceleration * Math.abs((scrollContainerRect.left + threshold.width - left) / threshold.width);
    }
    return {
      direction,
      speed
    };
  }
  function getScrollElementRect(element) {
    if (element === document.scrollingElement) {
      const {
        innerWidth,
        innerHeight
      } = window;
      return {
        top: 0,
        left: 0,
        right: innerWidth,
        bottom: innerHeight,
        width: innerWidth,
        height: innerHeight
      };
    }
    const {
      top,
      left,
      right,
      bottom
    } = element.getBoundingClientRect();
    return {
      top,
      left,
      right,
      bottom,
      width: element.clientWidth,
      height: element.clientHeight
    };
  }
  function getScrollOffsets(scrollableAncestors) {
    return scrollableAncestors.reduce((acc, node2) => {
      return add(acc, getScrollCoordinates(node2));
    }, defaultCoordinates);
  }
  function getScrollXOffset(scrollableAncestors) {
    return scrollableAncestors.reduce((acc, node2) => {
      return acc + getScrollXCoordinate(node2);
    }, 0);
  }
  function getScrollYOffset(scrollableAncestors) {
    return scrollableAncestors.reduce((acc, node2) => {
      return acc + getScrollYCoordinate(node2);
    }, 0);
  }
  function scrollIntoViewIfNeeded(element, measure) {
    if (measure === void 0) {
      measure = getClientRect;
    }
    if (!element) {
      return;
    }
    const {
      top,
      left,
      bottom,
      right
    } = measure(element);
    const firstScrollableAncestor = getFirstScrollableAncestor(element);
    if (!firstScrollableAncestor) {
      return;
    }
    if (bottom <= 0 || right <= 0 || top >= window.innerHeight || left >= window.innerWidth) {
      element.scrollIntoView({
        block: "center",
        inline: "center"
      });
    }
  }
  const properties = [["x", ["left", "right"], getScrollXOffset], ["y", ["top", "bottom"], getScrollYOffset]];
  class Rect {
    constructor(rect, element) {
      this.rect = void 0;
      this.width = void 0;
      this.height = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.right = void 0;
      this.left = void 0;
      const scrollableAncestors = getScrollableAncestors(element);
      const scrollOffsets = getScrollOffsets(scrollableAncestors);
      this.rect = {
        ...rect
      };
      this.width = rect.width;
      this.height = rect.height;
      for (const [axis, keys, getScrollOffset] of properties) {
        for (const key of keys) {
          Object.defineProperty(this, key, {
            get: () => {
              const currentOffsets = getScrollOffset(scrollableAncestors);
              const scrollOffsetsDeltla = scrollOffsets[axis] - currentOffsets;
              return this.rect[key] + scrollOffsetsDeltla;
            },
            enumerable: true
          });
        }
      }
      Object.defineProperty(this, "rect", {
        enumerable: false
      });
    }
  }
  class Listeners {
    constructor(target) {
      this.target = void 0;
      this.listeners = [];
      this.removeAll = () => {
        this.listeners.forEach((listener) => {
          var _this$target;
          return (_this$target = this.target) == null ? void 0 : _this$target.removeEventListener(...listener);
        });
      };
      this.target = target;
    }
    add(eventName, handler, options) {
      var _this$target2;
      (_this$target2 = this.target) == null ? void 0 : _this$target2.addEventListener(eventName, handler, options);
      this.listeners.push([eventName, handler, options]);
    }
  }
  function getEventListenerTarget(target) {
    const {
      EventTarget
    } = getWindow(target);
    return target instanceof EventTarget ? target : getOwnerDocument(target);
  }
  function hasExceededDistance(delta, measurement) {
    const dx = Math.abs(delta.x);
    const dy = Math.abs(delta.y);
    if (typeof measurement === "number") {
      return Math.sqrt(dx ** 2 + dy ** 2) > measurement;
    }
    if ("x" in measurement && "y" in measurement) {
      return dx > measurement.x && dy > measurement.y;
    }
    if ("x" in measurement) {
      return dx > measurement.x;
    }
    if ("y" in measurement) {
      return dy > measurement.y;
    }
    return false;
  }
  var EventName;
  (function(EventName2) {
    EventName2["Click"] = "click";
    EventName2["DragStart"] = "dragstart";
    EventName2["Keydown"] = "keydown";
    EventName2["ContextMenu"] = "contextmenu";
    EventName2["Resize"] = "resize";
    EventName2["SelectionChange"] = "selectionchange";
    EventName2["VisibilityChange"] = "visibilitychange";
  })(EventName || (EventName = {}));
  function preventDefault(event) {
    event.preventDefault();
  }
  function stopPropagation(event) {
    event.stopPropagation();
  }
  var KeyboardCode;
  (function(KeyboardCode2) {
    KeyboardCode2["Space"] = "Space";
    KeyboardCode2["Down"] = "ArrowDown";
    KeyboardCode2["Right"] = "ArrowRight";
    KeyboardCode2["Left"] = "ArrowLeft";
    KeyboardCode2["Up"] = "ArrowUp";
    KeyboardCode2["Esc"] = "Escape";
    KeyboardCode2["Enter"] = "Enter";
    KeyboardCode2["Tab"] = "Tab";
  })(KeyboardCode || (KeyboardCode = {}));
  const defaultKeyboardCodes = {
    start: [KeyboardCode.Space, KeyboardCode.Enter],
    cancel: [KeyboardCode.Esc],
    end: [KeyboardCode.Space, KeyboardCode.Enter, KeyboardCode.Tab]
  };
  const defaultKeyboardCoordinateGetter = (event, _ref5) => {
    let {
      currentCoordinates
    } = _ref5;
    switch (event.code) {
      case KeyboardCode.Right:
        return {
          ...currentCoordinates,
          x: currentCoordinates.x + 25
        };
      case KeyboardCode.Left:
        return {
          ...currentCoordinates,
          x: currentCoordinates.x - 25
        };
      case KeyboardCode.Down:
        return {
          ...currentCoordinates,
          y: currentCoordinates.y + 25
        };
      case KeyboardCode.Up:
        return {
          ...currentCoordinates,
          y: currentCoordinates.y - 25
        };
    }
    return void 0;
  };
  class KeyboardSensor {
    constructor(props) {
      this.props = void 0;
      this.autoScrollEnabled = false;
      this.referenceCoordinates = void 0;
      this.listeners = void 0;
      this.windowListeners = void 0;
      this.props = props;
      const {
        event: {
          target
        }
      } = props;
      this.props = props;
      this.listeners = new Listeners(getOwnerDocument(target));
      this.windowListeners = new Listeners(getWindow(target));
      this.handleKeyDown = this.handleKeyDown.bind(this);
      this.handleCancel = this.handleCancel.bind(this);
      this.attach();
    }
    attach() {
      this.handleStart();
      this.windowListeners.add(EventName.Resize, this.handleCancel);
      this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
      setTimeout(() => this.listeners.add(EventName.Keydown, this.handleKeyDown));
    }
    handleStart() {
      const {
        activeNode,
        onStart
      } = this.props;
      const node2 = activeNode.node.current;
      if (node2) {
        scrollIntoViewIfNeeded(node2);
      }
      onStart(defaultCoordinates);
    }
    handleKeyDown(event) {
      if (isKeyboardEvent(event)) {
        const {
          active,
          context,
          options
        } = this.props;
        const {
          keyboardCodes = defaultKeyboardCodes,
          coordinateGetter = defaultKeyboardCoordinateGetter,
          scrollBehavior = "smooth"
        } = options;
        const {
          code
        } = event;
        if (keyboardCodes.end.includes(code)) {
          this.handleEnd(event);
          return;
        }
        if (keyboardCodes.cancel.includes(code)) {
          this.handleCancel(event);
          return;
        }
        const {
          collisionRect
        } = context.current;
        const currentCoordinates = collisionRect ? {
          x: collisionRect.left,
          y: collisionRect.top
        } : defaultCoordinates;
        if (!this.referenceCoordinates) {
          this.referenceCoordinates = currentCoordinates;
        }
        const newCoordinates = coordinateGetter(event, {
          active,
          context: context.current,
          currentCoordinates
        });
        if (newCoordinates) {
          const coordinatesDelta = subtract(newCoordinates, currentCoordinates);
          const scrollDelta = {
            x: 0,
            y: 0
          };
          const {
            scrollableAncestors
          } = context.current;
          for (const scrollContainer of scrollableAncestors) {
            const direction = event.code;
            const {
              isTop,
              isRight,
              isLeft,
              isBottom,
              maxScroll,
              minScroll
            } = getScrollPosition(scrollContainer);
            const scrollElementRect = getScrollElementRect(scrollContainer);
            const clampedCoordinates = {
              x: Math.min(direction === KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),
              y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))
            };
            const canScrollX = direction === KeyboardCode.Right && !isRight || direction === KeyboardCode.Left && !isLeft;
            const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;
            if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {
              const newScrollCoordinates = scrollContainer.scrollLeft + coordinatesDelta.x;
              const canScrollToNewCoordinates = direction === KeyboardCode.Right && newScrollCoordinates <= maxScroll.x || direction === KeyboardCode.Left && newScrollCoordinates >= minScroll.x;
              if (canScrollToNewCoordinates && !coordinatesDelta.y) {
                scrollContainer.scrollTo({
                  left: newScrollCoordinates,
                  behavior: scrollBehavior
                });
                return;
              }
              if (canScrollToNewCoordinates) {
                scrollDelta.x = scrollContainer.scrollLeft - newScrollCoordinates;
              } else {
                scrollDelta.x = direction === KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;
              }
              if (scrollDelta.x) {
                scrollContainer.scrollBy({
                  left: -scrollDelta.x,
                  behavior: scrollBehavior
                });
              }
              break;
            } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {
              const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;
              const canScrollToNewCoordinates = direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y;
              if (canScrollToNewCoordinates && !coordinatesDelta.x) {
                scrollContainer.scrollTo({
                  top: newScrollCoordinates,
                  behavior: scrollBehavior
                });
                return;
              }
              if (canScrollToNewCoordinates) {
                scrollDelta.y = scrollContainer.scrollTop - newScrollCoordinates;
              } else {
                scrollDelta.y = direction === KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;
              }
              if (scrollDelta.y) {
                scrollContainer.scrollBy({
                  top: -scrollDelta.y,
                  behavior: scrollBehavior
                });
              }
              break;
            }
          }
          this.handleMove(event, add(subtract(newCoordinates, this.referenceCoordinates), scrollDelta));
        }
      }
    }
    handleMove(event, coordinates) {
      const {
        onMove
      } = this.props;
      event.preventDefault();
      onMove(coordinates);
    }
    handleEnd(event) {
      const {
        onEnd
      } = this.props;
      event.preventDefault();
      this.detach();
      onEnd();
    }
    handleCancel(event) {
      const {
        onCancel
      } = this.props;
      event.preventDefault();
      this.detach();
      onCancel();
    }
    detach() {
      this.listeners.removeAll();
      this.windowListeners.removeAll();
    }
  }
  KeyboardSensor.activators = [{
    eventName: "onKeyDown",
    handler: (event, _ref5, _ref22) => {
      let {
        keyboardCodes = defaultKeyboardCodes,
        onActivation
      } = _ref5;
      let {
        active
      } = _ref22;
      const {
        code
      } = event.nativeEvent;
      if (keyboardCodes.start.includes(code)) {
        const activator = active.activatorNode.current;
        if (activator && event.target !== activator) {
          return false;
        }
        event.preventDefault();
        onActivation == null ? void 0 : onActivation({
          event: event.nativeEvent
        });
        return true;
      }
      return false;
    }
  }];
  function isDistanceConstraint(constraint) {
    return Boolean(constraint && "distance" in constraint);
  }
  function isDelayConstraint(constraint) {
    return Boolean(constraint && "delay" in constraint);
  }
  class AbstractPointerSensor {
    constructor(props, events2, listenerTarget) {
      var _getEventCoordinates;
      if (listenerTarget === void 0) {
        listenerTarget = getEventListenerTarget(props.event.target);
      }
      this.props = void 0;
      this.events = void 0;
      this.autoScrollEnabled = true;
      this.document = void 0;
      this.activated = false;
      this.initialCoordinates = void 0;
      this.timeoutId = null;
      this.listeners = void 0;
      this.documentListeners = void 0;
      this.windowListeners = void 0;
      this.props = props;
      this.events = events2;
      const {
        event
      } = props;
      const {
        target
      } = event;
      this.props = props;
      this.events = events2;
      this.document = getOwnerDocument(target);
      this.documentListeners = new Listeners(this.document);
      this.listeners = new Listeners(listenerTarget);
      this.windowListeners = new Listeners(getWindow(target));
      this.initialCoordinates = (_getEventCoordinates = getEventCoordinates(event)) != null ? _getEventCoordinates : defaultCoordinates;
      this.handleStart = this.handleStart.bind(this);
      this.handleMove = this.handleMove.bind(this);
      this.handleEnd = this.handleEnd.bind(this);
      this.handleCancel = this.handleCancel.bind(this);
      this.handleKeydown = this.handleKeydown.bind(this);
      this.removeTextSelection = this.removeTextSelection.bind(this);
      this.attach();
    }
    attach() {
      const {
        events: events2,
        props: {
          options: {
            activationConstraint,
            bypassActivationConstraint
          }
        }
      } = this;
      this.listeners.add(events2.move.name, this.handleMove, {
        passive: false
      });
      this.listeners.add(events2.end.name, this.handleEnd);
      if (events2.cancel) {
        this.listeners.add(events2.cancel.name, this.handleCancel);
      }
      this.windowListeners.add(EventName.Resize, this.handleCancel);
      this.windowListeners.add(EventName.DragStart, preventDefault);
      this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
      this.windowListeners.add(EventName.ContextMenu, preventDefault);
      this.documentListeners.add(EventName.Keydown, this.handleKeydown);
      if (activationConstraint) {
        if (bypassActivationConstraint != null && bypassActivationConstraint({
          event: this.props.event,
          activeNode: this.props.activeNode,
          options: this.props.options
        })) {
          return this.handleStart();
        }
        if (isDelayConstraint(activationConstraint)) {
          this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);
          this.handlePending(activationConstraint);
          return;
        }
        if (isDistanceConstraint(activationConstraint)) {
          this.handlePending(activationConstraint);
          return;
        }
      }
      this.handleStart();
    }
    detach() {
      this.listeners.removeAll();
      this.windowListeners.removeAll();
      setTimeout(this.documentListeners.removeAll, 50);
      if (this.timeoutId !== null) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }
    }
    handlePending(constraint, offset) {
      const {
        active,
        onPending
      } = this.props;
      onPending(active, constraint, this.initialCoordinates, offset);
    }
    handleStart() {
      const {
        initialCoordinates
      } = this;
      const {
        onStart
      } = this.props;
      if (initialCoordinates) {
        this.activated = true;
        this.documentListeners.add(EventName.Click, stopPropagation, {
          capture: true
        });
        this.removeTextSelection();
        this.documentListeners.add(EventName.SelectionChange, this.removeTextSelection);
        onStart(initialCoordinates);
      }
    }
    handleMove(event) {
      var _getEventCoordinates2;
      const {
        activated,
        initialCoordinates,
        props
      } = this;
      const {
        onMove,
        options: {
          activationConstraint
        }
      } = props;
      if (!initialCoordinates) {
        return;
      }
      const coordinates = (_getEventCoordinates2 = getEventCoordinates(event)) != null ? _getEventCoordinates2 : defaultCoordinates;
      const delta = subtract(initialCoordinates, coordinates);
      if (!activated && activationConstraint) {
        if (isDistanceConstraint(activationConstraint)) {
          if (activationConstraint.tolerance != null && hasExceededDistance(delta, activationConstraint.tolerance)) {
            return this.handleCancel();
          }
          if (hasExceededDistance(delta, activationConstraint.distance)) {
            return this.handleStart();
          }
        }
        if (isDelayConstraint(activationConstraint)) {
          if (hasExceededDistance(delta, activationConstraint.tolerance)) {
            return this.handleCancel();
          }
        }
        this.handlePending(activationConstraint, delta);
        return;
      }
      if (event.cancelable) {
        event.preventDefault();
      }
      onMove(coordinates);
    }
    handleEnd() {
      const {
        onAbort,
        onEnd
      } = this.props;
      this.detach();
      if (!this.activated) {
        onAbort(this.props.active);
      }
      onEnd();
    }
    handleCancel() {
      const {
        onAbort,
        onCancel
      } = this.props;
      this.detach();
      if (!this.activated) {
        onAbort(this.props.active);
      }
      onCancel();
    }
    handleKeydown(event) {
      if (event.code === KeyboardCode.Esc) {
        this.handleCancel();
      }
    }
    removeTextSelection() {
      var _this$document$getSel;
      (_this$document$getSel = this.document.getSelection()) == null ? void 0 : _this$document$getSel.removeAllRanges();
    }
  }
  const events = {
    cancel: {
      name: "pointercancel"
    },
    move: {
      name: "pointermove"
    },
    end: {
      name: "pointerup"
    }
  };
  class PointerSensor extends AbstractPointerSensor {
    constructor(props) {
      const {
        event
      } = props;
      const listenerTarget = getOwnerDocument(event.target);
      super(props, events, listenerTarget);
    }
  }
  PointerSensor.activators = [{
    eventName: "onPointerDown",
    handler: (_ref5, _ref22) => {
      let {
        nativeEvent: event
      } = _ref5;
      let {
        onActivation
      } = _ref22;
      if (!event.isPrimary || event.button !== 0) {
        return false;
      }
      onActivation == null ? void 0 : onActivation({
        event
      });
      return true;
    }
  }];
  const events$1 = {
    move: {
      name: "mousemove"
    },
    end: {
      name: "mouseup"
    }
  };
  var MouseButton;
  (function(MouseButton2) {
    MouseButton2[MouseButton2["RightClick"] = 2] = "RightClick";
  })(MouseButton || (MouseButton = {}));
  class MouseSensor extends AbstractPointerSensor {
    constructor(props) {
      super(props, events$1, getOwnerDocument(props.event.target));
    }
  }
  MouseSensor.activators = [{
    eventName: "onMouseDown",
    handler: (_ref5, _ref22) => {
      let {
        nativeEvent: event
      } = _ref5;
      let {
        onActivation
      } = _ref22;
      if (event.button === MouseButton.RightClick) {
        return false;
      }
      onActivation == null ? void 0 : onActivation({
        event
      });
      return true;
    }
  }];
  const events$2 = {
    cancel: {
      name: "touchcancel"
    },
    move: {
      name: "touchmove"
    },
    end: {
      name: "touchend"
    }
  };
  class TouchSensor extends AbstractPointerSensor {
    constructor(props) {
      super(props, events$2);
    }
    static setup() {
      window.addEventListener(events$2.move.name, noop2, {
        capture: false,
        passive: false
      });
      return function teardown() {
        window.removeEventListener(events$2.move.name, noop2);
      };
      function noop2() {
      }
    }
  }
  TouchSensor.activators = [{
    eventName: "onTouchStart",
    handler: (_ref5, _ref22) => {
      let {
        nativeEvent: event
      } = _ref5;
      let {
        onActivation
      } = _ref22;
      const {
        touches
      } = event;
      if (touches.length > 1) {
        return false;
      }
      onActivation == null ? void 0 : onActivation({
        event
      });
      return true;
    }
  }];
  var AutoScrollActivator;
  (function(AutoScrollActivator2) {
    AutoScrollActivator2[AutoScrollActivator2["Pointer"] = 0] = "Pointer";
    AutoScrollActivator2[AutoScrollActivator2["DraggableRect"] = 1] = "DraggableRect";
  })(AutoScrollActivator || (AutoScrollActivator = {}));
  var TraversalOrder;
  (function(TraversalOrder2) {
    TraversalOrder2[TraversalOrder2["TreeOrder"] = 0] = "TreeOrder";
    TraversalOrder2[TraversalOrder2["ReversedTreeOrder"] = 1] = "ReversedTreeOrder";
  })(TraversalOrder || (TraversalOrder = {}));
  function useAutoScroller(_ref5) {
    let {
      acceleration,
      activator = AutoScrollActivator.Pointer,
      canScroll,
      draggingRect,
      enabled,
      interval = 5,
      order = TraversalOrder.TreeOrder,
      pointerCoordinates,
      scrollableAncestors,
      scrollableAncestorRects,
      delta,
      threshold
    } = _ref5;
    const scrollIntent = useScrollIntent({
      delta,
      disabled: !enabled
    });
    const [setAutoScrollInterval, clearAutoScrollInterval] = useInterval();
    const scrollSpeed = H.useRef({
      x: 0,
      y: 0
    });
    const scrollDirection = H.useRef({
      x: 0,
      y: 0
    });
    const rect = H.useMemo(() => {
      switch (activator) {
        case AutoScrollActivator.Pointer:
          return pointerCoordinates ? {
            top: pointerCoordinates.y,
            bottom: pointerCoordinates.y,
            left: pointerCoordinates.x,
            right: pointerCoordinates.x
          } : null;
        case AutoScrollActivator.DraggableRect:
          return draggingRect;
      }
    }, [activator, draggingRect, pointerCoordinates]);
    const scrollContainerRef = H.useRef(null);
    const autoScroll = H.useCallback(() => {
      const scrollContainer = scrollContainerRef.current;
      if (!scrollContainer) {
        return;
      }
      const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;
      const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;
      scrollContainer.scrollBy(scrollLeft, scrollTop);
    }, []);
    const sortedScrollableAncestors = H.useMemo(() => order === TraversalOrder.TreeOrder ? [...scrollableAncestors].reverse() : scrollableAncestors, [order, scrollableAncestors]);
    H.useEffect(
      () => {
        if (!enabled || !scrollableAncestors.length || !rect) {
          clearAutoScrollInterval();
          return;
        }
        for (const scrollContainer of sortedScrollableAncestors) {
          if ((canScroll == null ? void 0 : canScroll(scrollContainer)) === false) {
            continue;
          }
          const index = scrollableAncestors.indexOf(scrollContainer);
          const scrollContainerRect = scrollableAncestorRects[index];
          if (!scrollContainerRect) {
            continue;
          }
          const {
            direction,
            speed
          } = getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, rect, acceleration, threshold);
          for (const axis of ["x", "y"]) {
            if (!scrollIntent[axis][direction[axis]]) {
              speed[axis] = 0;
              direction[axis] = 0;
            }
          }
          if (speed.x > 0 || speed.y > 0) {
            clearAutoScrollInterval();
            scrollContainerRef.current = scrollContainer;
            setAutoScrollInterval(autoScroll, interval);
            scrollSpeed.current = speed;
            scrollDirection.current = direction;
            return;
          }
        }
        scrollSpeed.current = {
          x: 0,
          y: 0
        };
        scrollDirection.current = {
          x: 0,
          y: 0
        };
        clearAutoScrollInterval();
      },
[
        acceleration,
        autoScroll,
        canScroll,
        clearAutoScrollInterval,
        enabled,
        interval,
JSON.stringify(rect),
JSON.stringify(scrollIntent),
        setAutoScrollInterval,
        scrollableAncestors,
        sortedScrollableAncestors,
        scrollableAncestorRects,
JSON.stringify(threshold)
      ]
    );
  }
  const defaultScrollIntent = {
    x: {
      [Direction.Backward]: false,
      [Direction.Forward]: false
    },
    y: {
      [Direction.Backward]: false,
      [Direction.Forward]: false
    }
  };
  function useScrollIntent(_ref22) {
    let {
      delta,
      disabled
    } = _ref22;
    const previousDelta = usePrevious(delta);
    return useLazyMemo((previousIntent) => {
      if (disabled || !previousDelta || !previousIntent) {
        return defaultScrollIntent;
      }
      const direction = {
        x: Math.sign(delta.x - previousDelta.x),
        y: Math.sign(delta.y - previousDelta.y)
      };
      return {
        x: {
          [Direction.Backward]: previousIntent.x[Direction.Backward] || direction.x === -1,
          [Direction.Forward]: previousIntent.x[Direction.Forward] || direction.x === 1
        },
        y: {
          [Direction.Backward]: previousIntent.y[Direction.Backward] || direction.y === -1,
          [Direction.Forward]: previousIntent.y[Direction.Forward] || direction.y === 1
        }
      };
    }, [disabled, delta, previousDelta]);
  }
  function useCachedNode(draggableNodes, id) {
    const draggableNode = id != null ? draggableNodes.get(id) : void 0;
    const node2 = draggableNode ? draggableNode.node.current : null;
    return useLazyMemo((cachedNode) => {
      var _ref5;
      if (id == null) {
        return null;
      }
      return (_ref5 = node2 != null ? node2 : cachedNode) != null ? _ref5 : null;
    }, [node2, id]);
  }
  function useCombineActivators(sensors, getSyntheticHandler) {
    return H.useMemo(() => sensors.reduce((accumulator, sensor) => {
      const {
        sensor: Sensor
      } = sensor;
      const sensorActivators = Sensor.activators.map((activator) => ({
        eventName: activator.eventName,
        handler: getSyntheticHandler(activator.handler, sensor)
      }));
      return [...accumulator, ...sensorActivators];
    }, []), [sensors, getSyntheticHandler]);
  }
  var MeasuringStrategy;
  (function(MeasuringStrategy2) {
    MeasuringStrategy2[MeasuringStrategy2["Always"] = 0] = "Always";
    MeasuringStrategy2[MeasuringStrategy2["BeforeDragging"] = 1] = "BeforeDragging";
    MeasuringStrategy2[MeasuringStrategy2["WhileDragging"] = 2] = "WhileDragging";
  })(MeasuringStrategy || (MeasuringStrategy = {}));
  var MeasuringFrequency;
  (function(MeasuringFrequency2) {
    MeasuringFrequency2["Optimized"] = "optimized";
  })(MeasuringFrequency || (MeasuringFrequency = {}));
  const defaultValue = new Map();
  function useDroppableMeasuring(containers, _ref5) {
    let {
      dragging,
      dependencies,
      config
    } = _ref5;
    const [queue, setQueue] = H.useState(null);
    const {
      frequency,
      measure,
      strategy
    } = config;
    const containersRef = H.useRef(containers);
    const disabled = isDisabled();
    const disabledRef = useLatestValue(disabled);
    const measureDroppableContainers = H.useCallback(function(ids2) {
      if (ids2 === void 0) {
        ids2 = [];
      }
      if (disabledRef.current) {
        return;
      }
      setQueue((value) => {
        if (value === null) {
          return ids2;
        }
        return value.concat(ids2.filter((id) => !value.includes(id)));
      });
    }, [disabledRef]);
    const timeoutId = H.useRef(null);
    const droppableRects = useLazyMemo((previousValue) => {
      if (disabled && !dragging) {
        return defaultValue;
      }
      if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || queue != null) {
        const map = new Map();
        for (let container of containers) {
          if (!container) {
            continue;
          }
          if (queue && queue.length > 0 && !queue.includes(container.id) && container.rect.current) {
            map.set(container.id, container.rect.current);
            continue;
          }
          const node2 = container.node.current;
          const rect = node2 ? new Rect(measure(node2), node2) : null;
          container.rect.current = rect;
          if (rect) {
            map.set(container.id, rect);
          }
        }
        return map;
      }
      return previousValue;
    }, [containers, queue, dragging, disabled, measure]);
    H.useEffect(() => {
      containersRef.current = containers;
    }, [containers]);
    H.useEffect(
      () => {
        if (disabled) {
          return;
        }
        measureDroppableContainers();
      },
[dragging, disabled]
    );
    H.useEffect(
      () => {
        if (queue && queue.length > 0) {
          setQueue(null);
        }
      },
[JSON.stringify(queue)]
    );
    H.useEffect(
      () => {
        if (disabled || typeof frequency !== "number" || timeoutId.current !== null) {
          return;
        }
        timeoutId.current = setTimeout(() => {
          measureDroppableContainers();
          timeoutId.current = null;
        }, frequency);
      },
[frequency, disabled, measureDroppableContainers, ...dependencies]
    );
    return {
      droppableRects,
      measureDroppableContainers,
      measuringScheduled: queue != null
    };
    function isDisabled() {
      switch (strategy) {
        case MeasuringStrategy.Always:
          return false;
        case MeasuringStrategy.BeforeDragging:
          return dragging;
        default:
          return !dragging;
      }
    }
  }
  function useInitialValue(value, computeFn) {
    return useLazyMemo((previousValue) => {
      if (!value) {
        return null;
      }
      if (previousValue) {
        return previousValue;
      }
      return typeof computeFn === "function" ? computeFn(value) : value;
    }, [computeFn, value]);
  }
  function useInitialRect(node2, measure) {
    return useInitialValue(node2, measure);
  }
  function useMutationObserver(_ref5) {
    let {
      callback,
      disabled
    } = _ref5;
    const handleMutations = useEvent(callback);
    const mutationObserver = H.useMemo(() => {
      if (disabled || typeof window === "undefined" || typeof window.MutationObserver === "undefined") {
        return void 0;
      }
      const {
        MutationObserver: MutationObserver2
      } = window;
      return new MutationObserver2(handleMutations);
    }, [handleMutations, disabled]);
    H.useEffect(() => {
      return () => mutationObserver == null ? void 0 : mutationObserver.disconnect();
    }, [mutationObserver]);
    return mutationObserver;
  }
  function useResizeObserver(_ref5) {
    let {
      callback,
      disabled
    } = _ref5;
    const handleResize = useEvent(callback);
    const resizeObserver = H.useMemo(
      () => {
        if (disabled || typeof window === "undefined" || typeof window.ResizeObserver === "undefined") {
          return void 0;
        }
        const {
          ResizeObserver: ResizeObserver2
        } = window;
        return new ResizeObserver2(handleResize);
      },
[disabled]
    );
    H.useEffect(() => {
      return () => resizeObserver == null ? void 0 : resizeObserver.disconnect();
    }, [resizeObserver]);
    return resizeObserver;
  }
  function defaultMeasure(element) {
    return new Rect(getClientRect(element), element);
  }
  function useRect(element, measure, fallbackRect) {
    if (measure === void 0) {
      measure = defaultMeasure;
    }
    const [rect, setRect] = H.useState(null);
    function measureRect() {
      setRect((currentRect) => {
        if (!element) {
          return null;
        }
        if (element.isConnected === false) {
          var _ref5;
          return (_ref5 = currentRect != null ? currentRect : fallbackRect) != null ? _ref5 : null;
        }
        const newRect = measure(element);
        if (JSON.stringify(currentRect) === JSON.stringify(newRect)) {
          return currentRect;
        }
        return newRect;
      });
    }
    const mutationObserver = useMutationObserver({
      callback(records) {
        if (!element) {
          return;
        }
        for (const record of records) {
          const {
            type,
            target
          } = record;
          if (type === "childList" && target instanceof HTMLElement && target.contains(element)) {
            measureRect();
            break;
          }
        }
      }
    });
    const resizeObserver = useResizeObserver({
      callback: measureRect
    });
    useIsomorphicLayoutEffect(() => {
      measureRect();
      if (element) {
        resizeObserver == null ? void 0 : resizeObserver.observe(element);
        mutationObserver == null ? void 0 : mutationObserver.observe(document.body, {
          childList: true,
          subtree: true
        });
      } else {
        resizeObserver == null ? void 0 : resizeObserver.disconnect();
        mutationObserver == null ? void 0 : mutationObserver.disconnect();
      }
    }, [element]);
    return rect;
  }
  function useRectDelta(rect) {
    const initialRect = useInitialValue(rect);
    return getRectDelta(rect, initialRect);
  }
  const defaultValue$1 = [];
  function useScrollableAncestors(node2) {
    const previousNode = H.useRef(node2);
    const ancestors = useLazyMemo((previousValue) => {
      if (!node2) {
        return defaultValue$1;
      }
      if (previousValue && previousValue !== defaultValue$1 && node2 && previousNode.current && node2.parentNode === previousNode.current.parentNode) {
        return previousValue;
      }
      return getScrollableAncestors(node2);
    }, [node2]);
    H.useEffect(() => {
      previousNode.current = node2;
    }, [node2]);
    return ancestors;
  }
  function useScrollOffsets(elements) {
    const [scrollCoordinates, setScrollCoordinates] = H.useState(null);
    const prevElements = H.useRef(elements);
    const handleScroll = H.useCallback((event) => {
      const scrollingElement = getScrollableElement(event.target);
      if (!scrollingElement) {
        return;
      }
      setScrollCoordinates((scrollCoordinates2) => {
        if (!scrollCoordinates2) {
          return null;
        }
        scrollCoordinates2.set(scrollingElement, getScrollCoordinates(scrollingElement));
        return new Map(scrollCoordinates2);
      });
    }, []);
    H.useEffect(() => {
      const previousElements = prevElements.current;
      if (elements !== previousElements) {
        cleanup(previousElements);
        const entries = elements.map((element) => {
          const scrollableElement = getScrollableElement(element);
          if (scrollableElement) {
            scrollableElement.addEventListener("scroll", handleScroll, {
              passive: true
            });
            return [scrollableElement, getScrollCoordinates(scrollableElement)];
          }
          return null;
        }).filter((entry) => entry != null);
        setScrollCoordinates(entries.length ? new Map(entries) : null);
        prevElements.current = elements;
      }
      return () => {
        cleanup(elements);
        cleanup(previousElements);
      };
      function cleanup(elements2) {
        elements2.forEach((element) => {
          const scrollableElement = getScrollableElement(element);
          scrollableElement == null ? void 0 : scrollableElement.removeEventListener("scroll", handleScroll);
        });
      }
    }, [handleScroll, elements]);
    return H.useMemo(() => {
      if (elements.length) {
        return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates) => add(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);
      }
      return defaultCoordinates;
    }, [elements, scrollCoordinates]);
  }
  function useScrollOffsetsDelta(scrollOffsets, dependencies) {
    if (dependencies === void 0) {
      dependencies = [];
    }
    const initialScrollOffsets = H.useRef(null);
    H.useEffect(
      () => {
        initialScrollOffsets.current = null;
      },
dependencies
    );
    H.useEffect(() => {
      const hasScrollOffsets = scrollOffsets !== defaultCoordinates;
      if (hasScrollOffsets && !initialScrollOffsets.current) {
        initialScrollOffsets.current = scrollOffsets;
      }
      if (!hasScrollOffsets && initialScrollOffsets.current) {
        initialScrollOffsets.current = null;
      }
    }, [scrollOffsets]);
    return initialScrollOffsets.current ? subtract(scrollOffsets, initialScrollOffsets.current) : defaultCoordinates;
  }
  function useSensorSetup(sensors) {
    H.useEffect(
      () => {
        if (!canUseDOM) {
          return;
        }
        const teardownFns = sensors.map((_ref5) => {
          let {
            sensor
          } = _ref5;
          return sensor.setup == null ? void 0 : sensor.setup();
        });
        return () => {
          for (const teardown of teardownFns) {
            teardown == null ? void 0 : teardown();
          }
        };
      },

sensors.map((_ref22) => {
        let {
          sensor
        } = _ref22;
        return sensor;
      })
    );
  }
  function useSyntheticListeners(listeners2, id) {
    return H.useMemo(() => {
      return listeners2.reduce((acc, _ref5) => {
        let {
          eventName,
          handler
        } = _ref5;
        acc[eventName] = (event) => {
          handler(event, id);
        };
        return acc;
      }, {});
    }, [listeners2, id]);
  }
  function useWindowRect(element) {
    return H.useMemo(() => element ? getWindowClientRect(element) : null, [element]);
  }
  const defaultValue$2 = [];
  function useRects(elements, measure) {
    if (measure === void 0) {
      measure = getClientRect;
    }
    const [firstElement] = elements;
    const windowRect = useWindowRect(firstElement ? getWindow(firstElement) : null);
    const [rects, setRects] = H.useState(defaultValue$2);
    function measureRects() {
      setRects(() => {
        if (!elements.length) {
          return defaultValue$2;
        }
        return elements.map((element) => isDocumentScrollingElement(element) ? windowRect : new Rect(measure(element), element));
      });
    }
    const resizeObserver = useResizeObserver({
      callback: measureRects
    });
    useIsomorphicLayoutEffect(() => {
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
      measureRects();
      elements.forEach((element) => resizeObserver == null ? void 0 : resizeObserver.observe(element));
    }, [elements]);
    return rects;
  }
  function getMeasurableNode(node2) {
    if (!node2) {
      return null;
    }
    if (node2.children.length > 1) {
      return node2;
    }
    const firstChild = node2.children[0];
    return isHTMLElement(firstChild) ? firstChild : node2;
  }
  function useDragOverlayMeasuring(_ref5) {
    let {
      measure
    } = _ref5;
    const [rect, setRect] = H.useState(null);
    const handleResize = H.useCallback((entries) => {
      for (const {
        target
      } of entries) {
        if (isHTMLElement(target)) {
          setRect((rect2) => {
            const newRect = measure(target);
            return rect2 ? {
              ...rect2,
              width: newRect.width,
              height: newRect.height
            } : newRect;
          });
          break;
        }
      }
    }, [measure]);
    const resizeObserver = useResizeObserver({
      callback: handleResize
    });
    const handleNodeChange = H.useCallback((element) => {
      const node2 = getMeasurableNode(element);
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
      if (node2) {
        resizeObserver == null ? void 0 : resizeObserver.observe(node2);
      }
      setRect(node2 ? measure(node2) : null);
    }, [measure, resizeObserver]);
    const [nodeRef, setRef] = useNodeRef(handleNodeChange);
    return H.useMemo(() => ({
      nodeRef,
      rect,
      setRef
    }), [rect, nodeRef, setRef]);
  }
  const defaultSensors = [{
    sensor: PointerSensor,
    options: {}
  }, {
    sensor: KeyboardSensor,
    options: {}
  }];
  const defaultData = {
    current: {}
  };
  const defaultMeasuringConfiguration = {
    draggable: {
      measure: getTransformAgnosticClientRect
    },
    droppable: {
      measure: getTransformAgnosticClientRect,
      strategy: MeasuringStrategy.WhileDragging,
      frequency: MeasuringFrequency.Optimized
    },
    dragOverlay: {
      measure: getClientRect
    }
  };
  class DroppableContainersMap extends Map {
    get(id) {
      var _super$get;
      return id != null ? (_super$get = super.get(id)) != null ? _super$get : void 0 : void 0;
    }
    toArray() {
      return Array.from(this.values());
    }
    getEnabled() {
      return this.toArray().filter((_ref5) => {
        let {
          disabled
        } = _ref5;
        return !disabled;
      });
    }
    getNodeFor(id) {
      var _this$get$node$curren, _this$get;
      return (_this$get$node$curren = (_this$get = this.get(id)) == null ? void 0 : _this$get.node.current) != null ? _this$get$node$curren : void 0;
    }
  }
  const defaultPublicContext = {
    activatorEvent: null,
    active: null,
    activeNode: null,
    activeNodeRect: null,
    collisions: null,
    containerNodeRect: null,
    draggableNodes: new Map(),
    droppableRects: new Map(),
    droppableContainers: new DroppableContainersMap(),
    over: null,
    dragOverlay: {
      nodeRef: {
        current: null
      },
      rect: null,
      setRef: noop
    },
    scrollableAncestors: [],
    scrollableAncestorRects: [],
    measuringConfiguration: defaultMeasuringConfiguration,
    measureDroppableContainers: noop,
    windowRect: null,
    measuringScheduled: false
  };
  const defaultInternalContext = {
    activatorEvent: null,
    activators: [],
    active: null,
    activeNodeRect: null,
    ariaDescribedById: {
      draggable: ""
    },
    dispatch: noop,
    draggableNodes: new Map(),
    over: null,
    measureDroppableContainers: noop
  };
  const InternalContext = H.createContext(defaultInternalContext);
  const PublicContext = H.createContext(defaultPublicContext);
  function getInitialState() {
    return {
      draggable: {
        active: null,
        initialCoordinates: {
          x: 0,
          y: 0
        },
        nodes: new Map(),
        translate: {
          x: 0,
          y: 0
        }
      },
      droppable: {
        containers: new DroppableContainersMap()
      }
    };
  }
  function reducer(state2, action2) {
    switch (action2.type) {
      case Action.DragStart:
        return {
          ...state2,
          draggable: {
            ...state2.draggable,
            initialCoordinates: action2.initialCoordinates,
            active: action2.active
          }
        };
      case Action.DragMove:
        if (state2.draggable.active == null) {
          return state2;
        }
        return {
          ...state2,
          draggable: {
            ...state2.draggable,
            translate: {
              x: action2.coordinates.x - state2.draggable.initialCoordinates.x,
              y: action2.coordinates.y - state2.draggable.initialCoordinates.y
            }
          }
        };
      case Action.DragEnd:
      case Action.DragCancel:
        return {
          ...state2,
          draggable: {
            ...state2.draggable,
            active: null,
            initialCoordinates: {
              x: 0,
              y: 0
            },
            translate: {
              x: 0,
              y: 0
            }
          }
        };
      case Action.RegisterDroppable: {
        const {
          element
        } = action2;
        const {
          id
        } = element;
        const containers = new DroppableContainersMap(state2.droppable.containers);
        containers.set(id, element);
        return {
          ...state2,
          droppable: {
            ...state2.droppable,
            containers
          }
        };
      }
      case Action.SetDroppableDisabled: {
        const {
          id,
          key,
          disabled
        } = action2;
        const element = state2.droppable.containers.get(id);
        if (!element || key !== element.key) {
          return state2;
        }
        const containers = new DroppableContainersMap(state2.droppable.containers);
        containers.set(id, {
          ...element,
          disabled
        });
        return {
          ...state2,
          droppable: {
            ...state2.droppable,
            containers
          }
        };
      }
      case Action.UnregisterDroppable: {
        const {
          id,
          key
        } = action2;
        const element = state2.droppable.containers.get(id);
        if (!element || key !== element.key) {
          return state2;
        }
        const containers = new DroppableContainersMap(state2.droppable.containers);
        containers.delete(id);
        return {
          ...state2,
          droppable: {
            ...state2.droppable,
            containers
          }
        };
      }
      default: {
        return state2;
      }
    }
  }
  function RestoreFocus(_ref5) {
    let {
      disabled
    } = _ref5;
    const {
      active,
      activatorEvent,
      draggableNodes
    } = H.useContext(InternalContext);
    const previousActivatorEvent = usePrevious(activatorEvent);
    const previousActiveId = usePrevious(active == null ? void 0 : active.id);
    H.useEffect(() => {
      if (disabled) {
        return;
      }
      if (!activatorEvent && previousActivatorEvent && previousActiveId != null) {
        if (!isKeyboardEvent(previousActivatorEvent)) {
          return;
        }
        if (document.activeElement === previousActivatorEvent.target) {
          return;
        }
        const draggableNode = draggableNodes.get(previousActiveId);
        if (!draggableNode) {
          return;
        }
        const {
          activatorNode,
          node: node2
        } = draggableNode;
        if (!activatorNode.current && !node2.current) {
          return;
        }
        requestAnimationFrame(() => {
          for (const element of [activatorNode.current, node2.current]) {
            if (!element) {
              continue;
            }
            const focusableNode = findFirstFocusableNode(element);
            if (focusableNode) {
              focusableNode.focus();
              break;
            }
          }
        });
      }
    }, [activatorEvent, disabled, draggableNodes, previousActiveId, previousActivatorEvent]);
    return null;
  }
  function applyModifiers(modifiers, _ref5) {
    let {
      transform,
      ...args
    } = _ref5;
    return modifiers != null && modifiers.length ? modifiers.reduce((accumulator, modifier) => {
      return modifier({
        transform: accumulator,
        ...args
      });
    }, transform) : transform;
  }
  function useMeasuringConfiguration(config) {
    return H.useMemo(
      () => ({
        draggable: {
          ...defaultMeasuringConfiguration.draggable,
          ...config == null ? void 0 : config.draggable
        },
        droppable: {
          ...defaultMeasuringConfiguration.droppable,
          ...config == null ? void 0 : config.droppable
        },
        dragOverlay: {
          ...defaultMeasuringConfiguration.dragOverlay,
          ...config == null ? void 0 : config.dragOverlay
        }
      }),
[config == null ? void 0 : config.draggable, config == null ? void 0 : config.droppable, config == null ? void 0 : config.dragOverlay]
    );
  }
  function useLayoutShiftScrollCompensation(_ref5) {
    let {
      activeNode,
      measure,
      initialRect,
      config = true
    } = _ref5;
    const initialized = H.useRef(false);
    const {
      x,
      y
    } = typeof config === "boolean" ? {
      x: config,
      y: config
    } : config;
    useIsomorphicLayoutEffect(() => {
      const disabled = !x && !y;
      if (disabled || !activeNode) {
        initialized.current = false;
        return;
      }
      if (initialized.current || !initialRect) {
        return;
      }
      const node2 = activeNode == null ? void 0 : activeNode.node.current;
      if (!node2 || node2.isConnected === false) {
        return;
      }
      const rect = measure(node2);
      const rectDelta = getRectDelta(rect, initialRect);
      if (!x) {
        rectDelta.x = 0;
      }
      if (!y) {
        rectDelta.y = 0;
      }
      initialized.current = true;
      if (Math.abs(rectDelta.x) > 0 || Math.abs(rectDelta.y) > 0) {
        const firstScrollableAncestor = getFirstScrollableAncestor(node2);
        if (firstScrollableAncestor) {
          firstScrollableAncestor.scrollBy({
            top: rectDelta.y,
            left: rectDelta.x
          });
        }
      }
    }, [activeNode, x, y, initialRect, measure]);
  }
  const ActiveDraggableContext = H.createContext({
    ...defaultCoordinates,
    scaleX: 1,
    scaleY: 1
  });
  var Status;
  (function(Status2) {
    Status2[Status2["Uninitialized"] = 0] = "Uninitialized";
    Status2[Status2["Initializing"] = 1] = "Initializing";
    Status2[Status2["Initialized"] = 2] = "Initialized";
  })(Status || (Status = {}));
  const DndContext = H.memo(function DndContext2(_ref5) {
    var _sensorContext$curren, _dragOverlay$nodeRef$, _dragOverlay$rect, _over$rect;
    let {
      id,
      accessibility,
      autoScroll = true,
      children,
      sensors = defaultSensors,
      collisionDetection = rectIntersection,
      measuring,
      modifiers,
      ...props
    } = _ref5;
    const store2 = H.useReducer(reducer, void 0, getInitialState);
    const [state2, dispatch] = store2;
    const [dispatchMonitorEvent, registerMonitorListener] = useDndMonitorProvider();
    const [status, setStatus] = H.useState(Status.Uninitialized);
    const isInitialized = status === Status.Initialized;
    const {
      draggable: {
        active: activeId,
        nodes: draggableNodes,
        translate
      },
      droppable: {
        containers: droppableContainers
      }
    } = state2;
    const node2 = activeId != null ? draggableNodes.get(activeId) : null;
    const activeRects = H.useRef({
      initial: null,
      translated: null
    });
    const active = H.useMemo(() => {
      var _node$data;
      return activeId != null ? {
        id: activeId,
data: (_node$data = node2 == null ? void 0 : node2.data) != null ? _node$data : defaultData,
        rect: activeRects
      } : null;
    }, [activeId, node2]);
    const activeRef = H.useRef(null);
    const [activeSensor, setActiveSensor] = H.useState(null);
    const [activatorEvent, setActivatorEvent] = H.useState(null);
    const latestProps = useLatestValue(props, Object.values(props));
    const draggableDescribedById = useUniqueId("DndDescribedBy", id);
    const enabledDroppableContainers = H.useMemo(() => droppableContainers.getEnabled(), [droppableContainers]);
    const measuringConfiguration = useMeasuringConfiguration(measuring);
    const {
      droppableRects,
      measureDroppableContainers,
      measuringScheduled
    } = useDroppableMeasuring(enabledDroppableContainers, {
      dragging: isInitialized,
      dependencies: [translate.x, translate.y],
      config: measuringConfiguration.droppable
    });
    const activeNode = useCachedNode(draggableNodes, activeId);
    const activationCoordinates = H.useMemo(() => activatorEvent ? getEventCoordinates(activatorEvent) : null, [activatorEvent]);
    const autoScrollOptions = getAutoScrollerOptions();
    const initialActiveNodeRect = useInitialRect(activeNode, measuringConfiguration.draggable.measure);
    useLayoutShiftScrollCompensation({
      activeNode: activeId != null ? draggableNodes.get(activeId) : null,
      config: autoScrollOptions.layoutShiftCompensation,
      initialRect: initialActiveNodeRect,
      measure: measuringConfiguration.draggable.measure
    });
    const activeNodeRect = useRect(activeNode, measuringConfiguration.draggable.measure, initialActiveNodeRect);
    const containerNodeRect = useRect(activeNode ? activeNode.parentElement : null);
    const sensorContext = H.useRef({
      activatorEvent: null,
      active: null,
      activeNode,
      collisionRect: null,
      collisions: null,
      droppableRects,
      draggableNodes,
      draggingNode: null,
      draggingNodeRect: null,
      droppableContainers,
      over: null,
      scrollableAncestors: [],
      scrollAdjustedTranslate: null
    });
    const overNode = droppableContainers.getNodeFor((_sensorContext$curren = sensorContext.current.over) == null ? void 0 : _sensorContext$curren.id);
    const dragOverlay = useDragOverlayMeasuring({
      measure: measuringConfiguration.dragOverlay.measure
    });
    const draggingNode = (_dragOverlay$nodeRef$ = dragOverlay.nodeRef.current) != null ? _dragOverlay$nodeRef$ : activeNode;
    const draggingNodeRect = isInitialized ? (_dragOverlay$rect = dragOverlay.rect) != null ? _dragOverlay$rect : activeNodeRect : null;
    const usesDragOverlay = Boolean(dragOverlay.nodeRef.current && dragOverlay.rect);
    const nodeRectDelta = useRectDelta(usesDragOverlay ? null : activeNodeRect);
    const windowRect = useWindowRect(draggingNode ? getWindow(draggingNode) : null);
    const scrollableAncestors = useScrollableAncestors(isInitialized ? overNode != null ? overNode : activeNode : null);
    const scrollableAncestorRects = useRects(scrollableAncestors);
    const modifiedTranslate = applyModifiers(modifiers, {
      transform: {
        x: translate.x - nodeRectDelta.x,
        y: translate.y - nodeRectDelta.y,
        scaleX: 1,
        scaleY: 1
      },
      activatorEvent,
      active,
      activeNodeRect,
      containerNodeRect,
      draggingNodeRect,
      over: sensorContext.current.over,
      overlayNodeRect: dragOverlay.rect,
      scrollableAncestors,
      scrollableAncestorRects,
      windowRect
    });
    const pointerCoordinates = activationCoordinates ? add(activationCoordinates, translate) : null;
    const scrollOffsets = useScrollOffsets(scrollableAncestors);
    const scrollAdjustment = useScrollOffsetsDelta(scrollOffsets);
    const activeNodeScrollDelta = useScrollOffsetsDelta(scrollOffsets, [activeNodeRect]);
    const scrollAdjustedTranslate = add(modifiedTranslate, scrollAdjustment);
    const collisionRect = draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null;
    const collisions = active && collisionRect ? collisionDetection({
      active,
      collisionRect,
      droppableRects,
      droppableContainers: enabledDroppableContainers,
      pointerCoordinates
    }) : null;
    const overId = getFirstCollision(collisions, "id");
    const [over, setOver] = H.useState(null);
    const appliedTranslate = usesDragOverlay ? modifiedTranslate : add(modifiedTranslate, activeNodeScrollDelta);
    const transform = adjustScale(appliedTranslate, (_over$rect = over == null ? void 0 : over.rect) != null ? _over$rect : null, activeNodeRect);
    const activeSensorRef = H.useRef(null);
    const instantiateSensor = H.useCallback(
      (event, _ref22) => {
        let {
          sensor: Sensor,
          options
        } = _ref22;
        if (activeRef.current == null) {
          return;
        }
        const activeNode2 = draggableNodes.get(activeRef.current);
        if (!activeNode2) {
          return;
        }
        const activatorEvent2 = event.nativeEvent;
        const sensorInstance = new Sensor({
          active: activeRef.current,
          activeNode: activeNode2,
          event: activatorEvent2,
          options,

context: sensorContext,
          onAbort(id2) {
            const draggableNode = draggableNodes.get(id2);
            if (!draggableNode) {
              return;
            }
            const {
              onDragAbort
            } = latestProps.current;
            const event2 = {
              id: id2
            };
            onDragAbort == null ? void 0 : onDragAbort(event2);
            dispatchMonitorEvent({
              type: "onDragAbort",
              event: event2
            });
          },
          onPending(id2, constraint, initialCoordinates, offset) {
            const draggableNode = draggableNodes.get(id2);
            if (!draggableNode) {
              return;
            }
            const {
              onDragPending
            } = latestProps.current;
            const event2 = {
              id: id2,
              constraint,
              initialCoordinates,
              offset
            };
            onDragPending == null ? void 0 : onDragPending(event2);
            dispatchMonitorEvent({
              type: "onDragPending",
              event: event2
            });
          },
          onStart(initialCoordinates) {
            const id2 = activeRef.current;
            if (id2 == null) {
              return;
            }
            const draggableNode = draggableNodes.get(id2);
            if (!draggableNode) {
              return;
            }
            const {
              onDragStart
            } = latestProps.current;
            const event2 = {
              activatorEvent: activatorEvent2,
              active: {
                id: id2,
                data: draggableNode.data,
                rect: activeRects
              }
            };
            require$$0.unstable_batchedUpdates(() => {
              onDragStart == null ? void 0 : onDragStart(event2);
              setStatus(Status.Initializing);
              dispatch({
                type: Action.DragStart,
                initialCoordinates,
                active: id2
              });
              dispatchMonitorEvent({
                type: "onDragStart",
                event: event2
              });
              setActiveSensor(activeSensorRef.current);
              setActivatorEvent(activatorEvent2);
            });
          },
          onMove(coordinates) {
            dispatch({
              type: Action.DragMove,
              coordinates
            });
          },
          onEnd: createHandler2(Action.DragEnd),
          onCancel: createHandler2(Action.DragCancel)
        });
        activeSensorRef.current = sensorInstance;
        function createHandler2(type) {
          return async function handler() {
            const {
              active: active2,
              collisions: collisions2,
              over: over2,
              scrollAdjustedTranslate: scrollAdjustedTranslate2
            } = sensorContext.current;
            let event2 = null;
            if (active2 && scrollAdjustedTranslate2) {
              const {
                cancelDrop
              } = latestProps.current;
              event2 = {
                activatorEvent: activatorEvent2,
                active: active2,
                collisions: collisions2,
                delta: scrollAdjustedTranslate2,
                over: over2
              };
              if (type === Action.DragEnd && typeof cancelDrop === "function") {
                const shouldCancel = await Promise.resolve(cancelDrop(event2));
                if (shouldCancel) {
                  type = Action.DragCancel;
                }
              }
            }
            activeRef.current = null;
            require$$0.unstable_batchedUpdates(() => {
              dispatch({
                type
              });
              setStatus(Status.Uninitialized);
              setOver(null);
              setActiveSensor(null);
              setActivatorEvent(null);
              activeSensorRef.current = null;
              const eventName = type === Action.DragEnd ? "onDragEnd" : "onDragCancel";
              if (event2) {
                const handler2 = latestProps.current[eventName];
                handler2 == null ? void 0 : handler2(event2);
                dispatchMonitorEvent({
                  type: eventName,
                  event: event2
                });
              }
            });
          };
        }
      },
[draggableNodes]
    );
    const bindActivatorToSensorInstantiator = H.useCallback((handler, sensor) => {
      return (event, active2) => {
        const nativeEvent = event.nativeEvent;
        const activeDraggableNode = draggableNodes.get(active2);
        if (
activeRef.current !== null ||
!activeDraggableNode ||
nativeEvent.dndKit || nativeEvent.defaultPrevented
        ) {
          return;
        }
        const activationContext = {
          active: activeDraggableNode
        };
        const shouldActivate = handler(event, sensor.options, activationContext);
        if (shouldActivate === true) {
          nativeEvent.dndKit = {
            capturedBy: sensor.sensor
          };
          activeRef.current = active2;
          instantiateSensor(event, sensor);
        }
      };
    }, [draggableNodes, instantiateSensor]);
    const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);
    useSensorSetup(sensors);
    useIsomorphicLayoutEffect(() => {
      if (activeNodeRect && status === Status.Initializing) {
        setStatus(Status.Initialized);
      }
    }, [activeNodeRect, status]);
    H.useEffect(
      () => {
        const {
          onDragMove
        } = latestProps.current;
        const {
          active: active2,
          activatorEvent: activatorEvent2,
          collisions: collisions2,
          over: over2
        } = sensorContext.current;
        if (!active2 || !activatorEvent2) {
          return;
        }
        const event = {
          active: active2,
          activatorEvent: activatorEvent2,
          collisions: collisions2,
          delta: {
            x: scrollAdjustedTranslate.x,
            y: scrollAdjustedTranslate.y
          },
          over: over2
        };
        require$$0.unstable_batchedUpdates(() => {
          onDragMove == null ? void 0 : onDragMove(event);
          dispatchMonitorEvent({
            type: "onDragMove",
            event
          });
        });
      },
[scrollAdjustedTranslate.x, scrollAdjustedTranslate.y]
    );
    H.useEffect(
      () => {
        const {
          active: active2,
          activatorEvent: activatorEvent2,
          collisions: collisions2,
          droppableContainers: droppableContainers2,
          scrollAdjustedTranslate: scrollAdjustedTranslate2
        } = sensorContext.current;
        if (!active2 || activeRef.current == null || !activatorEvent2 || !scrollAdjustedTranslate2) {
          return;
        }
        const {
          onDragOver
        } = latestProps.current;
        const overContainer = droppableContainers2.get(overId);
        const over2 = overContainer && overContainer.rect.current ? {
          id: overContainer.id,
          rect: overContainer.rect.current,
          data: overContainer.data,
          disabled: overContainer.disabled
        } : null;
        const event = {
          active: active2,
          activatorEvent: activatorEvent2,
          collisions: collisions2,
          delta: {
            x: scrollAdjustedTranslate2.x,
            y: scrollAdjustedTranslate2.y
          },
          over: over2
        };
        require$$0.unstable_batchedUpdates(() => {
          setOver(over2);
          onDragOver == null ? void 0 : onDragOver(event);
          dispatchMonitorEvent({
            type: "onDragOver",
            event
          });
        });
      },
[overId]
    );
    useIsomorphicLayoutEffect(() => {
      sensorContext.current = {
        activatorEvent,
        active,
        activeNode,
        collisionRect,
        collisions,
        droppableRects,
        draggableNodes,
        draggingNode,
        draggingNodeRect,
        droppableContainers,
        over,
        scrollableAncestors,
        scrollAdjustedTranslate
      };
      activeRects.current = {
        initial: draggingNodeRect,
        translated: collisionRect
      };
    }, [active, activeNode, collisions, collisionRect, draggableNodes, draggingNode, draggingNodeRect, droppableRects, droppableContainers, over, scrollableAncestors, scrollAdjustedTranslate]);
    useAutoScroller({
      ...autoScrollOptions,
      delta: translate,
      draggingRect: collisionRect,
      pointerCoordinates,
      scrollableAncestors,
      scrollableAncestorRects
    });
    const publicContext = H.useMemo(() => {
      const context = {
        active,
        activeNode,
        activeNodeRect,
        activatorEvent,
        collisions,
        containerNodeRect,
        dragOverlay,
        draggableNodes,
        droppableContainers,
        droppableRects,
        over,
        measureDroppableContainers,
        scrollableAncestors,
        scrollableAncestorRects,
        measuringConfiguration,
        measuringScheduled,
        windowRect
      };
      return context;
    }, [active, activeNode, activeNodeRect, activatorEvent, collisions, containerNodeRect, dragOverlay, draggableNodes, droppableContainers, droppableRects, over, measureDroppableContainers, scrollableAncestors, scrollableAncestorRects, measuringConfiguration, measuringScheduled, windowRect]);
    const internalContext = H.useMemo(() => {
      const context = {
        activatorEvent,
        activators,
        active,
        activeNodeRect,
        ariaDescribedById: {
          draggable: draggableDescribedById
        },
        dispatch,
        draggableNodes,
        over,
        measureDroppableContainers
      };
      return context;
    }, [activatorEvent, activators, active, activeNodeRect, dispatch, draggableDescribedById, draggableNodes, over, measureDroppableContainers]);
    return H.createElement(DndMonitorContext.Provider, {
      value: registerMonitorListener
    }, H.createElement(InternalContext.Provider, {
      value: internalContext
    }, H.createElement(PublicContext.Provider, {
      value: publicContext
    }, H.createElement(ActiveDraggableContext.Provider, {
      value: transform
    }, children)), H.createElement(RestoreFocus, {
      disabled: (accessibility == null ? void 0 : accessibility.restoreFocus) === false
    })), H.createElement(Accessibility, {
      ...accessibility,
      hiddenTextDescribedById: draggableDescribedById
    }));
    function getAutoScrollerOptions() {
      const activeSensorDisablesAutoscroll = (activeSensor == null ? void 0 : activeSensor.autoScrollEnabled) === false;
      const autoScrollGloballyDisabled = typeof autoScroll === "object" ? autoScroll.enabled === false : autoScroll === false;
      const enabled = isInitialized && !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;
      if (typeof autoScroll === "object") {
        return {
          ...autoScroll,
          enabled
        };
      }
      return {
        enabled
      };
    }
  });
  const NullContext = H.createContext(null);
  const defaultRole = "button";
  const ID_PREFIX$1 = "Draggable";
  function useDraggable(_ref5) {
    let {
      id,
      data: data2,
      disabled = false,
      attributes
    } = _ref5;
    const key = useUniqueId(ID_PREFIX$1);
    const {
      activators,
      activatorEvent,
      active,
      activeNodeRect,
      ariaDescribedById,
      draggableNodes,
      over
    } = H.useContext(InternalContext);
    const {
      role = defaultRole,
      roleDescription = "draggable",
      tabIndex = 0
    } = attributes != null ? attributes : {};
    const isDragging = (active == null ? void 0 : active.id) === id;
    const transform = H.useContext(isDragging ? ActiveDraggableContext : NullContext);
    const [node2, setNodeRef] = useNodeRef();
    const [activatorNode, setActivatorNodeRef] = useNodeRef();
    const listeners2 = useSyntheticListeners(activators, id);
    const dataRef = useLatestValue(data2);
    useIsomorphicLayoutEffect(
      () => {
        draggableNodes.set(id, {
          id,
          key,
          node: node2,
          activatorNode,
          data: dataRef
        });
        return () => {
          const node3 = draggableNodes.get(id);
          if (node3 && node3.key === key) {
            draggableNodes.delete(id);
          }
        };
      },
[draggableNodes, id]
    );
    const memoizedAttributes = H.useMemo(() => ({
      role,
      tabIndex,
      "aria-disabled": disabled,
      "aria-pressed": isDragging && role === defaultRole ? true : void 0,
      "aria-roledescription": roleDescription,
      "aria-describedby": ariaDescribedById.draggable
    }), [disabled, role, tabIndex, isDragging, roleDescription, ariaDescribedById.draggable]);
    return {
      active,
      activatorEvent,
      activeNodeRect,
      attributes: memoizedAttributes,
      isDragging,
      listeners: disabled ? void 0 : listeners2,
      node: node2,
      over,
      setNodeRef,
      setActivatorNodeRef,
      transform
    };
  }
  function useDndContext() {
    return H.useContext(PublicContext);
  }
  const ID_PREFIX$1$1 = "Droppable";
  const defaultResizeObserverConfig = {
    timeout: 25
  };
  function useDroppable(_ref5) {
    let {
      data: data2,
      disabled = false,
      id,
      resizeObserverConfig
    } = _ref5;
    const key = useUniqueId(ID_PREFIX$1$1);
    const {
      active,
      dispatch,
      over,
      measureDroppableContainers
    } = H.useContext(InternalContext);
    const previous = H.useRef({
      disabled
    });
    const resizeObserverConnected = H.useRef(false);
    const rect = H.useRef(null);
    const callbackId = H.useRef(null);
    const {
      disabled: resizeObserverDisabled,
      updateMeasurementsFor,
      timeout: resizeObserverTimeout
    } = {
      ...defaultResizeObserverConfig,
      ...resizeObserverConfig
    };
    const ids2 = useLatestValue(updateMeasurementsFor != null ? updateMeasurementsFor : id);
    const handleResize = H.useCallback(
      () => {
        if (!resizeObserverConnected.current) {
          resizeObserverConnected.current = true;
          return;
        }
        if (callbackId.current != null) {
          clearTimeout(callbackId.current);
        }
        callbackId.current = setTimeout(() => {
          measureDroppableContainers(Array.isArray(ids2.current) ? ids2.current : [ids2.current]);
          callbackId.current = null;
        }, resizeObserverTimeout);
      },
[resizeObserverTimeout]
    );
    const resizeObserver = useResizeObserver({
      callback: handleResize,
      disabled: resizeObserverDisabled || !active
    });
    const handleNodeChange = H.useCallback((newElement, previousElement) => {
      if (!resizeObserver) {
        return;
      }
      if (previousElement) {
        resizeObserver.unobserve(previousElement);
        resizeObserverConnected.current = false;
      }
      if (newElement) {
        resizeObserver.observe(newElement);
      }
    }, [resizeObserver]);
    const [nodeRef, setNodeRef] = useNodeRef(handleNodeChange);
    const dataRef = useLatestValue(data2);
    H.useEffect(() => {
      if (!resizeObserver || !nodeRef.current) {
        return;
      }
      resizeObserver.disconnect();
      resizeObserverConnected.current = false;
      resizeObserver.observe(nodeRef.current);
    }, [nodeRef, resizeObserver]);
    H.useEffect(
      () => {
        dispatch({
          type: Action.RegisterDroppable,
          element: {
            id,
            key,
            disabled,
            node: nodeRef,
            rect,
            data: dataRef
          }
        });
        return () => dispatch({
          type: Action.UnregisterDroppable,
          key,
          id
        });
      },
[id]
    );
    H.useEffect(() => {
      if (disabled !== previous.current.disabled) {
        dispatch({
          type: Action.SetDroppableDisabled,
          id,
          key,
          disabled
        });
        previous.current.disabled = disabled;
      }
    }, [id, key, disabled, dispatch]);
    return {
      active,
      rect,
      isOver: (over == null ? void 0 : over.id) === id,
      node: nodeRef,
      over,
      setNodeRef
    };
  }
  function restrictToBoundingRect(transform, rect, boundingRect) {
    const value = {
      ...transform
    };
    if (rect.top + transform.y <= boundingRect.top) {
      value.y = boundingRect.top - rect.top;
    } else if (rect.bottom + transform.y >= boundingRect.top + boundingRect.height) {
      value.y = boundingRect.top + boundingRect.height - rect.bottom;
    }
    if (rect.left + transform.x <= boundingRect.left) {
      value.x = boundingRect.left - rect.left;
    } else if (rect.right + transform.x >= boundingRect.left + boundingRect.width) {
      value.x = boundingRect.left + boundingRect.width - rect.right;
    }
    return value;
  }
  const restrictToParentElement = (_ref5) => {
    let {
      containerNodeRect,
      draggingNodeRect,
      transform
    } = _ref5;
    if (!draggingNodeRect || !containerNodeRect) {
      return transform;
    }
    return restrictToBoundingRect(transform, draggingNodeRect, containerNodeRect);
  };
  const restrictToVerticalAxis = (_ref5) => {
    let {
      transform
    } = _ref5;
    return {
      ...transform,
      x: 0
    };
  };
  function arrayMove(array, from2, to) {
    const newArray = array.slice();
    newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from2, 1)[0]);
    return newArray;
  }
  function getSortedRects(items, rects) {
    return items.reduce((accumulator, id, index) => {
      const rect = rects.get(id);
      if (rect) {
        accumulator[index] = rect;
      }
      return accumulator;
    }, Array(items.length));
  }
  function isValidIndex(index) {
    return index !== null && index >= 0;
  }
  function itemsEqual(a2, b) {
    if (a2 === b) {
      return true;
    }
    if (a2.length !== b.length) {
      return false;
    }
    for (let i2 = 0; i2 < a2.length; i2++) {
      if (a2[i2] !== b[i2]) {
        return false;
      }
    }
    return true;
  }
  function normalizeDisabled(disabled) {
    if (typeof disabled === "boolean") {
      return {
        draggable: disabled,
        droppable: disabled
      };
    }
    return disabled;
  }
  const rectSortingStrategy = (_ref5) => {
    let {
      rects,
      activeIndex,
      overIndex,
      index
    } = _ref5;
    const newRects = arrayMove(rects, overIndex, activeIndex);
    const oldRect = rects[index];
    const newRect = newRects[index];
    if (!newRect || !oldRect) {
      return null;
    }
    return {
      x: newRect.left - oldRect.left,
      y: newRect.top - oldRect.top,
      scaleX: newRect.width / oldRect.width,
      scaleY: newRect.height / oldRect.height
    };
  };
  const defaultScale$1 = {
    scaleX: 1,
    scaleY: 1
  };
  const verticalListSortingStrategy = (_ref5) => {
    var _rects$activeIndex;
    let {
      activeIndex,
      activeNodeRect: fallbackActiveRect,
      index,
      rects,
      overIndex
    } = _ref5;
    const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;
    if (!activeNodeRect) {
      return null;
    }
    if (index === activeIndex) {
      const overIndexRect = rects[overIndex];
      if (!overIndexRect) {
        return null;
      }
      return {
        x: 0,
        y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top,
        ...defaultScale$1
      };
    }
    const itemGap = getItemGap$1(rects, index, activeIndex);
    if (index > activeIndex && index <= overIndex) {
      return {
        x: 0,
        y: -activeNodeRect.height - itemGap,
        ...defaultScale$1
      };
    }
    if (index < activeIndex && index >= overIndex) {
      return {
        x: 0,
        y: activeNodeRect.height + itemGap,
        ...defaultScale$1
      };
    }
    return {
      x: 0,
      y: 0,
      ...defaultScale$1
    };
  };
  function getItemGap$1(clientRects, index, activeIndex) {
    const currentRect = clientRects[index];
    const previousRect = clientRects[index - 1];
    const nextRect = clientRects[index + 1];
    if (!currentRect) {
      return 0;
    }
    if (activeIndex < index) {
      return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;
    }
    return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;
  }
  const ID_PREFIX = "Sortable";
  const Context = H.createContext({
    activeIndex: -1,
    containerId: ID_PREFIX,
    disableTransforms: false,
    items: [],
    overIndex: -1,
    useDragOverlay: false,
    sortedRects: [],
    strategy: rectSortingStrategy,
    disabled: {
      draggable: false,
      droppable: false
    }
  });
  function SortableContext(_ref5) {
    let {
      children,
      id,
      items: userDefinedItems,
      strategy = rectSortingStrategy,
      disabled: disabledProp = false
    } = _ref5;
    const {
      active,
      dragOverlay,
      droppableRects,
      over,
      measureDroppableContainers
    } = useDndContext();
    const containerId = useUniqueId(ID_PREFIX, id);
    const useDragOverlay = Boolean(dragOverlay.rect !== null);
    const items = H.useMemo(() => userDefinedItems.map((item) => typeof item === "object" && "id" in item ? item.id : item), [userDefinedItems]);
    const isDragging = active != null;
    const activeIndex = active ? items.indexOf(active.id) : -1;
    const overIndex = over ? items.indexOf(over.id) : -1;
    const previousItemsRef = H.useRef(items);
    const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);
    const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;
    const disabled = normalizeDisabled(disabledProp);
    useIsomorphicLayoutEffect(() => {
      if (itemsHaveChanged && isDragging) {
        measureDroppableContainers(items);
      }
    }, [itemsHaveChanged, items, isDragging, measureDroppableContainers]);
    H.useEffect(() => {
      previousItemsRef.current = items;
    }, [items]);
    const contextValue = H.useMemo(
      () => ({
        activeIndex,
        containerId,
        disabled,
        disableTransforms,
        items,
        overIndex,
        useDragOverlay,
        sortedRects: getSortedRects(items, droppableRects),
        strategy
      }),
[activeIndex, containerId, disabled.draggable, disabled.droppable, disableTransforms, items, overIndex, droppableRects, useDragOverlay, strategy]
    );
    return H.createElement(Context.Provider, {
      value: contextValue
    }, children);
  }
  const defaultNewIndexGetter = (_ref5) => {
    let {
      id,
      items,
      activeIndex,
      overIndex
    } = _ref5;
    return arrayMove(items, activeIndex, overIndex).indexOf(id);
  };
  const defaultAnimateLayoutChanges = (_ref22) => {
    let {
      containerId,
      isSorting,
      wasDragging,
      index,
      items,
      newIndex,
      previousItems,
      previousContainerId,
      transition
    } = _ref22;
    if (!transition || !wasDragging) {
      return false;
    }
    if (previousItems !== items && index === newIndex) {
      return false;
    }
    if (isSorting) {
      return true;
    }
    return newIndex !== index && containerId === previousContainerId;
  };
  const defaultTransition = {
    duration: 200,
    easing: "ease"
  };
  const transitionProperty = "transform";
  const disabledTransition = CSS.Transition.toString({
    property: transitionProperty,
    duration: 0,
    easing: "linear"
  });
  const defaultAttributes = {
    roleDescription: "sortable"
  };
  function useDerivedTransform(_ref5) {
    let {
      disabled,
      index,
      node: node2,
      rect
    } = _ref5;
    const [derivedTransform, setDerivedtransform] = H.useState(null);
    const previousIndex = H.useRef(index);
    useIsomorphicLayoutEffect(() => {
      if (!disabled && index !== previousIndex.current && node2.current) {
        const initial = rect.current;
        if (initial) {
          const current = getClientRect(node2.current, {
            ignoreTransform: true
          });
          const delta = {
            x: initial.left - current.left,
            y: initial.top - current.top,
            scaleX: initial.width / current.width,
            scaleY: initial.height / current.height
          };
          if (delta.x || delta.y) {
            setDerivedtransform(delta);
          }
        }
      }
      if (index !== previousIndex.current) {
        previousIndex.current = index;
      }
    }, [disabled, index, node2, rect]);
    H.useEffect(() => {
      if (derivedTransform) {
        setDerivedtransform(null);
      }
    }, [derivedTransform]);
    return derivedTransform;
  }
  function useSortable(_ref5) {
    let {
      animateLayoutChanges = defaultAnimateLayoutChanges,
      attributes: userDefinedAttributes,
      disabled: localDisabled,
      data: customData,
      getNewIndex = defaultNewIndexGetter,
      id,
      strategy: localStrategy,
      resizeObserverConfig,
      transition = defaultTransition
    } = _ref5;
    const {
      items,
      containerId,
      activeIndex,
      disabled: globalDisabled,
      disableTransforms,
      sortedRects,
      overIndex,
      useDragOverlay,
      strategy: globalStrategy
    } = H.useContext(Context);
    const disabled = normalizeLocalDisabled(localDisabled, globalDisabled);
    const index = items.indexOf(id);
    const data2 = H.useMemo(() => ({
      sortable: {
        containerId,
        index,
        items
      },
      ...customData
    }), [containerId, customData, index, items]);
    const itemsAfterCurrentSortable = H.useMemo(() => items.slice(items.indexOf(id)), [items, id]);
    const {
      rect,
      node: node2,
      isOver,
      setNodeRef: setDroppableNodeRef
    } = useDroppable({
      id,
      data: data2,
      disabled: disabled.droppable,
      resizeObserverConfig: {
        updateMeasurementsFor: itemsAfterCurrentSortable,
        ...resizeObserverConfig
      }
    });
    const {
      active,
      activatorEvent,
      activeNodeRect,
      attributes,
      setNodeRef: setDraggableNodeRef,
      listeners: listeners2,
      isDragging,
      over,
      setActivatorNodeRef,
      transform
    } = useDraggable({
      id,
      data: data2,
      attributes: {
        ...defaultAttributes,
        ...userDefinedAttributes
      },
      disabled: disabled.draggable
    });
    const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);
    const isSorting = Boolean(active);
    const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);
    const shouldDisplaceDragSource = !useDragOverlay && isDragging;
    const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;
    const strategy = localStrategy != null ? localStrategy : globalStrategy;
    const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({
      rects: sortedRects,
      activeNodeRect,
      activeIndex,
      overIndex,
      index
    }) : null;
    const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({
      id,
      items,
      activeIndex,
      overIndex
    }) : index;
    const activeId = active == null ? void 0 : active.id;
    const previous = H.useRef({
      activeId,
      items,
      newIndex,
      containerId
    });
    const itemsHaveChanged = items !== previous.current.items;
    const shouldAnimateLayoutChanges = animateLayoutChanges({
      active,
      containerId,
      isDragging,
      isSorting,
      id,
      index,
      items,
      newIndex: previous.current.newIndex,
      previousItems: previous.current.items,
      previousContainerId: previous.current.containerId,
      transition,
      wasDragging: previous.current.activeId != null
    });
    const derivedTransform = useDerivedTransform({
      disabled: !shouldAnimateLayoutChanges,
      index,
      node: node2,
      rect
    });
    H.useEffect(() => {
      if (isSorting && previous.current.newIndex !== newIndex) {
        previous.current.newIndex = newIndex;
      }
      if (containerId !== previous.current.containerId) {
        previous.current.containerId = containerId;
      }
      if (items !== previous.current.items) {
        previous.current.items = items;
      }
    }, [isSorting, newIndex, containerId, items]);
    H.useEffect(() => {
      if (activeId === previous.current.activeId) {
        return;
      }
      if (activeId != null && previous.current.activeId == null) {
        previous.current.activeId = activeId;
        return;
      }
      const timeoutId = setTimeout(() => {
        previous.current.activeId = activeId;
      }, 50);
      return () => clearTimeout(timeoutId);
    }, [activeId]);
    return {
      active,
      activeIndex,
      attributes,
      data: data2,
      rect,
      index,
      newIndex,
      items,
      isOver,
      isSorting,
      isDragging,
      listeners: listeners2,
      node: node2,
      overIndex,
      over,
      setNodeRef,
      setActivatorNodeRef,
      setDroppableNodeRef,
      setDraggableNodeRef,
      transform: derivedTransform != null ? derivedTransform : finalTransform,
      transition: getTransition()
    };
    function getTransition() {
      if (
derivedTransform ||
itemsHaveChanged && previous.current.newIndex === index
      ) {
        return disabledTransition;
      }
      if (shouldDisplaceDragSource && !isKeyboardEvent(activatorEvent) || !transition) {
        return void 0;
      }
      if (isSorting || shouldAnimateLayoutChanges) {
        return CSS.Transition.toString({
          ...transition,
          property: transitionProperty
        });
      }
      return void 0;
    }
  }
  function normalizeLocalDisabled(localDisabled, globalDisabled) {
    var _localDisabled$dragga, _localDisabled$droppa;
    if (typeof localDisabled === "boolean") {
      return {
        draggable: localDisabled,
droppable: false
      };
    }
    return {
      draggable: (_localDisabled$dragga = localDisabled == null ? void 0 : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,
      droppable: (_localDisabled$droppa = localDisabled == null ? void 0 : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable
    };
  }
  [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];
  const iconParkOutlineDrag = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M19 10a4 4 0 1 1-8 0a4 4 0 0 1 8 0m-4 18a4 4 0 1 0 0-8a4 4 0 0 0 0 8m0 14a4 4 0 1 0 0-8a4 4 0 0 0 0 8m22-32a4 4 0 1 1-8 0a4 4 0 0 1 8 0m-4 18a4 4 0 1 0 0-8a4 4 0 0 0 0 8m0 14a4 4 0 1 0 0-8a4 4 0 0 0 0 8", clipRule: "evenodd" })
  ] });
  const ForwardRef$3 = H.forwardRef(iconParkOutlineDrag);
  function TabPaneRecTabsConfig() {
    const {
      dynamicFeed,
      appRecommend
    } = useSettingsSnapshot();
    const sortedTabKeys = useSortedTabKeys();
    const getCssOrderStyle = (tab2) => {
      return {
        order: sortedTabKeys.indexOf(tab2) + 1
      };
    };
    return jsx$1("div", { className: sharedClassNames.tabPane, children: jsxs("div", { className: "grid grid-cols-[250px_1fr] gap-x-50px", children: [
jsx$1(SettingsGroup, { title: jsxs(Fragment, { children: [
        "Tab 设置",
jsx$1(HelpInfo, { className: "ml-5px", children: "勾选显示, 拖动排序" }),
jsx$1("span", { className: "flex-1" }),
jsx$1(ResetPartialSettingsButton, { paths: ["hidingTabKeys", "customTabKeysOrder"] })
      ] }), children: jsx$1(VideoSourceTabOrder, {}) }),
jsxs(SettingsGroup, { title: "更多设置", contentClassName: "gap-y-15px", children: [
jsxs("div", { style: getCssOrderStyle(ETab.Watchlater), children: [
jsxs("div", { className: "flex items-center text-size-1.3em", children: [
jsx$1(TabIcon, { tabKey: ETab.Watchlater, className: "mr-5px mt--1px" }),
            "稍后再看"
          ] }),
jsxs(antd.Space, { size: 10, children: [
jsx$1(CheckboxSettingItem, { configPath: "watchlaterAddSeparator", label: "添加分割线", tooltip: "添加「近期」「更早」分割线" }),
jsx$1(CheckboxSettingItem, { configPath: "watchlaterUseNormalVideoUrl", label: "使用普通视频链接", tooltip: explainForFlag("使用普通视频链接", "使用「稍后再看」自动列表链接") })
          ] })
        ] }),
jsxs("div", { style: getCssOrderStyle(ETab.Fav), children: [
jsxs("div", { className: "flex items-center text-size-1.3em", children: [
jsx$1(TabIcon, { tabKey: ETab.Fav, className: "mr-5px mt--2px" }),
            "收藏"
          ] }),
jsx$1(antd.Space, { size: 10, children: jsx$1(CheckboxSettingItem, { configPath: "fav.addSeparator", label: "添加分割线", tooltip: "顺序显示时, 按收藏夹添加分割线" }) })
        ] }),
jsxs("div", { style: getCssOrderStyle(ETab.DynamicFeed), children: [
jsxs("div", { className: "flex items-center text-size-1.3em", children: [
jsx$1(TabIcon, { tabKey: ETab.DynamicFeed, className: "mr-5px mt--2px" }),
            "动态"
          ] }),
jsxs("div", { className: "flex flex-wrap gap-x-10px gap-y-10px", children: [
jsx$1(CheckboxSettingItem, { configPath: "dynamicFeed.followGroup.enabled", label: "启用分组筛选", tooltip: jsxs(Fragment, { children: [
              "动态 Tab 启用分组筛选 ",
jsx$1("br", {}),
jsx$1(FollowGroupMechanismNote, {})
            ] }) }),
jsx$1(CheckboxSettingItem, { configPath: "dynamicFeed.showLive", label: "在动态中显示直播", tooltip: jsxs(Fragment, { children: [
              "动态里显示正在直播的 UP",
jsx$1("br", {}),
              "P.S 仅在选择「全部」时展示"
            ] }) }),
jsx$1(CheckboxSettingItem, { configPath: "dynamicFeed.whenViewAll.enableHideSomeContents", label: "「全部」动态过滤", tooltip: jsxs(Fragment, { children: [
              "查看「全部」动态时 ",
jsx$1("br", {}),
              explainForFlag("将添加右键菜单, 点击可添加到「全部」动态的过滤列表", "关闭此功能")
            ] }) }),
            dynamicFeed.whenViewAll.enableHideSomeContents && jsx$1(antd.Collapse, { size: "small", className: "w-full", items: [{
              key: "1",
              label: "在「全部」动态中隐藏 UP/分组 的动态",
              children: jsx$1(DynamicFeedWhenViewAllHideIdsPanel, {})
            }] })
          ] })
        ] }),
jsxs("div", { style: getCssOrderStyle(ETab.AppRecommend), children: [
jsxs("div", { className: "flex items-center text-size-1.3em", children: [
jsx$1(TabIcon, { tabKey: ETab.AppRecommend, className: "mr-5px" }),
            "App 推荐"
          ] }),
jsx$1("div", { className: "flex flex-col gap-y-5px", children: jsx$1("div", { className: "flex items-center", children: appRecShowContentFromOtherTabEl() }) })
        ] })
      ] })
    ] }) });
  }
  function useCurrentShowingTabKeys() {
    const {
      hidingTabKeys
    } = useSettingsSnapshot();
    return H.useMemo(() => CONFIGURABLE_TAB_KEYS.filter((key) => !hidingTabKeys.includes(key)), [hidingTabKeys]);
  }
  function VideoSourceTabOrder({
    className,
    style
  }) {
    const currentShowingTabKeys = useCurrentShowingTabKeys();
    const sortedTabKeys = useSortedTabKeys();
    const sensors = useSensors(useSensor(PointerSensor));
    const handleDragEnd = useMemoizedFn((e2) => {
      const {
        over,
        active
      } = e2;
      if (!over?.id || over.id === active.id) return;
      const oldIndex = sortedTabKeys.indexOf(active.id.toString());
      const newIndex = sortedTabKeys.indexOf(over.id.toString());
      const newList = arrayMove(sortedTabKeys, oldIndex, newIndex);
      updateSettings({
        customTabKeysOrder: newList
      });
    });
    return jsx$1("div", { ...{
      className,
      style
    }, children: jsx$1(antd.Checkbox.Group, { className: "block line-height-[unset]", value: currentShowingTabKeys, onChange: (newVal) => {
      if (!newVal.length) {
        return antMessage.error("至少选择一项!");
      }
      updateSettings({
        hidingTabKeys: CONFIGURABLE_TAB_KEYS.filter((k) => !newVal.includes(k))
      });
    }, children: jsx$1(DndContext, { sensors, collisionDetection: closestCenter, onDragEnd: handleDragEnd, modifiers: [restrictToVerticalAxis, restrictToParentElement], children: jsx$1(SortableContext, { items: sortedTabKeys, strategy: verticalListSortingStrategy, children: sortedTabKeys.map((key) => jsx$1(VideoSourceTabSortableItem, { id: key }, key)) }) }) }) });
  }
  function VideoSourceTabSortableItem({
    id
  }) {
    const {
      attributes,
      listeners: listeners2,
      setNodeRef,
      transform,
      transition,
      setActivatorNodeRef
    } = useSortable({
      id
    });
    const style = {
      transform: CSS.Transform.toString(transform),
      transition
    };
    const {
      label,
      desc
    } = TabConfig[id];
    return jsxs("div", { ref: setNodeRef, style, className: "mt-8px h-35px flex items-center justify-between b-1px b-gate-bg-lv-2 rounded-6px b-solid pl-10px pr-6px", ...attributes, children: [
jsxs(antd.Checkbox, { value: id, className: "inline-flex items-center [&_.ant-checkbox-label]:inline-flex [&_.ant-checkbox-label]:select-none [&_.ant-checkbox-label]:items-center", children: [
jsx$1(TabIcon, { tabKey: id, className: "mr-5px" }),
jsx$1(AntdTooltip, { align: {
          offset: [0, -6]
        }, title: desc, children: label })
      ] }),
jsx$1("div", { ...listeners2, ref: setActivatorNodeRef, className: "cursor-grab rounded-5px px-5px py-3px text-size-0 hover:bg-gate-bg-lv-3", children: jsx$1(ForwardRef$3, { className: "size-18px" }) })
    ] }, id);
  }
  function DynamicFeedWhenViewAllHideIdsPanel() {
    const {
      hideIds
    } = useSnapshot(settings.dynamicFeed.whenViewAll);
    const onDelete = useMemoizedFn(async (mid) => {
      await updateSettingsInnerArray("dynamicFeed.whenViewAll.hideIds", {
        remove: [mid]
      });
    });
    const {
      groups
    } = useSnapshot(dfStore);
    useMount(() => {
      dfStore.updateGroups();
    });
    const empty = !hideIds.length;
    if (empty) {
      return jsx$1("div", { className: "flex items-center justify-center", children: jsx$1(antd.Empty, {}) });
    }
    return jsx$1("div", { className: "max-h-250px flex flex-wrap gap-10px overflow-y-scroll", children: hideIds.map((tag) => {
      return jsx$1(TagItemDisplay, { tag, onDelete, renderTag: (t2) => jsx$1(DynamicFeedWhenViewAllHideIdTag, { tag: t2, followGroups: groups }) }, tag);
    }) });
  }
  function DynamicFeedWhenViewAllHideIdTag({
    tag,
    followGroups
  }) {
    let mid;
    let followGroupId;
    if (tag.startsWith(DF_SELECTED_KEY_PREFIX_UP)) {
      mid = tag.slice(DF_SELECTED_KEY_PREFIX_UP.length);
    } else if (tag.startsWith(DF_SELECTED_KEY_PREFIX_GROUP)) {
      followGroupId = tag.slice(DF_SELECTED_KEY_PREFIX_GROUP.length);
    } else ;
    const [upNickname, setUpNickname] = H.useState(void 0);
    useMount(async () => {
      if (!mid) return;
      const nickname = await getUserNickname(mid);
      if (nickname) setUpNickname(nickname);
    });
    const [followGroupName, setFollowGroupName] = H.useState(void 0);
    useMount(() => {
      if (!followGroupId) return;
      const groupName = followGroups?.find((g2) => g2.tagid.toString() === followGroupId)?.name;
      if (groupName) setFollowGroupName(groupName);
    });
    const label = H.useMemo(() => mid ? upNickname || mid : followGroupId ? followGroupName || followGroupId : "无效数据", [mid, upNickname, followGroupId, followGroupName]);
    const tooltip = H.useMemo(() => mid ? `mid: ${mid}` : followGroupId ? `分组: ${followGroupId}` : `Tag: ${tag}`, [mid, followGroupId, tag]);
    const icon = H.useMemo(() => mid ? jsx$1(IconForUp, { className: "mr-2px size-12px" }) : followGroupId ? jsx$1(IconForGroup, { className: "mr-2px size-16px" }) : void 0, [mid, followGroupId]);
    const href = H.useMemo(() => mid ? formatSpaceUrl(mid) : followGroupId ? formatFollowGroupUrl(followGroupId) : void 0, [mid, followGroupId]);
    return jsx$1(Fragment, { children: jsx$1(AntdTooltip, { title: tooltip, children: jsxs("span", { className: clsx("inline-flex items-center", mid ? "cursor-pointer" : "cursor-text"), children: [
      icon,
      href ? jsx$1("a", { href, target: "_blank", children: label }) : label
    ] }) }) });
  }
  function ThemesSelect() {
    const activeId = useCurrentTheme().id;
    const prevActiveId = usePrevious$1(activeId);
    const {
      colorPickerThemeSelectedColor
    } = useSettingsSnapshot();
    const [customColor, setCustomColor] = H.useState(colorPickerThemeSelectedColor || DEFAULT_BILI_PINK_THEME.colorPrimary);
    const customColorHex = H.useMemo(() => {
      return typeof customColor === "string" ? customColor : customColor.toHexString();
    }, [customColor]);
    useMount(() => {
      $evolvedThemeColor.updateThrottled();
    });
    return jsx$1("div", { children: ThemeGroups.map(({
      name,
      themes,
      tooltip
    }) => {
      return jsxs(H.Fragment, { children: [
jsxs("div", { className: "mt-2 flex items-center text-size-1.5em", children: [
          name,
jsx$1(HelpInfo, { className: "size-16px", useBlackBg: true, children: tooltip })
        ] }),
jsx$1("div", { className: "flex flex-wrap gap-x-5px gap-y-2px", children: themes.map((t2) => {
          const isActive = activeId === t2.id;
          const isCustom = t2.isCustom;
          const useAnimation = !!prevActiveId && prevActiveId !== t2.id;
          const innerSize = 28;
          const outerSize = innerSize + 8;
          let previewWrapper = jsx$1("div", { "data-role": "preview-wrapper", style: {
            width: outerSize
          }, className: clsx("mx-auto my-0 aspect-1 b-2px rounded-full b-solid", isActive ? "b-gate-primary" : "b-transparent", "flex items-center justify-center text-size-0"), children: jsx$1("div", { "data-role": "preview", className: "aspect-1 flex items-center justify-center rounded-full text-white", css: css("width:", innerSize, "px;background-color:", isCustom ? customColorHex : t2.colorPrimary, ";", ""), children: isActive && jsx$1(IconAnimatedChecked, { size: 18, useAnimation }) }) });
          if (t2.isCustom) {
            previewWrapper = jsx$1(
              antd.ColorPicker,
              {
                value: customColor,
                onChange: (c2) => setCustomColor(c2),
                onOpenChange: (open) => {
                  if (!open) {
                    updateSettings({
                      colorPickerThemeSelectedColor: customColorHex
                    });
                  }
                },
                children: previewWrapper
              }
            );
          }
          let el = jsxs("div", { className: "min-w-60px cursor-pointer text-center", onClick: (e2) => {
            updateSettings({
              theme: t2.id
            });
          }, children: [
            previewWrapper,
            t2.name
          ] });
          if (t2.tooltip || EXTRA_TOOLTIP[t2.id]) {
            el = jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
              t2.tooltip,
              EXTRA_TOOLTIP[t2.id]
            ] }), color: t2.colorPrimary, children: el });
          }
          el = jsx$1(H.Fragment, { children: el }, t2.id);
          return el;
        }) })
      ] }, name);
    }) });
  }
  function useHotkeyForConfig(hotkey, configPath, label) {
    return useKeyPress(hotkey, (e2) => {
      if (shouldDisableShortcut()) return;
      const current = Boolean(get(settings, configPath));
      const newValue = !current;
      set(settings, configPath, newValue);
      antMessage.success(`已${newValue ? "启用" : "禁用"}「${label}」`);
    }, {
      exactMatch: true
    });
  }
  const tab = "basic";
  const modalSettingsStore = proxy({
    tab
  });
  function ModalSettingsHotkey() {
    useHotkeyForConfig(["shift.p"], "autoPreviewWhenKeyboardSelect", "键盘选中后自动开始预览");
    useHotkeyForConfig(["shift.m"], "autoPreviewWhenHover", "鼠标悬浮后自动开始预览");
    useHotkeyForConfig(["shift.c"], "useNarrowMode", "居中模式");
    useHotkeyForConfigBorder();
    return null;
  }
  const customTabsCss = {
    name: "4k370z",
    styles: "&.ant-tabs{.ant-tabs-tab{justify-content:end;padding-inline:5px 15px;}.ant-tabs-nav-operations{display:none;}}"
  };
  function ModalSettings({
    show,
    onHide: onHide2
  }) {
    const {
      tab: tab2
    } = useSnapshot(modalSettingsStore);
    return jsxs(BaseModal, { show, onHide: onHide2, hideWhenMaskOnClick: true, hideWhenEsc: true, width: 900, clsModal: "max-h-unset", children: [
jsxs("div", { className: BaseModalClassNames.modalHeader, children: [
jsxs("div", { className: BaseModalClassNames.modalTitle, children: [
jsx$1(IconForConfig, { className: "mr-4px mt--2px size-26px" }),
          "设置"
        ] }),
jsx$1(ModalClose, { onClick: onHide2 })
      ] }),
jsx$1("main", { className: BaseModalClassNames.modalBody, style: {
        overflow: "hidden"
      }, children: jsx$1(antd.Tabs, { tabPosition: "left", size: "middle", css: customTabsCss, activeKey: tab2, onChange: (tab3) => modalSettingsStore.tab = tab3, items: [{
        label: "常规设置",
        key: "basic",
        children: jsx$1(TabPaneBasic, {})
      }, {
        label: "内容过滤",
        key: "filter",
        children: jsx$1(TabPaneFilter, {})
      }, {
        label: "主题选择",
        key: "theme-select",
        children: jsx$1("div", { className: sharedClassNames.tabPane, children: jsx$1(ThemesSelect, {}) })
      }, {
        label: "样式自定",
        key: "custom-ui",
        children: jsx$1(TabPaneCustomUI, {})
      }, {
        label: "Tab 设置",
        key: "video-source-tab-config",
        children: jsx$1(TabPaneRecTabsConfig, {})
      }, {
        label: "其他页面",
        key: "other-pages",
        children: jsx$1(TabPaneOtherPages, {})
      }, {
        label: "高级设置",
        key: "advance",
        children: jsx$1(TabPaneAdvance, {})
      }] }) })
    ] });
  }
  const iconParkOutlineRight = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "m19 12l12 12l-12 12" })
  ] });
  const ForwardRef$2 = H.forwardRef(iconParkOutlineRight);
  const CollapseBtn = H.forwardRef(function CollapseBtn2({
    children,
    initialOpen = false
  }, ref) {
    const [buttonsExpanded, buttonsExpandedActions] = useToggle(initialOpen);
    H.useImperativeHandle(ref, () => buttonsExpandedActions, [buttonsExpandedActions]);
    const btn = jsx$1(antd.Button, { onClick: buttonsExpandedActions.toggle, className: "icon-only-round-button", children: jsx$1(ForwardRef$2, { className: clsx("size-13px", buttonsExpanded ? "rotate-z-0" : "rotate-z-180deg") }) });
    return jsxs(Fragment, { children: [
      btn,
      buttonsExpanded && children
    ] });
  });
  const headerState = proxy({
    modalFeedVisible: false,
    modalSettingsVisible: false
  });
  function useHeaderState() {
    return useSnapshot(headerState);
  }
  function usePlainShortcutEnabled() {
    const {
      modalFeedVisible,
      modalSettingsVisible
    } = useHeaderState();
    return [modalFeedVisible, modalSettingsVisible, useModalDislikeVisible(), useModalMoveFavVisible()].every((x) => x === false);
  }
  const RefreshButton = H.forwardRef(function({
    onRefresh,
    className = "",
    style,
    refreshHotkeyEnabled,
    refreshing
  }, ref) {
    refreshHotkeyEnabled ??= true;
    const [deg, setDeg] = H.useState(0);
    const btn = H.useRef(null);
    const click = useMemoizedFn(() => {
      if (!btn.current) return;
      if (btn.current.disabled) return;
      btn.current.click();
    });
    H.useImperativeHandle(ref, () => ({
      click
    }), []);
    useKeyPress("r", () => {
      if (shouldDisableShortcut()) return;
      if (!refreshHotkeyEnabled) return;
      click();
    }, {
      exactMatch: true
    });
    const tab2 = useCurrentUsingTab();
    const {
      watchlaterItemsOrder,
      popularWeeklyUseShuffle
    } = useSettingsSnapshot();
    const {
      usingShuffle: favUsingShuffle
    } = useSnapshot(favStore);
    const text = tab2 === ETab.AppRecommend || tab2 === ETab.PcRecommend || tab2 === ETab.KeepFollowOnly || tab2 === ETab.Watchlater && watchlaterItemsOrder === WatchlaterItemsOrder.Shuffle || tab2 === ETab.Fav && favUsingShuffle || tab2 === ETab.Hot && isHotTabUsingShuffle(popularWeeklyUseShuffle) ? "换一换" : "刷新";
    const [scope, animate] = framerMotion.useAnimate();
    const onClick = useMemoizedFn((e2) => {
      animate(scope.current, {
        rotate: [0, 360]
      }, {
        duration: 0.5,
        type: "tween"
      });
      onRefresh?.();
    });
    return jsxs(antd.Button, { ref: btn, style, className: clsx("flex items-center gap-x-4px [&.ant-btn:not(:disabled):focus-visible]:outline-0", className), disabled: refreshing, onClick, children: [
jsx$1(IconForRoll, { ref: scope, className: "size-14px" }),
      text
    ] });
  });
  const ModalFeed = H.memo(function ModalFeed2({
    show,
    onHide: onHide2
  }) {
    const scrollerRef = H.useRef(null);
    const {
useNarrowMode,
modalFeedFullScreen
    } = useSettingsSnapshot();
    const useFullScreen = !useNarrowMode && modalFeedFullScreen;
    const modalBorderCls = H.useMemo(() => {
      const borderWidth = useFullScreen ? "b-5px" : "b-1px";
      return clsx(borderWidth, "b-gate-primary b-solid");
    }, [useFullScreen]);
    const onScrollToTop = useMemoizedFn(() => {
      if (scrollerRef.current) {
        scrollerRef.current.scrollTop = 0;
      }
    });
    const {
      modalSettingsVisible
    } = useHeaderState();
    const shortcutEnabled = [show, !modalSettingsVisible, !useModalDislikeVisible(), !useModalMoveFavVisible()].every((x) => x);
    const [headerState2, setHeaderState] = H.useState(initHeaderState);
    const renderHeader = () => {
      const {
        refreshing,
        onRefresh,
        extraInfo
      } = headerState2;
      return jsx$1(OnRefreshContext.Provider, { value: onRefresh, children: jsxs("div", { className: clsx(BaseModalClassNames.modalHeader, "gap-x-15px pr-15px"), children: [
jsxs("div", { className: "left flex flex-shrink-1 flex-wrap items-center gap-x-15px gap-y-4px", children: [
jsx$1(VideoSourceTab, { onRefresh }),
          extraInfo
        ] }),
jsxs("div", { className: "right flex flex-shrink-0 items-center gap-x-8px", children: [
          useNarrowMode ? null : jsx$1(CollapseBtn, { initialOpen: true, children: jsx$1(ModalFeedConfigChecks, {}) }),
jsx$1(RefreshButton, { refreshing, onRefresh, refreshHotkeyEnabled: shortcutEnabled }),
jsx$1(ModalClose, { onClick: onHide2, className: "ml-5px" })
        ] })
      ] }) });
    };
    const clsModalMask = clsx({
      ["bg-black/90%"]: useNarrowMode
    });
    const clsBase = "h-[calc(100vh-30px)] max-h-unset w-[calc(100vw-30px)] pr-0";
    const clsNarrow = "h-[calc(100vh-10px)] w-[calc(325*2+40px)]";
    const clsFullScreen = "h-full w-full";
    const clsModal = clsx(clsBase, {
      [clsNarrow]: useNarrowMode,
      [clsFullScreen]: useFullScreen
    }, modalBorderCls);
    return jsxs(BaseModal, { show, onHide: onHide2, clsModalMask, clsModal, children: [
      renderHeader(),
jsx$1("div", { className: clsx(BaseModalClassNames.modalBody, "pr-15px"), ref: scrollerRef, children: jsx$1(RecGrid, { shortcutEnabled, onScrollToTop, infiniteScrollUseWindow: false, scrollerRef, onSyncHeaderState: setHeaderState }) })
    ] });
  });
  function ModalFeedConfigChecks() {
    return jsxs(Fragment, { children: [
jsx$1(CheckboxSettingItem, { configPath: "showModalFeedOnLoad", label: "自动查看更多", tooltip: "打开首页时默认打开推荐弹窗", extraAction: (val) => {
        if (val) {
          antMessage.success("已开启自动查看更多: 下次打开首页时将直接展示推荐弹窗");
        }
      } }),
jsx$1(CheckboxSettingItem, { configPath: "modalFeedFullScreen", label: "全屏", tooltip: "世界清净了~" })
    ] });
  }
  function showModalFeed() {
    renderOnce();
    headerState.modalFeedVisible = true;
  }
  function hideModalFeed() {
    headerState.modalFeedVisible = false;
  }
  if (IN_BILIBILI_HOMEPAGE && settings.showModalFeedOnLoad) {
    setTimeout(showModalFeed);
  }
  function toggleModalSettings() {
    if (headerState.modalSettingsVisible) {
      hideModalSettings();
    } else {
      showModalSettings();
    }
  }
  function showModalSettings() {
    renderOnce();
    headerState.modalSettingsVisible = true;
  }
  function hideModalSettings() {
    headerState.modalSettingsVisible = false;
  }
  function registerSettingsGmCommand() {
    GM.registerMenuCommand?.("⚙️ 设置", showModalSettings);
  }
  const renderOnce = once(function render2() {
    const container = document.createElement("div");
    container.classList.add("modals-container", APP_CLS_ROOT);
    document.body.appendChild(container);
    const r2 = clientExports.createRoot(container);
    r2.render( jsx$1(AppRoot, { children: jsx$1(ModalsContainer, {}) }));
  });
  function ModalsContainer() {
    const {
      modalFeedVisible,
      modalSettingsVisible
    } = useHeaderState();
    return jsxs(Fragment, { children: [
jsx$1(ModalFeed, { show: modalFeedVisible, onHide: hideModalFeed }),
jsx$1(ModalSettings, { show: modalSettingsVisible, onHide: hideModalSettings })
    ] });
  }
  const tablerLayoutGrid = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 5a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1zm10 0a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1zM4 15a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1zm10 0a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1z" })
  ] });
  const ForwardRef$1 = H.forwardRef(tablerLayoutGrid);
  const tablerListDetails = ({
    title,
    titleId,
    ...props
  }, ref) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M13 5h8m-8 4h5m-5 6h8m-8 4h5M3 5a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1zm0 10a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1z" })
  ] });
  const ForwardRef = H.forwardRef(tablerListDetails);
  const debug$2 = baseDebug.extend("RecHeader");
  const RecHeader = H.forwardRef(function RecHeader2({
    onRefresh,
    refreshing,
    leftSlot,
    rightSlot,
    shortcutEnabled
  }, ref) {
    const {
      accessKey,
      pureRecommend,
      showModalFeedEntry,
      style,
      multiSelect: {
        showIcon: multiSelectShowIcon
      },
      __internalShowGridListSwitcher
    } = useSettingsSnapshot();
    const {
      cardDisplay,
      useStickyTabbar,
      stickyTabbarShadow
    } = style.pureRecommend;
    useKeyPress(["shift.comma"], (e2) => {
      if (shouldDisableShortcut()) return;
      toggleModalSettings();
    }, {
      exactMatch: true,
      useCapture: true
    });
    const [stickyRef, sticky] = useSticky();
    const scrollToTop = useMemoizedFn(() => {
      if (!pureRecommend) return;
      const container = stickyRef.current?.parentElement;
      if (!container) return;
      const rect = container.getBoundingClientRect();
      const headerHeight2 = $headerHeight.get();
      if (rect.top < headerHeight2) {
        const yOffset = getElementOffset(container).top;
        debug$2("[refresh:scroll] rect.top = %s, headerHeight = %s", rect.top, headerHeight2);
        document.documentElement.scrollTop = yOffset - headerHeight2 + 2;
      }
    });
    H.useImperativeHandle(ref, () => ({
      scrollToTop
    }));
    const headerHeight = $headerHeight.use();
    const showAccessKeyManage = useShouldShowAccessKeyManage();
    const usingEvolevdHeader = $usingEvolevdHeader.use();
    const dark = useIsDarkMode();
    const boxShadowCss = (() => {
      let val;
      if (usingEvolevdHeader) {
        val = dark ? "rgba(0, 0, 0, 26%) 0px 2px 10px 1px" : "rgba(0, 0, 0, 13%) 0 1px 10px 1px;";
      } else {
        val = `0 2px 4px ${dark ? "rgb(255 255 255 / 5%)" : "rgb(0 0 0 / 8%)"}`;
      }
      return css("box-shadow:", val, ";", "");
    })();
    const expandToFullWidthCss = useExpandToFullWidthCss();
    const toggleCardDisplay = useMemoizedFn(() => {
      const list2 = [ECardDisplay.Grid, ECardDisplay.List];
      const index = list2.indexOf(settings.style.pureRecommend.cardDisplay);
      const nextIndex = (index + 1) % list2.length;
      settings.style.pureRecommend.cardDisplay = list2[nextIndex];
    });
    const _className = n(pureRecommend && useStickyTabbar && "sticky z-gate-rec-header mb-10px b-b-1px b-b-transparent b-b-solid", pureRecommend && useStickyTabbar && sticky && "b-b-gate-bg-lv1 bg-$bg1_float", sticky && "sticky-state-on");
    const _css = H.useMemo(() => {
      if (!(pureRecommend && useStickyTabbar)) return;
      const topCss = css("top:", headerHeight - 1, "px;", "");
      const styles = [topCss];
      if (stickyTabbarShadow && sticky) styles.push(boxShadowCss, expandToFullWidthCss);
      return styles;
    }, [pureRecommend, useStickyTabbar, stickyTabbarShadow, sticky, headerHeight, boxShadowCss, expandToFullWidthCss]);
    return jsx$1(OnRefreshContext.Provider, { value: onRefresh, children: jsx$1("div", { ref: stickyRef, "data-role": "tab-bar-wrapper", className: _className, css: _css, children: jsxs("div", { "data-role": "tab-bar", className: `${APP_CLS_TAB_BAR} relative mb-0 h-auto flex flex-row items-center justify-between gap-x-15px px-0 py-8px`, children: [
jsxs("div", { "data-class-name": "left", className: "h-full flex flex-shrink-1 flex-wrap items-center gap-x-15px gap-y-8px", children: [
jsx$1(VideoSourceTab, { onRefresh }),
        leftSlot
      ] }),
jsxs("div", { "data-class-name": "right", className: "h-full flex flex-shrink-0 items-center gap-x-8px", children: [
        rightSlot,
        !accessKey && showAccessKeyManage && jsx$1(AccessKeyManage, { style: {
          marginLeft: 5
        } }),
        __internalShowGridListSwitcher && jsx$1(AntdTooltip, { title: "切换卡片显示模式", arrow: false, children: jsx$1(antd.Button, { className: "icon-only-round-button", onClick: toggleCardDisplay, children: cardDisplay === ECardDisplay.Grid ? jsx$1(ForwardRef$1, { className: "size-14px cursor-pointer" }) : jsx$1(ForwardRef, { className: "size-14px cursor-pointer" }) }) }),
        multiSelectShowIcon && jsx$1(MultiSelectButton, { iconOnly: true, addCopyActions: true }),
jsx$1(AntdTooltip, { title: "设置", arrow: false, children: jsxs(antd.Button, { onClick: showModalSettings, className: "icon-only-round-button", children: [
jsx$1(ModalSettingsHotkey, {}),
jsx$1(IconForConfig, { className: "size-14px" })
        ] }) }),
jsx$1(RefreshButton, { refreshing, onRefresh, refreshHotkeyEnabled: shortcutEnabled }),
        showModalFeedEntry && jsxs(antd.Button, { onClick: showModalFeed, className: "gap-0", children: [
jsx$1("span", { className: "relative top-1px", children: "查看更多" }),
jsx$1(ForwardRef$2, {})
        ] })
      ] })
    ] }) }) });
  });
  function useExpandToFullWidthCss() {
    const {
      xScrolling,
      bodyWidth
    } = useSizeExpression(document.body, (entry) => {
      const width = entry.contentRect.width;
      const xScrolling2 = !!(width && Math.round(width) > Math.round(window.innerWidth));
      if (!xScrolling2) {
        return {
          xScrolling: xScrolling2
        };
      } else {
        return {
          xScrolling: xScrolling2,
          bodyWidth: width
        };
      }
    }, () => ({
      xScrolling: false
    }));
    return H.useMemo(() => {
      if (!xScrolling) {
        const scrollbarWidth = isMac || isSafari ? "0px" : "20px";
        return css("margin-inline:calc((100% - 100vw + ", scrollbarWidth, ") / 2);padding-inline:calc((100vw - ", scrollbarWidth, " - 100%) / 2);", "");
      } else {
        const w = Math.floor(bodyWidth);
        return css("margin-inline:calc((100% - ", w, "px) / 2);padding-inline:calc((", w, "px - 100%) / 2);", "");
      }
    }, [xScrolling, bodyWidth]);
  }
  function useShouldShowAccessKeyManage() {
    const tab2 = useCurrentUsingTab();
    return tab2 === ETab.AppRecommend;
  }
  const narrowStyle = {
    grid: css("width:", 360 * 2 + 20, "px;margin:0 auto;", "")
  };
  function PureRecommend() {
    const {
      useNarrowMode
    } = useSettingsSnapshot();
    const shortcutEnabled = usePlainShortcutEnabled();
    const [headerState2, setHeaderState] = H.useState(initHeaderState);
    const recHeaderRef = H.useRef(null);
    const onScrollToTop = useMemoizedFn(() => {
      recHeaderRef.current?.scrollToTop();
    });
    return jsxs(Fragment, { children: [
jsx$1(RecHeader, { ref: recHeaderRef, refreshing: headerState2.refreshing, onRefresh: headerState2.onRefresh, leftSlot: headerState2.extraInfo, shortcutEnabled }),
jsx$1(RecGrid, { css: [useNarrowMode && narrowStyle.grid, "", ""], shortcutEnabled, infiniteScrollUseWindow: true, onScrollToTop, onSyncHeaderState: setHeaderState })
    ] });
  }
  const debug$1 = baseDebug.extend("components:SectionRecommend");
  function SectionRecommend() {
    const tab2 = H.useDeferredValue(useCurrentUsingTab());
    const servicesRegistry = useRefStateBox(() => ({}));
    return jsx$1(TabContent, { tab: tab2, servicesRegistry }, tab2);
  }
  const TabContent = H.memo(function TabContent2({
    tab: tab2,
    servicesRegistry
  }) {
    const skeletonPlaceholders = H.useMemo(() => range(20).map(() => crypto.randomUUID()), []);
    const {
      refreshingBox,
      itemsBox,
      refresh,
      error: refreshError,
      showSkeleton
    } = useRefresh({
      tab: tab2,
      debug: debug$1,
      fetcher: refreshForHome,
      servicesRegistry
    });
    const refreshing = refreshingBox.state;
    const items = itemsBox.state;
    const displaySkeleton = !items.length || refreshError || refreshing && showSkeleton;
    const cardBorderCss = useCardBorderCss();
    const shortcutEnabled = usePlainShortcutEnabled();
    return jsxs("section", { "data-area": "推荐", children: [
jsx$1(RecHeader, { refreshing, onRefresh: refresh, shortcutEnabled }),
jsx$1("div", { className: clsx(videoGrid, limitTwoLines, videoGridBiliFeed4), style: {
        marginBottom: 30
      }, children: displaySkeleton ? skeletonPlaceholders.map((id) => jsx$1(VideoCard, { tab: tab2 }, id)) : items.map((item) => {
        return item.api === EApiType.Separator ? null : jsx$1(VideoCard, { item, tab: tab2, baseCss: cardBorderCss }, item.uniqId);
      }) })
    ] });
  });
  const isHashEntry = location.hash.startsWith(`#/${APP_NAMESPACE}/`);
  const bewlyEnabledSelector = "html.bewly-design:not(:has(#i_cecream))";
  function hasBewlyBewly() {
    return !isHashEntry && !!document.querySelector(bewlyEnabledSelector);
  }
  function tryDetectBewlyBewly() {
    return tryAction(bewlyEnabledSelector, () => {
      appWarn(`unmount for using bewly-design`);
      root?.unmount();
    }, {
      pollTimeout: 5e3,
      warnOnTimeout: false
    });
  }
  let root;
  async function initHomepage() {
    tryToRemove(".adblock-tips");
    tryAction("html.gray", (el) => el.classList.remove("gray"));
    tryToRemove(".vip-login-tip");
    registerSettingsGmCommand();
    if (hasBewlyBewly()) {
      return appWarn(`quit for using bewly-design`);
    }
    if (settings.pureRecommend) {
      await initHomepagePureRecommend();
    } else {
      await initHomepageSection();
    }
    tryDetectBewlyBewly();
  }
  async function initHomepageSection() {
    const layoutEl = await poll$1(() => document.querySelector(".bili-feed4-layout"));
    if (!layoutEl) {
      appWarn(`init fail, can not find .bili-feed4-layout`);
      return;
    }
    const container = document.createElement("section");
    container.classList.add(APP_CLS_ROOT);
    layoutEl.insertAdjacentElement("afterbegin", container);
    root = clientExports.createRoot(container);
    root.render( jsx$1(AppRoot, { injectGlobalStyle: true, antdSetup: true, children: jsx$1(SectionRecommend, {}) }));
    tryToRemove(".bili-feed4 .header-channel");
  }
  async function initHomepagePureRecommend() {
    if (isSafari) await delay(500);
    tryToRemove("#i_cecream .bili-feed4-layout");
    tryToRemove(".bili-feed4 .header-channel");
    tryToRemove(".palette-button-wrap");
    const biliLayout = document.createElement("div");
    biliLayout.classList.add("bili-feed4-layout", "pure-recommend");
    await poll$1(() => document.querySelector("body #i_cecream"), {
      interval: 20
    });
    document.body.appendChild(biliLayout);
    const container = document.createElement("section");
    container.classList.add(APP_CLS_ROOT);
    biliLayout.appendChild(container);
    root = clientExports.createRoot(container);
    root.render( jsxs(AppRoot, { injectGlobalStyle: true, antdSetup: true, children: [
jsx$1(PureRecommend, {}),
jsx$1(antd.FloatButton.BackTop, { style: {
insetInlineEnd: "var(--back-top-right, 24px)"
      } })
    ] }));
  }
  function setupForNoneHomepage() {
    setupAppRootForNoneHomepage();
    registerSettingsGmCommand();
  }
  const _setupOnce = once(() => {
    const container = document.createElement("div");
    document.body.appendChild(container);
    const root2 = clientExports.createRoot(container);
    root2.render( jsx$1(AppRoot, { injectGlobalStyle: true, antdSetup: true }));
  });
  function setupAppRootForNoneHomepage() {
    _setupOnce();
  }
  function isInIframe() {
    try {
      return window.self !== window.top;
    } catch {
      return true;
    }
  }
  function initSearchPage() {
    if (isInIframe()) return;
    setupForNoneHomepage();
    if (settings.videoCard.videoPreview.addTo.searchPage) {
      addLargePreviewForSearchResults();
    }
  }
  function addLargePreviewForSearchResults() {
    const run = limitFunction(() => {
      const itemsSelector = ".video-list-item:has(> .bili-video-card),div:has(> .bili-video-card)";
      const list2 = Array.from(document.querySelectorAll(itemsSelector));
      for (const el of list2) addLargePreview(el);
    }, 1);
    run();
    const ob2 = new MutationObserver(() => run());
    ob2.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  const processed = new WeakSet();
  const processedAttr = `${APP_NAMESPACE}-add-large-preview-processed`;
  function addLargePreview(el) {
    if (processed.has(el)) return;
    if (el.getAttribute(processedAttr)) return;
    const prevEl = el.querySelector(".bili-watch-later--wrap");
    if (!prevEl) return;
    const container = document.createElement("div");
    prevEl.insertAdjacentElement("afterend", container);
    processed.add(el);
    el.setAttribute(processedAttr, "true");
    const root2 = clientExports.createRoot(container);
    root2.render( jsx$1(AppRoot, { children: jsx$1(LargePreviewSetup, { el }) }));
  }
  function LargePreviewSetup({
    el
  }) {
    const {
      bvid = "",
      cover
    } = H.useMemo(() => parseCardInfo(el), [el]);
    const cardEl = H.useMemo(() => el.querySelector(".bili-video-card") ?? el, [el]);
    const coverEl = H.useMemo(() => cardEl.querySelector(".bili-video-card__wrap > a"), [el]);
    const hovering = useHover(cardEl);
    const videoCardAsTriggerRef = H.useRef(coverEl);
    const {
      largePreviewActionButtonEl,
      largePreviewEl
    } = useLargePreviewRelated({
      shouldFetchPreviewData: !!bvid,
      hasLargePreviewActionButton: true,
      actionButtonVisible: hovering,
      actionButtonProps: {
        useMotion: true,
        motionProps: {
          initial: {
            opacity: 0
          },
          animate: {
            opacity: 1
          },
          exit: {
            opacity: 0,
            transition: {
              delay: 0
            }
          },
          transition: {
            duration: 0.2,
            ease: "linear",
            delay: 0.2
          }
        }
      },
bvid,
      cid: void 0,
      uniqId: bvid,
      sharedEmitter: defaultSharedEmitter,
cover,
      videoCardAsTriggerRef
    });
    return jsxs(Fragment, { children: [
jsx$1("div", { className: n(C.top("right"), "right-[calc(8px+28px+5px)]"), children: largePreviewActionButtonEl }),
      require$$0.createPortal(largePreviewEl, cardEl)
    ] });
  }
  function parseCardInfo(el) {
    let bvid;
    {
      const link = el.querySelector(".bili-video-card__wrap > a")?.href;
      if (link) {
        bvid = /^\/video\/(?<bvid>BV\w+)\//i.exec(new URL(link).pathname)?.groups?.bvid;
      }
    }
    const cover = el.querySelector("picture.v-img.bili-video-card__cover img")?.currentSrc;
    return {
      bvid,
      cover
    };
  }
  function initSpacePage() {
    setupForNoneHomepage();
    addDynEntry();
  }
  const rootElId = `${APP_NAMESPACE}-${crypto.randomUUID()}`;
  async function addDynEntry() {
    if (!state.mid) return;
    const oldSelector = ".h-action";
    const newSelector = ".upinfo .operations";
    await tryAction([oldSelector, newSelector].join(","), (container) => {
      state.href = location.href;
      state.usingNewSpacePage = container.matches(newSelector);
      getFollowedStatus();
      const rootEl = document.createElement("span");
      rootEl.id = rootElId;
      rootEl.classList.add("mr-24px");
      container.insertAdjacentElement("afterbegin", rootEl);
      const root2 = clientExports.createRoot(rootEl);
      root2.render( jsx$1(AppRoot, { injectGlobalStyle: true, children: jsx$1(ActionButtons, {}) }));
    }, {
      pollTimeout: 1e4,
      pollInterval: 1e3
    });
  }
  const state = proxy({
    href: location.href,
    usingNewSpacePage: false,
    followed: false,
    get mid() {
      return parseMid(this.href);
    },
    get collectionId() {
      const u2 = new URL(this.href);
      {
        const reg = /https:\/\/space.bilibili.com\/(?<mid>\d+)\/lists\/(?<collectionId>\d+)(?:\?type=season)?/;
        const match2 = this.href.match(reg);
        if (match2?.groups?.collectionId && (u2.searchParams.get("type") === "season" || !u2.searchParams.get("type"))) {
          return Number(match2?.groups?.collectionId);
        }
      }
      {
        const reg = /https:\/\/space.bilibili.com\/\d+\/channel\/collectiondetail\?/;
        if (reg.test(this.href)) {
          const u22 = new URL(this.href);
          const collectionId = u22.searchParams.get("sid")?.trim();
          if (collectionId) {
            return Number(collectionId);
          }
        }
      }
    },
    get isCollectionPage() {
      return typeof this.collectionId === "number";
    },
    get searchKeyword() {
      const reg = /https:\/\/space.bilibili.com\/\d+\/search/;
      if (!reg.test(this.href)) return void 0;
      const searchParams2 = new URLSearchParams(location.search);
      const keyword = searchParams2.get("keyword");
      return keyword ?? void 0;
    },
    get isSearching() {
      return !!this.searchKeyword?.trim();
    }
  });
  const getFollowedStatus = reusePendingPromise(async () => {
    const followed = await poll$1(() => {
      const list2 = Array.from(document.querySelectorAll(".space-follow-btn")).filter((el) => el.textContent?.trim() === "已关注");
      if (list2.length > 0) return true;
    }, {
      interval: 100,
      timeout: 5e3
    });
    state.followed = !!followed;
  });
  if (typeof window.navigation !== "undefined") {
    window.navigation.addEventListener?.("navigatesuccess", () => {
      state.href = location.href;
      getFollowedStatus();
    });
  }
  function ActionButtons() {
    const {
      mid,
      collectionId,
      followed,
      isSearching,
      searchKeyword
    } = useSnapshot(state);
    if (!mid) return;
    const btnClassName = "w-34px b-white/33% rounded-full hover:b-gate-primary hover:bg-gate-primary";
    let btnSpaceUpload;
    {
      let href = `https://www.bilibili.com/?${SpaceUploadQueryKey.Mid}=${mid}`;
      if (isSearching && searchKeyword) {
        href += `&${SpaceUploadQueryKey.SearchText}=${searchKeyword}`;
      }
      btnSpaceUpload = jsx$1(ActionButton, { className: btnClassName, href, tooltip: `在「${APP_NAME}」中查看 UP 的投稿`, children: jsx$1(IconForSpaceUpload, {}) }, "btnSpaceUpload");
    }
    let btnDynamicFeed;
    if (followed) {
      const href = `https://www.bilibili.com/?${DynamicFeedQueryKey.Mid}=${mid}`;
      btnDynamicFeed = jsx$1(ActionButton, { className: btnClassName, href, tooltip: `在「${APP_NAME}」中查看 UP 的动态`, children: jsx$1(IconForDynamicFeed, {}) }, "btnDynamicFeed");
    }
    let btnViewCollection;
    if (typeof collectionId === "number") {
      btnViewCollection = jsx$1(ActionButton, { className: btnClassName, href: `https://www.bilibili.com/?${FavQueryKey.CollectionIdFull}=${collectionId}`, target: "_blank", tooltip: `在「${APP_NAME}」中查看合集`, children: jsx$1(IconForCollection, {}) }, "btnViewCollection");
    }
    return jsxs("span", { className: "inline-flex items-center gap-x-8px", children: [
      btnViewCollection,
      btnSpaceUpload,
      btnDynamicFeed
    ] });
  }
  function ActionButton({
    href,
    children,
    className,
    style,
    tooltip,
    ...restProps
  }) {
    const {
      usingNewSpacePage
    } = useSnapshot(state);
    const _className = n("h-34px w-150px flex cursor-pointer items-center justify-center b-1px b-white/20% rounded-6px b-solid bg-white/14% text-14px color-white font-700 transition-duration-300 transition-property-all hover:bg-white/40%", className);
    const btn = usingNewSpacePage ? jsx$1("a", { ...restProps, href, className: _className, style, children }) : jsx$1("a", { href, className: clsx("h-f-btn", className), style: {
      width: "auto",
      paddingInline: "15px",
      ...style
    }, ...restProps, children });
    if (tooltip) {
      return jsx$1(AntdTooltip, { title: tooltip, children: btn });
    } else {
      return btn;
    }
  }
  function parseMid(href = location.href) {
    const url = new URL(href);
    const mid = url.pathname.split("/").map((x) => x.trim()).find((x) => x);
    if (!mid || !/^\d+$/.test(mid)) return;
    return mid;
  }
  function getBiliPlayer() {
    if (typeof unsafeWindow === "undefined") return;
    return unsafeWindow.player;
  }
  const debug = baseDebug.extend("main:video-play-page");
  async function initVideoPlayPage() {
    setupForNoneHomepage();
    registerGmCommands();
    setupCustomFavPicker();
    await handleFullscreen();
    await handleForceAutoPlay();
  }
  function registerGmCommands() {
    registerOpenInPipCommand();
    registerOpenInIinaCommand();
    registerAddToFavCommand();
  }
  function registerOpenInPipCommand() {
    if (!hasDocumentPictureInPicture) return;
    GM.registerMenuCommand?.("🎦 小窗打开", () => {
      pausePlayingVideo();
      openInPipWindow();
    });
  }
  function registerOpenInIinaCommand() {
    if (!isMac) return;
    GM.registerMenuCommand?.("▶️ IINA 打开", () => {
      pausePlayingVideo();
      openInIina();
    });
  }
  async function handleFullscreen() {
    const targetMode = new URL(location.href).searchParams.get(QueryKey.PlayerScreenMode);
    const next2 = targetMode === PlayerScreenMode.WebFullscreen || targetMode === PlayerScreenMode.Fullscreen;
    if (!next2) return;
    let action2;
    if (targetMode === PlayerScreenMode.WebFullscreen) {
      action2 = () => document.querySelector('[role="button"][aria-label="网页全屏"]')?.click();
    }
    if (targetMode === PlayerScreenMode.Fullscreen) {
      action2 = () => document.querySelector('[role="button"][aria-label="全屏"]')?.click();
    }
    const getCurrentMode = () => document.querySelector("#bilibili-player .bpx-player-container")?.dataset.screen || PlayerScreenMode.Normal;
    const timeoutAt = Date.now() + ms("30s");
    while (getCurrentMode() !== targetMode && Date.now() <= timeoutAt) {
      debug("current mode: %s", getCurrentMode());
      action2?.();
      await delay(100);
    }
    debug("handleFullscreen to %s complete", targetMode);
  }
  async function handleForceAutoPlay() {
    if (getBiliPlayerConfigAutoPlay()) return;
    const isON = new URL(location.href).searchParams.get(QueryKey.ForceAutoPlay) === ForceAutoPlay.ON;
    if (!isON) return;
    const playing = () => {
      const player = getBiliPlayer();
      return !!player && !player.isPaused();
    };
    const timeoutAt = Date.now() + ms("30s");
    while (Date.now() <= timeoutAt && !playing()) {
      getBiliPlayer()?.play();
      await delay(1e3);
    }
    debug("handleForceAutoPlay complete, playing = %s", playing());
  }
  function pausePlayingVideo() {
    const player = getBiliPlayer();
    if (player && !player.isPaused()) {
      player.pause();
    }
  }
  function openInPipWindow() {
    const u2 = new URL(location.href);
    u2.searchParams.set(QueryKey.PlayerScreenMode, PlayerScreenMode.WebFullscreen);
    const newHref = u2.href;
    openInPipOrPopup(newHref, "");
  }
  function openInIina() {
    const iinaUrl = `iina://open?url=${encodeURIComponent(location.href)}`;
    window.open(iinaUrl, "_self");
  }
  function registerAddToFavCommand() {
    GM.registerMenuCommand?.("⭐️ 加入收藏", addToFav);
  }
  async function setupCustomFavPicker() {
    if (!settings.fav.useCustomFavPicker.onPlayPage) return;
    if (!getCurrentPageBvid()) return;
    document.addEventListener("keydown", (e2) => {
      if (e2.key !== "e") return;
      if (shouldDisableShortcut()) return;
      if (isTypingInComments(e2.target)) return;
      e2.stopImmediatePropagation();
      e2.preventDefault();
      addToFav();
    }, {
      capture: true
    });
    const el = await poll$1(() => document.querySelector(".video-fav.video-toolbar-left-item"), {
      interval: 100,
      timeout: 5e3
    });
    el?.addEventListener("click", (e2) => {
      e2.stopImmediatePropagation();
      e2.preventDefault();
      addToFav();
    }, {
      capture: true
    });
  }
  async function addToFav() {
    const bvid = getCurrentPageBvid();
    if (!bvid) return antMessage.error("无法解析视频 BVID !");
    const avid = BvCode.bv2av(bvid);
    await pickFavFolder(void 0, async (targetFolder) => {
      const success = await UserFavService.addFav(avid, targetFolder.id);
      if (success) antMessage.success(`已加入收藏夹「${targetFolder.title}」`);
      return success;
    });
  }
  function isTypingInComments(el) {
    if (el.tagName.toLowerCase() !== "bili-comments") return false;
    const activeEditor = shadowRootQuery(el, ["bili-comments-header-renderer", "bili-comment-box", "#editor.active"]);
    return !!activeEditor;
  }
  function shadowRootQuery(root2, selectors) {
    let result = root2;
    for (const selector of selectors) {
      result = result.shadowRoot?.querySelector(selector) ?? void 0;
      if (!result) return;
    }
    return result;
  }
  dayjs.extend(duration);
  void function main() {
    if (IN_BILIBILI_HOMEPAGE) return initHomepage();
    if (IN_BILIBILI_VIDEO_PLAY_PAGE) return initVideoPlayPage();
    if (IN_BILIBILI_SPACE_PAGE) return initSpacePage();
    if (IN_BILIBILI_SEARCH_PAGE) return initSearchPage();
  }();

})(React, antd, UAParser, axios, SparkMD5, dayjs, dayjs_plugin_duration, ReactDOM, antdCssinjs, Motion, PinyinMatch, localforage);
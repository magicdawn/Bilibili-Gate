// ==UserScript==
// @name         Bilibili-Gate
// @namespace    https://magicdawn.fun
// @version      0.34.13
// @author       magicdawn
// @description  Bilibili 自定义首页
// @license      MIT
// @icon         https://www.bilibili.com/favicon.ico
// @homepageURL  https://greasyfork.org/zh-CN/scripts/443530-bilibili-gate
// @supportURL   https://github.com/magicdawn/Bilibili-Gate/issues
// @downloadURL  https://raw.githubusercontent.com/magicdawn/Bilibili-Gate/refs/heads/release/bilibili-gate.user.js
// @updateURL    https://raw.githubusercontent.com/magicdawn/Bilibili-Gate/refs/heads/release/bilibili-gate.meta.js
// @match        https://www.bilibili.com/
// @match        https://www.bilibili.com/?*
// @match        https://www.bilibili.com/index.html
// @match        https://www.bilibili.com/index.html?*
// @match        https://www.bilibili.com/video/*
// @match        https://www.bilibili.com/list/watchlater?*
// @match        https://www.bilibili.com/bangumi/play/*
// @match        https://space.bilibili.com/*
// @match        https://search.bilibili.com/*
// @require      https://registry.npmmirror.com/axios/0.30.2/files/dist/axios.min.js
// @require      https://registry.npmmirror.com/ua-parser-js/1.0.41/files/dist/ua-parser.min.js
// @require      https://registry.npmmirror.com/localforage/1.10.0/files/dist/localforage.min.js
// @require      https://registry.npmmirror.com/pinyin-match/1.2.10/files/dist/main.js
// @require      https://registry.npmmirror.com/spark-md5/3.0.2/files/spark-md5.min.js
// @tag          bilibili
// @connect      app.bilibili.com
// @grant        GM.deleteValue
// @grant        GM.getValue
// @grant        GM.listValues
// @grant        GM.openInTab
// @grant        GM.registerMenuCommand
// @grant        GM.setClipboard
// @grant        GM.setValue
// @grant        GM.xmlHttpRequest
// @grant        GM_addStyle
// @grant        GM_addValueChangeListener
// @grant        GM_download
// @grant        GM_info
// @grant        unsafeWindow
// @run-at       document-body
// ==/UserScript==

(async function (UAParser, axios, sparkMd5, localforage, PinyinMatch) {
  'use strict';

  const d$2=new Set;const importCSS = async e=>{d$2.has(e)||(d$2.add(e),(t=>{typeof GM_addStyle=="function"?GM_addStyle(t):(document.head||document.documentElement).appendChild(document.createElement("style")).append(t);})(e));};

  importCSS(` ._cls--gate-video-grid--divider_h4766_1 .ant-divider-inner-text {
  display: inline-flex;
  align-items: center;
  min-height: 30px;
}
._cls--gate-video-grid--divider_h4766_1 .ant-divider-inner-text a {
  color: var(--ant-color-link);
}
._cls--gate-video-grid--divider_h4766_1 .ant-divider-inner-text a:hover {
  color: var(--ant-color-primary);
}

._cls--gate-video-card--context-menu--root_h4766_13 .ant-dropdown-menu {
  --ant-dropdown-padding-block: 3px;
}
._cls--gate-video-card--context-menu--root_h4766_13 .ant-dropdown-menu:has(:nth-child(12)) {
  --ant-dropdown-padding-block: 2px;
}._video-grid_ucv12_1 {
  display: grid;
  position: relative;
  width: 100%;
  grid-gap: 20px 12px;
  --bilibili-gate--video-card--border-radius: 15px;
}

._grid-template-columns-using-var-col_ucv12_9 {
  --col: 4;
  grid-template-columns: repeat(var(--col), minmax(0, 1fr));
}

._grid-template-columns-using-card-min-width_ucv12_14 {
  --card-min-width: 330px;
  grid-template-columns: repeat(auto-fill, minmax(var(--card-min-width), 1fr));
}

._video-grid-addon-center-empty_ucv12_19::before {
  content: "";
  grid-column: 3/-3;
  grid-row: 1/span 9999;
  grid-auto-flow: dense;
}

._video-grid-bili-feed4_ucv12_26 {
  grid-gap: 20px 20px;
}
@media (max-width: 1399px) {
  ._video-grid-bili-feed4_ucv12_26 {
    --col: 4;
  }
}
@media (min-width: 1400px) {
  ._video-grid-bili-feed4_ucv12_26 {
    --col: 5;
  }
}
._video-grid-bili-feed4_ucv12_26 .ant-divider-horizontal.ant-divider-with-text {
  margin-bottom: -15px;
  margin-top: -15px;
}
._video-grid-bili-feed4_ucv12_26 .ant-divider-horizontal.ant-divider-with-text:first-of-type {
  margin-top: 0;
}

._video-grid-custom_ucv12_47 {
  --row-gap: clamp(20px, 1.4vw, 40px);
  column-gap: clamp(15px, 1.1cqw, 20px);
  row-gap: 0;
}
._video-grid-custom_ucv12_47 .bili-video-card {
  margin-bottom: var(--row-gap);
}
._video-grid-custom_ucv12_47 .ant-divider-horizontal.ant-divider-with-text {
  margin-top: calc(10px - var(--row-gap));
  margin-bottom: 5px;
}
._video-grid-custom_ucv12_47 .ant-divider-horizontal.ant-divider-with-text:first-of-type {
  margin-top: 0;
}

._narrow-mode_ucv12_63 {
  --col: 2 !important;
}*,::before,::after{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}::backdrop{--un-rotate:0;--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-scale-x:1;--un-scale-y:1;--un-scale-z:1;--un-skew-x:0;--un-skew-y:0;--un-translate-x:0;--un-translate-y:0;--un-translate-z:0;--un-ring-offset-shadow:0 0 rgb(0 0 0 / 0);--un-ring-shadow:0 0 rgb(0 0 0 / 0);--un-shadow-inset: ;--un-shadow:0 0 rgb(0 0 0 / 0);--un-ring-inset: ;--un-ring-offset-width:0px;--un-ring-offset-color:#fff;--un-ring-width:0px;--un-ring-color:rgb(147 197 253 / 0.5);--un-blur: ;--un-brightness: ;--un-contrast: ;--un-drop-shadow: ;--un-grayscale: ;--un-hue-rotate: ;--un-invert: ;--un-saturate: ;--un-sepia: ;--un-backdrop-blur: ;--un-backdrop-brightness: ;--un-backdrop-contrast: ;--un-backdrop-grayscale: ;--un-backdrop-hue-rotate: ;--un-backdrop-invert: ;--un-backdrop-opacity: ;--un-backdrop-saturate: ;--un-backdrop-sepia: ;}.icon-only-round-button{width:32px;height:32px;display:flex;align-items:center;justify-content:center;border-radius:50%;padding:0;}.inline-icon-only-round-button{width:32px;height:32px;display:inline-flex;align-items:center;justify-content:center;border-radius:50%;padding:0;}.flex-center{display:flex;align-items:center;justify-content:center;}.flex-v-center{display:flex;align-items:center;}.inline-flex-center{display:inline-flex;align-items:center;justify-content:center;}.\\[refresh\\:scroll\\]{refresh:scroll;}.pointer-events-auto{pointer-events:auto;}.\\[\\&_svg\\]\\:pointer-events-none svg,.pointer-events-none{pointer-events:none;}.visible{visibility:visible;}.invisible{visibility:hidden;}.absolute{position:absolute;}.fixed{position:fixed;}.position-relative,.relative{position:relative;}.sticky{position:sticky;}.static{position:static;}.inset-0{inset:0;}.inset-x-0{left:0;right:0;}.bottom--6px{bottom:-6px;}.bottom-0{bottom:0;}.left--2px{left:-2px;}.left--30px{left:-30px;}.left-0{left:0;}.left-2,.left-8px{left:8px;}.left-50\\%{left:50%;}.right--30px{right:-30px;}.right-\\[calc\\(8px\\+28px\\+5px\\)\\]{right:calc(8px + 28px + 5px);}.right-0{right:0;}.right-10px{right:10px;}.right-8px{right:8px;}.top-\\[-0\\.5px\\]{top:-0.5px;}.top-\\[-1px\\]{top:-1px;}.top-0{top:0;}.top-0\\.5px{top:0.5px;}.top-10px{top:10px;}.top-4px{top:4px;}.top-50\\%{top:50%;}.top-8px{top:8px;}.hover\\:left-0:hover{left:0;}.hover\\:right-0:hover{right:0;}.line-clamp-2{overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:2;line-clamp:2;}.line-clamp-3{overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:3;line-clamp:3;}.isolate{isolation:isolate;}.z-10000{z-index:10000;}.z-10004{z-index:10004;}.z-10005{z-index:10005;}.z-1001{z-index:1001;}.z-11000{z-index:11000;}.z-11200{z-index:11200;}.z-11300{z-index:11300;}.z-2{z-index:2;}.z-3{z-index:3;}.z-4{z-index:4;}.z-5{z-index:5;}.z-6{z-index:6;}.z-90000{z-index:90000;}.z-9999{z-index:9999;}.grid{display:grid;}.col-span-full,.grid-col-span-full{grid-column:1/-1;}.grid-cols-\\[250px_1fr\\]{grid-template-columns:250px 1fr;}.grid-cols-\\[repeat\\(2\\,max-content\\)_1fr\\]{grid-template-columns:repeat(2,max-content) 1fr;}.grid-cols-\\[repeat\\(2\\,max-content\\)\\]{grid-template-columns:repeat(2,max-content);}.grid-cols-\\[repeat\\(auto-fill\\,minmax\\(225px\\,1fr\\)\\)\\]{grid-template-columns:repeat(auto-fill,minmax(225px,1fr));}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr));}.grid-cols-4{grid-template-columns:repeat(4,minmax(0,1fr));}.m10{margin:40px;}.m12{margin:48px;}.m13{margin:52px;}.m14{margin:56px;}.m15{margin:60px;}.m16{margin:64px;}.m16\\.52{margin:66.08px;}.m160{margin:640px;}.m19{margin:76px;}.m19\\.833{margin:79.332px;}.m239\\.82{margin:959.28px;}.m24{margin:96px;}.m27\\.952{margin:111.808px;}.m29\\.756{margin:119.024px;}.m3{margin:12px;}.m33{margin:132px;}.m434\\.8{margin:1739.2px;}.m5{margin:20px;}.m9{margin:36px;}.\\[\\&_\\[role\\=\\"separator\\"\\]\\]\\:mx-0 [role="separator"],.mx-0{margin-left:0;margin-right:0;}.\\[\\&_\\[role\\=\\"separator\\"\\]\\]\\:my-2px [role="separator"],.my-2px{margin-top:2px;margin-bottom:2px;}.\\[\\&\\.ant-divider-horizontal\\.ant-divider-with-text\\]\\:my-5px.ant-divider-horizontal.ant-divider-with-text,.my-5px{margin-top:5px;margin-bottom:5px;}.\\[\\&\\.ant-empty-normal\\]\\:my-1.ant-empty-normal,.my-1{margin-top:4px;margin-bottom:4px;}.mx-1,.mx-4px{margin-left:4px;margin-right:4px;}.mx-2px{margin-left:2px;margin-right:2px;}.mx-5px{margin-left:5px;margin-right:5px;}.mx-auto{margin-left:auto;margin-right:auto;}.my-0{margin-top:0;margin-bottom:0;}.my-7px{margin-top:7px;margin-bottom:7px;}.my-auto{margin-top:auto;margin-bottom:auto;}.\\[\\&_svg\\]\\:mr-5px svg,.mr-5px{margin-right:5px;}.\\[\\&_svg\\]\\:mt--1px svg,.mt--1px{margin-top:-1px;}.mb-0{margin-bottom:0;}.mb-10px{margin-bottom:10px;}.mb-20px{margin-bottom:20px;}.mb-2px{margin-bottom:2px;}.mb-40px{margin-bottom:40px;}.mb-5px{margin-bottom:5px;}.mb-8px{margin-bottom:8px;}.ml-0{margin-left:0;}.ml-1,.ml-4px{margin-left:4px;}.ml-1\\.5,.ml-6px{margin-left:6px;}.ml-10px{margin-left:10px;}.ml-12px,.ml-3{margin-left:12px;}.ml-15px{margin-left:15px;}.ml-1px{margin-left:1px;}.ml-20px,.ml-xl{margin-left:20px;}.ml-25px{margin-left:25px;}.ml-2px{margin-left:2px;}.ml-30px{margin-left:30px;}.ml-4{margin-left:16px;}.ml-5px{margin-left:5px;}.ml-8px{margin-left:8px;}.ml-auto{margin-left:auto;}.mr-0{margin-right:0;}.mr-0\\!{margin-right:0 !important;}.mr-1,.mr-4px{margin-right:4px;}.mr-10px{margin-right:10px;}.mr-24px{margin-right:24px;}.mr-2px{margin-right:2px;}.mr-auto{margin-right:auto;}.ms{margin-inline-start:16px;}.mt--2px{margin-top:-2px;}.mt-0{margin-top:0;}.mt-0\\.5em{margin-top:0.5em;}.mt-1,.mt-4px{margin-top:4px;}.mt-10px{margin-top:10px;}.mt-15px{margin-top:15px;}.mt-2,.mt-8px{margin-top:8px;}.mt-20px{margin-top:20px;}.mt-2px{margin-top:2px;}.mt-3px{margin-top:3px;}.mt-6px{margin-top:6px;}.first\\:ml-0:first-child{margin-left:0;}.first\\:mt-0:first-child{margin-top:0;}.first\\:mt-0px:first-child{margin-top:0;}.box-content{box-sizing:content-box;}.inline{display:inline;}.block{display:block;}.inline-block{display:inline-block;}.contents{display:contents;}.\\[\\&\\>\\.ant-checkbox-label\\]\\:hidden>.ant-checkbox-label,.hidden{display:none;}.aspect-1{aspect-ratio:1;}.aspect-16\\/9{aspect-ratio:16/9;}.aspect-ratio-10\\/16{aspect-ratio:10/16;}.\\[\\&_svg\\]\\:size-16px svg,.size-16px{width:16px;height:16px;}.ant-spin .ant-spin-dot.\\[\\.ant-spin_\\.ant-spin-dot\\&\\]\\:size-25px,.size-25px{width:25px;height:25px;}.size-1\\.1em{width:1.1em;height:1.1em;}.size-1\\.3em{width:1.3em;height:1.3em;}.size-12px{width:12px;height:12px;}.size-13px{width:13px;height:13px;}.size-14px{width:14px;height:14px;}.size-15px{width:15px;height:15px;}.size-17px{width:17px;height:17px;}.size-18px{width:18px;height:18px;}.size-1em{width:1em;height:1em;}.size-2\\.5{width:10px;height:10px;}.size-2\\.5em{width:2.5em;height:2.5em;}.size-20px{width:20px;height:20px;}.size-24px{width:24px;height:24px;}.size-26px{width:26px;height:26px;}.size-28px{width:28px;height:28px;}.size-30px{width:30px;height:30px;}.size-32px{width:32px;height:32px;}.size-40px{width:40px;height:40px;}.size-full{width:100%;height:100%;}.h-\\[calc\\(100vh-30px\\)\\]{height:calc(100vh - 30px);}.h-0{height:0;}.h-100\\%,.h-full{height:100%;}.h-100vh{height:100vh;}.h-14px{height:14px;}.h-16px{height:16px;}.h-19px{height:19px;}.h-22px{height:22px;}.h-24px{height:24px;}.h-2px{height:2px;}.h-34px{height:34px;}.h-35px{height:35px;}.h-3px{height:3px;}.h-auto{height:auto;}.h-fit{height:fit-content;}.max-h-\\[calc\\(90vh-50px\\)\\]{max-height:calc(90vh - 50px);}.max-h-\\[max\\(362px\\,calc\\(90vh-50px-56px-15px\\)\\)\\]{max-height:max(362px,calc(90vh - 50px - 56px - 15px));}.max-h-130px{max-height:130px;}.max-h-250px{max-height:250px;}.max-h-50vh{max-height:50vh;}.max-h-full{max-height:100%;}.max-h-unset{max-height:unset;}.max-w-\\[calc\\(100\\%-6px\\)\\]{max-width:calc(100% - 6px);}.max-w-130px{max-width:130px;}.max-w-250px{max-width:250px;}.max-w-288px{max-width:288px;}.max-w-300px{max-width:300px;}.max-w-350px{max-width:350px;}.max-w-450px{max-width:450px;}.min-h-100px{min-height:100px;}.min-h-100vh{min-height:100vh;}.min-h-25px{min-height:25px;}.min-h-362px{min-height:362px;}.min-h-40px{min-height:40px;}.min-w-130px{min-width:130px;}.min-w-180px{min-width:180px;}.min-w-200px{min-width:200px;}.min-w-24px{min-width:24px;}.min-w-300px{min-width:300px;}.min-w-32px{min-width:32px;}.min-w-60px{min-width:60px;}.min-w-95px{min-width:95px;}.w-\\[calc\\(100vw-30px\\)\\]{width:calc(100vw - 30px);}.w-\\[max-content\\],.w-max{width:max-content;}.w-0{width:0;}.w-100\\%,.w-full{width:100%;}.w-114px{width:114px;}.w-130px{width:130px;}.w-150px{width:150px;}.w-160px{width:160px;}.w-16px{width:16px;}.w-215px{width:215px;}.w-34px{width:34px;}.w-500px{width:500px;}.w-50px{width:50px;}.w-55px{width:55px;}.w-720px{width:720px;}.w-740px{width:740px;}.w-75px{width:75px;}.flex{display:flex;}.\\[\\&_\\.ant-checkbox-label\\]\\:inline-flex .ant-checkbox-label,.\\[\\&_\\.ant-radio-label\\]\\:inline-flex .ant-radio-label,.\\[\\&_\\.ant-radio-wrapper\\]\\:inline-flex .ant-radio-wrapper,.inline-flex{display:inline-flex;}.flex-1{flex:1 1 0%;}.flex-none{flex:none;}.flex-shrink-0{flex-shrink:0;}.flex-shrink-1{flex-shrink:1;}.flex-grow-1{flex-grow:1;}.flex-basis-100\\%{flex-basis:100%;}.flex-row{flex-direction:row;}.flex-row-reverse{flex-direction:row-reverse;}.flex-col{flex-direction:column;}.flex-wrap{flex-wrap:wrap;}.translate-x--50\\%{--un-translate-x:-50%;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.translate-y--50\\%{--un-translate-y:-50%;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.translate-y-100\\%{--un-translate-y:100%;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.rotate-0{--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-rotate:0deg;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.rotate-180{--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-rotate:180deg;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.hover\\:rotate-90:hover{--un-rotate-x:0;--un-rotate-y:0;--un-rotate-z:0;--un-rotate:90deg;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.rotate-z-0{--un-rotate:0;--un-rotate-z:0deg;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.rotate-z-180deg{--un-rotate:0;--un-rotate-z:180deg;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.hover\\:scale-105\\%:hover{--un-scale-x:1.05;--un-scale-y:1.05;transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}.transform{transform:translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z)) rotate(var(--un-rotate)) rotateX(var(--un-rotate-x)) rotateY(var(--un-rotate-y)) rotateZ(var(--un-rotate-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z));}@keyframes spin{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}.animate-spin{animation:spin 1s linear infinite;}.cursor-\\[edit\\]{cursor:edit;}.cursor-default{cursor:default;}.cursor-pointer{cursor:pointer;}.\\[\\&\\:disabled\\]\\:cursor-wait:disabled{cursor:wait;}.cursor-text{cursor:text;}.cursor-move{cursor:move;}.cursor-grab{cursor:grab;}.\\[\\&_\\.ant-checkbox-label\\]\\:select-none .ant-checkbox-label,.\\[\\&_svg\\]\\:select-none svg,.select-none{-webkit-user-select:none;user-select:none;}.resize{resize:both;}.list-circle{list-style-type:circle;}.list-disc{list-style-type:disc;}.content-start{align-content:flex-start;}.items-start{align-items:flex-start;}.\\[\\&_\\.ant-checkbox-label\\]\\:items-center .ant-checkbox-label,.\\[\\&_\\.ant-radio-label\\]\\:items-center .ant-radio-label,.\\[\\&_\\.ant-radio-wrapper\\]\\:items-center .ant-radio-wrapper,.items-center{align-items:center;}.self-start{align-self:flex-start;}.justify-start{justify-content:flex-start;}.justify-end{justify-content:flex-end;}.justify-center{justify-content:center;}.justify-between{justify-content:space-between;}.justify-left{justify-content:left;}.justify-right{justify-content:right;}.gap-0{gap:0;}.gap-10px{gap:10px;}.gap-15px{gap:15px;}.gap-1px{gap:1px;}.gap-4px{gap:4px;}.gap-x-1,.gap-x-4px{column-gap:4px;}.gap-x-10px{column-gap:10px;}.gap-x-12px{column-gap:12px;}.gap-x-15px{column-gap:15px;}.gap-x-2,.gap-x-8px{column-gap:8px;}.gap-x-20px{column-gap:20px;}.gap-x-25px{column-gap:25px;}.gap-x-2px{column-gap:2px;}.gap-x-40px{column-gap:40px;}.gap-x-50px{column-gap:50px;}.gap-x-5px{column-gap:5px;}.gap-x-6px{column-gap:6px;}.gap-y-0{row-gap:0;}.gap-y-0\\.5em{row-gap:0.5em;}.gap-y-1,.gap-y-4px{row-gap:4px;}.gap-y-10px{row-gap:10px;}.gap-y-15px{row-gap:15px;}.gap-y-2,.gap-y-8px{row-gap:8px;}.gap-y-2px{row-gap:2px;}.gap-y-3px{row-gap:3px;}.gap-y-5px{row-gap:5px;}.gap-y-6px{row-gap:6px;}.overflow-hidden{overflow:hidden;}.overflow-x-hidden{overflow-x:hidden;}.overflow-y-auto{overflow-y:auto;}.text-ellipsis{text-overflow:ellipsis;}.whitespace-normal{white-space:normal;}.whitespace-nowrap{white-space:nowrap;}.whitespace-pre-wrap{white-space:pre-wrap;}.break-normal{overflow-wrap:normal;word-break:normal;}.break-all{word-break:break-all;}.b-1px,.border{border-width:1px;}.b-2px{border-width:2px;}.b-5px{border-width:5px;}.b-b-1px{border-bottom-width:1px;}.b-t-1px{border-top-width:1px;}.border-b-0{border-bottom-width:0px;}.b-\\#444{--un-border-opacity:1;border-color:rgb(68 68 68 / var(--un-border-opacity));}.b-gate-bg-lv-2{border-color:var(--bilibili-gate--bg--lv2);}.b-gate-border,.bilibili-gate-using-dark .dark\\:b-gate-border{border-color:var(--bilibili-gate--border-color);}.b-gate-primary{border-color:var(--bilibili-gate--primary-color);}.b-transparent{border-color:transparent;}.b-white\\/20\\%{border-color:rgb(255 255 255 / 0.2);}.b-white\\/33\\%{border-color:rgb(255 255 255 / 0.33);}.border-white\\/40{border-color:rgb(255 255 255 / 0.4);}.bilibili-gate-using-light .light\\:hover\\:b-gate-primary:hover{border-color:var(--bilibili-gate--primary-color);}.hover\\:b-gate-primary:hover{border-color:var(--bilibili-gate--primary-color);}.b-b-gate-bg-lv1{border-bottom-color:var(--bilibili-gate--bg--lv1);}.b-b-transparent{border-bottom-color:transparent;}.b-t-\\$bilibili-gate--separator-color{border-top-color:var(--bilibili-gate--separator-color);}.rounded,.rounded-4px{border-radius:4px;}.rounded-10px{border-radius:10px;}.rounded-15px{border-radius:15px;}.rounded-18px{border-radius:18px;}.rounded-20px{border-radius:20px;}.rounded-2px{border-radius:2px;}.rounded-5px{border-radius:5px;}.rounded-6px,.rounded-md{border-radius:6px;}.rounded-8px,.rounded-lg{border-radius:8px;}.rounded-9px{border-radius:9px;}.rounded-full{border-radius:9999px;}.rounded-b-none{border-bottom-left-radius:0;border-bottom-right-radius:0;}.rounded-t-6px{border-top-left-radius:6px;border-top-right-radius:6px;}.rounded-t-gate-video-card{border-top-left-radius:var(--bilibili-gate--video-card--border-radius);border-top-right-radius:var(--bilibili-gate--video-card--border-radius);}.b-solid{border-style:solid;}.border-none{border-style:none;}.b-b-solid{border-bottom-style:solid;}.b-t-solid{border-top-style:solid;}.\\[\\&\\:has\\(svg\\.peeking\\)\\]\\:bg-transparent:has(svg.peeking),.bg-transparent{background-color:transparent /* transparent */;}.bg-\\[rgb\\(33_33_33_\\/_0\\.7\\)\\]{--un-bg-opacity:0.7;background-color:rgb(33 33 33 / var(--un-bg-opacity)) /* rgb(33 33 33 / 0.7) */;}.bg-\\$brand_blue{background-color:var(--brand_blue) /* var(--brand_blue) */;}.bg-\\$brand_pink{background-color:var(--brand_pink) /* var(--brand_pink) */;}.bg-black\\/10{background-color:rgb(0 0 0 / 0.1) /* #000 */;}.bg-black\\/50{background-color:rgb(0 0 0 / 0.5) /* #000 */;}.bg-black\\/65{background-color:rgb(0 0 0 / 0.65) /* #000 */;}.bg-black\\/90\\%{background-color:rgb(0 0 0 / 0.9) /* #000 */;}.bg-gate-bg{background-color:var(--bilibili-gate--bg) /* var(--bilibili-gate--bg) */;}.bg-gate-bg-lv1{background-color:var(--bilibili-gate--bg--lv1) /* var(--bilibili-gate--bg--lv1) */;}.bg-gate-primary{background-color:var(--bilibili-gate--primary-color) /* var(--bilibili-gate--primary-color) */;}.bg-gate-primary-lv-3{background-color:var(--bilibili-gate--primary-color--lv3) /* var(--bilibili-gate--primary-color--lv3) */;}.bg-gate-primary\\!{background-color:var(--bilibili-gate--primary-color) /* var(--bilibili-gate--primary-color) */ !important;}.bg-white\\/14\\%{background-color:rgb(255 255 255 / 0.14) /* #fff */;}.bg-white\\/50\\%{background-color:rgb(255 255 255 / 0.5) /* #fff */;}.hover\\:bg-gate-bg-lv-3:hover{background-color:var(--bilibili-gate--bg--lv3) /* var(--bilibili-gate--bg--lv3) */;}.hover\\:bg-gate-bg-lv1:hover{background-color:var(--bilibili-gate--bg--lv1) /* var(--bilibili-gate--bg--lv1) */;}.hover\\:bg-gate-primary-lv1\\!:hover{background-color:var(--bilibili-gate--primary-color--lv1) /* var(--bilibili-gate--primary-color--lv1) */ !important;}.hover\\:bg-gate-primary:hover{background-color:var(--bilibili-gate--primary-color) /* var(--bilibili-gate--primary-color) */;}.hover\\:bg-white\\/40\\%:hover{background-color:rgb(255 255 255 / 0.4) /* #fff */;}.\\[\\&_g\\]\\:fill-inherit g{fill:inherit /* inherit */;}.\\[\\&_path\\]\\:fill-gate-primary path,.fill-gate-primary{fill:var(--bilibili-gate--primary-color) /* var(--bilibili-gate--primary-color) */;}.fill-none{fill:none;}.\\[\\&_\\.circle\\]\\:stroke-current .circle{stroke:currentColor /* currentColor */;}.object-cover{object-fit:cover;}.object-contain{object-fit:contain;}.p-10px{padding:10px;}.p-15px{padding:15px;}.p-1px{padding:1px;}.p-20px{padding:20px;}.p-2px{padding:2px;}.p-4px{padding:4px;}.p-8px{padding:8px;}.\\[\\&_\\.ant-radio-button-wrapper\\]\\:px-10px .ant-radio-button-wrapper{padding-left:10px;padding-right:10px;}.\\[\\&\\.ant-empty-normal\\]\\:py-5px.ant-empty-normal,.py-5px{padding-top:5px;padding-bottom:5px;}.p-x-2,.px-8px{padding-left:8px;padding-right:8px;}.p-y-1,.py-4px{padding-top:4px;padding-bottom:4px;}.px,.px-4{padding-left:16px;padding-right:16px;}.px-0{padding-left:0;padding-right:0;}.px-12px,.px-3{padding-left:12px;padding-right:12px;}.px-15px{padding-left:15px;padding-right:15px;}.px-24px{padding-left:24px;padding-right:24px;}.px-2px{padding-left:2px;padding-right:2px;}.px-4px{padding-left:4px;padding-right:4px;}.px-5px{padding-left:5px;padding-right:5px;}.px-6px{padding-left:6px;padding-right:6px;}.py-0{padding-top:0;padding-bottom:0;}.py-10px{padding-top:10px;padding-bottom:10px;}.py-12px{padding-top:12px;padding-bottom:12px;}.py-2,.py-8px{padding-top:8px;padding-bottom:8px;}.py-2px{padding-top:2px;padding-bottom:2px;}.py-30px{padding-top:30px;padding-bottom:30px;}.py-3px{padding-top:3px;padding-bottom:3px;}.py-6px{padding-top:6px;padding-bottom:6px;}.\\!\\[\\&_\\.ant-radio-label\\]\\:pl-4px .ant-radio-label{padding-left:4px !important;}.pb-15px{padding-bottom:15px;}.pb-2px{padding-bottom:2px;}.pb1257{padding-bottom:5028px;}.pl-10px{padding-left:10px;}.pl-16px{padding-left:16px;}.pl-20px{padding-left:20px;}.pl-2px{padding-left:2px;}.pl-4px{padding-left:4px;}.pl-6px{padding-left:6px;}.pr-0{padding-right:0;}.pr-10px{padding-right:10px;}.pr-12px{padding-right:12px;}.pr-15px{padding-right:15px;}.pr-18px{padding-right:18px;}.pr-6px{padding-right:6px;}.ps{padding-inline-start:16px;}.pt-0{padding-top:0;}.pt-15px{padding-top:15px;}.pt-5px{padding-top:5px;}.text-center{text-align:center;}.align-top{vertical-align:top;}.\\[\\&\\.ant-divider-horizontal\\.ant-divider-with-text\\]\\:text-14px.ant-divider-horizontal.ant-divider-with-text,.text-14px,.text-size-14px{font-size:14px;}.text-\\[1\\.5rem\\]{font-size:24px;}.text-1\\.25em{font-size:1.25em;}.text-1\\.2em{font-size:1.2em;}.text-1\\.4em{font-size:1.4em;}.text-1\\.5em,.text-size-1\\.5em{font-size:1.5em;}.text-12px,.text-size-12px{font-size:12px;}.text-13px,.text-size-13px{font-size:13px;}.text-15px{font-size:15px;}.text-15px\\!{font-size:15px !important;}.text-1em{font-size:1em;}.text-20px,.text-size-20px{font-size:20px;}.text-2em{font-size:2em;}.text-size-0{font-size:0;}.text-size-1\\.3em{font-size:1.3em;}.text-size-120\\%{font-size:120%;}.text-size-16px{font-size:16px;}.color-gate-primary,.text-gate-primary{color:var(--bilibili-gate--primary-color) /* var(--bilibili-gate--primary-color) */;}.text-gate-text{color:var(--bilibili-gate--text-color) /* var(--bilibili-gate--text-color) */;}.text-red{--un-text-opacity:1;color:rgb(248 113 113 / var(--un-text-opacity)) /* #f87171 */;}.color-white,.text-white{--un-text-opacity:1;color:rgb(255 255 255 / var(--un-text-opacity)) /* #fff */;}.text-yellow-400{--un-text-opacity:1;color:rgb(250 204 21 / var(--un-text-opacity)) /* #facc15 */;}.hover\\:color-gate-primary:hover{color:var(--bilibili-gate--primary-color) /* var(--bilibili-gate--primary-color) */;}.color-inherit{color:inherit;}.font-600{font-weight:600;}.font-700{font-weight:700;}.\\[\\&_\\.ant-btn-icon\\]\\:line-height-0 .ant-btn-icon,.line-height-\\[0\\]{line-height:0;}.line-height-\\[1\\.2\\]{line-height:1.2;}.line-height-\\[1\\]{line-height:1;}.line-height-\\[unset\\],.line-height-unset{line-height:unset;}.line-height-1\\.5{line-height:6px;}.line-height-14px{line-height:14px;}.line-height-17px{line-height:17px;}.line-height-18px{line-height:18px;}.line-height-normal{line-height:1.5;}.line-height-snug{line-height:1.375;}.line-height-tight{line-height:1.25;}.font-mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}.italic{font-style:italic;}.tab{-moz-tab-size:4;-o-tab-size:4;tab-size:4;}.\\[\\&\\:has\\(svg\\.peeking\\)\\]\\:opacity-10:has(svg.peeking){opacity:0.1;}.shadow{--un-shadow:var(--un-shadow-inset) 0 1px 3px 0 var(--un-shadow-color, rgb(0 0 0 / 0.1)),var(--un-shadow-inset) 0 1px 2px -1px var(--un-shadow-color, rgb(0 0 0 / 0.1));box-shadow:var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow);}.\\[\\&\\.ant-btn\\:not\\(\\:disabled\\)\\:focus-visible\\]\\:outline-0.ant-btn:not(:disabled):focus-visible{outline-width:0px;}.outline-none\\!{outline:2px solid transparent !important;outline-offset:2px !important;}.ring-1px{--un-ring-width:1px;--un-ring-offset-shadow:var(--un-ring-inset) 0 0 0 var(--un-ring-offset-width) var(--un-ring-offset-color);--un-ring-shadow:var(--un-ring-inset) 0 0 0 calc(var(--un-ring-width) + var(--un-ring-offset-width)) var(--un-ring-color);box-shadow:var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow);}.ring-gate-border{--un-ring-color:var(--bilibili-gate--border-color) /* var(--bilibili-gate--border-color) */;}.ring-gate-primary{--un-ring-color:var(--bilibili-gate--primary-color) /* var(--bilibili-gate--primary-color) */;}.backdrop-blur-10px{--un-backdrop-blur:blur(10px);-webkit-backdrop-filter:var(--un-backdrop-blur) var(--un-backdrop-brightness) var(--un-backdrop-contrast) var(--un-backdrop-grayscale) var(--un-backdrop-hue-rotate) var(--un-backdrop-invert) var(--un-backdrop-opacity) var(--un-backdrop-saturate) var(--un-backdrop-sepia);backdrop-filter:var(--un-backdrop-blur) var(--un-backdrop-brightness) var(--un-backdrop-contrast) var(--un-backdrop-grayscale) var(--un-backdrop-hue-rotate) var(--un-backdrop-invert) var(--un-backdrop-opacity) var(--un-backdrop-saturate) var(--un-backdrop-sepia);}.filter{filter:var(--un-blur) var(--un-brightness) var(--un-contrast) var(--un-drop-shadow) var(--un-grayscale) var(--un-hue-rotate) var(--un-invert) var(--un-saturate) var(--un-sepia);}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;}.transition-200{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:200ms;}.transition-300{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:300ms;}.transition-transform{transition-property:transform;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;}.transition-duration-150{transition-duration:150ms;}.transition-duration-300{transition-duration:300ms;}.ease,.ease-in-out,.transition-ease,.transition-ease-in-out{transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);}.ease-out{transition-timing-function:cubic-bezier(0, 0, 0.2, 1);}.transition-property-\\[border-color\\]{transition-property:border-color;}.transition-property-all{transition-property:all;}.transition-property-right\\,left{transition-property:right,left;}.transition-property-transform{transition-property:transform;}.\\@container,.\\@container-inline-size{container-type:inline-size;}@media (min-width: 1280px){.xl\\:gap-x-8px{column-gap:8px;}}.bilibili-gate-root .bili-video-card__skeleton--cover, .bilibili-gate-root .bili-video-card__skeleton--text, .bilibili-gate-root .bili-video-card__skeleton--light, .bilibili-gate-root .bili-video-card__skeleton--avatar {
  background: linear-gradient(135deg, rgba(0, 0, 0, 0.06) 25%, rgba(0, 0, 0, 0.15) 37%, rgba(0, 0, 0, 0.06) 63%);
}
.bilibili-gate-root .bili-video-card__skeleton--text.tiny {
  margin-top: 4px;
  width: 15%;
}
html.bilibili-gate-using-dark .bilibili-gate-root .bili-video-card__skeleton--cover, html.bilibili-gate-using-dark .bilibili-gate-root .bili-video-card__skeleton--text, html.bilibili-gate-using-dark .bilibili-gate-root .bili-video-card__skeleton--light, html.bilibili-gate-using-dark .bilibili-gate-root .bili-video-card__skeleton--avatar {
  background-color: #444;
}

._skeleton-active_wlycr_12 .bili-video-card__skeleton--cover, ._skeleton-active_wlycr_12 .bili-video-card__skeleton--text, ._skeleton-active_wlycr_12 .bili-video-card__skeleton--light, ._skeleton-active_wlycr_12 .bili-video-card__skeleton--avatar {
  background-size: 400% 100%;
  animation-name: _ant-skeleton-loading_wlycr_1;
  animation-duration: 2s;
  animation-timing-function: ease;
  animation-iteration-count: infinite;
}

@keyframes _ant-skeleton-loading_wlycr_1 {
  0% {
    background-position: 100% 50%;
  }
  80%, 100% {
    background-position: 0 50%;
  }
} `);

  function _mergeNamespaces$1(n2, m2) {
    for (var i2 = 0; i2 < m2.length; i2++) {
      const e = m2[i2];
      if (typeof e !== "string" && !Array.isArray(e)) {
        for (const k in e) {
          if (k !== "default" && !(k in n2)) {
            const d2 = Object.getOwnPropertyDescriptor(e, k);
            if (d2) {
              Object.defineProperty(n2, k, d2.get ? d2 : {
                enumerable: true,
                get: () => e[k]
              });
            }
          }
        }
      }
    }
    return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
  }
  const globalScss = '@charset "UTF-8";\n:root {\n  --bilibili-gate--font: "Alibaba PuHuiTi 3.0", "PingFang SC", "HarmonyOS_Regular", "Helvetica Neue", "Microsoft YaHei", sans-serif;\n}\n\n:root {\n  --bilibili-gate--primary-color--lv1: oklch(from var(--bilibili-gate--primary-color) calc(l - 0.04) c h/alpha);\n  --bilibili-gate--primary-color--lv2: oklch(from var(--bilibili-gate--primary-color) calc(l - 0.08) c h/alpha);\n  --bilibili-gate--primary-color--lv3: oklch(from var(--bilibili-gate--primary-color) calc(l - 0.12) c h/alpha);\n  --bilibili-gate--border-color: oklch(from var(--bilibili-gate--bg) calc(l - 0.05) c h/alpha);\n  --bilibili-gate--bg--lv1: oklch(from var(--bilibili-gate--bg) calc(l - 0.04) c h/alpha);\n  --bilibili-gate--bg--lv2: oklch(from var(--bilibili-gate--bg) calc(l - 0.08) c h/alpha);\n  --bilibili-gate--bg--lv3: oklch(from var(--bilibili-gate--bg) calc(l - 0.12) c h/alpha);\n}\n:root.bilibili-gate-using-dark {\n  --bilibili-gate--border-color: oklch(from var(--bilibili-gate--bg) calc(l + 0.07) c h/alpha);\n  --bilibili-gate--bg--lv1: oklch(from var(--bilibili-gate--bg) calc(l + 0.03) c h/alpha);\n  --bilibili-gate--bg--lv2: oklch(from var(--bilibili-gate--bg) calc(l + 0.08) c h/alpha);\n  --bilibili-gate--bg--lv3: oklch(from var(--bilibili-gate--bg) calc(l + 0.12) c h/alpha);\n}\n\n.bilibili-gate-root {\n  font-family: var(--custom-font-family--options--font-family, var(--bilibili-gate--font)) !important;\n  font-size: 14px;\n  --back-top-right: 24px;\n}\n.bilibili-gate-root dd,\n.bilibili-gate-root dl,\n.bilibili-gate-root ol,\n.bilibili-gate-root ul {\n  font-size: inherit;\n}\n.bilibili-gate-root li {\n  list-style: unset;\n}\n.bilibili-gate-root .bili-video-card .bili-video-card__info--tit:hover,\n.bilibili-gate-root .bili-video-card a:not(.disable-hover):hover {\n  color: var(--bilibili-gate--primary-color) !important;\n}\n.bilibili-gate-root .ant-btn {\n  font-size: 13px;\n}\n.bilibili-gate-root img:-moz-loading {\n  visibility: hidden;\n}\n\n@media (max-width: 1440px) {\n  .bilibili-gate-root {\n    --back-top-right: 16px;\n  }\n}\nbody .ant-tooltip a {\n  color: #1677ff;\n  transition: color 0.3s;\n}\nbody .ant-tooltip a:visited {\n  color: #1677ff;\n}\nbody .ant-tooltip a:hover {\n  color: #69b1ff;\n}\nbody .ant-tooltip a:active {\n  color: #0958d9;\n}\n\nbody button:where(.ant-switch):focus, body button:where(.ant-switch):active {\n  background-color: rgba(0, 0, 0, 0.25);\n  outline: unset;\n}\n\n/**\nB站自带 css, 影响了 solid button :focus 样式\nbody button:focus, body button:active {\n  background-color: transparent;\n  outline: none;\n}\n */\nbody .ant-btn.ant-btn-variant-solid:focus, body .ant-btn.ant-btn-variant-solid:active {\n  color: var(--ant-button-primary-color);\n  background: var(--ant-color-primary);\n}';
  importCSS(globalScss);
  const clsGateVideoGridDivider = "_cls--gate-video-grid--divider_h4766_1";
  const clsGateVideoCardContextMenuRoot = "_cls--gate-video-card--context-menu--root_h4766_13";
  const videoGrid = "_video-grid_ucv12_1";
  const gridTemplateColumnsUsingVarCol = "_grid-template-columns-using-var-col_ucv12_9";
  const gridTemplateColumnsUsingCardMinWidth = "_grid-template-columns-using-card-min-width_ucv12_14";
  const videoGridAddonCenterEmpty = "_video-grid-addon-center-empty_ucv12_19";
  const videoGridBiliFeed4 = "_video-grid-bili-feed4_ucv12_26";
  const videoGridCustom = "_video-grid-custom_ucv12_47";
  const narrowMode = "_narrow-mode_ucv12_63";
  const videoGrid_module = {
    videoGrid,
    gridTemplateColumnsUsingVarCol,
    gridTemplateColumnsUsingCardMinWidth,
    videoGridAddonCenterEmpty,
    videoGridBiliFeed4,
    videoGridCustom,
    narrowMode
  };
  const gridClassNames = Object.freeze( Object.defineProperty({
    __proto__: null,
    default: videoGrid_module,
    gridTemplateColumnsUsingCardMinWidth,
    gridTemplateColumnsUsingVarCol,
    narrowMode,
    videoGrid,
    videoGridAddonCenterEmpty,
    videoGridBiliFeed4,
    videoGridCustom
  }, Symbol.toStringTag, { value: "Module" }));
  function countBy(arr, mapper) {
    const result = {};
    for (let i2 = 0; i2 < arr.length; i2++) {
      const item = arr[i2];
      const key = mapper(item, i2, arr);
      result[key] = (result[key] ?? 0) + 1;
    }
    return result;
  }
  function difference(firstArr, secondArr) {
    const secondSet = new Set(secondArr);
    return firstArr.filter((item) => !secondSet.has(item));
  }
  function groupBy(arr, getKeyFromItem) {
    const result = {};
    for (let i2 = 0; i2 < arr.length; i2++) {
      const item = arr[i2];
      const key = getKeyFromItem(item, i2, arr);
      if (!Object.hasOwn(result, key)) {
        result[key] = [];
      }
      result[key].push(item);
    }
    return result;
  }
  function compareValues(a2, b, order) {
    if (a2 < b) {
      return order === "asc" ? -1 : 1;
    }
    if (a2 > b) {
      return order === "asc" ? 1 : -1;
    }
    return 0;
  }
  function orderBy(arr, criteria, orders) {
    return arr.slice().sort((a2, b) => {
      const ordersLength = orders.length;
      for (let i2 = 0; i2 < criteria.length; i2++) {
        const order = ordersLength > i2 ? orders[i2] : orders[ordersLength - 1];
        const criterion = criteria[i2];
        const criterionIsFunction = typeof criterion === "function";
        const valueA = criterionIsFunction ? criterion(a2) : a2[criterion];
        const valueB = criterionIsFunction ? criterion(b) : b[criterion];
        const result = compareValues(valueA, valueB, order);
        if (result !== 0) {
          return result;
        }
      }
      return 0;
    });
  }
  function random(minimum, maximum) {
    if (maximum == null) {
      maximum = minimum;
      minimum = 0;
    }
    if (minimum >= maximum) {
      throw new Error("Invalid input: The maximum value must be greater than the minimum value.");
    }
    return Math.random() * (maximum - minimum) + minimum;
  }
  function randomInt(minimum, maximum) {
    return Math.floor(random(minimum, maximum));
  }
  function shuffle(arr) {
    const result = arr.slice();
    for (let i2 = result.length - 1; i2 >= 1; i2--) {
      const j = Math.floor(Math.random() * (i2 + 1));
      [result[i2], result[j]] = [result[j], result[i2]];
    }
    return result;
  }
  function isSymbol(value) {
    return typeof value === "symbol" || value instanceof Symbol;
  }
  function toNumber(value) {
    if (isSymbol(value)) {
      return NaN;
    }
    return Number(value);
  }
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === Infinity || value === -Infinity) {
      const sign = value < 0 ? -1 : 1;
      return sign * Number.MAX_VALUE;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    const finite = toFinite(value);
    const remainder = finite % 1;
    return remainder ? finite - remainder : finite;
  }
  function uniq(arr) {
    return [...new Set(arr)];
  }
  function uniqBy(arr, mapper) {
    const map = new Map();
    for (let i2 = 0; i2 < arr.length; i2++) {
      const item = arr[i2];
      const key = mapper(item, i2, arr);
      if (!map.has(key)) {
        map.set(key, item);
      }
    }
    return Array.from(map.values());
  }
  let AbortError$1 = class AbortError extends Error {
    constructor(message2 = "The operation was aborted") {
      super(message2);
      this.name = "AbortError";
    }
  };
  function debounce$2(func, debounceMs, { signal, edges } = {}) {
    let pendingThis = void 0;
    let pendingArgs = null;
    const leading = edges != null && edges.includes("leading");
    const trailing = edges == null || edges.includes("trailing");
    const invoke = () => {
      if (pendingArgs !== null) {
        func.apply(pendingThis, pendingArgs);
        pendingThis = void 0;
        pendingArgs = null;
      }
    };
    const onTimerEnd = () => {
      if (trailing) {
        invoke();
      }
      cancel();
    };
    let timeoutId = null;
    const schedule = () => {
      if (timeoutId != null) {
        clearTimeout(timeoutId);
      }
      timeoutId = setTimeout(() => {
        timeoutId = null;
        onTimerEnd();
      }, debounceMs);
    };
    const cancelTimer = () => {
      if (timeoutId !== null) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
    };
    const cancel = () => {
      cancelTimer();
      pendingThis = void 0;
      pendingArgs = null;
    };
    const flush = () => {
      invoke();
    };
    const debounced = function(...args) {
      if (signal?.aborted) {
        return;
      }
      pendingThis = this;
      pendingArgs = args;
      const isFirstCall = timeoutId == null;
      schedule();
      if (leading && isFirstCall) {
        invoke();
      }
    };
    debounced.schedule = schedule;
    debounced.cancel = cancel;
    debounced.flush = flush;
    signal?.addEventListener("abort", cancel, { once: true });
    return debounced;
  }
  function identity(x) {
    return x;
  }
  function memoize$1(fn, options = {}) {
    const { cache: cache2 = new Map(), getCacheKey } = options;
    const memoizedFn = function(arg) {
      const key = getCacheKey ? getCacheKey(arg) : arg;
      if (cache2.has(key)) {
        return cache2.get(key);
      }
      const result = fn.call(this, arg);
      cache2.set(key, result);
      return result;
    };
    memoizedFn.cache = cache2;
    return memoizedFn;
  }
  function noop$4() {
  }
  function once(func) {
    let called = false;
    let cache2;
    return function(...args) {
      if (!called) {
        called = true;
        cache2 = func(...args);
      }
      return cache2;
    };
  }
  function delay$1(ms2, { signal } = {}) {
    return new Promise((resolve, reject) => {
      const abortError = () => {
        reject(new AbortError$1());
      };
      const abortHandler = () => {
        clearTimeout(timeoutId);
        abortError();
      };
      if (signal?.aborted) {
        return abortError();
      }
      const timeoutId = setTimeout(() => {
        signal?.removeEventListener("abort", abortHandler);
        resolve();
      }, ms2);
      signal?.addEventListener("abort", abortHandler, { once: true });
    });
  }
  function throttle$2(func, throttleMs, { signal, edges = ["leading", "trailing"] } = {}) {
    let pendingAt = null;
    const debounced = debounce$2(function(...args) {
      pendingAt = Date.now();
      func.apply(this, args);
    }, throttleMs, { signal, edges });
    const throttled = function(...args) {
      if (pendingAt == null) {
        pendingAt = Date.now();
      }
      if (Date.now() - pendingAt >= throttleMs) {
        pendingAt = Date.now();
        func.apply(this, args);
        debounced.cancel();
        debounced.schedule();
        return;
      }
      debounced.apply(this, args);
    };
    throttled.cancel = debounced.cancel;
    throttled.flush = debounced.flush;
    return throttled;
  }
  function range$1(start, end, step = 1) {
    if (end == null) {
      end = start;
      start = 0;
    }
    if (!Number.isInteger(step) || step === 0) {
      throw new Error(`The step value must be a non-zero integer.`);
    }
    const length2 = Math.max(Math.ceil((end - start) / step), 0);
    const result = new Array(length2);
    for (let i2 = 0; i2 < length2; i2++) {
      result[i2] = start + i2 * step;
    }
    return result;
  }
  function isPrimitive$1(value) {
    return value == null || typeof value !== "object" && typeof value !== "function";
  }
  function isTypedArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }
  function clone(obj) {
    if (isPrimitive$1(obj)) {
      return obj;
    }
    if (Array.isArray(obj) || isTypedArray(obj) || obj instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && obj instanceof SharedArrayBuffer) {
      return obj.slice(0);
    }
    const prototype = Object.getPrototypeOf(obj);
    if (prototype == null) {
      return Object.assign(Object.create(prototype), obj);
    }
    const Constructor = prototype.constructor;
    if (obj instanceof Date || obj instanceof Map || obj instanceof Set) {
      return new Constructor(obj);
    }
    if (obj instanceof RegExp) {
      const newRegExp = new Constructor(obj);
      newRegExp.lastIndex = obj.lastIndex;
      return newRegExp;
    }
    if (obj instanceof DataView) {
      return new Constructor(obj.buffer.slice(0));
    }
    if (obj instanceof Error) {
      let newError;
      if (obj instanceof AggregateError) {
        newError = new Constructor(obj.errors, obj.message, { cause: obj.cause });
      } else {
        newError = new Constructor(obj.message, { cause: obj.cause });
      }
      newError.stack = obj.stack;
      Object.assign(newError, obj);
      return newError;
    }
    if (typeof File !== "undefined" && obj instanceof File) {
      const newFile = new Constructor([obj], obj.name, { type: obj.type, lastModified: obj.lastModified });
      return newFile;
    }
    if (typeof obj === "object") {
      const newObject = Object.create(prototype);
      return Object.assign(newObject, obj);
    }
    return obj;
  }
  function getSymbols(object4) {
    return Object.getOwnPropertySymbols(object4).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object4, symbol));
  }
  function getTag(value) {
    if (value == null) {
      return value === void 0 ? "[object Undefined]" : "[object Null]";
    }
    return Object.prototype.toString.call(value);
  }
  const regexpTag = "[object RegExp]";
  const stringTag = "[object String]";
  const numberTag = "[object Number]";
  const booleanTag = "[object Boolean]";
  const argumentsTag = "[object Arguments]";
  const symbolTag = "[object Symbol]";
  const dateTag = "[object Date]";
  const mapTag = "[object Map]";
  const setTag = "[object Set]";
  const arrayTag = "[object Array]";
  const functionTag = "[object Function]";
  const arrayBufferTag = "[object ArrayBuffer]";
  const objectTag = "[object Object]";
  const errorTag = "[object Error]";
  const dataViewTag = "[object DataView]";
  const uint8ArrayTag = "[object Uint8Array]";
  const uint8ClampedArrayTag = "[object Uint8ClampedArray]";
  const uint16ArrayTag = "[object Uint16Array]";
  const uint32ArrayTag = "[object Uint32Array]";
  const bigUint64ArrayTag = "[object BigUint64Array]";
  const int8ArrayTag = "[object Int8Array]";
  const int16ArrayTag = "[object Int16Array]";
  const int32ArrayTag = "[object Int32Array]";
  const bigInt64ArrayTag = "[object BigInt64Array]";
  const float32ArrayTag = "[object Float32Array]";
  const float64ArrayTag = "[object Float64Array]";
  function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack2 = new Map(), cloneValue = void 0) {
    const cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack2);
    if (cloned !== void 0) {
      return cloned;
    }
    if (isPrimitive$1(valueToClone)) {
      return valueToClone;
    }
    if (stack2.has(valueToClone)) {
      return stack2.get(valueToClone);
    }
    if (Array.isArray(valueToClone)) {
      const result = new Array(valueToClone.length);
      stack2.set(valueToClone, result);
      for (let i2 = 0; i2 < valueToClone.length; i2++) {
        result[i2] = cloneDeepWithImpl(valueToClone[i2], i2, objectToClone, stack2, cloneValue);
      }
      if (Object.hasOwn(valueToClone, "index")) {
        result.index = valueToClone.index;
      }
      if (Object.hasOwn(valueToClone, "input")) {
        result.input = valueToClone.input;
      }
      return result;
    }
    if (valueToClone instanceof Date) {
      return new Date(valueToClone.getTime());
    }
    if (valueToClone instanceof RegExp) {
      const result = new RegExp(valueToClone.source, valueToClone.flags);
      result.lastIndex = valueToClone.lastIndex;
      return result;
    }
    if (valueToClone instanceof Map) {
      const result = new Map();
      stack2.set(valueToClone, result);
      for (const [key, value] of valueToClone) {
        result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack2, cloneValue));
      }
      return result;
    }
    if (valueToClone instanceof Set) {
      const result = new Set();
      stack2.set(valueToClone, result);
      for (const value of valueToClone) {
        result.add(cloneDeepWithImpl(value, void 0, objectToClone, stack2, cloneValue));
      }
      return result;
    }
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) {
      return valueToClone.subarray();
    }
    if (isTypedArray(valueToClone)) {
      const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
      stack2.set(valueToClone, result);
      for (let i2 = 0; i2 < valueToClone.length; i2++) {
        result[i2] = cloneDeepWithImpl(valueToClone[i2], i2, objectToClone, stack2, cloneValue);
      }
      return result;
    }
    if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) {
      return valueToClone.slice(0);
    }
    if (valueToClone instanceof DataView) {
      const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (typeof File !== "undefined" && valueToClone instanceof File) {
      const result = new File([valueToClone], valueToClone.name, {
        type: valueToClone.type
      });
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (typeof Blob !== "undefined" && valueToClone instanceof Blob) {
      const result = new Blob([valueToClone], { type: valueToClone.type });
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (valueToClone instanceof Error) {
      const result = new valueToClone.constructor();
      stack2.set(valueToClone, result);
      result.message = valueToClone.message;
      result.name = valueToClone.name;
      result.stack = valueToClone.stack;
      result.cause = valueToClone.cause;
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (valueToClone instanceof Boolean) {
      const result = new Boolean(valueToClone.valueOf());
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (valueToClone instanceof Number) {
      const result = new Number(valueToClone.valueOf());
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (valueToClone instanceof String) {
      const result = new String(valueToClone.valueOf());
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
      const result = Object.create(Object.getPrototypeOf(valueToClone));
      stack2.set(valueToClone, result);
      copyProperties(result, valueToClone, objectToClone, stack2, cloneValue);
      return result;
    }
    return valueToClone;
  }
  function copyProperties(target, source, objectToClone = target, stack2, cloneValue) {
    const keys2 = [...Object.keys(source), ...getSymbols(source)];
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const key = keys2[i2];
      const descriptor = Object.getOwnPropertyDescriptor(target, key);
      if (descriptor == null || descriptor.writable) {
        target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack2, cloneValue);
      }
    }
  }
  function isCloneableObject(object4) {
    switch (getTag(object4)) {
      case argumentsTag:
      case arrayTag:
      case arrayBufferTag:
      case dataViewTag:
      case booleanTag:
      case dateTag:
      case float32ArrayTag:
      case float64ArrayTag:
      case int8ArrayTag:
      case int16ArrayTag:
      case int32ArrayTag:
      case mapTag:
      case numberTag:
      case objectTag:
      case regexpTag:
      case setTag:
      case stringTag:
      case symbolTag:
      case uint8ArrayTag:
      case uint8ClampedArrayTag:
      case uint16ArrayTag:
      case uint32ArrayTag: {
        return true;
      }
      default: {
        return false;
      }
    }
  }
  function cloneDeep(obj) {
    return cloneDeepWithImpl(obj, void 0, obj, new Map(), void 0);
  }
  function isPlainObject(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    const proto = Object.getPrototypeOf(value);
    const hasObjectPrototype = proto === null || proto === Object.prototype || Object.getPrototypeOf(proto) === null;
    if (!hasObjectPrototype) {
      return false;
    }
    return Object.prototype.toString.call(value) === "[object Object]";
  }
  function isUnsafeProperty(key) {
    return key === "__proto__";
  }
  function mergeWith$1(target, source, merge2) {
    const sourceKeys = Object.keys(source);
    for (let i2 = 0; i2 < sourceKeys.length; i2++) {
      const key = sourceKeys[i2];
      if (isUnsafeProperty(key)) {
        continue;
      }
      const sourceValue = source[key];
      const targetValue = target[key];
      const merged = merge2(targetValue, sourceValue, key, target, source);
      if (merged !== void 0) {
        target[key] = merged;
      } else if (Array.isArray(sourceValue)) {
        if (Array.isArray(targetValue)) {
          target[key] = mergeWith$1(targetValue, sourceValue, merge2);
        } else {
          target[key] = mergeWith$1([], sourceValue, merge2);
        }
      } else if (isPlainObject(sourceValue)) {
        if (isPlainObject(targetValue)) {
          target[key] = mergeWith$1(targetValue, sourceValue, merge2);
        } else {
          target[key] = mergeWith$1({}, sourceValue, merge2);
        }
      } else if (targetValue === void 0 || sourceValue !== void 0) {
        target[key] = sourceValue;
      }
    }
    return target;
  }
  function omit$1(obj, keys2) {
    const result = { ...obj };
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const key = keys2[i2];
      delete result[key];
    }
    return result;
  }
  function pick(obj, keys2) {
    const result = {};
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const key = keys2[i2];
      if (Object.hasOwn(obj, key)) {
        result[key] = obj[key];
      }
    }
    return result;
  }
  const CASE_SPLIT_PATTERN = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");
  function words(str) {
    return Array.from(str.match(CASE_SPLIT_PATTERN) ?? []);
  }
  function toMerged(target, source) {
    return mergeWith$1(clone(target), source, function mergeRecursively(targetValue, sourceValue) {
      if (Array.isArray(sourceValue)) {
        if (Array.isArray(targetValue)) {
          return mergeWith$1(clone(targetValue), sourceValue, mergeRecursively);
        } else {
          return mergeWith$1([], sourceValue, mergeRecursively);
        }
      } else if (isPlainObject(sourceValue)) {
        if (isPlainObject(targetValue)) {
          return mergeWith$1(clone(targetValue), sourceValue, mergeRecursively);
        } else {
          return mergeWith$1({}, sourceValue, mergeRecursively);
        }
      }
    });
  }
  function isEqualsSameValueZero(value, other) {
    return value === other || Number.isNaN(value) && Number.isNaN(other);
  }
  function isEqualWith(a2, b, areValuesEqual) {
    return isEqualWithImpl(a2, b, void 0, void 0, void 0, void 0, areValuesEqual);
  }
  function isEqualWithImpl(a2, b, property, aParent, bParent, stack2, areValuesEqual) {
    const result = areValuesEqual(a2, b, property, aParent, bParent, stack2);
    if (result !== void 0) {
      return result;
    }
    if (typeof a2 === typeof b) {
      switch (typeof a2) {
        case "bigint":
        case "string":
        case "boolean":
        case "symbol":
        case "undefined": {
          return a2 === b;
        }
        case "number": {
          return a2 === b || Object.is(a2, b);
        }
        case "function": {
          return a2 === b;
        }
        case "object": {
          return areObjectsEqual(a2, b, stack2, areValuesEqual);
        }
      }
    }
    return areObjectsEqual(a2, b, stack2, areValuesEqual);
  }
  function areObjectsEqual(a2, b, stack2, areValuesEqual) {
    if (Object.is(a2, b)) {
      return true;
    }
    let aTag = getTag(a2);
    let bTag = getTag(b);
    if (aTag === argumentsTag) {
      aTag = objectTag;
    }
    if (bTag === argumentsTag) {
      bTag = objectTag;
    }
    if (aTag !== bTag) {
      return false;
    }
    switch (aTag) {
      case stringTag:
        return a2.toString() === b.toString();
      case numberTag: {
        const x = a2.valueOf();
        const y = b.valueOf();
        return isEqualsSameValueZero(x, y);
      }
      case booleanTag:
      case dateTag:
      case symbolTag:
        return Object.is(a2.valueOf(), b.valueOf());
      case regexpTag: {
        return a2.source === b.source && a2.flags === b.flags;
      }
      case functionTag: {
        return a2 === b;
      }
    }
    stack2 = stack2 ?? new Map();
    const aStack = stack2.get(a2);
    const bStack = stack2.get(b);
    if (aStack != null && bStack != null) {
      return aStack === b;
    }
    stack2.set(a2, b);
    stack2.set(b, a2);
    try {
      switch (aTag) {
        case mapTag: {
          if (a2.size !== b.size) {
            return false;
          }
          for (const [key, value] of a2.entries()) {
            if (!b.has(key) || !isEqualWithImpl(value, b.get(key), key, a2, b, stack2, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        case setTag: {
          if (a2.size !== b.size) {
            return false;
          }
          const aValues = Array.from(a2.values());
          const bValues = Array.from(b.values());
          for (let i2 = 0; i2 < aValues.length; i2++) {
            const aValue = aValues[i2];
            const index = bValues.findIndex((bValue) => {
              return isEqualWithImpl(aValue, bValue, void 0, a2, b, stack2, areValuesEqual);
            });
            if (index === -1) {
              return false;
            }
            bValues.splice(index, 1);
          }
          return true;
        }
        case arrayTag:
        case uint8ArrayTag:
        case uint8ClampedArrayTag:
        case uint16ArrayTag:
        case uint32ArrayTag:
        case bigUint64ArrayTag:
        case int8ArrayTag:
        case int16ArrayTag:
        case int32ArrayTag:
        case bigInt64ArrayTag:
        case float32ArrayTag:
        case float64ArrayTag: {
          if (typeof Buffer !== "undefined" && Buffer.isBuffer(a2) !== Buffer.isBuffer(b)) {
            return false;
          }
          if (a2.length !== b.length) {
            return false;
          }
          for (let i2 = 0; i2 < a2.length; i2++) {
            if (!isEqualWithImpl(a2[i2], b[i2], i2, a2, b, stack2, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        case arrayBufferTag: {
          if (a2.byteLength !== b.byteLength) {
            return false;
          }
          return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b), stack2, areValuesEqual);
        }
        case dataViewTag: {
          if (a2.byteLength !== b.byteLength || a2.byteOffset !== b.byteOffset) {
            return false;
          }
          return areObjectsEqual(new Uint8Array(a2), new Uint8Array(b), stack2, areValuesEqual);
        }
        case errorTag: {
          return a2.name === b.name && a2.message === b.message;
        }
        case objectTag: {
          const areEqualInstances = areObjectsEqual(a2.constructor, b.constructor, stack2, areValuesEqual) || isPlainObject(a2) && isPlainObject(b);
          if (!areEqualInstances) {
            return false;
          }
          const aKeys = [...Object.keys(a2), ...getSymbols(a2)];
          const bKeys = [...Object.keys(b), ...getSymbols(b)];
          if (aKeys.length !== bKeys.length) {
            return false;
          }
          for (let i2 = 0; i2 < aKeys.length; i2++) {
            const propKey = aKeys[i2];
            const aProp = a2[propKey];
            if (!Object.hasOwn(b, propKey)) {
              return false;
            }
            const bProp = b[propKey];
            if (!isEqualWithImpl(aProp, bProp, propKey, a2, b, stack2, areValuesEqual)) {
              return false;
            }
          }
          return true;
        }
        default: {
          return false;
        }
      }
    } finally {
      stack2.delete(a2);
      stack2.delete(b);
    }
  }
  function isEqual$2(a2, b) {
    return isEqualWith(a2, b, noop$4);
  }
  function isNil(x) {
    return x == null;
  }
  function startCase(str) {
    const words$1 = words(str.trim());
    let result = "";
    for (let i2 = 0; i2 < words$1.length; i2++) {
      const word = words$1[i2];
      if (result) {
        result += " ";
      }
      result += word[0].toUpperCase() + word.slice(1).toLowerCase();
    }
    return result;
  }
  function attempt(func) {
    try {
      return [null, func()];
    } catch (error) {
      return [error, null];
    }
  }
  async function attemptAsync(func) {
    try {
      const result = await func();
      return [null, result];
    } catch (error) {
      return [error, null];
    }
  }
  function invariant$1(condition, message2) {
    if (condition) {
      return;
    }
    if (typeof message2 === "string") {
      throw new Error(message2);
    }
    throw message2;
  }
  function isDeepKey(key) {
    switch (typeof key) {
      case "number":
      case "symbol": {
        return false;
      }
      case "string": {
        return key.includes(".") || key.includes("[") || key.includes("]");
      }
    }
  }
  function toKey(value) {
    if (typeof value === "string" || typeof value === "symbol") {
      return value;
    }
    if (Object.is(value?.valueOf?.(), -0)) {
      return "-0";
    }
    return String(value);
  }
  function toString(value) {
    if (value == null) {
      return "";
    }
    if (typeof value === "string") {
      return value;
    }
    if (Array.isArray(value)) {
      return value.map(toString).join(",");
    }
    const result = String(value);
    if (result === "0" && Object.is(Number(value), -0)) {
      return "-0";
    }
    return result;
  }
  function toPath(deepKey) {
    if (Array.isArray(deepKey)) {
      return deepKey.map(toKey);
    }
    if (typeof deepKey === "symbol") {
      return [deepKey];
    }
    deepKey = toString(deepKey);
    const result = [];
    const length2 = deepKey.length;
    if (length2 === 0) {
      return result;
    }
    let index = 0;
    let key = "";
    let quoteChar = "";
    let bracket = false;
    if (deepKey.charCodeAt(0) === 46) {
      result.push("");
      index++;
    }
    while (index < length2) {
      const char2 = deepKey[index];
      if (quoteChar) {
        if (char2 === "\\" && index + 1 < length2) {
          index++;
          key += deepKey[index];
        } else if (char2 === quoteChar) {
          quoteChar = "";
        } else {
          key += char2;
        }
      } else if (bracket) {
        if (char2 === '"' || char2 === "'") {
          quoteChar = char2;
        } else if (char2 === "]") {
          bracket = false;
          result.push(key);
          key = "";
        } else {
          key += char2;
        }
      } else {
        if (char2 === "[") {
          bracket = true;
          if (key) {
            result.push(key);
            key = "";
          }
        } else if (char2 === ".") {
          if (key) {
            result.push(key);
            key = "";
          }
        } else {
          key += char2;
        }
      }
      index++;
    }
    if (key) {
      result.push(key);
    }
    return result;
  }
  function get$1(object4, path, defaultValue2) {
    if (object4 == null) {
      return defaultValue2;
    }
    switch (typeof path) {
      case "string": {
        if (isUnsafeProperty(path)) {
          return defaultValue2;
        }
        const result = object4[path];
        if (result === void 0) {
          if (isDeepKey(path)) {
            return get$1(object4, toPath(path), defaultValue2);
          } else {
            return defaultValue2;
          }
        }
        return result;
      }
      case "number":
      case "symbol": {
        if (typeof path === "number") {
          path = toKey(path);
        }
        const result = object4[path];
        if (result === void 0) {
          return defaultValue2;
        }
        return result;
      }
      default: {
        if (Array.isArray(path)) {
          return getWithPath(object4, path, defaultValue2);
        }
        if (Object.is(path?.valueOf(), -0)) {
          path = "-0";
        } else {
          path = String(path);
        }
        if (isUnsafeProperty(path)) {
          return defaultValue2;
        }
        const result = object4[path];
        if (result === void 0) {
          return defaultValue2;
        }
        return result;
      }
    }
  }
  function getWithPath(object4, path, defaultValue2) {
    if (path.length === 0) {
      return defaultValue2;
    }
    let current = object4;
    for (let index = 0; index < path.length; index++) {
      if (current == null) {
        return defaultValue2;
      }
      if (isUnsafeProperty(path[index])) {
        return defaultValue2;
      }
      current = current[path[index]];
    }
    if (current === void 0) {
      return defaultValue2;
    }
    return current;
  }
  function isObject$4(value) {
    return value !== null && (typeof value === "object" || typeof value === "function");
  }
  const IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length2 = Number.MAX_SAFE_INTEGER) {
    switch (typeof value) {
      case "number": {
        return Number.isInteger(value) && value >= 0 && value < length2;
      }
      case "symbol": {
        return false;
      }
      case "string": {
        return IS_UNSIGNED_INTEGER.test(value);
      }
    }
  }
  const regexIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  const regexIsPlainProp = /^\w*$/;
  function isKey(value, object4) {
    if (Array.isArray(value)) {
      return false;
    }
    if (typeof value === "number" || typeof value === "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return typeof value === "string" && (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value)) || object4 != null && Object.hasOwn(object4, value);
  }
  const assignValue = (object4, key, value) => {
    const objValue = object4[key];
    if (!(Object.hasOwn(object4, key) && isEqualsSameValueZero(objValue, value)) || value === void 0 && !(key in object4)) {
      object4[key] = value;
    }
  };
  function updateWith(obj, path, updater, customizer) {
    if (obj == null && !isObject$4(obj)) {
      return obj;
    }
    let resolvedPath;
    if (isKey(path, obj)) {
      resolvedPath = [path];
    } else if (Array.isArray(path)) {
      resolvedPath = path;
    } else {
      resolvedPath = toPath(path);
    }
    const updateValue = updater(get$1(obj, resolvedPath));
    let current = obj;
    for (let i2 = 0; i2 < resolvedPath.length && current != null; i2++) {
      const key = toKey(resolvedPath[i2]);
      if (isUnsafeProperty(key)) {
        continue;
      }
      let newValue;
      if (i2 === resolvedPath.length - 1) {
        newValue = updateValue;
      } else {
        const objValue = current[key];
        const customizerResult = customizer?.(objValue, key, obj);
        newValue = customizerResult !== void 0 ? customizerResult : isObject$4(objValue) ? objValue : isIndex(resolvedPath[i2 + 1]) ? [] : {};
      }
      assignValue(current, key, newValue);
      current = current[key];
    }
    return obj;
  }
  function set$1(obj, path, value) {
    return updateWith(obj, path, () => value, () => void 0);
  }
  function times(n2, getValue2) {
    n2 = toInteger(n2);
    if (n2 < 1 || !Number.isSafeInteger(n2)) {
      return [];
    }
    const result = new Array(n2);
    for (let i2 = 0; i2 < n2; i2++) {
      result[i2] = typeof getValue2 === "function" ? getValue2(i2) : i2;
    }
    return result;
  }
  const TRACK_MEMO_SYMBOL = Symbol();
  const GET_ORIGINAL_SYMBOL = Symbol();
  const AFFECTED_PROPERTY = "a";
  const IS_TARGET_COPIED_PROPERTY = "f";
  const PROXY_PROPERTY = "p";
  const PROXY_CACHE_PROPERTY = "c";
  const TARGET_CACHE_PROPERTY = "t";
  const HAS_KEY_PROPERTY = "h";
  const ALL_OWN_KEYS_PROPERTY = "w";
  const HAS_OWN_KEY_PROPERTY = "o";
  const KEYS_PROPERTY = "k";
  let newProxy$1 = (target, handler) => new Proxy(target, handler);
  const getProto = Object.getPrototypeOf;
  const objectsToTrack = new WeakMap();
  const isObjectToTrack = (obj) => obj && (objectsToTrack.has(obj) ? objectsToTrack.get(obj) : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);
  const isObject$3 = (x) => typeof x === "object" && x !== null;
  const needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);
  const copyTargetObject = (obj) => {
    if (Array.isArray(obj)) {
      return Array.from(obj);
    }
    const descriptors = Object.getOwnPropertyDescriptors(obj);
    Object.values(descriptors).forEach((desc) => {
      desc.configurable = true;
    });
    return Object.create(getProto(obj), descriptors);
  };
  const createProxyHandler = (origObj, isTargetCopied) => {
    const state2 = {
      [IS_TARGET_COPIED_PROPERTY]: isTargetCopied
    };
    let trackObject = false;
    const recordUsage = (type4, key) => {
      if (!trackObject) {
        let used = state2[AFFECTED_PROPERTY].get(origObj);
        if (!used) {
          used = {};
          state2[AFFECTED_PROPERTY].set(origObj, used);
        }
        if (type4 === ALL_OWN_KEYS_PROPERTY) {
          used[ALL_OWN_KEYS_PROPERTY] = true;
        } else {
          let set2 = used[type4];
          if (!set2) {
            set2 = new Set();
            used[type4] = set2;
          }
          set2.add(key);
        }
      }
    };
    const recordObjectAsUsed = () => {
      trackObject = true;
      state2[AFFECTED_PROPERTY].delete(origObj);
    };
    const handler = {
      get(target, key) {
        if (key === GET_ORIGINAL_SYMBOL) {
          return origObj;
        }
        recordUsage(KEYS_PROPERTY, key);
        return createProxy(Reflect.get(target, key), state2[AFFECTED_PROPERTY], state2[PROXY_CACHE_PROPERTY], state2[TARGET_CACHE_PROPERTY]);
      },
      has(target, key) {
        if (key === TRACK_MEMO_SYMBOL) {
          recordObjectAsUsed();
          return true;
        }
        recordUsage(HAS_KEY_PROPERTY, key);
        return Reflect.has(target, key);
      },
      getOwnPropertyDescriptor(target, key) {
        recordUsage(HAS_OWN_KEY_PROPERTY, key);
        return Reflect.getOwnPropertyDescriptor(target, key);
      },
      ownKeys(target) {
        recordUsage(ALL_OWN_KEYS_PROPERTY);
        return Reflect.ownKeys(target);
      }
    };
    if (isTargetCopied) {
      handler.set = handler.deleteProperty = () => false;
    }
    return [handler, state2];
  };
  const getOriginalObject = (obj) => (
obj[GET_ORIGINAL_SYMBOL] ||
obj
  );
  const createProxy = (obj, affected, proxyCache2, targetCache2) => {
    if (!isObjectToTrack(obj))
      return obj;
    let targetAndCopied = targetCache2 && targetCache2.get(obj);
    if (!targetAndCopied) {
      const target2 = getOriginalObject(obj);
      if (needsToCopyTargetObject(target2)) {
        targetAndCopied = [target2, copyTargetObject(target2)];
      } else {
        targetAndCopied = [target2];
      }
      targetCache2 === null || targetCache2 === void 0 ? void 0 : targetCache2.set(obj, targetAndCopied);
    }
    const [target, copiedTarget] = targetAndCopied;
    let handlerAndState = proxyCache2 && proxyCache2.get(target);
    if (!handlerAndState || handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {
      handlerAndState = createProxyHandler(target, !!copiedTarget);
      handlerAndState[1][PROXY_PROPERTY] = newProxy$1(copiedTarget || target, handlerAndState[0]);
      if (proxyCache2) {
        proxyCache2.set(target, handlerAndState);
      }
    }
    handlerAndState[1][AFFECTED_PROPERTY] = affected;
    handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache2;
    handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache2;
    return handlerAndState[1][PROXY_PROPERTY];
  };
  const isAllOwnKeysChanged = (prevObj, nextObj) => {
    const prevKeys = Reflect.ownKeys(prevObj);
    const nextKeys = Reflect.ownKeys(nextObj);
    return prevKeys.length !== nextKeys.length || prevKeys.some((k, i2) => k !== nextKeys[i2]);
  };
  const isChanged = (prevObj, nextObj, affected, cache2, isEqual2 = Object.is) => {
    if (isEqual2(prevObj, nextObj)) {
      return false;
    }
    if (!isObject$3(prevObj) || !isObject$3(nextObj))
      return true;
    const used = affected.get(getOriginalObject(prevObj));
    if (!used)
      return true;
    if (cache2) {
      const hit = cache2.get(prevObj);
      if (hit === nextObj) {
        return false;
      }
      cache2.set(prevObj, nextObj);
    }
    let changed = null;
    for (const key of used[HAS_KEY_PROPERTY] || []) {
      changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);
      if (changed)
        return changed;
    }
    if (used[ALL_OWN_KEYS_PROPERTY] === true) {
      changed = isAllOwnKeysChanged(prevObj, nextObj);
      if (changed)
        return changed;
    } else {
      for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {
        const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);
        const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);
        changed = hasPrev !== hasNext;
        if (changed)
          return changed;
      }
    }
    for (const key of used[KEYS_PROPERTY] || []) {
      changed = isChanged(prevObj[key], nextObj[key], affected, cache2, isEqual2);
      if (changed)
        return changed;
    }
    if (changed === null)
      throw new Error("invalid used");
    return changed;
  };
  const getUntracked = (obj) => {
    if (isObjectToTrack(obj)) {
      return obj[GET_ORIGINAL_SYMBOL] || null;
    }
    return null;
  };
  const markToTrack = (obj, mark = true) => {
    objectsToTrack.set(obj, mark);
  };
  const affectedToPathList = (obj, affected, onlyWithValues) => {
    const list2 = [];
    const seen = new WeakSet();
    const walk = (x, path) => {
      var _a, _b, _c;
      if (seen.has(x)) {
        return;
      }
      if (isObject$3(x)) {
        seen.add(x);
      }
      const used = isObject$3(x) && affected.get(getOriginalObject(x));
      if (used) {
        (_a = used[HAS_KEY_PROPERTY]) === null || _a === void 0 ? void 0 : _a.forEach((key) => {
          const segment = `:has(${String(key)})`;
          list2.push(path ? [...path, segment] : [segment]);
        });
        if (used[ALL_OWN_KEYS_PROPERTY] === true) {
          const segment = ":ownKeys";
          list2.push(path ? [...path, segment] : [segment]);
        } else {
          (_b = used[HAS_OWN_KEY_PROPERTY]) === null || _b === void 0 ? void 0 : _b.forEach((key) => {
            const segment = `:hasOwn(${String(key)})`;
            list2.push(path ? [...path, segment] : [segment]);
          });
        }
        (_c = used[KEYS_PROPERTY]) === null || _c === void 0 ? void 0 : _c.forEach((key) => {
          if ("value" in (Object.getOwnPropertyDescriptor(x, key) || {})) {
            walk(x[key], path ? [...path, key] : [key]);
          }
        });
      } else if (path) {
        list2.push(path);
      }
    };
    walk(obj);
    return list2;
  };
  const __vite_import_meta_env__$1 = {};
  const isObject$2 = (x) => typeof x === "object" && x !== null;
  const canProxyDefault = (x) => isObject$2(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer) && !(x instanceof Promise);
  const createSnapshotDefault = (target, version2) => {
    const cache2 = snapCache$2.get(target);
    if ((cache2 == null ? void 0 : cache2[0]) === version2) {
      return cache2[1];
    }
    const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
    markToTrack(snap, true);
    snapCache$2.set(target, [version2, snap]);
    Reflect.ownKeys(target).forEach((key) => {
      if (Object.getOwnPropertyDescriptor(snap, key)) {
        return;
      }
      const value = Reflect.get(target, key);
      const { enumerable: enumerable4 } = Reflect.getOwnPropertyDescriptor(
        target,
        key
      );
      const desc = {
        value,
        enumerable: enumerable4,

configurable: true
      };
      if (refSet.has(value)) {
        markToTrack(value, false);
      } else if (proxyStateMap$3.has(value)) {
        const [target2, ensureVersion] = proxyStateMap$3.get(
          value
        );
        desc.value = createSnapshotDefault(target2, ensureVersion());
      }
      Object.defineProperty(snap, key, desc);
    });
    return Object.preventExtensions(snap);
  };
  const createHandlerDefault = (isInitializing, addPropListener, removePropListener, notifyUpdate) => ({
    deleteProperty(target, prop) {
      Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(void 0);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      const hasPrevValue = !isInitializing() && Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject$2(value)) {
        value = getUntracked(value) || value;
      }
      const nextValue = !proxyStateMap$3.has(value) && canProxy(value) ? proxy(value) : value;
      addPropListener(prop, nextValue);
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(void 0);
      return true;
    }
  });
  const proxyStateMap$3 = new WeakMap();
  const refSet = new WeakSet();
  const snapCache$2 = new WeakMap();
  const versionHolder = [1];
  const proxyCache = new WeakMap();
  let objectIs = Object.is;
  let newProxy = (target, handler) => new Proxy(target, handler);
  let canProxy = canProxyDefault;
  let createSnapshot = createSnapshotDefault;
  let createHandler = createHandlerDefault;
  function proxy(baseObject = {}) {
    if (!isObject$2(baseObject)) {
      throw new Error("object required");
    }
    const found = proxyCache.get(baseObject);
    if (found) {
      return found;
    }
    let version2 = versionHolder[0];
    const listeners2 = new Set();
    const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
      if (version2 !== nextVersion) {
        checkVersion = version2 = nextVersion;
        listeners2.forEach((listener) => listener(op, nextVersion));
      }
    };
    let checkVersion = version2;
    const ensureVersion = (nextCheckVersion = versionHolder[0]) => {
      if (checkVersion !== nextCheckVersion) {
        checkVersion = nextCheckVersion;
        propProxyStates.forEach(([propProxyState]) => {
          const propVersion = propProxyState[1](nextCheckVersion);
          if (propVersion > version2) {
            version2 = propVersion;
          }
        });
      }
      return version2;
    };
    const createPropListener = (prop) => (op, nextVersion) => {
      let newOp;
      if (op) {
        newOp = [...op];
        newOp[1] = [prop, ...newOp[1]];
      }
      notifyUpdate(newOp, nextVersion);
    };
    const propProxyStates = new Map();
    const addPropListener = (prop, propValue) => {
      const propProxyState = !refSet.has(propValue) && proxyStateMap$3.get(propValue);
      if (propProxyState) {
        if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && propProxyStates.has(prop)) {
          throw new Error("prop listener already exists");
        }
        if (listeners2.size) {
          const remove = propProxyState[2](createPropListener(prop));
          propProxyStates.set(prop, [propProxyState, remove]);
        } else {
          propProxyStates.set(prop, [propProxyState]);
        }
      }
    };
    const removePropListener = (prop) => {
      var _a;
      const entry = propProxyStates.get(prop);
      if (entry) {
        propProxyStates.delete(prop);
        (_a = entry[1]) == null ? void 0 : _a.call(entry);
      }
    };
    const addListener = (listener) => {
      listeners2.add(listener);
      if (listeners2.size === 1) {
        propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
          if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && prevRemove) {
            throw new Error("remove already exists");
          }
          const remove = propProxyState[2](createPropListener(prop));
          propProxyStates.set(prop, [propProxyState, remove]);
        });
      }
      const removeListener = () => {
        listeners2.delete(listener);
        if (listeners2.size === 0) {
          propProxyStates.forEach(([propProxyState, remove], prop) => {
            if (remove) {
              remove();
              propProxyStates.set(prop, [propProxyState]);
            }
          });
        }
      };
      return removeListener;
    };
    let initializing = true;
    const handler = createHandler(
      () => initializing,
      addPropListener,
      removePropListener,
      notifyUpdate
    );
    const proxyObject2 = newProxy(baseObject, handler);
    proxyCache.set(baseObject, proxyObject2);
    const proxyState = [baseObject, ensureVersion, addListener];
    proxyStateMap$3.set(proxyObject2, proxyState);
    Reflect.ownKeys(baseObject).forEach((key) => {
      const desc = Object.getOwnPropertyDescriptor(
        baseObject,
        key
      );
      if ("value" in desc && desc.writable) {
        proxyObject2[key] = baseObject[key];
      }
    });
    initializing = false;
    return proxyObject2;
  }
  function getVersion(proxyObject2) {
    const proxyState = proxyStateMap$3.get(proxyObject2);
    return proxyState == null ? void 0 : proxyState[1]();
  }
  function subscribe$3(proxyObject2, callback, notifyInSync) {
    const proxyState = proxyStateMap$3.get(proxyObject2);
    if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && !proxyState) {
      console.warn("Please use proxy object");
    }
    let promise;
    const ops = [];
    const addListener = proxyState[2];
    let isListenerActive = false;
    const listener = (op) => {
      if (op) {
        ops.push(op);
      }
      if (notifyInSync) {
        callback(ops.splice(0));
        return;
      }
      if (!promise) {
        promise = Promise.resolve().then(() => {
          promise = void 0;
          if (isListenerActive) {
            callback(ops.splice(0));
          }
        });
      }
    };
    const removeListener = addListener(listener);
    isListenerActive = true;
    return () => {
      isListenerActive = false;
      removeListener();
    };
  }
  function snapshot(proxyObject2) {
    const proxyState = proxyStateMap$3.get(proxyObject2);
    if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && !proxyState) {
      console.warn("Please use proxy object");
    }
    const [target, ensureVersion] = proxyState;
    return createSnapshot(target, ensureVersion());
  }
  function ref(obj) {
    refSet.add(obj);
    return obj;
  }
  function unstable_getInternalStates() {
    return {
      proxyStateMap: proxyStateMap$3,
      refSet,
      snapCache: snapCache$2,
      versionHolder,
      proxyCache
    };
  }
  function unstable_replaceInternalFunction(name, fn) {
    switch (name) {
      case "objectIs":
        objectIs = fn(objectIs);
        break;
      case "newProxy":
        newProxy = fn(newProxy);
        break;
      case "canProxy":
        canProxy = fn(canProxy);
        break;
      case "createSnapshot":
        createSnapshot = fn(createSnapshot);
        break;
      case "createHandler":
        createHandler = fn(createHandler);
        break;
      default:
        throw new Error("unknown function");
    }
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function getAugmentedNamespace(n2) {
    if (Object.prototype.hasOwnProperty.call(n2, "__esModule")) return n2;
    var f2 = n2.default;
    if (typeof f2 == "function") {
      var a2 = function a3() {
        var isInstance = false;
        try {
          isInstance = this instanceof a3;
        } catch {
        }
        if (isInstance) {
          return Reflect.construct(f2, arguments, this.constructor);
        }
        return f2.apply(this, arguments);
      };
      a2.prototype = f2.prototype;
    } else a2 = {};
    Object.defineProperty(a2, "__esModule", { value: true });
    Object.keys(n2).forEach(function(k) {
      var d2 = Object.getOwnPropertyDescriptor(n2, k);
      Object.defineProperty(a2, k, d2.get ? d2 : {
        enumerable: true,
        get: function() {
          return n2[k];
        }
      });
    });
    return a2;
  }
  var react = { exports: {} };
  var react_production = {};
  var hasRequiredReact_production;
  function requireReact_production() {
    if (hasRequiredReact_production) return react_production;
    hasRequiredReact_production = 1;
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE2 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var ReactNoopUpdateQueue = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function() {
      },
      enqueueReplaceState: function() {
      },
      enqueueSetState: function() {
      }
    }, assign2 = Object.assign, emptyObject = {};
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
      if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    function ComponentDummy() {
    }
    ComponentDummy.prototype = Component.prototype;
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    assign2(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;
    var isArrayImpl = Array.isArray;
    function noop2() {
    }
    var ReactSharedInternals = { H: null, A: null, T: null, S: null }, hasOwnProperty = Object.prototype.hasOwnProperty;
    function ReactElement(type4, key, props) {
      var refProp = props.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type4,
        key,
        ref: void 0 !== refProp ? refProp : null,
        props
      };
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      return ReactElement(oldElement.type, newKey, oldElement.props);
    }
    function isValidElement(object4) {
      return "object" === typeof object4 && null !== object4 && object4.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key.replace(/[=:]/g, function(match2) {
        return escaperLookup[match2];
      });
    }
    var userProvidedKeyEscapeRegex = /\/+/g;
    function getElementKey(element, index) {
      return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
    }
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch ("string" === typeof thenable.status ? thenable.then(noop2, noop2) : (thenable.status = "pending", thenable.then(
            function(fulfilledValue) {
              "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
            },
            function(error) {
              "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
            }
          )), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array4, escapedPrefix, nameSoFar, callback) {
      var type4 = typeof children;
      if ("undefined" === type4 || "boolean" === type4) children = null;
      var invokeCallback = false;
      if (null === children) invokeCallback = true;
      else
        switch (type4) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE:
                return invokeCallback = children._init, mapIntoArray(
                  invokeCallback(children._payload),
                  array4,
                  escapedPrefix,
                  nameSoFar,
                  callback
                );
            }
        }
      if (invokeCallback)
        return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array4, escapedPrefix, "", function(c2) {
          return c2;
        })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
          callback,
          escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
            userProvidedKeyEscapeRegex,
            "$&/"
          ) + "/") + invokeCallback
        )), array4.push(callback)), 1;
      invokeCallback = 0;
      var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i2 = 0; i2 < children.length; i2++)
          nameSoFar = children[i2], type4 = nextNamePrefix + getElementKey(nameSoFar, i2), invokeCallback += mapIntoArray(
            nameSoFar,
            array4,
            escapedPrefix,
            type4,
            callback
          );
      else if (i2 = getIteratorFn(children), "function" === typeof i2)
        for (children = i2.call(children), i2 = 0; !(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type4 = nextNamePrefix + getElementKey(nameSoFar, i2++), invokeCallback += mapIntoArray(
            nameSoFar,
            array4,
            escapedPrefix,
            type4,
            callback
          );
      else if ("object" === type4) {
        if ("function" === typeof children.then)
          return mapIntoArray(
            resolveThenable(children),
            array4,
            escapedPrefix,
            nameSoFar,
            callback
          );
        array4 = String(children);
        throw Error(
          "Objects are not valid as a React child (found: " + ("[object Object]" === array4 ? "object with keys {" + Object.keys(children).join(", ") + "}" : array4) + "). If you meant to render a collection of children, use an array instead."
        );
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (null == children) return children;
      var result = [], count = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(
          function(moduleObject) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 1, payload._result = moduleObject;
          },
          function(error) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 2, payload._result = error;
          }
        );
        -1 === payload._status && (payload._status = 0, payload._result = ctor);
      }
      if (1 === payload._status) return payload._result.default;
      throw payload._result;
    }
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    }, Children = {
      map: mapChildren,
      forEach: function(children, forEachFunc, forEachContext) {
        mapChildren(
          children,
          function() {
            forEachFunc.apply(this, arguments);
          },
          forEachContext
        );
      },
      count: function(children) {
        var n2 = 0;
        mapChildren(children, function() {
          n2++;
        });
        return n2;
      },
      toArray: function(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      },
      only: function(children) {
        if (!isValidElement(children))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return children;
      }
    };
    react_production.Activity = REACT_ACTIVITY_TYPE;
    react_production.Children = Children;
    react_production.Component = Component;
    react_production.Fragment = REACT_FRAGMENT_TYPE2;
    react_production.Profiler = REACT_PROFILER_TYPE;
    react_production.PureComponent = PureComponent;
    react_production.StrictMode = REACT_STRICT_MODE_TYPE;
    react_production.Suspense = REACT_SUSPENSE_TYPE;
    react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    react_production.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function(size) {
        return ReactSharedInternals.H.useMemoCache(size);
      }
    };
    react_production.cache = function(fn) {
      return function() {
        return fn.apply(null, arguments);
      };
    };
    react_production.cacheSignal = function() {
      return null;
    };
    react_production.cloneElement = function(element, config, children) {
      if (null === element || void 0 === element)
        throw Error(
          "The argument must be a React element, but you passed " + element + "."
        );
      var props = assign2({}, element.props), key = element.key;
      if (null != config)
        for (propName in void 0 !== config.key && (key = "" + config.key), config)
          !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;
      else if (1 < propName) {
        for (var childArray = Array(propName), i2 = 0; i2 < propName; i2++)
          childArray[i2] = arguments[i2 + 2];
        props.children = childArray;
      }
      return ReactElement(element.type, key, props);
    };
    react_production.createContext = function(defaultValue2) {
      defaultValue2 = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue2,
        _currentValue2: defaultValue2,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue2.Provider = defaultValue2;
      defaultValue2.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue2
      };
      return defaultValue2;
    };
    react_production.createElement = function(type4, config, children) {
      var propName, props = {}, key = null;
      if (null != config)
        for (propName in void 0 !== config.key && (key = "" + config.key), config)
          hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) props.children = children;
      else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), i2 = 0; i2 < childrenLength; i2++)
          childArray[i2] = arguments[i2 + 2];
        props.children = childArray;
      }
      if (type4 && type4.defaultProps)
        for (propName in childrenLength = type4.defaultProps, childrenLength)
          void 0 === props[propName] && (props[propName] = childrenLength[propName]);
      return ReactElement(type4, key, props);
    };
    react_production.createRef = function() {
      return { current: null };
    };
    react_production.forwardRef = function(render4) {
      return { $$typeof: REACT_FORWARD_REF_TYPE, render: render4 };
    };
    react_production.isValidElement = isValidElement;
    react_production.lazy = function(ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer
      };
    };
    react_production.memo = function(type4, compare) {
      return {
        $$typeof: REACT_MEMO_TYPE,
        type: type4,
        compare: void 0 === compare ? null : compare
      };
    };
    react_production.startTransition = function(scope) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop2, reportGlobalError);
      } catch (error) {
        reportGlobalError(error);
      } finally {
        null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
      }
    };
    react_production.unstable_useCacheRefresh = function() {
      return ReactSharedInternals.H.useCacheRefresh();
    };
    react_production.use = function(usable) {
      return ReactSharedInternals.H.use(usable);
    };
    react_production.useActionState = function(action2, initialState, permalink) {
      return ReactSharedInternals.H.useActionState(action2, initialState, permalink);
    };
    react_production.useCallback = function(callback, deps) {
      return ReactSharedInternals.H.useCallback(callback, deps);
    };
    react_production.useContext = function(Context2) {
      return ReactSharedInternals.H.useContext(Context2);
    };
    react_production.useDebugValue = function() {
    };
    react_production.useDeferredValue = function(value, initialValue2) {
      return ReactSharedInternals.H.useDeferredValue(value, initialValue2);
    };
    react_production.useEffect = function(create, deps) {
      return ReactSharedInternals.H.useEffect(create, deps);
    };
    react_production.useEffectEvent = function(callback) {
      return ReactSharedInternals.H.useEffectEvent(callback);
    };
    react_production.useId = function() {
      return ReactSharedInternals.H.useId();
    };
    react_production.useImperativeHandle = function(ref2, create, deps) {
      return ReactSharedInternals.H.useImperativeHandle(ref2, create, deps);
    };
    react_production.useInsertionEffect = function(create, deps) {
      return ReactSharedInternals.H.useInsertionEffect(create, deps);
    };
    react_production.useLayoutEffect = function(create, deps) {
      return ReactSharedInternals.H.useLayoutEffect(create, deps);
    };
    react_production.useMemo = function(create, deps) {
      return ReactSharedInternals.H.useMemo(create, deps);
    };
    react_production.useOptimistic = function(passthrough, reducer2) {
      return ReactSharedInternals.H.useOptimistic(passthrough, reducer2);
    };
    react_production.useReducer = function(reducer2, initialArg, init) {
      return ReactSharedInternals.H.useReducer(reducer2, initialArg, init);
    };
    react_production.useRef = function(initialValue2) {
      return ReactSharedInternals.H.useRef(initialValue2);
    };
    react_production.useState = function(initialState) {
      return ReactSharedInternals.H.useState(initialState);
    };
    react_production.useSyncExternalStore = function(subscribe2, getSnapshot, getServerSnapshot) {
      return ReactSharedInternals.H.useSyncExternalStore(
        subscribe2,
        getSnapshot,
        getServerSnapshot
      );
    };
    react_production.useTransition = function() {
      return ReactSharedInternals.H.useTransition();
    };
    react_production.version = "19.2.4";
    return react_production;
  }
  var hasRequiredReact;
  function requireReact() {
    if (hasRequiredReact) return react.exports;
    hasRequiredReact = 1;
    {
      react.exports = requireReact_production();
    }
    return react.exports;
  }
  var reactExports = requireReact();
  const React = getDefaultExportFromCjs(reactExports);
  const React3 = _mergeNamespaces$1({
    __proto__: null,
    default: React
  }, [reactExports]);
  const __vite_import_meta_env__ = {};
  const useAffectedDebugValue = (state2, affected) => {
    const pathList = reactExports.useRef(void 0);
    reactExports.useEffect(() => {
      pathList.current = affectedToPathList(state2, affected);
    });
    reactExports.useDebugValue(pathList.current);
  };
  const condUseAffectedDebugValue = useAffectedDebugValue;
  const targetCache = new WeakMap();
  function useSnapshot(proxyObject2, options) {
    const notifyInSync = options == null ? void 0 : options.sync;
    const affected = reactExports.useMemo(
      () => proxyObject2 && new WeakMap(),
      [proxyObject2]
    );
    const lastSnapshot = reactExports.useRef(void 0);
    const subscribed = reactExports.useRef(false);
    const currSnapshot = reactExports.useSyncExternalStore(
      reactExports.useCallback(
        (callback) => {
          subscribed.current = true;
          const unsub = subscribe$3(proxyObject2, callback, notifyInSync);
          callback();
          return () => {
            unsub();
            subscribed.current = false;
          };
        },
        [proxyObject2, notifyInSync]
      ),
      () => {
        const nextSnapshot = snapshot(proxyObject2);
        try {
          if (subscribed.current && lastSnapshot.current && !isChanged(
            lastSnapshot.current,
            nextSnapshot,
            affected,
new WeakMap()
          )) {
            return lastSnapshot.current;
          }
        } catch (e) {
        }
        return nextSnapshot;
      },
      () => snapshot(proxyObject2)
    );
    reactExports.useLayoutEffect(() => {
      lastSnapshot.current = currSnapshot;
    });
    if ((__vite_import_meta_env__ ? "production" : void 0) !== "production") {
      condUseAffectedDebugValue(currSnapshot, affected);
    }
    const proxyCache2 = reactExports.useMemo(() => new WeakMap(), []);
    return createProxy(currSnapshot, affected, proxyCache2, targetCache);
  }
  function coerce(value) {
    if (value instanceof Error) return value.stack || value.message;
    return value;
  }
  function selectColor(colors2, namespace) {
    let hash2 = 0;
    for (let i2 = 0; i2 < namespace.length; i2++) {
      hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i2);
      hash2 |= 0;
    }
    return colors2[Math.abs(hash2) % colors2.length];
  }
  function matchesTemplate(search, template) {
    let searchIndex = 0;
    let templateIndex = 0;
    let starIndex = -1;
    let matchIndex = 0;
    while (searchIndex < search.length) if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) if (template[templateIndex] === "*") {
      starIndex = templateIndex;
      matchIndex = searchIndex;
      templateIndex++;
    } else {
      searchIndex++;
      templateIndex++;
    }
    else if (starIndex !== -1) {
      templateIndex = starIndex + 1;
      matchIndex++;
      searchIndex = matchIndex;
    } else return false;
    while (templateIndex < template.length && template[templateIndex] === "*") templateIndex++;
    return templateIndex === template.length;
  }
  function humanize(value) {
    if (value >= 1e3) return `${(value / 1e3).toFixed(1)}s`;
    return `${value}ms`;
  }
  let globalNamespaces = "";
  function createDebug$1(namespace, options) {
    let prevTime;
    let enableOverride;
    let namespacesCache;
    let enabledCache;
    const debug2 = (...args) => {
      if (!debug2.enabled) return;
      const curr = Date.now();
      const diff = curr - (prevTime || curr);
      prevTime = curr;
      args[0] = coerce(args[0]);
      if (typeof args[0] !== "string") args.unshift("%O");
      let index = 0;
      args[0] = args[0].replace(/%([a-z%])/gi, (match2, format2) => {
        if (match2 === "%%") return "%";
        index++;
        const formatter = options.formatters[format2];
        if (typeof formatter === "function") {
          const value = args[index];
          match2 = formatter.call(debug2, value);
          args.splice(index, 1);
          index--;
        }
        return match2;
      });
      options.formatArgs.call(debug2, diff, args);
      debug2.log(...args);
    };
    debug2.extend = function(namespace$1, delimiter2 = ":") {
      return createDebug$1(this.namespace + delimiter2 + namespace$1, {
        useColors: this.useColors,
        color: this.color,
        formatArgs: this.formatArgs,
        formatters: this.formatters,
        inspectOpts: this.inspectOpts,
        log: this.log,
        humanize: this.humanize
      });
    };
    Object.assign(debug2, options);
    debug2.namespace = namespace;
    Object.defineProperty(debug2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride != null) return enableOverride;
        if (namespacesCache !== globalNamespaces) {
          namespacesCache = globalNamespaces;
          enabledCache = enabled(namespace);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    return debug2;
  }
  let names = [];
  let skips = [];
  function enable(namespaces$1) {
    globalNamespaces = namespaces$1;
    names = [];
    skips = [];
    const split = globalNamespaces.trim().replace(/\s+/g, ",").split(",").filter(Boolean);
    for (const ns of split) if (ns[0] === "-") skips.push(ns.slice(1));
    else names.push(ns);
  }
  function enabled(name) {
    for (const skip of skips) if (matchesTemplate(name, skip)) return false;
    for (const ns of names) if (matchesTemplate(name, ns)) return true;
    return false;
  }
  var define_process_env_default = {};
  const colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function formatArgs(diff, args) {
    const { useColors } = this;
    args[0] = `${(useColors ? "%c" : "") + this.namespace + (useColors ? " %c" : " ") + args[0] + (useColors ? "%c " : " ")}+${this.humanize(diff)}`;
    if (!useColors) return;
    const c2 = `color: ${this.color}`;
    args.splice(1, 0, c2, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-z%]/gi, (match2) => {
      if (match2 === "%%") return;
      index++;
      if (match2 === "%c") lastC = index;
    });
    args.splice(lastC, 0, c2);
  }
  const log = console.debug || console.log || (() => {
  });
  const storage = localstorage();
  const defaultOptions$1 = {
    useColors: true,
    formatArgs,
    formatters: { j(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return `[UnexpectedJSONParseError]: ${error.message}`;
      }
    } },
    inspectOpts: {},
    humanize,
    log
  };
  function createDebug(namespace, options) {
    var _ref4;
    const color2 = (_ref4 = options) !== null && _ref4 !== void 0 ? _ref4 : selectColor(colors, namespace);
    return createDebug$1(namespace, Object.assign(defaultOptions$1, { color: color2 }, options));
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (_unused) {
    }
  }
  function load() {
    let r2;
    try {
      r2 = storage.getItem("debug") || storage.getItem("DEBUG");
    } catch (_unused2) {
    }
    if (!r2 && typeof process !== "undefined" && "env" in process) r2 = define_process_env_default.DEBUG;
    return r2 || "";
  }
  enable(load());
  const APP_NAME = "Bilibili-Gate";
  const APP_NAMESPACE = "bilibili-gate";
  const APP_KEY_PREFIX = "bilibili_gate";
  const APP_SHORT_PREFIX = "bili-gate";
  const baseDebug = createDebug(APP_NAMESPACE);
  const HOST_API = "https://api.bilibili.com";
  const HOST_APP = "https://app.bilibili.com";
  const TVKeyInfo = {
    appkey: "4409e2ce8ffd12b8",
    appsec: "59b43e04ad6965f34319062b478f83dd"
  };
  const APP_CLS_ROOT = `${APP_NAMESPACE}-root`;
  const APP_CLS_GRID = `${APP_NAMESPACE}-video-grid`;
  const APP_CLS_CARD = `${APP_NAMESPACE}-video-card`;
  const APP_CLS_CARD_ACTIVE = `${APP_NAMESPACE}-video-card-active`;
  const APP_CLS_CARD_COVER = `${APP_NAMESPACE}-video-card-cover`;
  const APP_CLS_TAB_BAR = `${APP_NAMESPACE}-tab-bar`;
  const APP_CLS_CARD_RECOMMEND_REASON = `${APP_NAMESPACE}-video-card__recommend-reason`;
  const REQUEST_FAIL_MSG = "请求失败, 请重试 !!!";
  const OPERATION_FAIL_MSG = "操作失败, 请重试 !!!";
  const TLD = "bilibili.com";
  var BiliDomain = ((BiliDomain2) => {
    BiliDomain2[BiliDomain2["Tld"] = TLD] = "Tld";
    BiliDomain2["Main"] = `www.${TLD}`;
    BiliDomain2["Space"] = `space.${TLD}`;
    BiliDomain2["Search"] = `search.${TLD}`;
    return BiliDomain2;
  })(BiliDomain || {});
  const {
    hostname,
    pathname
  } = location;
  hostname === BiliDomain.Tld || hostname.endsWith(`.${BiliDomain.Tld}`);
  const IN_BILIBILI_MAIN = [BiliDomain.Tld, BiliDomain.Main].includes(hostname);
  const IN_BILIBILI_SPACE_PAGE = hostname === BiliDomain.Space;
  const IN_BILIBILI_SEARCH_PAGE = hostname === BiliDomain.Search;
  const IN_BILIBILI_HOMEPAGE = IN_BILIBILI_MAIN && (pathname === "/" || pathname === "/index.html");
  function logFactory(logFn) {
    return function appLog2(...args) {
      const [message2, ...rest] = args;
      const label = `%c${APP_NAME}%c`;
      const labelFormats = ["padding: 2px 4px; border-radius: 4px; color: #fff; background: #01847f; font-weight: bold;", ""];
      if (typeof message2 === "string") {
        return logFn(`${label} ${message2}`, ...labelFormats, ...rest);
      } else {
        return logFn(`${label}`, ...labelFormats, message2, ...rest);
      }
    };
  }
  const appLog = logFactory(console.log);
  const appWarn = logFactory(console.warn);
  const appError = logFactory(console.error);
  var BiliBrandColor = ((BiliBrandColor2) => {
    BiliBrandColor2["Pink"] = "#f69";
    BiliBrandColor2["Blue"] = "#00aeec";
    return BiliBrandColor2;
  })(BiliBrandColor || {});
  var ETab = ((ETab2) => {
    ETab2["AppRecommend"] = "app-recommend";
    ETab2["PcRecommend"] = "pc-recommend";
    ETab2["KeepFollowOnly"] = "keep-follow-only";
    ETab2["DynamicFeed"] = "dynamic-feed";
    ETab2["Watchlater"] = "watchlater";
    ETab2["Fav"] = "fav";
    ETab2["Hot"] = "hot";
    ETab2["Live"] = "live";
    ETab2["SpaceUpload"] = "space-upload";
    ETab2["Liked"] = "liked";
    return ETab2;
  })(ETab || {});
  var EHotSubTab = ((EHotSubTab2) => {
    EHotSubTab2["PopularGeneral"] = "popular-general";
    EHotSubTab2["PopularWeekly"] = "popular-weekly";
    EHotSubTab2["Rank"] = "ranking";
    return EHotSubTab2;
  })(EHotSubTab || {});
  const ALL_TAB_KEYS = Object.values(ETab);
  const NONE_CONFIGURABLE_TAB_KEYS = [
    "space-upload"
];
  const CONFIGURABLE_TAB_KEYS = difference(ALL_TAB_KEYS, NONE_CONFIGURABLE_TAB_KEYS);
  var jsxRuntime = { exports: {} };
  var reactJsxRuntime_production = {};
  var hasRequiredReactJsxRuntime_production;
  function requireReactJsxRuntime_production() {
    if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
    hasRequiredReactJsxRuntime_production = 1;
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE2 = Symbol.for("react.fragment");
    function jsxProd(type4, config, maybeKey) {
      var key = null;
      void 0 !== maybeKey && (key = "" + maybeKey);
      void 0 !== config.key && (key = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      config = maybeKey.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type: type4,
        key,
        ref: void 0 !== config ? config : null,
        props: maybeKey
      };
    }
    reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE2;
    reactJsxRuntime_production.jsx = jsxProd;
    reactJsxRuntime_production.jsxs = jsxProd;
    return reactJsxRuntime_production;
  }
  var hasRequiredJsxRuntime;
  function requireJsxRuntime() {
    if (hasRequiredJsxRuntime) return jsxRuntime.exports;
    hasRequiredJsxRuntime = 1;
    {
      jsxRuntime.exports = requireReactJsxRuntime_production();
    }
    return jsxRuntime.exports;
  }
  var jsxRuntimeExports = requireJsxRuntime();
  function sheetForTag(tag) {
    if (tag.sheet) {
      return tag.sheet;
    }
    for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
      if (document.styleSheets[i2].ownerNode === tag) {
        return document.styleSheets[i2];
      }
    }
    return void 0;
  }
  function createStyleElement(options) {
    var tag = document.createElement("style");
    tag.setAttribute("data-emotion", options.key);
    if (options.nonce !== void 0) {
      tag.setAttribute("nonce", options.nonce);
    }
    tag.appendChild(document.createTextNode(""));
    tag.setAttribute("data-s", "");
    return tag;
  }
  var StyleSheet = (function() {
    function StyleSheet2(options) {
      var _this = this;
      this._insertTag = function(tag) {
        var before;
        if (_this.tags.length === 0) {
          if (_this.insertionPoint) {
            before = _this.insertionPoint.nextSibling;
          } else if (_this.prepend) {
            before = _this.container.firstChild;
          } else {
            before = _this.before;
          }
        } else {
          before = _this.tags[_this.tags.length - 1].nextSibling;
        }
        _this.container.insertBefore(tag, before);
        _this.tags.push(tag);
      };
      this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
      this.tags = [];
      this.ctr = 0;
      this.nonce = options.nonce;
      this.key = options.key;
      this.container = options.container;
      this.prepend = options.prepend;
      this.insertionPoint = options.insertionPoint;
      this.before = null;
    }
    var _proto = StyleSheet2.prototype;
    _proto.hydrate = function hydrate(nodes) {
      nodes.forEach(this._insertTag);
    };
    _proto.insert = function insert(rule) {
      if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
        this._insertTag(createStyleElement(this));
      }
      var tag = this.tags[this.tags.length - 1];
      if (this.isSpeedy) {
        var sheet = sheetForTag(tag);
        try {
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (e) {
        }
      } else {
        tag.appendChild(document.createTextNode(rule));
      }
      this.ctr++;
    };
    _proto.flush = function flush() {
      this.tags.forEach(function(tag) {
        var _tag$parentNode;
        return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
      });
      this.tags = [];
      this.ctr = 0;
    };
    return StyleSheet2;
  })();
  var MS$1 = "-ms-";
  var MOZ$1 = "-moz-";
  var WEBKIT$1 = "-webkit-";
  var COMMENT$1 = "comm";
  var RULESET$1 = "rule";
  var DECLARATION$1 = "decl";
  var IMPORT$1 = "@import";
  var KEYFRAMES$1 = "@keyframes";
  var LAYER$1 = "@layer";
  var abs$1 = Math.abs;
  var from$1 = String.fromCharCode;
  var assign$1 = Object.assign;
  function hash$1(value, length2) {
    return charat$1(value, 0) ^ 45 ? (((length2 << 2 ^ charat$1(value, 0)) << 2 ^ charat$1(value, 1)) << 2 ^ charat$1(value, 2)) << 2 ^ charat$1(value, 3) : 0;
  }
  function trim$1(value) {
    return value.trim();
  }
  function match$2(value, pattern4) {
    return (value = pattern4.exec(value)) ? value[0] : value;
  }
  function replace$1(value, pattern4, replacement) {
    return value.replace(pattern4, replacement);
  }
  function indexof$1(value, search) {
    return value.indexOf(search);
  }
  function charat$1(value, index) {
    return value.charCodeAt(index) | 0;
  }
  function substr$1(value, begin, end) {
    return value.slice(begin, end);
  }
  function strlen$1(value) {
    return value.length;
  }
  function sizeof$1(value) {
    return value.length;
  }
  function append$1(value, array4) {
    return array4.push(value), value;
  }
  function combine$1(array4, callback) {
    return array4.map(callback).join("");
  }
  var line$1 = 1;
  var column$1 = 1;
  var length$1 = 0;
  var position$2 = 0;
  var character$1 = 0;
  var characters$1 = "";
  function node$1(value, root2, parent, type4, props, children, length2) {
    return { value, root: root2, parent, type: type4, props, children, line: line$1, column: column$1, length: length2, return: "" };
  }
  function copy$1(root2, props) {
    return assign$1(node$1("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
  }
  function char$1() {
    return character$1;
  }
  function prev$1() {
    character$1 = position$2 > 0 ? charat$1(characters$1, --position$2) : 0;
    if (column$1--, character$1 === 10)
      column$1 = 1, line$1--;
    return character$1;
  }
  function next$1() {
    character$1 = position$2 < length$1 ? charat$1(characters$1, position$2++) : 0;
    if (column$1++, character$1 === 10)
      column$1 = 1, line$1++;
    return character$1;
  }
  function peek$1() {
    return charat$1(characters$1, position$2);
  }
  function caret$1() {
    return position$2;
  }
  function slice$1(begin, end) {
    return substr$1(characters$1, begin, end);
  }
  function token$1(type4) {
    switch (type4) {
case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
case 59:
      case 123:
      case 125:
        return 4;
case 58:
        return 3;
case 34:
      case 39:
      case 40:
      case 91:
        return 2;
case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc$1(value) {
    return line$1 = column$1 = 1, length$1 = strlen$1(characters$1 = value), position$2 = 0, [];
  }
  function dealloc$1(value) {
    return characters$1 = "", value;
  }
  function delimit$1(type4) {
    return trim$1(slice$1(position$2 - 1, delimiter$1(type4 === 91 ? type4 + 2 : type4 === 40 ? type4 + 1 : type4)));
  }
  function whitespace$2(type4) {
    while (character$1 = peek$1())
      if (character$1 < 33)
        next$1();
      else
        break;
    return token$1(type4) > 2 || token$1(character$1) > 3 ? "" : " ";
  }
  function escaping$1(index, count) {
    while (--count && next$1())
      if (character$1 < 48 || character$1 > 102 || character$1 > 57 && character$1 < 65 || character$1 > 70 && character$1 < 97)
        break;
    return slice$1(index, caret$1() + (count < 6 && peek$1() == 32 && next$1() == 32));
  }
  function delimiter$1(type4) {
    while (next$1())
      switch (character$1) {
case type4:
          return position$2;
case 34:
        case 39:
          if (type4 !== 34 && type4 !== 39)
            delimiter$1(character$1);
          break;
case 40:
          if (type4 === 41)
            delimiter$1(type4);
          break;
case 92:
          next$1();
          break;
      }
    return position$2;
  }
  function commenter$1(type4, index) {
    while (next$1())
      if (type4 + character$1 === 47 + 10)
        break;
      else if (type4 + character$1 === 42 + 42 && peek$1() === 47)
        break;
    return "/*" + slice$1(index, position$2 - 1) + "*" + from$1(type4 === 47 ? type4 : next$1());
  }
  function identifier$1(index) {
    while (!token$1(peek$1()))
      next$1();
    return slice$1(index, position$2);
  }
  function compile$1(value) {
    return dealloc$1(parse$1("", null, null, null, [""], value = alloc$1(value), 0, [0], value));
  }
  function parse$1(value, root2, parent, rule, rules2, rulesets, pseudo, points, declarations) {
    var index = 0;
    var offset2 = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type4 = "";
    var props = rules2;
    var children = rulesets;
    var reference = rule;
    var characters2 = type4;
    while (scanning)
      switch (previous = character2, character2 = next$1()) {
case 40:
          if (previous != 108 && charat$1(characters2, length2 - 1) == 58) {
            if (indexof$1(characters2 += replace$1(delimit$1(character2), "&", "&\f"), "&\f") != -1)
              ampersand = -1;
            break;
          }
case 34:
        case 39:
        case 91:
          characters2 += delimit$1(character2);
          break;
case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace$2(previous);
          break;
case 92:
          characters2 += escaping$1(caret$1() - 1, 7);
          continue;
case 47:
          switch (peek$1()) {
            case 42:
            case 47:
              append$1(comment$1(commenter$1(next$1(), caret$1()), root2, parent), declarations);
              break;
            default:
              characters2 += "/";
          }
          break;
case 123 * variable:
          points[index++] = strlen$1(characters2) * ampersand;
case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
case 0:
            case 125:
              scanning = 0;
case 59 + offset2:
              if (ampersand == -1) characters2 = replace$1(characters2, /\f/g, "");
              if (property > 0 && strlen$1(characters2) - length2)
                append$1(property > 32 ? declaration$1(characters2 + ";", rule, parent, length2 - 1) : declaration$1(replace$1(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
              break;
case 59:
              characters2 += ";";
default:
              append$1(reference = ruleset$1(characters2, root2, parent, index, offset2, rules2, points, type4, props = [], children = [], length2), rulesets);
              if (character2 === 123)
                if (offset2 === 0)
                  parse$1(characters2, root2, reference, reference, props, rulesets, length2, points, children);
                else
                  switch (atrule === 99 && charat$1(characters2, 3) === 110 ? 100 : atrule) {
case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse$1(value, reference, reference, rule && append$1(ruleset$1(value, reference, reference, 0, 0, rules2, points, type4, rules2, props = [], length2), children), rules2, children, length2, points, rule ? props : children);
                      break;
                    default:
                      parse$1(characters2, reference, reference, reference, [""], children, 0, points, children);
                  }
          }
          index = offset2 = property = 0, variable = ampersand = 1, type4 = characters2 = "", length2 = pseudo;
          break;
case 58:
          length2 = 1 + strlen$1(characters2), property = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev$1() == 125)
              continue;
          }
          switch (characters2 += from$1(character2), character2 * variable) {
case 38:
              ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
              break;
case 44:
              points[index++] = (strlen$1(characters2) - 1) * ampersand, ampersand = 1;
              break;
case 64:
              if (peek$1() === 45)
                characters2 += delimit$1(next$1());
              atrule = peek$1(), offset2 = length2 = strlen$1(type4 = characters2 += identifier$1(caret$1())), character2++;
              break;
case 45:
              if (previous === 45 && strlen$1(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset$1(value, root2, parent, index, offset2, rules2, points, type4, props, children, length2) {
    var post = offset2 - 1;
    var rule = offset2 === 0 ? rules2 : [""];
    var size = sizeof$1(rule);
    for (var i2 = 0, j = 0, k = 0; i2 < index; ++i2)
      for (var x = 0, y = substr$1(value, post + 1, post = abs$1(j = points[i2])), z = value; x < size; ++x)
        if (z = trim$1(j > 0 ? rule[x] + " " + y : replace$1(y, /&\f/g, rule[x])))
          props[k++] = z;
    return node$1(value, root2, parent, offset2 === 0 ? RULESET$1 : type4, props, children, length2);
  }
  function comment$1(value, root2, parent) {
    return node$1(value, root2, parent, COMMENT$1, from$1(char$1()), substr$1(value, 2, -2), 0);
  }
  function declaration$1(value, root2, parent, length2) {
    return node$1(value, root2, parent, DECLARATION$1, substr$1(value, 0, length2), substr$1(value, length2 + 1, -1), length2);
  }
  function serialize$1(children, callback) {
    var output = "";
    var length2 = sizeof$1(children);
    for (var i2 = 0; i2 < length2; i2++)
      output += callback(children[i2], i2, children, callback) || "";
    return output;
  }
  function stringify$3(element, index, children, callback) {
    switch (element.type) {
      case LAYER$1:
        if (element.children.length) break;
      case IMPORT$1:
      case DECLARATION$1:
        return element.return = element.return || element.value;
      case COMMENT$1:
        return "";
      case KEYFRAMES$1:
        return element.return = element.value + "{" + serialize$1(element.children, callback) + "}";
      case RULESET$1:
        element.value = element.props.join(",");
    }
    return strlen$1(children = serialize$1(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
  }
  function middleware$1(collection) {
    var length2 = sizeof$1(collection);
    return function(element, index, children, callback) {
      var output = "";
      for (var i2 = 0; i2 < length2; i2++)
        output += collection[i2](element, index, children, callback) || "";
      return output;
    };
  }
  function rulesheet(callback) {
    return function(element) {
      if (!element.root) {
        if (element = element.return)
          callback(element);
      }
    };
  }
  function memoize(fn) {
    var cache2 = Object.create(null);
    return function(arg) {
      if (cache2[arg] === void 0) cache2[arg] = fn(arg);
      return cache2[arg];
    };
  }
  var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
    var previous = 0;
    var character2 = 0;
    while (true) {
      previous = character2;
      character2 = peek$1();
      if (previous === 38 && character2 === 12) {
        points[index] = 1;
      }
      if (token$1(character2)) {
        break;
      }
      next$1();
    }
    return slice$1(begin, position$2);
  };
  var toRules = function toRules2(parsed2, points) {
    var index = -1;
    var character2 = 44;
    do {
      switch (token$1(character2)) {
        case 0:
          if (character2 === 38 && peek$1() === 12) {
            points[index] = 1;
          }
          parsed2[index] += identifierWithPointTracking(position$2 - 1, points, index);
          break;
        case 2:
          parsed2[index] += delimit$1(character2);
          break;
        case 4:
          if (character2 === 44) {
            parsed2[++index] = peek$1() === 58 ? "&\f" : "";
            points[index] = parsed2[index].length;
            break;
          }
default:
          parsed2[index] += from$1(character2);
      }
    } while (character2 = next$1());
    return parsed2;
  };
  var getRules = function getRules2(value, points) {
    return dealloc$1(toRules(alloc$1(value), points));
  };
  var fixedElements = new WeakMap();
  var compat = function compat2(element) {
    if (element.type !== "rule" || !element.parent ||

element.length < 1) {
      return;
    }
    var value = element.value;
    var parent = element.parent;
    var isImplicitRule = element.column === parent.column && element.line === parent.line;
    while (parent.type !== "rule") {
      parent = parent.parent;
      if (!parent) return;
    }
    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
      return;
    }
    if (isImplicitRule) {
      return;
    }
    fixedElements.set(element, true);
    var points = [];
    var rules2 = getRules(value, points);
    var parentRules = parent.props;
    for (var i2 = 0, k = 0; i2 < rules2.length; i2++) {
      for (var j = 0; j < parentRules.length; j++, k++) {
        element.props[k] = points[i2] ? rules2[i2].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules2[i2];
      }
    }
  };
  var removeLabel = function removeLabel2(element) {
    if (element.type === "decl") {
      var value = element.value;
      if (
value.charCodeAt(0) === 108 &&
value.charCodeAt(2) === 98
      ) {
        element["return"] = "";
        element.value = "";
      }
    }
  };
  function prefix$1(value, length2) {
    switch (hash$1(value, length2)) {
case 5103:
        return WEBKIT$1 + "print-" + value + value;
case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return WEBKIT$1 + value + value;
case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return WEBKIT$1 + value + MOZ$1 + value + MS$1 + value + value;
case 6828:
      case 4268:
        return WEBKIT$1 + value + MS$1 + value + value;
case 6165:
        return WEBKIT$1 + value + MS$1 + "flex-" + value + value;
case 5187:
        return WEBKIT$1 + value + replace$1(value, /(\w+).+(:[^]+)/, WEBKIT$1 + "box-$1$2" + MS$1 + "flex-$1$2") + value;
case 5443:
        return WEBKIT$1 + value + MS$1 + "flex-item-" + replace$1(value, /flex-|-self/, "") + value;
case 4675:
        return WEBKIT$1 + value + MS$1 + "flex-line-pack" + replace$1(value, /align-content|flex-|-self/, "") + value;
case 5548:
        return WEBKIT$1 + value + MS$1 + replace$1(value, "shrink", "negative") + value;
case 5292:
        return WEBKIT$1 + value + MS$1 + replace$1(value, "basis", "preferred-size") + value;
case 6060:
        return WEBKIT$1 + "box-" + replace$1(value, "-grow", "") + WEBKIT$1 + value + MS$1 + replace$1(value, "grow", "positive") + value;
case 4554:
        return WEBKIT$1 + replace$1(value, /([^-])(transform)/g, "$1" + WEBKIT$1 + "$2") + value;
case 6187:
        return replace$1(replace$1(replace$1(value, /(zoom-|grab)/, WEBKIT$1 + "$1"), /(image-set)/, WEBKIT$1 + "$1"), value, "") + value;
case 5495:
      case 3959:
        return replace$1(value, /(image-set\([^]*)/, WEBKIT$1 + "$1$`$1");
case 4968:
        return replace$1(replace$1(value, /(.+:)(flex-)?(.*)/, WEBKIT$1 + "box-pack:$3" + MS$1 + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT$1 + value + value;
case 4095:
      case 3583:
      case 4068:
      case 2532:
        return replace$1(value, /(.+)-inline(.+)/, WEBKIT$1 + "$1$2") + value;
case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (strlen$1(value) - 1 - length2 > 6) switch (charat$1(value, length2 + 1)) {
case 109:
            if (charat$1(value, length2 + 4) !== 45) break;
case 102:
            return replace$1(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT$1 + "$2-$3$1" + MOZ$1 + (charat$1(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
case 115:
            return ~indexof$1(value, "stretch") ? prefix$1(replace$1(value, "stretch", "fill-available"), length2) + value : value;
        }
        break;
case 4949:
        if (charat$1(value, length2 + 1) !== 115) break;
case 6444:
        switch (charat$1(value, strlen$1(value) - 3 - (~indexof$1(value, "!important") && 10))) {
case 107:
            return replace$1(value, ":", ":" + WEBKIT$1) + value;
case 101:
            return replace$1(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT$1 + (charat$1(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT$1 + "$2$3$1" + MS$1 + "$2box$3") + value;
        }
        break;
case 5936:
        switch (charat$1(value, length2 + 11)) {
case 114:
            return WEBKIT$1 + value + MS$1 + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
case 108:
            return WEBKIT$1 + value + MS$1 + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
case 45:
            return WEBKIT$1 + value + MS$1 + replace$1(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
        }
        return WEBKIT$1 + value + MS$1 + value + value;
    }
    return value;
  }
  var prefixer$1 = function prefixer(element, index, children, callback) {
    if (element.length > -1) {
      if (!element["return"]) switch (element.type) {
        case DECLARATION$1:
          element["return"] = prefix$1(element.value, element.length);
          break;
        case KEYFRAMES$1:
          return serialize$1([copy$1(element, {
            value: replace$1(element.value, "@", "@" + WEBKIT$1)
          })], callback);
        case RULESET$1:
          if (element.length) return combine$1(element.props, function(value) {
            switch (match$2(value, /(::plac\w+|:read-\w+)/)) {
case ":read-only":
              case ":read-write":
                return serialize$1([copy$1(element, {
                  props: [replace$1(value, /:(read-\w+)/, ":" + MOZ$1 + "$1")]
                })], callback);
case "::placeholder":
                return serialize$1([copy$1(element, {
                  props: [replace$1(value, /:(plac\w+)/, ":" + WEBKIT$1 + "input-$1")]
                }), copy$1(element, {
                  props: [replace$1(value, /:(plac\w+)/, ":" + MOZ$1 + "$1")]
                }), copy$1(element, {
                  props: [replace$1(value, /:(plac\w+)/, MS$1 + "input-$1")]
                })], callback);
            }
            return "";
          });
      }
    }
  };
  var defaultStylisPlugins = [prefixer$1];
  var createCache$1 = function createCache(options) {
    var key = options.key;
    if (key === "css") {
      var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(ssrStyles, function(node2) {
        var dataEmotionAttribute = node2.getAttribute("data-emotion");
        if (dataEmotionAttribute.indexOf(" ") === -1) {
          return;
        }
        document.head.appendChild(node2);
        node2.setAttribute("data-s", "");
      });
    }
    var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
    var inserted = {};
    var container;
    var nodesToHydrate = [];
    {
      container = options.container || document.head;
      Array.prototype.forEach.call(

document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
        function(node2) {
          var attrib = node2.getAttribute("data-emotion").split(" ");
          for (var i2 = 1; i2 < attrib.length; i2++) {
            inserted[attrib[i2]] = true;
          }
          nodesToHydrate.push(node2);
        }
      );
    }
    var _insert;
    var omnipresentPlugins = [compat, removeLabel];
    {
      var currentSheet;
      var finalizingPlugins = [stringify$3, rulesheet(function(rule) {
        currentSheet.insert(rule);
      })];
      var serializer = middleware$1(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
      var stylis = function stylis2(styles) {
        return serialize$1(compile$1(styles), serializer);
      };
      _insert = function insert(selector, serialized, sheet, shouldCache) {
        currentSheet = sheet;
        stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
        if (shouldCache) {
          cache2.inserted[serialized.name] = true;
        }
      };
    }
    var cache2 = {
      key,
      sheet: new StyleSheet({
        key,
        container,
        nonce: options.nonce,
        speedy: options.speedy,
        prepend: options.prepend,
        insertionPoint: options.insertionPoint
      }),
      nonce: options.nonce,
      inserted,
      registered: {},
      insert: _insert
    };
    cache2.sheet.hydrate(nodesToHydrate);
    return cache2;
  };
  function _extends$15() {
    return _extends$15 = Object.assign ? Object.assign.bind() : function(n2) {
      for (var e = 1; e < arguments.length; e++) {
        var t2 = arguments[e];
        for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
      }
      return n2;
    }, _extends$15.apply(null, arguments);
  }
  var reactIs$1 = { exports: {} };
  var reactIs_production_min$1 = {};
  var hasRequiredReactIs_production_min$1;
  function requireReactIs_production_min$1() {
    if (hasRequiredReactIs_production_min$1) return reactIs_production_min$1;
    hasRequiredReactIs_production_min$1 = 1;
    var b = "function" === typeof Symbol && Symbol.for, c2 = b ? Symbol.for("react.element") : 60103, d2 = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f2 = b ? Symbol.for("react.strict_mode") : 60108, g2 = b ? Symbol.for("react.profiler") : 60114, h2 = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l2 = b ? Symbol.for("react.async_mode") : 60111, m2 = b ? Symbol.for("react.concurrent_mode") : 60111, n2 = b ? Symbol.for("react.forward_ref") : 60112, p2 = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r2 = b ? Symbol.for("react.memo") : 60115, t2 = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
    function z(a2) {
      if ("object" === typeof a2 && null !== a2) {
        var u2 = a2.$$typeof;
        switch (u2) {
          case c2:
            switch (a2 = a2.type, a2) {
              case l2:
              case m2:
              case e:
              case g2:
              case f2:
              case p2:
                return a2;
              default:
                switch (a2 = a2 && a2.$$typeof, a2) {
                  case k:
                  case n2:
                  case t2:
                  case r2:
                  case h2:
                    return a2;
                  default:
                    return u2;
                }
            }
          case d2:
            return u2;
        }
      }
    }
    function A(a2) {
      return z(a2) === m2;
    }
    reactIs_production_min$1.AsyncMode = l2;
    reactIs_production_min$1.ConcurrentMode = m2;
    reactIs_production_min$1.ContextConsumer = k;
    reactIs_production_min$1.ContextProvider = h2;
    reactIs_production_min$1.Element = c2;
    reactIs_production_min$1.ForwardRef = n2;
    reactIs_production_min$1.Fragment = e;
    reactIs_production_min$1.Lazy = t2;
    reactIs_production_min$1.Memo = r2;
    reactIs_production_min$1.Portal = d2;
    reactIs_production_min$1.Profiler = g2;
    reactIs_production_min$1.StrictMode = f2;
    reactIs_production_min$1.Suspense = p2;
    reactIs_production_min$1.isAsyncMode = function(a2) {
      return A(a2) || z(a2) === l2;
    };
    reactIs_production_min$1.isConcurrentMode = A;
    reactIs_production_min$1.isContextConsumer = function(a2) {
      return z(a2) === k;
    };
    reactIs_production_min$1.isContextProvider = function(a2) {
      return z(a2) === h2;
    };
    reactIs_production_min$1.isElement = function(a2) {
      return "object" === typeof a2 && null !== a2 && a2.$$typeof === c2;
    };
    reactIs_production_min$1.isForwardRef = function(a2) {
      return z(a2) === n2;
    };
    reactIs_production_min$1.isFragment = function(a2) {
      return z(a2) === e;
    };
    reactIs_production_min$1.isLazy = function(a2) {
      return z(a2) === t2;
    };
    reactIs_production_min$1.isMemo = function(a2) {
      return z(a2) === r2;
    };
    reactIs_production_min$1.isPortal = function(a2) {
      return z(a2) === d2;
    };
    reactIs_production_min$1.isProfiler = function(a2) {
      return z(a2) === g2;
    };
    reactIs_production_min$1.isStrictMode = function(a2) {
      return z(a2) === f2;
    };
    reactIs_production_min$1.isSuspense = function(a2) {
      return z(a2) === p2;
    };
    reactIs_production_min$1.isValidElementType = function(a2) {
      return "string" === typeof a2 || "function" === typeof a2 || a2 === e || a2 === m2 || a2 === g2 || a2 === f2 || a2 === p2 || a2 === q || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t2 || a2.$$typeof === r2 || a2.$$typeof === h2 || a2.$$typeof === k || a2.$$typeof === n2 || a2.$$typeof === w || a2.$$typeof === x || a2.$$typeof === y || a2.$$typeof === v);
    };
    reactIs_production_min$1.typeOf = z;
    return reactIs_production_min$1;
  }
  var hasRequiredReactIs$1;
  function requireReactIs$1() {
    if (hasRequiredReactIs$1) return reactIs$1.exports;
    hasRequiredReactIs$1 = 1;
    {
      reactIs$1.exports = requireReactIs_production_min$1();
    }
    return reactIs$1.exports;
  }
  var hoistNonReactStatics_cjs;
  var hasRequiredHoistNonReactStatics_cjs;
  function requireHoistNonReactStatics_cjs() {
    if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs;
    hasRequiredHoistNonReactStatics_cjs = 1;
    var reactIs2 = requireReactIs$1();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs2.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs2.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs2.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys2 = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i2 = 0; i2 < keys2.length; ++i2) {
          var key = keys2[i2];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e) {
            }
          }
        }
      }
      return targetComponent;
    }
    hoistNonReactStatics_cjs = hoistNonReactStatics;
    return hoistNonReactStatics_cjs;
  }
  requireHoistNonReactStatics_cjs();
  var isBrowser$4 = true;
  function getRegisteredStyles(registered, registeredStyles, classNames) {
    var rawClassName = "";
    classNames.split(" ").forEach(function(className) {
      if (registered[className] !== void 0) {
        registeredStyles.push(registered[className] + ";");
      } else if (className) {
        rawClassName += className + " ";
      }
    });
    return rawClassName;
  }
  var registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
    var className = cache2.key + "-" + serialized.name;
    if (




(isStringTag === false ||



isBrowser$4 === false) && cache2.registered[className] === void 0
    ) {
      cache2.registered[className] = serialized.styles;
    }
  };
  var insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
    registerStyles(cache2, serialized, isStringTag);
    var className = cache2.key + "-" + serialized.name;
    if (cache2.inserted[serialized.name] === void 0) {
      var current = serialized;
      do {
        cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
        current = current.next;
      } while (current !== void 0);
    }
  };
  function murmur2$1(str) {
    var h2 = 0;
    var k, i2 = 0, len = str.length;
    for (; len >= 4; ++i2, len -= 4) {
      k = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
      k =
(k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
      k ^=
k >>> 24;
      h2 =
(k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^
(h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
      case 2:
        h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
      case 1:
        h2 ^= str.charCodeAt(i2) & 255;
        h2 =
(h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    h2 ^= h2 >>> 13;
    h2 =
(h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
  }
  var unitlessKeys$1 = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };
  var hyphenateRegex = /[A-Z]|^ms/g;
  var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
  var isCustomProperty = function isCustomProperty2(property) {
    return property.charCodeAt(1) === 45;
  };
  var isProcessableValue = function isProcessableValue2(value) {
    return value != null && typeof value !== "boolean";
  };
  var processStyleName = memoize(function(styleName) {
    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
  });
  var processStyleValue = function processStyleValue2(key, value) {
    switch (key) {
      case "animation":
      case "animationName": {
        if (typeof value === "string") {
          return value.replace(animationRegex, function(match2, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
    }
    if (unitlessKeys$1[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
      return value + "px";
    }
    return value;
  };
  function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) {
      return "";
    }
    var componentSelector = interpolation;
    if (componentSelector.__emotion_styles !== void 0) {
      return componentSelector;
    }
    switch (typeof interpolation) {
      case "boolean": {
        return "";
      }
      case "object": {
        var keyframes2 = interpolation;
        if (keyframes2.anim === 1) {
          cursor = {
            name: keyframes2.name,
            styles: keyframes2.styles,
            next: cursor
          };
          return keyframes2.name;
        }
        var serializedStyles = interpolation;
        if (serializedStyles.styles !== void 0) {
          var next2 = serializedStyles.next;
          if (next2 !== void 0) {
            while (next2 !== void 0) {
              cursor = {
                name: next2.name,
                styles: next2.styles,
                next: cursor
              };
              next2 = next2.next;
            }
          }
          var styles = serializedStyles.styles + ";";
          return styles;
        }
        return createStringFromObject(mergedProps, registered, interpolation);
      }
      case "function": {
        if (mergedProps !== void 0) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        }
        break;
      }
    }
    var asString = interpolation;
    if (registered == null) {
      return asString;
    }
    var cached2 = registered[asString];
    return cached2 !== void 0 ? cached2 : asString;
  }
  function createStringFromObject(mergedProps, registered, obj) {
    var string3 = "";
    if (Array.isArray(obj)) {
      for (var i2 = 0; i2 < obj.length; i2++) {
        string3 += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
      }
    } else {
      for (var key in obj) {
        var value = obj[key];
        if (typeof value !== "object") {
          var asString = value;
          if (registered != null && registered[asString] !== void 0) {
            string3 += key + "{" + registered[asString] + "}";
          } else if (isProcessableValue(asString)) {
            string3 += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
          }
        } else {
          if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
            for (var _i = 0; _i < value.length; _i++) {
              if (isProcessableValue(value[_i])) {
                string3 += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
              }
            }
          } else {
            var interpolated = handleInterpolation(mergedProps, registered, value);
            switch (key) {
              case "animation":
              case "animationName": {
                string3 += processStyleName(key) + ":" + interpolated + ";";
                break;
              }
              default: {
                string3 += key + "{" + interpolated + "}";
              }
            }
          }
        }
      }
    }
    return string3;
  }
  var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
  var cursor;
  function serializeStyles(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
      return args[0];
    }
    var stringMode = true;
    var styles = "";
    cursor = void 0;
    var strings = args[0];
    if (strings == null || strings.raw === void 0) {
      stringMode = false;
      styles += handleInterpolation(mergedProps, registered, strings);
    } else {
      var asTemplateStringsArr = strings;
      styles += asTemplateStringsArr[0];
    }
    for (var i2 = 1; i2 < args.length; i2++) {
      styles += handleInterpolation(mergedProps, registered, args[i2]);
      if (stringMode) {
        var templateStringsArr = strings;
        styles += templateStringsArr[i2];
      }
    }
    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match2;
    while ((match2 = labelPattern.exec(styles)) !== null) {
      identifierName += "-" + match2[1];
    }
    var name = murmur2$1(styles) + identifierName;
    return {
      name,
      styles,
      next: cursor
    };
  }
  var syncFallback = function syncFallback2(create) {
    return create();
  };
  var useInsertionEffect = React3["useInsertionEffect"] ? React3["useInsertionEffect"] : false;
  var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
  var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
  var EmotionCacheContext = reactExports.createContext(





typeof HTMLElement !== "undefined" ? createCache$1({
      key: "css"
    }) : null
  );
  var CacheProvider = EmotionCacheContext.Provider;
  var withEmotionCache = function withEmotionCache2(func) {
    return reactExports.forwardRef(function(props, ref2) {
      var cache2 = reactExports.useContext(EmotionCacheContext);
      return func(props, cache2, ref2);
    });
  };
  var ThemeContext = reactExports.createContext({});
  var hasOwn = {}.hasOwnProperty;
  var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
  var createEmotionProps = function createEmotionProps2(type4, props) {
    var newProps = {};
    for (var _key in props) {
      if (hasOwn.call(props, _key)) {
        newProps[_key] = props[_key];
      }
    }
    newProps[typePropName] = type4;
    return newProps;
  };
  var Insertion = function Insertion2(_ref4) {
    var cache2 = _ref4.cache, serialized = _ref4.serialized, isStringTag = _ref4.isStringTag;
    registerStyles(cache2, serialized, isStringTag);
    useInsertionEffectAlwaysWithSyncFallback(function() {
      return insertStyles(cache2, serialized, isStringTag);
    });
    return null;
  };
  var Emotion = withEmotionCache(function(props, cache2, ref2) {
    var cssProp = props.css;
    if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
      cssProp = cache2.registered[cssProp];
    }
    var WrappedComponent = props[typePropName];
    var registeredStyles = [cssProp];
    var className = "";
    if (typeof props.className === "string") {
      className = getRegisteredStyles(cache2.registered, registeredStyles, props.className);
    } else if (props.className != null) {
      className = props.className + " ";
    }
    var serialized = serializeStyles(registeredStyles, void 0, reactExports.useContext(ThemeContext));
    className += cache2.key + "-" + serialized.name;
    var newProps = {};
    for (var _key2 in props) {
      if (hasOwn.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && true) {
        newProps[_key2] = props[_key2];
      }
    }
    newProps.className = className;
    if (ref2) {
      newProps.ref = ref2;
    }
    return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Insertion, {
      cache: cache2,
      serialized,
      isStringTag: typeof WrappedComponent === "string"
    }), reactExports.createElement(WrappedComponent, newProps));
  });
  var Emotion$1 = Emotion;
  var Fragment = jsxRuntimeExports.Fragment;
  var jsx$1 = function jsx(type4, props, key) {
    if (!hasOwn.call(props, "css")) {
      return jsxRuntimeExports.jsx(type4, props, key);
    }
    return jsxRuntimeExports.jsx(Emotion$1, createEmotionProps(type4, props), key);
  };
  var jsxs = function jsxs2(type4, props, key) {
    if (!hasOwn.call(props, "css")) {
      return jsxRuntimeExports.jsxs(type4, props, key);
    }
    return jsxRuntimeExports.jsxs(Emotion$1, createEmotionProps(type4, props), key);
  };
  const anyMap = new WeakMap();
  const eventsMap = new WeakMap();
  const producersMap = new WeakMap();
  var define_globalThis_process_env_default = {};
  const anyProducer = Symbol("anyProducer");
  const resolvedPromise = Promise.resolve();
  const listenerAdded = Symbol("listenerAdded");
  const listenerRemoved = Symbol("listenerRemoved");
  let canEmitMetaEvents = false;
  let isGlobalDebugEnabled = false;
  const isEventKeyType = (key) => typeof key === "string" || typeof key === "symbol" || typeof key === "number";
  function assertEventName(eventName) {
    if (!isEventKeyType(eventName)) {
      throw new TypeError("`eventName` must be a string, symbol, or number");
    }
  }
  function assertListener(listener) {
    if (typeof listener !== "function") {
      throw new TypeError("listener must be a function");
    }
  }
  function getListeners(instance, eventName) {
    const events2 = eventsMap.get(instance);
    if (!events2.has(eventName)) {
      return;
    }
    return events2.get(eventName);
  }
  function getEventProducers(instance, eventName) {
    const key = isEventKeyType(eventName) ? eventName : anyProducer;
    const producers = producersMap.get(instance);
    if (!producers.has(key)) {
      return;
    }
    return producers.get(key);
  }
  function enqueueProducers(instance, eventName, eventData) {
    const producers = producersMap.get(instance);
    if (producers.has(eventName)) {
      for (const producer of producers.get(eventName)) {
        producer.enqueue(eventData);
      }
    }
    if (producers.has(anyProducer)) {
      const item = Promise.all([eventName, eventData]);
      for (const producer of producers.get(anyProducer)) {
        producer.enqueue(item);
      }
    }
  }
  function iterator(instance, eventNames) {
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    let isFinished = false;
    let flush = () => {
    };
    let queue = [];
    const producer = {
      enqueue(item) {
        queue.push(item);
        flush();
      },
      finish() {
        isFinished = true;
        flush();
      }
    };
    for (const eventName of eventNames) {
      let set2 = getEventProducers(instance, eventName);
      if (!set2) {
        set2 = new Set();
        const producers = producersMap.get(instance);
        producers.set(eventName, set2);
      }
      set2.add(producer);
    }
    return {
      async next() {
        if (!queue) {
          return { done: true };
        }
        if (queue.length === 0) {
          if (isFinished) {
            queue = void 0;
            return this.next();
          }
          await new Promise((resolve) => {
            flush = resolve;
          });
          return this.next();
        }
        return {
          done: false,
          value: await queue.shift()
        };
      },
      async return(value) {
        queue = void 0;
        for (const eventName of eventNames) {
          const set2 = getEventProducers(instance, eventName);
          if (set2) {
            set2.delete(producer);
            if (set2.size === 0) {
              const producers = producersMap.get(instance);
              producers.delete(eventName);
            }
          }
        }
        flush();
        return arguments.length > 0 ? { done: true, value: await value } : { done: true };
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  function defaultMethodNamesOrAssert(methodNames) {
    if (methodNames === void 0) {
      return allEmitteryMethods;
    }
    if (!Array.isArray(methodNames)) {
      throw new TypeError("`methodNames` must be an array of strings");
    }
    for (const methodName of methodNames) {
      if (!allEmitteryMethods.includes(methodName)) {
        if (typeof methodName !== "string") {
          throw new TypeError("`methodNames` element must be a string");
        }
        throw new Error(`${methodName} is not Emittery method`);
      }
    }
    return methodNames;
  }
  const isMetaEvent = (eventName) => eventName === listenerAdded || eventName === listenerRemoved;
  function emitMetaEvent(emitter2, eventName, eventData) {
    if (!isMetaEvent(eventName)) {
      return;
    }
    try {
      canEmitMetaEvents = true;
      emitter2.emit(eventName, eventData);
    } finally {
      canEmitMetaEvents = false;
    }
  }
  class Emittery {
    static mixin(emitteryPropertyName, methodNames) {
      methodNames = defaultMethodNamesOrAssert(methodNames);
      return (target) => {
        if (typeof target !== "function") {
          throw new TypeError("`target` must be function");
        }
        for (const methodName of methodNames) {
          if (target.prototype[methodName] !== void 0) {
            throw new Error(`The property \`${methodName}\` already exists on \`target\``);
          }
        }
        function getEmitteryProperty() {
          Object.defineProperty(this, emitteryPropertyName, {
            enumerable: false,
            value: new Emittery()
          });
          return this[emitteryPropertyName];
        }
        Object.defineProperty(target.prototype, emitteryPropertyName, {
          enumerable: false,
          get: getEmitteryProperty
        });
        const emitteryMethodCaller = (methodName) => function(...args) {
          return this[emitteryPropertyName][methodName](...args);
        };
        for (const methodName of methodNames) {
          Object.defineProperty(target.prototype, methodName, {
            enumerable: false,
            value: emitteryMethodCaller(methodName)
          });
        }
        return target;
      };
    }
    static get isDebugEnabled() {
      if (typeof define_globalThis_process_env_default !== "object") {
        return isGlobalDebugEnabled;
      }
      const { env } = globalThis.process ?? { env: {} };
      return env.DEBUG === "emittery" || env.DEBUG === "*" || isGlobalDebugEnabled;
    }
    static set isDebugEnabled(newValue) {
      isGlobalDebugEnabled = newValue;
    }
    constructor(options = {}) {
      anyMap.set(this, new Set());
      eventsMap.set(this, new Map());
      producersMap.set(this, new Map());
      producersMap.get(this).set(anyProducer, new Set());
      this.debug = options.debug ?? {};
      if (this.debug.enabled === void 0) {
        this.debug.enabled = false;
      }
      if (!this.debug.logger) {
        this.debug.logger = (type4, debugName, eventName, eventData) => {
          try {
            eventData = JSON.stringify(eventData);
          } catch {
            eventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(",")}`;
          }
          if (typeof eventName === "symbol" || typeof eventName === "number") {
            eventName = eventName.toString();
          }
          const currentTime = new Date();
          const logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;
          console.log(`[${logTime}][emittery:${type4}][${debugName}] Event Name: ${eventName}
	data: ${eventData}`);
        };
      }
    }
    logIfDebugEnabled(type4, eventName, eventData) {
      if (Emittery.isDebugEnabled || this.debug.enabled) {
        this.debug.logger(type4, this.debug.name, eventName, eventData);
      }
    }
    on(eventNames, listener, { signal } = {}) {
      assertListener(listener);
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      for (const eventName of eventNames) {
        assertEventName(eventName);
        let set2 = getListeners(this, eventName);
        if (!set2) {
          set2 = new Set();
          const events2 = eventsMap.get(this);
          events2.set(eventName, set2);
        }
        set2.add(listener);
        this.logIfDebugEnabled("subscribe", eventName, void 0);
        if (!isMetaEvent(eventName)) {
          emitMetaEvent(this, listenerAdded, { eventName, listener });
        }
      }
      const off = () => {
        this.off(eventNames, listener);
        signal?.removeEventListener("abort", off);
      };
      signal?.addEventListener("abort", off, { once: true });
      if (signal?.aborted) {
        off();
      }
      return off;
    }
    off(eventNames, listener) {
      assertListener(listener);
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      for (const eventName of eventNames) {
        assertEventName(eventName);
        const set2 = getListeners(this, eventName);
        if (set2) {
          set2.delete(listener);
          if (set2.size === 0) {
            const events2 = eventsMap.get(this);
            events2.delete(eventName);
          }
        }
        this.logIfDebugEnabled("unsubscribe", eventName, void 0);
        if (!isMetaEvent(eventName)) {
          emitMetaEvent(this, listenerRemoved, { eventName, listener });
        }
      }
    }
    once(eventNames, predicate) {
      if (predicate !== void 0 && typeof predicate !== "function") {
        throw new TypeError("predicate must be a function");
      }
      let off_;
      const promise = new Promise((resolve) => {
        off_ = this.on(eventNames, (data2) => {
          if (predicate && !predicate(data2)) {
            return;
          }
          off_();
          resolve(data2);
        });
      });
      promise.off = off_;
      return promise;
    }
    events(eventNames) {
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      for (const eventName of eventNames) {
        assertEventName(eventName);
      }
      return iterator(this, eventNames);
    }
    async emit(eventName, eventData) {
      assertEventName(eventName);
      if (isMetaEvent(eventName) && !canEmitMetaEvents) {
        throw new TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");
      }
      this.logIfDebugEnabled("emit", eventName, eventData);
      enqueueProducers(this, eventName, eventData);
      const listeners2 = getListeners(this, eventName) ?? new Set();
      const anyListeners = anyMap.get(this);
      const staticListeners = [...listeners2];
      const staticAnyListeners = isMetaEvent(eventName) ? [] : [...anyListeners];
      await resolvedPromise;
      await Promise.all([
        ...staticListeners.map(async (listener) => {
          if (listeners2.has(listener)) {
            return listener(eventData);
          }
        }),
        ...staticAnyListeners.map(async (listener) => {
          if (anyListeners.has(listener)) {
            return listener(eventName, eventData);
          }
        })
      ]);
    }
    async emitSerial(eventName, eventData) {
      assertEventName(eventName);
      if (isMetaEvent(eventName) && !canEmitMetaEvents) {
        throw new TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");
      }
      this.logIfDebugEnabled("emitSerial", eventName, eventData);
      enqueueProducers(this, eventName, eventData);
      const listeners2 = getListeners(this, eventName) ?? new Set();
      const anyListeners = anyMap.get(this);
      const staticListeners = [...listeners2];
      const staticAnyListeners = isMetaEvent(eventName) ? [] : [...anyListeners];
      await resolvedPromise;
      for (const listener of staticListeners) {
        if (listeners2.has(listener)) {
          await listener(eventData);
        }
      }
      for (const listener of staticAnyListeners) {
        if (anyListeners.has(listener)) {
          await listener(eventName, eventData);
        }
      }
    }
    onAny(listener, { signal } = {}) {
      assertListener(listener);
      this.logIfDebugEnabled("subscribeAny", void 0, void 0);
      anyMap.get(this).add(listener);
      emitMetaEvent(this, listenerAdded, { listener });
      const offAny = () => {
        this.offAny(listener);
        signal?.removeEventListener("abort", offAny);
      };
      signal?.addEventListener("abort", offAny, { once: true });
      if (signal?.aborted) {
        offAny();
      }
      return offAny;
    }
    anyEvent() {
      return iterator(this);
    }
    offAny(listener) {
      assertListener(listener);
      this.logIfDebugEnabled("unsubscribeAny", void 0, void 0);
      emitMetaEvent(this, listenerRemoved, { listener });
      anyMap.get(this).delete(listener);
    }
    clearListeners(eventNames) {
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      for (const eventName of eventNames) {
        this.logIfDebugEnabled("clear", eventName, void 0);
        if (isEventKeyType(eventName)) {
          const set2 = getListeners(this, eventName);
          if (set2) {
            set2.clear();
          }
          const producers = getEventProducers(this, eventName);
          if (producers) {
            for (const producer of producers) {
              producer.finish();
            }
            producers.clear();
          }
        } else {
          anyMap.get(this).clear();
          for (const [eventName2, listeners2] of eventsMap.get(this).entries()) {
            listeners2.clear();
            eventsMap.get(this).delete(eventName2);
          }
          for (const [eventName2, producers] of producersMap.get(this).entries()) {
            for (const producer of producers) {
              producer.finish();
            }
            producers.clear();
            producersMap.get(this).delete(eventName2);
          }
        }
      }
    }
    listenerCount(eventNames) {
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      let count = 0;
      for (const eventName of eventNames) {
        if (isEventKeyType(eventName)) {
          count += anyMap.get(this).size + (getListeners(this, eventName)?.size ?? 0) + (getEventProducers(this, eventName)?.size ?? 0) + (getEventProducers(this)?.size ?? 0);
          continue;
        }
        if (eventName !== void 0) {
          assertEventName(eventName);
        }
        count += anyMap.get(this).size;
        for (const value of eventsMap.get(this).values()) {
          count += value.size;
        }
        for (const value of producersMap.get(this).values()) {
          count += value.size;
        }
      }
      return count;
    }
    bindMethods(target, methodNames) {
      if (typeof target !== "object" || target === null) {
        throw new TypeError("`target` must be an object");
      }
      methodNames = defaultMethodNamesOrAssert(methodNames);
      for (const methodName of methodNames) {
        if (target[methodName] !== void 0) {
          throw new Error(`The property \`${methodName}\` already exists on \`target\``);
        }
        Object.defineProperty(target, methodName, {
          enumerable: false,
          value: this[methodName].bind(this)
        });
      }
    }
  }
  const allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter((v) => v !== "constructor");
  Object.defineProperty(Emittery, "listenerAdded", {
    value: listenerAdded,
    writable: false,
    enumerable: true,
    configurable: false
  });
  Object.defineProperty(Emittery, "listenerRemoved", {
    value: listenerRemoved,
    writable: false,
    enumerable: true,
    configurable: false
  });
  function useEvent$1(callback) {
    const fnRef = reactExports.useRef(callback);
    fnRef.current = callback;
    const memoFn = reactExports.useCallback((...args) => fnRef.current?.(...args), []);
    return memoFn;
  }
  function canUseDom() {
    return !!(typeof window !== "undefined" && window.document && window.document.createElement);
  }
  const useInternalLayoutEffect = canUseDom() ? reactExports.useLayoutEffect : reactExports.useEffect;
  const useLayoutEffect = (callback, deps) => {
    const firstMountRef = reactExports.useRef(true);
    useInternalLayoutEffect(() => {
      return callback(firstMountRef.current);
    }, deps);
    useInternalLayoutEffect(() => {
      firstMountRef.current = false;
      return () => {
        firstMountRef.current = true;
      };
    }, []);
  };
  const useLayoutUpdateEffect = (callback, deps) => {
    useLayoutEffect((firstMount) => {
      if (!firstMount) {
        return callback();
      }
    }, deps);
  };
  const useSafeState = (defaultValue2) => {
    const destroyRef = reactExports.useRef(false);
    const [value, setValue] = reactExports.useState(defaultValue2);
    reactExports.useEffect(() => {
      destroyRef.current = false;
      return () => {
        destroyRef.current = true;
      };
    }, []);
    function safeSetState(updater, ignoreDestroy) {
      if (ignoreDestroy && destroyRef.current) {
        return;
      }
      setValue(updater);
    }
    return [value, safeSetState];
  };
  function useControlledState(defaultStateValue, value) {
    const [innerValue, setInnerValue] = reactExports.useState(defaultStateValue);
    const mergedValue = value !== void 0 ? value : innerValue;
    useLayoutEffect((mount) => {
      if (!mount) {
        setInnerValue(value);
      }
    }, [value]);
    return [
mergedValue,
setInnerValue
    ];
  }
  var reactIs = { exports: {} };
  var reactIs_production_min = {};
  var hasRequiredReactIs_production_min;
  function requireReactIs_production_min() {
    if (hasRequiredReactIs_production_min) return reactIs_production_min;
    hasRequiredReactIs_production_min = 1;
    var b = Symbol.for("react.element"), c2 = Symbol.for("react.portal"), d2 = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f2 = Symbol.for("react.profiler"), g2 = Symbol.for("react.provider"), h2 = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l2 = Symbol.for("react.forward_ref"), m2 = Symbol.for("react.suspense"), n2 = Symbol.for("react.suspense_list"), p2 = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t2 = Symbol.for("react.offscreen"), u2;
    u2 = Symbol.for("react.module.reference");
    function v(a2) {
      if ("object" === typeof a2 && null !== a2) {
        var r2 = a2.$$typeof;
        switch (r2) {
          case b:
            switch (a2 = a2.type, a2) {
              case d2:
              case f2:
              case e:
              case m2:
              case n2:
                return a2;
              default:
                switch (a2 = a2 && a2.$$typeof, a2) {
                  case k:
                  case h2:
                  case l2:
                  case q:
                  case p2:
                  case g2:
                    return a2;
                  default:
                    return r2;
                }
            }
          case c2:
            return r2;
        }
      }
    }
    reactIs_production_min.ContextConsumer = h2;
    reactIs_production_min.ContextProvider = g2;
    reactIs_production_min.Element = b;
    reactIs_production_min.ForwardRef = l2;
    reactIs_production_min.Fragment = d2;
    reactIs_production_min.Lazy = q;
    reactIs_production_min.Memo = p2;
    reactIs_production_min.Portal = c2;
    reactIs_production_min.Profiler = f2;
    reactIs_production_min.StrictMode = e;
    reactIs_production_min.Suspense = m2;
    reactIs_production_min.SuspenseList = n2;
    reactIs_production_min.isAsyncMode = function() {
      return false;
    };
    reactIs_production_min.isConcurrentMode = function() {
      return false;
    };
    reactIs_production_min.isContextConsumer = function(a2) {
      return v(a2) === h2;
    };
    reactIs_production_min.isContextProvider = function(a2) {
      return v(a2) === g2;
    };
    reactIs_production_min.isElement = function(a2) {
      return "object" === typeof a2 && null !== a2 && a2.$$typeof === b;
    };
    reactIs_production_min.isForwardRef = function(a2) {
      return v(a2) === l2;
    };
    reactIs_production_min.isFragment = function(a2) {
      return v(a2) === d2;
    };
    reactIs_production_min.isLazy = function(a2) {
      return v(a2) === q;
    };
    reactIs_production_min.isMemo = function(a2) {
      return v(a2) === p2;
    };
    reactIs_production_min.isPortal = function(a2) {
      return v(a2) === c2;
    };
    reactIs_production_min.isProfiler = function(a2) {
      return v(a2) === f2;
    };
    reactIs_production_min.isStrictMode = function(a2) {
      return v(a2) === e;
    };
    reactIs_production_min.isSuspense = function(a2) {
      return v(a2) === m2;
    };
    reactIs_production_min.isSuspenseList = function(a2) {
      return v(a2) === n2;
    };
    reactIs_production_min.isValidElementType = function(a2) {
      return "string" === typeof a2 || "function" === typeof a2 || a2 === d2 || a2 === f2 || a2 === e || a2 === m2 || a2 === n2 || a2 === t2 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q || a2.$$typeof === p2 || a2.$$typeof === g2 || a2.$$typeof === h2 || a2.$$typeof === l2 || a2.$$typeof === u2 || void 0 !== a2.getModuleId) ? true : false;
    };
    reactIs_production_min.typeOf = v;
    return reactIs_production_min;
  }
  var hasRequiredReactIs;
  function requireReactIs() {
    if (hasRequiredReactIs) return reactIs.exports;
    hasRequiredReactIs = 1;
    {
      reactIs.exports = requireReactIs_production_min();
    }
    return reactIs.exports;
  }
  var reactIsExports = requireReactIs();
  function useMemo(getValue2, condition, shouldUpdate) {
    const cacheRef = reactExports.useRef({});
    if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
      cacheRef.current.value = getValue2();
      cacheRef.current.condition = condition;
    }
    return cacheRef.current.value;
  }
  const REACT_ELEMENT_TYPE_18 = Symbol.for("react.element");
  const REACT_ELEMENT_TYPE_19 = Symbol.for("react.transitional.element");
  const REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
  function isFragment$1(object4) {
    return (
object4 && typeof object4 === "object" &&
(object4.$$typeof === REACT_ELEMENT_TYPE_18 || object4.$$typeof === REACT_ELEMENT_TYPE_19) &&
object4.type === REACT_FRAGMENT_TYPE
    );
  }
  const ReactMajorVersion = Number(reactExports.version.split(".")[0]);
  const fillRef = (ref2, node2) => {
    if (typeof ref2 === "function") {
      ref2(node2);
    } else if (typeof ref2 === "object" && ref2 && "current" in ref2) {
      ref2.current = node2;
    }
  };
  const composeRef = (...refs) => {
    const refList = refs.filter(Boolean);
    if (refList.length <= 1) {
      return refList[0];
    }
    return (node2) => {
      refs.forEach((ref2) => {
        fillRef(ref2, node2);
      });
    };
  };
  const useComposeRef = (...refs) => {
    return useMemo(
      () => composeRef(...refs),
refs,
      (prev2, next2) => prev2.length !== next2.length || prev2.every((ref2, i2) => ref2 !== next2[i2])
    );
  };
  const supportRef = (nodeOrComponent) => {
    if (!nodeOrComponent) {
      return false;
    }
    if (isReactElement(nodeOrComponent) && ReactMajorVersion >= 19) {
      return true;
    }
    const type4 = reactIsExports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
    if (typeof type4 === "function" && !type4.prototype?.render && type4.$$typeof !== reactIsExports.ForwardRef) {
      return false;
    }
    if (typeof nodeOrComponent === "function" && !nodeOrComponent.prototype?.render && nodeOrComponent.$$typeof !== reactIsExports.ForwardRef) {
      return false;
    }
    return true;
  };
  function isReactElement(node2) {
    return reactExports.isValidElement(node2) && !isFragment$1(node2);
  }
  const supportNodeRef = (node2) => {
    return isReactElement(node2) && supportRef(node2);
  };
  const getNodeRef = (node2) => {
    if (node2 && isReactElement(node2)) {
      const ele = node2;
      return ele.props.propertyIsEnumerable("ref") ? ele.props.ref : ele.ref;
    }
    return null;
  };
  function get(entity, path) {
    let current = entity;
    for (let i2 = 0; i2 < path.length; i2 += 1) {
      if (current === null || current === void 0) {
        return void 0;
      }
      current = current[path[i2]];
    }
    return current;
  }
  function internalSet(entity, paths, value, removeIfUndefined) {
    if (!paths.length) {
      return value;
    }
    const [path, ...restPath] = paths;
    let clone2;
    if (!entity && typeof path === "number") {
      clone2 = [];
    } else if (Array.isArray(entity)) {
      clone2 = [...entity];
    } else {
      clone2 = {
        ...entity
      };
    }
    if (removeIfUndefined && value === void 0 && restPath.length === 1) {
      delete clone2[path][restPath[0]];
    } else {
      clone2[path] = internalSet(clone2[path], restPath, value, removeIfUndefined);
    }
    return clone2;
  }
  function set(entity, paths, value, removeIfUndefined = false) {
    if (paths.length && removeIfUndefined && value === void 0 && !get(entity, paths.slice(0, -1))) {
      return entity;
    }
    return internalSet(entity, paths, value, removeIfUndefined);
  }
  function isObject$1(obj) {
    return typeof obj === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
  }
  function createEmpty(source) {
    return Array.isArray(source) ? [] : {};
  }
  const keys = typeof Reflect === "undefined" ? Object.keys : Reflect.ownKeys;
  function mergeWith(sources, config = {}) {
    const {
      prepareArray
    } = config;
    const finalPrepareArray = prepareArray || (() => []);
    let clone2 = createEmpty(sources[0]);
    sources.forEach((src) => {
      function internalMerge(path, parentLoopSet) {
        const loopSet = new Set(parentLoopSet);
        const value = get(src, path);
        const isArr = Array.isArray(value);
        if (isArr || isObject$1(value)) {
          if (!loopSet.has(value)) {
            loopSet.add(value);
            const originValue = get(clone2, path);
            if (isArr) {
              clone2 = set(clone2, path, finalPrepareArray(originValue, value));
            } else if (!originValue || typeof originValue !== "object") {
              clone2 = set(clone2, path, createEmpty(value));
            }
            keys(value).forEach((key) => {
              if (Object.getOwnPropertyDescriptor(value, key).enumerable) {
                internalMerge([...path, key], loopSet);
              }
            });
          }
        } else {
          clone2 = set(clone2, path, value);
        }
      }
      internalMerge([]);
    });
    return clone2;
  }
  function merge$2(...sources) {
    return mergeWith(sources);
  }
  let warned = {};
  const preMessage = (fn) => {
  };
  function warning$2(valid, message2) {
  }
  function note(valid, message2) {
  }
  function resetWarned() {
    warned = {};
  }
  function call(method4, valid, message2) {
    if (!valid && !warned[message2]) {
      method4(false, message2);
      warned[message2] = true;
    }
  }
  function warningOnce(valid, message2) {
    call(warning$2, valid, message2);
  }
  function noteOnce(valid, message2) {
    call(note, valid, message2);
  }
  warningOnce.preMessage = preMessage;
  warningOnce.resetWarned = resetWarned;
  warningOnce.noteOnce = noteOnce;
  function omit(obj, fields) {
    const clone2 = Object.assign({}, obj);
    if (Array.isArray(fields)) {
      fields.forEach((key) => {
        delete clone2[key];
      });
    }
    return clone2;
  }
  function toArray$4(children, option = {}) {
    let ret = [];
    React.Children.forEach(children, (child) => {
      if ((child === void 0 || child === null) && !option.keepEmpty) {
        return;
      }
      if (Array.isArray(child)) {
        ret = ret.concat(toArray$4(child));
      } else if (isFragment$1(child) && child.props) {
        ret = ret.concat(toArray$4(child.props.children, option));
      } else {
        ret.push(child);
      }
    });
    return ret;
  }
  const WarningContext = reactExports.createContext({});
  function isDOM(node2) {
    return node2 instanceof HTMLElement || node2 instanceof SVGElement;
  }
  function getDOM(node2) {
    if (node2 && typeof node2 === "object" && isDOM(node2.nativeElement)) {
      return node2.nativeElement;
    }
    if (isDOM(node2)) {
      return node2;
    }
    return null;
  }
  const CollectionContext = reactExports.createContext(null);
  function Collection({
    children,
    onBatchResize
  }) {
    const resizeIdRef = reactExports.useRef(0);
    const resizeInfosRef = reactExports.useRef([]);
    const onCollectionResize = reactExports.useContext(CollectionContext);
    const onResize2 = reactExports.useCallback((size, element, data2) => {
      resizeIdRef.current += 1;
      const currentId = resizeIdRef.current;
      resizeInfosRef.current.push({
        size,
        element,
        data: data2
      });
      Promise.resolve().then(() => {
        if (currentId === resizeIdRef.current) {
          onBatchResize?.(resizeInfosRef.current);
          resizeInfosRef.current = [];
        }
      });
      onCollectionResize?.(size, element, data2);
    }, [onBatchResize, onCollectionResize]);
    return reactExports.createElement(CollectionContext.Provider, {
      value: onResize2
    }, children);
  }
  const elementListeners = new Map();
  function onResize(entities) {
    entities.forEach((entity) => {
      const {
        target
      } = entity;
      elementListeners.get(target)?.forEach((listener) => listener(target));
    });
  }
  let observer$1;
  function ensureResizeObserver() {
    if (!observer$1) {
      observer$1 = new ResizeObserver(onResize);
    }
    return observer$1;
  }
  function observe$1(element, callback) {
    if (!elementListeners.has(element)) {
      elementListeners.set(element, new Set());
      ensureResizeObserver().observe(element);
    }
    elementListeners.get(element).add(callback);
  }
  function unobserve(element, callback) {
    if (elementListeners.has(element)) {
      elementListeners.get(element).delete(callback);
      if (!elementListeners.get(element).size) {
        ensureResizeObserver().unobserve(element);
        elementListeners.delete(element);
      }
    }
  }
  function useResizeObserver$1(enabled2, getTarget, onDelayResize, onSyncResize) {
    const sizeRef = reactExports.useRef({
      width: -1,
      height: -1,
      offsetWidth: -1,
      offsetHeight: -1
    });
    const onInternalResize = useEvent$1((target) => {
      const {
        width,
        height
      } = target.getBoundingClientRect();
      const {
        offsetWidth,
        offsetHeight
      } = target;
      const fixedWidth = Math.floor(width);
      const fixedHeight = Math.floor(height);
      if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
        const size = {
          width: fixedWidth,
          height: fixedHeight,
          offsetWidth,
          offsetHeight
        };
        sizeRef.current = size;
        const mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
        const mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
        const sizeInfo = {
          ...size,
          offsetWidth: mergedOffsetWidth,
          offsetHeight: mergedOffsetHeight
        };
        onSyncResize?.(sizeInfo, target);
        Promise.resolve().then(() => {
          onDelayResize?.(sizeInfo, target);
        });
      }
    });
    const isFuncTarget = typeof getTarget === "function";
    reactExports.useEffect(() => {
      const target = isFuncTarget ? getTarget() : getTarget;
      if (target && enabled2) {
        observe$1(target, onInternalResize);
      }
      return () => {
        if (target) {
          unobserve(target, onInternalResize);
        }
      };
    }, [
      enabled2,
isFuncTarget ? 0 : getTarget
    ]);
  }
  function SingleObserver(props, ref2) {
    const {
      children,
      disabled,
      onResize: onResize2,
      data: data2
    } = props;
    const elementRef = reactExports.useRef(null);
    const onCollectionResize = reactExports.useContext(CollectionContext);
    const isRenderProps = typeof children === "function";
    const mergedChildren = isRenderProps ? children(elementRef) : children;
    const canRef = !isRenderProps && reactExports.isValidElement(mergedChildren) && supportRef(mergedChildren);
    const originRef = canRef ? getNodeRef(mergedChildren) : null;
    const mergedRef = useComposeRef(originRef, elementRef);
    const getDomElement = () => {
      return getDOM(elementRef.current);
    };
    reactExports.useImperativeHandle(ref2, () => getDomElement());
    useResizeObserver$1(!disabled, getDomElement, onResize2, (sizeInfo, target) => {
      onCollectionResize?.(sizeInfo, target, data2);
    });
    return canRef ? reactExports.cloneElement(mergedChildren, {
      ref: mergedRef
    }) : mergedChildren;
  }
  const RefSingleObserver = reactExports.forwardRef(SingleObserver);
  function _extends$14() {
    _extends$14 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$14.apply(this, arguments);
  }
  const INTERNAL_PREFIX_KEY = "rc-observer-key";
  function ResizeObserver$1(props, ref2) {
    const {
      children
    } = props;
    const childNodes = typeof children === "function" ? [children] : toArray$4(children);
    return childNodes.map((child, index) => {
      const key = child?.key || `${INTERNAL_PREFIX_KEY}-${index}`;
      return reactExports.createElement(RefSingleObserver, _extends$14({}, props, {
        key,
        ref: index === 0 ? ref2 : void 0
      }), child);
    });
  }
  const RefResizeObserver = reactExports.forwardRef(ResizeObserver$1);
  RefResizeObserver.Collection = Collection;
  function r$2(e) {
    var t2, f2, n2 = "";
    if ("string" == typeof e || "number" == typeof e) n2 += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
      var o2 = e.length;
      for (t2 = 0; t2 < o2; t2++) e[t2] && (f2 = r$2(e[t2])) && (n2 && (n2 += " "), n2 += f2);
    } else for (f2 in e) e[f2] && (n2 && (n2 += " "), n2 += f2);
    return n2;
  }
  function clsx() {
    for (var e, t2, f2 = 0, n2 = "", o2 = arguments.length; f2 < o2; f2++) (e = arguments[f2]) && (t2 = r$2(e)) && (n2 && (n2 += " "), n2 += t2);
    return n2;
  }
  function _arrayLikeToArray(r2, a2) {
    (null == a2 || a2 > r2.length) && (a2 = r2.length);
    for (var e = 0, n2 = Array(a2); e < a2; e++) n2[e] = r2[e];
    return n2;
  }
  function _arrayWithoutHoles(r2) {
    if (Array.isArray(r2)) return _arrayLikeToArray(r2);
  }
  function _iterableToArray(r2) {
    if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
  }
  function _unsupportedIterableToArray(r2, a2) {
    if (r2) {
      if ("string" == typeof r2) return _arrayLikeToArray(r2, a2);
      var t2 = {}.toString.call(r2).slice(8, -1);
      return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
    }
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toConsumableArray(r2) {
    return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
  }
  let raf = (callback) => +setTimeout(callback, 16);
  let caf = (num) => clearTimeout(num);
  if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
    raf = (callback) => window.requestAnimationFrame(callback);
    caf = (handle) => window.cancelAnimationFrame(handle);
  }
  let rafUUID = 0;
  const rafIds = new Map();
  function cleanup(id2) {
    rafIds.delete(id2);
  }
  const wrapperRaf = (callback, times2 = 1) => {
    rafUUID += 1;
    const id2 = rafUUID;
    function callRef(leftTimes) {
      if (leftTimes === 0) {
        cleanup(id2);
        callback();
      } else {
        const realId = raf(() => {
          callRef(leftTimes - 1);
        });
        rafIds.set(id2, realId);
      }
    }
    callRef(times2);
    return id2;
  };
  wrapperRaf.cancel = (id2) => {
    const realId = rafIds.get(id2);
    cleanup(id2);
    return caf(realId);
  };
  function throttleByAnimationFrame(fn) {
    let requestId = null;
    const later = (args) => () => {
      requestId = null;
      fn.apply(void 0, _toConsumableArray(args));
    };
    const throttled = (...args) => {
      if (requestId === null) {
        requestId = wrapperRaf(later(args));
      }
    };
    throttled.cancel = () => {
      wrapperRaf.cancel(requestId);
      requestId = null;
    };
    return throttled;
  }
  const defaultPrefixCls = "ant";
  const defaultIconPrefixCls = "anticon";
  const Variants = ["outlined", "borderless", "filled", "underlined"];
  const defaultGetPrefixCls = (suffixCls, customizePrefixCls) => {
    if (customizePrefixCls) {
      return customizePrefixCls;
    }
    return suffixCls ? `${defaultPrefixCls}-${suffixCls}` : defaultPrefixCls;
  };
  const ConfigContext = reactExports.createContext({
getPrefixCls: defaultGetPrefixCls,
    iconPrefixCls: defaultIconPrefixCls
  });
  const {
    Consumer: ConfigConsumer
  } = ConfigContext;
  const EMPTY_OBJECT = {};
  function useComponentConfig(propName) {
    const context = reactExports.useContext(ConfigContext);
    const {
      getPrefixCls,
      direction,
      getPopupContainer,
      renderEmpty
    } = context;
    const propValue = context[propName];
    return {
      classNames: EMPTY_OBJECT,
      styles: EMPTY_OBJECT,
      ...propValue,
      getPrefixCls,
      direction,
      getPopupContainer,
      renderEmpty
    };
  }
  function murmur2(str) {
    var h2 = 0;
    var k, i2 = 0, len = str.length;
    for (; len >= 4; ++i2, len -= 4) {
      k = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
      k =
(k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
      k ^=
k >>> 24;
      h2 =
(k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^
(h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
      case 2:
        h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
      case 1:
        h2 ^= str.charCodeAt(i2) & 255;
        h2 =
(h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    h2 ^= h2 >>> 13;
    h2 =
(h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
  }
  function contains(root2, n2) {
    if (!root2) {
      return false;
    }
    if (root2.contains) {
      return root2.contains(n2);
    }
    let node2 = n2;
    while (node2) {
      if (node2 === root2) {
        return true;
      }
      node2 = node2.parentNode;
    }
    return false;
  }
  const APPEND_ORDER = "data-rc-order";
  const APPEND_PRIORITY = "data-rc-priority";
  const MARK_KEY = `rc-util-key`;
  const containerCache = new Map();
  function getMark({
    mark
  } = {}) {
    if (mark) {
      return mark.startsWith("data-") ? mark : `data-${mark}`;
    }
    return MARK_KEY;
  }
  function getContainer(option) {
    if (option.attachTo) {
      return option.attachTo;
    }
    const head = document.querySelector("head");
    return head || document.body;
  }
  function getOrder(prepend) {
    if (prepend === "queue") {
      return "prependQueue";
    }
    return prepend ? "prepend" : "append";
  }
  function findStyles(container) {
    return Array.from((containerCache.get(container) || container).children).filter((node2) => node2.tagName === "STYLE");
  }
  function injectCSS(css2, option = {}) {
    if (!canUseDom()) {
      return null;
    }
    const {
      csp,
      prepend,
      priority = 0
    } = option;
    const mergedOrder = getOrder(prepend);
    const isPrependQueue = mergedOrder === "prependQueue";
    const styleNode = document.createElement("style");
    styleNode.setAttribute(APPEND_ORDER, mergedOrder);
    if (isPrependQueue && priority) {
      styleNode.setAttribute(APPEND_PRIORITY, `${priority}`);
    }
    if (csp?.nonce) {
      styleNode.nonce = csp?.nonce;
    }
    styleNode.innerHTML = css2;
    const container = getContainer(option);
    const {
      firstChild
    } = container;
    if (prepend) {
      if (isPrependQueue) {
        const existStyle = (option.styles || findStyles(container)).filter((node2) => {
          if (!["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER))) {
            return false;
          }
          const nodePriority = Number(node2.getAttribute(APPEND_PRIORITY) || 0);
          return priority >= nodePriority;
        });
        if (existStyle.length) {
          container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
          return styleNode;
        }
      }
      container.insertBefore(styleNode, firstChild);
    } else {
      container.appendChild(styleNode);
    }
    return styleNode;
  }
  function findExistNode(key, option = {}) {
    let {
      styles
    } = option;
    styles ||= findStyles(getContainer(option));
    return styles.find((node2) => node2.getAttribute(getMark(option)) === key);
  }
  function removeCSS(key, option = {}) {
    const existNode = findExistNode(key, option);
    if (existNode) {
      const container = getContainer(option);
      container.removeChild(existNode);
    }
  }
  function syncRealContainer(container, option) {
    const cachedRealContainer = containerCache.get(container);
    if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
      const placeholderStyle = injectCSS("", option);
      const {
        parentNode
      } = placeholderStyle;
      containerCache.set(container, parentNode);
      container.removeChild(placeholderStyle);
    }
  }
  function updateCSS(css2, key, originOption = {}) {
    const container = getContainer(originOption);
    const styles = findStyles(container);
    const option = {
      ...originOption,
      styles
    };
    syncRealContainer(container, option);
    const existNode = findExistNode(key, option);
    if (existNode) {
      if (option.csp?.nonce && existNode.nonce !== option.csp?.nonce) {
        existNode.nonce = option.csp?.nonce;
      }
      if (existNode.innerHTML !== css2) {
        existNode.innerHTML = css2;
      }
      return existNode;
    }
    const newNode = injectCSS(css2, option);
    newNode.setAttribute(getMark(option), key);
    return newNode;
  }
  function isEqual$1(obj1, obj2, shallow = false) {
    const refSet2 = new Set();
    function deepEqual(a2, b, level = 1) {
      const circular = refSet2.has(a2);
      warningOnce(!circular, "Warning: There may be circular references");
      if (circular) {
        return false;
      }
      if (a2 === b) {
        return true;
      }
      if (shallow && level > 1) {
        return false;
      }
      refSet2.add(a2);
      const newLevel = level + 1;
      if (Array.isArray(a2)) {
        if (!Array.isArray(b) || a2.length !== b.length) {
          return false;
        }
        for (let i2 = 0; i2 < a2.length; i2++) {
          if (!deepEqual(a2[i2], b[i2], newLevel)) {
            return false;
          }
        }
        return true;
      }
      if (a2 && b && typeof a2 === "object" && typeof b === "object") {
        const keys2 = Object.keys(a2);
        if (keys2.length !== Object.keys(b).length) {
          return false;
        }
        return keys2.every((key) => deepEqual(a2[key], b[key], newLevel));
      }
      return false;
    }
    return deepEqual(obj1, obj2);
  }
  const SPLIT$1 = "%";
  function pathKey(keys2) {
    return keys2.join(SPLIT$1);
  }
  let updateId = 0;
  class Entity {
    instanceId;
    constructor(instanceId) {
      this.instanceId = instanceId;
    }
cache = new Map();
updateTimes = new Map();
    extracted = new Set();
    get(keys2) {
      return this.opGet(pathKey(keys2));
    }
opGet(keyPathStr) {
      return this.cache.get(keyPathStr) || null;
    }
    update(keys2, valueFn) {
      return this.opUpdate(pathKey(keys2), valueFn);
    }
opUpdate(keyPathStr, valueFn) {
      const prevValue = this.cache.get(keyPathStr);
      const nextValue = valueFn(prevValue);
      if (nextValue === null) {
        this.cache.delete(keyPathStr);
        this.updateTimes.delete(keyPathStr);
      } else {
        this.cache.set(keyPathStr, nextValue);
        this.updateTimes.set(keyPathStr, updateId);
        updateId += 1;
      }
    }
  }
  const AUTO_PREFIX = {};
  const ATTR_TOKEN = "data-token-hash";
  const ATTR_MARK = "data-css-hash";
  const CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
  function createCache2() {
    const cssinjsInstanceId = Math.random().toString(12).slice(2);
    if (typeof document !== "undefined" && document.head && document.body) {
      const styles = document.body.querySelectorAll(`style[${ATTR_MARK}]`) || [];
      const {
        firstChild
      } = document.head;
      Array.from(styles).forEach((style2) => {
        style2[CSS_IN_JS_INSTANCE] ||= cssinjsInstanceId;
        if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
          document.head.insertBefore(style2, firstChild);
        }
      });
      const styleHash = {};
      Array.from(document.querySelectorAll(`style[${ATTR_MARK}]`)).forEach((style2) => {
        const hash2 = style2.getAttribute(ATTR_MARK);
        if (styleHash[hash2]) {
          if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
            style2.parentNode?.removeChild(style2);
          }
        } else {
          styleHash[hash2] = true;
        }
      });
    }
    return new Entity(cssinjsInstanceId);
  }
  const StyleContext = reactExports.createContext({
    hashPriority: "low",
    cache: createCache2(),
    defaultCache: true,
    autoPrefix: false
  });
  const StyleProvider = (props) => {
    const {
      children,
      ...restProps
    } = props;
    const parentContext = reactExports.useContext(StyleContext);
    const context = useMemo(() => {
      const mergedContext = {
        ...parentContext
      };
      Object.keys(restProps).forEach((key) => {
        const value = restProps[key];
        if (restProps[key] !== void 0) {
          mergedContext[key] = value;
        }
      });
      const {
        cache: cache2,
        transformers = []
      } = restProps;
      mergedContext.cache = mergedContext.cache || createCache2();
      mergedContext.defaultCache = !cache2 && parentContext.defaultCache;
      if (transformers.includes(AUTO_PREFIX)) {
        mergedContext.autoPrefix = true;
      }
      return mergedContext;
    }, [parentContext, restProps], (prev2, next2) => !isEqual$1(prev2[0], next2[0], true) || !isEqual$1(prev2[1], next2[1], true));
    return reactExports.createElement(StyleContext.Provider, {
      value: context
    }, children);
  };
  function sameDerivativeOption(left, right) {
    if (left.length !== right.length) {
      return false;
    }
    for (let i2 = 0; i2 < left.length; i2++) {
      if (left[i2] !== right[i2]) {
        return false;
      }
    }
    return true;
  }
  class ThemeCache {
    static MAX_CACHE_SIZE = 20;
    static MAX_CACHE_OFFSET = 5;
    cache;
    keys;
    cacheCallTimes;
    constructor() {
      this.cache = new Map();
      this.keys = [];
      this.cacheCallTimes = 0;
    }
    size() {
      return this.keys.length;
    }
    internalGet(derivativeOption, updateCallTimes = false) {
      let cache2 = {
        map: this.cache
      };
      derivativeOption.forEach((derivative2) => {
        if (!cache2) {
          cache2 = void 0;
        } else {
          cache2 = cache2?.map?.get(derivative2);
        }
      });
      if (cache2?.value && updateCallTimes) {
        cache2.value[1] = this.cacheCallTimes++;
      }
      return cache2?.value;
    }
    get(derivativeOption) {
      return this.internalGet(derivativeOption, true)?.[0];
    }
    has(derivativeOption) {
      return !!this.internalGet(derivativeOption);
    }
    set(derivativeOption, value) {
      if (!this.has(derivativeOption)) {
        if (this.size() + 1 > ThemeCache.MAX_CACHE_SIZE + ThemeCache.MAX_CACHE_OFFSET) {
          const [targetKey] = this.keys.reduce((result, key) => {
            const [, callTimes] = result;
            if (this.internalGet(key)[1] < callTimes) {
              return [key, this.internalGet(key)[1]];
            }
            return result;
          }, [this.keys[0], this.cacheCallTimes]);
          this.delete(targetKey);
        }
        this.keys.push(derivativeOption);
      }
      let cache2 = this.cache;
      derivativeOption.forEach((derivative2, index) => {
        if (index === derivativeOption.length - 1) {
          cache2.set(derivative2, {
            value: [value, this.cacheCallTimes++]
          });
        } else {
          const cacheValue = cache2.get(derivative2);
          if (!cacheValue) {
            cache2.set(derivative2, {
              map: new Map()
            });
          } else if (!cacheValue.map) {
            cacheValue.map = new Map();
          }
          cache2 = cache2.get(derivative2).map;
        }
      });
    }
    deleteByPath(currentCache, derivatives) {
      const cache2 = currentCache.get(derivatives[0]);
      if (derivatives.length === 1) {
        if (!cache2.map) {
          currentCache.delete(derivatives[0]);
        } else {
          currentCache.set(derivatives[0], {
            map: cache2.map
          });
        }
        return cache2.value?.[0];
      }
      const result = this.deleteByPath(cache2.map, derivatives.slice(1));
      if ((!cache2.map || cache2.map.size === 0) && !cache2.value) {
        currentCache.delete(derivatives[0]);
      }
      return result;
    }
    delete(derivativeOption) {
      if (this.has(derivativeOption)) {
        this.keys = this.keys.filter((item) => !sameDerivativeOption(item, derivativeOption));
        return this.deleteByPath(this.cache, derivativeOption);
      }
      return void 0;
    }
  }
  let uuid$4 = 0;
  class Theme {
    derivatives;
    id;
    constructor(derivatives) {
      this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
      this.id = uuid$4;
      if (derivatives.length === 0) {
        warning$2(derivatives.length > 0);
      }
      uuid$4 += 1;
    }
    getDerivativeToken(token2) {
      return this.derivatives.reduce((result, derivative2) => derivative2(token2, result), void 0);
    }
  }
  const cacheThemes = new ThemeCache();
  function createTheme(derivatives) {
    const derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
    if (!cacheThemes.has(derivativeArr)) {
      cacheThemes.set(derivativeArr, new Theme(derivativeArr));
    }
    return cacheThemes.get(derivativeArr);
  }
  const resultCache = new WeakMap();
  const RESULT_VALUE = {};
  function memoResult(callback, deps) {
    let current = resultCache;
    for (let i2 = 0; i2 < deps.length; i2 += 1) {
      const dep = deps[i2];
      if (!current.has(dep)) {
        current.set(dep, new WeakMap());
      }
      current = current.get(dep);
    }
    if (!current.has(RESULT_VALUE)) {
      current.set(RESULT_VALUE, callback());
    }
    return current.get(RESULT_VALUE);
  }
  const flattenTokenCache = new WeakMap();
  function flattenToken(token2) {
    let str = flattenTokenCache.get(token2) || "";
    if (!str) {
      Object.keys(token2).forEach((key) => {
        const value = token2[key];
        str += key;
        if (value instanceof Theme) {
          str += value.id;
        } else if (value && typeof value === "object") {
          str += flattenToken(value);
        } else {
          str += value;
        }
      });
      str = murmur2(str);
      flattenTokenCache.set(token2, str);
    }
    return str;
  }
  function token2key(token2, salt) {
    return murmur2(`${salt}_${flattenToken(token2)}`);
  }
  const isClientSide = canUseDom();
  function unit$1(num) {
    if (typeof num === "number") {
      return `${num}px`;
    }
    return num;
  }
  function where(options) {
    const {
      hashCls,
      hashPriority = "low"
    } = options || {};
    if (!hashCls) {
      return "";
    }
    const hashSelector = `.${hashCls}`;
    return hashPriority === "low" ? `:where(${hashSelector})` : hashSelector;
  }
  const isNonNullable$1 = (val) => {
    return val !== void 0 && val !== null;
  };
  const token2CSSVar = (token2, prefix2 = "") => {
    return `--${prefix2 ? `${prefix2}-` : ""}${token2}`.replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase();
  };
  const serializeCSSVar = (cssVars2, hashId, options) => {
    const {
      hashCls,
      hashPriority = "low",
      scope
    } = options || {};
    if (!Object.keys(cssVars2).length) {
      return "";
    }
    const baseSelector = `${where({
    hashCls,
    hashPriority
  })}.${hashId}`;
    const scopes = [scope].flat().filter(Boolean);
    const selector = scopes.length ? scopes.map((s2) => `${baseSelector}.${s2}`).join(", ") : baseSelector;
    return `${selector}{${Object.entries(cssVars2).map(([key, value]) => `${key}:${value};`).join("")}}`;
  };
  const transformToken = (token2, themeKey, config) => {
    const {
      hashCls,
      hashPriority = "low",
      prefix: prefix2,
      unitless: unitless2,
      ignore: ignore2,
      preserve: preserve2
    } = config || {};
    const cssVars2 = {};
    const result = {};
    Object.entries(token2).forEach(([key, value]) => {
      if (preserve2?.[key]) {
        result[key] = value;
      } else if ((typeof value === "string" || typeof value === "number") && !ignore2?.[key]) {
        const cssVar2 = token2CSSVar(key, prefix2);
        cssVars2[cssVar2] = typeof value === "number" && !unitless2?.[key] ? `${value}px` : String(value);
        result[key] = `var(${cssVar2})`;
      }
    });
    return [result, serializeCSSVar(cssVars2, themeKey, {
      scope: config?.scope,
      hashCls,
      hashPriority
    })];
  };
  const effectMap = new Map();
  function useGlobalCache(prefix2, keyPath, cacheFn, onCacheRemove, onCacheEffect) {
    const {
      cache: globalCache
    } = reactExports.useContext(StyleContext);
    const fullPath = [prefix2, ...keyPath];
    const fullPathStr = pathKey(fullPath);
    const buildCache = (updater) => {
      globalCache.opUpdate(fullPathStr, (prevCache) => {
        const [times2 = 0, cache2] = prevCache || [void 0, void 0];
        let tmpCache = cache2;
        const mergedCache = tmpCache || cacheFn();
        const data2 = [times2, mergedCache];
        return updater ? updater(data2) : data2;
      });
    };
    reactExports.useMemo(
      () => {
        buildCache();
      },
[fullPathStr]
);
    let cacheEntity = globalCache.opGet(fullPathStr);
    const cacheContent = cacheEntity[1];
    reactExports.useInsertionEffect(() => {
      buildCache(([times2, cache2]) => [times2 + 1, cache2]);
      if (!effectMap.has(fullPathStr)) {
        onCacheEffect?.(cacheContent);
        effectMap.set(fullPathStr, true);
        Promise.resolve().then(() => {
          effectMap.delete(fullPathStr);
        });
      }
      return () => {
        globalCache.opUpdate(fullPathStr, (prevCache) => {
          const [times2 = 0, cache2] = prevCache || [];
          const nextCount = times2 - 1;
          if (nextCount === 0) {
            onCacheRemove?.(cache2, false);
            effectMap.delete(fullPathStr);
            return null;
          }
          return [times2 - 1, cache2];
        });
      };
    }, [fullPathStr]);
    return cacheContent;
  }
  const EMPTY_OVERRIDE = {};
  const hashPrefix = "css";
  const tokenKeys = new Map();
  function recordCleanToken(tokenKey) {
    tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
  }
  function removeStyleTags(key, instanceId) {
    if (typeof document !== "undefined") {
      const styles = document.querySelectorAll(`style[${ATTR_TOKEN}="${key}"]`);
      styles.forEach((style2) => {
        if (style2[CSS_IN_JS_INSTANCE] === instanceId) {
          style2.parentNode?.removeChild(style2);
        }
      });
    }
  }
  const TOKEN_THRESHOLD = -1;
  function cleanTokenStyle(tokenKey, instanceId) {
    tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
    const cleanableKeyList = new Set();
    tokenKeys.forEach((value, key) => {
      if (value <= 0) cleanableKeyList.add(key);
    });
    if (tokenKeys.size - cleanableKeyList.size > TOKEN_THRESHOLD) {
      cleanableKeyList.forEach((key) => {
        removeStyleTags(key, instanceId);
        tokenKeys.delete(key);
      });
    }
  }
  const getComputedToken$1 = (originToken, overrideToken, theme2, format2) => {
    const derivativeToken = theme2.getDerivativeToken(originToken);
    let mergedDerivativeToken = {
      ...derivativeToken,
      ...overrideToken
    };
    if (format2) {
      mergedDerivativeToken = format2(mergedDerivativeToken);
    }
    return mergedDerivativeToken;
  };
  const TOKEN_PREFIX = "token";
  function useCacheToken(theme2, tokens, option) {
    const {
      cache: {
        instanceId
      },
      container,
      hashPriority
    } = reactExports.useContext(StyleContext);
    const {
      salt = "",
      override = EMPTY_OVERRIDE,
      formatToken: formatToken2,
      getComputedToken: compute,
      cssVar: cssVar2
    } = option;
    const mergedToken = memoResult(() => Object.assign({}, ...tokens), tokens);
    const tokenStr = flattenToken(mergedToken);
    const overrideTokenStr = flattenToken(override);
    const cssVarStr = flattenToken(cssVar2);
    const cachedToken = useGlobalCache(TOKEN_PREFIX, [salt, theme2.id, tokenStr, overrideTokenStr, cssVarStr], () => {
      const mergedDerivativeToken = compute ? compute(mergedToken, override, theme2) : getComputedToken$1(mergedToken, override, theme2, formatToken2);
      const actualToken = {
        ...mergedDerivativeToken
      };
      const mergedSalt = `${salt}_${cssVar2.prefix}`;
      const hashId = murmur2(mergedSalt);
      const hashCls = `${hashPrefix}-${hashId}`;
      actualToken._tokenKey = token2key(actualToken, mergedSalt);
      const [tokenWithCssVar, cssVarsStr] = transformToken(mergedDerivativeToken, cssVar2.key, {
        prefix: cssVar2.prefix,
        ignore: cssVar2.ignore,
        unitless: cssVar2.unitless,
        preserve: cssVar2.preserve,
        hashPriority,
        hashCls: cssVar2.hashed ? hashCls : void 0
      });
      tokenWithCssVar._hashId = hashId;
      recordCleanToken(cssVar2.key);
      return [tokenWithCssVar, hashCls, actualToken, cssVarsStr, cssVar2.key];
    }, ([, , , , themeKey]) => {
      cleanTokenStyle(themeKey, instanceId);
    }, ([, , , cssVarsStr, themeKey]) => {
      if (!cssVarsStr) {
        return;
      }
      const style2 = updateCSS(cssVarsStr, murmur2(`css-var-${themeKey}`), {
        mark: ATTR_MARK,
        prepend: "queue",
        attachTo: container,
        priority: -999
      });
      style2[CSS_IN_JS_INSTANCE] = instanceId;
      style2.setAttribute(ATTR_TOKEN, themeKey);
    });
    return cachedToken;
  }
  var unitlessKeys = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };
  var MS = "-ms-";
  var MOZ = "-moz-";
  var WEBKIT = "-webkit-";
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var NAMESPACE = "@namespace";
  var KEYFRAMES = "@keyframes";
  var LAYER = "@layer";
  var abs = Math.abs;
  var from = String.fromCharCode;
  var assign = Object.assign;
  function hash(value, length2) {
    return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
  }
  function trim(value) {
    return value.trim();
  }
  function match$1(value, pattern4) {
    return (value = pattern4.exec(value)) ? value[0] : value;
  }
  function replace(value, pattern4, replacement) {
    return value.replace(pattern4, replacement);
  }
  function indexof(value, search, position2) {
    return value.indexOf(search, position2);
  }
  function charat(value, index) {
    return value.charCodeAt(index) | 0;
  }
  function substr(value, begin, end) {
    return value.slice(begin, end);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array4) {
    return array4.push(value), value;
  }
  function combine(array4, callback) {
    return array4.map(callback).join("");
  }
  function filter$2(array4, pattern4) {
    return array4.filter(function(value) {
      return !match$1(value, pattern4);
    });
  }
  var line = 1;
  var column = 1;
  var length = 0;
  var position$1 = 0;
  var character = 0;
  var characters = "";
  function node(value, root2, parent, type4, props, children, length2, siblings) {
    return { value, root: root2, parent, type: type4, props, children, line, column, length: length2, return: "", siblings };
  }
  function copy(root2, props) {
    return assign(node("", null, null, "", null, null, 0, root2.siblings), root2, { length: -root2.length }, props);
  }
  function lift(root2) {
    while (root2.root)
      root2 = copy(root2.root, { children: [root2] });
    append(root2, root2.siblings);
  }
  function char() {
    return character;
  }
  function prev() {
    character = position$1 > 0 ? charat(characters, --position$1) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position$1 < length ? charat(characters, position$1++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek() {
    return charat(characters, position$1);
  }
  function caret() {
    return position$1;
  }
  function slice(begin, end) {
    return substr(characters, begin, end);
  }
  function token(type4) {
    switch (type4) {
case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
case 59:
      case 123:
      case 125:
        return 4;
case 58:
        return 3;
case 34:
      case 39:
      case 40:
      case 91:
        return 2;
case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position$1 = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type4) {
    return trim(slice(position$1 - 1, delimiter(type4 === 91 ? type4 + 2 : type4 === 40 ? type4 + 1 : type4)));
  }
  function whitespace$1(type4) {
    while (character = peek())
      if (character < 33)
        next();
      else
        break;
    return token(type4) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index, count) {
    while (--count && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
  }
  function delimiter(type4) {
    while (next())
      switch (character) {
case type4:
          return position$1;
case 34:
        case 39:
          if (type4 !== 34 && type4 !== 39)
            delimiter(character);
          break;
case 40:
          if (type4 === 41)
            delimiter(type4);
          break;
case 92:
          next();
          break;
      }
    return position$1;
  }
  function commenter(type4, index) {
    while (next())
      if (type4 + character === 47 + 10)
        break;
      else if (type4 + character === 42 + 42 && peek() === 47)
        break;
    return "/*" + slice(index, position$1 - 1) + "*" + from(type4 === 47 ? type4 : next());
  }
  function identifier(index) {
    while (!token(peek()))
      next();
    return slice(index, position$1);
  }
  function compile(value) {
    return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse(value, root2, parent, rule, rules2, rulesets, pseudo, points, declarations) {
    var index = 0;
    var offset2 = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type4 = "";
    var props = rules2;
    var children = rulesets;
    var reference = rule;
    var characters2 = type4;
    while (scanning)
      switch (previous = character2, character2 = next()) {
case 40:
          if (previous != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs(index ? points[index - 1] : 0)) != -1)
              ampersand = -1;
            break;
          }
case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace$1(previous);
          break;
case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(comment(commenter(next(), caret()), root2, parent, declarations), declarations);
              if ((token(previous || 1) == 5 || token(peek() || 1) == 5) && strlen(characters2) && substr(characters2, -1, void 0) !== " ") characters2 += " ";
              break;
            default:
              characters2 += "/";
          }
          break;
case 123 * variable:
          points[index++] = strlen(characters2) * ampersand;
case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
case 0:
            case 125:
              scanning = 0;
case 59 + offset2:
              if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
              if (property > 0 && (strlen(characters2) - length2 || variable === 0 && previous === 47))
                append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
              break;
case 59:
              characters2 += ";";
default:
              append(reference = ruleset(characters2, root2, parent, index, offset2, rules2, points, type4, props = [], children = [], length2, rulesets), rulesets);
              if (character2 === 123)
                if (offset2 === 0)
                  parse(characters2, root2, reference, reference, props, rulesets, length2, points, children);
                else {
                  switch (atrule) {
case 99:
                      if (charat(characters2, 3) === 110) break;
case 108:
                      if (charat(characters2, 2) === 97) break;
                    default:
                      offset2 = 0;
case 100:
                    case 109:
                    case 115:
                  }
                  if (offset2) parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules2, points, type4, rules2, props = [], length2, children), children), rules2, children, length2, points, rule ? props : children);
                  else parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
          }
          index = offset2 = property = 0, variable = ampersand = 1, type4 = characters2 = "", length2 = pseudo;
          break;
case 58:
          length2 = 1 + strlen(characters2), property = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
case 38:
              ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
              break;
case 44:
              points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
case 64:
              if (peek() === 45)
                characters2 += delimit(next());
              atrule = peek(), offset2 = length2 = strlen(type4 = characters2 += identifier(caret())), character2++;
              break;
case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root2, parent, index, offset2, rules2, points, type4, props, children, length2, siblings) {
    var post = offset2 - 1;
    var rule = offset2 === 0 ? rules2 : [""];
    var size = sizeof(rule);
    for (var i2 = 0, j = 0, k = 0; i2 < index; ++i2)
      for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i2])), z = value; x < size; ++x)
        if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
          props[k++] = z;
    return node(value, root2, parent, offset2 === 0 ? RULESET : type4, props, children, length2, siblings);
  }
  function comment(value, root2, parent, siblings) {
    return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
  }
  function declaration(value, root2, parent, length2, siblings) {
    return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
  }
  function prefix(value, length2, children) {
    switch (hash(value, length2)) {
case 5103:
        return WEBKIT + "print-" + value + value;
case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
        return WEBKIT + value + value;
case 4855:
        return WEBKIT + value.replace("add", "source-over").replace("substract", "source-out").replace("intersect", "source-in").replace("exclude", "xor") + value;
case 4789:
        return MOZ + value + value;
case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return WEBKIT + value + MOZ + value + MS + value + value;
case 5936:
        switch (charat(value, length2 + 11)) {
case 114:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
case 108:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
case 45:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
        }
case 6828:
      case 4268:
      case 2903:
        return WEBKIT + value + MS + value + value;
case 6165:
        return WEBKIT + value + MS + "flex-" + value + value;
case 5187:
        return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
case 5443:
        return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/g, "") + (!match$1(value, /flex-|baseline/) ? MS + "grid-row-" + replace(value, /flex-|-self/g, "") : "") + value;
case 4675:
        return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/g, "") + value;
case 5548:
        return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
case 5292:
        return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
case 6060:
        return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
case 4554:
        return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
case 6187:
        return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
case 5495:
      case 3959:
        return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
case 4968:
        return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /space-between/, "justify") + WEBKIT + value + value;
case 4200:
        if (!match$1(value, /flex-|baseline/)) return MS + "grid-column-align" + substr(value, length2) + value;
        break;
case 2592:
      case 3360:
        return MS + replace(value, "template-", "") + value;
case 4384:
      case 3616:
        if (children && children.some(function(element, index) {
          return length2 = index, match$1(element.props, /grid-\w+-end/);
        })) {
          return ~indexof(value + (children = children[length2].value), "span", 0) ? value : MS + replace(value, "-start", "") + value + MS + "grid-row-span:" + (~indexof(children, "span", 0) ? match$1(children, /\d+/) : +match$1(children, /\d+/) - +match$1(value, /\d+/)) + ";";
        }
        return MS + replace(value, "-start", "") + value;
case 4896:
      case 4128:
        return children && children.some(function(element) {
          return match$1(element.props, /grid-\w+-start/);
        }) ? value : MS + replace(replace(value, "-end", "-span"), "span ", "") + value;
case 4095:
      case 3583:
      case 4068:
      case 2532:
        return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (strlen(value) - 1 - length2 > 6)
          switch (charat(value, length2 + 1)) {
case 109:
              if (charat(value, length2 + 4) !== 45)
                break;
case 102:
              return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
case 115:
              return ~indexof(value, "stretch", 0) ? prefix(replace(value, "stretch", "fill-available"), length2, children) + value : value;
          }
        break;
case 5152:
      case 5920:
        return replace(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(_2, a2, b, c2, d2, e, f2) {
          return MS + a2 + ":" + b + f2 + (c2 ? MS + a2 + "-span:" + (d2 ? e : +e - +b) + f2 : "") + value;
        });
case 4949:
        if (charat(value, length2 + 6) === 121)
          return replace(value, ":", ":" + WEBKIT) + value;
        break;
case 6444:
        switch (charat(value, charat(value, 14) === 45 ? 18 : 11)) {
case 120:
            return replace(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
case 100:
            return replace(value, ":", ":" + MS) + value;
        }
        break;
case 5719:
      case 2647:
      case 2135:
      case 3927:
      case 2391:
        return replace(value, "scroll-", "scroll-snap-") + value;
    }
    return value;
  }
  function serialize(children, callback) {
    var output = "";
    for (var i2 = 0; i2 < children.length; i2++)
      output += callback(children[i2], i2, children, callback) || "";
    return output;
  }
  function stringify$2(element, index, children, callback) {
    switch (element.type) {
      case LAYER:
        if (element.children.length) break;
      case IMPORT:
      case NAMESPACE:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize(element.children, callback) + "}";
      case RULESET:
        if (!strlen(element.value = element.props.join(","))) return "";
    }
    return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
  }
  function middleware(collection) {
    var length2 = sizeof(collection);
    return function(element, index, children, callback) {
      var output = "";
      for (var i2 = 0; i2 < length2; i2++)
        output += collection[i2](element, index, children, callback) || "";
      return output;
    };
  }
  function prefixer2(element, index, children, callback) {
    if (element.length > -1) {
      if (!element.return)
        switch (element.type) {
          case DECLARATION:
            element.return = prefix(element.value, element.length, children);
            return;
          case KEYFRAMES:
            return serialize([copy(element, { value: replace(element.value, "@", "@" + WEBKIT) })], callback);
          case RULESET:
            if (element.length)
              return combine(children = element.props, function(value) {
                switch (match$1(value, callback = /(::plac\w+|:read-\w+)/)) {
case ":read-only":
                  case ":read-write":
                    lift(copy(element, { props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")] }));
                    lift(copy(element, { props: [value] }));
                    assign(element, { props: filter$2(children, callback) });
                    break;
case "::placeholder":
                    lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }));
                    lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")] }));
                    lift(copy(element, { props: [replace(value, /:(plac\w+)/, MS + "input-$1")] }));
                    lift(copy(element, { props: [value] }));
                    assign(element, { props: filter$2(children, callback) });
                    break;
                }
                return "";
              });
        }
    }
  }
  const ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path";
  const CSS_FILE_STYLE = "_FILE_STYLE__";
  let cachePathMap;
  let fromCSSFile = true;
  function prepare() {
    if (!cachePathMap) {
      cachePathMap = {};
      if (canUseDom()) {
        const div = document.createElement("div");
        div.className = ATTR_CACHE_MAP;
        div.style.position = "fixed";
        div.style.visibility = "hidden";
        div.style.top = "-9999px";
        document.body.appendChild(div);
        let content = getComputedStyle(div).content || "";
        content = content.replace(/^"/, "").replace(/"$/, "");
        content.split(";").forEach((item) => {
          const [path, hash2] = item.split(":");
          cachePathMap[path] = hash2;
        });
        const inlineMapStyle = document.querySelector(`style[${ATTR_CACHE_MAP}]`);
        if (inlineMapStyle) {
          fromCSSFile = false;
          inlineMapStyle.parentNode?.removeChild(inlineMapStyle);
        }
        document.body.removeChild(div);
      }
    }
  }
  function existPath(path) {
    prepare();
    return !!cachePathMap[path];
  }
  function getStyleAndHash(path) {
    const hash2 = cachePathMap[path];
    let styleStr = null;
    if (hash2 && canUseDom()) {
      if (fromCSSFile) {
        styleStr = CSS_FILE_STYLE;
      } else {
        const style2 = document.querySelector(`style[${ATTR_MARK}="${cachePathMap[path]}"]`);
        if (style2) {
          styleStr = style2.innerHTML;
        } else {
          delete cachePathMap[path];
        }
      }
    }
    return [styleStr, hash2];
  }
  const SKIP_CHECK = "_skip_check_";
  const MULTI_VALUE = "_multi_value_";
  function normalizeStyle(styleStr, autoPrefix) {
    const serialized = autoPrefix ? serialize(compile(styleStr), middleware([prefixer2, stringify$2])) : serialize(compile(styleStr), stringify$2);
    return serialized.replace(/\{%%%\:[^;];}/g, ";");
  }
  function isCompoundCSSProperty(value) {
    return typeof value === "object" && value && (SKIP_CHECK in value || MULTI_VALUE in value);
  }
  function injectSelectorHash(key, hashId, hashPriority = "high") {
    if (!hashId) {
      return key;
    }
    const hashSelector = where({
      hashCls: hashId,
      hashPriority
    });
    const keys2 = key.split(",").map((k) => {
      const fullPath = k.trim().split(/\s+/);
      let firstPath = fullPath[0] || "";
      const htmlElement = firstPath.match(/^\w+/)?.[0] || "";
      firstPath = `${htmlElement}${hashSelector}${firstPath.slice(htmlElement.length)}`;
      return [firstPath, ...fullPath.slice(1)].join(" ");
    });
    return keys2.join(",");
  }
  const parseStyle = (interpolation, config = {}, {
    root: root2,
    injectHash,
    parentSelectors
  } = {
    root: true,
    parentSelectors: []
  }) => {
    const {
      hashId,
      layer,
      path,
      hashPriority,
      transformers = [],
      linters = []
    } = config;
    let styleStr = "";
    let effectStyle = {};
    function parseKeyframes(keyframes2) {
      const animationName = keyframes2.getName(hashId);
      if (!effectStyle[animationName]) {
        const [parsedStr] = parseStyle(keyframes2.style, config, {
          root: false,
          parentSelectors
        });
        effectStyle[animationName] = `@keyframes ${keyframes2.getName(hashId)}${parsedStr}`;
      }
    }
    function flattenList(list2, fullList = []) {
      list2.forEach((item) => {
        if (Array.isArray(item)) {
          flattenList(item, fullList);
        } else if (item) {
          fullList.push(item);
        }
      });
      return fullList;
    }
    const flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
    flattenStyleList.forEach((originStyle) => {
      const style2 = typeof originStyle === "string" && !root2 ? {} : originStyle;
      if (typeof style2 === "string") {
        styleStr += `${style2}
`;
      } else if (style2._keyframe) {
        parseKeyframes(style2);
      } else {
        const mergedStyle = transformers.reduce((prev2, trans) => trans?.visit?.(prev2) || prev2, style2);
        Object.keys(mergedStyle).forEach((key) => {
          const value = mergedStyle[key];
          if (typeof value === "object" && value && (key !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
            let subInjectHash = false;
            let mergedKey = key.trim();
            let nextRoot = false;
            if ((root2 || injectHash) && hashId) {
              if (mergedKey.startsWith("@")) {
                subInjectHash = true;
              } else if (mergedKey === "&") {
                mergedKey = injectSelectorHash("", hashId, hashPriority);
              } else {
                mergedKey = injectSelectorHash(key, hashId, hashPriority);
              }
            } else if (root2 && !hashId && (mergedKey === "&" || mergedKey === "")) {
              mergedKey = "";
              nextRoot = true;
            }
            const [parsedStr, childEffectStyle] = parseStyle(value, config, {
              root: nextRoot,
              injectHash: subInjectHash,
              parentSelectors: [...parentSelectors, mergedKey]
            });
            effectStyle = {
              ...effectStyle,
              ...childEffectStyle
            };
            styleStr += `${mergedKey}${parsedStr}`;
          } else {
            let appendStyle = function(cssKey, cssValue) {
              const styleName = cssKey.replace(/[A-Z]/g, (match2) => `-${match2.toLowerCase()}`);
              let formatValue = cssValue;
              if (!unitlessKeys[cssKey] && typeof formatValue === "number" && formatValue !== 0) {
                formatValue = `${formatValue}px`;
              }
              if (cssKey === "animationName" && cssValue?._keyframe) {
                parseKeyframes(cssValue);
                formatValue = cssValue.getName(hashId);
              }
              styleStr += `${styleName}:${formatValue};`;
            };
            const actualValue = value?.value ?? value;
            if (typeof value === "object" && value?.[MULTI_VALUE] && Array.isArray(actualValue)) {
              actualValue.forEach((item) => {
                appendStyle(key, item);
              });
            } else {
              if (isNonNullable$1(actualValue)) {
                appendStyle(key, actualValue);
              }
            }
          }
        });
      }
    });
    if (!root2) {
      styleStr = `{${styleStr}}`;
    } else if (layer) {
      if (styleStr) {
        styleStr = `@layer ${layer.name} {${styleStr}}`;
      }
      if (layer.dependencies) {
        effectStyle[`@layer ${layer.name}`] = layer.dependencies.map((deps) => `@layer ${deps}, ${layer.name};`).join("\n");
      }
    }
    return [styleStr, effectStyle];
  };
  function uniqueHash(path, styleStr) {
    return murmur2(`${path.join("%")}${styleStr}`);
  }
  const STYLE_PREFIX = "style";
  function useStyleRegister(info, styleFn) {
    const {
      path,
      hashId,
      layer,
      nonce,
      clientOnly,
      order = 0
    } = info;
    const {
      mock,
      hashPriority,
      container,
      transformers,
      linters,
      cache: cache2,
      layer: enableLayer,
      autoPrefix
    } = reactExports.useContext(StyleContext);
    const fullPath = [hashId || ""];
    if (enableLayer) {
      fullPath.push("layer");
    }
    fullPath.push(...path);
    let isMergedClientSide = isClientSide;
    useGlobalCache(
      STYLE_PREFIX,
      fullPath,
() => {
        const cachePath = fullPath.join("|");
        if (existPath(cachePath)) {
          const [inlineCacheStyleStr, styleHash] = getStyleAndHash(cachePath);
          if (inlineCacheStyleStr) {
            return [inlineCacheStyleStr, styleHash, {}, clientOnly, order];
          }
        }
        const styleObj = styleFn();
        const [parsedStyle, effectStyle] = parseStyle(styleObj, {
          hashId,
          hashPriority,
          layer: enableLayer ? layer : void 0,
          path: path.join("-"),
          transformers,
          linters
        });
        const styleStr = normalizeStyle(parsedStyle, autoPrefix || false);
        const styleId = uniqueHash(fullPath, styleStr);
        return [styleStr, styleId, effectStyle, clientOnly, order];
      },
(cacheValue, fromHMR) => {
        const [, styleId] = cacheValue;
        if (fromHMR && isClientSide) {
          removeCSS(styleId, {
            mark: ATTR_MARK,
            attachTo: container
          });
        }
      },
(cacheValue) => {
        const [styleStr, styleId, effectStyle, , priority] = cacheValue;
        if (isMergedClientSide && styleStr !== CSS_FILE_STYLE) {
          const mergedCSSConfig = {
            mark: ATTR_MARK,
            prepend: enableLayer ? false : "queue",
            attachTo: container,
            priority
          };
          const nonceStr = typeof nonce === "function" ? nonce() : nonce;
          if (nonceStr) {
            mergedCSSConfig.csp = {
              nonce: nonceStr
            };
          }
          const effectLayerKeys = [];
          const effectRestKeys = [];
          Object.keys(effectStyle).forEach((key) => {
            if (key.startsWith("@layer")) {
              effectLayerKeys.push(key);
            } else {
              effectRestKeys.push(key);
            }
          });
          effectLayerKeys.forEach((effectKey) => {
            updateCSS(normalizeStyle(effectStyle[effectKey], autoPrefix || false), `_layer-${effectKey}`, {
              ...mergedCSSConfig,
              prepend: true
            });
          });
          const style2 = updateCSS(styleStr, styleId, mergedCSSConfig);
          style2[CSS_IN_JS_INSTANCE] = cache2.instanceId;
          effectRestKeys.forEach((effectKey) => {
            updateCSS(normalizeStyle(effectStyle[effectKey], autoPrefix || false), `_effect-${effectKey}`, mergedCSSConfig);
          });
        }
      }
    );
  }
  const CSS_VAR_PREFIX = "cssVar";
  const useCSSVarRegister = (config, fn) => {
    const {
      key,
      prefix: prefix2,
      unitless: unitless2,
      ignore: ignore2,
      token: token2,
      hashId,
      scope
    } = config;
    const {
      cache: {
        instanceId
      },
      container,
      hashPriority
    } = reactExports.useContext(StyleContext);
    const {
      _tokenKey: tokenKey
    } = token2;
    const scopeKey = Array.isArray(scope) ? scope.join("@@") : scope;
    const stylePath = [...config.path, key, scopeKey, tokenKey];
    const cache2 = useGlobalCache(CSS_VAR_PREFIX, stylePath, () => {
      const originToken = fn();
      const [mergedToken, cssVarsStr] = transformToken(originToken, key, {
        prefix: prefix2,
        unitless: unitless2,
        ignore: ignore2,
        scope,
        hashPriority,
        hashCls: hashId
      });
      const styleId = uniqueHash(stylePath, cssVarsStr);
      return [mergedToken, cssVarsStr, styleId, key];
    }, ([, , styleId]) => {
      if (isClientSide) {
        removeCSS(styleId, {
          mark: ATTR_MARK,
          attachTo: container
        });
      }
    }, ([, cssVarsStr, styleId]) => {
      if (!cssVarsStr) {
        return;
      }
      const style2 = updateCSS(cssVarsStr, styleId, {
        mark: ATTR_MARK,
        prepend: "queue",
        attachTo: container,
        priority: -999
      });
      style2[CSS_IN_JS_INSTANCE] = instanceId;
      style2.setAttribute(ATTR_TOKEN, key);
    });
    return cache2;
  };
  class Keyframe {
    name;
    style;
    constructor(name, style2) {
      this.name = name;
      this.style = style2;
    }
    getName(hashId = "") {
      return hashId ? `${hashId}-${this.name}` : this.name;
    }
    _keyframe = true;
  }
  function noSplit(list2) {
    list2.notSplit = true;
    return list2;
  }
  ({
borderBlock: noSplit(["borderTop", "borderBottom"]),
    borderBlockStart: noSplit(["borderTop"]),
    borderBlockEnd: noSplit(["borderBottom"]),
    borderInline: noSplit(["borderLeft", "borderRight"]),
    borderInlineStart: noSplit(["borderLeft"]),
    borderInlineEnd: noSplit(["borderRight"])
  });
  function _typeof$2(o2) {
    "@babel/helpers - typeof";
    return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof$2(o2);
  }
  function _arrayWithHoles(r2) {
    if (Array.isArray(r2)) return r2;
  }
  function _iterableToArrayLimit(r2, l2) {
    var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
    if (null != t2) {
      var e, n2, i2, u2, a2 = [], f2 = true, o2 = false;
      try {
        if (i2 = (t2 = t2.call(r2)).next, 0 === l2) {
          if (Object(t2) !== t2) return;
          f2 = false;
        } else for (; !(f2 = (e = i2.call(t2)).done) && (a2.push(e.value), a2.length !== l2); f2 = true) ;
      } catch (r3) {
        o2 = true, n2 = r3;
      } finally {
        try {
          if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
        } finally {
          if (o2) throw n2;
        }
      }
      return a2;
    }
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _slicedToArray(r2, e) {
    return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e) || _unsupportedIterableToArray(r2, e) || _nonIterableRest();
  }
  function toPrimitive(t2, r2) {
    if ("object" != _typeof$2(t2) || !t2) return t2;
    var e = t2[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i2 = e.call(t2, r2);
      if ("object" != _typeof$2(i2)) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t2);
  }
  function toPropertyKey(t2) {
    var i2 = toPrimitive(t2, "string");
    return "symbol" == _typeof$2(i2) ? i2 : i2 + "";
  }
  function _defineProperty$1(e, r2, t2) {
    return (r2 = toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, {
      value: t2,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[r2] = t2, e;
  }
  function ownKeys$2(e, r2) {
    var t2 = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e);
      r2 && (o2 = o2.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t2.push.apply(t2, o2);
    }
    return t2;
  }
  function _objectSpread2(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$2(Object(t2), true).forEach(function(r3) {
        _defineProperty$1(e, r3, t2[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$2(Object(t2)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
      });
    }
    return e;
  }
  function _classCallCheck(a2, n2) {
    if (!(a2 instanceof n2)) throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e, r2) {
    for (var t2 = 0; t2 < r2.length; t2++) {
      var o2 = r2[t2];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e, toPropertyKey(o2.key), o2);
    }
  }
  function _createClass(e, r2, t2) {
    return r2 && _defineProperties(e.prototype, r2), t2 && _defineProperties(e, t2), Object.defineProperty(e, "prototype", {
      writable: false
    }), e;
  }
  function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  function _setPrototypeOf(t2, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e2) {
      return t3.__proto__ = e2, t3;
    }, _setPrototypeOf(t2, e);
  }
  function _inherits(t2, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t2.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t2,
        writable: true,
        configurable: true
      }
    }), Object.defineProperty(t2, "prototype", {
      writable: false
    }), e && _setPrototypeOf(t2, e);
  }
  function _getPrototypeOf(t2) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
      return t3.__proto__ || Object.getPrototypeOf(t3);
    }, _getPrototypeOf(t2);
  }
  function _isNativeReflectConstruct() {
    try {
      var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t3) {
    }
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
      return !!t2;
    })();
  }
  function _possibleConstructorReturn(t2, e) {
    if (e && ("object" == _typeof$2(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t2);
  }
  function _createSuper(t2) {
    var r2 = _isNativeReflectConstruct();
    return function() {
      var e, o2 = _getPrototypeOf(t2);
      if (r2) {
        var s2 = _getPrototypeOf(this).constructor;
        e = Reflect.construct(o2, arguments, s2);
      } else e = o2.apply(this, arguments);
      return _possibleConstructorReturn(this, e);
    };
  }
  var AbstractCalculator = _createClass(function AbstractCalculator2() {
    _classCallCheck(this, AbstractCalculator2);
  });
  var CALC_UNIT = "CALC_UNIT";
  var regexp$1 = new RegExp(CALC_UNIT, "g");
  function unit(value) {
    if (typeof value === "number") {
      return "".concat(value).concat(CALC_UNIT);
    }
    return value;
  }
  var CSSCalculator = (function(_AbstractCalculator) {
    _inherits(CSSCalculator2, _AbstractCalculator);
    var _super = _createSuper(CSSCalculator2);
    function CSSCalculator2(num, unitlessCssVar) {
      var _this;
      _classCallCheck(this, CSSCalculator2);
      _this = _super.call(this);
      _defineProperty$1(_assertThisInitialized(_this), "result", "");
      _defineProperty$1(_assertThisInitialized(_this), "unitlessCssVar", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "lowPriority", void 0);
      var numType = _typeof$2(num);
      _this.unitlessCssVar = unitlessCssVar;
      if (num instanceof CSSCalculator2) {
        _this.result = "(".concat(num.result, ")");
      } else if (numType === "number") {
        _this.result = unit(num);
      } else if (numType === "string") {
        _this.result = num;
      }
      return _this;
    }
    _createClass(CSSCalculator2, [{
      key: "add",
      value: function add2(num) {
        if (num instanceof CSSCalculator2) {
          this.result = "".concat(this.result, " + ").concat(num.getResult());
        } else if (typeof num === "number" || typeof num === "string") {
          this.result = "".concat(this.result, " + ").concat(unit(num));
        }
        this.lowPriority = true;
        return this;
      }
    }, {
      key: "sub",
      value: function sub(num) {
        if (num instanceof CSSCalculator2) {
          this.result = "".concat(this.result, " - ").concat(num.getResult());
        } else if (typeof num === "number" || typeof num === "string") {
          this.result = "".concat(this.result, " - ").concat(unit(num));
        }
        this.lowPriority = true;
        return this;
      }
    }, {
      key: "mul",
      value: function mul(num) {
        if (this.lowPriority) {
          this.result = "(".concat(this.result, ")");
        }
        if (num instanceof CSSCalculator2) {
          this.result = "".concat(this.result, " * ").concat(num.getResult(true));
        } else if (typeof num === "number" || typeof num === "string") {
          this.result = "".concat(this.result, " * ").concat(num);
        }
        this.lowPriority = false;
        return this;
      }
    }, {
      key: "div",
      value: function div(num) {
        if (this.lowPriority) {
          this.result = "(".concat(this.result, ")");
        }
        if (num instanceof CSSCalculator2) {
          this.result = "".concat(this.result, " / ").concat(num.getResult(true));
        } else if (typeof num === "number" || typeof num === "string") {
          this.result = "".concat(this.result, " / ").concat(num);
        }
        this.lowPriority = false;
        return this;
      }
    }, {
      key: "getResult",
      value: function getResult(force) {
        return this.lowPriority || force ? "(".concat(this.result, ")") : this.result;
      }
    }, {
      key: "equal",
      value: function equal(options) {
        var _this2 = this;
        var _ref4 = options || {}, cssUnit = _ref4.unit;
        var mergedUnit = true;
        if (typeof cssUnit === "boolean") {
          mergedUnit = cssUnit;
        } else if (Array.from(this.unitlessCssVar).some(function(cssVar2) {
          return _this2.result.includes(cssVar2);
        })) {
          mergedUnit = false;
        }
        this.result = this.result.replace(regexp$1, mergedUnit ? "px" : "");
        if (typeof this.lowPriority !== "undefined") {
          return "calc(".concat(this.result, ")");
        }
        return this.result;
      }
    }]);
    return CSSCalculator2;
  })(AbstractCalculator);
  var genCalc = function genCalc2(type4, unitlessCssVar) {
    var Calculator = CSSCalculator;
    return function(num) {
      return new Calculator(num, unitlessCssVar);
    };
  };
  var getCompVarPrefix = function getCompVarPrefix2(component, prefix2) {
    return "".concat([prefix2, component.replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2")].filter(Boolean).join("-"));
  };
  function getComponentToken(component, token2, defaultToken, options) {
    var customToken = _objectSpread2({}, token2[component]);
    if (options !== null && options !== void 0 && options.deprecatedTokens) {
      var deprecatedTokens = options.deprecatedTokens;
      deprecatedTokens.forEach(function(_ref4) {
        var _ref22 = _slicedToArray(_ref4, 2), oldTokenKey = _ref22[0], newTokenKey = _ref22[1];
        if (customToken !== null && customToken !== void 0 && customToken[oldTokenKey] || customToken !== null && customToken !== void 0 && customToken[newTokenKey]) {
          var _customToken$newToken;
          (_customToken$newToken = customToken[newTokenKey]) !== null && _customToken$newToken !== void 0 ? _customToken$newToken : customToken[newTokenKey] = customToken === null || customToken === void 0 ? void 0 : customToken[oldTokenKey];
        }
      });
    }
    var mergedToken = _objectSpread2(_objectSpread2({}, defaultToken), customToken);
    Object.keys(mergedToken).forEach(function(key) {
      if (mergedToken[key] === token2[key]) {
        delete mergedToken[key];
      }
    });
    return mergedToken;
  }
  var enableStatistic = typeof CSSINJS_STATISTIC !== "undefined";
  var recording = true;
  function merge$1() {
    for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
      objs[_key] = arguments[_key];
    }
    if (!enableStatistic) {
      return Object.assign.apply(Object, [{}].concat(objs));
    }
    recording = false;
    var ret = {};
    objs.forEach(function(obj) {
      if (_typeof$2(obj) !== "object") {
        return;
      }
      var keys2 = Object.keys(obj);
      keys2.forEach(function(key) {
        Object.defineProperty(ret, key, {
          configurable: true,
          enumerable: true,
          get: function get2() {
            return obj[key];
          }
        });
      });
    });
    recording = true;
    return ret;
  }
  var statistic = {};
  function noop$3() {
  }
  var statisticToken = function statisticToken2(token2) {
    var tokenKeys2;
    var proxy2 = token2;
    var flush = noop$3;
    if (enableStatistic && typeof Proxy !== "undefined") {
      tokenKeys2 = new Set();
      proxy2 = new Proxy(token2, {
        get: function get2(obj, prop) {
          if (recording) {
            var _tokenKeys;
            (_tokenKeys = tokenKeys2) === null || _tokenKeys === void 0 || _tokenKeys.add(prop);
          }
          return obj[prop];
        }
      });
      flush = function flush2(componentName, componentToken) {
        var _statistic$componentN;
        statistic[componentName] = {
          global: Array.from(tokenKeys2),
          component: _objectSpread2(_objectSpread2({}, (_statistic$componentN = statistic[componentName]) === null || _statistic$componentN === void 0 ? void 0 : _statistic$componentN.component), componentToken)
        };
      };
    }
    return {
      token: proxy2,
      keys: tokenKeys2,
      flush
    };
  };
  function getDefaultComponentToken(component, token2, getDefaultToken) {
    if (typeof getDefaultToken === "function") {
      var _token$component;
      return getDefaultToken(merge$1(token2, (_token$component = token2[component]) !== null && _token$component !== void 0 ? _token$component : {}));
    }
    return getDefaultToken !== null && getDefaultToken !== void 0 ? getDefaultToken : {};
  }
  function genMaxMin(type4) {
    return {
      max: function max() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return "max(".concat(args.map(function(value) {
          return unit$1(value);
        }).join(","), ")");
      },
      min: function min() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return "min(".concat(args.map(function(value) {
          return unit$1(value);
        }).join(","), ")");
      }
    };
  }
  var BEAT_LIMIT = 1e3 * 60 * 10;
  var ArrayKeyMap = (function() {
    function ArrayKeyMap2() {
      _classCallCheck(this, ArrayKeyMap2);
      _defineProperty$1(this, "map", new Map());
      _defineProperty$1(this, "objectIDMap", new WeakMap());
      _defineProperty$1(this, "nextID", 0);
      _defineProperty$1(this, "lastAccessBeat", new Map());
      _defineProperty$1(this, "accessBeat", 0);
    }
    _createClass(ArrayKeyMap2, [{
      key: "set",
      value: function set2(keys2, value) {
        this.clear();
        var compositeKey = this.getCompositeKey(keys2);
        this.map.set(compositeKey, value);
        this.lastAccessBeat.set(compositeKey, Date.now());
      }
    }, {
      key: "get",
      value: function get2(keys2) {
        var compositeKey = this.getCompositeKey(keys2);
        var cache2 = this.map.get(compositeKey);
        this.lastAccessBeat.set(compositeKey, Date.now());
        this.accessBeat += 1;
        return cache2;
      }
    }, {
      key: "getCompositeKey",
      value: function getCompositeKey(keys2) {
        var _this = this;
        var ids2 = keys2.map(function(key) {
          if (key && _typeof$2(key) === "object") {
            return "obj_".concat(_this.getObjectID(key));
          }
          return "".concat(_typeof$2(key), "_").concat(key);
        });
        return ids2.join("|");
      }
    }, {
      key: "getObjectID",
      value: function getObjectID(obj) {
        if (this.objectIDMap.has(obj)) {
          return this.objectIDMap.get(obj);
        }
        var id2 = this.nextID;
        this.objectIDMap.set(obj, id2);
        this.nextID += 1;
        return id2;
      }
    }, {
      key: "clear",
      value: function clear() {
        var _this2 = this;
        if (this.accessBeat > 1e4) {
          var now2 = Date.now();
          this.lastAccessBeat.forEach(function(beat, key) {
            if (now2 - beat > BEAT_LIMIT) {
              _this2.map.delete(key);
              _this2.lastAccessBeat.delete(key);
            }
          });
          this.accessBeat = 0;
        }
      }
    }]);
    return ArrayKeyMap2;
  })();
  var uniqueMap = new ArrayKeyMap();
  function useUniqueMemo(memoFn, deps) {
    return React.useMemo(function() {
      var cachedValue = uniqueMap.get(deps);
      if (cachedValue) {
        return cachedValue;
      }
      var newValue = memoFn();
      uniqueMap.set(deps, newValue);
      return newValue;
    }, deps);
  }
  var useDefaultCSP = function useDefaultCSP2() {
    return {};
  };
  function genStyleUtils(config) {
    var _config$useCSP = config.useCSP, useCSP = _config$useCSP === void 0 ? useDefaultCSP : _config$useCSP, useToken2 = config.useToken, usePrefix = config.usePrefix, getResetStyles = config.getResetStyles, getCommonStyle = config.getCommonStyle, getCompUnitless = config.getCompUnitless;
    function genStyleHooks2(component, styleFn, getDefaultToken, options) {
      var componentName = Array.isArray(component) ? component[0] : component;
      function prefixToken(key) {
        return "".concat(String(componentName)).concat(key.slice(0, 1).toUpperCase()).concat(key.slice(1));
      }
      var originUnitless = (options === null || options === void 0 ? void 0 : options.unitless) || {};
      var originCompUnitless = typeof getCompUnitless === "function" ? getCompUnitless(component) : {};
      var compUnitless = _objectSpread2(_objectSpread2({}, originCompUnitless), {}, _defineProperty$1({}, prefixToken("zIndexPopup"), true));
      Object.keys(originUnitless).forEach(function(key) {
        compUnitless[prefixToken(key)] = originUnitless[key];
      });
      var mergedOptions = _objectSpread2(_objectSpread2({}, options), {}, {
        unitless: compUnitless,
        prefixToken
      });
      var useStyle2 = genComponentStyleHook2(component, styleFn, getDefaultToken, mergedOptions);
      var useCSSVar = genCSSVarRegister(componentName, getDefaultToken, mergedOptions);
      return function(prefixCls) {
        var rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
        var hashId = useStyle2(prefixCls, rootCls);
        var extraPrefixCls = options === null || options === void 0 ? void 0 : options.extraCssVarPrefixCls;
        var resolvedExtraPrefixCls = typeof extraPrefixCls === "function" ? extraPrefixCls({
          prefixCls,
          rootCls
        }) : extraPrefixCls;
        var cssVarCls = useCSSVar(resolvedExtraPrefixCls !== null && resolvedExtraPrefixCls !== void 0 && resolvedExtraPrefixCls.length ? [rootCls].concat(_toConsumableArray(resolvedExtraPrefixCls)) : rootCls);
        return [hashId, cssVarCls];
      };
    }
    function genCSSVarRegister(component, getDefaultToken, options) {
      var compUnitless = options.unitless, prefixToken = options.prefixToken, ignore2 = options.ignore;
      return function(rootCls) {
        var _useToken = useToken2(), cssVar2 = _useToken.cssVar, realToken = _useToken.realToken;
        useCSSVarRegister({
          path: [component],
          prefix: cssVar2.prefix,
          key: cssVar2.key,
          unitless: compUnitless,
          ignore: ignore2,
          token: realToken,
          scope: rootCls
        }, function() {
          var defaultToken = getDefaultComponentToken(component, realToken, getDefaultToken);
          var componentToken = getComponentToken(component, realToken, defaultToken, {
            deprecatedTokens: options === null || options === void 0 ? void 0 : options.deprecatedTokens
          });
          if (defaultToken) {
            Object.keys(defaultToken).forEach(function(key) {
              componentToken[prefixToken(key)] = componentToken[key];
              delete componentToken[key];
            });
          }
          return componentToken;
        });
        return cssVar2 === null || cssVar2 === void 0 ? void 0 : cssVar2.key;
      };
    }
    function genComponentStyleHook2(componentName, styleFn, getDefaultToken) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var cells = Array.isArray(componentName) ? componentName : [componentName, componentName];
      var _cells = _slicedToArray(cells, 1), component = _cells[0];
      var concatComponent = cells.join("-");
      var mergedLayer = config.layer || {
        name: "antd"
      };
      return function(prefixCls) {
        var rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
        var _useToken2 = useToken2(), theme2 = _useToken2.theme, realToken = _useToken2.realToken, hashId = _useToken2.hashId, token2 = _useToken2.token, cssVar2 = _useToken2.cssVar, zeroRuntime = _useToken2.zeroRuntime;
        var memoizedZeroRuntime = reactExports.useMemo(function() {
          return zeroRuntime;
        }, []);
        if (memoizedZeroRuntime) {
          return hashId;
        }
        var _usePrefix = usePrefix(), rootPrefixCls = _usePrefix.rootPrefixCls, iconPrefixCls = _usePrefix.iconPrefixCls;
        var csp = useCSP();
        var type4 = "css";
        var calc = useUniqueMemo(function() {
          var unitlessCssVar = new Set();
          Object.keys(options.unitless || {}).forEach(function(key) {
            unitlessCssVar.add(token2CSSVar(key, cssVar2.prefix));
            unitlessCssVar.add(token2CSSVar(key, getCompVarPrefix(component, cssVar2.prefix)));
          });
          return genCalc(type4, unitlessCssVar);
        }, [type4, component, cssVar2 === null || cssVar2 === void 0 ? void 0 : cssVar2.prefix]);
        var _genMaxMin = genMaxMin(), max = _genMaxMin.max, min = _genMaxMin.min;
        var sharedConfig = {
          theme: theme2,
          token: token2,
          hashId,
          nonce: function nonce() {
            return csp.nonce;
          },
          clientOnly: options.clientOnly,
          layer: mergedLayer,
order: options.order || -999
        };
        if (typeof getResetStyles === "function") {
          useStyleRegister(_objectSpread2(_objectSpread2({}, sharedConfig), {}, {
            clientOnly: false,
            path: ["Shared", rootPrefixCls]
          }), function() {
            return getResetStyles(token2, {
              prefix: {
                rootPrefixCls,
                iconPrefixCls
              },
              csp
            });
          });
        }
        useStyleRegister(_objectSpread2(_objectSpread2({}, sharedConfig), {}, {
          path: [concatComponent, prefixCls, iconPrefixCls]
        }), function() {
          if (options.injectStyle === false) {
            return [];
          }
          var _statisticToken = statisticToken(token2), proxyToken = _statisticToken.token, flush = _statisticToken.flush;
          var defaultComponentToken = getDefaultComponentToken(component, realToken, getDefaultToken);
          var componentCls = ".".concat(prefixCls);
          var componentToken = getComponentToken(component, realToken, defaultComponentToken, {
            deprecatedTokens: options.deprecatedTokens
          });
          if (defaultComponentToken && _typeof$2(defaultComponentToken) === "object") {
            Object.keys(defaultComponentToken).forEach(function(key) {
              defaultComponentToken[key] = "var(".concat(token2CSSVar(key, getCompVarPrefix(component, cssVar2.prefix)), ")");
            });
          }
          var mergedToken = merge$1(proxyToken, {
            componentCls,
            prefixCls,
            iconCls: ".".concat(iconPrefixCls),
            antCls: ".".concat(rootPrefixCls),
            calc,
            max,
            min
          }, defaultComponentToken);
          var styleInterpolation = styleFn(mergedToken, {
            hashId,
            prefixCls,
            rootPrefixCls,
            iconPrefixCls
          });
          flush(component, componentToken);
          var commonStyle = typeof getCommonStyle === "function" ? getCommonStyle(mergedToken, prefixCls, rootCls, options.resetFont) : null;
          return [options.resetStyle === false ? null : commonStyle, styleInterpolation];
        });
        return hashId;
      };
    }
    function genSubStyleComponent2(componentName, styleFn, getDefaultToken) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var useStyle2 = genComponentStyleHook2(componentName, styleFn, getDefaultToken, _objectSpread2({
        resetStyle: false,
order: -998
      }, options));
      var StyledComponent = function StyledComponent2(_ref4) {
        var prefixCls = _ref4.prefixCls, _ref$rootCls = _ref4.rootCls, rootCls = _ref$rootCls === void 0 ? prefixCls : _ref$rootCls;
        useStyle2(prefixCls, rootCls);
        return null;
      };
      return StyledComponent;
    }
    return {
      genStyleHooks: genStyleHooks2,
      genSubStyleComponent: genSubStyleComponent2,
      genComponentStyleHook: genComponentStyleHook2
    };
  }
  const PresetColors = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];
  function getLineHeight(fontSize) {
    return (fontSize + 8) / fontSize;
  }
  function getFontSizes(base) {
    const fontSizes = Array.from({
      length: 10
    }).map((_2, index) => {
      const i2 = index - 1;
      const baseSize = base * Math.E ** (i2 / 5);
      const intSize = index > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
      return Math.floor(intSize / 2) * 2;
    });
    fontSizes[1] = base;
    return fontSizes.map((size) => ({
      size,
      lineHeight: getLineHeight(size)
    }));
  }
  const version = "6.3.1";
  const defaultPresetColors = {
    blue: "#1677FF",
    purple: "#722ED1",
    cyan: "#13C2C2",
    green: "#52C41A",
    magenta: "#EB2F96",
pink: "#EB2F96",
    red: "#F5222D",
    orange: "#FA8C16",
    yellow: "#FADB14",
    volcano: "#FA541C",
    geekblue: "#2F54EB",
    gold: "#FAAD14",
    lime: "#A0D911"
  };
  const seedToken = {
...defaultPresetColors,
colorPrimary: "#1677ff",
    colorSuccess: "#52c41a",
    colorWarning: "#faad14",
    colorError: "#ff4d4f",
    colorInfo: "#1677ff",
    colorLink: "",
    colorTextBase: "",
    colorBgBase: "",
fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
    fontFamilyCode: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
    fontSize: 14,
lineWidth: 1,
    lineType: "solid",
motionUnit: 0.1,
    motionBase: 0,
    motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
    motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
    motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
    motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
    motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
    motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
    motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
    motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
borderRadius: 6,
sizeUnit: 4,
    sizeStep: 4,
    sizePopupArrow: 16,
controlHeight: 32,
zIndexBase: 0,
    zIndexPopupBase: 1e3,
opacityImage: 1,
wireframe: false,
motion: true
  };
  const presetColors = {
    aliceblue: "9ehhb",
    antiquewhite: "9sgk7",
    aqua: "1ekf",
    aquamarine: "4zsno",
    azure: "9eiv3",
    beige: "9lhp8",
    bisque: "9zg04",
    black: "0",
    blanchedalmond: "9zhe5",
    blue: "73",
    blueviolet: "5e31e",
    brown: "6g016",
    burlywood: "8ouiv",
    cadetblue: "3qba8",
    chartreuse: "4zshs",
    chocolate: "87k0u",
    coral: "9yvyo",
    cornflowerblue: "3xael",
    cornsilk: "9zjz0",
    crimson: "8l4xo",
    cyan: "1ekf",
    darkblue: "3v",
    darkcyan: "rkb",
    darkgoldenrod: "776yz",
    darkgray: "6mbhl",
    darkgreen: "jr4",
    darkgrey: "6mbhl",
    darkkhaki: "7ehkb",
    darkmagenta: "5f91n",
    darkolivegreen: "3bzfz",
    darkorange: "9yygw",
    darkorchid: "5z6x8",
    darkred: "5f8xs",
    darksalmon: "9441m",
    darkseagreen: "5lwgf",
    darkslateblue: "2th1n",
    darkslategray: "1ugcv",
    darkslategrey: "1ugcv",
    darkturquoise: "14up",
    darkviolet: "5rw7n",
    deeppink: "9yavn",
    deepskyblue: "11xb",
    dimgray: "442g9",
    dimgrey: "442g9",
    dodgerblue: "16xof",
    firebrick: "6y7tu",
    floralwhite: "9zkds",
    forestgreen: "1cisi",
    fuchsia: "9y70f",
    gainsboro: "8m8kc",
    ghostwhite: "9pq0v",
    goldenrod: "8j4f4",
    gold: "9zda8",
    gray: "50i2o",
    green: "pa8",
    greenyellow: "6senj",
    grey: "50i2o",
    honeydew: "9eiuo",
    hotpink: "9yrp0",
    indianred: "80gnw",
    indigo: "2xcoy",
    ivory: "9zldc",
    khaki: "9edu4",
    lavenderblush: "9ziet",
    lavender: "90c8q",
    lawngreen: "4vk74",
    lemonchiffon: "9zkct",
    lightblue: "6s73a",
    lightcoral: "9dtog",
    lightcyan: "8s1rz",
    lightgoldenrodyellow: "9sjiq",
    lightgray: "89jo3",
    lightgreen: "5nkwg",
    lightgrey: "89jo3",
    lightpink: "9z6wx",
    lightsalmon: "9z2ii",
    lightseagreen: "19xgq",
    lightskyblue: "5arju",
    lightslategray: "4nwk9",
    lightslategrey: "4nwk9",
    lightsteelblue: "6wau6",
    lightyellow: "9zlcw",
    lime: "1edc",
    limegreen: "1zcxe",
    linen: "9shk6",
    magenta: "9y70f",
    maroon: "4zsow",
    mediumaquamarine: "40eju",
    mediumblue: "5p",
    mediumorchid: "79qkz",
    mediumpurple: "5r3rv",
    mediumseagreen: "2d9ip",
    mediumslateblue: "4tcku",
    mediumspringgreen: "1di2",
    mediumturquoise: "2uabw",
    mediumvioletred: "7rn9h",
    midnightblue: "z980",
    mintcream: "9ljp6",
    mistyrose: "9zg0x",
    moccasin: "9zfzp",
    navajowhite: "9zest",
    navy: "3k",
    oldlace: "9wq92",
    olive: "50hz4",
    olivedrab: "472ub",
    orange: "9z3eo",
    orangered: "9ykg0",
    orchid: "8iu3a",
    palegoldenrod: "9bl4a",
    palegreen: "5yw0o",
    paleturquoise: "6v4ku",
    palevioletred: "8k8lv",
    papayawhip: "9zi6t",
    peachpuff: "9ze0p",
    peru: "80oqn",
    pink: "9z8wb",
    plum: "8nba5",
    powderblue: "6wgdi",
    purple: "4zssg",
    rebeccapurple: "3zk49",
    red: "9y6tc",
    rosybrown: "7cv4f",
    royalblue: "2jvtt",
    saddlebrown: "5fmkz",
    salmon: "9rvci",
    sandybrown: "9jn1c",
    seagreen: "1tdnb",
    seashell: "9zje6",
    sienna: "6973h",
    silver: "7ir40",
    skyblue: "5arjf",
    slateblue: "45e4t",
    slategray: "4e100",
    slategrey: "4e100",
    snow: "9zke2",
    springgreen: "1egv",
    steelblue: "2r1kk",
    tan: "87yx8",
    teal: "pds",
    thistle: "8ggk8",
    tomato: "9yqfb",
    turquoise: "2j4r4",
    violet: "9b10u",
    wheat: "9ld4j",
    white: "9zldr",
    whitesmoke: "9lhpx",
    yellow: "9zl6o",
    yellowgreen: "61fzm"
  };
  const round = Math.round;
  function splitColorStr(str, parseNum) {
    const match2 = str.replace(/^[^(]*\((.*)/, "$1").replace(/\).*/, "").match(/\d*\.?\d+%?/g) || [];
    const numList = match2.map((item) => parseFloat(item));
    for (let i2 = 0; i2 < 3; i2 += 1) {
      numList[i2] = parseNum(numList[i2] || 0, match2[i2] || "", i2);
    }
    if (match2[3]) {
      numList[3] = match2[3].includes("%") ? numList[3] / 100 : numList[3];
    } else {
      numList[3] = 1;
    }
    return numList;
  }
  const parseHSVorHSL = (num, _2, index) => index === 0 ? num : num / 100;
  function limitRange(value, max) {
    const mergedMax = max || 255;
    if (value > mergedMax) {
      return mergedMax;
    }
    if (value < 0) {
      return 0;
    }
    return value;
  }
  class FastColor {
isValid = true;
r = 0;
g = 0;
b = 0;
a = 1;
_h;
    _hsl_s;
    _hsv_s;
    _l;
    _v;
_max;
    _min;
    _brightness;
    constructor(input) {
      function matchFormat(str) {
        return str[0] in input && str[1] in input && str[2] in input;
      }
      if (!input) ;
      else if (typeof input === "string") {
        let matchPrefix = function(prefix2) {
          return trimStr.startsWith(prefix2);
        };
        const trimStr = input.trim();
        if (/^#?[A-F\d]{3,8}$/i.test(trimStr)) {
          this.fromHexString(trimStr);
        } else if (matchPrefix("rgb")) {
          this.fromRgbString(trimStr);
        } else if (matchPrefix("hsl")) {
          this.fromHslString(trimStr);
        } else if (matchPrefix("hsv") || matchPrefix("hsb")) {
          this.fromHsvString(trimStr);
        } else {
          const presetColor = presetColors[trimStr.toLowerCase()];
          if (presetColor) {
            this.fromHexString(
parseInt(presetColor, 36).toString(16).padStart(6, "0")
            );
          }
        }
      } else if (input instanceof FastColor) {
        this.r = input.r;
        this.g = input.g;
        this.b = input.b;
        this.a = input.a;
        this._h = input._h;
        this._hsl_s = input._hsl_s;
        this._hsv_s = input._hsv_s;
        this._l = input._l;
        this._v = input._v;
      } else if (matchFormat("rgb")) {
        this.r = limitRange(input.r);
        this.g = limitRange(input.g);
        this.b = limitRange(input.b);
        this.a = typeof input.a === "number" ? limitRange(input.a, 1) : 1;
      } else if (matchFormat("hsl")) {
        this.fromHsl(input);
      } else if (matchFormat("hsv")) {
        this.fromHsv(input);
      } else {
        throw new Error("@ant-design/fast-color: unsupported input " + JSON.stringify(input));
      }
    }
setR(value) {
      return this._sc("r", value);
    }
    setG(value) {
      return this._sc("g", value);
    }
    setB(value) {
      return this._sc("b", value);
    }
    setA(value) {
      return this._sc("a", value, 1);
    }
    setHue(value) {
      const hsv = this.toHsv();
      hsv.h = value;
      return this._c(hsv);
    }

getLuminance() {
      function adjustGamma(raw) {
        const val = raw / 255;
        return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
      }
      const R = adjustGamma(this.r);
      const G = adjustGamma(this.g);
      const B = adjustGamma(this.b);
      return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    }
    getHue() {
      if (typeof this._h === "undefined") {
        const delta = this.getMax() - this.getMin();
        if (delta === 0) {
          this._h = 0;
        } else {
          this._h = round(60 * (this.r === this.getMax() ? (this.g - this.b) / delta + (this.g < this.b ? 6 : 0) : this.g === this.getMax() ? (this.b - this.r) / delta + 2 : (this.r - this.g) / delta + 4));
        }
      }
      return this._h;
    }
getSaturation() {
      return this.getHSVSaturation();
    }
    getHSVSaturation() {
      if (typeof this._hsv_s === "undefined") {
        const delta = this.getMax() - this.getMin();
        if (delta === 0) {
          this._hsv_s = 0;
        } else {
          this._hsv_s = delta / this.getMax();
        }
      }
      return this._hsv_s;
    }
    getHSLSaturation() {
      if (typeof this._hsl_s === "undefined") {
        const delta = this.getMax() - this.getMin();
        if (delta === 0) {
          this._hsl_s = 0;
        } else {
          const l2 = this.getLightness();
          this._hsl_s = delta / 255 / (1 - Math.abs(2 * l2 - 1));
        }
      }
      return this._hsl_s;
    }
    getLightness() {
      if (typeof this._l === "undefined") {
        this._l = (this.getMax() + this.getMin()) / 510;
      }
      return this._l;
    }
    getValue() {
      if (typeof this._v === "undefined") {
        this._v = this.getMax() / 255;
      }
      return this._v;
    }
getBrightness() {
      if (typeof this._brightness === "undefined") {
        this._brightness = (this.r * 299 + this.g * 587 + this.b * 114) / 1e3;
      }
      return this._brightness;
    }
darken(amount = 10) {
      const h2 = this.getHue();
      const s2 = this.getSaturation();
      let l2 = this.getLightness() - amount / 100;
      if (l2 < 0) {
        l2 = 0;
      }
      return this._c({
        h: h2,
        s: s2,
        l: l2,
        a: this.a
      });
    }
    lighten(amount = 10) {
      const h2 = this.getHue();
      const s2 = this.getSaturation();
      let l2 = this.getLightness() + amount / 100;
      if (l2 > 1) {
        l2 = 1;
      }
      return this._c({
        h: h2,
        s: s2,
        l: l2,
        a: this.a
      });
    }
mix(input, amount = 50) {
      const color2 = this._c(input);
      const p2 = amount / 100;
      const calc = (key) => (color2[key] - this[key]) * p2 + this[key];
      const rgba2 = {
        r: round(calc("r")),
        g: round(calc("g")),
        b: round(calc("b")),
        a: round(calc("a") * 100) / 100
      };
      return this._c(rgba2);
    }
tint(amount = 10) {
      return this.mix({
        r: 255,
        g: 255,
        b: 255,
        a: 1
      }, amount);
    }
shade(amount = 10) {
      return this.mix({
        r: 0,
        g: 0,
        b: 0,
        a: 1
      }, amount);
    }
    onBackground(background) {
      const bg = this._c(background);
      const alpha2 = this.a + bg.a * (1 - this.a);
      const calc = (key) => {
        return round((this[key] * this.a + bg[key] * bg.a * (1 - this.a)) / alpha2);
      };
      return this._c({
        r: calc("r"),
        g: calc("g"),
        b: calc("b"),
        a: alpha2
      });
    }
isDark() {
      return this.getBrightness() < 128;
    }
    isLight() {
      return this.getBrightness() >= 128;
    }
equals(other) {
      return this.r === other.r && this.g === other.g && this.b === other.b && this.a === other.a;
    }
    clone() {
      return this._c(this);
    }
toHexString() {
      let hex3 = "#";
      const rHex = (this.r || 0).toString(16);
      hex3 += rHex.length === 2 ? rHex : "0" + rHex;
      const gHex = (this.g || 0).toString(16);
      hex3 += gHex.length === 2 ? gHex : "0" + gHex;
      const bHex = (this.b || 0).toString(16);
      hex3 += bHex.length === 2 ? bHex : "0" + bHex;
      if (typeof this.a === "number" && this.a >= 0 && this.a < 1) {
        const aHex = round(this.a * 255).toString(16);
        hex3 += aHex.length === 2 ? aHex : "0" + aHex;
      }
      return hex3;
    }
toHsl() {
      return {
        h: this.getHue(),
        s: this.getHSLSaturation(),
        l: this.getLightness(),
        a: this.a
      };
    }
toHslString() {
      const h2 = this.getHue();
      const s2 = round(this.getHSLSaturation() * 100);
      const l2 = round(this.getLightness() * 100);
      return this.a !== 1 ? `hsla(${h2},${s2}%,${l2}%,${this.a})` : `hsl(${h2},${s2}%,${l2}%)`;
    }
toHsv() {
      return {
        h: this.getHue(),
        s: this.getHSVSaturation(),
        v: this.getValue(),
        a: this.a
      };
    }
    toRgb() {
      return {
        r: this.r,
        g: this.g,
        b: this.b,
        a: this.a
      };
    }
    toRgbString() {
      return this.a !== 1 ? `rgba(${this.r},${this.g},${this.b},${this.a})` : `rgb(${this.r},${this.g},${this.b})`;
    }
    toString() {
      return this.toRgbString();
    }

_sc(rgb, value, max) {
      const clone2 = this.clone();
      clone2[rgb] = limitRange(value, max);
      return clone2;
    }
    _c(input) {
      return new this.constructor(input);
    }
    getMax() {
      if (typeof this._max === "undefined") {
        this._max = Math.max(this.r, this.g, this.b);
      }
      return this._max;
    }
    getMin() {
      if (typeof this._min === "undefined") {
        this._min = Math.min(this.r, this.g, this.b);
      }
      return this._min;
    }
    fromHexString(trimStr) {
      const withoutPrefix = trimStr.replace("#", "");
      function connectNum(index1, index2) {
        return parseInt(withoutPrefix[index1] + withoutPrefix[index2 || index1], 16);
      }
      if (withoutPrefix.length < 6) {
        this.r = connectNum(0);
        this.g = connectNum(1);
        this.b = connectNum(2);
        this.a = withoutPrefix[3] ? connectNum(3) / 255 : 1;
      } else {
        this.r = connectNum(0, 1);
        this.g = connectNum(2, 3);
        this.b = connectNum(4, 5);
        this.a = withoutPrefix[6] ? connectNum(6, 7) / 255 : 1;
      }
    }
    fromHsl({
      h: _h,
      s: s2,
      l: l2,
      a: a2
    }) {
      const h2 = (_h % 360 + 360) % 360;
      this._h = h2;
      this._hsl_s = s2;
      this._l = l2;
      this.a = typeof a2 === "number" ? a2 : 1;
      if (s2 <= 0) {
        const rgb = round(l2 * 255);
        this.r = rgb;
        this.g = rgb;
        this.b = rgb;
        return;
      }
      let r2 = 0, g2 = 0, b = 0;
      const huePrime = h2 / 60;
      const chroma = (1 - Math.abs(2 * l2 - 1)) * s2;
      const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
      if (huePrime >= 0 && huePrime < 1) {
        r2 = chroma;
        g2 = secondComponent;
      } else if (huePrime >= 1 && huePrime < 2) {
        r2 = secondComponent;
        g2 = chroma;
      } else if (huePrime >= 2 && huePrime < 3) {
        g2 = chroma;
        b = secondComponent;
      } else if (huePrime >= 3 && huePrime < 4) {
        g2 = secondComponent;
        b = chroma;
      } else if (huePrime >= 4 && huePrime < 5) {
        r2 = secondComponent;
        b = chroma;
      } else if (huePrime >= 5 && huePrime < 6) {
        r2 = chroma;
        b = secondComponent;
      }
      const lightnessModification = l2 - chroma / 2;
      this.r = round((r2 + lightnessModification) * 255);
      this.g = round((g2 + lightnessModification) * 255);
      this.b = round((b + lightnessModification) * 255);
    }
    fromHsv({
      h: _h,
      s: s2,
      v,
      a: a2
    }) {
      const h2 = (_h % 360 + 360) % 360;
      this._h = h2;
      this._hsv_s = s2;
      this._v = v;
      this.a = typeof a2 === "number" ? a2 : 1;
      const vv = round(v * 255);
      this.r = vv;
      this.g = vv;
      this.b = vv;
      if (s2 <= 0) {
        return;
      }
      const hh = h2 / 60;
      const i2 = Math.floor(hh);
      const ff = hh - i2;
      const p2 = round(v * (1 - s2) * 255);
      const q = round(v * (1 - s2 * ff) * 255);
      const t2 = round(v * (1 - s2 * (1 - ff)) * 255);
      switch (i2) {
        case 0:
          this.g = t2;
          this.b = p2;
          break;
        case 1:
          this.r = q;
          this.b = p2;
          break;
        case 2:
          this.r = p2;
          this.b = t2;
          break;
        case 3:
          this.r = p2;
          this.g = q;
          break;
        case 4:
          this.r = t2;
          this.g = p2;
          break;
        case 5:
        default:
          this.g = p2;
          this.b = q;
          break;
      }
    }
    fromHsvString(trimStr) {
      const cells = splitColorStr(trimStr, parseHSVorHSL);
      this.fromHsv({
        h: cells[0],
        s: cells[1],
        v: cells[2],
        a: cells[3]
      });
    }
    fromHslString(trimStr) {
      const cells = splitColorStr(trimStr, parseHSVorHSL);
      this.fromHsl({
        h: cells[0],
        s: cells[1],
        l: cells[2],
        a: cells[3]
      });
    }
    fromRgbString(trimStr) {
      const cells = splitColorStr(trimStr, (num, txt) => (
txt.includes("%") ? round(num / 100 * 255) : num
      ));
      this.r = cells[0];
      this.g = cells[1];
      this.b = cells[2];
      this.a = cells[3];
    }
  }
  const hueStep = 2;
  const saturationStep = 0.16;
  const saturationStep2 = 0.05;
  const brightnessStep1 = 0.05;
  const brightnessStep2 = 0.15;
  const lightColorCount = 5;
  const darkColorCount = 4;
  const darkColorMap = [{
    index: 7,
    amount: 15
  }, {
    index: 6,
    amount: 25
  }, {
    index: 5,
    amount: 30
  }, {
    index: 5,
    amount: 45
  }, {
    index: 5,
    amount: 65
  }, {
    index: 5,
    amount: 85
  }, {
    index: 4,
    amount: 90
  }, {
    index: 3,
    amount: 95
  }, {
    index: 2,
    amount: 97
  }, {
    index: 1,
    amount: 98
  }];
  function getHue(hsv, i2, light) {
    let hue;
    if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
      hue = light ? Math.round(hsv.h) - hueStep * i2 : Math.round(hsv.h) + hueStep * i2;
    } else {
      hue = light ? Math.round(hsv.h) + hueStep * i2 : Math.round(hsv.h) - hueStep * i2;
    }
    if (hue < 0) {
      hue += 360;
    } else if (hue >= 360) {
      hue -= 360;
    }
    return hue;
  }
  function getSaturation(hsv, i2, light) {
    if (hsv.h === 0 && hsv.s === 0) {
      return hsv.s;
    }
    let saturation;
    if (light) {
      saturation = hsv.s - saturationStep * i2;
    } else if (i2 === darkColorCount) {
      saturation = hsv.s + saturationStep;
    } else {
      saturation = hsv.s + saturationStep2 * i2;
    }
    if (saturation > 1) {
      saturation = 1;
    }
    if (light && i2 === lightColorCount && saturation > 0.1) {
      saturation = 0.1;
    }
    if (saturation < 0.06) {
      saturation = 0.06;
    }
    return Math.round(saturation * 100) / 100;
  }
  function getValue$1(hsv, i2, light) {
    let value;
    if (light) {
      value = hsv.v + brightnessStep1 * i2;
    } else {
      value = hsv.v - brightnessStep2 * i2;
    }
    value = Math.max(0, Math.min(1, value));
    return Math.round(value * 100) / 100;
  }
  function generate$1(color2, opts = {}) {
    const patterns = [];
    const pColor = new FastColor(color2);
    const hsv = pColor.toHsv();
    for (let i2 = lightColorCount; i2 > 0; i2 -= 1) {
      const c2 = new FastColor({
        h: getHue(hsv, i2, true),
        s: getSaturation(hsv, i2, true),
        v: getValue$1(hsv, i2, true)
      });
      patterns.push(c2);
    }
    patterns.push(pColor);
    for (let i2 = 1; i2 <= darkColorCount; i2 += 1) {
      const c2 = new FastColor({
        h: getHue(hsv, i2),
        s: getSaturation(hsv, i2),
        v: getValue$1(hsv, i2)
      });
      patterns.push(c2);
    }
    if (opts.theme === "dark") {
      return darkColorMap.map(({
        index,
        amount
      }) => new FastColor(opts.backgroundColor || "#141414").mix(patterns[index], amount).toHexString());
    }
    return patterns.map((c2) => c2.toHexString());
  }
  const presetPrimaryColors = {
    "red": "#F5222D",
    "volcano": "#FA541C",
    "orange": "#FA8C16",
    "gold": "#FAAD14",
    "yellow": "#FADB14",
    "lime": "#A0D911",
    "green": "#52C41A",
    "cyan": "#13C2C2",
    "blue": "#1677FF",
    "geekblue": "#2F54EB",
    "purple": "#722ED1",
    "magenta": "#EB2F96",
    "grey": "#666666"
  };
  const red = ["#fff1f0", "#ffccc7", "#ffa39e", "#ff7875", "#ff4d4f", "#f5222d", "#cf1322", "#a8071a", "#820014", "#5c0011"];
  red.primary = red[5];
  const volcano = ["#fff2e8", "#ffd8bf", "#ffbb96", "#ff9c6e", "#ff7a45", "#fa541c", "#d4380d", "#ad2102", "#871400", "#610b00"];
  volcano.primary = volcano[5];
  const orange = ["#fff7e6", "#ffe7ba", "#ffd591", "#ffc069", "#ffa940", "#fa8c16", "#d46b08", "#ad4e00", "#873800", "#612500"];
  orange.primary = orange[5];
  const gold = ["#fffbe6", "#fff1b8", "#ffe58f", "#ffd666", "#ffc53d", "#faad14", "#d48806", "#ad6800", "#874d00", "#613400"];
  gold.primary = gold[5];
  const yellow = ["#feffe6", "#ffffb8", "#fffb8f", "#fff566", "#ffec3d", "#fadb14", "#d4b106", "#ad8b00", "#876800", "#614700"];
  yellow.primary = yellow[5];
  const lime = ["#fcffe6", "#f4ffb8", "#eaff8f", "#d3f261", "#bae637", "#a0d911", "#7cb305", "#5b8c00", "#3f6600", "#254000"];
  lime.primary = lime[5];
  const green = ["#f6ffed", "#d9f7be", "#b7eb8f", "#95de64", "#73d13d", "#52c41a", "#389e0d", "#237804", "#135200", "#092b00"];
  green.primary = green[5];
  const cyan = ["#e6fffb", "#b5f5ec", "#87e8de", "#5cdbd3", "#36cfc9", "#13c2c2", "#08979c", "#006d75", "#00474f", "#002329"];
  cyan.primary = cyan[5];
  const blue = ["#e6f4ff", "#bae0ff", "#91caff", "#69b1ff", "#4096ff", "#1677ff", "#0958d9", "#003eb3", "#002c8c", "#001d66"];
  blue.primary = blue[5];
  const geekblue = ["#f0f5ff", "#d6e4ff", "#adc6ff", "#85a5ff", "#597ef7", "#2f54eb", "#1d39c4", "#10239e", "#061178", "#030852"];
  geekblue.primary = geekblue[5];
  const purple = ["#f9f0ff", "#efdbff", "#d3adf7", "#b37feb", "#9254de", "#722ed1", "#531dab", "#391085", "#22075e", "#120338"];
  purple.primary = purple[5];
  const magenta = ["#fff0f6", "#ffd6e7", "#ffadd2", "#ff85c0", "#f759ab", "#eb2f96", "#c41d7f", "#9e1068", "#780650", "#520339"];
  magenta.primary = magenta[5];
  const grey = ["#a6a6a6", "#999999", "#8c8c8c", "#808080", "#737373", "#666666", "#404040", "#1a1a1a", "#000000", "#000000"];
  grey.primary = grey[5];
  const presetPalettes = {
    red,
    volcano,
    orange,
    gold,
    yellow,
    lime,
    green,
    cyan,
    blue,
    geekblue,
    purple,
    magenta,
    grey
  };
  function genColorMapToken(seed, {
    generateColorPalettes: generateColorPalettes2,
    generateNeutralColorPalettes: generateNeutralColorPalettes2
  }) {
    const {
      colorSuccess: colorSuccessBase,
      colorWarning: colorWarningBase,
      colorError: colorErrorBase,
      colorInfo: colorInfoBase,
      colorPrimary: colorPrimaryBase,
      colorBgBase,
      colorTextBase
    } = seed;
    const primaryColors = generateColorPalettes2(colorPrimaryBase);
    const successColors = generateColorPalettes2(colorSuccessBase);
    const warningColors = generateColorPalettes2(colorWarningBase);
    const errorColors = generateColorPalettes2(colorErrorBase);
    const infoColors = generateColorPalettes2(colorInfoBase);
    const neutralColors = generateNeutralColorPalettes2(colorBgBase, colorTextBase);
    const colorLink = seed.colorLink || seed.colorInfo;
    const linkColors = generateColorPalettes2(colorLink);
    const colorErrorBgFilledHover = new FastColor(errorColors[1]).mix(new FastColor(errorColors[3]), 50).toHexString();
    const presetColorTokens = {};
    PresetColors.forEach((colorKey) => {
      const colorBase = seed[colorKey];
      if (colorBase) {
        const colorPalette = generateColorPalettes2(colorBase);
        presetColorTokens[`${colorKey}Hover`] = colorPalette[5];
        presetColorTokens[`${colorKey}Active`] = colorPalette[7];
      }
    });
    return {
      ...neutralColors,
      colorPrimaryBg: primaryColors[1],
      colorPrimaryBgHover: primaryColors[2],
      colorPrimaryBorder: primaryColors[3],
      colorPrimaryBorderHover: primaryColors[4],
      colorPrimaryHover: primaryColors[5],
      colorPrimary: primaryColors[6],
      colorPrimaryActive: primaryColors[7],
      colorPrimaryTextHover: primaryColors[8],
      colorPrimaryText: primaryColors[9],
      colorPrimaryTextActive: primaryColors[10],
      colorSuccessBg: successColors[1],
      colorSuccessBgHover: successColors[2],
      colorSuccessBorder: successColors[3],
      colorSuccessBorderHover: successColors[4],
      colorSuccessHover: successColors[4],
      colorSuccess: successColors[6],
      colorSuccessActive: successColors[7],
      colorSuccessTextHover: successColors[8],
      colorSuccessText: successColors[9],
      colorSuccessTextActive: successColors[10],
      colorErrorBg: errorColors[1],
      colorErrorBgHover: errorColors[2],
      colorErrorBgFilledHover,
      colorErrorBgActive: errorColors[3],
      colorErrorBorder: errorColors[3],
      colorErrorBorderHover: errorColors[4],
      colorErrorHover: errorColors[5],
      colorError: errorColors[6],
      colorErrorActive: errorColors[7],
      colorErrorTextHover: errorColors[8],
      colorErrorText: errorColors[9],
      colorErrorTextActive: errorColors[10],
      colorWarningBg: warningColors[1],
      colorWarningBgHover: warningColors[2],
      colorWarningBorder: warningColors[3],
      colorWarningBorderHover: warningColors[4],
      colorWarningHover: warningColors[4],
      colorWarning: warningColors[6],
      colorWarningActive: warningColors[7],
      colorWarningTextHover: warningColors[8],
      colorWarningText: warningColors[9],
      colorWarningTextActive: warningColors[10],
      colorInfoBg: infoColors[1],
      colorInfoBgHover: infoColors[2],
      colorInfoBorder: infoColors[3],
      colorInfoBorderHover: infoColors[4],
      colorInfoHover: infoColors[4],
      colorInfo: infoColors[6],
      colorInfoActive: infoColors[7],
      colorInfoTextHover: infoColors[8],
      colorInfoText: infoColors[9],
      colorInfoTextActive: infoColors[10],
      colorLinkHover: linkColors[4],
      colorLink: linkColors[6],
      colorLinkActive: linkColors[7],
      ...presetColorTokens,
      colorBgMask: new FastColor("#000").setA(0.45).toRgbString(),
      colorWhite: "#fff"
    };
  }
  const genRadius = (radiusBase) => {
    let radiusLG = radiusBase;
    let radiusSM = radiusBase;
    let radiusXS = radiusBase;
    let radiusOuter = radiusBase;
    if (radiusBase < 6 && radiusBase >= 5) {
      radiusLG = radiusBase + 1;
    } else if (radiusBase < 16 && radiusBase >= 6) {
      radiusLG = radiusBase + 2;
    } else if (radiusBase >= 16) {
      radiusLG = 16;
    }
    if (radiusBase < 7 && radiusBase >= 5) {
      radiusSM = 4;
    } else if (radiusBase < 8 && radiusBase >= 7) {
      radiusSM = 5;
    } else if (radiusBase < 14 && radiusBase >= 8) {
      radiusSM = 6;
    } else if (radiusBase < 16 && radiusBase >= 14) {
      radiusSM = 7;
    } else if (radiusBase >= 16) {
      radiusSM = 8;
    }
    if (radiusBase < 6 && radiusBase >= 2) {
      radiusXS = 1;
    } else if (radiusBase >= 6) {
      radiusXS = 2;
    }
    if (radiusBase > 4 && radiusBase < 8) {
      radiusOuter = 4;
    } else if (radiusBase >= 8) {
      radiusOuter = 6;
    }
    return {
      borderRadius: radiusBase,
      borderRadiusXS: radiusXS,
      borderRadiusSM: radiusSM,
      borderRadiusLG: radiusLG,
      borderRadiusOuter: radiusOuter
    };
  };
  function genCommonMapToken(token2) {
    const {
      motionUnit,
      motionBase,
      borderRadius,
      lineWidth
    } = token2;
    return {
motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
      motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
      motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
lineWidthBold: lineWidth + 1,
...genRadius(borderRadius)
    };
  }
  const genControlHeight = (token2) => {
    const {
      controlHeight
    } = token2;
    return {
      controlHeightSM: controlHeight * 0.75,
      controlHeightXS: controlHeight * 0.5,
      controlHeightLG: controlHeight * 1.25
    };
  };
  const genFontMapToken = (fontSize) => {
    const fontSizePairs = getFontSizes(fontSize);
    const fontSizes = fontSizePairs.map((pair) => pair.size);
    const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
    const fontSizeMD = fontSizes[1];
    const fontSizeSM = fontSizes[0];
    const fontSizeLG = fontSizes[2];
    const lineHeight = lineHeights[1];
    const lineHeightSM = lineHeights[0];
    const lineHeightLG = lineHeights[2];
    return {
      fontSizeSM,
      fontSize: fontSizeMD,
      fontSizeLG,
      fontSizeXL: fontSizes[3],
      fontSizeHeading1: fontSizes[6],
      fontSizeHeading2: fontSizes[5],
      fontSizeHeading3: fontSizes[4],
      fontSizeHeading4: fontSizes[3],
      fontSizeHeading5: fontSizes[2],
      lineHeight,
      lineHeightLG,
      lineHeightSM,
      fontHeight: Math.round(lineHeight * fontSizeMD),
      fontHeightLG: Math.round(lineHeightLG * fontSizeLG),
      fontHeightSM: Math.round(lineHeightSM * fontSizeSM),
      lineHeightHeading1: lineHeights[6],
      lineHeightHeading2: lineHeights[5],
      lineHeightHeading3: lineHeights[4],
      lineHeightHeading4: lineHeights[3],
      lineHeightHeading5: lineHeights[2]
    };
  };
  function genSizeMapToken$1(token2) {
    const {
      sizeUnit,
      sizeStep
    } = token2;
    return {
      sizeXXL: sizeUnit * (sizeStep + 8),
sizeXL: sizeUnit * (sizeStep + 4),
sizeLG: sizeUnit * (sizeStep + 2),
sizeMD: sizeUnit * (sizeStep + 1),
sizeMS: sizeUnit * sizeStep,
size: sizeUnit * sizeStep,
sizeSM: sizeUnit * (sizeStep - 1),
sizeXS: sizeUnit * (sizeStep - 2),
sizeXXS: sizeUnit * (sizeStep - 3)
};
  }
  const getAlphaColor$2 = (baseColor, alpha2) => new FastColor(baseColor).setA(alpha2).toRgbString();
  const getSolidColor$1 = (baseColor, brightness) => {
    const instance = new FastColor(baseColor);
    return instance.darken(brightness).toHexString();
  };
  const generateColorPalettes$1 = (baseColor) => {
    const colors2 = generate$1(baseColor);
    return {
      1: colors2[0],
      2: colors2[1],
      3: colors2[2],
      4: colors2[3],
      5: colors2[4],
      6: colors2[5],
      7: colors2[6],
      8: colors2[4],
      9: colors2[5],
      10: colors2[6]
    };
  };
  const generateNeutralColorPalettes$1 = (bgBaseColor, textBaseColor) => {
    const colorBgBase = bgBaseColor || "#fff";
    const colorTextBase = textBaseColor || "#000";
    return {
      colorBgBase,
      colorTextBase,
      colorText: getAlphaColor$2(colorTextBase, 0.88),
      colorTextSecondary: getAlphaColor$2(colorTextBase, 0.65),
      colorTextTertiary: getAlphaColor$2(colorTextBase, 0.45),
      colorTextQuaternary: getAlphaColor$2(colorTextBase, 0.25),
      colorFill: getAlphaColor$2(colorTextBase, 0.15),
      colorFillSecondary: getAlphaColor$2(colorTextBase, 0.06),
      colorFillTertiary: getAlphaColor$2(colorTextBase, 0.04),
      colorFillQuaternary: getAlphaColor$2(colorTextBase, 0.02),
      colorBgSolid: getAlphaColor$2(colorTextBase, 1),
      colorBgSolidHover: getAlphaColor$2(colorTextBase, 0.75),
      colorBgSolidActive: getAlphaColor$2(colorTextBase, 0.95),
      colorBgLayout: getSolidColor$1(colorBgBase, 4),
      colorBgContainer: getSolidColor$1(colorBgBase, 0),
      colorBgElevated: getSolidColor$1(colorBgBase, 0),
      colorBgSpotlight: getAlphaColor$2(colorTextBase, 0.85),
      colorBgBlur: "transparent",
      colorBorder: getSolidColor$1(colorBgBase, 15),
      colorBorderDisabled: getSolidColor$1(colorBgBase, 15),
      colorBorderSecondary: getSolidColor$1(colorBgBase, 6)
    };
  };
  function derivative$2(token2) {
    presetPrimaryColors.pink = presetPrimaryColors.magenta;
    presetPalettes.pink = presetPalettes.magenta;
    const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
      const colors2 = token2[colorKey] === presetPrimaryColors[colorKey] ? presetPalettes[colorKey] : generate$1(token2[colorKey]);
      return Array.from({
        length: 10
      }, () => 1).reduce((prev2, _2, i2) => {
        prev2[`${colorKey}-${i2 + 1}`] = colors2[i2];
        prev2[`${colorKey}${i2 + 1}`] = colors2[i2];
        return prev2;
      }, {});
    }).reduce((prev2, cur) => {
      prev2 = {
        ...prev2,
        ...cur
      };
      return prev2;
    }, {});
    return {
      ...token2,
      ...colorPalettes,
...genColorMapToken(token2, {
        generateColorPalettes: generateColorPalettes$1,
        generateNeutralColorPalettes: generateNeutralColorPalettes$1
      }),
...genFontMapToken(token2.fontSize),
...genSizeMapToken$1(token2),
...genControlHeight(token2),
...genCommonMapToken(token2)
    };
  }
  const defaultTheme = createTheme(derivative$2);
  const defaultConfig = {
    token: seedToken,
    override: {
      override: seedToken
    },
    hashed: true
  };
  const DesignTokenContext = React.createContext(defaultConfig);
  function isStableColor(color2) {
    return color2 >= 0 && color2 <= 255;
  }
  function getAlphaColor$1(frontColor, backgroundColor) {
    const {
      r: fR,
      g: fG,
      b: fB,
      a: originAlpha
    } = new FastColor(frontColor).toRgb();
    if (originAlpha < 1) {
      return frontColor;
    }
    const {
      r: bR,
      g: bG,
      b: bB
    } = new FastColor(backgroundColor).toRgb();
    for (let fA = 0.01; fA <= 1; fA += 0.01) {
      const r2 = Math.round((fR - bR * (1 - fA)) / fA);
      const g2 = Math.round((fG - bG * (1 - fA)) / fA);
      const b = Math.round((fB - bB * (1 - fA)) / fA);
      if (isStableColor(r2) && isStableColor(g2) && isStableColor(b)) {
        return new FastColor({
          r: r2,
          g: g2,
          b,
          a: Math.round(fA * 100) / 100
        }).toRgbString();
      }
    }
    return new FastColor({
      r: fR,
      g: fG,
      b: fB,
      a: 1
    }).toRgbString();
  }
  function formatToken(derivativeToken) {
    const {
      override,
      ...restToken
    } = derivativeToken;
    const overrideTokens = {
      ...override
    };
    Object.keys(seedToken).forEach((token2) => {
      delete overrideTokens[token2];
    });
    const mergedToken = {
      ...restToken,
      ...overrideTokens
    };
    const screenXS = 480;
    const screenSM = 576;
    const screenMD = 768;
    const screenLG = 992;
    const screenXL = 1200;
    const screenXXL = 1600;
    const screenXXXL = 1920;
    if (mergedToken.motion === false) {
      const fastDuration = "0s";
      mergedToken.motionDurationFast = fastDuration;
      mergedToken.motionDurationMid = fastDuration;
      mergedToken.motionDurationSlow = fastDuration;
    }
    const aliasToken = {
      ...mergedToken,
colorFillContent: mergedToken.colorFillSecondary,
      colorFillContentHover: mergedToken.colorFill,
      colorFillAlter: mergedToken.colorFillQuaternary,
      colorBgContainerDisabled: mergedToken.colorFillTertiary,
colorBorderBg: mergedToken.colorBgContainer,
      colorSplit: getAlphaColor$1(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
colorTextPlaceholder: mergedToken.colorTextQuaternary,
      colorTextDisabled: mergedToken.colorTextQuaternary,
      colorTextHeading: mergedToken.colorText,
      colorTextLabel: mergedToken.colorTextSecondary,
      colorTextDescription: mergedToken.colorTextTertiary,
      colorTextLightSolid: mergedToken.colorWhite,
      colorHighlight: mergedToken.colorError,
      colorBgTextHover: mergedToken.colorFillSecondary,
      colorBgTextActive: mergedToken.colorFill,
      colorIcon: mergedToken.colorTextTertiary,
      colorIconHover: mergedToken.colorText,
      colorErrorOutline: getAlphaColor$1(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
      colorWarningOutline: getAlphaColor$1(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
fontSizeIcon: mergedToken.fontSizeSM,
lineWidthFocus: mergedToken.lineWidth * 3,
lineWidth: mergedToken.lineWidth,
      controlOutlineWidth: mergedToken.lineWidth * 2,
controlInteractiveSize: mergedToken.controlHeight / 2,
      controlItemBgHover: mergedToken.colorFillTertiary,
      controlItemBgActive: mergedToken.colorPrimaryBg,
      controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
      controlItemBgActiveDisabled: mergedToken.colorFill,
      controlTmpOutline: mergedToken.colorFillQuaternary,
      controlOutline: getAlphaColor$1(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
      lineType: mergedToken.lineType,
      borderRadius: mergedToken.borderRadius,
      borderRadiusXS: mergedToken.borderRadiusXS,
      borderRadiusSM: mergedToken.borderRadiusSM,
      borderRadiusLG: mergedToken.borderRadiusLG,
      fontWeightStrong: 600,
      opacityLoading: 0.65,
      linkDecoration: "none",
      linkHoverDecoration: "none",
      linkFocusDecoration: "none",
      controlPaddingHorizontal: 12,
      controlPaddingHorizontalSM: 8,
      paddingXXS: mergedToken.sizeXXS,
      paddingXS: mergedToken.sizeXS,
      paddingSM: mergedToken.sizeSM,
      padding: mergedToken.size,
      paddingMD: mergedToken.sizeMD,
      paddingLG: mergedToken.sizeLG,
      paddingXL: mergedToken.sizeXL,
      paddingContentHorizontalLG: mergedToken.sizeLG,
      paddingContentVerticalLG: mergedToken.sizeMS,
      paddingContentHorizontal: mergedToken.sizeMS,
      paddingContentVertical: mergedToken.sizeSM,
      paddingContentHorizontalSM: mergedToken.size,
      paddingContentVerticalSM: mergedToken.sizeXS,
      marginXXS: mergedToken.sizeXXS,
      marginXS: mergedToken.sizeXS,
      marginSM: mergedToken.sizeSM,
      margin: mergedToken.size,
      marginMD: mergedToken.sizeMD,
      marginLG: mergedToken.sizeLG,
      marginXL: mergedToken.sizeXL,
      marginXXL: mergedToken.sizeXXL,
      boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
      screenXS,
      screenXSMin: screenXS,
      screenXSMax: screenSM - 1,
      screenSM,
      screenSMMin: screenSM,
      screenSMMax: screenMD - 1,
      screenMD,
      screenMDMin: screenMD,
      screenMDMax: screenLG - 1,
      screenLG,
      screenLGMin: screenLG,
      screenLGMax: screenXL - 1,
      screenXL,
      screenXLMin: screenXL,
      screenXLMax: screenXXL - 1,
      screenXXL,
      screenXXLMin: screenXXL,
      screenXXLMax: screenXXXL - 1,
      screenXXXL,
      screenXXXLMin: screenXXXL,
      boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
      boxShadowCard: `
      0 1px 2px -2px ${new FastColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new FastColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new FastColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
      boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)",
...overrideTokens
    };
    return aliasToken;
  }
  const unitless = {
    lineHeight: true,
    lineHeightSM: true,
    lineHeightLG: true,
    lineHeightHeading1: true,
    lineHeightHeading2: true,
    lineHeightHeading3: true,
    lineHeightHeading4: true,
    lineHeightHeading5: true,
    opacityLoading: true,
    fontWeightStrong: true,
    zIndexPopupBase: true,
    zIndexBase: true,
    opacityImage: true
  };
  const ignore = {
    motionBase: true,
    motionUnit: true
  };
  const preserve = {
    screenXS: true,
    screenXSMin: true,
    screenXSMax: true,
    screenSM: true,
    screenSMMin: true,
    screenSMMax: true,
    screenMD: true,
    screenMDMin: true,
    screenMDMax: true,
    screenLG: true,
    screenLGMin: true,
    screenLGMax: true,
    screenXL: true,
    screenXLMin: true,
    screenXLMax: true,
    screenXXL: true,
    screenXXLMin: true
  };
  const getComputedToken = (originToken, overrideToken, theme2) => {
    const derivativeToken = theme2.getDerivativeToken(originToken);
    const {
      override,
      ...components2
    } = overrideToken;
    let mergedDerivativeToken = {
      ...derivativeToken,
      override
    };
    mergedDerivativeToken = formatToken(mergedDerivativeToken);
    if (components2) {
      Object.entries(components2).forEach(([key, value]) => {
        const {
          theme: componentTheme,
          ...componentTokens
        } = value;
        let mergedComponentToken = componentTokens;
        if (componentTheme) {
          mergedComponentToken = getComputedToken({
            ...mergedDerivativeToken,
            ...componentTokens
          }, {
            override: componentTokens
          }, componentTheme);
        }
        mergedDerivativeToken[key] = mergedComponentToken;
      });
    }
    return mergedDerivativeToken;
  };
  function useToken$1() {
    const {
      token: rootDesignToken,
      hashed,
      theme: theme2,
      override,
      cssVar: ctxCssVar,
      zeroRuntime
    } = React.useContext(DesignTokenContext);
    const cssVar2 = {
      prefix: ctxCssVar?.prefix ?? "ant",
      key: ctxCssVar?.key ?? "css-var-root"
    };
    const salt = `${version}-${hashed || ""}`;
    const mergedTheme = theme2 || defaultTheme;
    const [token2, hashId, realToken] = useCacheToken(mergedTheme, [seedToken, rootDesignToken], {
      salt,
      override,
      getComputedToken,
      cssVar: {
        ...cssVar2,
        unitless,
        ignore,
        preserve
      }
    });
    return [mergedTheme, realToken, hashed ? hashId : "", token2, cssVar2, !!zeroRuntime];
  }
  const textEllipsis = {
    overflow: "hidden",
    whiteSpace: "nowrap",
    textOverflow: "ellipsis"
  };
  const resetComponent = (token2, needInheritFontFamily = false) => ({
    boxSizing: "border-box",
    margin: 0,
    padding: 0,
    color: token2.colorText,
    fontSize: token2.fontSize,
lineHeight: token2.lineHeight,
    listStyle: "none",
fontFamily: needInheritFontFamily ? "inherit" : token2.fontFamily
  });
  const resetIcon = () => ({
    display: "inline-flex",
    alignItems: "center",
    color: "inherit",
    fontStyle: "normal",
    lineHeight: 0,
    textAlign: "center",
    textTransform: "none",
verticalAlign: "-0.125em",
    textRendering: "optimizeLegibility",
    "-webkit-font-smoothing": "antialiased",
    "-moz-osx-font-smoothing": "grayscale",
    "> *": {
      lineHeight: 1
    },
    svg: {
      display: "inline-block"
    }
  });
  const clearFix = () => ({
"&::before": {
      display: "table",
      content: '""'
    },
    "&::after": {
display: "table",
      clear: "both",
      content: '""'
    }
  });
  const genLinkStyle = (token2) => ({
    a: {
      color: token2.colorLink,
      textDecoration: token2.linkDecoration,
      backgroundColor: "transparent",
outline: "none",
      cursor: "pointer",
      transition: `color ${token2.motionDurationSlow}`,
      "-webkit-text-decoration-skip": "objects",
"&:hover": {
        color: token2.colorLinkHover
      },
      "&:active": {
        color: token2.colorLinkActive
      },
      "&:active, &:hover": {
        textDecoration: token2.linkHoverDecoration,
        outline: 0
      },
"&:focus": {
        textDecoration: token2.linkFocusDecoration,
        outline: 0
      },
      "&[disabled]": {
        color: token2.colorTextDisabled,
        cursor: "not-allowed"
      }
    }
  });
  const genCommonStyle = (token2, componentPrefixCls, rootCls, resetFont) => {
    const prefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
    const rootPrefixSelector = rootCls ? `.${rootCls}` : prefixSelector;
    const resetStyle = {
      boxSizing: "border-box",
      "&::before, &::after": {
        boxSizing: "border-box"
      }
    };
    let resetFontStyle = {};
    if (resetFont !== false) {
      resetFontStyle = {
        fontFamily: token2.fontFamily,
        fontSize: token2.fontSize
      };
    }
    return {
      [rootPrefixSelector]: {
        ...resetFontStyle,
        ...resetStyle,
        [prefixSelector]: resetStyle
      }
    };
  };
  const genFocusOutline = (token2, offset2) => ({
    outline: `${unit$1(token2.lineWidthFocus)} solid ${token2.colorPrimaryBorder}`,
    outlineOffset: offset2 ?? 1,
    transition: [`outline-offset`, `outline`].map((prop) => `${prop} 0s`).join(", ")
  });
  const genFocusStyle = (token2, offset2) => ({
    "&:focus-visible": genFocusOutline(token2, offset2)
  });
  const genIconStyle = (iconPrefixCls) => ({
    [`.${iconPrefixCls}`]: {
      ...resetIcon(),
      [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: {
        display: "block"
      }
    }
  });
  const operationUnit = (token2) => ({

color: token2.colorLink,
    textDecoration: token2.linkDecoration,
    outline: "none",
    cursor: "pointer",
    transition: `all ${token2.motionDurationSlow}`,
    border: 0,
    padding: 0,
    background: "none",
    userSelect: "none",
    ...genFocusStyle(token2),
    "&:hover": {
      color: token2.colorLinkHover,
      textDecoration: token2.linkHoverDecoration
    },
    "&:focus": {
      color: token2.colorLinkHover,
      textDecoration: token2.linkFocusDecoration
    },
    "&:active": {
      color: token2.colorLinkActive,
      textDecoration: token2.linkHoverDecoration
    }
  });
  const {
    genStyleHooks,
    genComponentStyleHook,
    genSubStyleComponent
  } = genStyleUtils({
    usePrefix: () => {
      const {
        getPrefixCls,
        iconPrefixCls
      } = reactExports.useContext(ConfigContext);
      const rootPrefixCls = getPrefixCls();
      return {
        rootPrefixCls,
        iconPrefixCls
      };
    },
    useToken: () => {
      const [theme2, realToken, hashId, token2, cssVar2, zeroRuntime] = useToken$1();
      return {
        theme: theme2,
        realToken,
        hashId,
        token: token2,
        cssVar: cssVar2,
        zeroRuntime
      };
    },
    useCSP: () => {
      const {
        csp
      } = reactExports.useContext(ConfigContext);
      return csp ?? {};
    },
    getResetStyles: (token2, config) => {
      const linkStyle = genLinkStyle(token2);
      return [linkStyle, {
        "&": linkStyle
      }, genIconStyle(config?.prefix.iconPrefixCls ?? defaultIconPrefixCls)];
    },
    getCommonStyle: genCommonStyle,
    getCompUnitless: () => unitless
  });
  const genCssVar = (antCls, component) => {
    const cssPrefix = `--${antCls.replace(/\./g, "")}-${component}-`;
    const varName = (name) => {
      return `${cssPrefix}${name}`;
    };
    const varRef = (name, fallback) => {
      return fallback ? `var(${cssPrefix}${name}, ${fallback})` : `var(${cssPrefix}${name})`;
    };
    return [varName, varRef];
  };
  function genPresetColor$1(token2, genCss) {
    return PresetColors.reduce((prev2, colorKey) => {
      const lightColor = token2[`${colorKey}1`];
      const lightBorderColor = token2[`${colorKey}3`];
      const darkColor = token2[`${colorKey}6`];
      const textColor = token2[`${colorKey}7`];
      return {
        ...prev2,
        ...genCss(colorKey, {
          lightColor,
          lightBorderColor,
          darkColor,
          textColor
        })
      };
    }, {});
  }
  const useResetIconStyle = (iconPrefixCls, csp) => {
    useToken$1();
    return useStyleRegister({
      hashId: "",
      path: ["ant-design-icons", iconPrefixCls],
      nonce: () => csp?.nonce,
      layer: {
        name: "antd"
      }
    }, () => genIconStyle(iconPrefixCls));
  };
  var CheckCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
  const IconContext = reactExports.createContext({});
  function getRoot(ele) {
    return ele?.getRootNode?.();
  }
  function inShadow(ele) {
    return getRoot(ele) instanceof ShadowRoot;
  }
  function getShadowRoot(ele) {
    return inShadow(ele) ? getRoot(ele) : null;
  }
  function camelCase(input) {
    return input.replace(/-(.)/g, (match2, g2) => g2.toUpperCase());
  }
  function warning$1(valid, message2) {
    warningOnce(valid, `[@ant-design/icons] ${message2}`);
  }
  function isIconDefinition(target) {
    return typeof target === "object" && typeof target.name === "string" && typeof target.theme === "string" && (typeof target.icon === "object" || typeof target.icon === "function");
  }
  function normalizeAttrs(attrs = {}) {
    return Object.keys(attrs).reduce((acc, key) => {
      const val = attrs[key];
      switch (key) {
        case "class":
          acc.className = val;
          delete acc.class;
          break;
        default:
          delete acc[key];
          acc[camelCase(key)] = val;
      }
      return acc;
    }, {});
  }
  function generate(node2, key, rootProps) {
    if (!rootProps) {
      return React.createElement(node2.tag, {
        key,
        ...normalizeAttrs(node2.attrs)
      }, (node2.children || []).map((child, index) => generate(child, `${key}-${node2.tag}-${index}`)));
    }
    return React.createElement(node2.tag, {
      key,
      ...normalizeAttrs(node2.attrs),
      ...rootProps
    }, (node2.children || []).map((child, index) => generate(child, `${key}-${node2.tag}-${index}`)));
  }
  function getSecondaryColor(primaryColor) {
    return generate$1(primaryColor)[0];
  }
  function normalizeTwoToneColors(twoToneColor) {
    if (!twoToneColor) {
      return [];
    }
    return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
  }
  const iconStyles = `
.anticon {
  display: inline-flex;
  align-items: center;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
  vertical-align: inherit;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`;
  const useInsertStyles = (eleRef) => {
    const {
      csp,
      prefixCls,
      layer
    } = reactExports.useContext(IconContext);
    let mergedStyleStr = iconStyles;
    if (prefixCls) {
      mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
    }
    if (layer) {
      mergedStyleStr = `@layer ${layer} {
${mergedStyleStr}
}`;
    }
    reactExports.useEffect(() => {
      const ele = eleRef.current;
      const shadowRoot = getShadowRoot(ele);
      updateCSS(mergedStyleStr, "@ant-design-icons", {
        prepend: !layer,
        csp,
        attachTo: shadowRoot
      });
    }, []);
  };
  const twoToneColorPalette = {
    primaryColor: "#333",
    secondaryColor: "#E6E6E6",
    calculated: false
  };
  function setTwoToneColors({
    primaryColor,
    secondaryColor
  }) {
    twoToneColorPalette.primaryColor = primaryColor;
    twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
    twoToneColorPalette.calculated = !!secondaryColor;
  }
  function getTwoToneColors() {
    return {
      ...twoToneColorPalette
    };
  }
  const IconBase = (props) => {
    const {
      icon,
      className,
      onClick,
      style: style2,
      primaryColor,
      secondaryColor,
      ...restProps
    } = props;
    const svgRef = reactExports.useRef(null);
    let colors2 = twoToneColorPalette;
    if (primaryColor) {
      colors2 = {
        primaryColor,
        secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
      };
    }
    useInsertStyles(svgRef);
    warning$1(isIconDefinition(icon), `icon should be icon definiton, but got ${icon}`);
    if (!isIconDefinition(icon)) {
      return null;
    }
    let target = icon;
    if (target && typeof target.icon === "function") {
      target = {
        ...target,
        icon: target.icon(colors2.primaryColor, colors2.secondaryColor)
      };
    }
    return generate(target.icon, `svg-${target.name}`, {
      className,
      onClick,
      style: style2,
      "data-icon": target.name,
      width: "1em",
      height: "1em",
      fill: "currentColor",
      "aria-hidden": "true",
      ...restProps,
      ref: svgRef
    });
  };
  IconBase.displayName = "IconReact";
  IconBase.getTwoToneColors = getTwoToneColors;
  IconBase.setTwoToneColors = setTwoToneColors;
  function setTwoToneColor(twoToneColor) {
    const [primaryColor, secondaryColor] = normalizeTwoToneColors(twoToneColor);
    return IconBase.setTwoToneColors({
      primaryColor,
      secondaryColor
    });
  }
  function getTwoToneColor() {
    const colors2 = IconBase.getTwoToneColors();
    if (!colors2.calculated) {
      return colors2.primaryColor;
    }
    return [colors2.primaryColor, colors2.secondaryColor];
  }
  function _extends$13() {
    _extends$13 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$13.apply(this, arguments);
  }
  setTwoToneColor(blue.primary);
  const Icon$1 = reactExports.forwardRef((props, ref2) => {
    const {
className,
icon,
      spin,
      rotate: rotate2,
      tabIndex,
      onClick,
twoToneColor,
      ...restProps
    } = props;
    const {
      prefixCls = "anticon",
      rootClassName
    } = reactExports.useContext(IconContext);
    const classString = clsx(rootClassName, prefixCls, {
      [`${prefixCls}-${icon.name}`]: !!icon.name,
      [`${prefixCls}-spin`]: !!spin || icon.name === "loading"
    }, className);
    let iconTabIndex = tabIndex;
    if (iconTabIndex === void 0 && onClick) {
      iconTabIndex = -1;
    }
    const svgStyle = rotate2 ? {
      msTransform: `rotate(${rotate2}deg)`,
      transform: `rotate(${rotate2}deg)`
    } : void 0;
    const [primaryColor, secondaryColor] = normalizeTwoToneColors(twoToneColor);
    return reactExports.createElement("span", _extends$13({
      role: "img",
      "aria-label": icon.name
    }, restProps, {
      ref: ref2,
      tabIndex: iconTabIndex,
      onClick,
      className: classString
    }), reactExports.createElement(IconBase, {
      icon,
      primaryColor,
      secondaryColor,
      style: svgStyle
    }));
  });
  Icon$1.getTwoToneColor = getTwoToneColor;
  Icon$1.setTwoToneColor = setTwoToneColor;
  function _extends$12() {
    _extends$12 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$12.apply(this, arguments);
  }
  const CheckCircleFilled = (props, ref2) => reactExports.createElement(Icon$1, _extends$12({}, props, {
    ref: ref2,
    icon: CheckCircleFilled$1
  }));
  const RefIcon$m = reactExports.forwardRef(CheckCircleFilled);
  var CloseCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, "name": "close-circle", "theme": "filled" };
  function _extends$11() {
    _extends$11 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$11.apply(this, arguments);
  }
  const CloseCircleFilled = (props, ref2) => reactExports.createElement(Icon$1, _extends$11({}, props, {
    ref: ref2,
    icon: CloseCircleFilled$1
  }));
  const RefIcon$l = reactExports.forwardRef(CloseCircleFilled);
  var CloseOutlined$1 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, "name": "close", "theme": "outlined" };
  function _extends$10() {
    _extends$10 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$10.apply(this, arguments);
  }
  const CloseOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends$10({}, props, {
    ref: ref2,
    icon: CloseOutlined$1
  }));
  const RefIcon$k = reactExports.forwardRef(CloseOutlined);
  var ExclamationCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };
  function _extends$$() {
    _extends$$ = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$$.apply(this, arguments);
  }
  const ExclamationCircleFilled = (props, ref2) => reactExports.createElement(Icon$1, _extends$$({}, props, {
    ref: ref2,
    icon: ExclamationCircleFilled$1
  }));
  const RefIcon$j = reactExports.forwardRef(ExclamationCircleFilled);
  var InfoCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "info-circle", "theme": "filled" };
  function _extends$_() {
    _extends$_ = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$_.apply(this, arguments);
  }
  const InfoCircleFilled = (props, ref2) => reactExports.createElement(Icon$1, _extends$_({}, props, {
    ref: ref2,
    icon: InfoCircleFilled$1
  }));
  const RefIcon$i = reactExports.forwardRef(InfoCircleFilled);
  const Context$2 = reactExports.createContext({});
  const MotionProvider = (props) => {
    const {
      children,
      ...rest
    } = props;
    const memoizedValue = reactExports.useMemo(() => {
      return {
        motion: rest.motion
      };
    }, [rest.motion]);
    return reactExports.createElement(Context$2.Provider, {
      value: memoizedValue
    }, children);
  };
  function useSyncState$1(defaultValue2) {
    const [, forceUpdate] = reactExports.useReducer((x) => x + 1, 0);
    const currentValueRef = reactExports.useRef(defaultValue2);
    const getValue2 = useEvent$1(() => {
      return currentValueRef.current;
    });
    const setValue = useEvent$1((updater) => {
      currentValueRef.current = typeof updater === "function" ? updater(currentValueRef.current) : updater;
      forceUpdate();
    });
    return [getValue2, setValue];
  }
  const STATUS_NONE = "none";
  const STATUS_APPEAR = "appear";
  const STATUS_ENTER = "enter";
  const STATUS_LEAVE = "leave";
  const STEP_NONE = "none";
  const STEP_PREPARE = "prepare";
  const STEP_START = "start";
  const STEP_ACTIVE = "active";
  const STEP_ACTIVATED = "end";
  const STEP_PREPARED = "prepared";
  function makePrefixMap(styleProp, eventName) {
    const prefixes = {};
    prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
    prefixes[`Webkit${styleProp}`] = `webkit${eventName}`;
    prefixes[`Moz${styleProp}`] = `moz${eventName}`;
    prefixes[`ms${styleProp}`] = `MS${eventName}`;
    prefixes[`O${styleProp}`] = `o${eventName.toLowerCase()}`;
    return prefixes;
  }
  function getVendorPrefixes(domSupport, win2) {
    const prefixes = {
      animationend: makePrefixMap("Animation", "AnimationEnd"),
      transitionend: makePrefixMap("Transition", "TransitionEnd")
    };
    if (domSupport) {
      if (!("AnimationEvent" in win2)) {
        delete prefixes.animationend.animation;
      }
      if (!("TransitionEvent" in win2)) {
        delete prefixes.transitionend.transition;
      }
    }
    return prefixes;
  }
  const vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== "undefined" ? window : {});
  let style = {};
  if (canUseDom()) {
    ({
      style
    } = document.createElement("div"));
  }
  const prefixedEventNames = {};
  function getVendorPrefixedEventName(eventName) {
    if (prefixedEventNames[eventName]) {
      return prefixedEventNames[eventName];
    }
    const prefixMap = vendorPrefixes[eventName];
    if (prefixMap) {
      const stylePropList = Object.keys(prefixMap);
      const len = stylePropList.length;
      for (let i2 = 0; i2 < len; i2 += 1) {
        const styleProp = stylePropList[i2];
        if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
          prefixedEventNames[eventName] = prefixMap[styleProp];
          return prefixedEventNames[eventName];
        }
      }
    }
    return "";
  }
  const internalAnimationEndName = getVendorPrefixedEventName("animationend");
  const internalTransitionEndName = getVendorPrefixedEventName("transitionend");
  const supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
  const animationEndName = internalAnimationEndName || "animationend";
  const transitionEndName = internalTransitionEndName || "transitionend";
  function getTransitionName$1(transitionName, transitionType) {
    if (!transitionName) return null;
    if (typeof transitionName === "object") {
      const type4 = transitionType.replace(/-\w/g, (match2) => match2[1].toUpperCase());
      return transitionName[type4];
    }
    return `${transitionName}-${transitionType}`;
  }
  const useDomMotionEvents = ((onInternalMotionEnd) => {
    const cacheElementRef = reactExports.useRef();
    function removeMotionEvents(element) {
      if (element) {
        element.removeEventListener(transitionEndName, onInternalMotionEnd);
        element.removeEventListener(animationEndName, onInternalMotionEnd);
      }
    }
    function patchMotionEvents(element) {
      if (cacheElementRef.current && cacheElementRef.current !== element) {
        removeMotionEvents(cacheElementRef.current);
      }
      if (element && element !== cacheElementRef.current) {
        element.addEventListener(transitionEndName, onInternalMotionEnd);
        element.addEventListener(animationEndName, onInternalMotionEnd);
        cacheElementRef.current = element;
      }
    }
    reactExports.useEffect(() => () => {
      removeMotionEvents(cacheElementRef.current);
      cacheElementRef.current = null;
    }, []);
    return [patchMotionEvents, removeMotionEvents];
  });
  const useIsomorphicLayoutEffect$2 = canUseDom() ? reactExports.useLayoutEffect : reactExports.useEffect;
  const useNextFrame = (() => {
    const nextFrameRef = reactExports.useRef(null);
    function cancelNextFrame() {
      wrapperRaf.cancel(nextFrameRef.current);
    }
    function nextFrame(callback, delay2 = 2) {
      cancelNextFrame();
      const nextFrameId = wrapperRaf(() => {
        if (delay2 <= 1) {
          callback({
            isCanceled: () => nextFrameId !== nextFrameRef.current
          });
        } else {
          nextFrame(callback, delay2 - 1);
        }
      });
      nextFrameRef.current = nextFrameId;
    }
    reactExports.useEffect(() => () => {
      cancelNextFrame();
    }, []);
    return [nextFrame, cancelNextFrame];
  });
  const FULL_STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
  const SIMPLE_STEP_QUEUE = [STEP_PREPARE, STEP_PREPARED];
  const SkipStep = false;
  const DoStep = true;
  function isActive(step) {
    return step === STEP_ACTIVE || step === STEP_ACTIVATED;
  }
  const useStepQueue = ((status, prepareOnly, callback) => {
    const [step, setStep] = useSafeState(STEP_NONE);
    const [nextFrame, cancelNextFrame] = useNextFrame();
    function startQueue() {
      setStep(STEP_PREPARE, true);
    }
    const STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
    useIsomorphicLayoutEffect$2(() => {
      if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
        const index = STEP_QUEUE.indexOf(step);
        const nextStep = STEP_QUEUE[index + 1];
        const result = callback(step);
        if (result === SkipStep) {
          setStep(nextStep, true);
        } else if (nextStep) {
          nextFrame((info) => {
            function doNext() {
              if (info.isCanceled()) return;
              setStep(nextStep, true);
            }
            if (result === true) {
              doNext();
            } else {
              Promise.resolve(result).then(doNext);
            }
          });
        }
      }
    }, [status, step]);
    reactExports.useEffect(() => () => {
      cancelNextFrame();
    }, []);
    return [startQueue, step];
  });
  function useStatus(supportMotion, visible, getElement, {
    motionEnter = true,
    motionAppear = true,
    motionLeave = true,
    motionDeadline,
    motionLeaveImmediately,
    onAppearPrepare,
    onEnterPrepare,
    onLeavePrepare,
    onAppearStart,
    onEnterStart,
    onLeaveStart,
    onAppearActive,
    onEnterActive,
    onLeaveActive,
    onAppearEnd,
    onEnterEnd,
    onLeaveEnd,
    onVisibleChanged
  }) {
    const [asyncVisible, setAsyncVisible] = reactExports.useState();
    const [getStatus, setStatus] = useSyncState$1(STATUS_NONE);
    const [style2, setStyle2] = reactExports.useState([null, null]);
    const currentStatus = getStatus();
    const mountedRef = reactExports.useRef(false);
    const deadlineRef = reactExports.useRef(null);
    function getDomElement() {
      return getElement();
    }
    const activeRef = reactExports.useRef(false);
    function updateMotionEndStatus() {
      setStatus(STATUS_NONE);
      setStyle2([null, null]);
    }
    const onInternalMotionEnd = useEvent$1((event) => {
      const status = getStatus();
      if (status === STATUS_NONE) {
        return;
      }
      const element = getDomElement();
      if (event && !event.deadline && event.target !== element) {
        return;
      }
      const currentActive = activeRef.current;
      let canEnd;
      if (status === STATUS_APPEAR && currentActive) {
        canEnd = onAppearEnd?.(element, event);
      } else if (status === STATUS_ENTER && currentActive) {
        canEnd = onEnterEnd?.(element, event);
      } else if (status === STATUS_LEAVE && currentActive) {
        canEnd = onLeaveEnd?.(element, event);
      }
      if (currentActive && canEnd !== false) {
        updateMotionEndStatus();
      }
    });
    const [patchMotionEvents] = useDomMotionEvents(onInternalMotionEnd);
    const getEventHandlers = (targetStatus) => {
      switch (targetStatus) {
        case STATUS_APPEAR:
          return {
            [STEP_PREPARE]: onAppearPrepare,
            [STEP_START]: onAppearStart,
            [STEP_ACTIVE]: onAppearActive
          };
        case STATUS_ENTER:
          return {
            [STEP_PREPARE]: onEnterPrepare,
            [STEP_START]: onEnterStart,
            [STEP_ACTIVE]: onEnterActive
          };
        case STATUS_LEAVE:
          return {
            [STEP_PREPARE]: onLeavePrepare,
            [STEP_START]: onLeaveStart,
            [STEP_ACTIVE]: onLeaveActive
          };
        default:
          return {};
      }
    };
    const eventHandlers = reactExports.useMemo(() => getEventHandlers(currentStatus), [currentStatus]);
    const [startStep, step] = useStepQueue(currentStatus, !supportMotion, (newStep) => {
      if (newStep === STEP_PREPARE) {
        const onPrepare = eventHandlers[STEP_PREPARE];
        if (!onPrepare) {
          return SkipStep;
        }
        return onPrepare(getDomElement());
      }
      if (newStep in eventHandlers) {
        setStyle2([eventHandlers[newStep]?.(getDomElement(), null) || null, newStep]);
      }
      if (newStep === STEP_ACTIVE && currentStatus !== STATUS_NONE) {
        patchMotionEvents(getDomElement());
        if (motionDeadline > 0) {
          clearTimeout(deadlineRef.current);
          deadlineRef.current = setTimeout(() => {
            onInternalMotionEnd({
              deadline: true
            });
          }, motionDeadline);
        }
      }
      if (newStep === STEP_PREPARED) {
        updateMotionEndStatus();
      }
      return DoStep;
    });
    const active = isActive(step);
    activeRef.current = active;
    const visibleRef = reactExports.useRef(null);
    useIsomorphicLayoutEffect$2(() => {
      if (mountedRef.current && visibleRef.current === visible) {
        return;
      }
      setAsyncVisible(visible);
      const isMounted = mountedRef.current;
      mountedRef.current = true;
      let nextStatus;
      if (!isMounted && visible && motionAppear) {
        nextStatus = STATUS_APPEAR;
      }
      if (isMounted && visible && motionEnter) {
        nextStatus = STATUS_ENTER;
      }
      if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
        nextStatus = STATUS_LEAVE;
      }
      const nextEventHandlers = getEventHandlers(nextStatus);
      if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {
        setStatus(nextStatus);
        startStep();
      } else {
        setStatus(STATUS_NONE);
      }
      visibleRef.current = visible;
    }, [visible]);
    reactExports.useEffect(() => {
      if (
currentStatus === STATUS_APPEAR && !motionAppear ||
currentStatus === STATUS_ENTER && !motionEnter ||
currentStatus === STATUS_LEAVE && !motionLeave
      ) {
        setStatus(STATUS_NONE);
      }
    }, [motionAppear, motionEnter, motionLeave]);
    reactExports.useEffect(() => () => {
      mountedRef.current = false;
      clearTimeout(deadlineRef.current);
    }, []);
    const firstMountChangeRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      if (asyncVisible) {
        firstMountChangeRef.current = true;
      }
      if (asyncVisible !== void 0 && currentStatus === STATUS_NONE) {
        if (firstMountChangeRef.current || asyncVisible) {
          onVisibleChanged?.(asyncVisible);
        }
        firstMountChangeRef.current = true;
      }
    }, [asyncVisible, currentStatus]);
    let mergedStyle = style2[0];
    if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
      mergedStyle = {
        transition: "none",
        ...mergedStyle
      };
    }
    const styleStep = style2[1];
    return [
      getStatus,
      step,
      mergedStyle,
      asyncVisible ?? visible,
!mountedRef.current && currentStatus === STATUS_NONE && supportMotion && motionAppear ? "NONE" : (
step === STEP_START || step === STEP_ACTIVE ? styleStep === step : true
      )
    ];
  }
  function genCSSMotion(config) {
    let transitionSupport = config;
    if (typeof config === "object") {
      ({
        transitionSupport
      } = config);
    }
    function isSupportTransition(props, contextMotion) {
      return !!(props.motionName && transitionSupport && contextMotion !== false);
    }
    const CSSMotion2 = reactExports.forwardRef((props, ref2) => {
      const {
visible = true,
        removeOnLeave = true,
        forceRender,
        children,
        motionName,
        leavedClassName,
        eventProps
      } = props;
      const {
        motion: contextMotion
      } = reactExports.useContext(Context$2);
      const supportMotion = isSupportTransition(props, contextMotion);
      const nodeRef = reactExports.useRef();
      function getDomElement() {
        return getDOM(nodeRef.current);
      }
      const [getStatus, statusStep, statusStyle, mergedVisible, styleReady] = useStatus(supportMotion, visible, getDomElement, props);
      const status = getStatus();
      const renderedRef = reactExports.useRef(mergedVisible);
      if (mergedVisible) {
        renderedRef.current = true;
      }
      const refObj = reactExports.useMemo(() => {
        const obj = {};
        Object.defineProperties(obj, {
          nativeElement: {
            enumerable: true,
            get: getDomElement
          },
          inMotion: {
            enumerable: true,
            get: () => () => getStatus() !== STATUS_NONE
          },
          enableMotion: {
            enumerable: true,
            get: () => () => supportMotion
          }
        });
        return obj;
      }, []);
      reactExports.useImperativeHandle(ref2, () => refObj, []);
      const idRef = reactExports.useRef(0);
      if (styleReady) {
        idRef.current += 1;
      }
      return reactExports.useMemo(() => {
        if (styleReady === "NONE") {
          return null;
        }
        let motionChildren;
        const mergedProps = {
          ...eventProps,
          visible
        };
        if (!children) {
          motionChildren = null;
        } else if (status === STATUS_NONE) {
          if (mergedVisible) {
            motionChildren = children({
              ...mergedProps
            }, nodeRef);
          } else if (!removeOnLeave && renderedRef.current && leavedClassName) {
            motionChildren = children({
              ...mergedProps,
              className: leavedClassName
            }, nodeRef);
          } else if (forceRender || !removeOnLeave && !leavedClassName) {
            motionChildren = children({
              ...mergedProps,
              style: {
                display: "none"
              }
            }, nodeRef);
          } else {
            motionChildren = null;
          }
        } else {
          let statusSuffix;
          if (statusStep === STEP_PREPARE) {
            statusSuffix = "prepare";
          } else if (isActive(statusStep)) {
            statusSuffix = "active";
          } else if (statusStep === STEP_START) {
            statusSuffix = "start";
          }
          const motionCls = getTransitionName$1(motionName, `${status}-${statusSuffix}`);
          motionChildren = children({
            ...mergedProps,
            className: clsx(getTransitionName$1(motionName, status), {
              [motionCls]: motionCls && statusSuffix,
              [motionName]: typeof motionName === "string"
            }),
            style: statusStyle
          }, nodeRef);
        }
        if ( reactExports.isValidElement(motionChildren) && supportRef(motionChildren)) {
          const originNodeRef = getNodeRef(motionChildren);
          if (!originNodeRef) {
            motionChildren = reactExports.cloneElement(motionChildren, {
              ref: nodeRef
            });
          }
        }
        return motionChildren;
      }, [idRef.current]);
    });
    CSSMotion2.displayName = "CSSMotion";
    return CSSMotion2;
  }
  const CSSMotion = genCSSMotion(supportTransition);
  const STATUS_ADD = "add";
  const STATUS_KEEP = "keep";
  const STATUS_REMOVE = "remove";
  const STATUS_REMOVED = "removed";
  function wrapKeyToObject(key) {
    let keyObj;
    if (key && typeof key === "object" && "key" in key) {
      keyObj = key;
    } else {
      keyObj = {
        key
      };
    }
    return {
      ...keyObj,
      key: String(keyObj.key)
    };
  }
  function parseKeys(keys2 = []) {
    return keys2.map(wrapKeyToObject);
  }
  function diffKeys(prevKeys = [], currentKeys = []) {
    let list2 = [];
    let currentIndex = 0;
    const currentLen = currentKeys.length;
    const prevKeyObjects = parseKeys(prevKeys);
    const currentKeyObjects = parseKeys(currentKeys);
    prevKeyObjects.forEach((keyObj) => {
      let hit = false;
      for (let i2 = currentIndex; i2 < currentLen; i2 += 1) {
        const currentKeyObj = currentKeyObjects[i2];
        if (currentKeyObj.key === keyObj.key) {
          if (currentIndex < i2) {
            list2 = list2.concat(currentKeyObjects.slice(currentIndex, i2).map((obj) => ({
              ...obj,
              status: STATUS_ADD
            })));
            currentIndex = i2;
          }
          list2.push({
            ...currentKeyObj,
            status: STATUS_KEEP
          });
          currentIndex += 1;
          hit = true;
          break;
        }
      }
      if (!hit) {
        list2.push({
          ...keyObj,
          status: STATUS_REMOVE
        });
      }
    });
    if (currentIndex < currentLen) {
      list2 = list2.concat(currentKeyObjects.slice(currentIndex).map((obj) => ({
        ...obj,
        status: STATUS_ADD
      })));
    }
    const keys2 = {};
    list2.forEach(({
      key
    }) => {
      keys2[key] = (keys2[key] || 0) + 1;
    });
    const duplicatedKeys = Object.keys(keys2).filter((key) => keys2[key] > 1);
    duplicatedKeys.forEach((matchKey) => {
      list2 = list2.filter(({
        key,
        status
      }) => key !== matchKey || status !== STATUS_REMOVE);
      list2.forEach((node2) => {
        if (node2.key === matchKey) {
          node2.status = STATUS_KEEP;
        }
      });
    });
    return list2;
  }
  function _extends$Z() {
    _extends$Z = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$Z.apply(this, arguments);
  }
  const MOTION_PROP_NAMES = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
  function genCSSMotionList(transitionSupport, CSSMotion$1 = CSSMotion) {
    class CSSMotionList2 extends reactExports.Component {
      static defaultProps = {
        component: "div"
      };
      state = {
        keyEntities: []
      };
      static getDerivedStateFromProps({
        keys: keys2
      }, {
        keyEntities
      }) {
        const parsedKeyObjects = parseKeys(keys2);
        const mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
        return {
          keyEntities: mixedKeyEntities.filter((entity) => {
            const prevEntity = keyEntities.find(({
              key
            }) => entity.key === key);
            if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
              return false;
            }
            return true;
          })
        };
      }
removeKey = (removeKey) => {
        this.setState((prevState) => {
          const nextKeyEntities = prevState.keyEntities.map((entity) => {
            if (entity.key !== removeKey) return entity;
            return {
              ...entity,
              status: STATUS_REMOVED
            };
          });
          return {
            keyEntities: nextKeyEntities
          };
        }, () => {
          const {
            keyEntities
          } = this.state;
          const restKeysCount = keyEntities.filter(({
            status
          }) => status !== STATUS_REMOVED).length;
          if (restKeysCount === 0 && this.props.onAllRemoved) {
            this.props.onAllRemoved();
          }
        });
      };
      render() {
        const {
          keyEntities
        } = this.state;
        const {
          component,
          children,
          onVisibleChanged,
          onAllRemoved,
          ...restProps
        } = this.props;
        const Component = component || reactExports.Fragment;
        const motionProps = {};
        MOTION_PROP_NAMES.forEach((prop) => {
          motionProps[prop] = restProps[prop];
          delete restProps[prop];
        });
        delete restProps.keys;
        return reactExports.createElement(Component, restProps, keyEntities.map(({
          status,
          ...eventProps
        }, index) => {
          const visible = status === STATUS_ADD || status === STATUS_KEEP;
          return reactExports.createElement(CSSMotion$1, _extends$Z({}, motionProps, {
            key: eventProps.key,
            visible,
            eventProps,
            onVisibleChanged: (changedVisible) => {
              onVisibleChanged?.(changedVisible, {
                key: eventProps.key
              });
              if (!changedVisible) {
                this.removeKey(eventProps.key);
              }
            }
          }), (props, ref2) => children({
            ...props,
            index
          }, ref2));
        }));
      }
    }
    return CSSMotionList2;
  }
  const CSSMotionList = genCSSMotionList();
  const attributes = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap`;
  const eventsName = `onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`;
  const propList = `${attributes} ${eventsName}`.split(/[\s\n]+/);
  const ariaPrefix = "aria-";
  const dataPrefix = "data-";
  function match(key, prefix2) {
    return key.indexOf(prefix2) === 0;
  }
  function pickAttrs(props, ariaOnly = false) {
    let mergedConfig;
    if (ariaOnly === false) {
      mergedConfig = {
        aria: true,
        data: true,
        attr: true
      };
    } else if (ariaOnly === true) {
      mergedConfig = {
        aria: true
      };
    } else {
      mergedConfig = {
        ...ariaOnly
      };
    }
    const attrs = {};
    Object.keys(props).forEach((key) => {
      if (
mergedConfig.aria && (key === "role" || match(key, ariaPrefix)) ||
mergedConfig.data && match(key, dataPrefix) ||
mergedConfig.attr && propList.includes(key)
      ) {
        attrs[key] = props[key];
      }
    });
    return attrs;
  }
  const locale$4 = {
items_per_page: "/ page",
    jump_to: "Go to",
    jump_to_confirm: "confirm",
    page: "Page",
prev_page: "Previous Page",
    next_page: "Next Page",
    prev_5: "Previous 5 Pages",
    next_5: "Next 5 Pages",
    prev_3: "Previous 3 Pages",
    next_3: "Next 3 Pages",
    page_size: "Page Size"
  };
  var commonLocale = {
    yearFormat: "YYYY",
    dayFormat: "D",
    cellMeridiemFormat: "A",
    monthBeforeYear: true
  };
  function _typeof$1(o2) {
    "@babel/helpers - typeof";
    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof$1(o2);
  }
  function ownKeys$1(e, r2) {
    var t2 = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e);
      r2 && (o2 = o2.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t2.push.apply(t2, o2);
    }
    return t2;
  }
  function _objectSpread(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
        _defineProperty(e, r3, t2[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
      });
    }
    return e;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(t2) {
    var i2 = _toPrimitive(t2, "string");
    return "symbol" == _typeof$1(i2) ? i2 : String(i2);
  }
  function _toPrimitive(t2, r2) {
    if ("object" != _typeof$1(t2) || !t2) return t2;
    var e = t2[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i2 = e.call(t2, r2);
      if ("object" != _typeof$1(i2)) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t2);
  }
  var locale$3 = _objectSpread(_objectSpread({}, commonLocale), {}, {
    locale: "en_US",
    today: "Today",
    now: "Now",
    backToToday: "Back to today",
    ok: "OK",
    clear: "Clear",
    week: "Week",
    month: "Month",
    year: "Year",
    timeSelect: "select time",
    dateSelect: "select date",
    weekSelect: "Choose a week",
    monthSelect: "Choose a month",
    yearSelect: "Choose a year",
    decadeSelect: "Choose a decade",
    previousMonth: "Previous month (PageUp)",
    nextMonth: "Next month (PageDown)",
    previousYear: "Last year (Control + left)",
    nextYear: "Next year (Control + right)",
    previousDecade: "Last decade",
    nextDecade: "Next decade",
    previousCentury: "Last century",
    nextCentury: "Next century"
  });
  const locale$2 = {
    placeholder: "Select time",
    rangePlaceholder: ["Start time", "End time"]
  };
  const locale$1 = {
    lang: {
      placeholder: "Select date",
      yearPlaceholder: "Select year",
      quarterPlaceholder: "Select quarter",
      monthPlaceholder: "Select month",
      weekPlaceholder: "Select week",
      rangePlaceholder: ["Start date", "End date"],
      rangeYearPlaceholder: ["Start year", "End year"],
      rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
      rangeMonthPlaceholder: ["Start month", "End month"],
      rangeWeekPlaceholder: ["Start week", "End week"],
      ...locale$3
    },
    timePickerLocale: {
      ...locale$2
    }
  };
  const typeTemplate$1 = "${label} is not a valid ${type}";
  const localeValues = {
    locale: "en",
    Pagination: locale$4,
    DatePicker: locale$1,
    TimePicker: locale$2,
    Calendar: locale$1,
    global: {
      placeholder: "Please select",
      close: "Close",
      sortable: "sortable"
    },
    Table: {
      filterTitle: "Filter menu",
      filterConfirm: "OK",
      filterReset: "Reset",
      filterEmptyText: "No filters",
      filterCheckAll: "Select all items",
      filterSearchPlaceholder: "Search in filters",
      emptyText: "No data",
      selectAll: "Select current page",
      selectInvert: "Invert current page",
      selectNone: "Clear all data",
      selectionAll: "Select all data",
      sortTitle: "Sort",
      expand: "Expand row",
      collapse: "Collapse row",
      triggerDesc: "Click to sort descending",
      triggerAsc: "Click to sort ascending",
      cancelSort: "Click to cancel sorting"
    },
    Tour: {
      Next: "Next",
      Previous: "Previous",
      Finish: "Finish"
    },
    Modal: {
      okText: "OK",
      cancelText: "Cancel",
      justOkText: "OK"
    },
    Popconfirm: {
      okText: "OK",
      cancelText: "Cancel"
    },
    Transfer: {
      titles: ["", ""],
      searchPlaceholder: "Search here",
      itemUnit: "item",
      itemsUnit: "items",
      remove: "Remove",
      selectCurrent: "Select current page",
      removeCurrent: "Remove current page",
      selectAll: "Select all data",
      deselectAll: "Deselect all data",
      removeAll: "Remove all data",
      selectInvert: "Invert current page"
    },
    Upload: {
      uploading: "Uploading...",
      removeFile: "Remove file",
      uploadError: "Upload error",
      previewFile: "Preview file",
      downloadFile: "Download file"
    },
    Empty: {
      description: "No data"
    },
    Icon: {
      icon: "icon"
    },
    Text: {
      edit: "Edit",
      copy: "Copy",
      copied: "Copied",
      expand: "Expand",
      collapse: "Collapse"
    },
    Form: {
      optional: "(optional)",
      defaultValidateMessages: {
        default: "Field validation error for ${label}",
        required: "Please enter ${label}",
        enum: "${label} must be one of [${enum}]",
        whitespace: "${label} cannot be a blank character",
        date: {
          format: "${label} date format is invalid",
          parse: "${label} cannot be converted to a date",
          invalid: "${label} is an invalid date"
        },
        types: {
          string: typeTemplate$1,
          method: typeTemplate$1,
          array: typeTemplate$1,
          object: typeTemplate$1,
          number: typeTemplate$1,
          date: typeTemplate$1,
          boolean: typeTemplate$1,
          integer: typeTemplate$1,
          float: typeTemplate$1,
          regexp: typeTemplate$1,
          email: typeTemplate$1,
          url: typeTemplate$1,
          hex: typeTemplate$1
        },
        string: {
          len: "${label} must be ${len} characters",
          min: "${label} must be at least ${min} characters",
          max: "${label} must be up to ${max} characters",
          range: "${label} must be between ${min}-${max} characters"
        },
        number: {
          len: "${label} must be equal to ${len}",
          min: "${label} must be minimum ${min}",
          max: "${label} must be maximum ${max}",
          range: "${label} must be between ${min}-${max}"
        },
        array: {
          len: "Must be ${len} ${label}",
          min: "At least ${min} ${label}",
          max: "At most ${max} ${label}",
          range: "The amount of ${label} must be between ${min}-${max}"
        },
        pattern: {
          mismatch: "${label} does not match the pattern ${pattern}"
        }
      }
    },
    QRCode: {
      expired: "QR code expired",
      refresh: "Refresh",
      scanned: "Scanned"
    },
    ColorPicker: {
      presetEmpty: "Empty",
      transparent: "Transparent",
      singleColor: "Single",
      gradientColor: "Gradient"
    }
  };
  let runtimeLocale = {
    ...localeValues.Modal
  };
  let localeList = [];
  const generateLocale = () => localeList.reduce((merged, locale2) => ({
    ...merged,
    ...locale2
  }), localeValues.Modal);
  function changeConfirmLocale(newLocale) {
    if (newLocale) {
      const cloneLocale = {
        ...newLocale
      };
      localeList.push(cloneLocale);
      runtimeLocale = generateLocale();
      return () => {
        localeList = localeList.filter((locale2) => locale2 !== cloneLocale);
        runtimeLocale = generateLocale();
      };
    }
    runtimeLocale = {
      ...localeValues.Modal
    };
  }
  function getConfirmLocale() {
    return runtimeLocale;
  }
  const LocaleContext = reactExports.createContext(void 0);
  const useLocale = (componentName, defaultLocale) => {
    const fullLocale = reactExports.useContext(LocaleContext);
    const getLocale = reactExports.useMemo(() => {
      const locale2 = defaultLocale || localeValues[componentName];
      const localeFromContext = fullLocale?.[componentName] ?? {};
      return {
        ...typeof locale2 === "function" ? locale2() : locale2,
        ...localeFromContext || {}
      };
    }, [componentName, defaultLocale, fullLocale]);
    const getLocaleCode = reactExports.useMemo(() => {
      const localeCode = fullLocale?.locale;
      if (fullLocale?.exist && !localeCode) {
        return localeValues.locale;
      }
      return localeCode;
    }, [fullLocale]);
    return [getLocale, getLocaleCode];
  };
  const ANT_MARK = "internalMark";
  const LocaleProvider = (props) => {
    const {
      locale: locale2 = {},
      children,
      _ANT_MARK__
    } = props;
    reactExports.useEffect(() => {
      const clearLocale = changeConfirmLocale(locale2?.Modal);
      return clearLocale;
    }, [locale2]);
    const getMemoizedContextValue = reactExports.useMemo(() => ({
      ...locale2,
      exist: true
    }), [locale2]);
    return reactExports.createElement(LocaleContext.Provider, {
      value: getMemoizedContextValue
    }, children);
  };
  function mergeProps$1(...items) {
    const ret = {};
    items.forEach((item) => {
      if (item) {
        Object.keys(item).forEach((key) => {
          if (item[key] !== void 0) {
            ret[key] = item[key];
          }
        });
      }
    });
    return ret;
  }
  const isNonNullable = (val) => {
    return val !== void 0 && val !== null;
  };
  const pickClosable = (context) => {
    if (!context) {
      return void 0;
    }
    const {
      closable,
      closeIcon
    } = context;
    return {
      closable,
      closeIcon
    };
  };
  const EmptyFallbackCloseCollection = {};
  const computeClosableConfig = (closable, closeIcon) => {
    if (!closable && (closable === false || closeIcon === false || closeIcon === null)) {
      return false;
    }
    if (closable === void 0 && closeIcon === void 0) {
      return null;
    }
    let closableConfig = {
      closeIcon: typeof closeIcon !== "boolean" && closeIcon !== null ? closeIcon : void 0
    };
    if (closable && typeof closable === "object") {
      closableConfig = {
        ...closableConfig,
        ...closable
      };
    }
    return closableConfig;
  };
  const mergeClosableConfigs = (propConfig, contextConfig, fallbackConfig) => {
    if (propConfig === false) {
      return false;
    }
    if (propConfig) {
      return mergeProps$1(fallbackConfig, contextConfig, propConfig);
    }
    if (contextConfig === false) {
      return false;
    }
    if (contextConfig) {
      return mergeProps$1(fallbackConfig, contextConfig);
    }
    return fallbackConfig.closable ? fallbackConfig : false;
  };
  const computeCloseIcon = (mergedConfig, fallbackCloseCollection, closeLabel) => {
    const {
      closeIconRender
    } = fallbackCloseCollection;
    const {
      closeIcon,
      ...restConfig
    } = mergedConfig;
    let finalCloseIcon = closeIcon;
    const ariaOrDataProps = pickAttrs(restConfig, true);
    if (isNonNullable(finalCloseIcon)) {
      if (closeIconRender) {
        finalCloseIcon = closeIconRender(finalCloseIcon);
      }
      finalCloseIcon = React.isValidElement(finalCloseIcon) ? React.cloneElement(finalCloseIcon, {
        "aria-label": closeLabel,
        ...finalCloseIcon.props,
        ...ariaOrDataProps
      }) : React.createElement("span", {
        "aria-label": closeLabel,
        ...ariaOrDataProps
      }, finalCloseIcon);
    }
    return [finalCloseIcon, ariaOrDataProps];
  };
  const computeClosable = (propCloseCollection, contextCloseCollection, fallbackCloseCollection = EmptyFallbackCloseCollection, closeLabel = "Close") => {
    const propConfig = computeClosableConfig(propCloseCollection?.closable, propCloseCollection?.closeIcon);
    const contextConfig = computeClosableConfig(contextCloseCollection?.closable, contextCloseCollection?.closeIcon);
    const mergedFallback = {
      closeIcon: React.createElement(RefIcon$k, null),
      ...fallbackCloseCollection
    };
    const mergedConfig = mergeClosableConfigs(propConfig, contextConfig, mergedFallback);
    const closeBtnIsDisabled = typeof mergedConfig !== "boolean" ? !!mergedConfig?.disabled : false;
    if (mergedConfig === false) {
      return [false, null, closeBtnIsDisabled, {}];
    }
    const [closeIcon, ariaProps] = computeCloseIcon(mergedConfig, mergedFallback, closeLabel);
    return [true, closeIcon, closeBtnIsDisabled, ariaProps];
  };
  const useClosable = (propCloseCollection, contextCloseCollection, fallbackCloseCollection = EmptyFallbackCloseCollection) => {
    const [contextLocale] = useLocale("global", localeValues.global);
    return React.useMemo(() => {
      return computeClosable(propCloseCollection, contextCloseCollection, {
        closeIcon: React.createElement(RefIcon$k, null),
        ...fallbackCloseCollection
      }, contextLocale.close);
    }, [propCloseCollection, contextCloseCollection, fallbackCloseCollection, contextLocale.close]);
  };
  const useForceUpdate = () => {
    return React.useReducer((ori) => ori + 1, 0);
  };
  const normalizeMaskConfig = (mask2, maskClosable) => {
    let maskConfig = {};
    if (mask2 && typeof mask2 === "object") {
      maskConfig = mask2;
    }
    if (typeof mask2 === "boolean") {
      maskConfig = {
        enabled: mask2
      };
    }
    if (maskConfig.closable === void 0 && maskClosable !== void 0) {
      maskConfig.closable = maskClosable;
    }
    return maskConfig;
  };
  const useMergedMask = (mask2, contextMask, prefixCls, maskClosable) => {
    return reactExports.useMemo(() => {
      const maskConfig = normalizeMaskConfig(mask2, maskClosable);
      const contextMaskConfig = normalizeMaskConfig(contextMask);
      const mergedConfig = {
        blur: false,
        ...contextMaskConfig,
        ...maskConfig,
        closable: maskConfig.closable ?? maskClosable ?? contextMaskConfig.closable ?? true
      };
      const className = mergedConfig.blur ? `${prefixCls}-mask-blur` : void 0;
      return [mergedConfig.enabled !== false, {
        mask: className
      }, !!mergedConfig.closable];
    }, [mask2, contextMask, prefixCls, maskClosable]);
  };
  const mergeClassNames = (schema, ...classNames) => {
    const mergedSchema = schema || {};
    return classNames.filter(Boolean).reduce((acc, cur) => {
      Object.keys(cur || {}).forEach((key) => {
        const keySchema = mergedSchema[key];
        const curVal = cur[key];
        if (keySchema && typeof keySchema === "object") {
          if (curVal && typeof curVal === "object") {
            acc[key] = mergeClassNames(keySchema, acc[key], curVal);
          } else {
            const {
              _default: defaultField
            } = keySchema;
            if (defaultField) {
              acc[key] = acc[key] || {};
              acc[key][defaultField] = clsx(acc[key][defaultField], curVal);
            }
          }
        } else {
          acc[key] = clsx(acc[key], curVal);
        }
      });
      return acc;
    }, {});
  };
  const useSemanticClassNames = (schema, ...classNames) => {
    return reactExports.useMemo(() => mergeClassNames.apply(void 0, [schema].concat(classNames)), [schema].concat(classNames));
  };
  const mergeStyles = (...styles) => {
    return styles.filter(Boolean).reduce((acc, cur = {}) => {
      Object.keys(cur).forEach((key) => {
        acc[key] = {
          ...acc[key],
          ...cur[key]
        };
      });
      return acc;
    }, {});
  };
  const useSemanticStyles = (...styles) => {
    return reactExports.useMemo(() => mergeStyles.apply(void 0, styles), [].concat(styles));
  };
  const fillObjectBySchema = (obj, schema) => {
    const newObj = {
      ...obj
    };
    Object.keys(schema).forEach((key) => {
      if (key !== "_default") {
        const nestSchema = schema[key];
        const nextValue = newObj[key] || {};
        newObj[key] = nestSchema ? fillObjectBySchema(nextValue, nestSchema) : nextValue;
      }
    });
    return newObj;
  };
  const resolveStyleOrClass = (value, info) => {
    return typeof value === "function" ? value(info) : value;
  };
  const useMergeSemantic = (classNamesList, stylesList, info, schema) => {
    const resolvedClassNamesList = classNamesList.map((classNames) => classNames ? resolveStyleOrClass(classNames, info) : void 0);
    const resolvedStylesList = stylesList.map((styles) => styles ? resolveStyleOrClass(styles, info) : void 0);
    const mergedClassNames = useSemanticClassNames.apply(void 0, [schema].concat(_toConsumableArray(resolvedClassNamesList)));
    const mergedStyles = useSemanticStyles.apply(void 0, _toConsumableArray(resolvedStylesList));
    return reactExports.useMemo(() => {
      if (!schema) {
        return [mergedClassNames, mergedStyles];
      }
      return [fillObjectBySchema(mergedClassNames, schema), fillObjectBySchema(mergedStyles, schema)];
    }, [mergedClassNames, mergedStyles, schema]);
  };
  const useMultipleSelect = (getKey2) => {
    const [prevSelectedIndex, setPrevSelectedIndex] = reactExports.useState(null);
    const multipleSelect = reactExports.useCallback((currentSelectedIndex, data2, selectedKeys) => {
      const configPrevSelectedIndex = prevSelectedIndex ?? currentSelectedIndex;
      const startIndex = Math.min(configPrevSelectedIndex || 0, currentSelectedIndex);
      const endIndex = Math.max(configPrevSelectedIndex || 0, currentSelectedIndex);
      const rangeKeys = data2.slice(startIndex, endIndex + 1).map(getKey2);
      const shouldSelected = rangeKeys.some((rangeKey) => !selectedKeys.has(rangeKey));
      const changedKeys = [];
      rangeKeys.forEach((item) => {
        if (shouldSelected) {
          if (!selectedKeys.has(item)) {
            changedKeys.push(item);
          }
          selectedKeys.add(item);
        } else {
          selectedKeys.delete(item);
          changedKeys.push(item);
        }
      });
      setPrevSelectedIndex(shouldSelected ? endIndex : null);
      return changedKeys;
    }, [prevSelectedIndex]);
    return [multipleSelect, setPrevSelectedIndex];
  };
  const isValidOrientation = (orientation) => {
    return orientation === "horizontal" || orientation === "vertical";
  };
  const useOrientation = (orientation, vertical, legacyDirection) => {
    return reactExports.useMemo(() => {
      const validOrientation = isValidOrientation(orientation);
      let mergedOrientation;
      if (validOrientation) {
        mergedOrientation = orientation;
      } else if (typeof vertical === "boolean") {
        mergedOrientation = vertical ? "vertical" : "horizontal";
      } else {
        const validLegacyDirection = isValidOrientation(legacyDirection);
        mergedOrientation = validLegacyDirection ? legacyDirection : "horizontal";
      }
      return [mergedOrientation, mergedOrientation === "vertical"];
    }, [legacyDirection, orientation, vertical]);
  };
  const usePatchElement = () => {
    const [elements, setElements] = reactExports.useState([]);
    const patchElement = reactExports.useCallback((element) => {
      setElements((originElements) => [].concat(_toConsumableArray(originElements), [element]));
      return () => {
        setElements((originElements) => originElements.filter((ele) => ele !== element));
      };
    }, []);
    return [elements, patchElement];
  };
  const ZIndexContext = React.createContext(void 0);
  const CONTAINER_OFFSET = 100;
  const CONTAINER_OFFSET_MAX_COUNT = 10;
  const CONTAINER_MAX_OFFSET = CONTAINER_OFFSET * CONTAINER_OFFSET_MAX_COUNT;
  const containerBaseZIndexOffset = {
    Modal: CONTAINER_OFFSET,
    Drawer: CONTAINER_OFFSET,
    Popover: CONTAINER_OFFSET,
    Popconfirm: CONTAINER_OFFSET,
    Tooltip: CONTAINER_OFFSET,
    Tour: CONTAINER_OFFSET,
    FloatButton: CONTAINER_OFFSET
  };
  const consumerBaseZIndexOffset = {
    SelectLike: 50,
    Dropdown: 50,
    DatePicker: 50,
    Menu: 50,
    ImagePreview: 1
  };
  const isContainerType = (type4) => {
    return type4 in containerBaseZIndexOffset;
  };
  const useZIndex = (componentType, customZIndex) => {
    const [, token2] = useToken$1();
    const parentZIndex = React.useContext(ZIndexContext);
    const isContainer = isContainerType(componentType);
    let result;
    if (customZIndex !== void 0) {
      result = [customZIndex, customZIndex];
    } else {
      let zIndex = parentZIndex ?? 0;
      if (isContainer) {
        zIndex +=
(parentZIndex ? 0 : token2.zIndexPopupBase) +
containerBaseZIndexOffset[componentType];
      } else {
        zIndex += consumerBaseZIndexOffset[componentType];
      }
      result = [parentZIndex === void 0 ? customZIndex : zIndex, zIndex];
    }
    return result;
  };
  function isWindow$1(obj) {
    return isNonNullable(obj) && obj === obj.window;
  }
  const getScroll$1 = (target) => {
    if (typeof window === "undefined") {
      return 0;
    }
    let result = 0;
    if (isWindow$1(target)) {
      result = target.pageYOffset;
    } else if (target instanceof Document) {
      result = target.documentElement.scrollTop;
    } else if (target instanceof HTMLElement) {
      result = target.scrollTop;
    } else if (target) {
      result = target["scrollTop"];
    }
    if (target && !isWindow$1(target) && typeof result !== "number") {
      result = (target.ownerDocument ?? target).documentElement?.scrollTop;
    }
    return result;
  };
  function easeInOutCubic(t2, b, c2, d2) {
    const cc = c2 - b;
    t2 /= d2 / 2;
    if (t2 < 1) {
      return cc / 2 * t2 * t2 * t2 + b;
    }
    return cc / 2 * ((t2 -= 2) * t2 * t2 + 2) + b;
  }
  function scrollTo(y, options = {}) {
    const {
      getContainer: getContainer2 = () => window,
      callback,
      duration: duration2 = 450
    } = options;
    const container = getContainer2();
    const scrollTop = getScroll$1(container);
    const startTime = Date.now();
    let rafId;
    const frameFunc = () => {
      const timestamp = Date.now();
      const time2 = timestamp - startTime;
      const nextScrollTop = easeInOutCubic(time2 > duration2 ? duration2 : time2, scrollTop, y, duration2);
      if (isWindow$1(container)) {
        container.scrollTo(window.pageXOffset, nextScrollTop);
      } else if (container instanceof Document || container.constructor.name === "HTMLDocument") {
        container.documentElement.scrollTop = nextScrollTop;
      } else {
        container.scrollTop = nextScrollTop;
      }
      if (time2 < duration2) {
        rafId = wrapperRaf(frameFunc);
      } else if (typeof callback === "function") {
        callback();
      }
    };
    rafId = wrapperRaf(frameFunc);
    return () => {
      wrapperRaf.cancel(rafId);
    };
  }
  const useCSSVarCls = (prefixCls) => `${prefixCls}-css-var`;
  const ValidateMessagesContext = reactExports.createContext(void 0);
  var reactDom = { exports: {} };
  var reactDom_production = {};
  var hasRequiredReactDom_production;
  function requireReactDom_production() {
    if (hasRequiredReactDom_production) return reactDom_production;
    hasRequiredReactDom_production = 1;
    var React2 = requireReact();
    function formatProdErrorMessage(code) {
      var url2 = "https://react.dev/errors/" + code;
      if (1 < arguments.length) {
        url2 += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var i2 = 2; i2 < arguments.length; i2++)
          url2 += "&args[]=" + encodeURIComponent(arguments[i2]);
      }
      return "Minified React error #" + code + "; visit " + url2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function noop2() {
    }
    var Internals = {
      d: {
        f: noop2,
        r: function() {
          throw Error(formatProdErrorMessage(522));
        },
        D: noop2,
        C: noop2,
        L: noop2,
        m: noop2,
        X: noop2,
        S: noop2,
        M: noop2
      },
      p: 0,
      findDOMNode: null
    }, REACT_PORTAL_TYPE = Symbol.for("react.portal");
    function createPortal$1(children, containerInfo, implementation) {
      var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: null == key ? null : "" + key,
        children,
        containerInfo,
        implementation
      };
    }
    var ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function getCrossOriginStringAs(as, input) {
      if ("font" === as) return "";
      if ("string" === typeof input)
        return "use-credentials" === input ? input : "";
    }
    reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
    reactDom_production.createPortal = function(children, container) {
      var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
        throw Error(formatProdErrorMessage(299));
      return createPortal$1(children, container, null, key);
    };
    reactDom_production.flushSync = function(fn) {
      var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
      try {
        if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
      } finally {
        ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
      }
    };
    reactDom_production.preconnect = function(href, options) {
      "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
    };
    reactDom_production.prefetchDNS = function(href) {
      "string" === typeof href && Internals.d.D(href);
    };
    reactDom_production.preinit = function(href, options) {
      if ("string" === typeof href && options && "string" === typeof options.as) {
        var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
        "style" === as ? Internals.d.S(
          href,
          "string" === typeof options.precedence ? options.precedence : void 0,
          {
            crossOrigin,
            integrity,
            fetchPriority
          }
        ) : "script" === as && Internals.d.X(href, {
          crossOrigin,
          integrity,
          fetchPriority,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      }
    };
    reactDom_production.preinitModule = function(href, options) {
      if ("string" === typeof href)
        if ("object" === typeof options && null !== options) {
          if (null == options.as || "script" === options.as) {
            var crossOrigin = getCrossOriginStringAs(
              options.as,
              options.crossOrigin
            );
            Internals.d.M(href, {
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
          }
        } else null == options && Internals.d.M(href);
    };
    reactDom_production.preload = function(href, options) {
      if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
        var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
        Internals.d.L(href, as, {
          crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0,
          type: "string" === typeof options.type ? options.type : void 0,
          fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
          referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
          imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
          imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
          media: "string" === typeof options.media ? options.media : void 0
        });
      }
    };
    reactDom_production.preloadModule = function(href, options) {
      if ("string" === typeof href)
        if (options) {
          var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
          Internals.d.m(href, {
            as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0
          });
        } else Internals.d.m(href);
    };
    reactDom_production.requestFormReset = function(form) {
      Internals.d.r(form);
    };
    reactDom_production.unstable_batchedUpdates = function(fn, a2) {
      return fn(a2);
    };
    reactDom_production.useFormState = function(action2, initialState, permalink) {
      return ReactSharedInternals.H.useFormState(action2, initialState, permalink);
    };
    reactDom_production.useFormStatus = function() {
      return ReactSharedInternals.H.useHostTransitionStatus();
    };
    reactDom_production.version = "19.2.4";
    return reactDom_production;
  }
  var hasRequiredReactDom;
  function requireReactDom() {
    if (hasRequiredReactDom) return reactDom.exports;
    hasRequiredReactDom = 1;
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    {
      checkDCE();
      reactDom.exports = requireReactDom_production();
    }
    return reactDom.exports;
  }
  var reactDomExports = requireReactDom();
  const OrderContext = reactExports.createContext(null);
  let inline = false;
  function inlineMock(nextInline) {
    return inline;
  }
  const EMPTY_LIST$1 = [];
  function useDom(render4, debug2) {
    const [ele] = reactExports.useState(() => {
      if (!canUseDom()) {
        return null;
      }
      const defaultEle = document.createElement("div");
      return defaultEle;
    });
    const appendedRef = reactExports.useRef(false);
    const queueCreate = reactExports.useContext(OrderContext);
    const [queue, setQueue] = reactExports.useState(EMPTY_LIST$1);
    const mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : (appendFn) => {
      setQueue((origin) => {
        const newQueue = [appendFn, ...origin];
        return newQueue;
      });
    });
    function append2() {
      if (!ele.parentElement) {
        document.body.appendChild(ele);
      }
      appendedRef.current = true;
    }
    function cleanup2() {
      ele.parentElement?.removeChild(ele);
      appendedRef.current = false;
    }
    useLayoutEffect(() => {
      if (render4) {
        if (queueCreate) {
          queueCreate(append2);
        } else {
          append2();
        }
      } else {
        cleanup2();
      }
      return cleanup2;
    }, [render4]);
    useLayoutEffect(() => {
      if (queue.length) {
        queue.forEach((appendFn) => appendFn());
        setQueue(EMPTY_LIST$1);
      }
    }, [queue]);
    return [ele, mergedQueueCreate];
  }
  function measureScrollbarSize(ele) {
    const randomId = `rc-scrollbar-measure-${Math.random().toString(36).substring(7)}`;
    const measureEle = document.createElement("div");
    measureEle.id = randomId;
    const measureStyle = measureEle.style;
    measureStyle.position = "absolute";
    measureStyle.left = "0";
    measureStyle.top = "0";
    measureStyle.width = "100px";
    measureStyle.height = "100px";
    measureStyle.overflow = "scroll";
    let fallbackWidth;
    let fallbackHeight;
    if (ele) {
      const targetStyle = getComputedStyle(ele);
      measureStyle.scrollbarColor = targetStyle.scrollbarColor;
      measureStyle.scrollbarWidth = targetStyle.scrollbarWidth;
      const webkitScrollbarStyle = getComputedStyle(ele, "::-webkit-scrollbar");
      const width = parseInt(webkitScrollbarStyle.width, 10);
      const height = parseInt(webkitScrollbarStyle.height, 10);
      try {
        const widthStyle = width ? `width: ${webkitScrollbarStyle.width};` : "";
        const heightStyle = height ? `height: ${webkitScrollbarStyle.height};` : "";
        updateCSS(`
#${randomId}::-webkit-scrollbar {
${widthStyle}
${heightStyle}
}`, randomId);
      } catch (e) {
        console.error(e);
        fallbackWidth = width;
        fallbackHeight = height;
      }
    }
    document.body.appendChild(measureEle);
    const scrollWidth = ele && fallbackWidth && !isNaN(fallbackWidth) ? fallbackWidth : measureEle.offsetWidth - measureEle.clientWidth;
    const scrollHeight = ele && fallbackHeight && !isNaN(fallbackHeight) ? fallbackHeight : measureEle.offsetHeight - measureEle.clientHeight;
    document.body.removeChild(measureEle);
    removeCSS(randomId);
    return {
      width: scrollWidth,
      height: scrollHeight
    };
  }
  function getTargetScrollBarSize(target) {
    if (typeof document === "undefined" || !target || !(target instanceof Element)) {
      return {
        width: 0,
        height: 0
      };
    }
    return measureScrollbarSize(target);
  }
  function isBodyOverflowing() {
    return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
  }
  const UNIQUE_ID = `rc-util-locker-${Date.now()}`;
  let uuid$3 = 0;
  function useScrollLocker(lock) {
    const mergedLock = !!lock;
    const [id2] = reactExports.useState(() => {
      uuid$3 += 1;
      return `${UNIQUE_ID}_${uuid$3}`;
    });
    useLayoutEffect(() => {
      if (mergedLock) {
        const scrollbarSize = getTargetScrollBarSize(document.body).width;
        const isOverflow = isBodyOverflowing();
        updateCSS(`
html body {
  overflow-y: hidden;
  ${isOverflow ? `width: calc(100% - ${scrollbarSize}px);` : ""}
}`, id2);
      } else {
        removeCSS(id2);
      }
      return () => {
        removeCSS(id2);
      };
    }, [mergedLock, id2]);
  }
  function getUseId() {
    const fullClone = {
      ...React3
    };
    return fullClone.useId;
  }
  let uuid$2 = 0;
  const useOriginId = getUseId();
  const useId = useOriginId ? (
(function useId2(id2) {
      const reactId = useOriginId();
      if (id2) {
        return id2;
      }
      return reactId;
    })
  ) : (
(function useCompatId(id2) {
      const [innerId, setInnerId] = reactExports.useState("ssr-id");
      reactExports.useEffect(() => {
        const nextId = uuid$2;
        uuid$2 += 1;
        setInnerId(`rc_unique_${nextId}`);
      }, []);
      if (id2) {
        return id2;
      }
      return innerId;
    })
  );
  let stack = [];
  const IME_LOCK_DURATION = 200;
  let lastCompositionEndTime = 0;
  const onGlobalKeyDown = (event) => {
    if (event.key === "Escape" && !event.isComposing) {
      const now2 = Date.now();
      if (now2 - lastCompositionEndTime < IME_LOCK_DURATION) {
        return;
      }
      const len = stack.length;
      for (let i2 = len - 1; i2 >= 0; i2 -= 1) {
        stack[i2].onEsc({
          top: i2 === len - 1,
          event
        });
      }
    }
  };
  const onGlobalCompositionEnd = () => {
    lastCompositionEndTime = Date.now();
  };
  function attachGlobalEventListeners() {
    window.addEventListener("keydown", onGlobalKeyDown);
    window.addEventListener("compositionend", onGlobalCompositionEnd);
  }
  function detachGlobalEventListeners() {
    if (stack.length === 0) {
      window.removeEventListener("keydown", onGlobalKeyDown);
      window.removeEventListener("compositionend", onGlobalCompositionEnd);
    }
  }
  function useEscKeyDown(open2, onEsc) {
    const id2 = useId();
    const onEventEsc = useEvent$1(onEsc);
    const ensure = () => {
      if (!stack.find((item) => item.id === id2)) {
        stack.push({
          id: id2,
          onEsc: onEventEsc
        });
      }
    };
    const clear = () => {
      stack = stack.filter((item) => item.id !== id2);
    };
    reactExports.useMemo(() => {
      if (open2) {
        ensure();
      } else if (!open2) {
        clear();
      }
    }, [open2]);
    reactExports.useEffect(() => {
      if (open2) {
        ensure();
        attachGlobalEventListeners();
        return () => {
          clear();
          detachGlobalEventListeners();
        };
      }
    }, [open2]);
  }
  const getPortalContainer = (getContainer2) => {
    if (getContainer2 === false) {
      return false;
    }
    if (!canUseDom() || !getContainer2) {
      return null;
    }
    if (typeof getContainer2 === "string") {
      return document.querySelector(getContainer2);
    }
    if (typeof getContainer2 === "function") {
      return getContainer2();
    }
    return getContainer2;
  };
  const Portal = reactExports.forwardRef((props, ref2) => {
    const {
      open: open2,
      autoLock,
      getContainer: getContainer2,
      debug: debug2,
      autoDestroy = true,
      children,
      onEsc
    } = props;
    const [shouldRender, setShouldRender] = reactExports.useState(open2);
    const mergedRender = shouldRender || open2;
    reactExports.useEffect(() => {
      if (autoDestroy || open2) {
        setShouldRender(open2);
      }
    }, [open2, autoDestroy]);
    const [innerContainer, setInnerContainer] = reactExports.useState(() => getPortalContainer(getContainer2));
    reactExports.useEffect(() => {
      const customizeContainer = getPortalContainer(getContainer2);
      setInnerContainer(() => (

customizeContainer ?? null
      ));
    });
    const [defaultContainer, queueCreate] = useDom(mergedRender && !innerContainer);
    const mergedContainer = innerContainer ?? defaultContainer;
    useScrollLocker(autoLock && open2 && canUseDom() && (mergedContainer === defaultContainer || mergedContainer === document.body));
    useEscKeyDown(open2, onEsc);
    let childRef = null;
    if (children && supportRef(children) && ref2) {
      childRef = getNodeRef(children);
    }
    const mergedRef = useComposeRef(childRef, ref2);
    if (!mergedRender || !canUseDom() || innerContainer === void 0) {
      return null;
    }
    const renderInline = mergedContainer === false || inlineMock();
    let reffedChildren = children;
    if (ref2) {
      reffedChildren = reactExports.cloneElement(children, {
        ref: mergedRef
      });
    }
    return reactExports.createElement(OrderContext.Provider, {
      value: queueCreate
    }, renderInline ? reffedChildren : reactDomExports.createPortal(reffedChildren, mergedContainer));
  });
  function Arrow(props) {
    const {
      prefixCls,
      align,
      arrow,
      arrowPos
    } = props;
    const {
      className,
      content,
      style: style2
    } = arrow || {};
    const {
      x = 0,
      y = 0
    } = arrowPos;
    const arrowRef = reactExports.useRef(null);
    if (!align || !align.points) {
      return null;
    }
    const alignStyle = {
      position: "absolute"
    };
    if (align.autoArrow !== false) {
      const popupPoints = align.points[0];
      const targetPoints = align.points[1];
      const popupTB = popupPoints[0];
      const popupLR = popupPoints[1];
      const targetTB = targetPoints[0];
      const targetLR = targetPoints[1];
      if (popupTB === targetTB || !["t", "b"].includes(popupTB)) {
        alignStyle.top = y;
      } else if (popupTB === "t") {
        alignStyle.top = 0;
      } else {
        alignStyle.bottom = 0;
      }
      if (popupLR === targetLR || !["l", "r"].includes(popupLR)) {
        alignStyle.left = x;
      } else if (popupLR === "l") {
        alignStyle.left = 0;
      } else {
        alignStyle.right = 0;
      }
    }
    return reactExports.createElement("div", {
      ref: arrowRef,
      className: clsx(`${prefixCls}-arrow`, className),
      style: {
        ...alignStyle,
        ...style2
      }
    }, content);
  }
  function _extends$Y() {
    _extends$Y = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$Y.apply(this, arguments);
  }
  function Mask$1(props) {
    const {
      prefixCls,
      open: open2,
      zIndex,
      mask: mask2,
      motion: motion2,
      mobile
    } = props;
    if (!mask2) {
      return null;
    }
    return reactExports.createElement(CSSMotion, _extends$Y({}, motion2, {
      motionAppear: true,
      visible: open2,
      removeOnLeave: true
    }), ({
      className
    }) => reactExports.createElement("div", {
      style: {
        zIndex
      },
      className: clsx(`${prefixCls}-mask`, mobile && `${prefixCls}-mobile-mask`, className)
    }));
  }
  const PopupContent = reactExports.memo(({
    children
  }) => children, (_2, next2) => next2.cache);
  function useOffsetStyle(isMobile2, ready, open2, align, offsetR, offsetB, offsetX, offsetY) {
    const AUTO = "auto";
    const offsetStyle = isMobile2 ? {} : {
      left: "-1000vw",
      top: "-1000vh",
      right: AUTO,
      bottom: AUTO
    };
    if (!isMobile2 && (ready || !open2)) {
      const {
        points
      } = align;
      const dynamicInset = align.dynamicInset || align._experimental?.dynamicInset;
      const alignRight = dynamicInset && points[0][1] === "r";
      const alignBottom = dynamicInset && points[0][0] === "b";
      if (alignRight) {
        offsetStyle.right = offsetR;
        offsetStyle.left = AUTO;
      } else {
        offsetStyle.left = offsetX;
        offsetStyle.right = AUTO;
      }
      if (alignBottom) {
        offsetStyle.bottom = offsetB;
        offsetStyle.top = AUTO;
      } else {
        offsetStyle.top = offsetY;
        offsetStyle.bottom = AUTO;
      }
    }
    return offsetStyle;
  }
  function _extends$X() {
    _extends$X = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$X.apply(this, arguments);
  }
  const Popup$1 = reactExports.forwardRef((props, ref2) => {
    const {
      onEsc,
      popup,
      className,
      prefixCls,
      style: style2,
      target,
      onVisibleChanged,
open: open2,
      keepDom,
      fresh,
onClick,
mask: mask2,
arrow,
      arrowPos,
      align,
motion: motion2,
      maskMotion,
mobile,
forceRender,
      getPopupContainer,
      autoDestroy,
      portal: Portal2,
      children,
      zIndex,
      onMouseEnter,
      onMouseLeave,
      onPointerEnter,
      onPointerDownCapture,
      ready,
      offsetX,
      offsetY,
      offsetR,
      offsetB,
      onAlign,
      onPrepare,
onResize: onResize2,
      stretch,
      targetWidth,
      targetHeight
    } = props;
    const popupContent = typeof popup === "function" ? popup() : popup;
    const isNodeVisible = open2 || keepDom;
    const isMobile2 = !!mobile;
    const [mergedMask, mergedMaskMotion, mergedPopupMotion] = reactExports.useMemo(() => {
      if (mobile) {
        return [mobile.mask, mobile.maskMotion, mobile.motion];
      }
      return [mask2, maskMotion, motion2];
    }, [mobile, mask2, maskMotion, motion2]);
    const getPopupContainerNeedParams = getPopupContainer?.length > 0;
    const [show, setShow] = reactExports.useState(!getPopupContainer || !getPopupContainerNeedParams);
    useLayoutEffect(() => {
      if (!show && getPopupContainerNeedParams && target) {
        setShow(true);
      }
    }, [show, getPopupContainerNeedParams, target]);
    const onInternalResize = useEvent$1((size, ele) => {
      onResize2?.(size, ele);
      onAlign();
    });
    const offsetStyle = useOffsetStyle(isMobile2, ready, open2, align, offsetR, offsetB, offsetX, offsetY);
    if (!show) {
      return null;
    }
    const miscStyle = {};
    if (stretch) {
      if (stretch.includes("height") && targetHeight) {
        miscStyle.height = targetHeight;
      } else if (stretch.includes("minHeight") && targetHeight) {
        miscStyle.minHeight = targetHeight;
      }
      if (stretch.includes("width") && targetWidth) {
        miscStyle.width = targetWidth;
      } else if (stretch.includes("minWidth") && targetWidth) {
        miscStyle.minWidth = targetWidth;
      }
    }
    if (!open2) {
      miscStyle.pointerEvents = "none";
    }
    return reactExports.createElement(Portal2, {
      open: forceRender || isNodeVisible,
      getContainer: getPopupContainer && (() => getPopupContainer(target)),
      autoDestroy,
      onEsc
    }, reactExports.createElement(Mask$1, {
      prefixCls,
      open: open2,
      zIndex,
      mask: mergedMask,
      motion: mergedMaskMotion,
      mobile: isMobile2
    }), reactExports.createElement(RefResizeObserver, {
      onResize: onInternalResize,
      disabled: !open2
    }, (resizeObserverRef) => {
      return reactExports.createElement(CSSMotion, _extends$X({
        motionAppear: true,
        motionEnter: true,
        motionLeave: true,
        removeOnLeave: false,
        forceRender,
        leavedClassName: `${prefixCls}-hidden`
      }, mergedPopupMotion, {
        onAppearPrepare: onPrepare,
        onEnterPrepare: onPrepare,
        visible: open2,
        onVisibleChanged: (nextVisible) => {
          motion2?.onVisibleChanged?.(nextVisible);
          onVisibleChanged(nextVisible);
        }
      }), ({
        className: motionClassName,
        style: motionStyle
      }, motionRef) => {
        const cls = clsx(prefixCls, motionClassName, className, {
          [`${prefixCls}-mobile`]: isMobile2
        });
        return reactExports.createElement("div", {
          ref: composeRef(resizeObserverRef, ref2, motionRef),
          className: cls,
          style: {
            "--arrow-x": `${arrowPos.x || 0}px`,
            "--arrow-y": `${arrowPos.y || 0}px`,
            ...offsetStyle,
            ...miscStyle,
            ...motionStyle,
            boxSizing: "border-box",
            zIndex,
            ...style2
          },
          onMouseEnter,
          onMouseLeave,
          onPointerEnter,
          onClick,
          onPointerDownCapture
        }, arrow && reactExports.createElement(Arrow, {
          prefixCls,
          arrow,
          arrowPos,
          align
        }), reactExports.createElement(PopupContent, {
          cache: !open2 && !fresh
        }, popupContent));
      });
    }), children);
  });
  const TriggerContext = reactExports.createContext(null);
  const UniqueContext = reactExports.createContext(null);
  function toArray$3(val) {
    return val ? Array.isArray(val) ? val : [val] : [];
  }
  function useAction(action2, showAction, hideAction) {
    return reactExports.useMemo(() => {
      const mergedShowAction = toArray$3(showAction ?? action2);
      const mergedHideAction = toArray$3(hideAction ?? action2);
      const showActionSet = new Set(mergedShowAction);
      const hideActionSet = new Set(mergedHideAction);
      if (showActionSet.has("hover") && !showActionSet.has("click")) {
        showActionSet.add("touch");
      }
      if (hideActionSet.has("hover") && !hideActionSet.has("click")) {
        hideActionSet.add("touch");
      }
      return [showActionSet, hideActionSet];
    }, [action2, showAction, hideAction]);
  }
  const isVisible = ((element) => {
    if (!element) {
      return false;
    }
    if (element instanceof Element) {
      if (element.offsetParent) {
        return true;
      }
      if (element.getBBox) {
        const {
          width,
          height
        } = element.getBBox();
        if (width || height) {
          return true;
        }
      }
      if (element.getBoundingClientRect) {
        const {
          width,
          height
        } = element.getBoundingClientRect();
        if (width || height) {
          return true;
        }
      }
    }
    return false;
  });
  function isPointsEq(a1 = [], a2 = [], isAlignPoint) {
    const getVal = (a3, index) => a3[index] || "";
    if (isAlignPoint) {
      return getVal(a1, 0) === getVal(a2, 0);
    }
    return getVal(a1, 0) === getVal(a2, 0) && getVal(a1, 1) === getVal(a2, 1);
  }
  function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
    const {
      points
    } = align;
    const placements2 = Object.keys(builtinPlacements);
    for (let i2 = 0; i2 < placements2.length; i2 += 1) {
      const placement = placements2[i2];
      if (isPointsEq(builtinPlacements[placement]?.points, points, isAlignPoint)) {
        return `${prefixCls}-placement-${placement}`;
      }
    }
    return "";
  }
  function getWin(ele) {
    return ele.ownerDocument.defaultView;
  }
  function collectScroller(ele) {
    const scrollerList = [];
    let current = ele?.parentElement;
    const scrollStyle = ["hidden", "scroll", "clip", "auto"];
    while (current) {
      const {
        overflowX,
        overflowY,
        overflow
      } = getWin(current).getComputedStyle(current);
      if ([overflowX, overflowY, overflow].some((o2) => scrollStyle.includes(o2))) {
        scrollerList.push(current);
      }
      current = current.parentElement;
    }
    return scrollerList;
  }
  function toNum(num, defaultValue2 = 1) {
    return Number.isNaN(num) ? defaultValue2 : num;
  }
  function getPxValue(val) {
    return toNum(parseFloat(val), 0);
  }
  function getVisibleArea(initArea, scrollerList) {
    const visibleArea = {
      ...initArea
    };
    (scrollerList || []).forEach((ele) => {
      if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) {
        return;
      }
      const {
        overflow,
        overflowClipMargin,
        borderTopWidth,
        borderBottomWidth,
        borderLeftWidth,
        borderRightWidth
      } = getWin(ele).getComputedStyle(ele);
      const eleRect = ele.getBoundingClientRect();
      const {
        offsetHeight: eleOutHeight,
        clientHeight: eleInnerHeight,
        offsetWidth: eleOutWidth,
        clientWidth: eleInnerWidth
      } = ele;
      const borderTopNum = getPxValue(borderTopWidth);
      const borderBottomNum = getPxValue(borderBottomWidth);
      const borderLeftNum = getPxValue(borderLeftWidth);
      const borderRightNum = getPxValue(borderRightWidth);
      const scaleX2 = toNum(Math.round(eleRect.width / eleOutWidth * 1e3) / 1e3);
      const scaleY2 = toNum(Math.round(eleRect.height / eleOutHeight * 1e3) / 1e3);
      const eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX2;
      const eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY2;
      const scaledBorderTopWidth = borderTopNum * scaleY2;
      const scaledBorderBottomWidth = borderBottomNum * scaleY2;
      const scaledBorderLeftWidth = borderLeftNum * scaleX2;
      const scaledBorderRightWidth = borderRightNum * scaleX2;
      let clipMarginWidth = 0;
      let clipMarginHeight = 0;
      if (overflow === "clip") {
        const clipNum = getPxValue(overflowClipMargin);
        clipMarginWidth = clipNum * scaleX2;
        clipMarginHeight = clipNum * scaleY2;
      }
      const eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;
      const eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;
      const eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;
      const eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;
      visibleArea.left = Math.max(visibleArea.left, eleLeft);
      visibleArea.top = Math.max(visibleArea.top, eleTop);
      visibleArea.right = Math.min(visibleArea.right, eleRight);
      visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
    });
    return visibleArea;
  }
  function getUnitOffset(size, offset2 = 0) {
    const offsetStr = `${offset2}`;
    const cells = offsetStr.match(/^(.*)\%$/);
    if (cells) {
      return size * (parseFloat(cells[1]) / 100);
    }
    return parseFloat(offsetStr);
  }
  function getNumberOffset(rect, offset2) {
    const [offsetX, offsetY] = offset2 || [];
    return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];
  }
  function splitPoints(points = "") {
    return [points[0], points[1]];
  }
  function getAlignPoint(rect, points) {
    const topBottom = points[0];
    const leftRight = points[1];
    let x;
    let y;
    if (topBottom === "t") {
      y = rect.y;
    } else if (topBottom === "b") {
      y = rect.y + rect.height;
    } else {
      y = rect.y + rect.height / 2;
    }
    if (leftRight === "l") {
      x = rect.x;
    } else if (leftRight === "r") {
      x = rect.x + rect.width;
    } else {
      x = rect.x + rect.width / 2;
    }
    return {
      x,
      y
    };
  }
  function reversePoints(points, index) {
    const reverseMap = {
      t: "b",
      b: "t",
      l: "r",
      r: "l"
    };
    const clone2 = [...points];
    clone2[index] = reverseMap[points[index]] || "c";
    return clone2;
  }
  function flatPoints(points) {
    return points.join("");
  }
  function useAlign(open2, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign, mobile) {
    const [offsetInfo, setOffsetInfo] = reactExports.useState({
      ready: false,
      offsetX: 0,
      offsetY: 0,
      offsetR: 0,
      offsetB: 0,
      arrowX: 0,
      arrowY: 0,
      scaleX: 1,
      scaleY: 1,
      align: builtinPlacements[placement] || {}
    });
    const alignCountRef = reactExports.useRef(0);
    const scrollerList = reactExports.useMemo(() => {
      if (!popupEle || mobile) {
        return [];
      }
      return collectScroller(popupEle);
    }, [popupEle]);
    const prevFlipRef = reactExports.useRef({});
    const resetFlipCache = () => {
      prevFlipRef.current = {};
    };
    if (!open2) {
      resetFlipCache();
    }
    const onAlign = useEvent$1(() => {
      if (popupEle && target && open2 && !mobile) {
        let getIntersectionVisibleArea = function(offsetX, offsetY, area = visibleArea) {
          const l2 = popupRect.x + offsetX;
          const t2 = popupRect.y + offsetY;
          const r2 = l2 + popupWidth;
          const b = t2 + popupHeight;
          const visibleL = Math.max(l2, area.left);
          const visibleT = Math.max(t2, area.top);
          const visibleR = Math.min(r2, area.right);
          const visibleB = Math.min(b, area.bottom);
          return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));
        }, syncNextPopupPosition = function() {
          nextPopupY = popupRect.y + nextOffsetY;
          nextPopupBottom = nextPopupY + popupHeight;
          nextPopupX = popupRect.x + nextOffsetX;
          nextPopupRight = nextPopupX + popupWidth;
        };
        const popupElement = popupEle;
        const doc = popupElement.ownerDocument;
        const win2 = getWin(popupElement);
        const {
          position: popupPosition
        } = win2.getComputedStyle(popupElement);
        const originLeft = popupElement.style.left;
        const originTop = popupElement.style.top;
        const originRight = popupElement.style.right;
        const originBottom = popupElement.style.bottom;
        const originOverflow = popupElement.style.overflow;
        const placementInfo = {
          ...builtinPlacements[placement],
          ...popupAlign
        };
        const placeholderElement = doc.createElement("div");
        popupElement.parentElement?.appendChild(placeholderElement);
        placeholderElement.style.left = `${popupElement.offsetLeft}px`;
        placeholderElement.style.top = `${popupElement.offsetTop}px`;
        placeholderElement.style.position = popupPosition;
        placeholderElement.style.height = `${popupElement.offsetHeight}px`;
        placeholderElement.style.width = `${popupElement.offsetWidth}px`;
        popupElement.style.left = "0";
        popupElement.style.top = "0";
        popupElement.style.right = "auto";
        popupElement.style.bottom = "auto";
        popupElement.style.overflow = "hidden";
        let targetRect;
        if (Array.isArray(target)) {
          targetRect = {
            x: target[0],
            y: target[1],
            width: 0,
            height: 0
          };
        } else {
          const rect = target.getBoundingClientRect();
          rect.x = rect.x ?? rect.left;
          rect.y = rect.y ?? rect.top;
          targetRect = {
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height
          };
        }
        const popupRect = popupElement.getBoundingClientRect();
        const {
          height,
          width
        } = win2.getComputedStyle(popupElement);
        popupRect.x = popupRect.x ?? popupRect.left;
        popupRect.y = popupRect.y ?? popupRect.top;
        const {
          clientWidth,
          clientHeight,
          scrollWidth,
          scrollHeight,
          scrollTop,
          scrollLeft
        } = doc.documentElement;
        const popupHeight = popupRect.height;
        const popupWidth = popupRect.width;
        const targetHeight = targetRect.height;
        const targetWidth = targetRect.width;
        const visibleRegion = {
          left: 0,
          top: 0,
          right: clientWidth,
          bottom: clientHeight
        };
        const scrollRegion = {
          left: -scrollLeft,
          top: -scrollTop,
          right: scrollWidth - scrollLeft,
          bottom: scrollHeight - scrollTop
        };
        let {
          htmlRegion
        } = placementInfo;
        const VISIBLE = "visible";
        const VISIBLE_FIRST = "visibleFirst";
        if (htmlRegion !== "scroll" && htmlRegion !== VISIBLE_FIRST) {
          htmlRegion = VISIBLE;
        }
        const isVisibleFirst = htmlRegion === VISIBLE_FIRST;
        const scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);
        const visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);
        const visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;
        const adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;
        popupElement.style.left = "auto";
        popupElement.style.top = "auto";
        popupElement.style.right = "0";
        popupElement.style.bottom = "0";
        const popupMirrorRect = popupElement.getBoundingClientRect();
        popupElement.style.left = originLeft;
        popupElement.style.top = originTop;
        popupElement.style.right = originRight;
        popupElement.style.bottom = originBottom;
        popupElement.style.overflow = originOverflow;
        popupElement.parentElement?.removeChild(placeholderElement);
        const scaleX2 = toNum(Math.round(popupWidth / parseFloat(width) * 1e3) / 1e3);
        const scaleY2 = toNum(Math.round(popupHeight / parseFloat(height) * 1e3) / 1e3);
        if (scaleX2 === 0 || scaleY2 === 0 || isDOM(target) && !isVisible(target)) {
          return;
        }
        const {
          offset: offset2,
          targetOffset: targetOffset2
        } = placementInfo;
        let [popupOffsetX, popupOffsetY] = getNumberOffset(popupRect, offset2);
        const [targetOffsetX, targetOffsetY] = getNumberOffset(targetRect, targetOffset2);
        targetRect.x -= targetOffsetX;
        targetRect.y -= targetOffsetY;
        const [popupPoint, targetPoint] = placementInfo.points || [];
        const targetPoints = splitPoints(targetPoint);
        const popupPoints = splitPoints(popupPoint);
        const targetAlignPoint = getAlignPoint(targetRect, targetPoints);
        const popupAlignPoint = getAlignPoint(popupRect, popupPoints);
        const nextAlignInfo = {
          ...placementInfo
        };
        let nextPoints = [popupPoints, targetPoints];
        let nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;
        let nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;
        const originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);
        const originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);
        const targetAlignPointTL = getAlignPoint(targetRect, ["t", "l"]);
        const popupAlignPointTL = getAlignPoint(popupRect, ["t", "l"]);
        const targetAlignPointBR = getAlignPoint(targetRect, ["b", "r"]);
        const popupAlignPointBR = getAlignPoint(popupRect, ["b", "r"]);
        const overflow = placementInfo.overflow || {};
        const {
          adjustX,
          adjustY,
          shiftX,
          shiftY
        } = overflow;
        const supportAdjust = (val) => {
          if (typeof val === "boolean") {
            return val;
          }
          return val >= 0;
        };
        let nextPopupY;
        let nextPopupBottom;
        let nextPopupX;
        let nextPopupRight;
        syncNextPopupPosition();
        const needAdjustY = supportAdjust(adjustY);
        const sameTB = popupPoints[0] === targetPoints[0];
        if (needAdjustY && popupPoints[0] === "t" && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {
          let tmpNextOffsetY = nextOffsetY;
          if (sameTB) {
            tmpNextOffsetY -= popupHeight - targetHeight;
          } else {
            tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
          }
          const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);
          const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
          if (
newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||
newVisibleRecommendArea >= originIntersectionRecommendArea)
          ) {
            prevFlipRef.current.bt = true;
            nextOffsetY = tmpNextOffsetY;
            popupOffsetY = -popupOffsetY;
            nextPoints = [reversePoints(nextPoints[0], 0), reversePoints(nextPoints[1], 0)];
          } else {
            prevFlipRef.current.bt = false;
          }
        }
        if (needAdjustY && popupPoints[0] === "b" && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {
          let tmpNextOffsetY = nextOffsetY;
          if (sameTB) {
            tmpNextOffsetY += popupHeight - targetHeight;
          } else {
            tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
          }
          const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);
          const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
          if (
newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||
newVisibleRecommendArea >= originIntersectionRecommendArea)
          ) {
            prevFlipRef.current.tb = true;
            nextOffsetY = tmpNextOffsetY;
            popupOffsetY = -popupOffsetY;
            nextPoints = [reversePoints(nextPoints[0], 0), reversePoints(nextPoints[1], 0)];
          } else {
            prevFlipRef.current.tb = false;
          }
        }
        const needAdjustX = supportAdjust(adjustX);
        const sameLR = popupPoints[1] === targetPoints[1];
        if (needAdjustX && popupPoints[1] === "l" && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {
          let tmpNextOffsetX = nextOffsetX;
          if (sameLR) {
            tmpNextOffsetX -= popupWidth - targetWidth;
          } else {
            tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
          }
          const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);
          const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
          if (
newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||
newVisibleRecommendArea >= originIntersectionRecommendArea)
          ) {
            prevFlipRef.current.rl = true;
            nextOffsetX = tmpNextOffsetX;
            popupOffsetX = -popupOffsetX;
            nextPoints = [reversePoints(nextPoints[0], 1), reversePoints(nextPoints[1], 1)];
          } else {
            prevFlipRef.current.rl = false;
          }
        }
        if (needAdjustX && popupPoints[1] === "r" && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {
          let tmpNextOffsetX = nextOffsetX;
          if (sameLR) {
            tmpNextOffsetX += popupWidth - targetWidth;
          } else {
            tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
          }
          const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);
          const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
          if (
newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||
newVisibleRecommendArea >= originIntersectionRecommendArea)
          ) {
            prevFlipRef.current.lr = true;
            nextOffsetX = tmpNextOffsetX;
            popupOffsetX = -popupOffsetX;
            nextPoints = [reversePoints(nextPoints[0], 1), reversePoints(nextPoints[1], 1)];
          } else {
            prevFlipRef.current.lr = false;
          }
        }
        nextAlignInfo.points = [flatPoints(nextPoints[0]), flatPoints(nextPoints[1])];
        syncNextPopupPosition();
        const numShiftX = shiftX === true ? 0 : shiftX;
        if (typeof numShiftX === "number") {
          if (nextPopupX < visibleRegionArea.left) {
            nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;
            if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {
              nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;
            }
          }
          if (nextPopupRight > visibleRegionArea.right) {
            nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;
            if (targetRect.x > visibleRegionArea.right - numShiftX) {
              nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;
            }
          }
        }
        const numShiftY = shiftY === true ? 0 : shiftY;
        if (typeof numShiftY === "number") {
          if (nextPopupY < visibleRegionArea.top) {
            nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;
            if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {
              nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;
            }
          }
          if (nextPopupBottom > visibleRegionArea.bottom) {
            nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;
            if (targetRect.y > visibleRegionArea.bottom - numShiftY) {
              nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;
            }
          }
        }
        const popupLeft = popupRect.x + nextOffsetX;
        const popupRight = popupLeft + popupWidth;
        const popupTop = popupRect.y + nextOffsetY;
        const popupBottom = popupTop + popupHeight;
        const targetLeft = targetRect.x;
        const targetRight = targetLeft + targetWidth;
        const targetTop = targetRect.y;
        const targetBottom = targetTop + targetHeight;
        const maxLeft = Math.max(popupLeft, targetLeft);
        const minRight = Math.min(popupRight, targetRight);
        const xCenter = (maxLeft + minRight) / 2;
        const nextArrowX = xCenter - popupLeft;
        const maxTop = Math.max(popupTop, targetTop);
        const minBottom = Math.min(popupBottom, targetBottom);
        const yCenter = (maxTop + minBottom) / 2;
        const nextArrowY = yCenter - popupTop;
        onPopupAlign?.(popupEle, nextAlignInfo);
        let offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);
        let offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);
        if (scaleX2 === 1) {
          nextOffsetX = Math.floor(nextOffsetX);
          offsetX4Right = Math.floor(offsetX4Right);
        }
        if (scaleY2 === 1) {
          nextOffsetY = Math.floor(nextOffsetY);
          offsetY4Bottom = Math.floor(offsetY4Bottom);
        }
        const nextOffsetInfo = {
          ready: true,
          offsetX: nextOffsetX / scaleX2,
          offsetY: nextOffsetY / scaleY2,
          offsetR: offsetX4Right / scaleX2,
          offsetB: offsetY4Bottom / scaleY2,
          arrowX: nextArrowX / scaleX2,
          arrowY: nextArrowY / scaleY2,
          scaleX: scaleX2,
          scaleY: scaleY2,
          align: nextAlignInfo
        };
        setOffsetInfo(nextOffsetInfo);
      }
    });
    const triggerAlign = () => {
      alignCountRef.current += 1;
      const id2 = alignCountRef.current;
      Promise.resolve().then(() => {
        if (alignCountRef.current === id2) {
          onAlign();
        }
      });
    };
    const resetReady = () => {
      setOffsetInfo((ori) => ({
        ...ori,
        ready: false
      }));
    };
    useLayoutEffect(resetReady, [placement]);
    useLayoutEffect(() => {
      if (!open2) {
        resetReady();
      }
    }, [open2]);
    return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];
  }
  function useDelay() {
    const delayRef = reactExports.useRef(null);
    const clearDelay = () => {
      if (delayRef.current) {
        clearTimeout(delayRef.current);
        delayRef.current = null;
      }
    };
    const delayInvoke = (callback, delay2) => {
      clearDelay();
      if (delay2 === 0) {
        callback();
      } else {
        delayRef.current = setTimeout(() => {
          callback();
        }, delay2 * 1e3);
      }
    };
    reactExports.useEffect(() => {
      return () => {
        clearDelay();
      };
    }, []);
    return delayInvoke;
  }
  function useWatch$1(open2, target, popup, onAlign, onScroll) {
    useLayoutEffect(() => {
      if (open2 && target && popup) {
        let notifyScroll = function() {
          onAlign();
          onScroll();
        };
        const targetElement = target;
        const popupElement = popup;
        const targetScrollList = collectScroller(targetElement);
        const popupScrollList = collectScroller(popupElement);
        const win2 = getWin(popupElement);
        const mergedList = new Set([win2, ...targetScrollList, ...popupScrollList]);
        mergedList.forEach((scroller) => {
          scroller.addEventListener("scroll", notifyScroll, {
            passive: true
          });
        });
        win2.addEventListener("resize", notifyScroll, {
          passive: true
        });
        onAlign();
        return () => {
          mergedList.forEach((scroller) => {
            scroller.removeEventListener("scroll", notifyScroll);
            win2.removeEventListener("resize", notifyScroll);
          });
        };
      }
    }, [open2, target, popup]);
  }
  function useWinClick(open2, clickToHide, targetEle, popupEle, mask2, maskClosable, inPopupOrChild, triggerOpen) {
    const openRef = reactExports.useRef(open2);
    openRef.current = open2;
    const popupPointerDownRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      if (clickToHide && popupEle && (!mask2 || maskClosable)) {
        const onPointerDown = () => {
          popupPointerDownRef.current = false;
        };
        const onTriggerClose = (e) => {
          if (openRef.current && !inPopupOrChild(e.composedPath?.()?.[0] || e.target) && !popupPointerDownRef.current) {
            triggerOpen(false);
          }
        };
        const win2 = getWin(popupEle);
        win2.addEventListener("pointerdown", onPointerDown, true);
        win2.addEventListener("mousedown", onTriggerClose, true);
        win2.addEventListener("contextmenu", onTriggerClose, true);
        const targetShadowRoot = getShadowRoot(targetEle);
        if (targetShadowRoot) {
          targetShadowRoot.addEventListener("mousedown", onTriggerClose, true);
          targetShadowRoot.addEventListener("contextmenu", onTriggerClose, true);
        }
        return () => {
          win2.removeEventListener("pointerdown", onPointerDown, true);
          win2.removeEventListener("mousedown", onTriggerClose, true);
          win2.removeEventListener("contextmenu", onTriggerClose, true);
          if (targetShadowRoot) {
            targetShadowRoot.removeEventListener("mousedown", onTriggerClose, true);
            targetShadowRoot.removeEventListener("contextmenu", onTriggerClose, true);
          }
        };
      }
    }, [clickToHide, targetEle, popupEle, mask2, maskClosable]);
    function onPopupPointerDown() {
      popupPointerDownRef.current = true;
    }
    return onPopupPointerDown;
  }
  function useTargetState() {
    const [options, setOptions] = React.useState(null);
    const [open2, setOpen] = React.useState(false);
    const [isAnimating, setIsAnimating] = React.useState(false);
    const pendingOptionsRef = React.useRef(null);
    const trigger2 = useEvent$1((nextOptions) => {
      if (nextOptions === false) {
        pendingOptionsRef.current = null;
        setOpen(false);
      } else {
        if (isAnimating && open2) {
          pendingOptionsRef.current = nextOptions;
        } else {
          setOpen(true);
          setOptions(nextOptions);
          pendingOptionsRef.current = null;
          if (!open2) {
            setIsAnimating(true);
          }
        }
      }
    });
    const onVisibleChanged = useEvent$1((visible) => {
      if (visible) {
        setIsAnimating(false);
        if (pendingOptionsRef.current) {
          setOptions(pendingOptionsRef.current);
          pendingOptionsRef.current = null;
        }
      } else {
        setIsAnimating(false);
        pendingOptionsRef.current = null;
      }
    });
    return [trigger2, open2, options, onVisibleChanged];
  }
  function _extends$W() {
    _extends$W = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$W.apply(this, arguments);
  }
  const UniqueContainer = (props) => {
    const {
      prefixCls,
      isMobile: isMobile2,
      ready,
      open: open2,
      align,
      offsetR,
      offsetB,
      offsetX,
      offsetY,
      arrowPos,
      popupSize,
      motion: motion2,
      uniqueContainerClassName,
      uniqueContainerStyle
    } = props;
    const containerCls = `${prefixCls}-unique-container`;
    const [motionVisible, setMotionVisible] = React.useState(false);
    const offsetStyle = useOffsetStyle(isMobile2, ready, open2, align, offsetR, offsetB, offsetX, offsetY);
    const cachedOffsetStyleRef = React.useRef(offsetStyle);
    if (ready) {
      cachedOffsetStyleRef.current = offsetStyle;
    }
    const sizeStyle = {};
    if (popupSize) {
      sizeStyle.width = popupSize.width;
      sizeStyle.height = popupSize.height;
    }
    return React.createElement(CSSMotion, _extends$W({
      motionAppear: true,
      motionEnter: true,
      motionLeave: true,
      removeOnLeave: false,
      leavedClassName: `${containerCls}-hidden`
    }, motion2, {
      visible: open2,
      onVisibleChanged: (nextVisible) => {
        setMotionVisible(nextVisible);
      }
    }), ({
      className: motionClassName,
      style: motionStyle
    }) => {
      const cls = clsx(containerCls, motionClassName, uniqueContainerClassName, {
        [`${containerCls}-visible`]: motionVisible
      });
      return React.createElement("div", {
        className: cls,
        style: {
          "--arrow-x": `${arrowPos?.x || 0}px`,
          "--arrow-y": `${arrowPos?.y || 0}px`,
          ...cachedOffsetStyleRef.current,
          ...sizeStyle,
          ...motionStyle,
          ...uniqueContainerStyle
        }
      });
    });
  };
  const UniqueProvider$1 = ({
    children,
    postTriggerProps
  }) => {
    const [trigger2, open2, options, onTargetVisibleChanged] = useTargetState();
    const mergedOptions = reactExports.useMemo(() => {
      if (!options || !postTriggerProps) {
        return options;
      }
      return postTriggerProps(options);
    }, [options, postTriggerProps]);
    const [popupEle, setPopupEle] = reactExports.useState(null);
    const [popupSize, setPopupSize] = reactExports.useState(null);
    const externalPopupRef = reactExports.useRef(null);
    const setPopupRef = useEvent$1((node2) => {
      externalPopupRef.current = node2;
      if (isDOM(node2) && popupEle !== node2) {
        setPopupEle(node2);
      }
    });
    const isOpenRef = reactExports.useRef(null);
    const delayInvoke = useDelay();
    const show = useEvent$1((showOptions, isOpen) => {
      isOpenRef.current = isOpen;
      delayInvoke(() => {
        trigger2(showOptions);
      }, showOptions.delay);
    });
    const hide = (delay2) => {
      delayInvoke(() => {
        if (isOpenRef.current?.()) {
          return;
        }
        trigger2(false);
      }, delay2);
    };
    const onVisibleChanged = useEvent$1((visible) => {
      onTargetVisibleChanged(visible);
    });
    const [
      ready,
      offsetX,
      offsetY,
      offsetR,
      offsetB,
      arrowX,
      arrowY,
,
      ,
alignInfo,
      onAlign
    ] = useAlign(
      open2,
      popupEle,
      mergedOptions?.target,
      mergedOptions?.popupPlacement,
      mergedOptions?.builtinPlacements || {},
      mergedOptions?.popupAlign,
      void 0,
false
);
    const alignedClassName = reactExports.useMemo(() => {
      if (!mergedOptions) {
        return "";
      }
      const baseClassName = getAlignPopupClassName(
        mergedOptions.builtinPlacements || {},
        mergedOptions.prefixCls || "",
        alignInfo,
        false
);
      return clsx(baseClassName, mergedOptions.getPopupClassNameFromAlign?.(alignInfo));
    }, [alignInfo, mergedOptions?.getPopupClassNameFromAlign, mergedOptions?.builtinPlacements, mergedOptions?.prefixCls]);
    const contextValue = reactExports.useMemo(() => ({
      show,
      hide
    }), []);
    reactExports.useEffect(() => {
      onAlign();
    }, [mergedOptions?.target]);
    const onPrepare = useEvent$1(() => {
      onAlign();
      return Promise.resolve();
    });
    const subPopupElements = reactExports.useRef({});
    const parentContext = reactExports.useContext(TriggerContext);
    const triggerContextValue = reactExports.useMemo(() => ({
      registerSubPopup: (id2, subPopupEle) => {
        subPopupElements.current[id2] = subPopupEle;
        parentContext?.registerSubPopup(id2, subPopupEle);
      }
    }), [parentContext]);
    const prefixCls = mergedOptions?.prefixCls;
    return reactExports.createElement(UniqueContext.Provider, {
      value: contextValue
    }, children, mergedOptions && reactExports.createElement(TriggerContext.Provider, {
      value: triggerContextValue
    }, reactExports.createElement(Popup$1, {
      ref: setPopupRef,
      portal: Portal,
      onEsc: mergedOptions.onEsc,
      prefixCls,
      popup: mergedOptions.popup,
      className: clsx(mergedOptions.popupClassName, alignedClassName, `${prefixCls}-unique-controlled`),
      style: mergedOptions.popupStyle,
      target: mergedOptions.target,
      open: open2,
      keepDom: true,
      fresh: true,
      autoDestroy: false,
      onVisibleChanged,
      ready,
      offsetX,
      offsetY,
      offsetR,
      offsetB,
      onAlign,
      onPrepare,
      onResize: (size) => setPopupSize({
        width: size.offsetWidth,
        height: size.offsetHeight
      }),
      arrowPos: {
        x: arrowX,
        y: arrowY
      },
      align: alignInfo,
      zIndex: mergedOptions.zIndex,
      mask: mergedOptions.mask,
      arrow: mergedOptions.arrow,
      motion: mergedOptions.popupMotion,
      maskMotion: mergedOptions.maskMotion,
      getPopupContainer: mergedOptions.getPopupContainer
    }, reactExports.createElement(UniqueContainer, {
      prefixCls,
      isMobile: false,
      ready,
      open: open2,
      align: alignInfo,
      offsetR,
      offsetB,
      offsetX,
      offsetY,
      arrowPos: {
        x: arrowX,
        y: arrowY
      },
      popupSize,
      motion: mergedOptions.popupMotion,
      uniqueContainerClassName: clsx(mergedOptions.uniqueContainerClassName, alignedClassName),
      uniqueContainerStyle: mergedOptions.uniqueContainerStyle
    }))));
  };
  function generateTrigger(PortalComponent = Portal) {
    const Trigger2 = reactExports.forwardRef((props, ref2) => {
      const {
        prefixCls = "rc-trigger-popup",
        children,
action: action2 = "hover",
        showAction,
        hideAction,
popupVisible,
        defaultPopupVisible,
        onOpenChange,
        afterOpenChange,
        onPopupVisibleChange,
        afterPopupVisibleChange,
mouseEnterDelay,
        mouseLeaveDelay = 0.1,
        focusDelay,
        blurDelay,
mask: mask2,
        maskClosable = true,
getPopupContainer,
        forceRender,
        autoDestroy,
popup,
        popupClassName,
        uniqueContainerClassName,
        uniqueContainerStyle,
        popupStyle,
        popupPlacement,
        builtinPlacements = {},
        popupAlign,
        zIndex,
        stretch,
        getPopupClassNameFromAlign,
        fresh,
        unique,
        alignPoint,
        onPopupClick,
        onPopupAlign,
arrow,
popupMotion,
        maskMotion,
mobile,
        ...restProps
      } = props;
      const mergedAutoDestroy = autoDestroy || false;
      const openUncontrolled = popupVisible === void 0;
      const isMobile2 = !!mobile;
      const subPopupElements = reactExports.useRef({});
      const parentContext = reactExports.useContext(TriggerContext);
      const context = reactExports.useMemo(() => {
        return {
          registerSubPopup: (id22, subPopupEle) => {
            subPopupElements.current[id22] = subPopupEle;
            parentContext?.registerSubPopup(id22, subPopupEle);
          }
        };
      }, [parentContext]);
      const uniqueContext = reactExports.useContext(UniqueContext);
      const id2 = useId();
      const [popupEle, setPopupEle] = reactExports.useState(null);
      const externalPopupRef = reactExports.useRef(null);
      const setPopupRef = useEvent$1((node2) => {
        externalPopupRef.current = node2;
        if (isDOM(node2) && popupEle !== node2) {
          setPopupEle(node2);
        }
        parentContext?.registerSubPopup(id2, node2);
      });
      const [targetEle, setTargetEle] = reactExports.useState(null);
      const externalForwardRef = reactExports.useRef(null);
      const setTargetRef = useEvent$1((node2) => {
        const domNode = getDOM(node2);
        if (isDOM(domNode) && targetEle !== domNode) {
          setTargetEle(domNode);
          externalForwardRef.current = domNode;
        }
      });
      const cloneProps = {};
      const inPopupOrChild = useEvent$1((ele) => {
        const childDOM = targetEle;
        return childDOM?.contains(ele) || getShadowRoot(childDOM)?.host === ele || ele === childDOM || popupEle?.contains(ele) || getShadowRoot(popupEle)?.host === ele || ele === popupEle || Object.values(subPopupElements.current).some((subPopupEle) => subPopupEle?.contains(ele) || ele === subPopupEle);
      });
      const innerArrow = arrow ? {
...arrow !== true ? arrow : {}
      } : null;
      const [internalOpen, setInternalOpen] = useControlledState(defaultPopupVisible || false, popupVisible);
      const mergedOpen = internalOpen || false;
      const child = reactExports.useMemo(() => {
        const nextChild = typeof children === "function" ? children({
          open: mergedOpen
        }) : children;
        return reactExports.Children.only(nextChild);
      }, [children, mergedOpen]);
      const originChildProps = child?.props || {};
      const isOpen = useEvent$1(() => mergedOpen);
      const getUniqueOptions = useEvent$1((delay2 = 0) => ({
        popup,
        target: targetEle,
        delay: delay2,
        prefixCls,
        popupClassName,
        uniqueContainerClassName,
        uniqueContainerStyle,
        popupStyle,
        popupPlacement,
        builtinPlacements,
        popupAlign,
        zIndex,
        mask: mask2,
        maskClosable,
        popupMotion,
        maskMotion,
        arrow: innerArrow,
        getPopupContainer,
        getPopupClassNameFromAlign,
        id: id2,
        onEsc
      }));
      useLayoutEffect(() => {
        if (uniqueContext && unique && targetEle && !openUncontrolled && !parentContext) {
          if (mergedOpen) {
            uniqueContext.show(getUniqueOptions(mouseEnterDelay), isOpen);
          } else {
            uniqueContext.hide(mouseLeaveDelay);
          }
        }
      }, [mergedOpen, targetEle]);
      const openRef = reactExports.useRef(mergedOpen);
      openRef.current = mergedOpen;
      const internalTriggerOpen = useEvent$1((nextOpen) => {
        reactDomExports.flushSync(() => {
          if (mergedOpen !== nextOpen) {
            setInternalOpen(nextOpen);
            onOpenChange?.(nextOpen);
            onPopupVisibleChange?.(nextOpen);
          }
        });
      });
      const delayInvoke = useDelay();
      const triggerOpen = (nextOpen, delay2 = 0) => {
        if (popupVisible !== void 0) {
          delayInvoke(() => {
            internalTriggerOpen(nextOpen);
          }, delay2);
          return;
        }
        if (uniqueContext && unique && openUncontrolled && !parentContext) {
          if (nextOpen) {
            uniqueContext.show(getUniqueOptions(delay2), isOpen);
          } else {
            uniqueContext.hide(delay2);
          }
          return;
        }
        delayInvoke(() => {
          internalTriggerOpen(nextOpen);
        }, delay2);
      };
      function onEsc({
        top
      }) {
        if (top) {
          triggerOpen(false);
        }
      }
      const [inMotion, setInMotion] = reactExports.useState(false);
      useLayoutEffect((firstMount) => {
        if (!firstMount || mergedOpen) {
          setInMotion(true);
        }
      }, [mergedOpen]);
      const [motionPrepareResolve, setMotionPrepareResolve] = reactExports.useState(null);
      const [mousePos, setMousePos] = reactExports.useState(null);
      const setMousePosByEvent = (event) => {
        setMousePos([event.clientX, event.clientY]);
      };
      const [ready, offsetX, offsetY, offsetR, offsetB, arrowX, arrowY, scaleX2, scaleY2, alignInfo, onAlign] = useAlign(mergedOpen, popupEle, alignPoint && mousePos !== null ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign, isMobile2);
      const [showActions, hideActions] = useAction(action2, showAction, hideAction);
      const clickToShow = showActions.has("click");
      const clickToHide = hideActions.has("click") || hideActions.has("contextMenu");
      const triggerAlign = useEvent$1(() => {
        if (!inMotion) {
          onAlign();
        }
      });
      const onScroll = () => {
        if (openRef.current && alignPoint && clickToHide) {
          triggerOpen(false);
        }
      };
      useWatch$1(mergedOpen, targetEle, popupEle, triggerAlign, onScroll);
      useLayoutEffect(() => {
        triggerAlign();
      }, [mousePos, popupPlacement]);
      useLayoutEffect(() => {
        if (mergedOpen && !builtinPlacements?.[popupPlacement]) {
          triggerAlign();
        }
      }, [JSON.stringify(popupAlign)]);
      const alignedClassName = reactExports.useMemo(() => {
        const baseClassName = getAlignPopupClassName(builtinPlacements, prefixCls, alignInfo, alignPoint);
        return clsx(baseClassName, getPopupClassNameFromAlign?.(alignInfo));
      }, [alignInfo, getPopupClassNameFromAlign, builtinPlacements, prefixCls, alignPoint]);
      reactExports.useImperativeHandle(ref2, () => ({
        nativeElement: externalForwardRef.current,
        popupElement: externalPopupRef.current,
        forceAlign: triggerAlign
      }));
      const [targetWidth, setTargetWidth] = reactExports.useState(0);
      const [targetHeight, setTargetHeight] = reactExports.useState(0);
      const syncTargetSize = () => {
        if (stretch && targetEle) {
          const rect = targetEle.getBoundingClientRect();
          setTargetWidth(rect.width);
          setTargetHeight(rect.height);
        }
      };
      const onTargetResize = () => {
        syncTargetSize();
        triggerAlign();
      };
      const onVisibleChanged = (visible) => {
        setInMotion(false);
        onAlign();
        afterOpenChange?.(visible);
        afterPopupVisibleChange?.(visible);
      };
      const onPrepare = () => new Promise((resolve) => {
        syncTargetSize();
        setMotionPrepareResolve(() => resolve);
      });
      useLayoutEffect(() => {
        if (motionPrepareResolve) {
          onAlign();
          motionPrepareResolve();
          setMotionPrepareResolve(null);
        }
      }, [motionPrepareResolve]);
      function wrapperAction(eventName, nextOpen, delay2, callback, ignoreCheck) {
        cloneProps[eventName] = (event, ...args) => {
          if (!ignoreCheck || !ignoreCheck()) {
            callback?.(event);
            triggerOpen(nextOpen, delay2);
          }
          originChildProps[eventName]?.(event, ...args);
        };
      }
      const touchToShow = showActions.has("touch");
      const touchToHide = hideActions.has("touch");
      const touchedRef = reactExports.useRef(false);
      if (touchToShow || touchToHide) {
        cloneProps.onTouchStart = (...args) => {
          touchedRef.current = true;
          if (openRef.current && touchToHide) {
            triggerOpen(false);
          } else if (!openRef.current && touchToShow) {
            triggerOpen(true);
          }
          originChildProps.onTouchStart?.(...args);
        };
      }
      if (clickToShow || clickToHide) {
        cloneProps.onClick = (event, ...args) => {
          if (openRef.current && clickToHide) {
            triggerOpen(false);
          } else if (!openRef.current && clickToShow) {
            setMousePosByEvent(event);
            triggerOpen(true);
          }
          originChildProps.onClick?.(event, ...args);
          touchedRef.current = false;
        };
      }
      const onPopupPointerDown = useWinClick(mergedOpen, clickToHide || touchToHide, targetEle, popupEle, mask2, maskClosable, inPopupOrChild, triggerOpen);
      const hoverToShow = showActions.has("hover");
      const hoverToHide = hideActions.has("hover");
      let onPopupMouseEnter;
      let onPopupMouseLeave;
      const ignoreMouseTrigger = () => {
        return touchedRef.current;
      };
      if (hoverToShow) {
        const onMouseEnterCallback = (event) => {
          setMousePosByEvent(event);
        };
        wrapperAction("onMouseEnter", true, mouseEnterDelay, onMouseEnterCallback, ignoreMouseTrigger);
        wrapperAction("onPointerEnter", true, mouseEnterDelay, onMouseEnterCallback, ignoreMouseTrigger);
        onPopupMouseEnter = (event) => {
          if ((mergedOpen || inMotion) && popupEle?.contains(event.target)) {
            triggerOpen(true, mouseEnterDelay);
          }
        };
        if (alignPoint) {
          cloneProps.onMouseMove = (event) => {
            originChildProps.onMouseMove?.(event);
          };
        }
      }
      if (hoverToHide) {
        wrapperAction("onMouseLeave", false, mouseLeaveDelay, void 0, ignoreMouseTrigger);
        wrapperAction("onPointerLeave", false, mouseLeaveDelay, void 0, ignoreMouseTrigger);
        onPopupMouseLeave = () => {
          triggerOpen(false, mouseLeaveDelay);
        };
      }
      if (showActions.has("focus")) {
        wrapperAction("onFocus", true, focusDelay);
      }
      if (hideActions.has("focus")) {
        wrapperAction("onBlur", false, blurDelay);
      }
      if (showActions.has("contextMenu")) {
        cloneProps.onContextMenu = (event, ...args) => {
          if (openRef.current && hideActions.has("contextMenu")) {
            triggerOpen(false);
          } else {
            setMousePosByEvent(event);
            triggerOpen(true);
          }
          event.preventDefault();
          originChildProps.onContextMenu?.(event, ...args);
        };
      }
      const rendedRef = reactExports.useRef(false);
      rendedRef.current ||= forceRender || mergedOpen || inMotion;
      const mergedChildrenProps = {
        ...originChildProps,
        ...cloneProps
      };
      const passedProps = {};
      const passedEventList = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
      passedEventList.forEach((eventName) => {
        if (restProps[eventName]) {
          passedProps[eventName] = (...args) => {
            mergedChildrenProps[eventName]?.(...args);
            restProps[eventName](...args);
          };
        }
      });
      const arrowPos = {
        x: arrowX,
        y: arrowY
      };
      useResizeObserver$1(mergedOpen, targetEle, onTargetResize);
      const mergedRef = useComposeRef(setTargetRef, getNodeRef(child));
      const triggerNode = reactExports.cloneElement(child, {
        ...mergedChildrenProps,
        ...passedProps,
        ref: mergedRef
      });
      return reactExports.createElement(reactExports.Fragment, null, triggerNode, rendedRef.current && (!uniqueContext || !unique) && reactExports.createElement(TriggerContext.Provider, {
        value: context
      }, reactExports.createElement(Popup$1, {
        portal: PortalComponent,
        ref: setPopupRef,
        prefixCls,
        popup,
        className: clsx(popupClassName, !isMobile2 && alignedClassName),
        style: popupStyle,
        target: targetEle,
        onMouseEnter: onPopupMouseEnter,
        onMouseLeave: onPopupMouseLeave,
        onPointerEnter: onPopupMouseEnter,
        zIndex,
        open: mergedOpen,
        keepDom: inMotion,
        fresh,
        onClick: onPopupClick,
        onPointerDownCapture: onPopupPointerDown,
        mask: mask2,
        motion: popupMotion,
        maskMotion,
        onVisibleChanged,
        onPrepare,
        forceRender,
        autoDestroy: mergedAutoDestroy,
        getPopupContainer,
        onEsc,
        align: alignInfo,
        arrow: innerArrow,
        arrowPos,
        ready,
        offsetX,
        offsetY,
        offsetR,
        offsetB,
        onAlign: triggerAlign,
        stretch,
        targetWidth: targetWidth / scaleX2,
        targetHeight: targetHeight / scaleY2,
        mobile
      })));
    });
    return Trigger2;
  }
  const Trigger = generateTrigger(Portal);
  function isFragment(child) {
    return child && React.isValidElement(child) && child.type === React.Fragment;
  }
  const replaceElement = (element, replacement, props) => {
    if (! React.isValidElement(element)) {
      return replacement;
    }
    return React.cloneElement(element, typeof props === "function" ? props(element.props || {}) : props);
  };
  function cloneElement(element, props) {
    return replaceElement(element, element, props);
  }
  const MotionContent = ({
    children
  }) => {
    const {
      getPrefixCls
    } = React.useContext(ConfigContext);
    const rootPrefixCls = getPrefixCls();
    if (! React.isValidElement(children)) {
      return children;
    }
    return React.createElement(CSSMotion, {
      visible: true,
      motionName: `${rootPrefixCls}-fade`,
      motionAppear: true,
      motionEnter: true,
      motionLeave: false,
      removeOnLeave: false
    }, ({
      style: motionStyle,
      className: motionClassName
    }) => {
      return cloneElement(children, (oriProps) => ({
        className: clsx(oriProps.className, motionClassName),
        style: {
          ...oriProps.style,
          ...motionStyle
        }
      }));
    });
  };
  const cachedPlacements = [null, null];
  function uniqueBuiltinPlacements(ori) {
    if (cachedPlacements[0] !== ori) {
      const target = {};
      Object.keys(ori).forEach((placement) => {
        target[placement] = {
          ...ori[placement],
          dynamicInset: false
        };
      });
      cachedPlacements[0] = ori;
      cachedPlacements[1] = target;
    }
    return cachedPlacements[1];
  }
  const UniqueProvider = ({
    children
  }) => {
    const renderPopup = (options) => {
      const {
        id: id2,
        builtinPlacements,
        popup
      } = options;
      const popupEle = typeof popup === "function" ? popup() : popup;
      const parsedPlacements = uniqueBuiltinPlacements(builtinPlacements);
      return {
        ...options,
        getPopupContainer: null,
        arrow: false,
        popup: React.createElement(MotionContent, {
          key: id2
        }, popupEle),
        builtinPlacements: parsedPlacements
      };
    };
    return React.createElement(UniqueProvider$1, {
      postTriggerProps: renderPopup
    }, children);
  };
  const DisabledContext = reactExports.createContext(false);
  const DisabledContextProvider = ({
    children,
    disabled
  }) => {
    const originDisabled = reactExports.useContext(DisabledContext);
    return reactExports.createElement(DisabledContext.Provider, {
      value: disabled ?? originDisabled
    }, children);
  };
  const SizeContext = reactExports.createContext(void 0);
  const SizeContextProvider = ({
    children,
    size
  }) => {
    const originSize = reactExports.useContext(SizeContext);
    return reactExports.createElement(SizeContext.Provider, {
      value: size || originSize
    }, children);
  };
  function useConfig() {
    const componentDisabled = reactExports.useContext(DisabledContext);
    const componentSize = reactExports.useContext(SizeContext);
    return {
      componentDisabled,
      componentSize
    };
  }
  function useTheme(theme2, parentTheme, config) {
    const themeConfig = theme2 || {};
    const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? {
      ...defaultConfig,
      hashed: parentTheme?.hashed ?? defaultConfig.hashed,
      cssVar: parentTheme?.cssVar
    } : parentTheme;
    const themeKey = reactExports.useId();
    return useMemo(() => {
      if (!theme2) {
        return parentTheme;
      }
      const mergedComponents = {
        ...parentThemeConfig.components
      };
      Object.keys(theme2.components || {}).forEach((componentName) => {
        mergedComponents[componentName] = {
          ...mergedComponents[componentName],
          ...theme2.components[componentName]
        };
      });
      const cssVarKey = `css-var-${themeKey.replace(/:/g, "")}`;
      const mergedCssVar = {
        prefix: config?.prefixCls,
...parentThemeConfig.cssVar,
        ...themeConfig.cssVar,
        key: themeConfig.cssVar?.key || cssVarKey
      };
      return {
        ...parentThemeConfig,
        ...themeConfig,
        token: {
          ...parentThemeConfig.token,
          ...themeConfig.token
        },
        components: mergedComponents,
        cssVar: mergedCssVar
      };
    }, [themeConfig, parentThemeConfig], (prev2, next2) => prev2.some((prevTheme, index) => {
      const nextTheme = next2[index];
      return !isEqual$1(prevTheme, nextTheme, true);
    }));
  }
  const MotionCacheContext = reactExports.createContext(true);
  function MotionWrapper(props) {
    const parentMotion = reactExports.useContext(MotionCacheContext);
    const {
      children
    } = props;
    const [, token2] = useToken$1();
    const {
      motion: motion2
    } = token2;
    const needWrapMotionProviderRef = reactExports.useRef(false);
    needWrapMotionProviderRef.current || (needWrapMotionProviderRef.current = parentMotion !== motion2);
    if (needWrapMotionProviderRef.current) {
      return reactExports.createElement(MotionCacheContext.Provider, {
        value: motion2
      }, reactExports.createElement(MotionProvider, {
        motion: motion2
      }, children));
    }
    return children;
  }
  const PropWarning = () => null;
  const IconStyle = ({
    iconPrefixCls,
    csp
  }) => {
    useResetIconStyle(iconPrefixCls, csp);
    return null;
  };
  const PASSED_PROPS = ["getTargetContainer", "getPopupContainer", "renderEmpty", "input", "pagination", "form", "select", "button"];
  let globalPrefixCls;
  let globalIconPrefixCls;
  let globalTheme;
  let globalHolderRender;
  function getGlobalPrefixCls() {
    return globalPrefixCls || defaultPrefixCls;
  }
  function getGlobalIconPrefixCls() {
    return globalIconPrefixCls || defaultIconPrefixCls;
  }
  const setGlobalConfig = (props) => {
    const {
      prefixCls,
      iconPrefixCls,
      theme: theme2,
      holderRender
    } = props;
    if (prefixCls !== void 0) {
      globalPrefixCls = prefixCls;
    }
    if (iconPrefixCls !== void 0) {
      globalIconPrefixCls = iconPrefixCls;
    }
    if ("holderRender" in props) {
      globalHolderRender = holderRender;
    }
    if (theme2) {
      globalTheme = theme2;
    }
  };
  const globalConfig = () => ({
    getPrefixCls: (suffixCls, customizePrefixCls) => {
      if (customizePrefixCls) {
        return customizePrefixCls;
      }
      return suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls();
    },
    getIconPrefixCls: getGlobalIconPrefixCls,
    getRootPrefixCls: () => {
      if (globalPrefixCls) {
        return globalPrefixCls;
      }
      return getGlobalPrefixCls();
    },
    getTheme: () => globalTheme,
    holderRender: globalHolderRender
  });
  const ProviderChildren = (props) => {
    const {
      children,
      csp: customCsp,
      autoInsertSpaceInButton,
      alert,
      affix,
      anchor,
      app,
      form,
      locale: locale2,
      componentSize,
      direction,
      space,
      splitter,
      virtual,
      dropdownMatchSelectWidth,
      popupMatchSelectWidth,
      popupOverflow,
      legacyLocale,
      parentContext,
      iconPrefixCls: customIconPrefixCls,
      theme: theme2,
      componentDisabled,
      segmented,
      statistic: statistic2,
      spin,
      calendar,
      carousel,
      cascader,
      collapse,
      typography,
      checkbox,
      descriptions,
      divider,
      drawer,
      skeleton,
      steps,
      image,
      layout: layout2,
      list: list2,
      mentions,
      modal,
      progress: progress2,
      result,
      slider,
      breadcrumb,
      masonry,
      menu,
      pagination,
      input,
      textArea,
      otp,
      empty,
      badge,
      radio,
      rate,
      ribbon,
      switch: SWITCH,
      transfer,
      avatar,
      message: message2,
      tag,
      table,
      card,
      cardMeta,
      tabs,
      timeline,
      timePicker,
      upload,
      notification: notification2,
      tree,
      colorPicker,
      datePicker,
      rangePicker,
      flex,
      wave,
      dropdown,
      warning: warningConfig,
      tour,
      tooltip,
      popover,
      popconfirm,
      qrcode,
      floatButton,
      floatButtonGroup,
      variant,
      inputNumber,
      treeSelect,
      watermark
    } = props;
    const getPrefixCls = reactExports.useCallback((suffixCls, customizePrefixCls) => {
      const {
        prefixCls
      } = props;
      if (customizePrefixCls) {
        return customizePrefixCls;
      }
      const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
      return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
    }, [parentContext.getPrefixCls, props.prefixCls]);
    const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || defaultIconPrefixCls;
    const csp = customCsp || parentContext.csp;
    const mergedTheme = useTheme(theme2, parentContext.theme, {
      prefixCls: getPrefixCls("")
    });
    const baseConfig = {
      csp,
      autoInsertSpaceInButton,
      alert,
      affix,
      anchor,
      app,
      locale: locale2 || legacyLocale,
      direction,
      space,
      splitter,
      virtual,
      popupMatchSelectWidth: popupMatchSelectWidth ?? dropdownMatchSelectWidth,
      popupOverflow,
      getPrefixCls,
      iconPrefixCls,
      theme: mergedTheme,
      segmented,
      statistic: statistic2,
      spin,
      calendar,
      carousel,
      cascader,
      collapse,
      typography,
      checkbox,
      descriptions,
      divider,
      drawer,
      skeleton,
      steps,
      image,
      input,
      textArea,
      otp,
      layout: layout2,
      list: list2,
      mentions,
      modal,
      progress: progress2,
      result,
      slider,
      breadcrumb,
      masonry,
      menu,
      pagination,
      empty,
      badge,
      radio,
      rate,
      ribbon,
      switch: SWITCH,
      transfer,
      avatar,
      message: message2,
      tag,
      table,
      card,
      cardMeta,
      tabs,
      timeline,
      timePicker,
      upload,
      notification: notification2,
      tree,
      colorPicker,
      datePicker,
      rangePicker,
      flex,
      wave,
      dropdown,
      warning: warningConfig,
      tour,
      tooltip,
      popover,
      popconfirm,
      qrcode,
      floatButton,
      floatButtonGroup,
      variant,
      inputNumber,
      treeSelect,
      watermark
    };
    const config = {
      ...parentContext
    };
    Object.keys(baseConfig).forEach((key) => {
      if (baseConfig[key] !== void 0) {
        config[key] = baseConfig[key];
      }
    });
    PASSED_PROPS.forEach((propName) => {
      const propValue = props[propName];
      if (propValue) {
        config[propName] = propValue;
      }
    });
    if (typeof autoInsertSpaceInButton !== "undefined") {
      config.button = {
        autoInsertSpace: autoInsertSpaceInButton,
        ...config.button
      };
    }
    const memoedConfig = useMemo(() => config, config, (prevConfig, currentConfig) => {
      const prevKeys = Object.keys(prevConfig);
      const currentKeys = Object.keys(currentConfig);
      return prevKeys.length !== currentKeys.length || prevKeys.some((key) => prevConfig[key] !== currentConfig[key]);
    });
    const {
      layer
    } = reactExports.useContext(StyleContext);
    const memoIconContextValue = reactExports.useMemo(() => ({
      prefixCls: iconPrefixCls,
      csp,
      layer: layer ? "antd" : void 0
    }), [iconPrefixCls, csp, layer]);
    let childNode = reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(IconStyle, {
      iconPrefixCls,
      csp
    }), reactExports.createElement(PropWarning, {
      dropdownMatchSelectWidth
    }), children);
    const validateMessages = reactExports.useMemo(() => merge$2(localeValues.Form?.defaultValidateMessages || {}, memoedConfig.locale?.Form?.defaultValidateMessages || {}, memoedConfig.form?.validateMessages || {}, form?.validateMessages || {}), [memoedConfig, form?.validateMessages]);
    if (Object.keys(validateMessages).length > 0) {
      childNode = reactExports.createElement(ValidateMessagesContext.Provider, {
        value: validateMessages
      }, childNode);
    }
    if (locale2) {
      childNode = reactExports.createElement(LocaleProvider, {
        locale: locale2,
        _ANT_MARK__: ANT_MARK
      }, childNode);
    }
    {
      childNode = reactExports.createElement(IconContext.Provider, {
        value: memoIconContextValue
      }, childNode);
    }
    if (componentSize) {
      childNode = reactExports.createElement(SizeContextProvider, {
        size: componentSize
      }, childNode);
    }
    childNode = reactExports.createElement(MotionWrapper, null, childNode);
    if (tooltip?.unique) {
      childNode = reactExports.createElement(UniqueProvider, null, childNode);
    }
    const memoTheme = reactExports.useMemo(() => {
      const {
        algorithm,
        token: token2,
        components: components2,
        cssVar: cssVar2,
        ...rest
      } = mergedTheme || {};
      const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : defaultTheme;
      const parsedComponents = {};
      Object.entries(components2 || {}).forEach(([componentName, componentToken]) => {
        const parsedToken = {
          ...componentToken
        };
        if ("algorithm" in parsedToken) {
          if (parsedToken.algorithm === true) {
            parsedToken.theme = themeObj;
          } else if (Array.isArray(parsedToken.algorithm) || typeof parsedToken.algorithm === "function") {
            parsedToken.theme = createTheme(parsedToken.algorithm);
          }
          delete parsedToken.algorithm;
        }
        parsedComponents[componentName] = parsedToken;
      });
      const mergedToken = {
        ...seedToken,
        ...token2
      };
      return {
        ...rest,
        theme: themeObj,
        token: mergedToken,
        components: parsedComponents,
        override: {
          override: mergedToken,
          ...parsedComponents
        },
        cssVar: cssVar2
      };
    }, [mergedTheme]);
    if (theme2) {
      childNode = reactExports.createElement(DesignTokenContext.Provider, {
        value: memoTheme
      }, childNode);
    }
    if (memoedConfig.warning) {
      childNode = reactExports.createElement(WarningContext.Provider, {
        value: memoedConfig.warning
      }, childNode);
    }
    if (componentDisabled !== void 0) {
      childNode = reactExports.createElement(DisabledContextProvider, {
        disabled: componentDisabled
      }, childNode);
    }
    return reactExports.createElement(ConfigContext.Provider, {
      value: memoedConfig
    }, childNode);
  };
  const ConfigProvider = (props) => {
    const context = reactExports.useContext(ConfigContext);
    const antLocale = reactExports.useContext(LocaleContext);
    return reactExports.createElement(ProviderChildren, {
      parentContext: context,
      legacyLocale: antLocale,
      ...props
    });
  };
  ConfigProvider.ConfigContext = ConfigContext;
  ConfigProvider.SizeContext = SizeContext;
  ConfigProvider.config = setGlobalConfig;
  ConfigProvider.useConfig = useConfig;
  Object.defineProperty(ConfigProvider, "SizeContext", {
    get: () => {
      return SizeContext;
    }
  });
  const KeyCode = {
BACKSPACE: 8,
TAB: 9,

ENTER: 13,
SHIFT: 16,
CTRL: 17,
ALT: 18,
CAPS_LOCK: 20,
ESC: 27,
SPACE: 32,
PAGE_UP: 33,

PAGE_DOWN: 34,

END: 35,

HOME: 36,

LEFT: 37,

UP: 38,

RIGHT: 39,

DOWN: 40,

DELETE: 46,
N: 78,
P: 80,
META: 91,

WIN_KEY_RIGHT: 92,
CONTEXT_MENU: 93,
F1: 112,
F2: 113,
F3: 114,
F4: 115,
F5: 116,
F6: 117,
F7: 118,
F8: 119,
F9: 120,
F10: 121,
F11: 122,
F12: 123,
SEMICOLON: 186,

EQUALS: 187,

WIN_KEY: 224
  };
  function _extends$V() {
    _extends$V = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$V.apply(this, arguments);
  }
  const Notify = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls,
      style: style2,
      className,
      duration: duration2 = 4.5,
      showProgress,
      pauseOnHover = true,
      eventKey,
      content,
      closable,
      props: divProps,
      onClick,
      onNoticeClose,
      times: times2,
      hovering: forcedHovering
    } = props;
    const [hovering, setHovering] = reactExports.useState(false);
    const [percent2, setPercent] = reactExports.useState(0);
    const [spentTime, setSpentTime] = reactExports.useState(0);
    const mergedHovering = forcedHovering || hovering;
    const mergedDuration = typeof duration2 === "number" ? duration2 : 0;
    const mergedShowProgress = mergedDuration > 0 && showProgress;
    const onInternalClose = () => {
      onNoticeClose(eventKey);
    };
    const onCloseKeyDown = (e) => {
      if (e.key === "Enter" || e.code === "Enter" || e.keyCode === KeyCode.ENTER) {
        onInternalClose();
      }
    };
    reactExports.useEffect(() => {
      if (!mergedHovering && mergedDuration > 0) {
        const start = Date.now() - spentTime;
        const timeout = setTimeout(() => {
          onInternalClose();
        }, mergedDuration * 1e3 - spentTime);
        return () => {
          if (pauseOnHover) {
            clearTimeout(timeout);
          }
          setSpentTime(Date.now() - start);
        };
      }
    }, [mergedDuration, mergedHovering, times2]);
    reactExports.useEffect(() => {
      if (!mergedHovering && mergedShowProgress && (pauseOnHover || spentTime === 0)) {
        const start = performance.now();
        let animationFrame;
        const calculate = () => {
          cancelAnimationFrame(animationFrame);
          animationFrame = requestAnimationFrame((timestamp) => {
            const runtime = timestamp + spentTime - start;
            const progress2 = Math.min(runtime / (mergedDuration * 1e3), 1);
            setPercent(progress2 * 100);
            if (progress2 < 1) {
              calculate();
            }
          });
        };
        calculate();
        return () => {
          if (pauseOnHover) {
            cancelAnimationFrame(animationFrame);
          }
        };
      }
    }, [mergedDuration, spentTime, mergedHovering, mergedShowProgress, times2]);
    const closableObj = reactExports.useMemo(() => {
      if (typeof closable === "object" && closable !== null) {
        return closable;
      }
      return {};
    }, [closable]);
    const ariaProps = pickAttrs(closableObj, true);
    const validPercent = 100 - (!percent2 || percent2 < 0 ? 0 : percent2 > 100 ? 100 : percent2);
    const noticePrefixCls = `${prefixCls}-notice`;
    return reactExports.createElement("div", _extends$V({}, divProps, {
      ref: ref2,
      className: clsx(noticePrefixCls, className, {
        [`${noticePrefixCls}-closable`]: closable
      }),
      style: style2,
      onMouseEnter: (e) => {
        setHovering(true);
        divProps?.onMouseEnter?.(e);
      },
      onMouseLeave: (e) => {
        setHovering(false);
        divProps?.onMouseLeave?.(e);
      },
      onClick
    }), reactExports.createElement("div", {
      className: `${noticePrefixCls}-content`
    }, content), closable && reactExports.createElement("button", _extends$V({
      className: `${noticePrefixCls}-close`,
      onKeyDown: onCloseKeyDown,
      "aria-label": "Close"
    }, ariaProps, {
      onClick: (e) => {
        e.preventDefault();
        e.stopPropagation();
        onInternalClose();
      }
    }), closableObj.closeIcon ?? "x"), mergedShowProgress && reactExports.createElement("progress", {
      className: `${noticePrefixCls}-progress`,
      max: "100",
      value: validPercent
    }, validPercent + "%"));
  });
  const NotificationContext = React.createContext({});
  const NotificationProvider = ({
    children,
    classNames
  }) => {
    return React.createElement(NotificationContext.Provider, {
      value: {
        classNames
      }
    }, children);
  };
  const DEFAULT_OFFSET$2 = 8;
  const DEFAULT_THRESHOLD = 3;
  const DEFAULT_GAP = 16;
  const useStack = (config) => {
    const result = {
      offset: DEFAULT_OFFSET$2,
      threshold: DEFAULT_THRESHOLD,
      gap: DEFAULT_GAP
    };
    if (config && typeof config === "object") {
      result.offset = config.offset ?? DEFAULT_OFFSET$2;
      result.threshold = config.threshold ?? DEFAULT_THRESHOLD;
      result.gap = config.gap ?? DEFAULT_GAP;
    }
    return [!!config, result];
  };
  function _extends$U() {
    _extends$U = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$U.apply(this, arguments);
  }
  const NoticeList = (props) => {
    const {
      configList,
      placement,
      prefixCls,
      className,
      style: style2,
      motion: motion2,
      onAllNoticeRemoved,
      onNoticeClose,
      stack: stackConfig
    } = props;
    const {
      classNames: ctxCls
    } = reactExports.useContext(NotificationContext);
    const dictRef = reactExports.useRef({});
    const [latestNotice, setLatestNotice] = reactExports.useState(null);
    const [hoverKeys, setHoverKeys] = reactExports.useState([]);
    const keys2 = configList.map((config) => ({
      config,
      key: String(config.key)
    }));
    const [stack2, {
      offset: offset2,
      threshold,
      gap
    }] = useStack(stackConfig);
    const expanded = stack2 && (hoverKeys.length > 0 || keys2.length <= threshold);
    const placementMotion = typeof motion2 === "function" ? motion2(placement) : motion2;
    reactExports.useEffect(() => {
      if (stack2 && hoverKeys.length > 1) {
        setHoverKeys((prev2) => prev2.filter((key) => keys2.some(({
          key: dataKey
        }) => key === dataKey)));
      }
    }, [hoverKeys, keys2, stack2]);
    reactExports.useEffect(() => {
      if (stack2 && dictRef.current[keys2[keys2.length - 1]?.key]) {
        setLatestNotice(dictRef.current[keys2[keys2.length - 1]?.key]);
      }
    }, [keys2, stack2]);
    return React.createElement(CSSMotionList, _extends$U({
      key: placement,
      className: clsx(prefixCls, `${prefixCls}-${placement}`, ctxCls?.list, className, {
        [`${prefixCls}-stack`]: !!stack2,
        [`${prefixCls}-stack-expanded`]: expanded
      }),
      style: style2,
      keys: keys2,
      motionAppear: true
    }, placementMotion, {
      onAllRemoved: () => {
        onAllNoticeRemoved(placement);
      }
    }), ({
      config,
      className: motionClassName,
      style: motionStyle,
      index: motionIndex
    }, nodeRef) => {
      const {
        key,
        times: times2
      } = config;
      const strKey = String(key);
      const {
        className: configClassName,
        style: configStyle,
        classNames: configClassNames,
        styles: configStyles,
        ...restConfig
      } = config;
      const dataIndex = keys2.findIndex((item) => item.key === strKey);
      const stackStyle = {};
      if (stack2) {
        const index = keys2.length - 1 - (dataIndex > -1 ? dataIndex : motionIndex - 1);
        const transformX = placement === "top" || placement === "bottom" ? "-50%" : "0";
        if (index > 0) {
          stackStyle.height = expanded ? dictRef.current[strKey]?.offsetHeight : latestNotice?.offsetHeight;
          let verticalOffset = 0;
          for (let i2 = 0; i2 < index; i2++) {
            verticalOffset += dictRef.current[keys2[keys2.length - 1 - i2].key]?.offsetHeight + gap;
          }
          const transformY = (expanded ? verticalOffset : index * offset2) * (placement.startsWith("top") ? 1 : -1);
          const scaleX2 = !expanded && latestNotice?.offsetWidth && dictRef.current[strKey]?.offsetWidth ? (latestNotice?.offsetWidth - offset2 * 2 * (index < 3 ? index : 3)) / dictRef.current[strKey]?.offsetWidth : 1;
          stackStyle.transform = `translate3d(${transformX}, ${transformY}px, 0) scaleX(${scaleX2})`;
        } else {
          stackStyle.transform = `translate3d(${transformX}, 0, 0)`;
        }
      }
      return React.createElement("div", {
        ref: nodeRef,
        className: clsx(`${prefixCls}-notice-wrapper`, motionClassName, configClassNames?.wrapper),
        style: {
          ...motionStyle,
          ...stackStyle,
          ...configStyles?.wrapper
        },
        onMouseEnter: () => setHoverKeys((prev2) => prev2.includes(strKey) ? prev2 : [...prev2, strKey]),
        onMouseLeave: () => setHoverKeys((prev2) => prev2.filter((k) => k !== strKey))
      }, React.createElement(Notify, _extends$U({}, restConfig, {
        ref: (node2) => {
          if (dataIndex > -1) {
            dictRef.current[strKey] = node2;
          } else {
            delete dictRef.current[strKey];
          }
        },
        prefixCls,
        classNames: configClassNames,
        styles: configStyles,
        className: clsx(configClassName, ctxCls?.notice),
        style: configStyle,
        times: times2,
        key,
        eventKey: key,
        onNoticeClose,
        hovering: stack2 && hoverKeys.length > 0
      })));
    });
  };
  const Notifications = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls = "rc-notification",
      container,
      motion: motion2,
      maxCount,
      className,
      style: style2,
      onAllRemoved,
      stack: stack2,
      renderNotifications: renderNotifications2
    } = props;
    const [configList, setConfigList] = reactExports.useState([]);
    const onNoticeClose = (key) => {
      const config = configList.find((item) => item.key === key);
      const closable = config?.closable;
      const closableObj = closable && typeof closable === "object" ? closable : {};
      const {
        onClose: closableOnClose
      } = closableObj;
      closableOnClose?.();
      config?.onClose?.();
      setConfigList((list2) => list2.filter((item) => item.key !== key));
    };
    reactExports.useImperativeHandle(ref2, () => ({
      open: (config) => {
        setConfigList((list2) => {
          let clone2 = [...list2];
          const index = clone2.findIndex((item) => item.key === config.key);
          const innerConfig = {
            ...config
          };
          if (index >= 0) {
            innerConfig.times = (list2[index]?.times || 0) + 1;
            clone2[index] = innerConfig;
          } else {
            innerConfig.times = 0;
            clone2.push(innerConfig);
          }
          if (maxCount > 0 && clone2.length > maxCount) {
            clone2 = clone2.slice(-maxCount);
          }
          return clone2;
        });
      },
      close: (key) => {
        onNoticeClose(key);
      },
      destroy: () => {
        setConfigList([]);
      }
    }));
    const [placements2, setPlacements] = reactExports.useState({});
    reactExports.useEffect(() => {
      const nextPlacements = {};
      configList.forEach((config) => {
        const {
          placement = "topRight"
        } = config;
        if (placement) {
          nextPlacements[placement] = nextPlacements[placement] || [];
          nextPlacements[placement].push(config);
        }
      });
      Object.keys(placements2).forEach((placement) => {
        nextPlacements[placement] = nextPlacements[placement] || [];
      });
      setPlacements(nextPlacements);
    }, [configList]);
    const onAllNoticeRemoved = (placement) => {
      setPlacements((originPlacements) => {
        const clone2 = {
          ...originPlacements
        };
        const list2 = clone2[placement] || [];
        if (!list2.length) {
          delete clone2[placement];
        }
        return clone2;
      });
    };
    const emptyRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      if (Object.keys(placements2).length > 0) {
        emptyRef.current = true;
      } else if (emptyRef.current) {
        onAllRemoved?.();
        emptyRef.current = false;
      }
    }, [placements2]);
    if (!container) {
      return null;
    }
    const placementList = Object.keys(placements2);
    return reactDomExports.createPortal( reactExports.createElement(reactExports.Fragment, null, placementList.map((placement) => {
      const placementConfigList = placements2[placement];
      const list2 = reactExports.createElement(NoticeList, {
        key: placement,
        configList: placementConfigList,
        placement,
        prefixCls,
        className: className?.(placement),
        style: style2?.(placement),
        motion: motion2,
        onNoticeClose,
        onAllNoticeRemoved,
        stack: stack2
      });
      return renderNotifications2 ? renderNotifications2(list2, {
        prefixCls,
        key: placement
      }) : list2;
    })), container);
  });
  const defaultGetContainer = () => document.body;
  let uniqueKey = 0;
  function mergeConfig(...objList) {
    const clone2 = {};
    objList.forEach((obj) => {
      if (obj) {
        Object.keys(obj).forEach((key) => {
          const val = obj[key];
          if (val !== void 0) {
            clone2[key] = val;
          }
        });
      }
    });
    return clone2;
  }
  function useNotification$1(rootConfig = {}) {
    const {
      getContainer: getContainer2 = defaultGetContainer,
      motion: motion2,
      prefixCls,
      maxCount,
      className,
      style: style2,
      onAllRemoved,
      stack: stack2,
      renderNotifications: renderNotifications2,
      ...shareConfig
    } = rootConfig;
    const [container, setContainer] = reactExports.useState();
    const notificationsRef = reactExports.useRef();
    const contextHolder = reactExports.createElement(Notifications, {
      container,
      ref: notificationsRef,
      prefixCls,
      motion: motion2,
      maxCount,
      className,
      style: style2,
      onAllRemoved,
      stack: stack2,
      renderNotifications: renderNotifications2
    });
    const [taskQueue2, setTaskQueue] = reactExports.useState([]);
    const open2 = useEvent$1((config) => {
      const mergedConfig = mergeConfig(shareConfig, config);
      if (mergedConfig.key === null || mergedConfig.key === void 0) {
        mergedConfig.key = `rc-notification-${uniqueKey}`;
        uniqueKey += 1;
      }
      setTaskQueue((queue) => [...queue, {
        type: "open",
        config: mergedConfig
      }]);
    });
    const api = reactExports.useMemo(() => ({
      open: open2,
      close: (key) => {
        setTaskQueue((queue) => [...queue, {
          type: "close",
          key
        }]);
      },
      destroy: () => {
        setTaskQueue((queue) => [...queue, {
          type: "destroy"
        }]);
      }
    }), []);
    reactExports.useEffect(() => {
      setContainer(getContainer2());
    });
    reactExports.useEffect(() => {
      if (notificationsRef.current && taskQueue2.length) {
        taskQueue2.forEach((task) => {
          switch (task.type) {
            case "open":
              notificationsRef.current.open(task.config);
              break;
            case "close":
              notificationsRef.current.close(task.key);
              break;
            case "destroy":
              notificationsRef.current.destroy();
              break;
          }
        });
        let oriTaskQueue;
        let tgtTaskQueue;
        setTaskQueue((oriQueue) => {
          if (oriTaskQueue !== oriQueue || !tgtTaskQueue) {
            oriTaskQueue = oriQueue;
            tgtTaskQueue = oriQueue.filter((task) => !taskQueue2.includes(task));
          }
          return tgtTaskQueue;
        });
      }
    }, [taskQueue2]);
    return [api, contextHolder];
  }
  var LoadingOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
  function _extends$T() {
    _extends$T = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$T.apply(this, arguments);
  }
  const LoadingOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends$T({}, props, {
    ref: ref2,
    icon: LoadingOutlined$1
  }));
  const RefIcon$h = reactExports.forwardRef(LoadingOutlined);
  const genMessageStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      boxShadow,
      colorText,
      colorSuccess,
      colorError,
      colorWarning,
      colorInfo,
      fontSizeLG,
      motionEaseInOutCirc,
      motionDurationSlow,
      marginXS,
      paddingXS,
      borderRadiusLG,
      zIndexPopup,
contentPadding,
      contentBg
    } = token2;
    const noticeCls = `${componentCls}-notice`;
    const messageMoveIn = new Keyframe("MessageMoveIn", {
      "0%": {
        padding: 0,
        transform: "translateY(-100%)",
        opacity: 0
      },
      "100%": {
        padding: paddingXS,
        transform: "translateY(0)",
        opacity: 1
      }
    });
    const messageMoveOut = new Keyframe("MessageMoveOut", {
      "0%": {
        maxHeight: token2.height,
        padding: paddingXS,
        opacity: 1
      },
      "100%": {
        maxHeight: 0,
        padding: 0,
        opacity: 0
      }
    });
    const noticeStyle = {
      padding: paddingXS,
      textAlign: "center",
      [`${componentCls}-custom-content`]: {
        display: "flex",
        alignItems: "center"
      },
      [`${componentCls}-custom-content > ${iconCls}`]: {
        marginInlineEnd: marginXS,
fontSize: fontSizeLG
      },
      [`${noticeCls}-content`]: {
        display: "inline-block",
        padding: contentPadding,
        background: contentBg,
        borderRadius: borderRadiusLG,
        boxShadow,
        pointerEvents: "all"
      },
      [`${componentCls}-success > ${iconCls}`]: {
        color: colorSuccess
      },
      [`${componentCls}-error > ${iconCls}`]: {
        color: colorError
      },
      [`${componentCls}-warning > ${iconCls}`]: {
        color: colorWarning
      },
      [`${componentCls}-info > ${iconCls},
      ${componentCls}-loading > ${iconCls}`]: {
        color: colorInfo
      }
    };
    return [
{
        [componentCls]: {
          ...resetComponent(token2),
          color: colorText,
          position: "fixed",
          top: marginXS,
          width: "100%",
          pointerEvents: "none",
          zIndex: zIndexPopup,
          [`${componentCls}-move-up`]: {
            animationFillMode: "forwards"
          },
          [`
        ${componentCls}-move-up-appear,
        ${componentCls}-move-up-enter
      `]: {
            animationName: messageMoveIn,
            animationDuration: motionDurationSlow,
            animationPlayState: "paused",
            animationTimingFunction: motionEaseInOutCirc
          },
          [`
        ${componentCls}-move-up-appear${componentCls}-move-up-appear-active,
        ${componentCls}-move-up-enter${componentCls}-move-up-enter-active
      `]: {
            animationPlayState: "running"
          },
          [`${componentCls}-move-up-leave`]: {
            animationName: messageMoveOut,
            animationDuration: motionDurationSlow,
            animationPlayState: "paused",
            animationTimingFunction: motionEaseInOutCirc
          },
          [`${componentCls}-move-up-leave${componentCls}-move-up-leave-active`]: {
            animationPlayState: "running"
          },
          "&-rtl": {
            direction: "rtl",
            span: {
              direction: "rtl"
            }
          }
        }
      },
{
        [componentCls]: {
          [`${noticeCls}-wrapper`]: {
            ...noticeStyle
          }
        }
      },
{
        [`${componentCls}-notice-pure-panel`]: {
          ...noticeStyle,
          padding: 0,
          textAlign: "start"
        }
      }
    ];
  };
  const prepareComponentToken$s = (token2) => ({
    zIndexPopup: token2.zIndexPopupBase + CONTAINER_MAX_OFFSET + 10,
    contentBg: token2.colorBgElevated,
    contentPadding: `${(token2.controlHeightLG - token2.fontSize * token2.lineHeight) / 2}px ${token2.paddingSM}px`
  });
  const useStyle$E = genStyleHooks("Message", (token2) => {
    const combinedToken = merge$1(token2, {
      height: 150
    });
    return genMessageStyle(combinedToken);
  }, prepareComponentToken$s);
  const TypeIcon = {
    info: reactExports.createElement(RefIcon$i, null),
    success: reactExports.createElement(RefIcon$m, null),
    error: reactExports.createElement(RefIcon$l, null),
    warning: reactExports.createElement(RefIcon$j, null),
    loading: reactExports.createElement(RefIcon$h, null)
  };
  const PureContent$1 = (props) => {
    const {
      prefixCls,
      type: type4,
      icon,
      children,
      classNames: pureContentClassNames,
      styles
    } = props;
    const iconElement = icon || type4 && TypeIcon[type4];
    const iconNode = cloneElement(iconElement, (currentProps) => {
      const mergedStyle = {
        ...currentProps?.style,
        ...styles?.icon
      };
      return {
        className: clsx(currentProps.className, pureContentClassNames?.icon),
        style: mergedStyle
      };
    });
    return reactExports.createElement("div", {
      className: clsx(`${prefixCls}-custom-content`, `${prefixCls}-${type4}`)
    }, iconNode, reactExports.createElement("span", {
      className: pureContentClassNames?.content,
      style: styles?.content
    }, children));
  };
  const PurePanel$a = (props) => {
    const {
      prefixCls: staticPrefixCls,
      className,
      style: style2,
      type: type4,
      icon,
      content,
      classNames: messageClassNames,
      styles,
      ...restProps
    } = props;
    const {
      getPrefixCls,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("message");
    const prefixCls = staticPrefixCls || getPrefixCls("message");
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$E(prefixCls, rootCls);
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, messageClassNames], [contextStyles, styles], {
      props
    });
    return reactExports.createElement(Notify, {
      ...restProps,
      prefixCls,
      className: clsx(contextClassName, mergedClassNames.root, className, hashId, `${prefixCls}-notice-pure-panel`, cssVarCls, rootCls),
      style: {
        ...mergedStyles.root,
        ...contextStyle,
        ...style2
      },
      eventKey: "pure",
      duration: null,
      content: reactExports.createElement(PureContent$1, {
        prefixCls,
        type: type4,
        icon,
        classNames: mergedClassNames,
        styles: mergedStyles
      }, content)
    });
  };
  function getMotion$2(prefixCls, transitionName) {
    return {
      motionName: transitionName ?? `${prefixCls}-move-up`
    };
  }
  function wrapPromiseFn(openFn) {
    let closeFn;
    const closePromise = new Promise((resolve) => {
      closeFn = openFn(() => {
        resolve(true);
      });
    });
    const result = () => {
      closeFn?.();
    };
    result.then = (filled, rejected) => closePromise.then(filled, rejected);
    result.promise = closePromise;
    return result;
  }
  const DEFAULT_OFFSET$1 = 8;
  const DEFAULT_DURATION$1 = 3;
  const Wrapper$1 = ({
    children,
    prefixCls
  }) => {
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$E(prefixCls, rootCls);
    return reactExports.createElement(NotificationProvider, {
      classNames: {
        list: clsx(hashId, cssVarCls, rootCls)
      }
    }, children);
  };
  const renderNotifications$1 = (node2, {
    prefixCls,
    key
  }) => reactExports.createElement(Wrapper$1, {
    prefixCls,
    key
  }, node2);
  const Holder$1 = reactExports.forwardRef((props, ref2) => {
    const {
      top,
      prefixCls: staticPrefixCls,
      getContainer: staticGetContainer,
      maxCount,
      duration: duration2 = DEFAULT_DURATION$1,
      rtl,
      transitionName,
      onAllRemoved,
      pauseOnHover = true
    } = props;
    const {
      getPrefixCls,
      direction,
      getPopupContainer
    } = useComponentConfig("message");
    const {
      message: message2
    } = reactExports.useContext(ConfigContext);
    const prefixCls = staticPrefixCls || getPrefixCls("message");
    const getStyle2 = () => ({
      left: "50%",
      transform: "translateX(-50%)",
      top: top ?? DEFAULT_OFFSET$1
    });
    const getClassName = () => clsx({
      [`${prefixCls}-rtl`]: rtl ?? direction === "rtl"
    });
    const getNotificationMotion = () => getMotion$2(prefixCls, transitionName);
    const [mergedClassNames, mergedStyles] = useMergeSemantic([props?.classNames, message2?.classNames], [props?.styles, message2?.styles], {
      props
    });
    const [api, holder] = useNotification$1({
      prefixCls,
      style: getStyle2,
      className: getClassName,
      motion: getNotificationMotion,
closable: false,
      duration: duration2,
      getContainer: () => staticGetContainer?.() || getPopupContainer?.() || document.body,
      maxCount,
      onAllRemoved,
      renderNotifications: renderNotifications$1,
      pauseOnHover
    });
    reactExports.useImperativeHandle(ref2, () => ({
      ...api,
      prefixCls,
      message: message2,
      classNames: mergedClassNames,
      styles: mergedStyles
    }));
    return holder;
  });
  let keyIndex = 0;
  function useInternalMessage(messageConfig2) {
    const holderRef = reactExports.useRef(null);
    const wrapAPI = reactExports.useMemo(() => {
      const close = (key) => {
        holderRef.current?.close(key);
      };
      const open2 = (config) => {
        if (!holderRef.current) {
          const fakeResult = () => {
          };
          fakeResult.then = () => {
          };
          return fakeResult;
        }
        const {
          open: originOpen,
          prefixCls,
          message: message2,
          classNames: originClassNames,
          styles: originStyles
        } = holderRef.current;
        const contextClassName = message2?.className || {};
        const contextStyle = message2?.style || {};
        const rawContextClassNames = message2?.classNames || {};
        const rawContextStyles = message2?.styles || {};
        const noticePrefixCls = `${prefixCls}-notice`;
        const {
          content,
          icon,
          type: type4,
          key,
          className,
          style: style2,
          onClose,
          classNames: configClassNames = {},
          styles = {},
          ...restConfig
        } = config;
        let mergedKey = key;
        if (!isNonNullable(mergedKey)) {
          keyIndex += 1;
          mergedKey = `antd-message-${keyIndex}`;
        }
        const contextConfig = {
          ...messageConfig2,
          ...config
        };
        const contextClassNames = resolveStyleOrClass(rawContextClassNames, {
          props: contextConfig
        });
        const semanticClassNames = resolveStyleOrClass(configClassNames, {
          props: contextConfig
        });
        const contextStyles = resolveStyleOrClass(rawContextStyles, {
          props: contextConfig
        });
        const semanticStyles = resolveStyleOrClass(styles, {
          props: contextConfig
        });
        const mergedClassNames = mergeClassNames(void 0, contextClassNames, semanticClassNames, originClassNames);
        const mergedStyles = mergeStyles(contextStyles, semanticStyles, originStyles);
        return wrapPromiseFn((resolve) => {
          originOpen({
            ...restConfig,
            key: mergedKey,
            content: reactExports.createElement(PureContent$1, {
              prefixCls,
              type: type4,
              icon,
              classNames: mergedClassNames,
              styles: mergedStyles
            }, content),
            placement: "top",
            className: clsx({
              [`${noticePrefixCls}-${type4}`]: type4
            }, className, contextClassName, mergedClassNames.root),
            style: {
              ...mergedStyles.root,
              ...contextStyle,
              ...style2
            },
            onClose: () => {
              onClose?.();
              resolve();
            }
          });
          return () => {
            close(mergedKey);
          };
        });
      };
      const destroy2 = (key) => {
        if (key !== void 0) {
          close(key);
        } else {
          holderRef.current?.destroy();
        }
      };
      const clone2 = {
        open: open2,
        destroy: destroy2
      };
      const keys2 = ["info", "success", "warning", "error", "loading"];
      keys2.forEach((type4) => {
        const typeOpen2 = (jointContent, duration2, onClose) => {
          let config;
          if (jointContent && typeof jointContent === "object" && "content" in jointContent) {
            config = jointContent;
          } else {
            config = {
              content: jointContent
            };
          }
          let mergedDuration;
          let mergedOnClose;
          if (typeof duration2 === "function") {
            mergedOnClose = duration2;
          } else {
            mergedDuration = duration2;
            mergedOnClose = onClose;
          }
          const mergedConfig = {
            onClose: mergedOnClose,
            duration: mergedDuration,
            ...config,
            type: type4
          };
          return open2(mergedConfig);
        };
        clone2[type4] = typeOpen2;
      });
      return clone2;
    }, []);
    return [wrapAPI, reactExports.createElement(Holder$1, {
      key: "message-holder",
      ...messageConfig2,
      ref: holderRef
    })];
  }
  function useMessage(messageConfig2) {
    return useInternalMessage(messageConfig2);
  }
  var client = { exports: {} };
  var reactDomClient_production = {};
  var scheduler = { exports: {} };
  var scheduler_production = {};
  var hasRequiredScheduler_production;
  function requireScheduler_production() {
    if (hasRequiredScheduler_production) return scheduler_production;
    hasRequiredScheduler_production = 1;
    (function(exports$1) {
      function push(heap, node2) {
        var index = heap.length;
        heap.push(node2);
        a: for (; 0 < index; ) {
          var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
          if (0 < compare(parent, node2))
            heap[parentIndex] = node2, heap[index] = parent, index = parentIndex;
          else break a;
        }
      }
      function peek2(heap) {
        return 0 === heap.length ? null : heap[0];
      }
      function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last = heap.pop();
        if (last !== first) {
          heap[0] = last;
          a: for (var index = 0, length2 = heap.length, halfLength = length2 >>> 1; index < halfLength; ) {
            var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
            if (0 > compare(left, last))
              rightIndex < length2 && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
            else if (rightIndex < length2 && 0 > compare(right, last))
              heap[index] = right, heap[rightIndex] = last, index = rightIndex;
            else break a;
          }
        }
        return first;
      }
      function compare(a2, b) {
        var diff = a2.sortIndex - b.sortIndex;
        return 0 !== diff ? diff : a2.id - b.id;
      }
      exports$1.unstable_now = void 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        exports$1.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        var localDate = Date, initialTime = localDate.now();
        exports$1.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      var taskQueue2 = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
      function advanceTimers(currentTime) {
        for (var timer = peek2(timerQueue); null !== timer; ) {
          if (null === timer.callback) pop(timerQueue);
          else if (timer.startTime <= currentTime)
            pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue2, timer);
          else break;
          timer = peek2(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled)
          if (null !== peek2(taskQueue2))
            isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
          else {
            var firstTimer = peek2(timerQueue);
            null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
          }
      }
      var isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
      function shouldYieldToHost() {
        return needsPaint ? true : exports$1.unstable_now() - startTime < frameInterval ? false : true;
      }
      function performWorkUntilDeadline() {
        needsPaint = false;
        if (isMessageLoopRunning) {
          var currentTime = exports$1.unstable_now();
          startTime = currentTime;
          var hasMoreWork = true;
          try {
            a: {
              isHostCallbackScheduled = false;
              isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
              isPerformingWork = true;
              var previousPriorityLevel = currentPriorityLevel;
              try {
                b: {
                  advanceTimers(currentTime);
                  for (currentTask = peek2(taskQueue2); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                    var callback = currentTask.callback;
                    if ("function" === typeof callback) {
                      currentTask.callback = null;
                      currentPriorityLevel = currentTask.priorityLevel;
                      var continuationCallback = callback(
                        currentTask.expirationTime <= currentTime
                      );
                      currentTime = exports$1.unstable_now();
                      if ("function" === typeof continuationCallback) {
                        currentTask.callback = continuationCallback;
                        advanceTimers(currentTime);
                        hasMoreWork = true;
                        break b;
                      }
                      currentTask === peek2(taskQueue2) && pop(taskQueue2);
                      advanceTimers(currentTime);
                    } else pop(taskQueue2);
                    currentTask = peek2(taskQueue2);
                  }
                  if (null !== currentTask) hasMoreWork = true;
                  else {
                    var firstTimer = peek2(timerQueue);
                    null !== firstTimer && requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                    hasMoreWork = false;
                  }
                }
                break a;
              } finally {
                currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
              }
              hasMoreWork = void 0;
            }
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
          }
        }
      }
      var schedulePerformWorkUntilDeadline;
      if ("function" === typeof localSetImmediate)
        schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      function requestHostTimeout(callback, ms2) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports$1.unstable_now());
        }, ms2);
      }
      exports$1.unstable_IdlePriority = 5;
      exports$1.unstable_ImmediatePriority = 1;
      exports$1.unstable_LowPriority = 4;
      exports$1.unstable_NormalPriority = 3;
      exports$1.unstable_Profiling = null;
      exports$1.unstable_UserBlockingPriority = 2;
      exports$1.unstable_cancelCallback = function(task) {
        task.callback = null;
      };
      exports$1.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
      };
      exports$1.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
      };
      exports$1.unstable_next = function(eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports$1.unstable_requestPaint = function() {
        needsPaint = true;
      };
      exports$1.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports$1.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports$1.unstable_now();
        "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch (priorityLevel) {
          case 1:
            var timeout = -1;
            break;
          case 2:
            timeout = 250;
            break;
          case 5:
            timeout = 1073741823;
            break;
          case 4:
            timeout = 1e4;
            break;
          default:
            timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: options,
          expirationTime: timeout,
          sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek2(taskQueue2) && priorityLevel === peek2(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue2, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
        return priorityLevel;
      };
      exports$1.unstable_shouldYield = shouldYieldToHost;
      exports$1.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      };
    })(scheduler_production);
    return scheduler_production;
  }
  var hasRequiredScheduler;
  function requireScheduler() {
    if (hasRequiredScheduler) return scheduler.exports;
    hasRequiredScheduler = 1;
    {
      scheduler.exports = requireScheduler_production();
    }
    return scheduler.exports;
  }
  var hasRequiredReactDomClient_production;
  function requireReactDomClient_production() {
    if (hasRequiredReactDomClient_production) return reactDomClient_production;
    hasRequiredReactDomClient_production = 1;
    var Scheduler = requireScheduler(), React2 = requireReact(), ReactDOM = requireReactDom();
    function formatProdErrorMessage(code) {
      var url2 = "https://react.dev/errors/" + code;
      if (1 < arguments.length) {
        url2 += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var i2 = 2; i2 < arguments.length; i2++)
          url2 += "&args[]=" + encodeURIComponent(arguments[i2]);
      }
      return "Minified React error #" + code + "; visit " + url2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function isValidContainer(node2) {
      return !(!node2 || 1 !== node2.nodeType && 9 !== node2.nodeType && 11 !== node2.nodeType);
    }
    function getNearestMountedFiber(fiber) {
      var node2 = fiber, nearestMounted = fiber;
      if (fiber.alternate) for (; node2.return; ) node2 = node2.return;
      else {
        fiber = node2;
        do
          node2 = fiber, 0 !== (node2.flags & 4098) && (nearestMounted = node2.return), fiber = node2.return;
        while (fiber);
      }
      return 3 === node2.tag ? nearestMounted : null;
    }
    function getSuspenseInstanceFromFiber(fiber) {
      if (13 === fiber.tag) {
        var suspenseState = fiber.memoizedState;
        null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
        if (null !== suspenseState) return suspenseState.dehydrated;
      }
      return null;
    }
    function getActivityInstanceFromFiber(fiber) {
      if (31 === fiber.tag) {
        var activityState = fiber.memoizedState;
        null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
        if (null !== activityState) return activityState.dehydrated;
      }
      return null;
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber)
        throw Error(formatProdErrorMessage(188));
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        alternate = getNearestMountedFiber(fiber);
        if (null === alternate) throw Error(formatProdErrorMessage(188));
        return alternate !== fiber ? null : fiber;
      }
      for (var a2 = fiber, b = alternate; ; ) {
        var parentA = a2.return;
        if (null === parentA) break;
        var parentB = parentA.alternate;
        if (null === parentB) {
          b = parentA.return;
          if (null !== b) {
            a2 = b;
            continue;
          }
          break;
        }
        if (parentA.child === parentB.child) {
          for (parentB = parentA.child; parentB; ) {
            if (parentB === a2) return assertIsMounted(parentA), fiber;
            if (parentB === b) return assertIsMounted(parentA), alternate;
            parentB = parentB.sibling;
          }
          throw Error(formatProdErrorMessage(188));
        }
        if (a2.return !== b.return) a2 = parentA, b = parentB;
        else {
          for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
            if (child$0 === a2) {
              didFindChild = true;
              a2 = parentA;
              b = parentB;
              break;
            }
            if (child$0 === b) {
              didFindChild = true;
              b = parentA;
              a2 = parentB;
              break;
            }
            child$0 = child$0.sibling;
          }
          if (!didFindChild) {
            for (child$0 = parentB.child; child$0; ) {
              if (child$0 === a2) {
                didFindChild = true;
                a2 = parentB;
                b = parentA;
                break;
              }
              if (child$0 === b) {
                didFindChild = true;
                b = parentB;
                a2 = parentA;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) throw Error(formatProdErrorMessage(189));
          }
        }
        if (a2.alternate !== b) throw Error(formatProdErrorMessage(190));
      }
      if (3 !== a2.tag) throw Error(formatProdErrorMessage(188));
      return a2.stateNode.current === a2 ? fiber : alternate;
    }
    function findCurrentHostFiberImpl(node2) {
      var tag = node2.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node2;
      for (node2 = node2.child; null !== node2; ) {
        tag = findCurrentHostFiberImpl(node2);
        if (null !== tag) return tag;
        node2 = node2.sibling;
      }
      return null;
    }
    var assign2 = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE2 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    function getComponentNameFromType(type4) {
      if (null == type4) return null;
      if ("function" === typeof type4)
        return type4.$$typeof === REACT_CLIENT_REFERENCE ? null : type4.displayName || type4.name || null;
      if ("string" === typeof type4) return type4;
      switch (type4) {
        case REACT_FRAGMENT_TYPE2:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type4)
        switch (type4.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type4.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type4._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type4.render;
            type4 = type4.displayName;
            type4 || (type4 = innerType.displayName || innerType.name || "", type4 = "" !== type4 ? "ForwardRef(" + type4 + ")" : "ForwardRef");
            return type4;
          case REACT_MEMO_TYPE:
            return innerType = type4.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type4.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type4._payload;
            type4 = type4._init;
            try {
              return getComponentNameFromType(type4(innerType));
            } catch (x) {
            }
        }
      return null;
    }
    var isArrayImpl = Array.isArray, ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
      pending: false,
      data: null,
      method: null,
      action: null
    }, valueStack = [], index = -1;
    function createCursor(defaultValue2) {
      return { current: defaultValue2 };
    }
    function pop(cursor2) {
      0 > index || (cursor2.current = valueStack[index], valueStack[index] = null, index--);
    }
    function push(cursor2, value) {
      index++;
      valueStack[index] = cursor2.current;
      cursor2.current = value;
    }
    var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null);
    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance);
      push(contextFiberStackCursor, fiber);
      push(contextStackCursor, null);
      switch (nextRootInstance.nodeType) {
        case 9:
        case 11:
          fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
          break;
        default:
          if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
            nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
          else
            switch (fiber) {
              case "svg":
                fiber = 1;
                break;
              case "math":
                fiber = 2;
                break;
              default:
                fiber = 0;
            }
      }
      pop(contextStackCursor);
      push(contextStackCursor, fiber);
    }
    function popHostContainer() {
      pop(contextStackCursor);
      pop(contextFiberStackCursor);
      pop(rootInstanceStackCursor);
    }
    function pushHostContext(fiber) {
      null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
      var context = contextStackCursor.current;
      var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
      context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
    }
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
      hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
    }
    var prefix2, suffix;
    function describeBuiltInComponentFrame(name) {
      if (void 0 === prefix2)
        try {
          throw Error();
        } catch (x) {
          var match2 = x.stack.trim().match(/\n( *(at )?)/);
          prefix2 = match2 && match2[1] || "";
          suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return "\n" + prefix2 + name + suffix;
    }
    var reentry = false;
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) return "";
      reentry = true;
      var previousPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function() {
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$1) {
                    control = x$1;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$2) {
                  control = x$2;
                }
                (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                });
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack)
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name"
        );
        namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
          for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
            RunInRootFrame++;
          for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
            "DetermineComponentFrameRoot"
          ); )
            namePropDescriptor++;
          if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
            for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
              namePropDescriptor--;
          for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
            if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
              if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                do
                  if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                    var frame2 = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                    fn.displayName && frame2.includes("<anonymous>") && (frame2 = frame2.replace("<anonymous>", fn.displayName));
                    return frame2;
                  }
                while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
              }
              break;
            }
        }
      } finally {
        reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
      }
      return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
    }
    function describeFiber(fiber, childFiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return describeBuiltInComponentFrame(fiber.type);
        case 16:
          return describeBuiltInComponentFrame("Lazy");
        case 13:
          return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
        case 19:
          return describeBuiltInComponentFrame("SuspenseList");
        case 0:
        case 15:
          return describeNativeComponentFrame(fiber.type, false);
        case 11:
          return describeNativeComponentFrame(fiber.type.render, false);
        case 1:
          return describeNativeComponentFrame(fiber.type, true);
        case 31:
          return describeBuiltInComponentFrame("Activity");
        default:
          return "";
      }
    }
    function getStackByFiberInDevAndProd(workInProgress2) {
      try {
        var info = "", previous = null;
        do
          info += describeFiber(workInProgress2, previous), previous = workInProgress2, workInProgress2 = workInProgress2.return;
        while (workInProgress2);
        return info;
      } catch (x) {
        return "\nError generating stack: " + x.message + "\n" + x.stack;
      }
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now2 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null;
    function setIsStrictModeForDevtools(newIsStrictMode) {
      "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
      if (injectedHook && "function" === typeof injectedHook.setStrictMode)
        try {
          injectedHook.setStrictMode(rendererID, newIsStrictMode);
        } catch (err) {
        }
    }
    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log2 = Math.log, LN2 = Math.LN2;
    function clz32Fallback(x) {
      x >>>= 0;
      return 0 === x ? 32 : 31 - (log2(x) / LN2 | 0) | 0;
    }
    var nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304;
    function getHighestPriorityLanes(lanes) {
      var pendingSyncLanes = lanes & 42;
      if (0 !== pendingSyncLanes) return pendingSyncLanes;
      switch (lanes & -lanes) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
          return lanes & 261888;
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return lanes & 3932160;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return lanes & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return lanes;
      }
    }
    function getNextLanes(root3, wipLanes, rootHasPendingCommit) {
      var pendingLanes = root3.pendingLanes;
      if (0 === pendingLanes) return 0;
      var nextLanes = 0, suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes;
      root3 = root3.warmLanes;
      var nonIdlePendingLanes = pendingLanes & 134217727;
      0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
      return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
    }
    function checkIfRootIsPrerendering(root3, renderLanes2) {
      return 0 === (root3.pendingLanes & ~(root3.suspendedLanes & ~root3.pingedLanes) & renderLanes2);
    }
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return currentTime + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return currentTime + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function claimNextRetryLane() {
      var lane = nextRetryLane;
      nextRetryLane <<= 1;
      0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
      return lane;
    }
    function createLaneMap(initial) {
      for (var laneMap = [], i2 = 0; 31 > i2; i2++) laneMap.push(initial);
      return laneMap;
    }
    function markRootUpdated$1(root3, updateLane) {
      root3.pendingLanes |= updateLane;
      268435456 !== updateLane && (root3.suspendedLanes = 0, root3.pingedLanes = 0, root3.warmLanes = 0);
    }
    function markRootFinished(root3, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
      var previouslyPendingLanes = root3.pendingLanes;
      root3.pendingLanes = remainingLanes;
      root3.suspendedLanes = 0;
      root3.pingedLanes = 0;
      root3.warmLanes = 0;
      root3.expiredLanes &= remainingLanes;
      root3.entangledLanes &= remainingLanes;
      root3.errorRecoveryDisabledLanes &= remainingLanes;
      root3.shellSuspendCounter = 0;
      var entanglements = root3.entanglements, expirationTimes = root3.expirationTimes, hiddenUpdates = root3.hiddenUpdates;
      for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
        var index$7 = 31 - clz32(remainingLanes), lane = 1 << index$7;
        entanglements[index$7] = 0;
        expirationTimes[index$7] = -1;
        var hiddenUpdatesForLane = hiddenUpdates[index$7];
        if (null !== hiddenUpdatesForLane)
          for (hiddenUpdates[index$7] = null, index$7 = 0; index$7 < hiddenUpdatesForLane.length; index$7++) {
            var update = hiddenUpdatesForLane[index$7];
            null !== update && (update.lane &= -536870913);
          }
        remainingLanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, 0);
      0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root3.tag && (root3.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
    }
    function markSpawnedDeferredLane(root3, spawnedLane, entangledLanes) {
      root3.pendingLanes |= spawnedLane;
      root3.suspendedLanes &= ~spawnedLane;
      var spawnedLaneIndex = 31 - clz32(spawnedLane);
      root3.entangledLanes |= spawnedLane;
      root3.entanglements[spawnedLaneIndex] = root3.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
    }
    function markRootEntangled(root3, entangledLanes) {
      var rootEntangledLanes = root3.entangledLanes |= entangledLanes;
      for (root3 = root3.entanglements; rootEntangledLanes; ) {
        var index$8 = 31 - clz32(rootEntangledLanes), lane = 1 << index$8;
        lane & entangledLanes | root3[index$8] & entangledLanes && (root3[index$8] |= entangledLanes);
        rootEntangledLanes &= ~lane;
      }
    }
    function getBumpedLaneForHydration(root3, renderLanes2) {
      var renderLane = renderLanes2 & -renderLanes2;
      renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
      return 0 !== (renderLane & (root3.suspendedLanes | renderLanes2)) ? 0 : renderLane;
    }
    function getBumpedLaneForHydrationByLane(lane) {
      switch (lane) {
        case 2:
          lane = 1;
          break;
        case 8:
          lane = 4;
          break;
        case 32:
          lane = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          lane = 128;
          break;
        case 268435456:
          lane = 134217728;
          break;
        default:
          lane = 0;
      }
      return lane;
    }
    function lanesToEventPriority(lanes) {
      lanes &= -lanes;
      return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
    }
    function resolveUpdatePriority() {
      var updatePriority = ReactDOMSharedInternals.p;
      if (0 !== updatePriority) return updatePriority;
      updatePriority = window.event;
      return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
    }
    function runWithPriority(priority, fn) {
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        return ReactDOMSharedInternals.p = priority, fn();
      } finally {
        ReactDOMSharedInternals.p = previousPriority;
      }
    }
    var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey;
    function detachDeletedInstance(node2) {
      delete node2[internalInstanceKey];
      delete node2[internalPropsKey];
      delete node2[internalEventHandlersKey];
      delete node2[internalEventHandlerListenersKey];
      delete node2[internalEventHandlesSetKey];
    }
    function getClosestInstanceFromNode(targetNode) {
      var targetInst = targetNode[internalInstanceKey];
      if (targetInst) return targetInst;
      for (var parentNode = targetNode.parentNode; parentNode; ) {
        if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
          parentNode = targetInst.alternate;
          if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
            for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode; ) {
              if (parentNode = targetNode[internalInstanceKey]) return parentNode;
              targetNode = getParentHydrationBoundary(targetNode);
            }
          return targetInst;
        }
        targetNode = parentNode;
        parentNode = targetNode.parentNode;
      }
      return null;
    }
    function getInstanceFromNode(node2) {
      if (node2 = node2[internalInstanceKey] || node2[internalContainerInstanceKey]) {
        var tag = node2.tag;
        if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag)
          return node2;
      }
      return null;
    }
    function getNodeFromInstance(inst) {
      var tag = inst.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
      throw Error(formatProdErrorMessage(33));
    }
    function getResourcesFromRoot(root3) {
      var resources = root3[internalRootNodeResourcesKey];
      resources || (resources = root3[internalRootNodeResourcesKey] = { hoistableStyles: new Map(), hoistableScripts: new Map() });
      return resources;
    }
    function markNodeAsHoistable(node2) {
      node2[internalHoistableMarker] = true;
    }
    var allNativeEvents = new Set(), registrationNameDependencies = {};
    function registerTwoPhaseEvent(registrationName, dependencies) {
      registerDirectEvent(registrationName, dependencies);
      registerDirectEvent(registrationName + "Capture", dependencies);
    }
    function registerDirectEvent(registrationName, dependencies) {
      registrationNameDependencies[registrationName] = dependencies;
      for (registrationName = 0; registrationName < dependencies.length; registrationName++)
        allNativeEvents.add(dependencies[registrationName]);
    }
    var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
        return true;
      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
        return validatedAttributeNameCache[attributeName] = true;
      illegalAttributeNameCache[attributeName] = true;
      return false;
    }
    function setValueForAttribute(node2, name, value) {
      if (isAttributeNameSafe(name))
        if (null === value) node2.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
              node2.removeAttribute(name);
              return;
            case "boolean":
              var prefix$10 = name.toLowerCase().slice(0, 5);
              if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
                node2.removeAttribute(name);
                return;
              }
          }
          node2.setAttribute(name, "" + value);
        }
    }
    function setValueForKnownAttribute(node2, name, value) {
      if (null === value) node2.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node2.removeAttribute(name);
            return;
        }
        node2.setAttribute(name, "" + value);
      }
    }
    function setValueForNamespacedAttribute(node2, namespace, name, value) {
      if (null === value) node2.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node2.removeAttribute(name);
            return;
        }
        node2.setAttributeNS(namespace, name, "" + value);
      }
    }
    function getToStringValue(value) {
      switch (typeof value) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return value;
        case "object":
          return value;
        default:
          return "";
      }
    }
    function isCheckable(elem) {
      var type4 = elem.type;
      return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type4 || "radio" === type4);
    }
    function trackValueOnNode(node2, valueField, currentValue) {
      var descriptor = Object.getOwnPropertyDescriptor(
        node2.constructor.prototype,
        valueField
      );
      if (!node2.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
        var get2 = descriptor.get, set2 = descriptor.set;
        Object.defineProperty(node2, valueField, {
          configurable: true,
          get: function() {
            return get2.call(this);
          },
          set: function(value) {
            currentValue = "" + value;
            set2.call(this, value);
          }
        });
        Object.defineProperty(node2, valueField, {
          enumerable: descriptor.enumerable
        });
        return {
          getValue: function() {
            return currentValue;
          },
          setValue: function(value) {
            currentValue = "" + value;
          },
          stopTracking: function() {
            node2._valueTracker = null;
            delete node2[valueField];
          }
        };
      }
    }
    function track(node2) {
      if (!node2._valueTracker) {
        var valueField = isCheckable(node2) ? "checked" : "value";
        node2._valueTracker = trackValueOnNode(
          node2,
          valueField,
          "" + node2[valueField]
        );
      }
    }
    function updateValueIfChanged(node2) {
      if (!node2) return false;
      var tracker = node2._valueTracker;
      if (!tracker) return true;
      var lastValue = tracker.getValue();
      var value = "";
      node2 && (value = isCheckable(node2) ? node2.checked ? "true" : "false" : node2.value);
      node2 = value;
      return node2 !== lastValue ? (tracker.setValue(node2), true) : false;
    }
    function getActiveElement(doc) {
      doc = doc || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof doc) return null;
      try {
        return doc.activeElement || doc.body;
      } catch (e) {
        return doc.body;
      }
    }
    var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
    function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
      return value.replace(
        escapeSelectorAttributeValueInsideDoubleQuotesRegex,
        function(ch) {
          return "\\" + ch.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    function updateInput(element, value, defaultValue2, lastDefaultValue, checked, defaultChecked, type4, name) {
      element.name = "";
      null != type4 && "function" !== typeof type4 && "symbol" !== typeof type4 && "boolean" !== typeof type4 ? element.type = type4 : element.removeAttribute("type");
      if (null != value)
        if ("number" === type4) {
          if (0 === value && "" === element.value || element.value != value)
            element.value = "" + getToStringValue(value);
        } else
          element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
      else
        "submit" !== type4 && "reset" !== type4 || element.removeAttribute("value");
      null != value ? setDefaultValue(element, type4, getToStringValue(value)) : null != defaultValue2 ? setDefaultValue(element, type4, getToStringValue(defaultValue2)) : null != lastDefaultValue && element.removeAttribute("value");
      null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
      null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
      null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
    }
    function initInput(element, value, defaultValue2, checked, defaultChecked, type4, name, isHydrating2) {
      null != type4 && "function" !== typeof type4 && "symbol" !== typeof type4 && "boolean" !== typeof type4 && (element.type = type4);
      if (null != value || null != defaultValue2) {
        if (!("submit" !== type4 && "reset" !== type4 || void 0 !== value && null !== value)) {
          track(element);
          return;
        }
        defaultValue2 = null != defaultValue2 ? "" + getToStringValue(defaultValue2) : "";
        value = null != value ? "" + getToStringValue(value) : defaultValue2;
        isHydrating2 || value === element.value || (element.value = value);
        element.defaultValue = value;
      }
      checked = null != checked ? checked : defaultChecked;
      checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
      element.checked = isHydrating2 ? element.checked : !!checked;
      element.defaultChecked = !!checked;
      null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
      track(element);
    }
    function setDefaultValue(node2, type4, value) {
      "number" === type4 && getActiveElement(node2.ownerDocument) === node2 || node2.defaultValue === "" + value || (node2.defaultValue = "" + value);
    }
    function updateOptions(node2, multiple, propValue, setDefaultSelected) {
      node2 = node2.options;
      if (multiple) {
        multiple = {};
        for (var i2 = 0; i2 < propValue.length; i2++)
          multiple["$" + propValue[i2]] = true;
        for (propValue = 0; propValue < node2.length; propValue++)
          i2 = multiple.hasOwnProperty("$" + node2[propValue].value), node2[propValue].selected !== i2 && (node2[propValue].selected = i2), i2 && setDefaultSelected && (node2[propValue].defaultSelected = true);
      } else {
        propValue = "" + getToStringValue(propValue);
        multiple = null;
        for (i2 = 0; i2 < node2.length; i2++) {
          if (node2[i2].value === propValue) {
            node2[i2].selected = true;
            setDefaultSelected && (node2[i2].defaultSelected = true);
            return;
          }
          null !== multiple || node2[i2].disabled || (multiple = node2[i2]);
        }
        null !== multiple && (multiple.selected = true);
      }
    }
    function updateTextarea(element, value, defaultValue2) {
      if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue2)) {
        element.defaultValue !== value && (element.defaultValue = value);
        return;
      }
      element.defaultValue = null != defaultValue2 ? "" + getToStringValue(defaultValue2) : "";
    }
    function initTextarea(element, value, defaultValue2, children) {
      if (null == value) {
        if (null != children) {
          if (null != defaultValue2) throw Error(formatProdErrorMessage(92));
          if (isArrayImpl(children)) {
            if (1 < children.length) throw Error(formatProdErrorMessage(93));
            children = children[0];
          }
          defaultValue2 = children;
        }
        null == defaultValue2 && (defaultValue2 = "");
        value = defaultValue2;
      }
      defaultValue2 = getToStringValue(value);
      element.defaultValue = defaultValue2;
      children = element.textContent;
      children === defaultValue2 && "" !== children && null !== children && (element.value = children);
      track(element);
    }
    function setTextContent(node2, text) {
      if (text) {
        var firstChild = node2.firstChild;
        if (firstChild && firstChild === node2.lastChild && 3 === firstChild.nodeType) {
          firstChild.nodeValue = text;
          return;
        }
      }
      node2.textContent = text;
    }
    var unitlessNumbers = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    );
    function setValueForStyle(style3, styleName, value) {
      var isCustomProperty3 = 0 === styleName.indexOf("--");
      null == value || "boolean" === typeof value || "" === value ? isCustomProperty3 ? style3.setProperty(styleName, "") : "float" === styleName ? style3.cssFloat = "" : style3[styleName] = "" : isCustomProperty3 ? style3.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style3.cssFloat = value : style3[styleName] = ("" + value).trim() : style3[styleName] = value + "px";
    }
    function setValueForStyles(node2, styles, prevStyles) {
      if (null != styles && "object" !== typeof styles)
        throw Error(formatProdErrorMessage(62));
      node2 = node2.style;
      if (null != prevStyles) {
        for (var styleName in prevStyles)
          !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node2.setProperty(styleName, "") : "float" === styleName ? node2.cssFloat = "" : node2[styleName] = "");
        for (var styleName$16 in styles)
          styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node2, styleName$16, styleName);
      } else
        for (var styleName$17 in styles)
          styles.hasOwnProperty(styleName$17) && setValueForStyle(node2, styleName$17, styles[styleName$17]);
    }
    function isCustomElement(tagName) {
      if (-1 === tagName.indexOf("-")) return false;
      switch (tagName) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var aliases = new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function sanitizeURL(url2) {
      return isJavaScriptProtocol.test("" + url2) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url2;
    }
    function noop$12() {
    }
    var currentReplayingEvent = null;
    function getEventTarget(nativeEvent) {
      nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
      nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
      return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
    }
    var restoreTarget = null, restoreQueue = null;
    function restoreStateOfTarget(target) {
      var internalInstance = getInstanceFromNode(target);
      if (internalInstance && (target = internalInstance.stateNode)) {
        var props = target[internalPropsKey] || null;
        a: switch (target = internalInstance.stateNode, internalInstance.type) {
          case "input":
            updateInput(
              target,
              props.value,
              props.defaultValue,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name
            );
            internalInstance = props.name;
            if ("radio" === props.type && null != internalInstance) {
              for (props = target; props.parentNode; ) props = props.parentNode;
              props = props.querySelectorAll(
                'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                  "" + internalInstance
                ) + '"][type="radio"]'
              );
              for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                var otherNode = props[internalInstance];
                if (otherNode !== target && otherNode.form === target.form) {
                  var otherProps = otherNode[internalPropsKey] || null;
                  if (!otherProps) throw Error(formatProdErrorMessage(90));
                  updateInput(
                    otherNode,
                    otherProps.value,
                    otherProps.defaultValue,
                    otherProps.defaultValue,
                    otherProps.checked,
                    otherProps.defaultChecked,
                    otherProps.type,
                    otherProps.name
                  );
                }
              }
              for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
            }
            break a;
          case "textarea":
            updateTextarea(target, props.value, props.defaultValue);
            break a;
          case "select":
            internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
        }
      }
    }
    var isInsideEventHandler = false;
    function batchedUpdates$1(fn, a2, b) {
      if (isInsideEventHandler) return fn(a2, b);
      isInsideEventHandler = true;
      try {
        var JSCompiler_inline_result = fn(a2);
        return JSCompiler_inline_result;
      } finally {
        if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
          if (flushSyncWork$1(), restoreTarget && (a2 = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a2), fn))
            for (a2 = 0; a2 < fn.length; a2++) restoreStateOfTarget(fn[a2]);
        }
      }
    }
    function getListener(inst, registrationName) {
      var stateNode = inst.stateNode;
      if (null === stateNode) return null;
      var props = stateNode[internalPropsKey] || null;
      if (null === props) return null;
      stateNode = props[registrationName];
      a: switch (registrationName) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
          inst = !props;
          break a;
        default:
          inst = false;
      }
      if (inst) return null;
      if (stateNode && "function" !== typeof stateNode)
        throw Error(
          formatProdErrorMessage(231, registrationName, typeof stateNode)
        );
      return stateNode;
    }
    var canUseDOM2 = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
    if (canUseDOM2)
      try {
        var options = {};
        Object.defineProperty(options, "passive", {
          get: function() {
            passiveBrowserEventsSupported = true;
          }
        });
        window.addEventListener("test", options, options);
        window.removeEventListener("test", options, options);
      } catch (e) {
        passiveBrowserEventsSupported = false;
      }
    var root2 = null, startText = null, fallbackText = null;
    function getData() {
      if (fallbackText) return fallbackText;
      var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root2 ? root2.value : root2.textContent, endLength = endValue.length;
      for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
      var minEnd = startLength - start;
      for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
      return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
    }
    function getEventCharCode(nativeEvent) {
      var keyCode = nativeEvent.keyCode;
      "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
      10 === nativeEvent && (nativeEvent = 13);
      return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
    }
    function functionThatReturnsTrue() {
      return true;
    }
    function functionThatReturnsFalse() {
      return false;
    }
    function createSyntheticEvent(Interface) {
      function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
        this._reactName = reactName;
        this._targetInst = targetInst;
        this.type = reactEventType;
        this.nativeEvent = nativeEvent;
        this.target = nativeEventTarget;
        this.currentTarget = null;
        for (var propName in Interface)
          Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
        this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }
      assign2(SyntheticBaseEvent.prototype, {
        preventDefault: function() {
          this.defaultPrevented = true;
          var event = this.nativeEvent;
          event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
        },
        stopPropagation: function() {
          var event = this.nativeEvent;
          event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
        },
        persist: function() {
        },
        isPersistent: functionThatReturnsTrue
      });
      return SyntheticBaseEvent;
    }
    var EventInterface = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign2({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign2({}, UIEventInterface, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: getEventModifierState,
      button: 0,
      buttons: 0,
      relatedTarget: function(event) {
        return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
      },
      movementX: function(event) {
        if ("movementX" in event) return event.movementX;
        event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
        return lastMovementX;
      },
      movementY: function(event) {
        return "movementY" in event ? event.movementY : lastMovementY;
      }
    }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign2({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign2({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign2({}, EventInterface, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign2({}, EventInterface, {
      clipboardData: function(event) {
        return "clipboardData" in event ? event.clipboardData : window.clipboardData;
      }
    }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign2({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, translateToKey = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, modifierKeyToProp = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function modifierStateGetter(keyArg) {
      var nativeEvent = this.nativeEvent;
      return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
    }
    function getEventModifierState() {
      return modifierStateGetter;
    }
    var KeyboardEventInterface = assign2({}, UIEventInterface, {
      key: function(nativeEvent) {
        if (nativeEvent.key) {
          var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
          if ("Unidentified" !== key) return key;
        }
        return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: getEventModifierState,
      charCode: function(event) {
        return "keypress" === event.type ? getEventCharCode(event) : 0;
      },
      keyCode: function(event) {
        return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
      },
      which: function(event) {
        return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
      }
    }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign2({}, MouseEventInterface, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign2({}, UIEventInterface, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: getEventModifierState
    }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign2({}, EventInterface, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign2({}, MouseEventInterface, {
      deltaX: function(event) {
        return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
      },
      deltaY: function(event) {
        return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign2({}, EventInterface, {
      newState: 0,
      oldState: 0
    }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], canUseCompositionEvent = canUseDOM2 && "CompositionEvent" in window, documentMode = null;
    canUseDOM2 && "documentMode" in document && (documentMode = document.documentMode);
    var canUseTextInputEvent = canUseDOM2 && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM2 && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CHAR = String.fromCharCode(32), hasSpaceKeypress = false;
    function isFallbackCompositionEnd(domEventName, nativeEvent) {
      switch (domEventName) {
        case "keyup":
          return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
        case "keydown":
          return 229 !== nativeEvent.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function getDataFromCustomEvent(nativeEvent) {
      nativeEvent = nativeEvent.detail;
      return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
    }
    var isComposing = false;
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
      switch (domEventName) {
        case "compositionend":
          return getDataFromCustomEvent(nativeEvent);
        case "keypress":
          if (32 !== nativeEvent.which) return null;
          hasSpaceKeypress = true;
          return SPACEBAR_CHAR;
        case "textInput":
          return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
        default:
          return null;
      }
    }
    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
      if (isComposing)
        return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root2 = null, isComposing = false, domEventName) : null;
      switch (domEventName) {
        case "paste":
          return null;
        case "keypress":
          if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
            if (nativeEvent.char && 1 < nativeEvent.char.length)
              return nativeEvent.char;
            if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
          }
          return null;
        case "compositionend":
          return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
        default:
          return null;
      }
    }
    var supportedInputTypes = {
      color: true,
      date: true,
      datetime: true,
      "datetime-local": true,
      email: true,
      month: true,
      number: true,
      password: true,
      range: true,
      search: true,
      tel: true,
      text: true,
      time: true,
      url: true,
      week: true
    };
    function isTextInputElement(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
    }
    function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
      restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
      inst = accumulateTwoPhaseListeners(inst, "onChange");
      0 < inst.length && (nativeEvent = new SyntheticEvent(
        "onChange",
        "change",
        null,
        nativeEvent,
        target
      ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
    }
    var activeElement$1 = null, activeElementInst$1 = null;
    function runEventInBatch(dispatchQueue) {
      processDispatchQueue(dispatchQueue, 0);
    }
    function getInstIfValueChanged(targetInst) {
      var targetNode = getNodeFromInstance(targetInst);
      if (updateValueIfChanged(targetNode)) return targetInst;
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
      if ("change" === domEventName) return targetInst;
    }
    var isInputEventSupported = false;
    if (canUseDOM2) {
      var JSCompiler_inline_result$jscomp$286;
      if (canUseDOM2) {
        var isSupported$jscomp$inline_427 = "oninput" in document;
        if (!isSupported$jscomp$inline_427) {
          var element$jscomp$inline_428 = document.createElement("div");
          element$jscomp$inline_428.setAttribute("oninput", "return;");
          isSupported$jscomp$inline_427 = "function" === typeof element$jscomp$inline_428.oninput;
        }
        JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
      } else JSCompiler_inline_result$jscomp$286 = false;
      isInputEventSupported = JSCompiler_inline_result$jscomp$286 && (!document.documentMode || 9 < document.documentMode);
    }
    function stopWatchingForValueChange() {
      activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
    }
    function handlePropertyChange(nativeEvent) {
      if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(
          dispatchQueue,
          activeElementInst$1,
          nativeEvent,
          getEventTarget(nativeEvent)
        );
        batchedUpdates$1(runEventInBatch, dispatchQueue);
      }
    }
    function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
      "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
    }
    function getTargetInstForInputEventPolyfill(domEventName) {
      if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
        return getInstIfValueChanged(activeElementInst$1);
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
      if ("click" === domEventName) return getInstIfValueChanged(targetInst);
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
      if ("input" === domEventName || "change" === domEventName)
        return getInstIfValueChanged(targetInst);
    }
    function is(x, y) {
      return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    var objectIs2 = "function" === typeof Object.is ? Object.is : is;
    function shallowEqual(objA, objB) {
      if (objectIs2(objA, objB)) return true;
      if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
        return false;
      var keysA = Object.keys(objA), keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) return false;
      for (keysB = 0; keysB < keysA.length; keysB++) {
        var currentKey = keysA[keysB];
        if (!hasOwnProperty.call(objB, currentKey) || !objectIs2(objA[currentKey], objB[currentKey]))
          return false;
      }
      return true;
    }
    function getLeafNode(node2) {
      for (; node2 && node2.firstChild; ) node2 = node2.firstChild;
      return node2;
    }
    function getNodeForCharacterOffset(root3, offset2) {
      var node2 = getLeafNode(root3);
      root3 = 0;
      for (var nodeEnd; node2; ) {
        if (3 === node2.nodeType) {
          nodeEnd = root3 + node2.textContent.length;
          if (root3 <= offset2 && nodeEnd >= offset2)
            return { node: node2, offset: offset2 - root3 };
          root3 = nodeEnd;
        }
        a: {
          for (; node2; ) {
            if (node2.nextSibling) {
              node2 = node2.nextSibling;
              break a;
            }
            node2 = node2.parentNode;
          }
          node2 = void 0;
        }
        node2 = getLeafNode(node2);
      }
    }
    function containsNode(outerNode, innerNode) {
      return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
    }
    function getActiveElementDeep(containerInfo) {
      containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
      for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
        try {
          var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
        } catch (err) {
          JSCompiler_inline_result = false;
        }
        if (JSCompiler_inline_result) containerInfo = element.contentWindow;
        else break;
        element = getActiveElement(containerInfo.document);
      }
      return element;
    }
    function hasSelectionCapabilities(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
    }
    var skipSelectionChangeEvent = canUseDOM2 && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false;
    function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
      var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
      mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
        anchorNode: doc.anchorNode,
        anchorOffset: doc.anchorOffset,
        focusNode: doc.focusNode,
        focusOffset: doc.focusOffset
      }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
        "onSelect",
        "select",
        null,
        nativeEvent,
        nativeEventTarget
      ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
    }
    function makePrefixMap2(styleProp, eventName) {
      var prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit" + styleProp] = "webkit" + eventName;
      prefixes["Moz" + styleProp] = "moz" + eventName;
      return prefixes;
    }
    var vendorPrefixes2 = {
      animationend: makePrefixMap2("Animation", "AnimationEnd"),
      animationiteration: makePrefixMap2("Animation", "AnimationIteration"),
      animationstart: makePrefixMap2("Animation", "AnimationStart"),
      transitionrun: makePrefixMap2("Transition", "TransitionRun"),
      transitionstart: makePrefixMap2("Transition", "TransitionStart"),
      transitioncancel: makePrefixMap2("Transition", "TransitionCancel"),
      transitionend: makePrefixMap2("Transition", "TransitionEnd")
    }, prefixedEventNames2 = {}, style2 = {};
    canUseDOM2 && (style2 = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes2.animationend.animation, delete vendorPrefixes2.animationiteration.animation, delete vendorPrefixes2.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes2.transitionend.transition);
    function getVendorPrefixedEventName2(eventName) {
      if (prefixedEventNames2[eventName]) return prefixedEventNames2[eventName];
      if (!vendorPrefixes2[eventName]) return eventName;
      var prefixMap = vendorPrefixes2[eventName], styleProp;
      for (styleProp in prefixMap)
        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style2)
          return prefixedEventNames2[eventName] = prefixMap[styleProp];
      return eventName;
    }
    var ANIMATION_END = getVendorPrefixedEventName2("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName2("animationiteration"), ANIMATION_START = getVendorPrefixedEventName2("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName2("transitionrun"), TRANSITION_START = getVendorPrefixedEventName2("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName2("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName2("transitionend"), topLevelEventsToReactNames = new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
    simpleEventPluginEvents.push("scrollEnd");
    function registerSimpleEvent(domEventName, reactName) {
      topLevelEventsToReactNames.set(domEventName, reactName);
      registerTwoPhaseEvent(reactName, [domEventName]);
    }
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    }, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0;
    function finishQueueingConcurrentUpdates() {
      for (var endIndex = concurrentQueuesIndex, i2 = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i2 < endIndex; ) {
        var fiber = concurrentQueues[i2];
        concurrentQueues[i2++] = null;
        var queue = concurrentQueues[i2];
        concurrentQueues[i2++] = null;
        var update = concurrentQueues[i2];
        concurrentQueues[i2++] = null;
        var lane = concurrentQueues[i2];
        concurrentQueues[i2++] = null;
        if (null !== queue && null !== update) {
          var pending = queue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
      }
    }
    function enqueueUpdate$1(fiber, queue, update, lane) {
      concurrentQueues[concurrentQueuesIndex++] = fiber;
      concurrentQueues[concurrentQueuesIndex++] = queue;
      concurrentQueues[concurrentQueuesIndex++] = update;
      concurrentQueues[concurrentQueuesIndex++] = lane;
      concurrentlyUpdatedLanes |= lane;
      fiber.lanes |= lane;
      fiber = fiber.alternate;
      null !== fiber && (fiber.lanes |= lane);
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
      enqueueUpdate$1(fiber, queue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
      enqueueUpdate$1(fiber, null, null, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
      sourceFiber.lanes |= lane;
      var alternate = sourceFiber.alternate;
      null !== alternate && (alternate.lanes |= lane);
      for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
        parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
      return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
    }
    function getRootForUpdatedFiber(sourceFiber) {
      if (50 < nestedUpdateCount)
        throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
      for (var parent = sourceFiber.return; null !== parent; )
        sourceFiber = parent, parent = sourceFiber.return;
      return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
    }
    var emptyContextObject = {};
    function FiberNode(tag, pendingProps, key, mode) {
      this.tag = tag;
      this.key = key;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.refCleanup = this.ref = null;
      this.pendingProps = pendingProps;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = mode;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function createFiberImplClass(tag, pendingProps, key, mode) {
      return new FiberNode(tag, pendingProps, key, mode);
    }
    function shouldConstruct(Component) {
      Component = Component.prototype;
      return !(!Component || !Component.isReactComponent);
    }
    function createWorkInProgress(current, pendingProps) {
      var workInProgress2 = current.alternate;
      null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
        current.tag,
        pendingProps,
        current.key,
        current.mode
      ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
      workInProgress2.flags = current.flags & 65011712;
      workInProgress2.childLanes = current.childLanes;
      workInProgress2.lanes = current.lanes;
      workInProgress2.child = current.child;
      workInProgress2.memoizedProps = current.memoizedProps;
      workInProgress2.memoizedState = current.memoizedState;
      workInProgress2.updateQueue = current.updateQueue;
      pendingProps = current.dependencies;
      workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
      workInProgress2.sibling = current.sibling;
      workInProgress2.index = current.index;
      workInProgress2.ref = current.ref;
      workInProgress2.refCleanup = current.refCleanup;
      return workInProgress2;
    }
    function resetWorkInProgress(workInProgress2, renderLanes2) {
      workInProgress2.flags &= 65011714;
      var current = workInProgress2.alternate;
      null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
        lanes: renderLanes2.lanes,
        firstContext: renderLanes2.firstContext
      });
      return workInProgress2;
    }
    function createFiberFromTypeAndProps(type4, key, pendingProps, owner, mode, lanes) {
      var fiberTag = 0;
      owner = type4;
      if ("function" === typeof type4) shouldConstruct(type4) && (fiberTag = 1);
      else if ("string" === typeof type4)
        fiberTag = isHostHoistableType(
          type4,
          pendingProps,
          contextStackCursor.current
        ) ? 26 : "html" === type4 || "head" === type4 || "body" === type4 ? 27 : 5;
      else
        a: switch (type4) {
          case REACT_ACTIVITY_TYPE:
            return type4 = createFiberImplClass(31, pendingProps, key, mode), type4.elementType = REACT_ACTIVITY_TYPE, type4.lanes = lanes, type4;
          case REACT_FRAGMENT_TYPE2:
            return createFiberFromFragment(pendingProps.children, mode, lanes, key);
          case REACT_STRICT_MODE_TYPE:
            fiberTag = 8;
            mode |= 24;
            break;
          case REACT_PROFILER_TYPE:
            return type4 = createFiberImplClass(12, pendingProps, key, mode | 2), type4.elementType = REACT_PROFILER_TYPE, type4.lanes = lanes, type4;
          case REACT_SUSPENSE_TYPE:
            return type4 = createFiberImplClass(13, pendingProps, key, mode), type4.elementType = REACT_SUSPENSE_TYPE, type4.lanes = lanes, type4;
          case REACT_SUSPENSE_LIST_TYPE:
            return type4 = createFiberImplClass(19, pendingProps, key, mode), type4.elementType = REACT_SUSPENSE_LIST_TYPE, type4.lanes = lanes, type4;
          default:
            if ("object" === typeof type4 && null !== type4)
              switch (type4.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  fiberTag = 10;
                  break a;
                case REACT_CONSUMER_TYPE:
                  fiberTag = 9;
                  break a;
                case REACT_FORWARD_REF_TYPE:
                  fiberTag = 11;
                  break a;
                case REACT_MEMO_TYPE:
                  fiberTag = 14;
                  break a;
                case REACT_LAZY_TYPE:
                  fiberTag = 16;
                  owner = null;
                  break a;
              }
            fiberTag = 29;
            pendingProps = Error(
              formatProdErrorMessage(130, null === type4 ? "null" : typeof type4, "")
            );
            owner = null;
        }
      key = createFiberImplClass(fiberTag, pendingProps, key, mode);
      key.elementType = type4;
      key.type = owner;
      key.lanes = lanes;
      return key;
    }
    function createFiberFromFragment(elements, mode, lanes, key) {
      elements = createFiberImplClass(7, elements, key, mode);
      elements.lanes = lanes;
      return elements;
    }
    function createFiberFromText(content, mode, lanes) {
      content = createFiberImplClass(6, content, null, mode);
      content.lanes = lanes;
      return content;
    }
    function createFiberFromDehydratedFragment(dehydratedNode) {
      var fiber = createFiberImplClass(18, null, null, 0);
      fiber.stateNode = dehydratedNode;
      return fiber;
    }
    function createFiberFromPortal(portal, mode, lanes) {
      mode = createFiberImplClass(
        4,
        null !== portal.children ? portal.children : [],
        portal.key,
        mode
      );
      mode.lanes = lanes;
      mode.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation
      };
      return mode;
    }
    var CapturedStacks = new WeakMap();
    function createCapturedValueAtFiber(value, source) {
      if ("object" === typeof value && null !== value) {
        var existing = CapturedStacks.get(value);
        if (void 0 !== existing) return existing;
        source = {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
        CapturedStacks.set(value, source);
        return source;
      }
      return {
        value,
        source,
        stack: getStackByFiberInDevAndProd(source)
      };
    }
    var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
    function pushTreeFork(workInProgress2, totalChildren) {
      forkStack[forkStackIndex++] = treeForkCount;
      forkStack[forkStackIndex++] = treeForkProvider;
      treeForkProvider = workInProgress2;
      treeForkCount = totalChildren;
    }
    function pushTreeId(workInProgress2, totalChildren, index2) {
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextProvider = workInProgress2;
      var baseIdWithLeadingBit = treeContextId;
      workInProgress2 = treeContextOverflow;
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index2 += 1;
      var length2 = 32 - clz32(totalChildren) + baseLength;
      if (30 < length2) {
        var numberOfOverflowBits = baseLength - baseLength % 5;
        length2 = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit;
        treeContextOverflow = length2 + workInProgress2;
      } else
        treeContextId = 1 << length2 | index2 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
    }
    function pushMaterializedTreeId(workInProgress2) {
      null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
    }
    function popTreeContext(workInProgress2) {
      for (; workInProgress2 === treeForkProvider; )
        treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
      for (; workInProgress2 === treeContextProvider; )
        treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
    }
    function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextId = suspendedContext.id;
      treeContextOverflow = suspendedContext.overflow;
      treeContextProvider = workInProgress2;
    }
    var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(formatProdErrorMessage(519));
    function throwOnHydrationMismatch(fiber) {
      var error = Error(
        formatProdErrorMessage(
          418,
          1 < arguments.length && void 0 !== arguments[1] && arguments[1] ? "text" : "HTML",
          ""
        )
      );
      queueHydrationError(createCapturedValueAtFiber(error, fiber));
      throw HydrationMismatchException;
    }
    function prepareToHydrateHostInstance(fiber) {
      var instance = fiber.stateNode, type4 = fiber.type, props = fiber.memoizedProps;
      instance[internalInstanceKey] = fiber;
      instance[internalPropsKey] = props;
      switch (type4) {
        case "dialog":
          listenToNonDelegatedEvent("cancel", instance);
          listenToNonDelegatedEvent("close", instance);
          break;
        case "iframe":
        case "object":
        case "embed":
          listenToNonDelegatedEvent("load", instance);
          break;
        case "video":
        case "audio":
          for (type4 = 0; type4 < mediaEventTypes.length; type4++)
            listenToNonDelegatedEvent(mediaEventTypes[type4], instance);
          break;
        case "source":
          listenToNonDelegatedEvent("error", instance);
          break;
        case "img":
        case "image":
        case "link":
          listenToNonDelegatedEvent("error", instance);
          listenToNonDelegatedEvent("load", instance);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", instance);
          break;
        case "input":
          listenToNonDelegatedEvent("invalid", instance);
          initInput(
            instance,
            props.value,
            props.defaultValue,
            props.checked,
            props.defaultChecked,
            props.type,
            props.name,
            true
          );
          break;
        case "select":
          listenToNonDelegatedEvent("invalid", instance);
          break;
        case "textarea":
          listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children);
      }
      type4 = props.children;
      "string" !== typeof type4 && "number" !== typeof type4 && "bigint" !== typeof type4 || instance.textContent === "" + type4 || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type4) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$12), instance = true) : instance = false;
      instance || throwOnHydrationMismatch(fiber, true);
    }
    function popToNextHostParent(fiber) {
      for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
        switch (hydrationParentFiber.tag) {
          case 5:
          case 31:
          case 13:
            rootOrSingletonContext = false;
            return;
          case 27:
          case 3:
            rootOrSingletonContext = true;
            return;
          default:
            hydrationParentFiber = hydrationParentFiber.return;
        }
    }
    function popHydrationState(fiber) {
      if (fiber !== hydrationParentFiber) return false;
      if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
      var tag = fiber.tag, JSCompiler_temp;
      if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
        if (JSCompiler_temp = 5 === tag)
          JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
        JSCompiler_temp = !JSCompiler_temp;
      }
      JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
      popToNextHostParent(fiber);
      if (13 === tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber) throw Error(formatProdErrorMessage(317));
        nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
      } else if (31 === tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber) throw Error(formatProdErrorMessage(317));
        nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
      } else
        27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
      return true;
    }
    function resetHydrationState() {
      nextHydratableInstance = hydrationParentFiber = null;
      isHydrating = false;
    }
    function upgradeHydrationErrorsToRecoverable() {
      var queuedErrors = hydrationErrors;
      null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
        workInProgressRootRecoverableErrors,
        queuedErrors
      ), hydrationErrors = null);
      return queuedErrors;
    }
    function queueHydrationError(error) {
      null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
    }
    var valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null;
    function pushProvider(providerFiber, context, nextValue) {
      push(valueCursor, context._currentValue);
      context._currentValue = nextValue;
    }
    function popProvider(context) {
      context._currentValue = valueCursor.current;
      pop(valueCursor);
    }
    function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
      for (; null !== parent; ) {
        var alternate = parent.alternate;
        (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
        if (parent === propagationRoot) break;
        parent = parent.return;
      }
    }
    function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
      var fiber = workInProgress2.child;
      null !== fiber && (fiber.return = workInProgress2);
      for (; null !== fiber; ) {
        var list2 = fiber.dependencies;
        if (null !== list2) {
          var nextFiber = fiber.child;
          list2 = list2.firstContext;
          a: for (; null !== list2; ) {
            var dependency = list2;
            list2 = fiber;
            for (var i2 = 0; i2 < contexts.length; i2++)
              if (dependency.context === contexts[i2]) {
                list2.lanes |= renderLanes2;
                dependency = list2.alternate;
                null !== dependency && (dependency.lanes |= renderLanes2);
                scheduleContextWorkOnParentPath(
                  list2.return,
                  renderLanes2,
                  workInProgress2
                );
                forcePropagateEntireTree || (nextFiber = null);
                break a;
              }
            list2 = dependency.next;
          }
        } else if (18 === fiber.tag) {
          nextFiber = fiber.return;
          if (null === nextFiber) throw Error(formatProdErrorMessage(341));
          nextFiber.lanes |= renderLanes2;
          list2 = nextFiber.alternate;
          null !== list2 && (list2.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
          nextFiber = null;
        } else nextFiber = fiber.child;
        if (null !== nextFiber) nextFiber.return = fiber;
        else
          for (nextFiber = fiber; null !== nextFiber; ) {
            if (nextFiber === workInProgress2) {
              nextFiber = null;
              break;
            }
            fiber = nextFiber.sibling;
            if (null !== fiber) {
              fiber.return = nextFiber.return;
              nextFiber = fiber;
              break;
            }
            nextFiber = nextFiber.return;
          }
        fiber = nextFiber;
      }
    }
    function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
      current = null;
      for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
        if (!isInsidePropagationBailout) {
          if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
          else if (0 !== (parent.flags & 262144)) break;
        }
        if (10 === parent.tag) {
          var currentParent = parent.alternate;
          if (null === currentParent) throw Error(formatProdErrorMessage(387));
          currentParent = currentParent.memoizedProps;
          if (null !== currentParent) {
            var context = parent.type;
            objectIs2(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
          }
        } else if (parent === hostTransitionProviderCursor.current) {
          currentParent = parent.alternate;
          if (null === currentParent) throw Error(formatProdErrorMessage(387));
          currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
        }
        parent = parent.return;
      }
      null !== current && propagateContextChanges(
        workInProgress2,
        current,
        renderLanes2,
        forcePropagateEntireTree
      );
      workInProgress2.flags |= 262144;
    }
    function checkIfContextChanged(currentDependencies) {
      for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
        if (!objectIs2(
          currentDependencies.context._currentValue,
          currentDependencies.memoizedValue
        ))
          return true;
        currentDependencies = currentDependencies.next;
      }
      return false;
    }
    function prepareToReadContext(workInProgress2) {
      currentlyRenderingFiber$1 = workInProgress2;
      lastContextDependency = null;
      workInProgress2 = workInProgress2.dependencies;
      null !== workInProgress2 && (workInProgress2.firstContext = null);
    }
    function readContext(context) {
      return readContextForConsumer(currentlyRenderingFiber$1, context);
    }
    function readContextDuringReconciliation(consumer, context) {
      null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
      return readContextForConsumer(consumer, context);
    }
    function readContextForConsumer(consumer, context) {
      var value = context._currentValue;
      context = { context, memoizedValue: value, next: null };
      if (null === lastContextDependency) {
        if (null === consumer) throw Error(formatProdErrorMessage(308));
        lastContextDependency = context;
        consumer.dependencies = { lanes: 0, firstContext: context };
        consumer.flags |= 524288;
      } else lastContextDependency = lastContextDependency.next = context;
      return value;
    }
    var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
      var listeners2 = [], signal = this.signal = {
        aborted: false,
        addEventListener: function(type4, listener) {
          listeners2.push(listener);
        }
      };
      this.abort = function() {
        signal.aborted = true;
        listeners2.forEach(function(listener) {
          return listener();
        });
      };
    }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0
    };
    function createCache3() {
      return {
        controller: new AbortControllerLocal(),
        data: new Map(),
        refCount: 0
      };
    }
    function releaseCache(cache2) {
      cache2.refCount--;
      0 === cache2.refCount && scheduleCallback$2(NormalPriority, function() {
        cache2.controller.abort();
      });
    }
    var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null;
    function entangleAsyncAction(transition, thenable) {
      if (null === currentEntangledListeners) {
        var entangledListeners = currentEntangledListeners = [];
        currentEntangledPendingCount = 0;
        currentEntangledLane = requestTransitionLane();
        currentEntangledActionThenable = {
          status: "pending",
          value: void 0,
          then: function(resolve) {
            entangledListeners.push(resolve);
          }
        };
      }
      currentEntangledPendingCount++;
      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
      return thenable;
    }
    function pingEngtangledActionScope() {
      if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
        null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
        var listeners2 = currentEntangledListeners;
        currentEntangledListeners = null;
        currentEntangledLane = 0;
        currentEntangledActionThenable = null;
        for (var i2 = 0; i2 < listeners2.length; i2++) (0, listeners2[i2])();
      }
    }
    function chainThenableValue(thenable, result) {
      var listeners2 = [], thenableWithOverride = {
        status: "pending",
        value: null,
        reason: null,
        then: function(resolve) {
          listeners2.push(resolve);
        }
      };
      thenable.then(
        function() {
          thenableWithOverride.status = "fulfilled";
          thenableWithOverride.value = result;
          for (var i2 = 0; i2 < listeners2.length; i2++) (0, listeners2[i2])(result);
        },
        function(error) {
          thenableWithOverride.status = "rejected";
          thenableWithOverride.reason = error;
          for (error = 0; error < listeners2.length; error++)
            (0, listeners2[error])(void 0);
        }
      );
      return thenableWithOverride;
    }
    var prevOnStartTransitionFinish = ReactSharedInternals.S;
    ReactSharedInternals.S = function(transition, returnValue) {
      globalMostRecentTransitionTime = now2();
      "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
      null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
    };
    var resumedCache = createCursor(null);
    function peekCacheFromPool() {
      var cacheResumedFromPreviousRender = resumedCache.current;
      return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
    }
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
      null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
    }
    function getSuspendedCache() {
      var cacheFromPool = peekCacheFromPool();
      return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
    }
    var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), SuspenseActionException = Error(formatProdErrorMessage(542)), noopSuspenseyCommitThenable = { then: function() {
    } };
    function isThenableResolved(thenable) {
      thenable = thenable.status;
      return "fulfilled" === thenable || "rejected" === thenable;
    }
    function trackUsedThenable(thenableState2, thenable, index2) {
      index2 = thenableState2[index2];
      void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop$12, noop$12), thenable = index2);
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
        default:
          if ("string" === typeof thenable.status) thenable.then(noop$12, noop$12);
          else {
            thenableState2 = workInProgressRoot;
            if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
              throw Error(formatProdErrorMessage(482));
            thenableState2 = thenable;
            thenableState2.status = "pending";
            thenableState2.then(
              function(fulfilledValue) {
                if ("pending" === thenable.status) {
                  var fulfilledThenable = thenable;
                  fulfilledThenable.status = "fulfilled";
                  fulfilledThenable.value = fulfilledValue;
                }
              },
              function(error) {
                if ("pending" === thenable.status) {
                  var rejectedThenable = thenable;
                  rejectedThenable.status = "rejected";
                  rejectedThenable.reason = error;
                }
              }
            );
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          }
          suspendedThenable = thenable;
          throw SuspenseException;
      }
    }
    function resolveLazy(lazyType) {
      try {
        var init = lazyType._init;
        return init(lazyType._payload);
      } catch (x) {
        if (null !== x && "object" === typeof x && "function" === typeof x.then)
          throw suspendedThenable = x, SuspenseException;
        throw x;
      }
    }
    var suspendedThenable = null;
    function getSuspendedThenable() {
      if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
      var thenable = suspendedThenable;
      suspendedThenable = null;
      return thenable;
    }
    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
      if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
        throw Error(formatProdErrorMessage(483));
    }
    var thenableState$1 = null, thenableIndexCounter$1 = 0;
    function unwrapThenable(thenable) {
      var index2 = thenableIndexCounter$1;
      thenableIndexCounter$1 += 1;
      null === thenableState$1 && (thenableState$1 = []);
      return trackUsedThenable(thenableState$1, thenable, index2);
    }
    function coerceRef(workInProgress2, element) {
      element = element.props.ref;
      workInProgress2.ref = void 0 !== element ? element : null;
    }
    function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
        throw Error(formatProdErrorMessage(525));
      returnFiber = Object.prototype.toString.call(newChild);
      throw Error(
        formatProdErrorMessage(
          31,
          "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
        )
      );
    }
    function createChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          var deletions = returnFiber.deletions;
          null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
        }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects) return null;
        for (; null !== currentFirstChild; )
          deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return null;
      }
      function mapRemainingChildren(currentFirstChild) {
        for (var existingChildren = new Map(); null !== currentFirstChild; )
          null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return existingChildren;
      }
      function useFiber(fiber, pendingProps) {
        fiber = createWorkInProgress(fiber, pendingProps);
        fiber.index = 0;
        fiber.sibling = null;
        return fiber;
      }
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects)
          return newFiber.flags |= 1048576, lastPlacedIndex;
        newIndex = newFiber.alternate;
        if (null !== newIndex)
          return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
        newFiber.flags |= 67108866;
        return lastPlacedIndex;
      }
      function placeSingleChild(newFiber) {
        shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
        return newFiber;
      }
      function updateTextNode(returnFiber, current, textContent, lanes) {
        if (null === current || 6 !== current.tag)
          return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
        current = useFiber(current, textContent);
        current.return = returnFiber;
        return current;
      }
      function updateElement(returnFiber, current, element, lanes) {
        var elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE2)
          return updateFragment(
            returnFiber,
            current,
            element.props.children,
            lanes,
            element.key
          );
        if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
          return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
        current = createFiberFromTypeAndProps(
          element.type,
          element.key,
          element.props,
          null,
          returnFiber.mode,
          lanes
        );
        coerceRef(current, element);
        current.return = returnFiber;
        return current;
      }
      function updatePortal(returnFiber, current, portal, lanes) {
        if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
          return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
        current = useFiber(current, portal.children || []);
        current.return = returnFiber;
        return current;
      }
      function updateFragment(returnFiber, current, fragment, lanes, key) {
        if (null === current || 7 !== current.tag)
          return current = createFiberFromFragment(
            fragment,
            returnFiber.mode,
            lanes,
            key
          ), current.return = returnFiber, current;
        current = useFiber(current, fragment);
        current.return = returnFiber;
        return current;
      }
      function createChild(returnFiber, newChild, lanes) {
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return newChild = createFiberFromText(
            "" + newChild,
            returnFiber.mode,
            lanes
          ), newChild.return = returnFiber, newChild;
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return lanes = createFiberFromTypeAndProps(
                newChild.type,
                newChild.key,
                newChild.props,
                null,
                returnFiber.mode,
                lanes
              ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
            case REACT_PORTAL_TYPE:
              return newChild = createFiberFromPortal(
                newChild,
                returnFiber.mode,
                lanes
              ), newChild.return = returnFiber, newChild;
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), createChild(returnFiber, newChild, lanes);
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return newChild = createFiberFromFragment(
              newChild,
              returnFiber.mode,
              lanes,
              null
            ), newChild.return = returnFiber, newChild;
          if ("function" === typeof newChild.then)
            return createChild(returnFiber, unwrapThenable(newChild), lanes);
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return createChild(
              returnFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return null;
      }
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        var key = null !== oldFiber ? oldFiber.key : null;
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_PORTAL_TYPE:
              return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), updateSlot(returnFiber, oldFiber, newChild, lanes);
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
          if ("function" === typeof newChild.then)
            return updateSlot(
              returnFiber,
              oldFiber,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateSlot(
              returnFiber,
              oldFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return null;
      }
      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return existingChildren = existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
            case REACT_PORTAL_TYPE:
              return existingChildren = existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                newChild,
                lanes
              );
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
          if ("function" === typeof newChild.then)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return null;
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(
            returnFiber,
            oldFiber,
            newChildren[newIdx],
            lanes
          );
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (newIdx === newChildren.length)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (null === oldFiber) {
          for (; newIdx < newChildren.length; newIdx++)
            oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
              oldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
          nextOldFiber = updateFromMap(
            oldFiber,
            returnFiber,
            newIdx,
            newChildren[newIdx],
            lanes
          ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
            null === nextOldFiber.key ? newIdx : nextOldFiber.key
          ), currentFirstChild = placeChild(
            nextOldFiber,
            currentFirstChild,
            newIdx
          ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
        if (null == newChildren) throw Error(formatProdErrorMessage(151));
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (step.done)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (null === oldFiber) {
          for (; !step.done; newIdx++, step = newChildren.next())
            step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
          step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
        "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE2 && null === newChild.key && (newChild = newChild.props.children);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              a: {
                for (var key = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key) {
                    key = newChild.type;
                    if (key === REACT_FRAGMENT_TYPE2) {
                      if (7 === currentFirstChild.tag) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(
                          currentFirstChild,
                          newChild.props.children
                        );
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                    } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(currentFirstChild, newChild.props);
                      coerceRef(lanes, newChild);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    }
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  } else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                newChild.type === REACT_FRAGMENT_TYPE2 ? (lanes = createFiberFromFragment(
                  newChild.props.children,
                  returnFiber.mode,
                  lanes,
                  newChild.key
                ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
              }
              return placeSingleChild(returnFiber);
            case REACT_PORTAL_TYPE:
              a: {
                for (key = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key)
                    if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(currentFirstChild, newChild.children || []);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    } else {
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    }
                  else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                lanes.return = returnFiber;
                returnFiber = lanes;
              }
              return placeSingleChild(returnFiber);
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
          }
          if (isArrayImpl(newChild))
            return reconcileChildrenArray(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
          if (getIteratorFn(newChild)) {
            key = getIteratorFn(newChild);
            if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
            newChild = key.call(newChild);
            return reconcileChildrenIterator(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
          }
          if ("function" === typeof newChild.then)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
      }
      return function(returnFiber, currentFirstChild, newChild, lanes) {
        try {
          thenableIndexCounter$1 = 0;
          var firstChildFiber = reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          );
          thenableState$1 = null;
          return firstChildFiber;
        } catch (x) {
          if (x === SuspenseException || x === SuspenseActionException) throw x;
          var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
          fiber.lanes = lanes;
          fiber.return = returnFiber;
          return fiber;
        } finally {
        }
      };
    }
    var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), hasForceUpdate = false;
    function initializeUpdateQueue(fiber) {
      fiber.updateQueue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function cloneUpdateQueue(current, workInProgress2) {
      current = current.updateQueue;
      workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
        baseState: current.baseState,
        firstBaseUpdate: current.firstBaseUpdate,
        lastBaseUpdate: current.lastBaseUpdate,
        shared: current.shared,
        callbacks: null
      });
    }
    function createUpdate(lane) {
      return { lane, tag: 0, payload: null, callback: null, next: null };
    }
    function enqueueUpdate(fiber, update, lane) {
      var updateQueue = fiber.updateQueue;
      if (null === updateQueue) return null;
      updateQueue = updateQueue.shared;
      if (0 !== (executionContext & 2)) {
        var pending = updateQueue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        updateQueue.pending = update;
        update = getRootForUpdatedFiber(fiber);
        markUpdateLaneFromFiberToRoot(fiber, null, lane);
        return update;
      }
      enqueueUpdate$1(fiber, updateQueue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function entangleTransitions(root3, fiber, lane) {
      fiber = fiber.updateQueue;
      if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
        var queueLanes = fiber.lanes;
        queueLanes &= root3.pendingLanes;
        lane |= queueLanes;
        fiber.lanes = lane;
        markRootEntangled(root3, lane);
      }
    }
    function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
      var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
      if (null !== current && (current = current.updateQueue, queue === current)) {
        var newFirst = null, newLast = null;
        queue = queue.firstBaseUpdate;
        if (null !== queue) {
          do {
            var clone2 = {
              lane: queue.lane,
              tag: queue.tag,
              payload: queue.payload,
              callback: null,
              next: null
            };
            null === newLast ? newFirst = newLast = clone2 : newLast = newLast.next = clone2;
            queue = queue.next;
          } while (null !== queue);
          null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
        } else newFirst = newLast = capturedUpdate;
        queue = {
          baseState: current.baseState,
          firstBaseUpdate: newFirst,
          lastBaseUpdate: newLast,
          shared: current.shared,
          callbacks: current.callbacks
        };
        workInProgress2.updateQueue = queue;
        return;
      }
      workInProgress2 = queue.lastBaseUpdate;
      null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
      queue.lastBaseUpdate = capturedUpdate;
    }
    var didReadFromEntangledAsyncAction = false;
    function suspendIfUpdateReadFromEntangledAsyncAction() {
      if (didReadFromEntangledAsyncAction) {
        var entangledActionThenable = currentEntangledActionThenable;
        if (null !== entangledActionThenable) throw entangledActionThenable;
      }
    }
    function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
      didReadFromEntangledAsyncAction = false;
      var queue = workInProgress$jscomp$0.updateQueue;
      hasForceUpdate = false;
      var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
      if (null !== pendingQueue) {
        queue.shared.pending = null;
        var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
        lastPendingUpdate.next = null;
        null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
        lastBaseUpdate = lastPendingUpdate;
        var current = workInProgress$jscomp$0.alternate;
        null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
      }
      if (null !== firstBaseUpdate) {
        var newState = queue.baseState;
        lastBaseUpdate = 0;
        current = firstPendingUpdate = lastPendingUpdate = null;
        pendingQueue = firstBaseUpdate;
        do {
          var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
          if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
            0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
            null !== current && (current = current.next = {
              lane: 0,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: null,
              next: null
            });
            a: {
              var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
              updateLane = props;
              var instance = instance$jscomp$0;
              switch (update.tag) {
                case 1:
                  workInProgress2 = update.payload;
                  if ("function" === typeof workInProgress2) {
                    newState = workInProgress2.call(instance, newState, updateLane);
                    break a;
                  }
                  newState = workInProgress2;
                  break a;
                case 3:
                  workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                case 0:
                  workInProgress2 = update.payload;
                  updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                  if (null === updateLane || void 0 === updateLane) break a;
                  newState = assign2({}, newState, updateLane);
                  break a;
                case 2:
                  hasForceUpdate = true;
              }
            }
            updateLane = pendingQueue.callback;
            null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
          } else
            isHiddenUpdate = {
              lane: updateLane,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: pendingQueue.callback,
              next: null
            }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
          pendingQueue = pendingQueue.next;
          if (null === pendingQueue)
            if (pendingQueue = queue.shared.pending, null === pendingQueue)
              break;
            else
              isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
        } while (1);
        null === current && (lastPendingUpdate = newState);
        queue.baseState = lastPendingUpdate;
        queue.firstBaseUpdate = firstPendingUpdate;
        queue.lastBaseUpdate = current;
        null === firstBaseUpdate && (queue.shared.lanes = 0);
        workInProgressRootSkippedLanes |= lastBaseUpdate;
        workInProgress$jscomp$0.lanes = lastBaseUpdate;
        workInProgress$jscomp$0.memoizedState = newState;
      }
    }
    function callCallback(callback, context) {
      if ("function" !== typeof callback)
        throw Error(formatProdErrorMessage(191, callback));
      callback.call(context);
    }
    function commitCallbacks(updateQueue, context) {
      var callbacks = updateQueue.callbacks;
      if (null !== callbacks)
        for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
          callCallback(callbacks[updateQueue], context);
    }
    var currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0);
    function pushHiddenContext(fiber, context) {
      fiber = entangledRenderLanes;
      push(prevEntangledRenderLanesCursor, fiber);
      push(currentTreeHiddenStackCursor, context);
      entangledRenderLanes = fiber | context.baseLanes;
    }
    function reuseHiddenContextOnStack() {
      push(prevEntangledRenderLanesCursor, entangledRenderLanes);
      push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
    }
    function popHiddenContext() {
      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
      pop(currentTreeHiddenStackCursor);
      pop(prevEntangledRenderLanesCursor);
    }
    var suspenseHandlerStackCursor = createCursor(null), shellBoundary = null;
    function pushPrimaryTreeSuspenseHandler(handler) {
      var current = handler.alternate;
      push(suspenseStackCursor, suspenseStackCursor.current & 1);
      push(suspenseHandlerStackCursor, handler);
      null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
    }
    function pushDehydratedActivitySuspenseHandler(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current);
      push(suspenseHandlerStackCursor, fiber);
      null === shellBoundary && (shellBoundary = fiber);
    }
    function pushOffscreenSuspenseHandler(fiber) {
      22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack();
    }
    function reuseSuspenseHandlerOnStack() {
      push(suspenseStackCursor, suspenseStackCursor.current);
      push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
    }
    function popSuspenseHandler(fiber) {
      pop(suspenseHandlerStackCursor);
      shellBoundary === fiber && (shellBoundary = null);
      pop(suspenseStackCursor);
    }
    var suspenseStackCursor = createCursor(0);
    function findFirstSuspended(row) {
      for (var node2 = row; null !== node2; ) {
        if (13 === node2.tag) {
          var state2 = node2.memoizedState;
          if (null !== state2 && (state2 = state2.dehydrated, null === state2 || isSuspenseInstancePending(state2) || isSuspenseInstanceFallback(state2)))
            return node2;
        } else if (19 === node2.tag && ("forwards" === node2.memoizedProps.revealOrder || "backwards" === node2.memoizedProps.revealOrder || "unstable_legacy-backwards" === node2.memoizedProps.revealOrder || "together" === node2.memoizedProps.revealOrder)) {
          if (0 !== (node2.flags & 128)) return node2;
        } else if (null !== node2.child) {
          node2.child.return = node2;
          node2 = node2.child;
          continue;
        }
        if (node2 === row) break;
        for (; null === node2.sibling; ) {
          if (null === node2.return || node2.return === row) return null;
          node2 = node2.return;
        }
        node2.sibling.return = node2.return;
        node2 = node2.sibling;
      }
      return null;
    }
    var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0;
    function throwInvalidHookError() {
      throw Error(formatProdErrorMessage(321));
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (null === prevDeps) return false;
      for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++)
        if (!objectIs2(nextDeps[i2], prevDeps[i2])) return false;
      return true;
    }
    function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
      renderLanes = nextRenderLanes;
      currentlyRenderingFiber = workInProgress2;
      workInProgress2.memoizedState = null;
      workInProgress2.updateQueue = null;
      workInProgress2.lanes = 0;
      ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      nextRenderLanes = Component(props, secondArg);
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
        workInProgress2,
        Component,
        props,
        secondArg
      ));
      finishRenderingHooks(current);
      return nextRenderLanes;
    }
    function finishRenderingHooks(current) {
      ReactSharedInternals.H = ContextOnlyDispatcher;
      var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
      renderLanes = 0;
      workInProgressHook = currentHook = currentlyRenderingFiber = null;
      didScheduleRenderPhaseUpdate = false;
      thenableIndexCounter = 0;
      thenableState = null;
      if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
      null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
    }
    function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
      currentlyRenderingFiber = workInProgress2;
      var numberOfReRenders = 0;
      do {
        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
        thenableIndexCounter = 0;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
        numberOfReRenders += 1;
        workInProgressHook = currentHook = null;
        if (null != workInProgress2.updateQueue) {
          var children = workInProgress2.updateQueue;
          children.lastEffect = null;
          children.events = null;
          children.stores = null;
          null != children.memoCache && (children.memoCache.index = 0);
        }
        ReactSharedInternals.H = HooksDispatcherOnRerender;
        children = Component(props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
      return children;
    }
    function TransitionAwareHostComponent() {
      var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
      maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
      dispatcher = dispatcher.useState()[0];
      (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
      return maybeThenable;
    }
    function checkDidRenderIdHook() {
      var didRenderIdHook = 0 !== localIdCounter;
      localIdCounter = 0;
      return didRenderIdHook;
    }
    function bailoutHooks(current, workInProgress2, lanes) {
      workInProgress2.updateQueue = current.updateQueue;
      workInProgress2.flags &= -2053;
      current.lanes &= ~lanes;
    }
    function resetHooksOnUnwind(workInProgress2) {
      if (didScheduleRenderPhaseUpdate) {
        for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
          var queue = workInProgress2.queue;
          null !== queue && (queue.pending = null);
          workInProgress2 = workInProgress2.next;
        }
        didScheduleRenderPhaseUpdate = false;
      }
      renderLanes = 0;
      workInProgressHook = currentHook = currentlyRenderingFiber = null;
      didScheduleRenderPhaseUpdateDuringThisPass = false;
      thenableIndexCounter = localIdCounter = 0;
      thenableState = null;
    }
    function mountWorkInProgressHook() {
      var hook = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
      return workInProgressHook;
    }
    function updateWorkInProgressHook() {
      if (null === currentHook) {
        var nextCurrentHook = currentlyRenderingFiber.alternate;
        nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
      } else nextCurrentHook = currentHook.next;
      var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
      if (null !== nextWorkInProgressHook)
        workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
      else {
        if (null === nextCurrentHook) {
          if (null === currentlyRenderingFiber.alternate)
            throw Error(formatProdErrorMessage(467));
          throw Error(formatProdErrorMessage(310));
        }
        currentHook = nextCurrentHook;
        nextCurrentHook = {
          memoizedState: currentHook.memoizedState,
          baseState: currentHook.baseState,
          baseQueue: currentHook.baseQueue,
          queue: currentHook.queue,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
      }
      return workInProgressHook;
    }
    function createFunctionComponentUpdateQueue() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function useThenable(thenable) {
      var index2 = thenableIndexCounter;
      thenableIndexCounter += 1;
      null === thenableState && (thenableState = []);
      thenable = trackUsedThenable(thenableState, thenable, index2);
      index2 = currentlyRenderingFiber;
      null === (null === workInProgressHook ? index2.memoizedState : workInProgressHook.next) && (index2 = index2.alternate, ReactSharedInternals.H = null === index2 || null === index2.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
      return thenable;
    }
    function use(usable) {
      if (null !== usable && "object" === typeof usable) {
        if ("function" === typeof usable.then) return useThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
      }
      throw Error(formatProdErrorMessage(438, String(usable)));
    }
    function useMemoCache(size) {
      var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
      null !== updateQueue && (memoCache = updateQueue.memoCache);
      if (null == memoCache) {
        var current = currentlyRenderingFiber.alternate;
        null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
          data: current.data.map(function(array4) {
            return array4.slice();
          }),
          index: 0
        })));
      }
      null == memoCache && (memoCache = { data: [], index: 0 });
      null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
      updateQueue.memoCache = memoCache;
      updateQueue = memoCache.data[memoCache.index];
      if (void 0 === updateQueue)
        for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
          updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
      memoCache.index++;
      return updateQueue;
    }
    function basicStateReducer(state2, action2) {
      return "function" === typeof action2 ? action2(state2) : action2;
    }
    function updateReducer(reducer2) {
      var hook = updateWorkInProgressHook();
      return updateReducerImpl(hook, currentHook, reducer2);
    }
    function updateReducerImpl(hook, current, reducer2) {
      var queue = hook.queue;
      if (null === queue) throw Error(formatProdErrorMessage(311));
      queue.lastRenderedReducer = reducer2;
      var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
      if (null !== pendingQueue) {
        if (null !== baseQueue) {
          var baseFirst = baseQueue.next;
          baseQueue.next = pendingQueue.next;
          pendingQueue.next = baseFirst;
        }
        current.baseQueue = baseQueue = pendingQueue;
        queue.pending = null;
      }
      pendingQueue = hook.baseState;
      if (null === baseQueue) hook.memoizedState = pendingQueue;
      else {
        current = baseQueue.next;
        var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$60 = false;
        do {
          var updateLane = update.lane & -536870913;
          if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
            var revertLane = update.revertLane;
            if (0 === revertLane)
              null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                lane: 0,
                revertLane: 0,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
            else if ((renderLanes & revertLane) === revertLane) {
              update = update.next;
              revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
              continue;
            } else
              updateLane = {
                lane: 0,
                revertLane: update.revertLane,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
            updateLane = update.action;
            shouldDoubleInvokeUserFnsInHooksDEV && reducer2(pendingQueue, updateLane);
            pendingQueue = update.hasEagerState ? update.eagerState : reducer2(pendingQueue, updateLane);
          } else
            revertLane = {
              lane: updateLane,
              revertLane: update.revertLane,
              gesture: update.gesture,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
          update = update.next;
        } while (null !== update && update !== current);
        null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
        if (!objectIs2(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$60 && (reducer2 = currentEntangledActionThenable, null !== reducer2)))
          throw reducer2;
        hook.memoizedState = pendingQueue;
        hook.baseState = baseFirst;
        hook.baseQueue = newBaseQueueLast;
        queue.lastRenderedState = pendingQueue;
      }
      null === baseQueue && (queue.lanes = 0);
      return [hook.memoizedState, queue.dispatch];
    }
    function rerenderReducer(reducer2) {
      var hook = updateWorkInProgressHook(), queue = hook.queue;
      if (null === queue) throw Error(formatProdErrorMessage(311));
      queue.lastRenderedReducer = reducer2;
      var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
      if (null !== lastRenderPhaseUpdate) {
        queue.pending = null;
        var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
        do
          newState = reducer2(newState, update.action), update = update.next;
        while (update !== lastRenderPhaseUpdate);
        objectIs2(newState, hook.memoizedState) || (didReceiveUpdate = true);
        hook.memoizedState = newState;
        null === hook.baseQueue && (hook.baseState = newState);
        queue.lastRenderedState = newState;
      }
      return [newState, dispatch];
    }
    function updateSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
      if (isHydrating$jscomp$0) {
        if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
        getServerSnapshot = getServerSnapshot();
      } else getServerSnapshot = getSnapshot();
      var snapshotChanged = !objectIs2(
        (currentHook || hook).memoizedState,
        getServerSnapshot
      );
      snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
      hook = hook.queue;
      updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe2), [
        subscribe2
      ]);
      if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
        fiber.flags |= 2048;
        pushSimpleEffect(
          9,
          { destroy: void 0 },
          updateStoreInstance.bind(
            null,
            fiber,
            hook,
            getServerSnapshot,
            getSnapshot
          ),
          null
        );
        if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
        isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      return getServerSnapshot;
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= 16384;
      fiber = { getSnapshot, value: renderedSnapshot };
      getSnapshot = currentlyRenderingFiber.updateQueue;
      null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    function subscribeToStore(fiber, inst, subscribe2) {
      return subscribe2(function() {
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      });
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs2(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    function forceStoreRerender(fiber) {
      var root3 = enqueueConcurrentRenderForLane(fiber, 2);
      null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2);
    }
    function mountStateImpl(initialState) {
      var hook = mountWorkInProgressHook();
      if ("function" === typeof initialState) {
        var initialStateInitializer = initialState;
        initialState = initialStateInitializer();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            initialStateInitializer();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      }
      hook.memoizedState = hook.baseState = initialState;
      hook.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialState
      };
      return hook;
    }
    function updateOptimisticImpl(hook, current, passthrough, reducer2) {
      hook.baseState = passthrough;
      return updateReducerImpl(
        hook,
        currentHook,
        "function" === typeof reducer2 ? reducer2 : basicStateReducer
      );
    }
    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
      if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
      fiber = actionQueue.action;
      if (null !== fiber) {
        var actionNode = {
          payload,
          action: fiber,
          next: null,
          isTransition: true,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(listener) {
            actionNode.listeners.push(listener);
          }
        };
        null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
        setState(actionNode);
        setPendingState = actionQueue.pending;
        null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
      }
    }
    function runActionStateAction(actionQueue, node2) {
      var action2 = node2.action, payload = node2.payload, prevState = actionQueue.state;
      if (node2.isTransition) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = action2(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          handleActionReturnValue(actionQueue, node2, returnValue);
        } catch (error) {
          onActionError(actionQueue, node2, error);
        } finally {
          null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      } else
        try {
          prevTransition = action2(prevState, payload), handleActionReturnValue(actionQueue, node2, prevTransition);
        } catch (error$66) {
          onActionError(actionQueue, node2, error$66);
        }
    }
    function handleActionReturnValue(actionQueue, node2, returnValue) {
      null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
        function(nextState) {
          onActionSuccess(actionQueue, node2, nextState);
        },
        function(error) {
          return onActionError(actionQueue, node2, error);
        }
      ) : onActionSuccess(actionQueue, node2, returnValue);
    }
    function onActionSuccess(actionQueue, actionNode, nextState) {
      actionNode.status = "fulfilled";
      actionNode.value = nextState;
      notifyActionListeners(actionNode);
      actionQueue.state = nextState;
      actionNode = actionQueue.pending;
      null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
    }
    function onActionError(actionQueue, actionNode, error) {
      var last = actionQueue.pending;
      actionQueue.pending = null;
      if (null !== last) {
        last = last.next;
        do
          actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
        while (actionNode !== last);
      }
      actionQueue.action = null;
    }
    function notifyActionListeners(actionNode) {
      actionNode = actionNode.listeners;
      for (var i2 = 0; i2 < actionNode.length; i2++) (0, actionNode[i2])();
    }
    function actionStateReducer(oldState, newState) {
      return newState;
    }
    function mountActionState(action2, initialStateProp) {
      if (isHydrating) {
        var ssrFormState = workInProgressRoot.formState;
        if (null !== ssrFormState) {
          a: {
            var JSCompiler_inline_result = currentlyRenderingFiber;
            if (isHydrating) {
              if (nextHydratableInstance) {
                b: {
                  var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                  for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                    if (!inRootOrSingleton) {
                      JSCompiler_inline_result$jscomp$0 = null;
                      break b;
                    }
                    JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling
                    );
                    if (null === JSCompiler_inline_result$jscomp$0) {
                      JSCompiler_inline_result$jscomp$0 = null;
                      break b;
                    }
                  }
                  inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                  JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                }
                if (JSCompiler_inline_result$jscomp$0) {
                  nextHydratableInstance = getNextHydratable(
                    JSCompiler_inline_result$jscomp$0.nextSibling
                  );
                  JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                  break a;
                }
              }
              throwOnHydrationMismatch(JSCompiler_inline_result);
            }
            JSCompiler_inline_result = false;
          }
          JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
        }
      }
      ssrFormState = mountWorkInProgressHook();
      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
      JSCompiler_inline_result = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: actionStateReducer,
        lastRenderedState: initialStateProp
      };
      ssrFormState.queue = JSCompiler_inline_result;
      ssrFormState = dispatchSetState.bind(
        null,
        currentlyRenderingFiber,
        JSCompiler_inline_result
      );
      JSCompiler_inline_result.dispatch = ssrFormState;
      JSCompiler_inline_result = mountStateImpl(false);
      inRootOrSingleton = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber,
        false,
        JSCompiler_inline_result.queue
      );
      JSCompiler_inline_result = mountWorkInProgressHook();
      JSCompiler_inline_result$jscomp$0 = {
        state: initialStateProp,
        dispatch: null,
        action: action2,
        pending: null
      };
      JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
      ssrFormState = dispatchActionState.bind(
        null,
        currentlyRenderingFiber,
        JSCompiler_inline_result$jscomp$0,
        inRootOrSingleton,
        ssrFormState
      );
      JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
      JSCompiler_inline_result.memoizedState = action2;
      return [initialStateProp, ssrFormState, false];
    }
    function updateActionState(action2) {
      var stateHook = updateWorkInProgressHook();
      return updateActionStateImpl(stateHook, currentHook, action2);
    }
    function updateActionStateImpl(stateHook, currentStateHook, action2) {
      currentStateHook = updateReducerImpl(
        stateHook,
        currentStateHook,
        actionStateReducer
      )[0];
      stateHook = updateReducer(basicStateReducer)[0];
      if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
        try {
          var state2 = useThenable(currentStateHook);
        } catch (x) {
          if (x === SuspenseException) throw SuspenseActionException;
          throw x;
        }
      else state2 = currentStateHook;
      currentStateHook = updateWorkInProgressHook();
      var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
      action2 !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
        9,
        { destroy: void 0 },
        actionStateActionEffect.bind(null, actionQueue, action2),
        null
      ));
      return [state2, dispatch, stateHook];
    }
    function actionStateActionEffect(actionQueue, action2) {
      actionQueue.action = action2;
    }
    function rerenderActionState(action2) {
      var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
      if (null !== currentStateHook)
        return updateActionStateImpl(stateHook, currentStateHook, action2);
      updateWorkInProgressHook();
      stateHook = stateHook.memoizedState;
      currentStateHook = updateWorkInProgressHook();
      var dispatch = currentStateHook.queue.dispatch;
      currentStateHook.memoizedState = action2;
      return [stateHook, dispatch, false];
    }
    function pushSimpleEffect(tag, inst, create, deps) {
      tag = { tag, create, deps, inst, next: null };
      inst = currentlyRenderingFiber.updateQueue;
      null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
      create = inst.lastEffect;
      null === create ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);
      return tag;
    }
    function updateRef() {
      return updateWorkInProgressHook().memoizedState;
    }
    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = mountWorkInProgressHook();
      currentlyRenderingFiber.flags |= fiberFlags;
      hook.memoizedState = pushSimpleEffect(
        1 | hookFlags,
        { destroy: void 0 },
        create,
        void 0 === deps ? null : deps
      );
    }
    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var inst = hook.memoizedState.inst;
      null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
        1 | hookFlags,
        inst,
        create,
        deps
      ));
    }
    function mountEffect(create, deps) {
      mountEffectImpl(8390656, 8, create, deps);
    }
    function updateEffect(create, deps) {
      updateEffectImpl(2048, 8, create, deps);
    }
    function useEffectEventImpl(payload) {
      currentlyRenderingFiber.flags |= 4;
      var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
      if (null === componentUpdateQueue)
        componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
      else {
        var events2 = componentUpdateQueue.events;
        null === events2 ? componentUpdateQueue.events = [payload] : events2.push(payload);
      }
    }
    function updateEvent(callback) {
      var ref2 = updateWorkInProgressHook().memoizedState;
      useEffectEventImpl({ ref: ref2, nextImpl: callback });
      return function() {
        if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
        return ref2.impl.apply(void 0, arguments);
      };
    }
    function updateInsertionEffect(create, deps) {
      return updateEffectImpl(4, 2, create, deps);
    }
    function updateLayoutEffect(create, deps) {
      return updateEffectImpl(4, 4, create, deps);
    }
    function imperativeHandleEffect(create, ref2) {
      if ("function" === typeof ref2) {
        create = create();
        var refCleanup = ref2(create);
        return function() {
          "function" === typeof refCleanup ? refCleanup() : ref2(null);
        };
      }
      if (null !== ref2 && void 0 !== ref2)
        return create = create(), ref2.current = create, function() {
          ref2.current = null;
        };
    }
    function updateImperativeHandle(ref2, create, deps) {
      deps = null !== deps && void 0 !== deps ? deps.concat([ref2]) : null;
      updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref2), deps);
    }
    function mountDebugValue() {
    }
    function updateCallback(callback, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      hook.memoizedState = [callback, deps];
      return callback;
    }
    function updateMemo(nextCreate, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      prevState = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [prevState, deps];
      return prevState;
    }
    function mountDeferredValueImpl(hook, value, initialValue2) {
      if (void 0 === initialValue2 || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
        return hook.memoizedState = value;
      hook.memoizedState = initialValue2;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return initialValue2;
    }
    function updateDeferredValueImpl(hook, prevValue, value, initialValue2) {
      if (objectIs2(value, prevValue)) return value;
      if (null !== currentTreeHiddenStackCursor.current)
        return hook = mountDeferredValueImpl(hook, value, initialValue2), objectIs2(hook, prevValue) || (didReceiveUpdate = true), hook;
      if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
        return didReceiveUpdate = true, hook.memoizedState = value;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return prevValue;
    }
    function startTransition(fiber, queue, pendingState, finishedState, callback) {
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      dispatchOptimisticSetState(fiber, false, queue, pendingState);
      try {
        var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
          var thenableForFinishedState = chainThenableValue(
            returnValue,
            finishedState
          );
          dispatchSetStateInternal(
            fiber,
            queue,
            thenableForFinishedState,
            requestUpdateLane(fiber)
          );
        } else
          dispatchSetStateInternal(
            fiber,
            queue,
            finishedState,
            requestUpdateLane(fiber)
          );
      } catch (error) {
        dispatchSetStateInternal(
          fiber,
          queue,
          { then: function() {
          }, status: "rejected", reason: error },
          requestUpdateLane()
        );
      } finally {
        ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
      }
    }
    function noop2() {
    }
    function startHostTransition(formFiber, pendingState, action2, formData) {
      if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
      var queue = ensureFormComponentIsStateful(formFiber).queue;
      startTransition(
        formFiber,
        queue,
        pendingState,
        sharedNotPendingObject,
        null === action2 ? noop2 : function() {
          requestFormReset$1(formFiber);
          return action2(formData);
        }
      );
    }
    function ensureFormComponentIsStateful(formFiber) {
      var existingStateHook = formFiber.memoizedState;
      if (null !== existingStateHook) return existingStateHook;
      existingStateHook = {
        memoizedState: sharedNotPendingObject,
        baseState: sharedNotPendingObject,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: sharedNotPendingObject
        },
        next: null
      };
      var initialResetState = {};
      existingStateHook.next = {
        memoizedState: initialResetState,
        baseState: initialResetState,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialResetState
        },
        next: null
      };
      formFiber.memoizedState = existingStateHook;
      formFiber = formFiber.alternate;
      null !== formFiber && (formFiber.memoizedState = existingStateHook);
      return existingStateHook;
    }
    function requestFormReset$1(formFiber) {
      var stateHook = ensureFormComponentIsStateful(formFiber);
      null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
      dispatchSetStateInternal(
        formFiber,
        stateHook.next.queue,
        {},
        requestUpdateLane()
      );
    }
    function useHostTransitionStatus() {
      return readContext(HostTransitionContext);
    }
    function updateId2() {
      return updateWorkInProgressHook().memoizedState;
    }
    function updateRefresh() {
      return updateWorkInProgressHook().memoizedState;
    }
    function refreshCache(fiber) {
      for (var provider = fiber.return; null !== provider; ) {
        switch (provider.tag) {
          case 24:
          case 3:
            var lane = requestUpdateLane();
            fiber = createUpdate(lane);
            var root$69 = enqueueUpdate(provider, fiber, lane);
            null !== root$69 && (scheduleUpdateOnFiber(root$69, provider, lane), entangleTransitions(root$69, provider, lane));
            provider = { cache: createCache3() };
            fiber.payload = provider;
            return;
        }
        provider = provider.return;
      }
    }
    function dispatchReducerAction(fiber, queue, action2) {
      var lane = requestUpdateLane();
      action2 = {
        lane,
        revertLane: 0,
        gesture: null,
        action: action2,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action2) : (action2 = enqueueConcurrentHookUpdate(fiber, queue, action2, lane), null !== action2 && (scheduleUpdateOnFiber(action2, fiber, lane), entangleTransitionUpdate(action2, queue, lane)));
    }
    function dispatchSetState(fiber, queue, action2) {
      var lane = requestUpdateLane();
      dispatchSetStateInternal(fiber, queue, action2, lane);
    }
    function dispatchSetStateInternal(fiber, queue, action2, lane) {
      var update = {
        lane,
        revertLane: 0,
        gesture: null,
        action: action2,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
      else {
        var alternate = fiber.alternate;
        if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
          try {
            var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action2);
            update.hasEagerState = true;
            update.eagerState = eagerState;
            if (objectIs2(eagerState, currentState))
              return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
          } catch (error) {
          } finally {
          }
        action2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (null !== action2)
          return scheduleUpdateOnFiber(action2, fiber, lane), entangleTransitionUpdate(action2, queue, lane), true;
      }
      return false;
    }
    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action2) {
      action2 = {
        lane: 2,
        revertLane: requestTransitionLane(),
        gesture: null,
        action: action2,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) {
        if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
      } else
        throwIfDuringRender = enqueueConcurrentHookUpdate(
          fiber,
          queue,
          action2,
          2
        ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
    }
    function isRenderPhaseUpdate(fiber) {
      var alternate = fiber.alternate;
      return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
    }
    function enqueueRenderPhaseUpdate(queue, update) {
      didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
      var pending = queue.pending;
      null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
      queue.pending = update;
    }
    function entangleTransitionUpdate(root3, queue, lane) {
      if (0 !== (lane & 4194048)) {
        var queueLanes = queue.lanes;
        queueLanes &= root3.pendingLanes;
        lane |= queueLanes;
        queue.lanes = lane;
        markRootEntangled(root3, lane);
      }
    }
    var ContextOnlyDispatcher = {
      readContext,
      use,
      useCallback: throwInvalidHookError,
      useContext: throwInvalidHookError,
      useEffect: throwInvalidHookError,
      useImperativeHandle: throwInvalidHookError,
      useLayoutEffect: throwInvalidHookError,
      useInsertionEffect: throwInvalidHookError,
      useMemo: throwInvalidHookError,
      useReducer: throwInvalidHookError,
      useRef: throwInvalidHookError,
      useState: throwInvalidHookError,
      useDebugValue: throwInvalidHookError,
      useDeferredValue: throwInvalidHookError,
      useTransition: throwInvalidHookError,
      useSyncExternalStore: throwInvalidHookError,
      useId: throwInvalidHookError,
      useHostTransitionStatus: throwInvalidHookError,
      useFormState: throwInvalidHookError,
      useActionState: throwInvalidHookError,
      useOptimistic: throwInvalidHookError,
      useMemoCache: throwInvalidHookError,
      useCacheRefresh: throwInvalidHookError
    };
    ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
    var HooksDispatcherOnMount = {
      readContext,
      use,
      useCallback: function(callback, deps) {
        mountWorkInProgressHook().memoizedState = [
          callback,
          void 0 === deps ? null : deps
        ];
        return callback;
      },
      useContext: readContext,
      useEffect: mountEffect,
      useImperativeHandle: function(ref2, create, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref2]) : null;
        mountEffectImpl(
          4194308,
          4,
          imperativeHandleEffect.bind(null, create, ref2),
          deps
        );
      },
      useLayoutEffect: function(create, deps) {
        return mountEffectImpl(4194308, 4, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        mountEffectImpl(4, 2, create, deps);
      },
      useMemo: function(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var nextValue = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [nextValue, deps];
        return nextValue;
      },
      useReducer: function(reducer2, initialArg, init) {
        var hook = mountWorkInProgressHook();
        if (void 0 !== init) {
          var initialState = init(initialArg);
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              init(initialArg);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        } else initialState = initialArg;
        hook.memoizedState = hook.baseState = initialState;
        reducer2 = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: reducer2,
          lastRenderedState: initialState
        };
        hook.queue = reducer2;
        reducer2 = reducer2.dispatch = dispatchReducerAction.bind(
          null,
          currentlyRenderingFiber,
          reducer2
        );
        return [hook.memoizedState, reducer2];
      },
      useRef: function(initialValue2) {
        var hook = mountWorkInProgressHook();
        initialValue2 = { current: initialValue2 };
        return hook.memoizedState = initialValue2;
      },
      useState: function(initialState) {
        initialState = mountStateImpl(initialState);
        var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
        queue.dispatch = dispatch;
        return [initialState.memoizedState, dispatch];
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function(value, initialValue2) {
        var hook = mountWorkInProgressHook();
        return mountDeferredValueImpl(hook, value, initialValue2);
      },
      useTransition: function() {
        var stateHook = mountStateImpl(false);
        stateHook = startTransition.bind(
          null,
          currentlyRenderingFiber,
          stateHook.queue,
          true,
          false
        );
        mountWorkInProgressHook().memoizedState = stateHook;
        return [false, stateHook];
      },
      useSyncExternalStore: function(subscribe2, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
        if (isHydrating) {
          if (void 0 === getServerSnapshot)
            throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else {
          getServerSnapshot = getSnapshot();
          if (null === workInProgressRoot)
            throw Error(formatProdErrorMessage(349));
          0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        hook.memoizedState = getServerSnapshot;
        var inst = { value: getServerSnapshot, getSnapshot };
        hook.queue = inst;
        mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe2), [
          subscribe2
        ]);
        fiber.flags |= 2048;
        pushSimpleEffect(
          9,
          { destroy: void 0 },
          updateStoreInstance.bind(
            null,
            fiber,
            inst,
            getServerSnapshot,
            getSnapshot
          ),
          null
        );
        return getServerSnapshot;
      },
      useId: function() {
        var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
        if (isHydrating) {
          var JSCompiler_inline_result = treeContextOverflow;
          var idWithLeadingBit = treeContextId;
          JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
          identifierPrefix = "_" + identifierPrefix + "R_" + JSCompiler_inline_result;
          JSCompiler_inline_result = localIdCounter++;
          0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
          identifierPrefix += "_";
        } else
          JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + JSCompiler_inline_result.toString(32) + "_";
        return hook.memoizedState = identifierPrefix;
      },
      useHostTransitionStatus,
      useFormState: mountActionState,
      useActionState: mountActionState,
      useOptimistic: function(passthrough) {
        var hook = mountWorkInProgressHook();
        hook.memoizedState = hook.baseState = passthrough;
        var queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        hook.queue = queue;
        hook = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          true,
          queue
        );
        queue.dispatch = hook;
        return [passthrough, hook];
      },
      useMemoCache,
      useCacheRefresh: function() {
        return mountWorkInProgressHook().memoizedState = refreshCache.bind(
          null,
          currentlyRenderingFiber
        );
      },
      useEffectEvent: function(callback) {
        var hook = mountWorkInProgressHook(), ref2 = { impl: callback };
        hook.memoizedState = ref2;
        return function() {
          if (0 !== (executionContext & 2))
            throw Error(formatProdErrorMessage(440));
          return ref2.impl.apply(void 0, arguments);
        };
      }
    }, HooksDispatcherOnUpdate = {
      readContext,
      use,
      useCallback: updateCallback,
      useContext: readContext,
      useEffect: updateEffect,
      useImperativeHandle: updateImperativeHandle,
      useInsertionEffect: updateInsertionEffect,
      useLayoutEffect: updateLayoutEffect,
      useMemo: updateMemo,
      useReducer: updateReducer,
      useRef: updateRef,
      useState: function() {
        return updateReducer(basicStateReducer);
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function(value, initialValue2) {
        var hook = updateWorkInProgressHook();
        return updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue2
        );
      },
      useTransition: function() {
        var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
          start
        ];
      },
      useSyncExternalStore: updateSyncExternalStore,
      useId: updateId2,
      useHostTransitionStatus,
      useFormState: updateActionState,
      useActionState: updateActionState,
      useOptimistic: function(passthrough, reducer2) {
        var hook = updateWorkInProgressHook();
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer2);
      },
      useMemoCache,
      useCacheRefresh: updateRefresh
    };
    HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
    var HooksDispatcherOnRerender = {
      readContext,
      use,
      useCallback: updateCallback,
      useContext: readContext,
      useEffect: updateEffect,
      useImperativeHandle: updateImperativeHandle,
      useInsertionEffect: updateInsertionEffect,
      useLayoutEffect: updateLayoutEffect,
      useMemo: updateMemo,
      useReducer: rerenderReducer,
      useRef: updateRef,
      useState: function() {
        return rerenderReducer(basicStateReducer);
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function(value, initialValue2) {
        var hook = updateWorkInProgressHook();
        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue2) : updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue2
        );
      },
      useTransition: function() {
        var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
          start
        ];
      },
      useSyncExternalStore: updateSyncExternalStore,
      useId: updateId2,
      useHostTransitionStatus,
      useFormState: rerenderActionState,
      useActionState: rerenderActionState,
      useOptimistic: function(passthrough, reducer2) {
        var hook = updateWorkInProgressHook();
        if (null !== currentHook)
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer2);
        hook.baseState = passthrough;
        return [passthrough, hook.queue.dispatch];
      },
      useMemoCache,
      useCacheRefresh: updateRefresh
    };
    HooksDispatcherOnRerender.useEffectEvent = updateEvent;
    function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
      ctor = workInProgress2.memoizedState;
      getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
      getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign2({}, ctor, getDerivedStateFromProps);
      workInProgress2.memoizedState = getDerivedStateFromProps;
      0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
    }
    var classComponentUpdater = {
      enqueueSetState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.payload = payload;
        void 0 !== callback && null !== callback && (update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      },
      enqueueReplaceState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.tag = 1;
        update.payload = payload;
        void 0 !== callback && null !== callback && (update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      },
      enqueueForceUpdate: function(inst, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.tag = 2;
        void 0 !== callback && null !== callback && (update.callback = callback);
        callback = enqueueUpdate(inst, update, lane);
        null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
      }
    };
    function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
      workInProgress2 = workInProgress2.stateNode;
      return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
    }
    function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
      workInProgress2 = instance.state;
      "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
      "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
    }
    function resolveClassComponentProps(Component, baseProps) {
      var newProps = baseProps;
      if ("ref" in baseProps) {
        newProps = {};
        for (var propName in baseProps)
          "ref" !== propName && (newProps[propName] = baseProps[propName]);
      }
      if (Component = Component.defaultProps) {
        newProps === baseProps && (newProps = assign2({}, newProps));
        for (var propName$73 in Component)
          void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
      }
      return newProps;
    }
    function defaultOnUncaughtError(error) {
      reportGlobalError(error);
    }
    function defaultOnCaughtError(error) {
      console.error(error);
    }
    function defaultOnRecoverableError(error) {
      reportGlobalError(error);
    }
    function logUncaughtError(root3, errorInfo) {
      try {
        var onUncaughtError = root3.onUncaughtError;
        onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
      } catch (e$74) {
        setTimeout(function() {
          throw e$74;
        });
      }
    }
    function logCaughtError(root3, boundary, errorInfo) {
      try {
        var onCaughtError = root3.onCaughtError;
        onCaughtError(errorInfo.value, {
          componentStack: errorInfo.stack,
          errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
        });
      } catch (e$75) {
        setTimeout(function() {
          throw e$75;
        });
      }
    }
    function createRootErrorUpdate(root3, errorInfo, lane) {
      lane = createUpdate(lane);
      lane.tag = 3;
      lane.payload = { element: null };
      lane.callback = function() {
        logUncaughtError(root3, errorInfo);
      };
      return lane;
    }
    function createClassErrorUpdate(lane) {
      lane = createUpdate(lane);
      lane.tag = 3;
      return lane;
    }
    function initializeClassErrorUpdate(update, root3, fiber, errorInfo) {
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if ("function" === typeof getDerivedStateFromError) {
        var error = errorInfo.value;
        update.payload = function() {
          return getDerivedStateFromError(error);
        };
        update.callback = function() {
          logCaughtError(root3, fiber, errorInfo);
        };
      }
      var inst = fiber.stateNode;
      null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
        logCaughtError(root3, fiber, errorInfo);
        "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
        var stack2 = errorInfo.stack;
        this.componentDidCatch(errorInfo.value, {
          componentStack: null !== stack2 ? stack2 : ""
        });
      });
    }
    function throwException(root3, returnFiber, sourceFiber, value, rootRenderLanes) {
      sourceFiber.flags |= 32768;
      if (null !== value && "object" === typeof value && "function" === typeof value.then) {
        returnFiber = sourceFiber.alternate;
        null !== returnFiber && propagateParentContextChanges(
          returnFiber,
          sourceFiber,
          rootRenderLanes,
          true
        );
        sourceFiber = suspenseHandlerStackCursor.current;
        if (null !== sourceFiber) {
          switch (sourceFiber.tag) {
            case 31:
            case 13:
              return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([value]) : returnFiber.add(value), attachPingListener(root3, value, rootRenderLanes)), false;
            case 22:
              return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                transitions: null,
                markerInstances: null,
                retryQueue: new Set([value])
              }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([value]) : sourceFiber.add(value)), attachPingListener(root3, value, rootRenderLanes)), false;
          }
          throw Error(formatProdErrorMessage(435, sourceFiber.tag));
        }
        attachPingListener(root3, value, rootRenderLanes);
        renderDidSuspendDelayIfPossible();
        return false;
      }
      if (isHydrating)
        return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root3 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root3, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
          cause: value
        }), queueHydrationError(
          createCapturedValueAtFiber(returnFiber, sourceFiber)
        )), root3 = root3.current.alternate, root3.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root3.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
          root3.stateNode,
          value,
          rootRenderLanes
        ), enqueueCapturedUpdate(root3, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
      var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
      wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
      null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
      4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
      if (null === returnFiber) return true;
      value = createCapturedValueAtFiber(value, sourceFiber);
      sourceFiber = returnFiber;
      do {
        switch (sourceFiber.tag) {
          case 3:
            return sourceFiber.flags |= 65536, root3 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root3, root3 = createRootErrorUpdate(sourceFiber.stateNode, value, root3), enqueueCapturedUpdate(sourceFiber, root3), false;
          case 1:
            if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
              return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                rootRenderLanes,
                root3,
                sourceFiber,
                value
              ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
        }
        sourceFiber = sourceFiber.return;
      } while (null !== sourceFiber);
      return false;
    }
    var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = false;
    function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
      workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
        workInProgress2,
        current.child,
        nextChildren,
        renderLanes2
      );
    }
    function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
      Component = Component.render;
      var ref2 = workInProgress2.ref;
      if ("ref" in nextProps) {
        var propsWithoutRef = {};
        for (var key in nextProps)
          "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
      } else propsWithoutRef = nextProps;
      prepareToReadContext(workInProgress2);
      nextProps = renderWithHooks(
        current,
        workInProgress2,
        Component,
        propsWithoutRef,
        ref2,
        renderLanes2
      );
      key = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && key && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      if (null === current) {
        var type4 = Component.type;
        if ("function" === typeof type4 && !shouldConstruct(type4) && void 0 === type4.defaultProps && null === Component.compare)
          return workInProgress2.tag = 15, workInProgress2.type = type4, updateSimpleMemoComponent(
            current,
            workInProgress2,
            type4,
            nextProps,
            renderLanes2
          );
        current = createFiberFromTypeAndProps(
          Component.type,
          null,
          nextProps,
          workInProgress2,
          workInProgress2.mode,
          renderLanes2
        );
        current.ref = workInProgress2.ref;
        current.return = workInProgress2;
        return workInProgress2.child = current;
      }
      type4 = current.child;
      if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
        var prevProps = type4.memoizedProps;
        Component = Component.compare;
        Component = null !== Component ? Component : shallowEqual;
        if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
          return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      workInProgress2.flags |= 1;
      current = createWorkInProgress(type4, nextProps);
      current.ref = workInProgress2.ref;
      current.return = workInProgress2;
      return workInProgress2.child = current;
    }
    function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      if (null !== current) {
        var prevProps = current.memoizedProps;
        if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
          if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
            0 !== (current.flags & 131072) && (didReceiveUpdate = true);
          else
            return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      return updateFunctionComponent(
        current,
        workInProgress2,
        Component,
        nextProps,
        renderLanes2
      );
    }
    function updateOffscreenComponent(current, workInProgress2, renderLanes2, nextProps) {
      var nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
      null === current && null === workInProgress2.stateNode && (workInProgress2.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      });
      if ("hidden" === nextProps.mode) {
        if (0 !== (workInProgress2.flags & 128)) {
          prevState = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
          if (null !== current) {
            nextProps = workInProgress2.child = current.child;
            for (nextChildren = 0; null !== nextProps; )
              nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
            nextProps = nextChildren & ~prevState;
          } else nextProps = 0, workInProgress2.child = null;
          return deferHiddenOffscreenComponent(
            current,
            workInProgress2,
            prevState,
            renderLanes2,
            nextProps
          );
        }
        if (0 !== (renderLanes2 & 536870912))
          workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
            workInProgress2,
            null !== prevState ? prevState.cachePool : null
          ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
        else
          return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(
            current,
            workInProgress2,
            null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
            renderLanes2,
            nextProps
          );
      } else
        null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack());
      reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    function bailoutOffscreenComponent(current, workInProgress2) {
      null !== current && 22 === current.tag || null !== workInProgress2.stateNode || (workInProgress2.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      });
      return workInProgress2.sibling;
    }
    function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
      var JSCompiler_inline_result = peekCacheFromPool();
      JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
      workInProgress2.memoizedState = {
        baseLanes: nextBaseLanes,
        cachePool: JSCompiler_inline_result
      };
      null !== current && pushTransition(workInProgress2, null);
      reuseHiddenContextOnStack();
      pushOffscreenSuspenseHandler(workInProgress2);
      null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
      workInProgress2.childLanes = remainingChildLanes;
      return null;
    }
    function mountActivityChildren(workInProgress2, nextProps) {
      nextProps = mountWorkInProgressOffscreenFiber(
        { mode: nextProps.mode, children: nextProps.children },
        workInProgress2.mode
      );
      nextProps.ref = workInProgress2.ref;
      workInProgress2.child = nextProps;
      nextProps.return = workInProgress2;
      return nextProps;
    }
    function retryActivityComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
      current = mountActivityChildren(workInProgress2, workInProgress2.pendingProps);
      current.flags |= 2;
      popSuspenseHandler(workInProgress2);
      workInProgress2.memoizedState = null;
      return current;
    }
    function updateActivityComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, didSuspend = 0 !== (workInProgress2.flags & 128);
      workInProgress2.flags &= -129;
      if (null === current) {
        if (isHydrating) {
          if ("hidden" === nextProps.mode)
            return current = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current);
          pushDehydratedActivitySuspenseHandler(workInProgress2);
          (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
            current,
            rootOrSingletonContext
          ), current = null !== current && "&" === current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
            dehydrated: current,
            treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
            retryLane: 536870912,
            hydrationErrors: null
          }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
          if (null === current) throw throwOnHydrationMismatch(workInProgress2);
          workInProgress2.lanes = 536870912;
          return null;
        }
        return mountActivityChildren(workInProgress2, nextProps);
      }
      var prevState = current.memoizedState;
      if (null !== prevState) {
        var dehydrated = prevState.dehydrated;
        pushDehydratedActivitySuspenseHandler(workInProgress2);
        if (didSuspend)
          if (workInProgress2.flags & 256)
            workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          else if (null !== workInProgress2.memoizedState)
            workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null;
          else throw Error(formatProdErrorMessage(558));
        else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), didSuspend = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || didSuspend) {
          nextProps = workInProgressRoot;
          if (null !== nextProps && (dehydrated = getBumpedLaneForHydration(nextProps, renderLanes2), 0 !== dehydrated && dehydrated !== prevState.retryLane))
            throw prevState.retryLane = dehydrated, enqueueConcurrentRenderForLane(current, dehydrated), scheduleUpdateOnFiber(nextProps, current, dehydrated), SelectiveHydrationException;
          renderDidSuspendDelayIfPossible();
          workInProgress2 = retryActivityComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else
          current = prevState.treeContext, nextHydratableInstance = getNextHydratable(dehydrated.nextSibling), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
        return workInProgress2;
      }
      current = createWorkInProgress(current.child, {
        mode: nextProps.mode,
        children: nextProps.children
      });
      current.ref = workInProgress2.ref;
      workInProgress2.child = current;
      current.return = workInProgress2;
      return current;
    }
    function markRef(current, workInProgress2) {
      var ref2 = workInProgress2.ref;
      if (null === ref2)
        null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
      else {
        if ("function" !== typeof ref2 && "object" !== typeof ref2)
          throw Error(formatProdErrorMessage(284));
        if (null === current || current.ref !== ref2)
          workInProgress2.flags |= 4194816;
      }
    }
    function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      prepareToReadContext(workInProgress2);
      Component = renderWithHooks(
        current,
        workInProgress2,
        Component,
        nextProps,
        void 0,
        renderLanes2
      );
      nextProps = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, Component, renderLanes2);
      return workInProgress2.child;
    }
    function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
      prepareToReadContext(workInProgress2);
      workInProgress2.updateQueue = null;
      nextProps = renderWithHooksAgain(
        workInProgress2,
        Component,
        nextProps,
        secondArg
      );
      finishRenderingHooks(current);
      Component = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && Component && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      prepareToReadContext(workInProgress2);
      if (null === workInProgress2.stateNode) {
        var context = emptyContextObject, contextType = Component.contextType;
        "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
        context = new Component(nextProps, context);
        workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
        context.updater = classComponentUpdater;
        workInProgress2.stateNode = context;
        context._reactInternals = workInProgress2;
        context = workInProgress2.stateNode;
        context.props = nextProps;
        context.state = workInProgress2.memoizedState;
        context.refs = {};
        initializeUpdateQueue(workInProgress2);
        contextType = Component.contextType;
        context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
        context.state = workInProgress2.memoizedState;
        contextType = Component.getDerivedStateFromProps;
        "function" === typeof contextType && (applyDerivedStateFromProps(
          workInProgress2,
          Component,
          contextType,
          nextProps
        ), context.state = workInProgress2.memoizedState);
        "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
        "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
        nextProps = true;
      } else if (null === current) {
        context = workInProgress2.stateNode;
        var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
        context.props = oldProps;
        var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
        contextType = emptyContextObject;
        "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
        var getDerivedStateFromProps = Component.getDerivedStateFromProps;
        contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
        unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
        contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
          workInProgress2,
          context,
          nextProps,
          contextType
        );
        hasForceUpdate = false;
        var oldState = workInProgress2.memoizedState;
        context.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        oldContext = workInProgress2.memoizedState;
        unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
          workInProgress2,
          Component,
          getDerivedStateFromProps,
          nextProps
        ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
          workInProgress2,
          Component,
          oldProps,
          nextProps,
          oldState,
          oldContext,
          contextType
        )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
      } else {
        context = workInProgress2.stateNode;
        cloneUpdateQueue(current, workInProgress2);
        contextType = workInProgress2.memoizedProps;
        contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
        context.props = contextType$jscomp$0;
        getDerivedStateFromProps = workInProgress2.pendingProps;
        oldState = context.context;
        oldContext = Component.contextType;
        oldProps = emptyContextObject;
        "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
        unresolvedOldProps = Component.getDerivedStateFromProps;
        (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
          workInProgress2,
          context,
          nextProps,
          oldProps
        );
        hasForceUpdate = false;
        oldState = workInProgress2.memoizedState;
        context.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        var newState = workInProgress2.memoizedState;
        contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
          workInProgress2,
          Component,
          unresolvedOldProps,
          nextProps
        ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
          workInProgress2,
          Component,
          contextType$jscomp$0,
          nextProps,
          oldState,
          newState,
          oldProps
        ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
          nextProps,
          newState,
          oldProps
        )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
      }
      context = nextProps;
      markRef(current, workInProgress2);
      nextProps = 0 !== (workInProgress2.flags & 128);
      context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
        workInProgress2,
        current.child,
        null,
        renderLanes2
      ), workInProgress2.child = reconcileChildFibers(
        workInProgress2,
        null,
        Component,
        renderLanes2
      )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
        current,
        workInProgress2,
        renderLanes2
      );
      return current;
    }
    function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
      resetHydrationState();
      workInProgress2.flags |= 256;
      reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    var SUSPENDED_MARKER = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    };
    function mountSuspenseOffscreenState(renderLanes2) {
      return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
    }
    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
      current = null !== current ? current.childLanes & ~renderLanes2 : 0;
      primaryTreeDidDefer && (current |= workInProgressDeferredLane);
      return current;
    }
    function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
      (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
      JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
      JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
      workInProgress2.flags &= -33;
      if (null === current) {
        if (isHydrating) {
          showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack();
          (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
            current,
            rootOrSingletonContext
          ), current = null !== current && "&" !== current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
            dehydrated: current,
            treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
            retryLane: 536870912,
            hydrationErrors: null
          }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
          if (null === current) throw throwOnHydrationMismatch(workInProgress2);
          isSuspenseInstanceFallback(current) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
          return null;
        }
        var nextPrimaryChildren = nextProps.children;
        nextProps = nextProps.fallback;
        if (showFallback)
          return reuseSuspenseHandlerOnStack(), showFallback = workInProgress2.mode, nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
            { mode: "hidden", children: nextPrimaryChildren },
            showFallback
          ), nextProps = createFiberFromFragment(
            nextProps,
            showFallback,
            renderLanes2,
            null
          ), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextPrimaryChildren.sibling = nextProps, workInProgress2.child = nextPrimaryChildren, nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(null, nextProps);
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
      }
      var prevState = current.memoizedState;
      if (null !== prevState && (nextPrimaryChildren = prevState.dehydrated, null !== nextPrimaryChildren)) {
        if (didSuspend)
          workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
            { mode: "visible", children: nextProps.children },
            showFallback
          ), nextPrimaryChildren = createFiberFromFragment(
            nextPrimaryChildren,
            showFallback,
            renderLanes2,
            null
          ), nextPrimaryChildren.flags |= 2, nextProps.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, reconcileChildFibers(
            workInProgress2,
            current.child,
            null,
            renderLanes2
          ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(null, nextProps));
        else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextPrimaryChildren)) {
          JSCompiler_temp = nextPrimaryChildren.nextSibling && nextPrimaryChildren.nextSibling.dataset;
          if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
          JSCompiler_temp = digest;
          nextProps = Error(formatProdErrorMessage(419));
          nextProps.stack = "";
          nextProps.digest = JSCompiler_temp;
          queueHydrationError({ value: nextProps, source: null, stack: null });
          workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
          JSCompiler_temp = workInProgressRoot;
          if (null !== JSCompiler_temp && (nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes2), 0 !== nextProps && nextProps !== prevState.retryLane))
            throw prevState.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
          isSuspenseInstancePending(nextPrimaryChildren) || renderDidSuspendDelayIfPossible();
          workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else
          isSuspenseInstancePending(nextPrimaryChildren) ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(
            nextPrimaryChildren.nextSibling
          ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountSuspensePrimaryChildren(
            workInProgress2,
            nextProps.children
          ), workInProgress2.flags |= 4096);
        return workInProgress2;
      }
      if (showFallback)
        return reuseSuspenseHandlerOnStack(), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, prevState = current.child, digest = prevState.sibling, nextProps = createWorkInProgress(prevState, {
          mode: "hidden",
          children: nextProps.children
        }), nextProps.subtreeFlags = prevState.subtreeFlags & 65011712, null !== digest ? nextPrimaryChildren = createWorkInProgress(
          digest,
          nextPrimaryChildren
        ) : (nextPrimaryChildren = createFiberFromFragment(
          nextPrimaryChildren,
          showFallback,
          renderLanes2,
          null
        ), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, bailoutOffscreenComponent(null, nextProps), nextProps = workInProgress2.child, nextPrimaryChildren = current.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (showFallback = nextPrimaryChildren.cachePool, null !== showFallback ? (prevState = CacheContext._currentValue, showFallback = showFallback.parent !== prevState ? { parent: prevState, pool: prevState } : showFallback) : showFallback = getSuspendedCache(), nextPrimaryChildren = {
          baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
          cachePool: showFallback
        }), nextProps.memoizedState = nextPrimaryChildren, nextProps.childLanes = getRemainingWorkInPrimaryTree(
          current,
          JSCompiler_temp,
          renderLanes2
        ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(current.child, nextProps);
      pushPrimaryTreeSuspenseHandler(workInProgress2);
      renderLanes2 = current.child;
      current = renderLanes2.sibling;
      renderLanes2 = createWorkInProgress(renderLanes2, {
        mode: "visible",
        children: nextProps.children
      });
      renderLanes2.return = workInProgress2;
      renderLanes2.sibling = null;
      null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
      workInProgress2.child = renderLanes2;
      workInProgress2.memoizedState = null;
      return renderLanes2;
    }
    function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
      primaryChildren = mountWorkInProgressOffscreenFiber(
        { mode: "visible", children: primaryChildren },
        workInProgress2.mode
      );
      primaryChildren.return = workInProgress2;
      return workInProgress2.child = primaryChildren;
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
      offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
      offscreenProps.lanes = 0;
      return offscreenProps;
    }
    function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
      current = mountSuspensePrimaryChildren(
        workInProgress2,
        workInProgress2.pendingProps.children
      );
      current.flags |= 2;
      workInProgress2.memoizedState = null;
      return current;
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
      fiber.lanes |= renderLanes2;
      var alternate = fiber.alternate;
      null !== alternate && (alternate.lanes |= renderLanes2);
      scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
    }
    function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
      var renderState = workInProgress2.memoizedState;
      null === renderState ? workInProgress2.memoizedState = {
        isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail,
        tailMode,
        treeForkCount: treeForkCount2
      } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
    }
    function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
      nextProps = nextProps.children;
      var suspenseContext = suspenseStackCursor.current, shouldForceFallback = 0 !== (suspenseContext & 2);
      shouldForceFallback ? (suspenseContext = suspenseContext & 1 | 2, workInProgress2.flags |= 128) : suspenseContext &= 1;
      push(suspenseStackCursor, suspenseContext);
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      nextProps = isHydrating ? treeForkCount : 0;
      if (!shouldForceFallback && null !== current && 0 !== (current.flags & 128))
        a: for (current = workInProgress2.child; null !== current; ) {
          if (13 === current.tag)
            null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
          else if (19 === current.tag)
            scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
          else if (null !== current.child) {
            current.child.return = current;
            current = current.child;
            continue;
          }
          if (current === workInProgress2) break a;
          for (; null === current.sibling; ) {
            if (null === current.return || current.return === workInProgress2)
              break a;
            current = current.return;
          }
          current.sibling.return = current.return;
          current = current.sibling;
        }
      switch (revealOrder) {
        case "forwards":
          renderLanes2 = workInProgress2.child;
          for (revealOrder = null; null !== renderLanes2; )
            current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
          renderLanes2 = revealOrder;
          null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
          initSuspenseListRenderState(
            workInProgress2,
            false,
            revealOrder,
            renderLanes2,
            tailMode,
            nextProps
          );
          break;
        case "backwards":
        case "unstable_legacy-backwards":
          renderLanes2 = null;
          revealOrder = workInProgress2.child;
          for (workInProgress2.child = null; null !== revealOrder; ) {
            current = revealOrder.alternate;
            if (null !== current && null === findFirstSuspended(current)) {
              workInProgress2.child = revealOrder;
              break;
            }
            current = revealOrder.sibling;
            revealOrder.sibling = renderLanes2;
            renderLanes2 = revealOrder;
            revealOrder = current;
          }
          initSuspenseListRenderState(
            workInProgress2,
            true,
            renderLanes2,
            null,
            tailMode,
            nextProps
          );
          break;
        case "together":
          initSuspenseListRenderState(
            workInProgress2,
            false,
            null,
            null,
            void 0,
            nextProps
          );
          break;
        default:
          workInProgress2.memoizedState = null;
      }
      return workInProgress2.child;
    }
    function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
      null !== current && (workInProgress2.dependencies = current.dependencies);
      workInProgressRootSkippedLanes |= workInProgress2.lanes;
      if (0 === (renderLanes2 & workInProgress2.childLanes))
        if (null !== current) {
          if (propagateParentContextChanges(
            current,
            workInProgress2,
            renderLanes2,
            false
          ), 0 === (renderLanes2 & workInProgress2.childLanes))
            return null;
        } else return null;
      if (null !== current && workInProgress2.child !== current.child)
        throw Error(formatProdErrorMessage(153));
      if (null !== workInProgress2.child) {
        current = workInProgress2.child;
        renderLanes2 = createWorkInProgress(current, current.pendingProps);
        workInProgress2.child = renderLanes2;
        for (renderLanes2.return = workInProgress2; null !== current.sibling; )
          current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
      }
      return workInProgress2.child;
    }
    function checkScheduledUpdateOrContext(current, renderLanes2) {
      if (0 !== (current.lanes & renderLanes2)) return true;
      current = current.dependencies;
      return null !== current && checkIfContextChanged(current) ? true : false;
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
      switch (workInProgress2.tag) {
        case 3:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
          resetHydrationState();
          break;
        case 27:
        case 5:
          pushHostContext(workInProgress2);
          break;
        case 4:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          break;
        case 10:
          pushProvider(
            workInProgress2,
            workInProgress2.type,
            workInProgress2.memoizedProps.value
          );
          break;
        case 31:
          if (null !== workInProgress2.memoizedState)
            return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
          break;
        case 13:
          var state$102 = workInProgress2.memoizedState;
          if (null !== state$102) {
            if (null !== state$102.dehydrated)
              return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
            if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
              return updateSuspenseComponent(current, workInProgress2, renderLanes2);
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            current = bailoutOnAlreadyFinishedWork(
              current,
              workInProgress2,
              renderLanes2
            );
            return null !== current ? current.sibling : null;
          }
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          break;
        case 19:
          var didSuspendBefore = 0 !== (current.flags & 128);
          state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes);
          state$102 || (propagateParentContextChanges(
            current,
            workInProgress2,
            renderLanes2,
            false
          ), state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes));
          if (didSuspendBefore) {
            if (state$102)
              return updateSuspenseListComponent(
                current,
                workInProgress2,
                renderLanes2
              );
            workInProgress2.flags |= 128;
          }
          didSuspendBefore = workInProgress2.memoizedState;
          null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
          push(suspenseStackCursor, suspenseStackCursor.current);
          if (state$102) break;
          else return null;
        case 22:
          return workInProgress2.lanes = 0, updateOffscreenComponent(
            current,
            workInProgress2,
            renderLanes2,
            workInProgress2.pendingProps
          );
        case 24:
          pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
      }
      return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    }
    function beginWork(current, workInProgress2, renderLanes2) {
      if (null !== current)
        if (current.memoizedProps !== workInProgress2.pendingProps)
          didReceiveUpdate = true;
        else {
          if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
            return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
              current,
              workInProgress2,
              renderLanes2
            );
          didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
        }
      else
        didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
      workInProgress2.lanes = 0;
      switch (workInProgress2.tag) {
        case 16:
          a: {
            var props = workInProgress2.pendingProps;
            current = resolveLazy(workInProgress2.elementType);
            workInProgress2.type = current;
            if ("function" === typeof current)
              shouldConstruct(current) ? (props = resolveClassComponentProps(current, props), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                null,
                workInProgress2,
                current,
                props,
                renderLanes2
              )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                null,
                workInProgress2,
                current,
                props,
                renderLanes2
              ));
            else {
              if (void 0 !== current && null !== current) {
                var $$typeof = current.$$typeof;
                if ($$typeof === REACT_FORWARD_REF_TYPE) {
                  workInProgress2.tag = 11;
                  workInProgress2 = updateForwardRef(
                    null,
                    workInProgress2,
                    current,
                    props,
                    renderLanes2
                  );
                  break a;
                } else if ($$typeof === REACT_MEMO_TYPE) {
                  workInProgress2.tag = 14;
                  workInProgress2 = updateMemoComponent(
                    null,
                    workInProgress2,
                    current,
                    props,
                    renderLanes2
                  );
                  break a;
                }
              }
              workInProgress2 = getComponentNameFromType(current) || current;
              throw Error(formatProdErrorMessage(306, workInProgress2, ""));
            }
          }
          return workInProgress2;
        case 0:
          return updateFunctionComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 1:
          return props = workInProgress2.type, $$typeof = resolveClassComponentProps(
            props,
            workInProgress2.pendingProps
          ), updateClassComponent(
            current,
            workInProgress2,
            props,
            $$typeof,
            renderLanes2
          );
        case 3:
          a: {
            pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            );
            if (null === current) throw Error(formatProdErrorMessage(387));
            props = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            $$typeof = prevState.element;
            cloneUpdateQueue(current, workInProgress2);
            processUpdateQueue(workInProgress2, props, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            props = nextState.cache;
            pushProvider(workInProgress2, CacheContext, props);
            props !== prevState.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            );
            suspendIfUpdateReadFromEntangledAsyncAction();
            props = nextState.element;
            if (prevState.isDehydrated)
              if (prevState = {
                element: props,
                isDehydrated: false,
                cache: nextState.cache
              }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                workInProgress2 = mountHostRootWithoutHydrating(
                  current,
                  workInProgress2,
                  props,
                  renderLanes2
                );
                break a;
              } else if (props !== $$typeof) {
                $$typeof = createCapturedValueAtFiber(
                  Error(formatProdErrorMessage(424)),
                  workInProgress2
                );
                queueHydrationError($$typeof);
                workInProgress2 = mountHostRootWithoutHydrating(
                  current,
                  workInProgress2,
                  props,
                  renderLanes2
                );
                break a;
              } else {
                current = workInProgress2.stateNode.containerInfo;
                switch (current.nodeType) {
                  case 9:
                    current = current.body;
                    break;
                  default:
                    current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
                }
                nextHydratableInstance = getNextHydratable(current.firstChild);
                hydrationParentFiber = workInProgress2;
                isHydrating = true;
                hydrationErrors = null;
                rootOrSingletonContext = true;
                renderLanes2 = mountChildFibers(
                  workInProgress2,
                  null,
                  props,
                  renderLanes2
                );
                for (workInProgress2.child = renderLanes2; renderLanes2; )
                  renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
              }
            else {
              resetHydrationState();
              if (props === $$typeof) {
                workInProgress2 = bailoutOnAlreadyFinishedWork(
                  current,
                  workInProgress2,
                  renderLanes2
                );
                break a;
              }
              reconcileChildren(current, workInProgress2, props, renderLanes2);
            }
            workInProgress2 = workInProgress2.child;
          }
          return workInProgress2;
        case 26:
          return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
            workInProgress2.type,
            null,
            workInProgress2.pendingProps,
            null
          )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, props = getOwnerDocumentFromRootContainer(
            rootInstanceStackCursor.current
          ).createElement(renderLanes2), props[internalInstanceKey] = workInProgress2, props[internalPropsKey] = current, setInitialProperties(props, renderLanes2, current), markNodeAsHoistable(props), workInProgress2.stateNode = props) : workInProgress2.memoizedState = getResource(
            workInProgress2.type,
            current.memoizedProps,
            workInProgress2.pendingProps,
            current.memoizedState
          ), null;
        case 27:
          return pushHostContext(workInProgress2), null === current && isHydrating && (props = workInProgress2.stateNode = resolveSingletonInstance(
            workInProgress2.type,
            workInProgress2.pendingProps,
            rootInstanceStackCursor.current
          ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, $$typeof = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = $$typeof, nextHydratableInstance = getNextHydratable(props.firstChild)) : nextHydratableInstance = $$typeof), reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
        case 5:
          if (null === current && isHydrating) {
            if ($$typeof = props = nextHydratableInstance)
              props = canHydrateInstance(
                props,
                workInProgress2.type,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== props ? (workInProgress2.stateNode = props, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(props.firstChild), rootOrSingletonContext = false, $$typeof = true) : $$typeof = false;
            $$typeof || throwOnHydrationMismatch(workInProgress2);
          }
          pushHostContext(workInProgress2);
          $$typeof = workInProgress2.type;
          prevState = workInProgress2.pendingProps;
          nextState = null !== current ? current.memoizedProps : null;
          props = prevState.children;
          shouldSetTextContent($$typeof, prevState) ? props = null : null !== nextState && shouldSetTextContent($$typeof, nextState) && (workInProgress2.flags |= 32);
          null !== workInProgress2.memoizedState && ($$typeof = renderWithHooks(
            current,
            workInProgress2,
            TransitionAwareHostComponent,
            null,
            null,
            renderLanes2
          ), HostTransitionContext._currentValue = $$typeof);
          markRef(current, workInProgress2);
          reconcileChildren(current, workInProgress2, props, renderLanes2);
          return workInProgress2.child;
        case 6:
          if (null === current && isHydrating) {
            if (current = renderLanes2 = nextHydratableInstance)
              renderLanes2 = canHydrateTextInstance(
                renderLanes2,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
            current || throwOnHydrationMismatch(workInProgress2);
          }
          return null;
        case 13:
          return updateSuspenseComponent(current, workInProgress2, renderLanes2);
        case 4:
          return pushHostContainer(
            workInProgress2,
            workInProgress2.stateNode.containerInfo
          ), props = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
            workInProgress2,
            null,
            props,
            renderLanes2
          ) : reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
        case 11:
          return updateForwardRef(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 7:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps,
            renderLanes2
          ), workInProgress2.child;
        case 8:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 12:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 10:
          return props = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, props.value), reconcileChildren(current, workInProgress2, props.children, renderLanes2), workInProgress2.child;
        case 9:
          return $$typeof = workInProgress2.type._context, props = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), $$typeof = readContext($$typeof), props = props($$typeof), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
        case 14:
          return updateMemoComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 15:
          return updateSimpleMemoComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 19:
          return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
        case 31:
          return updateActivityComponent(current, workInProgress2, renderLanes2);
        case 22:
          return updateOffscreenComponent(
            current,
            workInProgress2,
            renderLanes2,
            workInProgress2.pendingProps
          );
        case 24:
          return prepareToReadContext(workInProgress2), props = readContext(CacheContext), null === current ? ($$typeof = peekCacheFromPool(), null === $$typeof && ($$typeof = workInProgressRoot, prevState = createCache3(), $$typeof.pooledCache = prevState, prevState.refCount++, null !== prevState && ($$typeof.pooledCacheLanes |= renderLanes2), $$typeof = prevState), workInProgress2.memoizedState = { parent: props, cache: $$typeof }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, $$typeof)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), $$typeof = current.memoizedState, prevState = workInProgress2.memoizedState, $$typeof.parent !== props ? ($$typeof = { parent: props, cache: props }, workInProgress2.memoizedState = $$typeof, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = $$typeof), pushProvider(workInProgress2, CacheContext, props)) : (props = prevState.cache, pushProvider(workInProgress2, CacheContext, props), props !== $$typeof.cache && propagateContextChanges(
            workInProgress2,
            [CacheContext],
            renderLanes2,
            true
          ))), reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 29:
          throw workInProgress2.pendingProps;
      }
      throw Error(formatProdErrorMessage(156, workInProgress2.tag));
    }
    function markUpdate(workInProgress2) {
      workInProgress2.flags |= 4;
    }
    function preloadInstanceAndSuspendIfNeeded(workInProgress2, type4, oldProps, newProps, renderLanes2) {
      if (type4 = 0 !== (workInProgress2.mode & 32)) type4 = false;
      if (type4) {
        if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
          if (workInProgress2.stateNode.complete) workInProgress2.flags |= 8192;
          else if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
          else
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      } else workInProgress2.flags &= -16777217;
    }
    function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
      if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
        workInProgress2.flags &= -16777217;
      else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
        if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
        else
          throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
    }
    function scheduleRetryEffect(workInProgress2, retryQueue) {
      null !== retryQueue && (workInProgress2.flags |= 4);
      workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
    }
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!isHydrating)
        switch (renderState.tailMode) {
          case "hidden":
            hasRenderedATailFallback = renderState.tail;
            for (var lastTailNode = null; null !== hasRenderedATailFallback; )
              null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
            null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
            break;
          case "collapsed":
            lastTailNode = renderState.tail;
            for (var lastTailNode$106 = null; null !== lastTailNode; )
              null !== lastTailNode.alternate && (lastTailNode$106 = lastTailNode), lastTailNode = lastTailNode.sibling;
            null === lastTailNode$106 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$106.sibling = null;
        }
    }
    function bubbleProperties(completedWork) {
      var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
      if (didBailout)
        for (var child$107 = completedWork.child; null !== child$107; )
          newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags & 65011712, subtreeFlags |= child$107.flags & 65011712, child$107.return = completedWork, child$107 = child$107.sibling;
      else
        for (child$107 = completedWork.child; null !== child$107; )
          newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags, subtreeFlags |= child$107.flags, child$107.return = completedWork, child$107 = child$107.sibling;
      completedWork.subtreeFlags |= subtreeFlags;
      completedWork.childLanes = newChildLanes;
      return didBailout;
    }
    function completeWork(current, workInProgress2, renderLanes2) {
      var newProps = workInProgress2.pendingProps;
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return bubbleProperties(workInProgress2), null;
        case 1:
          return bubbleProperties(workInProgress2), null;
        case 3:
          renderLanes2 = workInProgress2.stateNode;
          newProps = null;
          null !== current && (newProps = current.memoizedState.cache);
          workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
          popProvider(CacheContext);
          popHostContainer();
          renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
          if (null === current || null === current.child)
            popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
          bubbleProperties(workInProgress2);
          return null;
        case 26:
          var type4 = workInProgress2.type, nextResource = workInProgress2.memoizedState;
          null === current ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
            workInProgress2,
            type4,
            null,
            newProps,
            renderLanes2
          ))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current = current.memoizedProps, current !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
            workInProgress2,
            type4,
            current,
            newProps,
            renderLanes2
          ));
          return null;
        case 27:
          popHostContext(workInProgress2);
          renderLanes2 = rootInstanceStackCursor.current;
          type4 = workInProgress2.type;
          if (null !== current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if (!newProps) {
              if (null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              bubbleProperties(workInProgress2);
              return null;
            }
            current = contextStackCursor.current;
            popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2) : (current = resolveSingletonInstance(type4, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
          }
          bubbleProperties(workInProgress2);
          return null;
        case 5:
          popHostContext(workInProgress2);
          type4 = workInProgress2.type;
          if (null !== current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if (!newProps) {
              if (null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              bubbleProperties(workInProgress2);
              return null;
            }
            nextResource = contextStackCursor.current;
            if (popHydrationState(workInProgress2))
              prepareToHydrateHostInstance(workInProgress2);
            else {
              var ownerDocument = getOwnerDocumentFromRootContainer(
                rootInstanceStackCursor.current
              );
              switch (nextResource) {
                case 1:
                  nextResource = ownerDocument.createElementNS(
                    "http://www.w3.org/2000/svg",
                    type4
                  );
                  break;
                case 2:
                  nextResource = ownerDocument.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    type4
                  );
                  break;
                default:
                  switch (type4) {
                    case "svg":
                      nextResource = ownerDocument.createElementNS(
                        "http://www.w3.org/2000/svg",
                        type4
                      );
                      break;
                    case "math":
                      nextResource = ownerDocument.createElementNS(
                        "http://www.w3.org/1998/Math/MathML",
                        type4
                      );
                      break;
                    case "script":
                      nextResource = ownerDocument.createElement("div");
                      nextResource.innerHTML = "<script><\/script>";
                      nextResource = nextResource.removeChild(
                        nextResource.firstChild
                      );
                      break;
                    case "select":
                      nextResource = "string" === typeof newProps.is ? ownerDocument.createElement("select", {
                        is: newProps.is
                      }) : ownerDocument.createElement("select");
                      newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                      break;
                    default:
                      nextResource = "string" === typeof newProps.is ? ownerDocument.createElement(type4, { is: newProps.is }) : ownerDocument.createElement(type4);
                  }
              }
              nextResource[internalInstanceKey] = workInProgress2;
              nextResource[internalPropsKey] = newProps;
              a: for (ownerDocument = workInProgress2.child; null !== ownerDocument; ) {
                if (5 === ownerDocument.tag || 6 === ownerDocument.tag)
                  nextResource.appendChild(ownerDocument.stateNode);
                else if (4 !== ownerDocument.tag && 27 !== ownerDocument.tag && null !== ownerDocument.child) {
                  ownerDocument.child.return = ownerDocument;
                  ownerDocument = ownerDocument.child;
                  continue;
                }
                if (ownerDocument === workInProgress2) break a;
                for (; null === ownerDocument.sibling; ) {
                  if (null === ownerDocument.return || ownerDocument.return === workInProgress2)
                    break a;
                  ownerDocument = ownerDocument.return;
                }
                ownerDocument.sibling.return = ownerDocument.return;
                ownerDocument = ownerDocument.sibling;
              }
              workInProgress2.stateNode = nextResource;
              a: switch (setInitialProperties(nextResource, type4, newProps), type4) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  newProps = !!newProps.autoFocus;
                  break a;
                case "img":
                  newProps = true;
                  break a;
                default:
                  newProps = false;
              }
              newProps && markUpdate(workInProgress2);
            }
          }
          bubbleProperties(workInProgress2);
          preloadInstanceAndSuspendIfNeeded(
            workInProgress2,
            workInProgress2.type,
            null === current ? null : current.memoizedProps,
            workInProgress2.pendingProps,
            renderLanes2
          );
          return null;
        case 6:
          if (current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if ("string" !== typeof newProps && null === workInProgress2.stateNode)
              throw Error(formatProdErrorMessage(166));
            current = rootInstanceStackCursor.current;
            if (popHydrationState(workInProgress2)) {
              current = workInProgress2.stateNode;
              renderLanes2 = workInProgress2.memoizedProps;
              newProps = null;
              type4 = hydrationParentFiber;
              if (null !== type4)
                switch (type4.tag) {
                  case 27:
                  case 5:
                    newProps = type4.memoizedProps;
                }
              current[internalInstanceKey] = workInProgress2;
              current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
              current || throwOnHydrationMismatch(workInProgress2, true);
            } else
              current = getOwnerDocumentFromRootContainer(current).createTextNode(
                newProps
              ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
          }
          bubbleProperties(workInProgress2);
          return null;
        case 31:
          renderLanes2 = workInProgress2.memoizedState;
          if (null === current || null !== current.memoizedState) {
            newProps = popHydrationState(workInProgress2);
            if (null !== renderLanes2) {
              if (null === current) {
                if (!newProps) throw Error(formatProdErrorMessage(318));
                current = workInProgress2.memoizedState;
                current = null !== current ? current.dehydrated : null;
                if (!current) throw Error(formatProdErrorMessage(557));
                current[internalInstanceKey] = workInProgress2;
              } else
                resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
              bubbleProperties(workInProgress2);
              current = false;
            } else
              renderLanes2 = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = renderLanes2), current = true;
            if (!current) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
            if (0 !== (workInProgress2.flags & 128))
              throw Error(formatProdErrorMessage(558));
          }
          bubbleProperties(workInProgress2);
          return null;
        case 13:
          newProps = workInProgress2.memoizedState;
          if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
            type4 = popHydrationState(workInProgress2);
            if (null !== newProps && null !== newProps.dehydrated) {
              if (null === current) {
                if (!type4) throw Error(formatProdErrorMessage(318));
                type4 = workInProgress2.memoizedState;
                type4 = null !== type4 ? type4.dehydrated : null;
                if (!type4) throw Error(formatProdErrorMessage(317));
                type4[internalInstanceKey] = workInProgress2;
              } else
                resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
              bubbleProperties(workInProgress2);
              type4 = false;
            } else
              type4 = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type4), type4 = true;
            if (!type4) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
          }
          popSuspenseHandler(workInProgress2);
          if (0 !== (workInProgress2.flags & 128))
            return workInProgress2.lanes = renderLanes2, workInProgress2;
          renderLanes2 = null !== newProps;
          current = null !== current && null !== current.memoizedState;
          renderLanes2 && (newProps = workInProgress2.child, type4 = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type4 = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type4 && (newProps.flags |= 2048));
          renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
          scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
          bubbleProperties(workInProgress2);
          return null;
        case 4:
          return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
        case 10:
          return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
        case 19:
          pop(suspenseStackCursor);
          newProps = workInProgress2.memoizedState;
          if (null === newProps) return bubbleProperties(workInProgress2), null;
          type4 = 0 !== (workInProgress2.flags & 128);
          nextResource = newProps.rendering;
          if (null === nextResource)
            if (type4) cutOffTailIfNeeded(newProps, false);
            else {
              if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                for (current = workInProgress2.child; null !== current; ) {
                  nextResource = findFirstSuspended(current);
                  if (null !== nextResource) {
                    workInProgress2.flags |= 128;
                    cutOffTailIfNeeded(newProps, false);
                    current = nextResource.updateQueue;
                    workInProgress2.updateQueue = current;
                    scheduleRetryEffect(workInProgress2, current);
                    workInProgress2.subtreeFlags = 0;
                    current = renderLanes2;
                    for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                      resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                    push(
                      suspenseStackCursor,
                      suspenseStackCursor.current & 1 | 2
                    );
                    isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                    return workInProgress2.child;
                  }
                  current = current.sibling;
                }
              null !== newProps.tail && now2() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type4 = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
            }
          else {
            if (!type4)
              if (current = findFirstSuspended(nextResource), null !== current) {
                if (workInProgress2.flags |= 128, type4 = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating)
                  return bubbleProperties(workInProgress2), null;
              } else
                2 * now2() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, type4 = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
            newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current = newProps.last, null !== current ? current.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
          }
          if (null !== newProps.tail)
            return current = newProps.tail, newProps.rendering = current, newProps.tail = current.sibling, newProps.renderingStartTime = now2(), current.sibling = null, renderLanes2 = suspenseStackCursor.current, push(
              suspenseStackCursor,
              type4 ? renderLanes2 & 1 | 2 : renderLanes2 & 1
            ), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current;
          bubbleProperties(workInProgress2);
          return null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
        case 24:
          return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(formatProdErrorMessage(156, workInProgress2.tag));
    }
    function unwindWork(current, workInProgress2) {
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 1:
          return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 3:
          return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 26:
        case 27:
        case 5:
          return popHostContext(workInProgress2), null;
        case 31:
          if (null !== workInProgress2.memoizedState) {
            popSuspenseHandler(workInProgress2);
            if (null === workInProgress2.alternate)
              throw Error(formatProdErrorMessage(340));
            resetHydrationState();
          }
          current = workInProgress2.flags;
          return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 13:
          popSuspenseHandler(workInProgress2);
          current = workInProgress2.memoizedState;
          if (null !== current && null !== current.dehydrated) {
            if (null === workInProgress2.alternate)
              throw Error(formatProdErrorMessage(340));
            resetHydrationState();
          }
          current = workInProgress2.flags;
          return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 19:
          return pop(suspenseStackCursor), null;
        case 4:
          return popHostContainer(), null;
        case 10:
          return popProvider(workInProgress2.type), null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 24:
          return popProvider(CacheContext), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function unwindInterruptedWork(current, interruptedWork) {
      popTreeContext(interruptedWork);
      switch (interruptedWork.tag) {
        case 3:
          popProvider(CacheContext);
          popHostContainer();
          break;
        case 26:
        case 27:
        case 5:
          popHostContext(interruptedWork);
          break;
        case 4:
          popHostContainer();
          break;
        case 31:
          null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
          break;
        case 13:
          popSuspenseHandler(interruptedWork);
          break;
        case 19:
          pop(suspenseStackCursor);
          break;
        case 10:
          popProvider(interruptedWork.type);
          break;
        case 22:
        case 23:
          popSuspenseHandler(interruptedWork);
          popHiddenContext();
          null !== current && pop(resumedCache);
          break;
        case 24:
          popProvider(CacheContext);
      }
    }
    function commitHookEffectListMount(flags, finishedWork) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              lastEffect = void 0;
              var create = updateQueue.create, inst = updateQueue.inst;
              lastEffect = create();
              inst.destroy = lastEffect;
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              var inst = updateQueue.inst, destroy2 = inst.destroy;
              if (void 0 !== destroy2) {
                inst.destroy = void 0;
                lastEffect = finishedWork;
                var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy2;
                try {
                  destroy_();
                } catch (error) {
                  captureCommitPhaseError(
                    lastEffect,
                    nearestMountedAncestor,
                    error
                  );
                }
              }
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitClassCallbacks(finishedWork) {
      var updateQueue = finishedWork.updateQueue;
      if (null !== updateQueue) {
        var instance = finishedWork.stateNode;
        try {
          commitCallbacks(updateQueue, instance);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
      instance.props = resolveClassComponentProps(
        current.type,
        current.memoizedProps
      );
      instance.state = current.memoizedState;
      try {
        instance.componentWillUnmount();
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyAttachRef(current, nearestMountedAncestor) {
      try {
        var ref2 = current.ref;
        if (null !== ref2) {
          switch (current.tag) {
            case 26:
            case 27:
            case 5:
              var instanceToUse = current.stateNode;
              break;
            case 30:
              instanceToUse = current.stateNode;
              break;
            default:
              instanceToUse = current.stateNode;
          }
          "function" === typeof ref2 ? current.refCleanup = ref2(instanceToUse) : ref2.current = instanceToUse;
        }
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyDetachRef(current, nearestMountedAncestor) {
      var ref2 = current.ref, refCleanup = current.refCleanup;
      if (null !== ref2)
        if ("function" === typeof refCleanup)
          try {
            refCleanup();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          } finally {
            current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
          }
        else if ("function" === typeof ref2)
          try {
            ref2(null);
          } catch (error$140) {
            captureCommitPhaseError(current, nearestMountedAncestor, error$140);
          }
        else ref2.current = null;
    }
    function commitHostMount(finishedWork) {
      var type4 = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
      try {
        a: switch (type4) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            props.autoFocus && instance.focus();
            break a;
          case "img":
            props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHostUpdate(finishedWork, newProps, oldProps) {
      try {
        var domElement = finishedWork.stateNode;
        updateProperties(domElement, finishedWork.type, oldProps, newProps);
        domElement[internalPropsKey] = newProps;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHostParent(fiber) {
      return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
    }
    function getHostSibling(fiber) {
      a: for (; ; ) {
        for (; null === fiber.sibling; ) {
          if (null === fiber.return || isHostParent(fiber.return)) return null;
          fiber = fiber.return;
        }
        fiber.sibling.return = fiber.return;
        for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
          if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
          if (fiber.flags & 2) continue a;
          if (null === fiber.child || 4 === fiber.tag) continue a;
          else fiber.child.return = fiber, fiber = fiber.child;
        }
        if (!(fiber.flags & 2)) return fiber.stateNode;
      }
    }
    function insertOrAppendPlacementNodeIntoContainer(node2, before, parent) {
      var tag = node2.tag;
      if (5 === tag || 6 === tag)
        node2 = node2.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node2, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node2), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$12));
      else if (4 !== tag && (27 === tag && isSingletonScope(node2.type) && (parent = node2.stateNode, before = null), node2 = node2.child, null !== node2))
        for (insertOrAppendPlacementNodeIntoContainer(node2, before, parent), node2 = node2.sibling; null !== node2; )
          insertOrAppendPlacementNodeIntoContainer(node2, before, parent), node2 = node2.sibling;
    }
    function insertOrAppendPlacementNode(node2, before, parent) {
      var tag = node2.tag;
      if (5 === tag || 6 === tag)
        node2 = node2.stateNode, before ? parent.insertBefore(node2, before) : parent.appendChild(node2);
      else if (4 !== tag && (27 === tag && isSingletonScope(node2.type) && (parent = node2.stateNode), node2 = node2.child, null !== node2))
        for (insertOrAppendPlacementNode(node2, before, parent), node2 = node2.sibling; null !== node2; )
          insertOrAppendPlacementNode(node2, before, parent), node2 = node2.sibling;
    }
    function commitHostSingletonAcquisition(finishedWork) {
      var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
      try {
        for (var type4 = finishedWork.type, attributes2 = singleton.attributes; attributes2.length; )
          singleton.removeAttributeNode(attributes2[0]);
        setInitialProperties(singleton, type4, props);
        singleton[internalInstanceKey] = finishedWork;
        singleton[internalPropsKey] = props;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null;
    function commitBeforeMutationEffects(root3, firstChild) {
      root3 = root3.containerInfo;
      eventsEnabled = _enabled;
      root3 = getActiveElementDeep(root3);
      if (hasSelectionCapabilities(root3)) {
        if ("selectionStart" in root3)
          var JSCompiler_temp = {
            start: root3.selectionStart,
            end: root3.selectionEnd
          };
        else
          a: {
            JSCompiler_temp = (JSCompiler_temp = root3.ownerDocument) && JSCompiler_temp.defaultView || window;
            var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
            if (selection && 0 !== selection.rangeCount) {
              JSCompiler_temp = selection.anchorNode;
              var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
              selection = selection.focusOffset;
              try {
                JSCompiler_temp.nodeType, focusNode.nodeType;
              } catch (e$20) {
                JSCompiler_temp = null;
                break a;
              }
              var length2 = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node2 = root3, parentNode = null;
              b: for (; ; ) {
                for (var next2; ; ) {
                  node2 !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node2.nodeType || (start = length2 + anchorOffset);
                  node2 !== focusNode || 0 !== selection && 3 !== node2.nodeType || (end = length2 + selection);
                  3 === node2.nodeType && (length2 += node2.nodeValue.length);
                  if (null === (next2 = node2.firstChild)) break;
                  parentNode = node2;
                  node2 = next2;
                }
                for (; ; ) {
                  if (node2 === root3) break b;
                  parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length2);
                  parentNode === focusNode && ++indexWithinFocus === selection && (end = length2);
                  if (null !== (next2 = node2.nextSibling)) break;
                  node2 = parentNode;
                  parentNode = node2.parentNode;
                }
                node2 = next2;
              }
              JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
            } else JSCompiler_temp = null;
          }
        JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
      } else JSCompiler_temp = null;
      selectionInformation = { focusedElem: root3, selectionRange: JSCompiler_temp };
      _enabled = false;
      for (nextEffect = firstChild; null !== nextEffect; )
        if (firstChild = nextEffect, root3 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root3)
          root3.return = firstChild, nextEffect = root3;
        else
          for (; null !== nextEffect; ) {
            firstChild = nextEffect;
            focusNode = firstChild.alternate;
            root3 = firstChild.flags;
            switch (firstChild.tag) {
              case 0:
                if (0 !== (root3 & 4) && (root3 = firstChild.updateQueue, root3 = null !== root3 ? root3.events : null, null !== root3))
                  for (JSCompiler_temp = 0; JSCompiler_temp < root3.length; JSCompiler_temp++)
                    anchorOffset = root3[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
                break;
              case 11:
              case 15:
                break;
              case 1:
                if (0 !== (root3 & 1024) && null !== focusNode) {
                  root3 = void 0;
                  JSCompiler_temp = firstChild;
                  anchorOffset = focusNode.memoizedProps;
                  focusNode = focusNode.memoizedState;
                  selection = JSCompiler_temp.stateNode;
                  try {
                    var resolvedPrevProps = resolveClassComponentProps(
                      JSCompiler_temp.type,
                      anchorOffset
                    );
                    root3 = selection.getSnapshotBeforeUpdate(
                      resolvedPrevProps,
                      focusNode
                    );
                    selection.__reactInternalSnapshotBeforeUpdate = root3;
                  } catch (error) {
                    captureCommitPhaseError(
                      JSCompiler_temp,
                      JSCompiler_temp.return,
                      error
                    );
                  }
                }
                break;
              case 3:
                if (0 !== (root3 & 1024)) {
                  if (root3 = firstChild.stateNode.containerInfo, JSCompiler_temp = root3.nodeType, 9 === JSCompiler_temp)
                    clearContainerSparingly(root3);
                  else if (1 === JSCompiler_temp)
                    switch (root3.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        clearContainerSparingly(root3);
                        break;
                      default:
                        root3.textContent = "";
                    }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if (0 !== (root3 & 1024)) throw Error(formatProdErrorMessage(163));
            }
            root3 = firstChild.sibling;
            if (null !== root3) {
              root3.return = firstChild.return;
              nextEffect = root3;
              break;
            }
            nextEffect = firstChild.return;
          }
    }
    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitHookEffectListMount(5, finishedWork);
          break;
        case 1:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 4)
            if (finishedRoot = finishedWork.stateNode, null === current)
              try {
                finishedRoot.componentDidMount();
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            else {
              var prevProps = resolveClassComponentProps(
                finishedWork.type,
                current.memoizedProps
              );
              current = current.memoizedState;
              try {
                finishedRoot.componentDidUpdate(
                  prevProps,
                  current,
                  finishedRoot.__reactInternalSnapshotBeforeUpdate
                );
              } catch (error$139) {
                captureCommitPhaseError(
                  finishedWork,
                  finishedWork.return,
                  error$139
                );
              }
            }
          flags & 64 && commitClassCallbacks(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 3:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
            current = null;
            if (null !== finishedWork.child)
              switch (finishedWork.child.tag) {
                case 27:
                case 5:
                  current = finishedWork.child.stateNode;
                  break;
                case 1:
                  current = finishedWork.child.stateNode;
              }
            try {
              commitCallbacks(finishedRoot, current);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 27:
          null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          null === current && flags & 4 && commitHostMount(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          break;
        case 31:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
            null,
            finishedWork
          ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
          break;
        case 22:
          flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
          if (!flags) {
            current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
            prevProps = offscreenSubtreeIsHidden;
            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = flags;
            (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              0 !== (finishedWork.subtreeFlags & 8772)
            ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            offscreenSubtreeIsHidden = prevProps;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          }
          break;
        case 30:
          break;
        default:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      }
    }
    function detachFiberAfterEffects(fiber) {
      var alternate = fiber.alternate;
      null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
      fiber.child = null;
      fiber.deletions = null;
      fiber.sibling = null;
      5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
      fiber.stateNode = null;
      fiber.return = null;
      fiber.dependencies = null;
      fiber.memoizedProps = null;
      fiber.memoizedState = null;
      fiber.pendingProps = null;
      fiber.stateNode = null;
      fiber.updateQueue = null;
    }
    var hostParent = null, hostParentIsContainer = false;
    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
      for (parent = parent.child; null !== parent; )
        commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
    }
    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
      if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
        try {
          injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
        } catch (err) {
        }
      switch (deletedFiber.tag) {
        case 26:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
          break;
        case 27:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
          isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          releaseSingletonInstance(deletedFiber.stateNode);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 5:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        case 6:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = null;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          if (null !== hostParent)
            if (hostParentIsContainer)
              try {
                (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
            else
              try {
                hostParent.removeChild(deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
          break;
        case 18:
          null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(
            9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
            deletedFiber.stateNode
          ), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
          break;
        case 4:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = deletedFiber.stateNode.containerInfo;
          hostParentIsContainer = true;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
          offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 1:
          offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
            deletedFiber,
            nearestMountedAncestor,
            prevHostParent
          ));
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 21:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 22:
          offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          offscreenSubtreeWasHidden = prevHostParent;
          break;
        default:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
      }
    }
    function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
      if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
        finishedRoot = finishedRoot.dehydrated;
        try {
          retryIfBlockedOn(finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
        try {
          retryIfBlockedOn(finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function getRetryCache(finishedWork) {
      switch (finishedWork.tag) {
        case 31:
        case 13:
        case 19:
          var retryCache = finishedWork.stateNode;
          null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
          return retryCache;
        case 22:
          return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
        default:
          throw Error(formatProdErrorMessage(435, finishedWork.tag));
      }
    }
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
      var retryCache = getRetryCache(finishedWork);
      wakeables.forEach(function(wakeable) {
        if (!retryCache.has(wakeable)) {
          retryCache.add(wakeable);
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          wakeable.then(retry, retry);
        }
      });
    }
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
      var deletions = parentFiber.deletions;
      if (null !== deletions)
        for (var i2 = 0; i2 < deletions.length; i2++) {
          var childToDelete = deletions[i2], root3 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
          a: for (; null !== parent; ) {
            switch (parent.tag) {
              case 27:
                if (isSingletonScope(parent.type)) {
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                }
                break;
              case 5:
                hostParent = parent.stateNode;
                hostParentIsContainer = false;
                break a;
              case 3:
              case 4:
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = true;
                break a;
            }
            parent = parent.return;
          }
          if (null === hostParent) throw Error(formatProdErrorMessage(160));
          commitDeletionEffectsOnFiber(root3, returnFiber, childToDelete);
          hostParent = null;
          hostParentIsContainer = false;
          root3 = childToDelete.alternate;
          null !== root3 && (root3.return = null);
          childToDelete.return = null;
        }
      if (parentFiber.subtreeFlags & 13886)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
    }
    var currentHoistableRoot = null;
    function commitMutationEffectsOnFiber(finishedWork, root3) {
      var current = finishedWork.alternate, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
          break;
        case 1:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
          break;
        case 26:
          var hoistableRoot = currentHoistableRoot;
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          if (flags & 4) {
            var currentResource = null !== current ? current.memoizedState : null;
            flags = finishedWork.memoizedState;
            if (null === current)
              if (null === flags)
                if (null === finishedWork.stateNode) {
                  a: {
                    flags = finishedWork.type;
                    current = finishedWork.memoizedProps;
                    hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                    b: switch (flags) {
                      case "title":
                        currentResource = hoistableRoot.getElementsByTagName("title")[0];
                        if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                          currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                            currentResource,
                            hoistableRoot.querySelector("head > title")
                          );
                        setInitialProperties(currentResource, flags, current);
                        currentResource[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(currentResource);
                        flags = currentResource;
                        break a;
                      case "link":
                        var maybeNodes = getHydratableHoistableCache(
                          "link",
                          "href",
                          hoistableRoot
                        ).get(flags + (current.href || ""));
                        if (maybeNodes) {
                          for (var i2 = 0; i2 < maybeNodes.length; i2++)
                            if (currentResource = maybeNodes[i2], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                              maybeNodes.splice(i2, 1);
                              break b;
                            }
                        }
                        currentResource = hoistableRoot.createElement(flags);
                        setInitialProperties(currentResource, flags, current);
                        hoistableRoot.head.appendChild(currentResource);
                        break;
                      case "meta":
                        if (maybeNodes = getHydratableHoistableCache(
                          "meta",
                          "content",
                          hoistableRoot
                        ).get(flags + (current.content || ""))) {
                          for (i2 = 0; i2 < maybeNodes.length; i2++)
                            if (currentResource = maybeNodes[i2], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                              maybeNodes.splice(i2, 1);
                              break b;
                            }
                        }
                        currentResource = hoistableRoot.createElement(flags);
                        setInitialProperties(currentResource, flags, current);
                        hoistableRoot.head.appendChild(currentResource);
                        break;
                      default:
                        throw Error(formatProdErrorMessage(468, flags));
                    }
                    currentResource[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(currentResource);
                    flags = currentResource;
                  }
                  finishedWork.stateNode = flags;
                } else
                  mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode
                  );
              else
                finishedWork.stateNode = acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                );
            else
              currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
                hoistableRoot,
                finishedWork.type,
                finishedWork.stateNode
              ) : acquireResource(
                hoistableRoot,
                flags,
                finishedWork.memoizedProps
              )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current.memoizedProps
              );
          }
          break;
        case 27:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          null !== current && flags & 4 && commitHostUpdate(
            finishedWork,
            finishedWork.memoizedProps,
            current.memoizedProps
          );
          break;
        case 5:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          if (finishedWork.flags & 32) {
            hoistableRoot = finishedWork.stateNode;
            try {
              setTextContent(hoistableRoot, "");
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
            finishedWork,
            hoistableRoot,
            null !== current ? current.memoizedProps : hoistableRoot
          ));
          flags & 1024 && (needsFormReset = true);
          break;
        case 6:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4) {
            if (null === finishedWork.stateNode)
              throw Error(formatProdErrorMessage(162));
            flags = finishedWork.memoizedProps;
            current = finishedWork.stateNode;
            try {
              current.nodeValue = flags;
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 3:
          tagCaches = null;
          hoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(root3.containerInfo);
          recursivelyTraverseMutationEffects(root3, finishedWork);
          currentHoistableRoot = hoistableRoot;
          commitReconciliationEffects(finishedWork);
          if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
            try {
              retryIfBlockedOn(root3.containerInfo);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
          break;
        case 4:
          flags = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(
            finishedWork.stateNode.containerInfo
          );
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          currentHoistableRoot = flags;
          break;
        case 12:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          break;
        case 31:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 13:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now2());
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 22:
          hoistableRoot = null !== finishedWork.memoizedState;
          var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
          recursivelyTraverseMutationEffects(root3, finishedWork);
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
          commitReconciliationEffects(finishedWork);
          if (flags & 8192)
            a: for (root3 = finishedWork.stateNode, root3._visibility = hoistableRoot ? root3._visibility & -2 : root3._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root3 = finishedWork; ; ) {
              if (5 === root3.tag || 26 === root3.tag) {
                if (null === current) {
                  wasHidden = current = root3;
                  try {
                    if (currentResource = wasHidden.stateNode, hoistableRoot)
                      maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                    else {
                      i2 = wasHidden.stateNode;
                      var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                      i2.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                    }
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (6 === root3.tag) {
                if (null === current) {
                  wasHidden = root3;
                  try {
                    wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (18 === root3.tag) {
                if (null === current) {
                  wasHidden = root3;
                  try {
                    var instance = wasHidden.stateNode;
                    hoistableRoot ? hideOrUnhideDehydratedBoundary(instance, true) : hideOrUnhideDehydratedBoundary(wasHidden.stateNode, false);
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if ((22 !== root3.tag && 23 !== root3.tag || null === root3.memoizedState || root3 === finishedWork) && null !== root3.child) {
                root3.child.return = root3;
                root3 = root3.child;
                continue;
              }
              if (root3 === finishedWork) break a;
              for (; null === root3.sibling; ) {
                if (null === root3.return || root3.return === finishedWork) break a;
                current === root3 && (current = null);
                root3 = root3.return;
              }
              current === root3 && (current = null);
              root3.sibling.return = root3.return;
              root3 = root3.sibling;
            }
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
          break;
        case 19:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          recursivelyTraverseMutationEffects(root3, finishedWork), commitReconciliationEffects(finishedWork);
      }
    }
    function commitReconciliationEffects(finishedWork) {
      var flags = finishedWork.flags;
      if (flags & 2) {
        try {
          for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
            if (isHostParent(parentFiber)) {
              hostParentFiber = parentFiber;
              break;
            }
            parentFiber = parentFiber.return;
          }
          if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
          switch (hostParentFiber.tag) {
            case 27:
              var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before, parent);
              break;
            case 5:
              var parent$141 = hostParentFiber.stateNode;
              hostParentFiber.flags & 32 && (setTextContent(parent$141, ""), hostParentFiber.flags &= -33);
              var before$142 = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before$142, parent$141);
              break;
            case 3:
            case 4:
              var parent$143 = hostParentFiber.stateNode.containerInfo, before$144 = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(
                finishedWork,
                before$144,
                parent$143
              );
              break;
            default:
              throw Error(formatProdErrorMessage(161));
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        finishedWork.flags &= -3;
      }
      flags & 4096 && (finishedWork.flags &= -4097);
    }
    function recursivelyResetForms(parentFiber) {
      if (parentFiber.subtreeFlags & 1024)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var fiber = parentFiber;
          recursivelyResetForms(fiber);
          5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
          parentFiber = parentFiber.sibling;
        }
    }
    function recursivelyTraverseLayoutEffects(root3, parentFiber) {
      if (parentFiber.subtreeFlags & 8772)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitLayoutEffectOnFiber(root3, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
    }
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedWork = parentFiber;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 1:
            safelyDetachRef(finishedWork, finishedWork.return);
            var instance = finishedWork.stateNode;
            "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
              finishedWork,
              finishedWork.return,
              instance
            );
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 27:
            releaseSingletonInstance(finishedWork.stateNode);
          case 26:
          case 5:
            safelyDetachRef(finishedWork, finishedWork.return);
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 30:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          default:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            commitHookEffectListMount(4, finishedWork);
            break;
          case 1:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            current = finishedWork;
            finishedRoot = current.stateNode;
            if ("function" === typeof finishedRoot.componentDidMount)
              try {
                finishedRoot.componentDidMount();
              } catch (error) {
                captureCommitPhaseError(current, current.return, error);
              }
            current = finishedWork;
            finishedRoot = current.updateQueue;
            if (null !== finishedRoot) {
              var instance = current.stateNode;
              try {
                var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                if (null !== hiddenCallbacks)
                  for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                    callCallback(hiddenCallbacks[finishedRoot], instance);
              } catch (error) {
                captureCommitPhaseError(current, current.return, error);
              }
            }
            includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 27:
            commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            break;
          case 31:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 30:
            break;
          default:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function commitOffscreenPassiveMountEffects(current, finishedWork) {
      var previousCache = null;
      null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
      current = null;
      null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
      current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
    }
    function commitCachePassiveMountEffect(current, finishedWork) {
      current = null;
      null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
      finishedWork = finishedWork.memoizedState.cache;
      finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
    }
    function recursivelyTraversePassiveMountEffects(root3, parentFiber, committedLanes, committedTransitions) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveMountOnFiber(
            root3,
            parentFiber,
            committedLanes,
            committedTransitions
          ), parentFiber = parentFiber.sibling;
    }
    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && commitHookEffectListMount(9, finishedWork);
          break;
        case 1:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 3:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
          break;
        case 12:
          if (flags & 2048) {
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            finishedRoot = finishedWork.stateNode;
            try {
              var _finishedWork$memoize2 = finishedWork.memoizedProps, id2 = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
              "function" === typeof onPostCommit && onPostCommit(
                id2,
                null === finishedWork.alternate ? "mount" : "update",
                finishedRoot.passiveEffectDuration,
                -0
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
          break;
        case 31:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 13:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 23:
          break;
        case 22:
          _finishedWork$memoize2 = finishedWork.stateNode;
          id2 = finishedWork.alternate;
          null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            0 !== (finishedWork.subtreeFlags & 10256) || false
          ));
          flags & 2048 && commitOffscreenPassiveMountEffects(id2, finishedWork);
          break;
        case 24:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
      }
    }
    function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || false);
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
            commitHookEffectListMount(8, finishedWork);
            break;
          case 23:
            break;
          case 22:
            var instance = finishedWork.stateNode;
            null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ) : recursivelyTraverseAtomicPassiveEffects(
              finishedRoot,
              finishedWork
            ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ));
            includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
            break;
          case 24:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 22:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
              flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
              flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
    }
    var suspenseyCommitFlag = 8192;
    function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
      if (parentFiber.subtreeFlags & suspenseyCommitFlag)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          accumulateSuspenseyCommitOnFiber(
            parentFiber,
            committedLanes,
            suspendedState
          ), parentFiber = parentFiber.sibling;
    }
    function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
      switch (fiber.tag) {
        case 26:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
          fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
            suspendedState,
            currentHoistableRoot,
            fiber.memoizedState,
            fiber.memoizedProps
          );
          break;
        case 5:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
          break;
        case 3:
        case 4:
          var previousHoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
          currentHoistableRoot = previousHoistableRoot;
          break;
        case 22:
          null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          ), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          ));
          break;
        default:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
      }
    }
    function detachAlternateSiblings(parentFiber) {
      var previousFiber = parentFiber.alternate;
      if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
        previousFiber.child = null;
        do
          previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
        while (null !== parentFiber);
      }
    }
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i2 = 0; i2 < deletions.length; i2++) {
            var childToDelete = deletions[i2];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
          break;
        case 3:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        case 12:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        case 22:
          var instance = finishedWork.stateNode;
          null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        default:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
      }
    }
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i2 = 0; i2 < deletions.length; i2++) {
            var childToDelete = deletions[i2];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        deletions = parentFiber;
        switch (deletions.tag) {
          case 0:
          case 11:
          case 15:
            commitHookEffectListUnmount(8, deletions, deletions.return);
            recursivelyTraverseDisconnectPassiveEffects(deletions);
            break;
          case 22:
            i2 = deletions.stateNode;
            i2._visibility & 2 && (i2._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
            break;
          default:
            recursivelyTraverseDisconnectPassiveEffects(deletions);
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
      for (; null !== nextEffect; ) {
        var fiber = nextEffect;
        switch (fiber.tag) {
          case 0:
          case 11:
          case 15:
            commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
            break;
          case 23:
          case 22:
            if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
              var cache2 = fiber.memoizedState.cachePool.pool;
              null != cache2 && cache2.refCount++;
            }
            break;
          case 24:
            releaseCache(fiber.memoizedState.cache);
        }
        cache2 = fiber.child;
        if (null !== cache2) cache2.return = fiber, nextEffect = cache2;
        else
          a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
            cache2 = nextEffect;
            var sibling = cache2.sibling, returnFiber = cache2.return;
            detachFiberAfterEffects(cache2);
            if (cache2 === fiber) {
              nextEffect = null;
              break a;
            }
            if (null !== sibling) {
              sibling.return = returnFiber;
              nextEffect = sibling;
              break a;
            }
            nextEffect = returnFiber;
          }
      }
    }
    var DefaultAsyncDispatcher = {
      getCacheForType: function(resourceType) {
        var cache2 = readContext(CacheContext), cacheForType = cache2.data.get(resourceType);
        void 0 === cacheForType && (cacheForType = resourceType(), cache2.data.set(resourceType, cacheForType));
        return cacheForType;
      },
      cacheSignal: function() {
        return readContext(CacheContext).controller.signal;
      }
    }, PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
    function requestUpdateLane() {
      return 0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes : null !== ReactSharedInternals.T ? requestTransitionLane() : resolveUpdatePriority();
    }
    function requestDeferredLane() {
      if (0 === workInProgressDeferredLane)
        if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
          var lane = nextTransitionDeferredLane;
          nextTransitionDeferredLane <<= 1;
          0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
          workInProgressDeferredLane = lane;
        } else workInProgressDeferredLane = 536870912;
      lane = suspenseHandlerStackCursor.current;
      null !== lane && (lane.flags |= 32);
      return workInProgressDeferredLane;
    }
    function scheduleUpdateOnFiber(root3, fiber, lane) {
      if (root3 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root3.cancelPendingCommit)
        prepareFreshStack(root3, 0), markRootSuspended(
          root3,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      markRootUpdated$1(root3, lane);
      if (0 === (executionContext & 2) || root3 !== workInProgressRoot)
        root3 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
          root3,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        )), ensureRootIsScheduled(root3);
    }
    function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
      if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
      var shouldTimeSlice = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
      do {
        if (0 === exitStatus) {
          workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
          break;
        } else {
          forceSync = root$jscomp$0.current.alternate;
          if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
            exitStatus = renderRootSync(root$jscomp$0, lanes, false);
            renderWasConcurrent = false;
            continue;
          }
          if (2 === exitStatus) {
            renderWasConcurrent = lanes;
            if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
              var JSCompiler_inline_result = 0;
            else
              JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
            if (0 !== JSCompiler_inline_result) {
              lanes = JSCompiler_inline_result;
              a: {
                var root3 = root$jscomp$0;
                exitStatus = workInProgressRootConcurrentErrors;
                var wasRootDehydrated = root3.current.memoizedState.isDehydrated;
                wasRootDehydrated && (prepareFreshStack(root3, JSCompiler_inline_result).flags |= 256);
                JSCompiler_inline_result = renderRootSync(
                  root3,
                  JSCompiler_inline_result,
                  false
                );
                if (2 !== JSCompiler_inline_result) {
                  if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                    root3.errorRecoveryDisabledLanes |= renderWasConcurrent;
                    workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                    exitStatus = 4;
                    break a;
                  }
                  renderWasConcurrent = workInProgressRootRecoverableErrors;
                  workInProgressRootRecoverableErrors = exitStatus;
                  null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                    workInProgressRootRecoverableErrors,
                    renderWasConcurrent
                  ));
                }
                exitStatus = JSCompiler_inline_result;
              }
              renderWasConcurrent = false;
              if (2 !== exitStatus) continue;
            }
          }
          if (1 === exitStatus) {
            prepareFreshStack(root$jscomp$0, 0);
            markRootSuspended(root$jscomp$0, lanes, 0, true);
            break;
          }
          a: {
            shouldTimeSlice = root$jscomp$0;
            renderWasConcurrent = exitStatus;
            switch (renderWasConcurrent) {
              case 0:
              case 1:
                throw Error(formatProdErrorMessage(345));
              case 4:
                if ((lanes & 4194048) !== lanes) break;
              case 6:
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                break a;
              case 2:
                workInProgressRootRecoverableErrors = null;
                break;
              case 3:
              case 5:
                break;
              default:
                throw Error(formatProdErrorMessage(329));
            }
            if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now2(), 10 < exitStatus)) {
              markRootSuspended(
                shouldTimeSlice,
                lanes,
                workInProgressDeferredLane,
                !workInProgressRootDidSkipSuspendedSiblings
              );
              if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
              pendingEffectsLanes = lanes;
              shouldTimeSlice.timeoutHandle = scheduleTimeout(
                commitRootWhenReady.bind(
                  null,
                  shouldTimeSlice,
                  forceSync,
                  workInProgressRootRecoverableErrors,
                  workInProgressTransitions,
                  workInProgressRootDidIncludeRecursiveRenderUpdate,
                  lanes,
                  workInProgressDeferredLane,
                  workInProgressRootInterleavedUpdatedLanes,
                  workInProgressSuspendedRetryLanes,
                  workInProgressRootDidSkipSuspendedSiblings,
                  renderWasConcurrent,
                  "Throttled",
                  -0,
                  0
                ),
                exitStatus
              );
              break a;
            }
            commitRootWhenReady(
              shouldTimeSlice,
              forceSync,
              workInProgressRootRecoverableErrors,
              workInProgressTransitions,
              workInProgressRootDidIncludeRecursiveRenderUpdate,
              lanes,
              workInProgressDeferredLane,
              workInProgressRootInterleavedUpdatedLanes,
              workInProgressSuspendedRetryLanes,
              workInProgressRootDidSkipSuspendedSiblings,
              renderWasConcurrent,
              null,
              -0,
              0
            );
          }
        }
        break;
      } while (1);
      ensureRootIsScheduled(root$jscomp$0);
    }
    function commitRootWhenReady(root3, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
      root3.timeoutHandle = -1;
      suspendedCommitReason = finishedWork.subtreeFlags;
      if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
        suspendedCommitReason = {
          stylesheets: null,
          count: 0,
          imgCount: 0,
          imgBytes: 0,
          suspenseyImages: [],
          waitingForImages: true,
          waitingForViewTransition: false,
          unsuspend: noop$12
        };
        accumulateSuspenseyCommitOnFiber(
          finishedWork,
          lanes,
          suspendedCommitReason
        );
        var timeoutOffset = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now2() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now2() : 0;
        timeoutOffset = waitForCommitToBeReady(
          suspendedCommitReason,
          timeoutOffset
        );
        if (null !== timeoutOffset) {
          pendingEffectsLanes = lanes;
          root3.cancelPendingCommit = timeoutOffset(
            commitRoot.bind(
              null,
              root3,
              finishedWork,
              lanes,
              recoverableErrors,
              transitions,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes,
              exitStatus,
              suspendedCommitReason,
              null,
              completedRenderStartTime,
              completedRenderEndTime
            )
          );
          markRootSuspended(root3, lanes, spawnedLane, !didSkipSuspendedSiblings);
          return;
        }
      }
      commitRoot(
        root3,
        finishedWork,
        lanes,
        recoverableErrors,
        transitions,
        didIncludeRenderPhaseUpdate,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes
      );
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (var node2 = finishedWork; ; ) {
        var tag = node2.tag;
        if ((0 === tag || 11 === tag || 15 === tag) && node2.flags & 16384 && (tag = node2.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
          for (var i2 = 0; i2 < tag.length; i2++) {
            var check = tag[i2], getSnapshot = check.getSnapshot;
            check = check.value;
            try {
              if (!objectIs2(getSnapshot(), check)) return false;
            } catch (error) {
              return false;
            }
          }
        tag = node2.child;
        if (node2.subtreeFlags & 16384 && null !== tag)
          tag.return = node2, node2 = tag;
        else {
          if (node2 === finishedWork) break;
          for (; null === node2.sibling; ) {
            if (null === node2.return || node2.return === finishedWork) return true;
            node2 = node2.return;
          }
          node2.sibling.return = node2.return;
          node2 = node2.sibling;
        }
      }
      return true;
    }
    function markRootSuspended(root3, suspendedLanes, spawnedLane, didAttemptEntireTree) {
      suspendedLanes &= ~workInProgressRootPingedLanes;
      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
      root3.suspendedLanes |= suspendedLanes;
      root3.pingedLanes &= ~suspendedLanes;
      didAttemptEntireTree && (root3.warmLanes |= suspendedLanes);
      didAttemptEntireTree = root3.expirationTimes;
      for (var lanes = suspendedLanes; 0 < lanes; ) {
        var index$6 = 31 - clz32(lanes), lane = 1 << index$6;
        didAttemptEntireTree[index$6] = -1;
        lanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, suspendedLanes);
    }
    function flushSyncWork$1() {
      return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0), false) : true;
    }
    function resetWorkInProgressStack() {
      if (null !== workInProgress) {
        if (0 === workInProgressSuspendedReason)
          var interruptedWork = workInProgress.return;
        else
          interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
        for (; null !== interruptedWork; )
          unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
        workInProgress = null;
      }
    }
    function prepareFreshStack(root3, lanes) {
      var timeoutHandle = root3.timeoutHandle;
      -1 !== timeoutHandle && (root3.timeoutHandle = -1, cancelTimeout(timeoutHandle));
      timeoutHandle = root3.cancelPendingCommit;
      null !== timeoutHandle && (root3.cancelPendingCommit = null, timeoutHandle());
      pendingEffectsLanes = 0;
      resetWorkInProgressStack();
      workInProgressRoot = root3;
      workInProgress = timeoutHandle = createWorkInProgress(root3.current, null);
      workInProgressRootRenderLanes = lanes;
      workInProgressSuspendedReason = 0;
      workInProgressThrownValue = null;
      workInProgressRootDidSkipSuspendedSiblings = false;
      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root3, lanes);
      workInProgressRootDidAttachPingListener = false;
      workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
      workInProgressRootDidIncludeRecursiveRenderUpdate = false;
      0 !== (lanes & 8) && (lanes |= lanes & 32);
      var allEntangledLanes = root3.entangledLanes;
      if (0 !== allEntangledLanes)
        for (root3 = root3.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
          var index$4 = 31 - clz32(allEntangledLanes), lane = 1 << index$4;
          lanes |= root3[index$4];
          allEntangledLanes &= ~lane;
        }
      entangledRenderLanes = lanes;
      finishQueueingConcurrentUpdates();
      return timeoutHandle;
    }
    function handleThrow(root3, thrownValue) {
      currentlyRenderingFiber = null;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
      workInProgressThrownValue = thrownValue;
      null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
        root3,
        createCapturedValueAtFiber(thrownValue, root3.current)
      ));
    }
    function shouldRemainOnPreviousScreen() {
      var handler = suspenseHandlerStackCursor.current;
      return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
    }
    function pushDispatcher() {
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
    }
    function pushAsyncDispatcher() {
      var prevAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      return prevAsyncDispatcher;
    }
    function renderDidSuspendDelayIfPossible() {
      workInProgressRootExitStatus = 4;
      workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
      0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
        workInProgressRoot,
        workInProgressRootRenderLanes,
        workInProgressDeferredLane,
        false
      );
    }
    function renderRootSync(root3, lanes, shouldYieldForPrerendering) {
      var prevExecutionContext = executionContext;
      executionContext |= 2;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes)
        workInProgressTransitions = null, prepareFreshStack(root3, lanes);
      lanes = false;
      var exitStatus = workInProgressRootExitStatus;
      a: do
        try {
          if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
            var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
            switch (workInProgressSuspendedReason) {
              case 8:
                resetWorkInProgressStack();
                exitStatus = 6;
                break a;
              case 3:
              case 2:
              case 9:
              case 6:
                null === suspenseHandlerStackCursor.current && (lanes = true);
                var reason = workInProgressSuspendedReason;
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
                if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                  exitStatus = 0;
                  break a;
                }
                break;
              default:
                reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
            }
          }
          workLoopSync();
          exitStatus = workInProgressRootExitStatus;
          break;
        } catch (thrownValue$165) {
          handleThrow(root3, thrownValue$165);
        }
      while (1);
      lanes && root3.shellSuspendCounter++;
      lastContextDependency = currentlyRenderingFiber$1 = null;
      executionContext = prevExecutionContext;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
      return exitStatus;
    }
    function workLoopSync() {
      for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root3, lanes) {
      var prevExecutionContext = executionContext;
      executionContext |= 2;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now2() + 500, prepareFreshStack(root3, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
        root3,
        lanes
      );
      a: do
        try {
          if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
            lanes = workInProgress;
            var thrownValue = workInProgressThrownValue;
            b: switch (workInProgressSuspendedReason) {
              case 1:
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root3, lanes, thrownValue, 1);
                break;
              case 2:
              case 9:
                if (isThenableResolved(thrownValue)) {
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  replaySuspendedUnitOfWork(lanes);
                  break;
                }
                lanes = function() {
                  2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root3 || (workInProgressSuspendedReason = 7);
                  ensureRootIsScheduled(root3);
                };
                thrownValue.then(lanes, lanes);
                break a;
              case 3:
                workInProgressSuspendedReason = 7;
                break a;
              case 4:
                workInProgressSuspendedReason = 5;
                break a;
              case 7:
                isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root3, lanes, thrownValue, 7));
                break;
              case 5:
                var resource = null;
                switch (workInProgress.tag) {
                  case 26:
                    resource = workInProgress.memoizedState;
                  case 5:
                  case 27:
                    var hostFiber = workInProgress;
                    if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                      workInProgressSuspendedReason = 0;
                      workInProgressThrownValue = null;
                      var sibling = hostFiber.sibling;
                      if (null !== sibling) workInProgress = sibling;
                      else {
                        var returnFiber = hostFiber.return;
                        null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                      }
                      break b;
                    }
                }
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root3, lanes, thrownValue, 5);
                break;
              case 6:
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root3, lanes, thrownValue, 6);
                break;
              case 8:
                resetWorkInProgressStack();
                workInProgressRootExitStatus = 6;
                break a;
              default:
                throw Error(formatProdErrorMessage(462));
            }
          }
          workLoopConcurrentByScheduler();
          break;
        } catch (thrownValue$167) {
          handleThrow(root3, thrownValue$167);
        }
      while (1);
      lastContextDependency = currentlyRenderingFiber$1 = null;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      executionContext = prevExecutionContext;
      if (null !== workInProgress) return 0;
      workInProgressRoot = null;
      workInProgressRootRenderLanes = 0;
      finishQueueingConcurrentUpdates();
      return workInProgressRootExitStatus;
    }
    function workLoopConcurrentByScheduler() {
      for (; null !== workInProgress && !shouldYield(); )
        performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
      var next2 = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next2 ? completeUnitOfWork(unitOfWork) : workInProgress = next2;
    }
    function replaySuspendedUnitOfWork(unitOfWork) {
      var next2 = unitOfWork;
      var current = next2.alternate;
      switch (next2.tag) {
        case 15:
        case 0:
          next2 = replayFunctionComponent(
            current,
            next2,
            next2.pendingProps,
            next2.type,
            void 0,
            workInProgressRootRenderLanes
          );
          break;
        case 11:
          next2 = replayFunctionComponent(
            current,
            next2,
            next2.pendingProps,
            next2.type.render,
            next2.ref,
            workInProgressRootRenderLanes
          );
          break;
        case 5:
          resetHooksOnUnwind(next2);
        default:
          unwindInterruptedWork(current, next2), next2 = workInProgress = resetWorkInProgress(next2, entangledRenderLanes), next2 = beginWork(current, next2, entangledRenderLanes);
      }
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next2 ? completeUnitOfWork(unitOfWork) : workInProgress = next2;
    }
    function throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, suspendedReason) {
      lastContextDependency = currentlyRenderingFiber$1 = null;
      resetHooksOnUnwind(unitOfWork);
      thenableState$1 = null;
      thenableIndexCounter$1 = 0;
      var returnFiber = unitOfWork.return;
      try {
        if (throwException(
          root3,
          returnFiber,
          unitOfWork,
          thrownValue,
          workInProgressRootRenderLanes
        )) {
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root3,
            createCapturedValueAtFiber(thrownValue, root3.current)
          );
          workInProgress = null;
          return;
        }
      } catch (error) {
        if (null !== returnFiber) throw workInProgress = returnFiber, error;
        workInProgressRootExitStatus = 1;
        logUncaughtError(
          root3,
          createCapturedValueAtFiber(thrownValue, root3.current)
        );
        workInProgress = null;
        return;
      }
      if (unitOfWork.flags & 32768) {
        if (isHydrating || 1 === suspendedReason) root3 = true;
        else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
          root3 = false;
        else if (workInProgressRootDidSkipSuspendedSiblings = root3 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
          suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
        unwindUnitOfWork(unitOfWork, root3);
      } else completeUnitOfWork(unitOfWork);
    }
    function completeUnitOfWork(unitOfWork) {
      var completedWork = unitOfWork;
      do {
        if (0 !== (completedWork.flags & 32768)) {
          unwindUnitOfWork(
            completedWork,
            workInProgressRootDidSkipSuspendedSiblings
          );
          return;
        }
        unitOfWork = completedWork.return;
        var next2 = completeWork(
          completedWork.alternate,
          completedWork,
          entangledRenderLanes
        );
        if (null !== next2) {
          workInProgress = next2;
          return;
        }
        completedWork = completedWork.sibling;
        if (null !== completedWork) {
          workInProgress = completedWork;
          return;
        }
        workInProgress = completedWork = unitOfWork;
      } while (null !== completedWork);
      0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
    }
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
      do {
        var next2 = unwindWork(unitOfWork.alternate, unitOfWork);
        if (null !== next2) {
          next2.flags &= 32767;
          workInProgress = next2;
          return;
        }
        next2 = unitOfWork.return;
        null !== next2 && (next2.flags |= 32768, next2.subtreeFlags = 0, next2.deletions = null);
        if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
          workInProgress = unitOfWork;
          return;
        }
        workInProgress = unitOfWork = next2;
      } while (null !== unitOfWork);
      workInProgressRootExitStatus = 6;
      workInProgress = null;
    }
    function commitRoot(root3, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
      root3.cancelPendingCommit = null;
      do
        flushPendingEffects();
      while (0 !== pendingEffectsStatus);
      if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
      if (null !== finishedWork) {
        if (finishedWork === root3.current) throw Error(formatProdErrorMessage(177));
        didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
        didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
        markRootFinished(
          root3,
          lanes,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
        root3 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
        pendingFinishedWork = finishedWork;
        pendingEffectsRoot = root3;
        pendingEffectsLanes = lanes;
        pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
        pendingPassiveTransitions = transitions;
        pendingRecoverableErrors = recoverableErrors;
        0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root3.callbackNode = null, root3.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
          flushPassiveEffects();
          return null;
        })) : (root3.callbackNode = null, root3.callbackPriority = 0);
        recoverableErrors = 0 !== (finishedWork.flags & 13878);
        if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
          recoverableErrors = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          transitions = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          spawnedLane = executionContext;
          executionContext |= 4;
          try {
            commitBeforeMutationEffects(root3, finishedWork, lanes);
          } finally {
            executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
          }
        }
        pendingEffectsStatus = 1;
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
      }
    }
    function flushMutationEffects() {
      if (1 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
        if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
          rootMutationHasEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          try {
            commitMutationEffectsOnFiber(finishedWork, root3);
            var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root3.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
              priorFocusedElem.ownerDocument.documentElement,
              priorFocusedElem
            )) {
              if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                var start = priorSelectionRange.start, end = priorSelectionRange.end;
                void 0 === end && (end = start);
                if ("selectionStart" in priorFocusedElem)
                  priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                    end,
                    priorFocusedElem.value.length
                  );
                else {
                  var doc = priorFocusedElem.ownerDocument || document, win2 = doc && doc.defaultView || window;
                  if (win2.getSelection) {
                    var selection = win2.getSelection(), length2 = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length2), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length2);
                    !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                    var startMarker = getNodeForCharacterOffset(
                      priorFocusedElem,
                      start$jscomp$0
                    ), endMarker = getNodeForCharacterOffset(
                      priorFocusedElem,
                      end$jscomp$0
                    );
                    if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                      var range3 = doc.createRange();
                      range3.setStart(startMarker.node, startMarker.offset);
                      selection.removeAllRanges();
                      start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range3), selection.extend(endMarker.node, endMarker.offset)) : (range3.setEnd(endMarker.node, endMarker.offset), selection.addRange(range3));
                    }
                  }
                }
              }
              doc = [];
              for (selection = priorFocusedElem; selection = selection.parentNode; )
                1 === selection.nodeType && doc.push({
                  element: selection,
                  left: selection.scrollLeft,
                  top: selection.scrollTop
                });
              "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
              for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                var info = doc[priorFocusedElem];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
            _enabled = !!eventsEnabled;
            selectionInformation = eventsEnabled = null;
          } finally {
            executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
          }
        }
        root3.current = finishedWork;
        pendingEffectsStatus = 2;
      }
    }
    function flushLayoutEffects() {
      if (2 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
        if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
          rootHasLayoutEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          try {
            commitLayoutEffectOnFiber(root3, finishedWork.alternate, finishedWork);
          } finally {
            executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
          }
        }
        pendingEffectsStatus = 3;
      }
    }
    function flushSpawnedWork() {
      if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        requestPaint();
        var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
        0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root3, root3.pendingLanes));
        var remainingLanes = root3.pendingLanes;
        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
        lanesToEventPriority(lanes);
        finishedWork = finishedWork.stateNode;
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
          try {
            injectedHook.onCommitFiberRoot(
              rendererID,
              finishedWork,
              void 0,
              128 === (finishedWork.current.flags & 128)
            );
          } catch (err) {
          }
        if (null !== recoverableErrors) {
          finishedWork = ReactSharedInternals.T;
          remainingLanes = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          ReactSharedInternals.T = null;
          try {
            for (var onRecoverableError = root3.onRecoverableError, i2 = 0; i2 < recoverableErrors.length; i2++) {
              var recoverableError = recoverableErrors[i2];
              onRecoverableError(recoverableError.value, {
                componentStack: recoverableError.stack
              });
            }
          } finally {
            ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
          }
        }
        0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
        ensureRootIsScheduled(root3);
        remainingLanes = root3.pendingLanes;
        0 !== (lanes & 261930) && 0 !== (remainingLanes & 42) ? root3 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root3) : nestedUpdateCount = 0;
        flushSyncWorkAcrossRoots_impl(0);
      }
    }
    function releaseRootPooledCache(root3, remainingLanes) {
      0 === (root3.pooledCacheLanes &= remainingLanes) && (remainingLanes = root3.pooledCache, null != remainingLanes && (root3.pooledCache = null, releaseCache(remainingLanes)));
    }
    function flushPendingEffects() {
      flushMutationEffects();
      flushLayoutEffects();
      flushSpawnedWork();
      return flushPassiveEffects();
    }
    function flushPassiveEffects() {
      if (5 !== pendingEffectsStatus) return false;
      var root3 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
      pendingEffectsRemainingLanes = 0;
      var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
        ReactSharedInternals.T = null;
        renderPriority = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
        pendingEffectsStatus = 0;
        pendingFinishedWork = pendingEffectsRoot = null;
        pendingEffectsLanes = 0;
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
        var prevExecutionContext = executionContext;
        executionContext |= 4;
        commitPassiveUnmountOnFiber(root$jscomp$0.current);
        commitPassiveMountOnFiber(
          root$jscomp$0,
          root$jscomp$0.current,
          lanes,
          renderPriority
        );
        executionContext = prevExecutionContext;
        flushSyncWorkAcrossRoots_impl(0, false);
        if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
          } catch (err) {
          }
        return true;
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root3, remainingLanes);
      }
    }
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
      null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
    }
    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
      if (3 === sourceFiber.tag)
        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
      else
        for (; null !== nearestMountedAncestor; ) {
          if (3 === nearestMountedAncestor.tag) {
            captureCommitPhaseErrorOnRoot(
              nearestMountedAncestor,
              sourceFiber,
              error
            );
            break;
          } else if (1 === nearestMountedAncestor.tag) {
            var instance = nearestMountedAncestor.stateNode;
            if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
              error = createClassErrorUpdate(2);
              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
              null !== instance && (initializeClassErrorUpdate(
                error,
                instance,
                nearestMountedAncestor,
                sourceFiber
              ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
              break;
            }
          }
          nearestMountedAncestor = nearestMountedAncestor.return;
        }
    }
    function attachPingListener(root3, wakeable, lanes) {
      var pingCache = root3.pingCache;
      if (null === pingCache) {
        pingCache = root3.pingCache = new PossiblyWeakMap();
        var threadIDs = new Set();
        pingCache.set(wakeable, threadIDs);
      } else
        threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = new Set(), pingCache.set(wakeable, threadIDs));
      threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root3 = pingSuspendedRoot.bind(null, root3, wakeable, lanes), wakeable.then(root3, root3));
    }
    function pingSuspendedRoot(root3, wakeable, pingedLanes) {
      var pingCache = root3.pingCache;
      null !== pingCache && pingCache.delete(wakeable);
      root3.pingedLanes |= root3.suspendedLanes & pingedLanes;
      root3.warmLanes &= ~pingedLanes;
      workInProgressRoot === root3 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now2() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root3, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
      ensureRootIsScheduled(root3);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      0 === retryLane && (retryLane = claimNextRetryLane());
      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
      null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      var retryLane = 0;
      switch (boundaryFiber.tag) {
        case 31:
        case 13:
          var retryCache = boundaryFiber.stateNode;
          var suspenseState = boundaryFiber.memoizedState;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          break;
        case 19:
          retryCache = boundaryFiber.stateNode;
          break;
        case 22:
          retryCache = boundaryFiber.stateNode._retryCache;
          break;
        default:
          throw Error(formatProdErrorMessage(314));
      }
      null !== retryCache && retryCache.delete(wakeable);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function scheduleCallback$1(priorityLevel, callback) {
      return scheduleCallback$3(priorityLevel, callback);
    }
    var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0;
    function ensureRootIsScheduled(root3) {
      root3 !== lastScheduledRoot && null === root3.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root3 : lastScheduledRoot = lastScheduledRoot.next = root3);
      mightHavePendingSyncWork = true;
      didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
    }
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
      if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = true;
        do {
          var didPerformSomeWork = false;
          for (var root$170 = firstScheduledRoot; null !== root$170; ) {
            if (0 !== syncTransitionLanes) {
              var pendingLanes = root$170.pendingLanes;
              if (0 === pendingLanes) var JSCompiler_inline_result = 0;
              else {
                var suspendedLanes = root$170.suspendedLanes, pingedLanes = root$170.pingedLanes;
                JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
              }
              0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
            } else
              JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                root$170,
                root$170 === workInProgressRoot ? JSCompiler_inline_result : 0,
                null !== root$170.cancelPendingCommit || -1 !== root$170.timeoutHandle
              ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$170, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
            root$170 = root$170.next;
          }
        } while (didPerformSomeWork);
        isFlushingWork = false;
      }
    }
    function processRootScheduleInImmediateTask() {
      processRootScheduleInMicrotask();
    }
    function processRootScheduleInMicrotask() {
      mightHavePendingSyncWork = didScheduleMicrotask = false;
      var syncTransitionLanes = 0;
      0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
      for (var currentTime = now2(), prev2 = null, root3 = firstScheduledRoot; null !== root3; ) {
        var next2 = root3.next, nextLanes = scheduleTaskForRootDuringMicrotask(root3, currentTime);
        if (0 === nextLanes)
          root3.next = null, null === prev2 ? firstScheduledRoot = next2 : prev2.next = next2, null === next2 && (lastScheduledRoot = prev2);
        else if (prev2 = root3, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
          mightHavePendingSyncWork = true;
        root3 = next2;
      }
      0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus || flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
      0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
    }
    function scheduleTaskForRootDuringMicrotask(root3, currentTime) {
      for (var suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes, expirationTimes = root3.expirationTimes, lanes = root3.pendingLanes & -62914561; 0 < lanes; ) {
        var index$5 = 31 - clz32(lanes), lane = 1 << index$5, expirationTime = expirationTimes[index$5];
        if (-1 === expirationTime) {
          if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
            expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
        } else expirationTime <= currentTime && (root3.expiredLanes |= lane);
        lanes &= ~lane;
      }
      currentTime = workInProgressRoot;
      suspendedLanes = workInProgressRootRenderLanes;
      suspendedLanes = getNextLanes(
        root3,
        root3 === currentTime ? suspendedLanes : 0,
        null !== root3.cancelPendingCommit || -1 !== root3.timeoutHandle
      );
      pingedLanes = root3.callbackNode;
      if (0 === suspendedLanes || root3 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root3.cancelPendingCommit)
        return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root3.callbackNode = null, root3.callbackPriority = 0;
      if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root3, suspendedLanes)) {
        currentTime = suspendedLanes & -suspendedLanes;
        if (currentTime === root3.callbackPriority) return currentTime;
        null !== pingedLanes && cancelCallback$1(pingedLanes);
        switch (lanesToEventPriority(suspendedLanes)) {
          case 2:
          case 8:
            suspendedLanes = UserBlockingPriority;
            break;
          case 32:
            suspendedLanes = NormalPriority$1;
            break;
          case 268435456:
            suspendedLanes = IdlePriority;
            break;
          default:
            suspendedLanes = NormalPriority$1;
        }
        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root3);
        suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
        root3.callbackPriority = currentTime;
        root3.callbackNode = suspendedLanes;
        return currentTime;
      }
      null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
      root3.callbackPriority = 2;
      root3.callbackNode = null;
      return 2;
    }
    function performWorkOnRootViaSchedulerTask(root3, didTimeout) {
      if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
        return root3.callbackNode = null, root3.callbackPriority = 0, null;
      var originalCallbackNode = root3.callbackNode;
      if (flushPendingEffects() && root3.callbackNode !== originalCallbackNode)
        return null;
      var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
        root3,
        root3 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
        null !== root3.cancelPendingCommit || -1 !== root3.timeoutHandle
      );
      if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
      performWorkOnRoot(root3, workInProgressRootRenderLanes$jscomp$0, didTimeout);
      scheduleTaskForRootDuringMicrotask(root3, now2());
      return null != root3.callbackNode && root3.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root3) : null;
    }
    function performSyncWorkOnRoot(root3, lanes) {
      if (flushPendingEffects()) return null;
      performWorkOnRoot(root3, lanes, true);
    }
    function scheduleImmediateRootScheduleTask() {
      scheduleMicrotask(function() {
        0 !== (executionContext & 6) ? scheduleCallback$3(
          ImmediatePriority,
          processRootScheduleInImmediateTask
        ) : processRootScheduleInMicrotask();
      });
    }
    function requestTransitionLane() {
      if (0 === currentEventTransitionLane) {
        var actionScopeLane = currentEntangledLane;
        0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
        currentEventTransitionLane = actionScopeLane;
      }
      return currentEventTransitionLane;
    }
    function coerceFormActionProp(actionProp) {
      return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
    }
    function createFormDataWithSubmitter(form, submitter) {
      var temp = submitter.ownerDocument.createElement("input");
      temp.name = submitter.name;
      temp.value = submitter.value;
      form.id && temp.setAttribute("form", form.id);
      submitter.parentNode.insertBefore(temp, submitter);
      form = new FormData(form);
      temp.parentNode.removeChild(temp);
      return form;
    }
    function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
      if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
        var action2 = coerceFormActionProp(
          (nativeEventTarget[internalPropsKey] || null).action
        ), submitter = nativeEvent.submitter;
        submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action2 = domEventName, submitter = null));
        var event = new SyntheticEvent(
          "action",
          "action",
          null,
          nativeEvent,
          nativeEventTarget
        );
        dispatchQueue.push({
          event,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (nativeEvent.defaultPrevented) {
                  if (0 !== currentEventTransitionLane) {
                    var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                    startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action: action2
                      },
                      null,
                      formData
                    );
                  }
                } else
                  "function" === typeof action2 && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                    maybeTargetInst,
                    {
                      pending: true,
                      data: formData,
                      method: nativeEventTarget.method,
                      action: action2
                    },
                    action2,
                    formData
                  ));
              },
              currentTarget: nativeEventTarget
            }
          ]
        });
      }
    }
    for (var i$jscomp$inline_1577 = 0; i$jscomp$inline_1577 < simpleEventPluginEvents.length; i$jscomp$inline_1577++) {
      var eventName$jscomp$inline_1578 = simpleEventPluginEvents[i$jscomp$inline_1577], domEventName$jscomp$inline_1579 = eventName$jscomp$inline_1578.toLowerCase(), capitalizedEvent$jscomp$inline_1580 = eventName$jscomp$inline_1578[0].toUpperCase() + eventName$jscomp$inline_1578.slice(1);
      registerSimpleEvent(
        domEventName$jscomp$inline_1579,
        "on" + capitalizedEvent$jscomp$inline_1580
      );
    }
    registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
    registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
    registerSimpleEvent(ANIMATION_START, "onAnimationStart");
    registerSimpleEvent("dblclick", "onDoubleClick");
    registerSimpleEvent("focusin", "onFocus");
    registerSimpleEvent("focusout", "onBlur");
    registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
    registerSimpleEvent(TRANSITION_START, "onTransitionStart");
    registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
    registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
    registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
    registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
    registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
    registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
    registerTwoPhaseEvent(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(" ")
    );
    registerTwoPhaseEvent(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    );
    registerTwoPhaseEvent("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]);
    registerTwoPhaseEvent(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ), nonDelegatedEvents = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
    );
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
      eventSystemFlags = 0 !== (eventSystemFlags & 4);
      for (var i2 = 0; i2 < dispatchQueue.length; i2++) {
        var _dispatchQueue$i = dispatchQueue[i2], event = _dispatchQueue$i.event;
        _dispatchQueue$i = _dispatchQueue$i.listeners;
        a: {
          var previousInstance = void 0;
          if (eventSystemFlags)
            for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
              var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              previousInstance = _dispatchListeners$i;
              event.currentTarget = currentTarget;
              try {
                previousInstance(event);
              } catch (error) {
                reportGlobalError(error);
              }
              event.currentTarget = null;
              previousInstance = instance;
            }
          else
            for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
              _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
              instance = _dispatchListeners$i.instance;
              currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              previousInstance = _dispatchListeners$i;
              event.currentTarget = currentTarget;
              try {
                previousInstance(event);
              } catch (error) {
                reportGlobalError(error);
              }
              event.currentTarget = null;
              previousInstance = instance;
            }
        }
      }
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
      var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
      void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = new Set());
      var listenerSetKey = domEventName + "__bubble";
      JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
      var eventSystemFlags = 0;
      isCapturePhaseListener && (eventSystemFlags |= 4);
      addTrappedEventListener(
        target,
        domEventName,
        eventSystemFlags,
        isCapturePhaseListener
      );
    }
    var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
    function listenToAllSupportedEvents(rootContainerElement) {
      if (!rootContainerElement[listeningMarker]) {
        rootContainerElement[listeningMarker] = true;
        allNativeEvents.forEach(function(domEventName) {
          "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
        });
        var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
      }
    }
    function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
      switch (getEventPriority(domEventName)) {
        case 2:
          var listenerWrapper = dispatchDiscreteEvent;
          break;
        case 8:
          listenerWrapper = dispatchContinuousEvent;
          break;
        default:
          listenerWrapper = dispatchEvent;
      }
      eventSystemFlags = listenerWrapper.bind(
        null,
        domEventName,
        eventSystemFlags,
        targetContainer
      );
      listenerWrapper = void 0;
      !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
      isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        capture: true,
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
    }
    function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
      var ancestorInst = targetInst$jscomp$0;
      if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
        a: for (; ; ) {
          if (null === targetInst$jscomp$0) return;
          var nodeTag = targetInst$jscomp$0.tag;
          if (3 === nodeTag || 4 === nodeTag) {
            var container = targetInst$jscomp$0.stateNode.containerInfo;
            if (container === targetContainer) break;
            if (4 === nodeTag)
              for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                var grandTag = nodeTag.tag;
                if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                  return;
                nodeTag = nodeTag.return;
              }
            for (; null !== container; ) {
              nodeTag = getClosestInstanceFromNode(container);
              if (null === nodeTag) return;
              grandTag = nodeTag.tag;
              if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                targetInst$jscomp$0 = ancestorInst = nodeTag;
                continue a;
              }
              container = container.parentNode;
            }
          }
          targetInst$jscomp$0 = targetInst$jscomp$0.return;
        }
      batchedUpdates$1(function() {
        var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
        a: {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (void 0 !== reactName) {
            var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (0 === getEventCharCode(nativeEvent)) break a;
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (2 === nativeEvent.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
              case "scrollend":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
              case "toggle":
              case "beforetoggle":
                SyntheticEventCtor = SyntheticToggleEvent;
            }
            var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
            inCapturePhase = [];
            for (var instance = targetInst, lastHostComponent; null !== instance; ) {
              var _instance = instance;
              lastHostComponent = _instance.stateNode;
              _instance = _instance.tag;
              5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
                createDispatchListener(instance, _instance, lastHostComponent)
              ));
              if (accumulateTargetOnly) break;
              instance = instance.return;
            }
            0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
              reactName,
              reactEventType,
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
          }
        }
        if (0 === (eventSystemFlags & 7)) {
          a: {
            reactName = "mouseover" === domEventName || "pointerover" === domEventName;
            SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
            if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
              break a;
            if (SyntheticEventCtor || reactName) {
              reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
              if (SyntheticEventCtor) {
                if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                  reactEventType = null;
              } else SyntheticEventCtor = null, reactEventType = targetInst;
              if (SyntheticEventCtor !== reactEventType) {
                inCapturePhase = SyntheticMouseEvent;
                _instance = "onMouseLeave";
                reactEventName = "onMouseEnter";
                instance = "mouse";
                if ("pointerout" === domEventName || "pointerover" === domEventName)
                  inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                reactName = new inCapturePhase(
                  _instance,
                  instance + "leave",
                  SyntheticEventCtor,
                  nativeEvent,
                  nativeEventTarget
                );
                reactName.target = accumulateTargetOnly;
                reactName.relatedTarget = lastHostComponent;
                _instance = null;
                getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                  reactEventName,
                  instance + "enter",
                  reactEventType,
                  nativeEvent,
                  nativeEventTarget
                ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
                accumulateTargetOnly = _instance;
                if (SyntheticEventCtor && reactEventType)
                  b: {
                    inCapturePhase = getParent;
                    reactEventName = SyntheticEventCtor;
                    instance = reactEventType;
                    lastHostComponent = 0;
                    for (_instance = reactEventName; _instance; _instance = inCapturePhase(_instance))
                      lastHostComponent++;
                    _instance = 0;
                    for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                      _instance++;
                    for (; 0 < lastHostComponent - _instance; )
                      reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                    for (; 0 < _instance - lastHostComponent; )
                      instance = inCapturePhase(instance), _instance--;
                    for (; lastHostComponent--; ) {
                      if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
                        inCapturePhase = reactEventName;
                        break b;
                      }
                      reactEventName = inCapturePhase(reactEventName);
                      instance = inCapturePhase(instance);
                    }
                    inCapturePhase = null;
                  }
                else inCapturePhase = null;
                null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                  dispatchQueue,
                  reactName,
                  SyntheticEventCtor,
                  inCapturePhase,
                  false
                );
                null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                  dispatchQueue,
                  accumulateTargetOnly,
                  reactEventType,
                  inCapturePhase,
                  true
                );
              }
            }
          }
          a: {
            reactName = targetInst ? getNodeFromInstance(targetInst) : window;
            SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
            if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
              var getTargetInstFunc = getTargetInstForChangeEvent;
            else if (isTextInputElement(reactName))
              if (isInputEventSupported)
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                var handleEventFunc = handleEventsForInputEventPolyfill;
              }
            else
              SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
            if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
              createAndAccumulateChangeEvent(
                dispatchQueue,
                getTargetInstFunc,
                nativeEvent,
                nativeEventTarget
              );
              break a;
            }
            handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
            "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
          }
          handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
          switch (domEventName) {
            case "focusin":
              if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
              break;
            case "focusout":
              lastSelection = activeElementInst = activeElement = null;
              break;
            case "mousedown":
              mouseDown = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = false;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) break;
            case "keydown":
            case "keyup":
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          }
          var fallbackData;
          if (canUseCompositionEvent)
            b: {
              switch (domEventName) {
                case "compositionstart":
                  var eventType = "onCompositionStart";
                  break b;
                case "compositionend":
                  eventType = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  eventType = "onCompositionUpdate";
                  break b;
              }
              eventType = void 0;
            }
          else
            isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
          eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root2 = nativeEventTarget, startText = "value" in root2 ? root2.value : root2.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
            eventType,
            domEventName,
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
          if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
            eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
              "onBeforeInput",
              "beforeinput",
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({
              event: handleEventFunc,
              listeners: eventType
            }), handleEventFunc.data = fallbackData);
          extractEvents$1(
            dispatchQueue,
            domEventName,
            targetInst,
            nativeEvent,
            nativeEventTarget
          );
        }
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      });
    }
    function createDispatchListener(instance, listener, currentTarget) {
      return {
        instance,
        listener,
        currentTarget
      };
    }
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
      for (var captureName = reactName + "Capture", listeners2 = []; null !== targetFiber; ) {
        var _instance2 = targetFiber, stateNode = _instance2.stateNode;
        _instance2 = _instance2.tag;
        5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners2.unshift(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners2.push(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ));
        if (3 === targetFiber.tag) return listeners2;
        targetFiber = targetFiber.return;
      }
      return [];
    }
    function getParent(inst) {
      if (null === inst) return null;
      do
        inst = inst.return;
      while (inst && 5 !== inst.tag && 27 !== inst.tag);
      return inst ? inst : null;
    }
    function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common2, inCapturePhase) {
      for (var registrationName = event._reactName, listeners2 = []; null !== target && target !== common2; ) {
        var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
        _instance3 = _instance3.tag;
        if (null !== alternate && alternate === common2) break;
        5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners2.unshift(
          createDispatchListener(target, stateNode, alternate)
        )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners2.push(
          createDispatchListener(target, stateNode, alternate)
        )));
        target = target.return;
      }
      0 !== listeners2.length && dispatchQueue.push({ event, listeners: listeners2 });
    }
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
    function normalizeMarkupForTextOrAttribute(markup) {
      return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
    }
    function checkForUnmatchedText(serverText, clientText) {
      clientText = normalizeMarkupForTextOrAttribute(clientText);
      return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
    }
    function setProp(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "children":
          "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
          break;
        case "className":
          setValueForKnownAttribute(domElement, "class", value);
          break;
        case "tabIndex":
          setValueForKnownAttribute(domElement, "tabindex", value);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          setValueForKnownAttribute(domElement, key, value);
          break;
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "data":
          if ("object" !== tag) {
            setValueForKnownAttribute(domElement, "data", value);
            break;
          }
        case "src":
        case "href":
          if ("" === value && ("a" !== tag || "href" !== key)) {
            domElement.removeAttribute(key);
            break;
          }
          if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
            domElement.removeAttribute(key);
            break;
          }
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "action":
        case "formAction":
          if ("function" === typeof value) {
            domElement.setAttribute(
              key,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
              domElement,
              tag,
              "formEncType",
              props.formEncType,
              props,
              null
            ), setProp(
              domElement,
              tag,
              "formMethod",
              props.formMethod,
              props,
              null
            ), setProp(
              domElement,
              tag,
              "formTarget",
              props.formTarget,
              props,
              null
            )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
          if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
            domElement.removeAttribute(key);
            break;
          }
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "onClick":
          null != value && (domElement.onclick = noop$12);
          break;
        case "onScroll":
          null != value && listenToNonDelegatedEvent("scroll", domElement);
          break;
        case "onScrollEnd":
          null != value && listenToNonDelegatedEvent("scrollend", domElement);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(formatProdErrorMessage(61));
            key = value.__html;
            if (null != key) {
              if (null != props.children) throw Error(formatProdErrorMessage(60));
              domElement.innerHTML = key;
            }
          }
          break;
        case "multiple":
          domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "muted":
          domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
            domElement.removeAttribute("xlink:href");
            break;
          }
          key = sanitizeURL("" + value);
          domElement.setAttributeNS(
            "http://www.w3.org/1999/xlink",
            "xlink:href",
            key
          );
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
          break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
          break;
        case "capture":
        case "download":
          true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
          break;
        case "rowSpan":
        case "start":
          null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
          break;
        case "popover":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          setValueForAttribute(domElement, "popover", value);
          break;
        case "xlinkActuate":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:actuate",
            value
          );
          break;
        case "xlinkArcrole":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:arcrole",
            value
          );
          break;
        case "xlinkRole":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:role",
            value
          );
          break;
        case "xlinkShow":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:show",
            value
          );
          break;
        case "xlinkTitle":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:title",
            value
          );
          break;
        case "xlinkType":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:type",
            value
          );
          break;
        case "xmlBase":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:base",
            value
          );
          break;
        case "xmlLang":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:lang",
            value
          );
          break;
        case "xmlSpace":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:space",
            value
          );
          break;
        case "is":
          setValueForAttribute(domElement, "is", value);
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
            key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
      }
    }
    function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(formatProdErrorMessage(61));
            key = value.__html;
            if (null != key) {
              if (null != props.children) throw Error(formatProdErrorMessage(60));
              domElement.innerHTML = key;
            }
          }
          break;
        case "children":
          "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
          break;
        case "onScroll":
          null != value && listenToNonDelegatedEvent("scroll", domElement);
          break;
        case "onScrollEnd":
          null != value && listenToNonDelegatedEvent("scrollend", domElement);
          break;
        case "onClick":
          null != value && (domElement.onclick = noop$12);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!registrationNameDependencies.hasOwnProperty(key))
            a: {
              if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                domElement.addEventListener(tag, value, props);
                break a;
              }
              key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
            }
      }
    }
    function setInitialProperties(domElement, tag, props) {
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          var hasSrc = false, hasSrcSet = false, propKey;
          for (propKey in props)
            if (props.hasOwnProperty(propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "src":
                    hasSrc = true;
                    break;
                  case "srcSet":
                    hasSrcSet = true;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, propKey, propValue, props, null);
                }
            }
          hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
          hasSrc && setProp(domElement, tag, "src", props.src, props, null);
          return;
        case "input":
          listenToNonDelegatedEvent("invalid", domElement);
          var defaultValue2 = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
          for (hasSrc in props)
            if (props.hasOwnProperty(hasSrc)) {
              var propValue$184 = props[hasSrc];
              if (null != propValue$184)
                switch (hasSrc) {
                  case "name":
                    hasSrcSet = propValue$184;
                    break;
                  case "type":
                    propValue = propValue$184;
                    break;
                  case "checked":
                    checked = propValue$184;
                    break;
                  case "defaultChecked":
                    defaultChecked = propValue$184;
                    break;
                  case "value":
                    propKey = propValue$184;
                    break;
                  case "defaultValue":
                    defaultValue2 = propValue$184;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propValue$184)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(domElement, tag, hasSrc, propValue$184, props, null);
                }
            }
          initInput(
            domElement,
            propKey,
            defaultValue2,
            checked,
            defaultChecked,
            propValue,
            hasSrcSet,
            false
          );
          return;
        case "select":
          listenToNonDelegatedEvent("invalid", domElement);
          hasSrc = propValue = propKey = null;
          for (hasSrcSet in props)
            if (props.hasOwnProperty(hasSrcSet) && (defaultValue2 = props[hasSrcSet], null != defaultValue2))
              switch (hasSrcSet) {
                case "value":
                  propKey = defaultValue2;
                  break;
                case "defaultValue":
                  propValue = defaultValue2;
                  break;
                case "multiple":
                  hasSrc = defaultValue2;
                default:
                  setProp(domElement, tag, hasSrcSet, defaultValue2, props, null);
              }
          tag = propKey;
          props = propValue;
          domElement.multiple = !!hasSrc;
          null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
          return;
        case "textarea":
          listenToNonDelegatedEvent("invalid", domElement);
          propKey = hasSrcSet = hasSrc = null;
          for (propValue in props)
            if (props.hasOwnProperty(propValue) && (defaultValue2 = props[propValue], null != defaultValue2))
              switch (propValue) {
                case "value":
                  hasSrc = defaultValue2;
                  break;
                case "defaultValue":
                  hasSrcSet = defaultValue2;
                  break;
                case "children":
                  propKey = defaultValue2;
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != defaultValue2) throw Error(formatProdErrorMessage(91));
                  break;
                default:
                  setProp(domElement, tag, propValue, defaultValue2, props, null);
              }
          initTextarea(domElement, hasSrc, hasSrcSet, propKey);
          return;
        case "option":
          for (checked in props)
            if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
              switch (checked) {
                case "selected":
                  domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                  break;
                default:
                  setProp(domElement, tag, checked, hasSrc, props, null);
              }
          return;
        case "dialog":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          listenToNonDelegatedEvent("cancel", domElement);
          listenToNonDelegatedEvent("close", domElement);
          break;
        case "iframe":
        case "object":
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "video":
        case "audio":
          for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
            listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
          break;
        case "image":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", domElement);
          break;
        case "embed":
        case "source":
        case "link":
          listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (defaultChecked in props)
            if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
              switch (defaultChecked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(137, tag));
                default:
                  setProp(domElement, tag, defaultChecked, hasSrc, props, null);
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (propValue$184 in props)
              props.hasOwnProperty(propValue$184) && (hasSrc = props[propValue$184], void 0 !== hasSrc && setPropOnCustomElement(
                domElement,
                tag,
                propValue$184,
                hasSrc,
                props,
                void 0
              ));
            return;
          }
      }
      for (defaultValue2 in props)
        props.hasOwnProperty(defaultValue2) && (hasSrc = props[defaultValue2], null != hasSrc && setProp(domElement, tag, defaultValue2, hasSrc, props, null));
    }
    function updateProperties(domElement, tag, lastProps, nextProps) {
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var name = null, type4 = null, value = null, defaultValue2 = null, lastDefaultValue = null, checked = null, defaultChecked = null;
          for (propKey in lastProps) {
            var lastProp = lastProps[propKey];
            if (lastProps.hasOwnProperty(propKey) && null != lastProp)
              switch (propKey) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  lastDefaultValue = lastProp;
                default:
                  nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
              }
          }
          for (var propKey$201 in nextProps) {
            var propKey = nextProps[propKey$201];
            lastProp = lastProps[propKey$201];
            if (nextProps.hasOwnProperty(propKey$201) && (null != propKey || null != lastProp))
              switch (propKey$201) {
                case "type":
                  type4 = propKey;
                  break;
                case "name":
                  name = propKey;
                  break;
                case "checked":
                  checked = propKey;
                  break;
                case "defaultChecked":
                  defaultChecked = propKey;
                  break;
                case "value":
                  value = propKey;
                  break;
                case "defaultValue":
                  defaultValue2 = propKey;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  propKey !== lastProp && setProp(
                    domElement,
                    tag,
                    propKey$201,
                    propKey,
                    nextProps,
                    lastProp
                  );
              }
          }
          updateInput(
            domElement,
            value,
            defaultValue2,
            lastDefaultValue,
            checked,
            defaultChecked,
            type4,
            name
          );
          return;
        case "select":
          propKey = value = defaultValue2 = propKey$201 = null;
          for (type4 in lastProps)
            if (lastDefaultValue = lastProps[type4], lastProps.hasOwnProperty(type4) && null != lastDefaultValue)
              switch (type4) {
                case "value":
                  break;
                case "multiple":
                  propKey = lastDefaultValue;
                default:
                  nextProps.hasOwnProperty(type4) || setProp(
                    domElement,
                    tag,
                    type4,
                    null,
                    nextProps,
                    lastDefaultValue
                  );
              }
          for (name in nextProps)
            if (type4 = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type4 || null != lastDefaultValue))
              switch (name) {
                case "value":
                  propKey$201 = type4;
                  break;
                case "defaultValue":
                  defaultValue2 = type4;
                  break;
                case "multiple":
                  value = type4;
                default:
                  type4 !== lastDefaultValue && setProp(
                    domElement,
                    tag,
                    name,
                    type4,
                    nextProps,
                    lastDefaultValue
                  );
              }
          tag = defaultValue2;
          lastProps = value;
          nextProps = propKey;
          null != propKey$201 ? updateOptions(domElement, !!lastProps, propKey$201, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
          return;
        case "textarea":
          propKey = propKey$201 = null;
          for (defaultValue2 in lastProps)
            if (name = lastProps[defaultValue2], lastProps.hasOwnProperty(defaultValue2) && null != name && !nextProps.hasOwnProperty(defaultValue2))
              switch (defaultValue2) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  setProp(domElement, tag, defaultValue2, null, nextProps, name);
              }
          for (value in nextProps)
            if (name = nextProps[value], type4 = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type4))
              switch (value) {
                case "value":
                  propKey$201 = name;
                  break;
                case "defaultValue":
                  propKey = name;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != name) throw Error(formatProdErrorMessage(91));
                  break;
                default:
                  name !== type4 && setProp(domElement, tag, value, name, nextProps, type4);
              }
          updateTextarea(domElement, propKey$201, propKey);
          return;
        case "option":
          for (var propKey$217 in lastProps)
            if (propKey$201 = lastProps[propKey$217], lastProps.hasOwnProperty(propKey$217) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$217))
              switch (propKey$217) {
                case "selected":
                  domElement.selected = false;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    propKey$217,
                    null,
                    nextProps,
                    propKey$201
                  );
              }
          for (lastDefaultValue in nextProps)
            if (propKey$201 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
              switch (lastDefaultValue) {
                case "selected":
                  domElement.selected = propKey$201 && "function" !== typeof propKey$201 && "symbol" !== typeof propKey$201;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    lastDefaultValue,
                    propKey$201,
                    nextProps,
                    propKey
                  );
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var propKey$222 in lastProps)
            propKey$201 = lastProps[propKey$222], lastProps.hasOwnProperty(propKey$222) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$222) && setProp(domElement, tag, propKey$222, null, nextProps, propKey$201);
          for (checked in nextProps)
            if (propKey$201 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
              switch (checked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey$201)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    checked,
                    propKey$201,
                    nextProps,
                    propKey
                  );
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (var propKey$227 in lastProps)
              propKey$201 = lastProps[propKey$227], lastProps.hasOwnProperty(propKey$227) && void 0 !== propKey$201 && !nextProps.hasOwnProperty(propKey$227) && setPropOnCustomElement(
                domElement,
                tag,
                propKey$227,
                void 0,
                nextProps,
                propKey$201
              );
            for (defaultChecked in nextProps)
              propKey$201 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$201 === propKey || void 0 === propKey$201 && void 0 === propKey || setPropOnCustomElement(
                domElement,
                tag,
                defaultChecked,
                propKey$201,
                nextProps,
                propKey
              );
            return;
          }
      }
      for (var propKey$232 in lastProps)
        propKey$201 = lastProps[propKey$232], lastProps.hasOwnProperty(propKey$232) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$232) && setProp(domElement, tag, propKey$232, null, nextProps, propKey$201);
      for (lastProp in nextProps)
        propKey$201 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$201 === propKey || null == propKey$201 && null == propKey || setProp(domElement, tag, lastProp, propKey$201, nextProps, propKey);
    }
    function isLikelyStaticResource(initiatorType) {
      switch (initiatorType) {
        case "css":
        case "script":
        case "font":
        case "img":
        case "image":
        case "input":
        case "link":
          return true;
        default:
          return false;
      }
    }
    function estimateBandwidth() {
      if ("function" === typeof performance.getEntriesByType) {
        for (var count = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i2 = 0; i2 < resourceEntries.length; i2++) {
          var entry = resourceEntries[i2], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration2 = entry.duration;
          if (transferSize && duration2 && isLikelyStaticResource(initiatorType)) {
            initiatorType = 0;
            duration2 = entry.responseEnd;
            for (i2 += 1; i2 < resourceEntries.length; i2++) {
              var overlapEntry = resourceEntries[i2], overlapStartTime = overlapEntry.startTime;
              if (overlapStartTime > duration2) break;
              var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
              overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration2 ? 1 : (duration2 - overlapStartTime) / (overlapEntry - overlapStartTime)));
            }
            --i2;
            bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
            count++;
            if (10 < count) break;
          }
        }
        if (0 < count) return bits / count / 1e6;
      }
      return navigator.connection && (count = navigator.connection.downlink, "number" === typeof count) ? count : 5;
    }
    var eventsEnabled = null, selectionInformation = null;
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
      return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
    }
    function getOwnHostContext(namespaceURI) {
      switch (namespaceURI) {
        case "http://www.w3.org/2000/svg":
          return 1;
        case "http://www.w3.org/1998/Math/MathML":
          return 2;
        default:
          return 0;
      }
    }
    function getChildHostContextProd(parentNamespace, type4) {
      if (0 === parentNamespace)
        switch (type4) {
          case "svg":
            return 1;
          case "math":
            return 2;
          default:
            return 0;
        }
      return 1 === parentNamespace && "foreignObject" === type4 ? 0 : parentNamespace;
    }
    function shouldSetTextContent(type4, props) {
      return "textarea" === type4 || "noscript" === type4 || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
    }
    var currentPopstateTransitionEvent = null;
    function shouldAttemptEagerTransition() {
      var event = window.event;
      if (event && "popstate" === event.type) {
        if (event === currentPopstateTransitionEvent) return false;
        currentPopstateTransitionEvent = event;
        return true;
      }
      currentPopstateTransitionEvent = null;
      return false;
    }
    var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
      return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
    } : scheduleTimeout;
    function handleErrorInNextTick(error) {
      setTimeout(function() {
        throw error;
      });
    }
    function isSingletonScope(type4) {
      return "head" === type4;
    }
    function clearHydrationBoundary(parentInstance, hydrationInstance) {
      var node2 = hydrationInstance, depth = 0;
      do {
        var nextNode = node2.nextSibling;
        parentInstance.removeChild(node2);
        if (nextNode && 8 === nextNode.nodeType)
          if (node2 = nextNode.data, "/$" === node2 || "/&" === node2) {
            if (0 === depth) {
              parentInstance.removeChild(nextNode);
              retryIfBlockedOn(hydrationInstance);
              return;
            }
            depth--;
          } else if ("$" === node2 || "$?" === node2 || "$~" === node2 || "$!" === node2 || "&" === node2)
            depth++;
          else if ("html" === node2)
            releaseSingletonInstance(parentInstance.ownerDocument.documentElement);
          else if ("head" === node2) {
            node2 = parentInstance.ownerDocument.head;
            releaseSingletonInstance(node2);
            for (var node$jscomp$0 = node2.firstChild; node$jscomp$0; ) {
              var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
              node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node2.removeChild(node$jscomp$0);
              node$jscomp$0 = nextNode$jscomp$0;
            }
          } else
            "body" === node2 && releaseSingletonInstance(parentInstance.ownerDocument.body);
        node2 = nextNode;
      } while (node2);
      retryIfBlockedOn(hydrationInstance);
    }
    function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
      var node2 = suspenseInstance;
      suspenseInstance = 0;
      do {
        var nextNode = node2.nextSibling;
        1 === node2.nodeType ? isHidden ? (node2._stashedDisplay = node2.style.display, node2.style.display = "none") : (node2.style.display = node2._stashedDisplay || "", "" === node2.getAttribute("style") && node2.removeAttribute("style")) : 3 === node2.nodeType && (isHidden ? (node2._stashedText = node2.nodeValue, node2.nodeValue = "") : node2.nodeValue = node2._stashedText || "");
        if (nextNode && 8 === nextNode.nodeType)
          if (node2 = nextNode.data, "/$" === node2)
            if (0 === suspenseInstance) break;
            else suspenseInstance--;
          else
            "$" !== node2 && "$?" !== node2 && "$~" !== node2 && "$!" !== node2 || suspenseInstance++;
        node2 = nextNode;
      } while (node2);
    }
    function clearContainerSparingly(container) {
      var nextNode = container.firstChild;
      nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
      for (; nextNode; ) {
        var node2 = nextNode;
        nextNode = nextNode.nextSibling;
        switch (node2.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            clearContainerSparingly(node2);
            detachDeletedInstance(node2);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if ("stylesheet" === node2.rel.toLowerCase()) continue;
        }
        container.removeChild(node2);
      }
    }
    function canHydrateInstance(instance, type4, props, inRootOrSingleton) {
      for (; 1 === instance.nodeType; ) {
        var anyProps = props;
        if (instance.nodeName.toLowerCase() !== type4.toLowerCase()) {
          if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
            break;
        } else if (!inRootOrSingleton)
          if ("input" === type4 && "hidden" === instance.type) {
            var name = null == anyProps.name ? null : "" + anyProps.name;
            if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
              return instance;
          } else return instance;
        else if (!instance[internalHoistableMarker])
          switch (type4) {
            case "meta":
              if (!instance.hasAttribute("itemprop")) break;
              return instance;
            case "link":
              name = instance.getAttribute("rel");
              if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                break;
              else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                break;
              return instance;
            case "style":
              if (instance.hasAttribute("data-precedence")) break;
              return instance;
            case "script":
              name = instance.getAttribute("src");
              if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                break;
              return instance;
            default:
              return instance;
          }
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) break;
      }
      return null;
    }
    function canHydrateTextInstance(instance, text, inRootOrSingleton) {
      if ("" === text) return null;
      for (; 3 !== instance.nodeType; ) {
        if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
      for (; 8 !== instance.nodeType; ) {
        if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    function isSuspenseInstancePending(instance) {
      return "$?" === instance.data || "$~" === instance.data;
    }
    function isSuspenseInstanceFallback(instance) {
      return "$!" === instance.data || "$?" === instance.data && "loading" !== instance.ownerDocument.readyState;
    }
    function registerSuspenseInstanceRetry(instance, callback) {
      var ownerDocument = instance.ownerDocument;
      if ("$~" === instance.data) instance._reactRetry = callback;
      else if ("$?" !== instance.data || "loading" !== ownerDocument.readyState)
        callback();
      else {
        var listener = function() {
          callback();
          ownerDocument.removeEventListener("DOMContentLoaded", listener);
        };
        ownerDocument.addEventListener("DOMContentLoaded", listener);
        instance._reactRetry = listener;
      }
    }
    function getNextHydratable(node2) {
      for (; null != node2; node2 = node2.nextSibling) {
        var nodeType = node2.nodeType;
        if (1 === nodeType || 3 === nodeType) break;
        if (8 === nodeType) {
          nodeType = node2.data;
          if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "$~" === nodeType || "&" === nodeType || "F!" === nodeType || "F" === nodeType)
            break;
          if ("/$" === nodeType || "/&" === nodeType) return null;
        }
      }
      return node2;
    }
    var previousHydratableOnEnteringScopedSingleton = null;
    function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
      hydrationInstance = hydrationInstance.nextSibling;
      for (var depth = 0; hydrationInstance; ) {
        if (8 === hydrationInstance.nodeType) {
          var data2 = hydrationInstance.data;
          if ("/$" === data2 || "/&" === data2) {
            if (0 === depth)
              return getNextHydratable(hydrationInstance.nextSibling);
            depth--;
          } else
            "$" !== data2 && "$!" !== data2 && "$?" !== data2 && "$~" !== data2 && "&" !== data2 || depth++;
        }
        hydrationInstance = hydrationInstance.nextSibling;
      }
      return null;
    }
    function getParentHydrationBoundary(targetInstance) {
      targetInstance = targetInstance.previousSibling;
      for (var depth = 0; targetInstance; ) {
        if (8 === targetInstance.nodeType) {
          var data2 = targetInstance.data;
          if ("$" === data2 || "$!" === data2 || "$?" === data2 || "$~" === data2 || "&" === data2) {
            if (0 === depth) return targetInstance;
            depth--;
          } else "/$" !== data2 && "/&" !== data2 || depth++;
        }
        targetInstance = targetInstance.previousSibling;
      }
      return null;
    }
    function resolveSingletonInstance(type4, props, rootContainerInstance) {
      props = getOwnerDocumentFromRootContainer(rootContainerInstance);
      switch (type4) {
        case "html":
          type4 = props.documentElement;
          if (!type4) throw Error(formatProdErrorMessage(452));
          return type4;
        case "head":
          type4 = props.head;
          if (!type4) throw Error(formatProdErrorMessage(453));
          return type4;
        case "body":
          type4 = props.body;
          if (!type4) throw Error(formatProdErrorMessage(454));
          return type4;
        default:
          throw Error(formatProdErrorMessage(451));
      }
    }
    function releaseSingletonInstance(instance) {
      for (var attributes2 = instance.attributes; attributes2.length; )
        instance.removeAttributeNode(attributes2[0]);
      detachDeletedInstance(instance);
    }
    var preloadPropsMap = new Map(), preconnectsSet = new Set();
    function getHoistableRoot(container) {
      return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
    }
    var previousDispatcher = ReactDOMSharedInternals.d;
    ReactDOMSharedInternals.d = {
      f: flushSyncWork,
      r: requestFormReset,
      D: prefetchDNS,
      C: preconnect,
      L: preload,
      m: preloadModule,
      X: preinitScript,
      S: preinitStyle,
      M: preinitModuleScript
    };
    function flushSyncWork() {
      var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
      return previousWasRendering || wasRendering;
    }
    function requestFormReset(form) {
      var formInst = getInstanceFromNode(form);
      null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
    }
    var globalDocument = "undefined" === typeof document ? null : document;
    function preconnectAs(rel, href, crossOrigin) {
      var ownerDocument = globalDocument;
      if (ownerDocument && "string" === typeof href && href) {
        var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
        limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
        "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
        preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
      }
    }
    function prefetchDNS(href) {
      previousDispatcher.D(href);
      preconnectAs("dns-prefetch", href, null);
    }
    function preconnect(href, crossOrigin) {
      previousDispatcher.C(href, crossOrigin);
      preconnectAs("preconnect", href, crossOrigin);
    }
    function preload(href, as, options2) {
      previousDispatcher.L(href, as, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href && as) {
        var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
        "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
          options2.imageSrcSet
        ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
          options2.imageSizes
        ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
        var key = preloadSelector;
        switch (as) {
          case "style":
            key = getStyleKey(href);
            break;
          case "script":
            key = getScriptKey(href);
        }
        preloadPropsMap.has(key) || (href = assign2(
          {
            rel: "preload",
            href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
            as
          },
          options2
        ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
      }
    }
    function preloadModule(href, options2) {
      previousDispatcher.m(href, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href) {
        var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
        switch (as) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            key = getScriptKey(href);
        }
        if (!preloadPropsMap.has(key) && (href = assign2({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                return;
          }
          as = ownerDocument.createElement("link");
          setInitialProperties(as, "link", href);
          markNodeAsHoistable(as);
          ownerDocument.head.appendChild(as);
        }
      }
    }
    function preinitStyle(href, precedence, options2) {
      previousDispatcher.S(href, precedence, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href) {
        var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
        precedence = precedence || "default";
        var resource = styles.get(key);
        if (!resource) {
          var state2 = { loading: 0, preload: null };
          if (resource = ownerDocument.querySelector(
            getStylesheetSelectorFromKey(key)
          ))
            state2.loading = 5;
          else {
            href = assign2(
              { rel: "stylesheet", href, "data-precedence": precedence },
              options2
            );
            (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
            var link = resource = ownerDocument.createElement("link");
            markNodeAsHoistable(link);
            setInitialProperties(link, "link", href);
            link._p = new Promise(function(resolve, reject) {
              link.onload = resolve;
              link.onerror = reject;
            });
            link.addEventListener("load", function() {
              state2.loading |= 1;
            });
            link.addEventListener("error", function() {
              state2.loading |= 2;
            });
            state2.loading |= 4;
            insertStylesheet(resource, precedence, ownerDocument);
          }
          resource = {
            type: "stylesheet",
            instance: resource,
            count: 1,
            state: state2
          };
          styles.set(key, resource);
        }
      }
    }
    function preinitScript(src, options2) {
      previousDispatcher.X(src, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
        resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign2({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
          type: "script",
          instance: resource,
          count: 1,
          state: null
        }, scripts.set(key, resource));
      }
    }
    function preinitModuleScript(src, options2) {
      previousDispatcher.M(src, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
        resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign2({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
          type: "script",
          instance: resource,
          count: 1,
          state: null
        }, scripts.set(key, resource));
      }
    }
    function getResource(type4, currentProps, pendingProps, currentResource) {
      var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
      if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
      switch (type4) {
        case "meta":
        case "title":
          return null;
        case "style":
          return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
            type4 = getStyleKey(pendingProps.href);
            var styles$243 = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableStyles, resource$244 = styles$243.get(type4);
            resource$244 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$244 = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: { loading: 0, preload: null }
            }, styles$243.set(type4, resource$244), (styles$243 = JSCompiler_inline_result.querySelector(
              getStylesheetSelectorFromKey(type4)
            )) && !styles$243._p && (resource$244.instance = styles$243, resource$244.state.loading = 5), preloadPropsMap.has(type4) || (pendingProps = {
              rel: "preload",
              as: "style",
              href: pendingProps.href,
              crossOrigin: pendingProps.crossOrigin,
              integrity: pendingProps.integrity,
              media: pendingProps.media,
              hrefLang: pendingProps.hrefLang,
              referrerPolicy: pendingProps.referrerPolicy
            }, preloadPropsMap.set(type4, pendingProps), styles$243 || preloadStylesheet(
              JSCompiler_inline_result,
              type4,
              pendingProps,
              resource$244.state
            )));
            if (currentProps && null === currentResource)
              throw Error(formatProdErrorMessage(528, ""));
            return resource$244;
          }
          if (currentProps && null !== currentResource)
            throw Error(formatProdErrorMessage(529, ""));
          return null;
        case "script":
          return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
        default:
          throw Error(formatProdErrorMessage(444, type4));
      }
    }
    function getStyleKey(href) {
      return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
    }
    function getStylesheetSelectorFromKey(key) {
      return 'link[rel="stylesheet"][' + key + "]";
    }
    function stylesheetPropsFromRawProps(rawProps) {
      return assign2({}, rawProps, {
        "data-precedence": rawProps.precedence,
        precedence: null
      });
    }
    function preloadStylesheet(ownerDocument, key, preloadProps, state2) {
      ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state2.loading = 1 : (key = ownerDocument.createElement("link"), state2.preload = key, key.addEventListener("load", function() {
        return state2.loading |= 1;
      }), key.addEventListener("error", function() {
        return state2.loading |= 2;
      }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
    }
    function getScriptKey(src) {
      return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
    }
    function getScriptSelectorFromKey(key) {
      return "script[async]" + key;
    }
    function acquireResource(hoistableRoot, resource, props) {
      resource.count++;
      if (null === resource.instance)
        switch (resource.type) {
          case "style":
            var instance = hoistableRoot.querySelector(
              'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
            );
            if (instance)
              return resource.instance = instance, markNodeAsHoistable(instance), instance;
            var styleProps = assign2({}, props, {
              "data-href": props.href,
              "data-precedence": props.precedence,
              href: null,
              precedence: null
            });
            instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
              "style"
            );
            markNodeAsHoistable(instance);
            setInitialProperties(instance, "style", styleProps);
            insertStylesheet(instance, props.precedence, hoistableRoot);
            return resource.instance = instance;
          case "stylesheet":
            styleProps = getStyleKey(props.href);
            var instance$249 = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(styleProps)
            );
            if (instance$249)
              return resource.state.loading |= 4, resource.instance = instance$249, markNodeAsHoistable(instance$249), instance$249;
            instance = stylesheetPropsFromRawProps(props);
            (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
            instance$249 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
            markNodeAsHoistable(instance$249);
            var linkInstance = instance$249;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance$249, "link", instance);
            resource.state.loading |= 4;
            insertStylesheet(instance$249, props.precedence, hoistableRoot);
            return resource.instance = instance$249;
          case "script":
            instance$249 = getScriptKey(props.src);
            if (styleProps = hoistableRoot.querySelector(
              getScriptSelectorFromKey(instance$249)
            ))
              return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
            instance = props;
            if (styleProps = preloadPropsMap.get(instance$249))
              instance = assign2({}, props), adoptPreloadPropsForScript(instance, styleProps);
            hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
            styleProps = hoistableRoot.createElement("script");
            markNodeAsHoistable(styleProps);
            setInitialProperties(styleProps, "link", instance);
            hoistableRoot.head.appendChild(styleProps);
            return resource.instance = styleProps;
          case "void":
            return null;
          default:
            throw Error(formatProdErrorMessage(443, resource.type));
        }
      else
        "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
      return resource.instance;
    }
    function insertStylesheet(instance, precedence, root3) {
      for (var nodes = root3.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i2 = 0; i2 < nodes.length; i2++) {
        var node2 = nodes[i2];
        if (node2.dataset.precedence === precedence) prior = node2;
        else if (prior !== last) break;
      }
      prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root3.nodeType ? root3.head : root3, precedence.insertBefore(instance, precedence.firstChild));
    }
    function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
      null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
      null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
      null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
    }
    function adoptPreloadPropsForScript(scriptProps, preloadProps) {
      null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
      null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
      null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
    }
    var tagCaches = null;
    function getHydratableHoistableCache(type4, keyAttribute, ownerDocument) {
      if (null === tagCaches) {
        var cache2 = new Map();
        var caches = tagCaches = new Map();
        caches.set(ownerDocument, cache2);
      } else
        caches = tagCaches, cache2 = caches.get(ownerDocument), cache2 || (cache2 = new Map(), caches.set(ownerDocument, cache2));
      if (cache2.has(type4)) return cache2;
      cache2.set(type4, null);
      ownerDocument = ownerDocument.getElementsByTagName(type4);
      for (caches = 0; caches < ownerDocument.length; caches++) {
        var node2 = ownerDocument[caches];
        if (!(node2[internalHoistableMarker] || node2[internalInstanceKey] || "link" === type4 && "stylesheet" === node2.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node2.namespaceURI) {
          var nodeKey = node2.getAttribute(keyAttribute) || "";
          nodeKey = type4 + nodeKey;
          var existing = cache2.get(nodeKey);
          existing ? existing.push(node2) : cache2.set(nodeKey, [node2]);
        }
      }
      return cache2;
    }
    function mountHoistable(hoistableRoot, type4, instance) {
      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
      hoistableRoot.head.insertBefore(
        instance,
        "title" === type4 ? hoistableRoot.querySelector("head > title") : null
      );
    }
    function isHostHoistableType(type4, props, hostContext) {
      if (1 === hostContext || null != props.itemProp) return false;
      switch (type4) {
        case "meta":
        case "title":
          return true;
        case "style":
          if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
            break;
          return true;
        case "link":
          if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
            break;
          switch (props.rel) {
            case "stylesheet":
              return type4 = props.disabled, "string" === typeof props.precedence && null == type4;
            default:
              return true;
          }
        case "script":
          if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
            return true;
      }
      return false;
    }
    function preloadResource(resource) {
      return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
    }
    function suspendResource(state2, hoistableRoot, resource, props) {
      if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
        if (null === resource.instance) {
          var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
            getStylesheetSelectorFromKey(key)
          );
          if (instance) {
            hoistableRoot = instance._p;
            null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state2.count++, state2 = onUnsuspend.bind(state2), hoistableRoot.then(state2, state2));
            resource.state.loading |= 4;
            resource.instance = instance;
            markNodeAsHoistable(instance);
            return;
          }
          instance = hoistableRoot.ownerDocument || hoistableRoot;
          props = stylesheetPropsFromRawProps(props);
          (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
          instance = instance.createElement("link");
          markNodeAsHoistable(instance);
          var linkInstance = instance;
          linkInstance._p = new Promise(function(resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(instance, "link", props);
          resource.instance = instance;
        }
        null === state2.stylesheets && (state2.stylesheets = new Map());
        state2.stylesheets.set(resource, hoistableRoot);
        (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state2.count++, resource = onUnsuspend.bind(state2), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
      }
    }
    var estimatedBytesWithinLimit = 0;
    function waitForCommitToBeReady(state2, timeoutOffset) {
      state2.stylesheets && 0 === state2.count && insertSuspendedStylesheets(state2, state2.stylesheets);
      return 0 < state2.count || 0 < state2.imgCount ? function(commit) {
        var stylesheetTimer = setTimeout(function() {
          state2.stylesheets && insertSuspendedStylesheets(state2, state2.stylesheets);
          if (state2.unsuspend) {
            var unsuspend = state2.unsuspend;
            state2.unsuspend = null;
            unsuspend();
          }
        }, 6e4 + timeoutOffset);
        0 < state2.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
        var imgTimer = setTimeout(
          function() {
            state2.waitingForImages = false;
            if (0 === state2.count && (state2.stylesheets && insertSuspendedStylesheets(state2, state2.stylesheets), state2.unsuspend)) {
              var unsuspend = state2.unsuspend;
              state2.unsuspend = null;
              unsuspend();
            }
          },
          (state2.imgBytes > estimatedBytesWithinLimit ? 50 : 800) + timeoutOffset
        );
        state2.unsuspend = commit;
        return function() {
          state2.unsuspend = null;
          clearTimeout(stylesheetTimer);
          clearTimeout(imgTimer);
        };
      } : null;
    }
    function onUnsuspend() {
      this.count--;
      if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
        if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
        else if (this.unsuspend) {
          var unsuspend = this.unsuspend;
          this.unsuspend = null;
          unsuspend();
        }
      }
    }
    var precedencesByRoot = null;
    function insertSuspendedStylesheets(state2, resources) {
      state2.stylesheets = null;
      null !== state2.unsuspend && (state2.count++, precedencesByRoot = new Map(), resources.forEach(insertStylesheetIntoRoot, state2), precedencesByRoot = null, onUnsuspend.call(state2));
    }
    function insertStylesheetIntoRoot(root3, resource) {
      if (!(resource.state.loading & 4)) {
        var precedences = precedencesByRoot.get(root3);
        if (precedences) var last = precedences.get(null);
        else {
          precedences = new Map();
          precedencesByRoot.set(root3, precedences);
          for (var nodes = root3.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ), i2 = 0; i2 < nodes.length; i2++) {
            var node2 = nodes[i2];
            if ("LINK" === node2.nodeName || "not all" !== node2.getAttribute("media"))
              precedences.set(node2.dataset.precedence, node2), last = node2;
          }
          last && precedences.set(null, last);
        }
        nodes = resource.instance;
        node2 = nodes.getAttribute("data-precedence");
        i2 = precedences.get(node2) || last;
        i2 === last && precedences.set(null, nodes);
        precedences.set(node2, nodes);
        this.count++;
        last = onUnsuspend.bind(this);
        nodes.addEventListener("load", last);
        nodes.addEventListener("error", last);
        i2 ? i2.parentNode.insertBefore(nodes, i2.nextSibling) : (root3 = 9 === root3.nodeType ? root3.head : root3, root3.insertBefore(nodes, root3.firstChild));
        resource.state.loading |= 4;
      }
    }
    var HostTransitionContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Provider: null,
      Consumer: null,
      _currentValue: sharedNotPendingObject,
      _currentValue2: sharedNotPendingObject,
      _threadCount: 0
    };
    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
      this.tag = 1;
      this.containerInfo = containerInfo;
      this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
      this.callbackPriority = 0;
      this.expirationTimes = createLaneMap(-1);
      this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = createLaneMap(0);
      this.hiddenUpdates = createLaneMap(null);
      this.identifierPrefix = identifierPrefix;
      this.onUncaughtError = onUncaughtError;
      this.onCaughtError = onCaughtError;
      this.onRecoverableError = onRecoverableError;
      this.pooledCache = null;
      this.pooledCacheLanes = 0;
      this.formState = formState;
      this.incompleteTransitions = new Map();
    }
    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
      containerInfo = new FiberRootNode(
        containerInfo,
        tag,
        hydrate,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        onDefaultTransitionIndicator,
        formState
      );
      tag = 1;
      true === isStrictMode && (tag |= 24);
      isStrictMode = createFiberImplClass(3, null, null, tag);
      containerInfo.current = isStrictMode;
      isStrictMode.stateNode = containerInfo;
      tag = createCache3();
      tag.refCount++;
      containerInfo.pooledCache = tag;
      tag.refCount++;
      isStrictMode.memoizedState = {
        element: initialChildren,
        isDehydrated: hydrate,
        cache: tag
      };
      initializeUpdateQueue(isStrictMode);
      return containerInfo;
    }
    function getContextForSubtree(parentComponent) {
      if (!parentComponent) return emptyContextObject;
      parentComponent = emptyContextObject;
      return parentComponent;
    }
    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
      parentComponent = getContextForSubtree(parentComponent);
      null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
      container = createUpdate(lane);
      container.payload = { element };
      callback = void 0 === callback ? null : callback;
      null !== callback && (container.callback = callback);
      element = enqueueUpdate(rootFiber, container, lane);
      null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
    }
    function markRetryLaneImpl(fiber, retryLane) {
      fiber = fiber.memoizedState;
      if (null !== fiber && null !== fiber.dehydrated) {
        var a2 = fiber.retryLane;
        fiber.retryLane = 0 !== a2 && a2 < retryLane ? a2 : retryLane;
      }
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane);
      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
    }
    function attemptContinuousHydration(fiber) {
      if (13 === fiber.tag || 31 === fiber.tag) {
        var root3 = enqueueConcurrentRenderForLane(fiber, 67108864);
        null !== root3 && scheduleUpdateOnFiber(root3, fiber, 67108864);
        markRetryLaneIfNotHydrated(fiber, 67108864);
      }
    }
    function attemptHydrationAtCurrentPriority(fiber) {
      if (13 === fiber.tag || 31 === fiber.tag) {
        var lane = requestUpdateLane();
        lane = getBumpedLaneForHydrationByLane(lane);
        var root3 = enqueueConcurrentRenderForLane(fiber, lane);
        null !== root3 && scheduleUpdateOnFiber(root3, fiber, lane);
        markRetryLaneIfNotHydrated(fiber, lane);
      }
    }
    var _enabled = true;
    function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (_enabled) {
        var blockedOn = findInstanceBlockingEvent(nativeEvent);
        if (null === blockedOn)
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer
          ), clearIfContinuousEvent(domEventName, nativeEvent);
        else if (queueIfContinuousEvent(
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        ))
          nativeEvent.stopPropagation();
        else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
          for (; null !== blockedOn; ) {
            var fiber = getInstanceFromNode(blockedOn);
            if (null !== fiber)
              switch (fiber.tag) {
                case 3:
                  fiber = fiber.stateNode;
                  if (fiber.current.memoizedState.isDehydrated) {
                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                    if (0 !== lanes) {
                      var root3 = fiber;
                      root3.pendingLanes |= 2;
                      for (root3.entangledLanes |= 2; lanes; ) {
                        var lane = 1 << 31 - clz32(lanes);
                        root3.entanglements[1] |= lane;
                        lanes &= ~lane;
                      }
                      ensureRootIsScheduled(fiber);
                      0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now2() + 500, flushSyncWorkAcrossRoots_impl(0));
                    }
                  }
                  break;
                case 31:
                case 13:
                  root3 = enqueueConcurrentRenderForLane(fiber, 2), null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
              }
            fiber = findInstanceBlockingEvent(nativeEvent);
            null === fiber && dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            );
            if (fiber === blockedOn) break;
            blockedOn = fiber;
          }
          null !== blockedOn && nativeEvent.stopPropagation();
        } else
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            null,
            targetContainer
          );
      }
    }
    function findInstanceBlockingEvent(nativeEvent) {
      nativeEvent = getEventTarget(nativeEvent);
      return findInstanceBlockingTarget(nativeEvent);
    }
    var return_targetInst = null;
    function findInstanceBlockingTarget(targetNode) {
      return_targetInst = null;
      targetNode = getClosestInstanceFromNode(targetNode);
      if (null !== targetNode) {
        var nearestMounted = getNearestMountedFiber(targetNode);
        if (null === nearestMounted) targetNode = null;
        else {
          var tag = nearestMounted.tag;
          if (13 === tag) {
            targetNode = getSuspenseInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (31 === tag) {
            targetNode = getActivityInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (3 === tag) {
            if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
              return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
            targetNode = null;
          } else nearestMounted !== targetNode && (targetNode = null);
        }
      }
      return_targetInst = targetNode;
      return null;
    }
    function getEventPriority(domEventName) {
      switch (domEventName) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 8;
        case "message":
          switch (getCurrentPriorityLevel()) {
            case ImmediatePriority:
              return 2;
            case UserBlockingPriority:
              return 8;
            case NormalPriority$1:
            case LowPriority:
              return 32;
            case IdlePriority:
              return 268435456;
            default:
              return 32;
          }
        default:
          return 32;
      }
    }
    var hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = new Map(), queuedPointerCaptures = new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    );
    function clearIfContinuousEvent(domEventName, nativeEvent) {
      switch (domEventName) {
        case "focusin":
        case "focusout":
          queuedFocus = null;
          break;
        case "dragenter":
        case "dragleave":
          queuedDrag = null;
          break;
        case "mouseover":
        case "mouseout":
          queuedMouse = null;
          break;
        case "pointerover":
        case "pointerout":
          queuedPointers.delete(nativeEvent.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          queuedPointerCaptures.delete(nativeEvent.pointerId);
      }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
        return existingQueuedEvent = {
          blockedOn,
          domEventName,
          eventSystemFlags,
          nativeEvent,
          targetContainers: [targetContainer]
        }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
      existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
      blockedOn = existingQueuedEvent.targetContainers;
      null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
      return existingQueuedEvent;
    }
    function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      switch (domEventName) {
        case "focusin":
          return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedFocus,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "dragenter":
          return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedDrag,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "mouseover":
          return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedMouse,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "pointerover":
          var pointerId = nativeEvent.pointerId;
          queuedPointers.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointers.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )
          );
          return true;
        case "gotpointercapture":
          return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointerCaptures.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )
          ), true;
      }
      return false;
    }
    function attemptExplicitHydrationTarget(queuedTarget) {
      var targetInst = getClosestInstanceFromNode(queuedTarget.target);
      if (null !== targetInst) {
        var nearestMounted = getNearestMountedFiber(targetInst);
        if (null !== nearestMounted) {
          if (targetInst = nearestMounted.tag, 13 === targetInst) {
            if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function() {
                attemptHydrationAtCurrentPriority(nearestMounted);
              });
              return;
            }
          } else if (31 === targetInst) {
            if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function() {
                attemptHydrationAtCurrentPriority(nearestMounted);
              });
              return;
            }
          } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
            queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
            return;
          }
        }
      }
      queuedTarget.blockedOn = null;
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
      if (null !== queuedEvent.blockedOn) return false;
      for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
        var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
        if (null === nextBlockedOn) {
          nextBlockedOn = queuedEvent.nativeEvent;
          var nativeEventClone = new nextBlockedOn.constructor(
            nextBlockedOn.type,
            nextBlockedOn
          );
          currentReplayingEvent = nativeEventClone;
          nextBlockedOn.target.dispatchEvent(nativeEventClone);
          currentReplayingEvent = null;
        } else
          return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
        targetContainers.shift();
      }
      return true;
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
      attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
    }
    function replayUnblockedEvents() {
      hasScheduledReplayAttempt = false;
      null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
      null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
      null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
      queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
      queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
      queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        replayUnblockedEvents
      )));
    }
    var lastScheduledReplayQueue = null;
    function scheduleReplayQueueIfNeeded(formReplayingQueue) {
      lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        function() {
          lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
          for (var i2 = 0; i2 < formReplayingQueue.length; i2 += 3) {
            var form = formReplayingQueue[i2], submitterOrAction = formReplayingQueue[i2 + 1], formData = formReplayingQueue[i2 + 2];
            if ("function" !== typeof submitterOrAction)
              if (null === findInstanceBlockingTarget(submitterOrAction || form))
                continue;
              else break;
            var formInst = getInstanceFromNode(form);
            null !== formInst && (formReplayingQueue.splice(i2, 3), i2 -= 3, startHostTransition(
              formInst,
              {
                pending: true,
                data: formData,
                method: form.method,
                action: submitterOrAction
              },
              submitterOrAction,
              formData
            ));
          }
        }
      ));
    }
    function retryIfBlockedOn(unblocked) {
      function unblock(queuedEvent) {
        return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
      }
      null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
      null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
      null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
      queuedPointers.forEach(unblock);
      queuedPointerCaptures.forEach(unblock);
      for (var i2 = 0; i2 < queuedExplicitHydrationTargets.length; i2++) {
        var queuedTarget = queuedExplicitHydrationTargets[i2];
        queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
      }
      for (; 0 < queuedExplicitHydrationTargets.length && (i2 = queuedExplicitHydrationTargets[0], null === i2.blockedOn); )
        attemptExplicitHydrationTarget(i2), null === i2.blockedOn && queuedExplicitHydrationTargets.shift();
      i2 = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
      if (null != i2)
        for (queuedTarget = 0; queuedTarget < i2.length; queuedTarget += 3) {
          var form = i2[queuedTarget], submitterOrAction = i2[queuedTarget + 1], formProps = form[internalPropsKey] || null;
          if ("function" === typeof submitterOrAction)
            formProps || scheduleReplayQueueIfNeeded(i2);
          else if (formProps) {
            var action2 = null;
            if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
              if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                action2 = formProps.formAction;
              else {
                if (null !== findInstanceBlockingTarget(form)) continue;
              }
            else action2 = formProps.action;
            "function" === typeof action2 ? i2[queuedTarget + 1] = action2 : (i2.splice(queuedTarget, 3), queuedTarget -= 3);
            scheduleReplayQueueIfNeeded(i2);
          }
        }
    }
    function defaultOnDefaultTransitionIndicator() {
      function handleNavigate(event) {
        event.canIntercept && "react-transition" === event.info && event.intercept({
          handler: function() {
            return new Promise(function(resolve) {
              return pendingResolve = resolve;
            });
          },
          focusReset: "manual",
          scroll: "manual"
        });
      }
      function handleNavigateComplete() {
        null !== pendingResolve && (pendingResolve(), pendingResolve = null);
        isCancelled || setTimeout(startFakeNavigation, 20);
      }
      function startFakeNavigation() {
        if (!isCancelled && !navigation.transition) {
          var currentEntry = navigation.currentEntry;
          currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
            state: currentEntry.getState(),
            info: "react-transition",
            history: "replace"
          });
        }
      }
      if ("object" === typeof navigation) {
        var isCancelled = false, pendingResolve = null;
        navigation.addEventListener("navigate", handleNavigate);
        navigation.addEventListener("navigatesuccess", handleNavigateComplete);
        navigation.addEventListener("navigateerror", handleNavigateComplete);
        setTimeout(startFakeNavigation, 100);
        return function() {
          isCancelled = true;
          navigation.removeEventListener("navigate", handleNavigate);
          navigation.removeEventListener("navigatesuccess", handleNavigateComplete);
          navigation.removeEventListener("navigateerror", handleNavigateComplete);
          null !== pendingResolve && (pendingResolve(), pendingResolve = null);
        };
      }
    }
    function ReactDOMRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
      var root3 = this._internalRoot;
      if (null === root3) throw Error(formatProdErrorMessage(409));
      var current = root3.current, lane = requestUpdateLane();
      updateContainerImpl(current, lane, children, root3, null, null);
    };
    ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
      var root3 = this._internalRoot;
      if (null !== root3) {
        this._internalRoot = null;
        var container = root3.containerInfo;
        updateContainerImpl(root3.current, 2, null, root3, null, null);
        flushSyncWork$1();
        container[internalContainerInstanceKey] = null;
      }
    };
    function ReactDOMHydrationRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
      if (target) {
        var updatePriority = resolveUpdatePriority();
        target = { blockedOn: null, target, priority: updatePriority };
        for (var i2 = 0; i2 < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i2].priority; i2++) ;
        queuedExplicitHydrationTargets.splice(i2, 0, target);
        0 === i2 && attemptExplicitHydrationTarget(target);
      }
    };
    var isomorphicReactPackageVersion$jscomp$inline_1840 = React2.version;
    if ("19.2.4" !== isomorphicReactPackageVersion$jscomp$inline_1840)
      throw Error(
        formatProdErrorMessage(
          527,
          isomorphicReactPackageVersion$jscomp$inline_1840,
          "19.2.4"
        )
      );
    ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
      var fiber = componentOrElement._reactInternals;
      if (void 0 === fiber) {
        if ("function" === typeof componentOrElement.render)
          throw Error(formatProdErrorMessage(188));
        componentOrElement = Object.keys(componentOrElement).join(",");
        throw Error(formatProdErrorMessage(268, componentOrElement));
      }
      componentOrElement = findCurrentFiberUsingSlowPath(fiber);
      componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
      componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
      return componentOrElement;
    };
    var internals$jscomp$inline_2347 = {
      bundleType: 0,
      version: "19.2.4",
      rendererPackageName: "react-dom",
      currentDispatcherRef: ReactSharedInternals,
      reconcilerVersion: "19.2.4"
    };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!hook$jscomp$inline_2348.isDisabled && hook$jscomp$inline_2348.supportsFiber)
        try {
          rendererID = hook$jscomp$inline_2348.inject(
            internals$jscomp$inline_2347
          ), injectedHook = hook$jscomp$inline_2348;
        } catch (err) {
        }
    }
    reactDomClient_production.createRoot = function(container, options2) {
      if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
      var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
      null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError));
      options2 = createFiberRoot(
        container,
        1,
        false,
        null,
        null,
        isStrictMode,
        identifierPrefix,
        null,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        defaultOnDefaultTransitionIndicator
      );
      container[internalContainerInstanceKey] = options2.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMRoot(options2);
    };
    reactDomClient_production.hydrateRoot = function(container, initialChildren, options2) {
      if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
      var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
      null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.formState && (formState = options2.formState));
      initialChildren = createFiberRoot(
        container,
        1,
        true,
        initialChildren,
        null != options2 ? options2 : null,
        isStrictMode,
        identifierPrefix,
        formState,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        defaultOnDefaultTransitionIndicator
      );
      initialChildren.context = getContextForSubtree(null);
      options2 = initialChildren.current;
      isStrictMode = requestUpdateLane();
      isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
      identifierPrefix = createUpdate(isStrictMode);
      identifierPrefix.callback = null;
      enqueueUpdate(options2, identifierPrefix, isStrictMode);
      options2 = isStrictMode;
      initialChildren.current.lanes = options2;
      markRootUpdated$1(initialChildren, options2);
      ensureRootIsScheduled(initialChildren);
      container[internalContainerInstanceKey] = initialChildren.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMHydrationRoot(initialChildren);
    };
    reactDomClient_production.version = "19.2.4";
    return reactDomClient_production;
  }
  var hasRequiredClient;
  function requireClient() {
    if (hasRequiredClient) return client.exports;
    hasRequiredClient = 1;
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    {
      checkDCE();
      client.exports = requireReactDomClient_production();
    }
    return client.exports;
  }
  var clientExports = requireClient();
  const MARK = "__rc_react_root__";
  function render(node2, container) {
    const root2 = container[MARK] || clientExports.createRoot(container);
    root2.render(node2);
    container[MARK] = root2;
  }
  async function unmount(container) {
    return Promise.resolve().then(() => {
      container[MARK]?.unmount();
      delete container[MARK];
    });
  }
  const getCollapsedHeight = () => ({
    height: 0,
    opacity: 0
  });
  const getRealHeight = (node2) => {
    const {
      scrollHeight
    } = node2;
    return {
      height: scrollHeight,
      opacity: 1
    };
  };
  const getCurrentHeight = (node2) => ({
    height: node2 ? node2.offsetHeight : 0
  });
  const skipOpacityTransition = (_2, event) => event?.deadline === true || event.propertyName === "height";
  const initCollapseMotion = (rootCls = defaultPrefixCls) => ({
    motionName: `${rootCls}-motion-collapse`,
    onAppearStart: getCollapsedHeight,
    onEnterStart: getCollapsedHeight,
    onAppearActive: getRealHeight,
    onEnterActive: getRealHeight,
    onLeaveStart: getCurrentHeight,
    onLeaveActive: getCollapsedHeight,
    onAppearEnd: skipOpacityTransition,
    onEnterEnd: skipOpacityTransition,
    onLeaveEnd: skipOpacityTransition,
    motionDeadline: 500
  });
  const getTransitionName = (rootPrefixCls, motion2, transitionName) => {
    if (transitionName !== void 0) {
      return transitionName;
    }
    return `${rootPrefixCls}-${motion2}`;
  };
  const genWaveStyle = (token2) => {
    const {
      componentCls,
      colorPrimary,
      motionDurationSlow,
      motionEaseInOut,
      motionEaseOutCirc,
      antCls
    } = token2;
    const [, varRef] = genCssVar(antCls, "wave");
    return {
      [componentCls]: {
        position: "absolute",
        background: "transparent",
        pointerEvents: "none",
        boxSizing: "border-box",
        color: varRef("color", colorPrimary),
        boxShadow: `0 0 0 0 currentcolor`,
        opacity: 0.2,
"&.wave-motion-appear": {
          transition: [`box-shadow 0.4s`, `opacity 2s`].map((prop) => `${prop} ${motionEaseOutCirc}`).join(","),
          "&-active": {
            boxShadow: `0 0 0 6px currentcolor`,
            opacity: 0
          },
          "&.wave-quick": {
            transition: [`box-shadow`, `opacity`].map((prop) => `${prop} ${motionDurationSlow} ${motionEaseInOut}`).join(",")
          }
        }
      }
    };
  };
  const useStyle$D = genComponentStyleHook("Wave", genWaveStyle);
  const TARGET_CLS = `${defaultPrefixCls}-wave-target`;
  function isValidWaveColor(color2) {
    return color2 && typeof color2 === "string" && color2 !== "#fff" && color2 !== "#ffffff" && color2 !== "rgb(255, 255, 255)" && color2 !== "rgba(255, 255, 255, 1)" && !/rgba\((?:\d*, ){3}0\)/.test(color2) &&
color2 !== "transparent" && color2 !== "canvastext";
  }
  function getTargetWaveColor(node2, colorSource = null) {
    const style2 = getComputedStyle(node2);
    const {
      borderTopColor,
      borderColor,
      backgroundColor
    } = style2;
    if (colorSource && isValidWaveColor(style2[colorSource])) {
      return style2[colorSource];
    }
    return [borderTopColor, borderColor, backgroundColor].find(isValidWaveColor) ?? null;
  }
  function validateNum(value) {
    return Number.isNaN(value) ? 0 : value;
  }
  const WaveEffect = (props) => {
    const {
      className,
      target,
      component,
      colorSource
    } = props;
    const divRef = reactExports.useRef(null);
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const rootPrefixCls = getPrefixCls();
    const [varName] = genCssVar(rootPrefixCls, "wave");
    const [waveColor, setWaveColor] = reactExports.useState(null);
    const [borderRadius, setBorderRadius] = reactExports.useState([]);
    const [left, setLeft] = reactExports.useState(0);
    const [top, setTop] = reactExports.useState(0);
    const [width, setWidth] = reactExports.useState(0);
    const [height, setHeight] = reactExports.useState(0);
    const [enabled2, setEnabled] = reactExports.useState(false);
    const waveStyle = {
      left,
      top,
      width,
      height,
      borderRadius: borderRadius.map((radius2) => `${radius2}px`).join(" ")
    };
    if (waveColor) {
      waveStyle[varName("color")] = waveColor;
    }
    function syncPos() {
      const nodeStyle = getComputedStyle(target);
      setWaveColor(getTargetWaveColor(target, colorSource));
      const isStatic = nodeStyle.position === "static";
      const {
        borderLeftWidth,
        borderTopWidth
      } = nodeStyle;
      setLeft(isStatic ? target.offsetLeft : validateNum(-Number.parseFloat(borderLeftWidth)));
      setTop(isStatic ? target.offsetTop : validateNum(-Number.parseFloat(borderTopWidth)));
      setWidth(target.offsetWidth);
      setHeight(target.offsetHeight);
      const {
        borderTopLeftRadius,
        borderTopRightRadius,
        borderBottomLeftRadius,
        borderBottomRightRadius
      } = nodeStyle;
      setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map((radius2) => validateNum(Number.parseFloat(radius2))));
    }
    reactExports.useEffect(() => {
      if (target) {
        const id2 = wrapperRaf(() => {
          syncPos();
          setEnabled(true);
        });
        let resizeObserver;
        if (typeof ResizeObserver !== "undefined") {
          resizeObserver = new ResizeObserver(syncPos);
          resizeObserver.observe(target);
        }
        return () => {
          wrapperRaf.cancel(id2);
          resizeObserver?.disconnect();
        };
      }
    }, [target]);
    if (!enabled2) {
      return null;
    }
    const isSmallComponent = (component === "Checkbox" || component === "Radio") && target?.classList.contains(TARGET_CLS);
    return reactExports.createElement(CSSMotion, {
      visible: true,
      motionAppear: true,
      motionName: "wave-motion",
      motionDeadline: 5e3,
      onAppearEnd: (_2, event) => {
        if (event.deadline || event.propertyName === "opacity") {
          const holder = divRef.current?.parentElement;
          unmount(holder).then(() => {
            holder?.remove();
          });
        }
        return false;
      }
    }, ({
      className: motionClassName
    }, ref2) => reactExports.createElement("div", {
      ref: composeRef(divRef, ref2),
      className: clsx(className, motionClassName, {
        "wave-quick": isSmallComponent
      }),
      style: waveStyle
    }));
  };
  const showWaveEffect = (target, info) => {
    const {
      component
    } = info;
    if (component === "Checkbox" && !target.querySelector("input")?.checked) {
      return;
    }
    const holder = document.createElement("div");
    holder.style.position = "absolute";
    holder.style.left = "0px";
    holder.style.top = "0px";
    target?.insertBefore(holder, target?.firstChild);
    render( reactExports.createElement(WaveEffect, {
      ...info,
      target
    }), holder);
  };
  const useWave = (nodeRef, className, component, colorSource) => {
    const {
      wave
    } = reactExports.useContext(ConfigContext);
    const [, token2, hashId] = useToken$1();
    const showWave = useEvent$1((event) => {
      const node2 = nodeRef.current;
      if (wave?.disabled || !node2) {
        return;
      }
      const targetNode = node2.querySelector(`.${TARGET_CLS}`) || node2;
      const {
        showEffect
      } = wave || {};
      (showEffect || showWaveEffect)(targetNode, {
        className,
        token: token2,
        component,
        event,
        hashId,
        colorSource
      });
    });
    const rafId = reactExports.useRef(null);
    reactExports.useEffect(() => () => {
      wrapperRaf.cancel(rafId.current);
    }, []);
    const showDebounceWave = (event) => {
      wrapperRaf.cancel(rafId.current);
      rafId.current = wrapperRaf(() => {
        showWave(event);
      });
    };
    return showDebounceWave;
  };
  const Wave = (props) => {
    const {
      children,
      disabled,
      component,
      colorSource
    } = props;
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const containerRef = reactExports.useRef(null);
    const prefixCls = getPrefixCls("wave");
    const hashId = useStyle$D(prefixCls);
    const showWave = useWave(containerRef, clsx(prefixCls, hashId), component, colorSource);
    React.useEffect(() => {
      const node2 = containerRef.current;
      if (!node2 || node2.nodeType !== window.Node.ELEMENT_NODE || disabled) {
        return;
      }
      const onClick = (e) => {
        if (!isVisible(e.target) ||
!node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") && !node2.className.includes("disabled:") || node2.getAttribute("aria-disabled") === "true" || node2.className.includes("-leave")) {
          return;
        }
        showWave(e);
      };
      node2.addEventListener("click", onClick, true);
      return () => {
        node2.removeEventListener("click", onClick, true);
      };
    }, [disabled]);
    if (! React.isValidElement(children)) {
      return children ?? null;
    }
    const ref2 = supportRef(children) ? composeRef(getNodeRef(children), containerRef) : containerRef;
    return cloneElement(children, {
      ref: ref2
    });
  };
  const useSize = (customSize) => {
    const size = React.useContext(SizeContext);
    const mergedSize = React.useMemo(() => {
      if (!customSize) {
        return size;
      }
      if (typeof customSize === "string") {
        return customSize ?? size;
      }
      if (typeof customSize === "function") {
        return customSize(size);
      }
      return size;
    }, [customSize, size]);
    return mergedSize;
  };
  const genSpaceCompactStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: {
        display: "inline-flex",
        "&-block": {
          display: "flex",
          width: "100%"
        },
        "&-vertical": {
          flexDirection: "column"
        },
        "&-rtl": {
          direction: "rtl"
        }
      }
    };
  };
  const useStyle$C = genStyleHooks(["Space", "Compact"], genSpaceCompactStyle, () => ({}), {

resetStyle: false
  });
  const SpaceCompactItemContext = reactExports.createContext(null);
  const useCompactItemContext = (prefixCls, direction) => {
    const compactItemContext = reactExports.useContext(SpaceCompactItemContext);
    const compactItemClassnames = reactExports.useMemo(() => {
      if (!compactItemContext) {
        return "";
      }
      const {
        compactDirection,
        isFirstItem,
        isLastItem
      } = compactItemContext;
      const separator = compactDirection === "vertical" ? "-vertical-" : "-";
      return clsx(`${prefixCls}-compact${separator}item`, {
        [`${prefixCls}-compact${separator}first-item`]: isFirstItem,
        [`${prefixCls}-compact${separator}last-item`]: isLastItem,
        [`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
      });
    }, [prefixCls, direction, compactItemContext]);
    return {
      compactSize: compactItemContext?.compactSize,
      compactDirection: compactItemContext?.compactDirection,
      compactItemClassnames
    };
  };
  const NoCompactStyle = (props) => {
    const {
      children
    } = props;
    return reactExports.createElement(SpaceCompactItemContext.Provider, {
      value: null
    }, children);
  };
  const CompactItem = (props) => {
    const {
      children,
      ...others
    } = props;
    return reactExports.createElement(SpaceCompactItemContext.Provider, {
      value: reactExports.useMemo(() => others, [others])
    }, children);
  };
  const Compact$1 = (props) => {
    const {
      getPrefixCls,
      direction: directionConfig
    } = reactExports.useContext(ConfigContext);
    const {
      size,
      direction,
      orientation,
      block,
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      children,
      vertical,
      ...restProps
    } = props;
    const [mergedOrientation, mergedVertical] = useOrientation(orientation, vertical, direction);
    const mergedSize = useSize((ctx) => size ?? ctx);
    const prefixCls = getPrefixCls("space-compact", customizePrefixCls);
    const [hashId] = useStyle$C(prefixCls);
    const clx = clsx(prefixCls, hashId, {
      [`${prefixCls}-rtl`]: directionConfig === "rtl",
      [`${prefixCls}-block`]: block,
      [`${prefixCls}-vertical`]: mergedVertical
    }, className, rootClassName);
    const compactItemContext = reactExports.useContext(SpaceCompactItemContext);
    const childNodes = toArray$4(children);
    const nodes = reactExports.useMemo(() => childNodes.map((child, i2) => {
      const key = child?.key || `${prefixCls}-item-${i2}`;
      return reactExports.createElement(CompactItem, {
        key,
        compactSize: mergedSize,
        compactDirection: mergedOrientation,
        isFirstItem: i2 === 0 && (!compactItemContext || compactItemContext?.isFirstItem),
        isLastItem: i2 === childNodes.length - 1 && (!compactItemContext || compactItemContext?.isLastItem)
      }, child);
    }), [childNodes, compactItemContext, mergedOrientation, mergedSize, prefixCls]);
    if (childNodes.length === 0) {
      return null;
    }
    return reactExports.createElement("div", {
      className: clx,
      ...restProps
    }, nodes);
  };
  const GroupSizeContext = reactExports.createContext(void 0);
  const ButtonGroup = (props) => {
    const {
      getPrefixCls,
      direction
    } = reactExports.useContext(ConfigContext);
    const {
      prefixCls: customizePrefixCls,
      size,
      className,
      ...others
    } = props;
    const prefixCls = getPrefixCls("btn-group", customizePrefixCls);
    const [, , hashId] = useToken$1();
    const sizeCls = reactExports.useMemo(() => {
      switch (size) {
        case "large":
          return "lg";
        case "small":
          return "sm";
        default:
          return "";
      }
    }, [size]);
    const classes2 = clsx(prefixCls, {
      [`${prefixCls}-${sizeCls}`]: sizeCls,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, hashId);
    return reactExports.createElement(GroupSizeContext.Provider, {
      value: size
    }, reactExports.createElement("div", {
      ...others,
      className: classes2
    }));
  };
  const rxTwoCNChar = /^[\u4E00-\u9FA5]{2}$/;
  const isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
  function convertLegacyProps(type4) {
    if (type4 === "danger") {
      return {
        danger: true
      };
    }
    return {
      type: type4
    };
  }
  function isString$1(str) {
    return typeof str === "string";
  }
  function isUnBorderedButtonVariant(type4) {
    return type4 === "text" || type4 === "link";
  }
  function splitCNCharsBySpace(child, needInserted, style2, className) {
    if (!isNonNullable(child) || child === "") {
      return;
    }
    const SPACE = needInserted ? " " : "";
    if (typeof child !== "string" && typeof child !== "number" && isString$1(child.type) && isTwoCNChar(child.props.children)) {
      return cloneElement(child, (oriProps) => {
        const mergedCls = clsx(oriProps.className, className) || void 0;
        const mergedStyle = {
          ...style2,
          ...oriProps.style
        };
        return {
          ...oriProps,
          children: oriProps.children.split("").join(SPACE),
          className: mergedCls,
          style: mergedStyle
        };
      });
    }
    if (isString$1(child)) {
      return React.createElement("span", {
        className,
        style: style2
      }, isTwoCNChar(child) ? child.split("").join(SPACE) : child);
    }
    if (isFragment(child)) {
      return React.createElement("span", {
        className,
        style: style2
      }, child);
    }
    return cloneElement(child, (oriProps) => ({
      ...oriProps,
      className: clsx(oriProps.className, className) || void 0,
      style: {
        ...oriProps.style,
        ...style2
      }
    }));
  }
  function spaceChildren(children, needInserted, style2, className) {
    let isPrevChildPure = false;
    const childList = [];
    React.Children.forEach(children, (child) => {
      const type4 = typeof child;
      const isCurrentChildPure = type4 === "string" || type4 === "number";
      if (isPrevChildPure && isCurrentChildPure) {
        const lastIndex = childList.length - 1;
        const lastChild = childList[lastIndex];
        childList[lastIndex] = `${lastChild}${child}`;
      } else {
        childList.push(child);
      }
      isPrevChildPure = isCurrentChildPure;
    });
    return React.Children.map(childList, (child) => splitCNCharsBySpace(child, needInserted, style2, className));
  }
  ["default", "primary", "danger"].concat(_toConsumableArray(PresetColors));
  const IconWrapper = reactExports.forwardRef((props, ref2) => {
    const {
      className,
      style: style2,
      children,
      prefixCls
    } = props;
    const iconWrapperCls = clsx(`${prefixCls}-icon`, className);
    return React.createElement("span", {
      ref: ref2,
      className: iconWrapperCls,
      style: style2
    }, children);
  });
  const InnerLoadingIcon = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls,
      className,
      style: style2,
      iconClassName
    } = props;
    const mergedIconCls = clsx(`${prefixCls}-loading-icon`, className);
    return React.createElement(IconWrapper, {
      prefixCls,
      className: mergedIconCls,
      style: style2,
      ref: ref2
    }, React.createElement(RefIcon$h, {
      className: iconClassName
    }));
  });
  const getCollapsedWidth = () => ({
    width: 0,
    opacity: 0,
    transform: "scale(0)"
  });
  const getRealWidth = (node2) => ({
    width: node2.scrollWidth,
    opacity: 1,
    transform: "scale(1)"
  });
  const DefaultLoadingIcon = (props) => {
    const {
      prefixCls,
      loading,
      existIcon,
      className,
      style: style2,
      mount
    } = props;
    const visible = !!loading;
    if (existIcon) {
      return React.createElement(InnerLoadingIcon, {
        prefixCls,
        className,
        style: style2
      });
    }
    return React.createElement(CSSMotion, {
      visible,
motionName: `${prefixCls}-loading-icon-motion`,
      motionAppear: !mount,
      motionEnter: !mount,
      motionLeave: !mount,
      removeOnLeave: true,
      onAppearStart: getCollapsedWidth,
      onAppearActive: getRealWidth,
      onEnterStart: getCollapsedWidth,
      onEnterActive: getRealWidth,
      onLeaveStart: getRealWidth,
      onLeaveActive: getCollapsedWidth
    }, ({
      className: motionCls,
      style: motionStyle
    }, ref2) => {
      const mergedStyle = {
        ...style2,
        ...motionStyle
      };
      return React.createElement(InnerLoadingIcon, {
        prefixCls,
        className: clsx(className, motionCls),
        style: mergedStyle,
        ref: ref2
      });
    });
  };
  const genCollapseMotion = (token2) => {
    const {
      componentCls,
      antCls,
      motionDurationMid,
      motionEaseInOut
    } = token2;
    return {
      [componentCls]: {
[`${antCls}-motion-collapse-legacy`]: {
          overflow: "hidden",
          "&-active": {
            transition: `${["height", "opacity"].map((prop) => `${prop} ${motionDurationMid} ${motionEaseInOut}`).join(", ")} !important`
          }
        },
        [`${antCls}-motion-collapse`]: {
          overflow: "hidden",
          transition: `${["height", "opacity"].map((prop) => `${prop} ${motionDurationMid} ${motionEaseInOut}`).join(", ")} !important`
        }
      }
    };
  };
  const initMotionCommon = (duration2) => ({
    animationDuration: duration2,
    animationFillMode: "both"
  });
  const initMotionCommonLeave = (duration2) => ({
    animationDuration: duration2,
    animationFillMode: "both"
  });
  const initMotion = (motionCls, inKeyframes, outKeyframes, duration2, sameLevel = false) => {
    const sameLevelPrefix = sameLevel ? "&" : "";
    return {
      [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: {
        ...initMotionCommon(duration2),
        animationPlayState: "paused"
      },
      [`${sameLevelPrefix}${motionCls}-leave`]: {
        ...initMotionCommonLeave(duration2),
        animationPlayState: "paused"
      },
      [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
        animationName: inKeyframes,
        animationPlayState: "running"
      },
      [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
        animationName: outKeyframes,
        animationPlayState: "running",
        pointerEvents: "none"
      }
    };
  };
  const fadeIn = new Keyframe("antFadeIn", {
    "0%": {
      opacity: 0
    },
    "100%": {
      opacity: 1
    }
  });
  const fadeOut = new Keyframe("antFadeOut", {
    "0%": {
      opacity: 1
    },
    "100%": {
      opacity: 0
    }
  });
  const initFadeMotion = (token2, sameLevel = false) => {
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-fade`;
    const sameLevelPrefix = sameLevel ? "&" : "";
    return [initMotion(motionCls, fadeIn, fadeOut, token2.motionDurationMid, sameLevel), {
      [`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
        opacity: 0,
        animationTimingFunction: "linear"
      },
      [`${sameLevelPrefix}${motionCls}-leave`]: {
        animationTimingFunction: "linear"
      }
    }];
  };
  const moveDownIn = new Keyframe("antMoveDownIn", {
    "0%": {
      transform: "translate3d(0, 100%, 0)",
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  const moveDownOut = new Keyframe("antMoveDownOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: "translate3d(0, 100%, 0)",
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  const moveLeftIn = new Keyframe("antMoveLeftIn", {
    "0%": {
      transform: "translate3d(-100%, 0, 0)",
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  const moveLeftOut = new Keyframe("antMoveLeftOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: "translate3d(-100%, 0, 0)",
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  const moveRightIn = new Keyframe("antMoveRightIn", {
    "0%": {
      transform: "translate3d(100%, 0, 0)",
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  const moveRightOut = new Keyframe("antMoveRightOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: "translate3d(100%, 0, 0)",
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  const moveUpIn = new Keyframe("antMoveUpIn", {
    "0%": {
      transform: "translate3d(0, -100%, 0)",
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  const moveUpOut = new Keyframe("antMoveUpOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: "translate3d(0, -100%, 0)",
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  const moveMotion = {
    "move-up": {
      inKeyframes: moveUpIn,
      outKeyframes: moveUpOut
    },
    "move-down": {
      inKeyframes: moveDownIn,
      outKeyframes: moveDownOut
    },
    "move-left": {
      inKeyframes: moveLeftIn,
      outKeyframes: moveLeftOut
    },
    "move-right": {
      inKeyframes: moveRightIn,
      outKeyframes: moveRightOut
    }
  };
  const initMoveMotion = (token2, motionName) => {
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-${motionName}`;
    const {
      inKeyframes,
      outKeyframes
    } = moveMotion[motionName];
    return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
      [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
        opacity: 0,
        animationTimingFunction: token2.motionEaseOutCirc
      },
      [`${motionCls}-leave`]: {
        animationTimingFunction: token2.motionEaseInOutCirc
      }
    }];
  };
  const slideUpIn = new Keyframe("antSlideUpIn", {
    "0%": {
      transform: "scaleY(0.8)",
      transformOrigin: "0% 0%",
      opacity: 0
    },
    "100%": {
      transform: "scaleY(1)",
      transformOrigin: "0% 0%",
      opacity: 1
    }
  });
  const slideUpOut = new Keyframe("antSlideUpOut", {
    "0%": {
      transform: "scaleY(1)",
      transformOrigin: "0% 0%",
      opacity: 1
    },
    "100%": {
      transform: "scaleY(0.8)",
      transformOrigin: "0% 0%",
      opacity: 0
    }
  });
  const slideDownIn = new Keyframe("antSlideDownIn", {
    "0%": {
      transform: "scaleY(0.8)",
      transformOrigin: "100% 100%",
      opacity: 0
    },
    "100%": {
      transform: "scaleY(1)",
      transformOrigin: "100% 100%",
      opacity: 1
    }
  });
  const slideDownOut = new Keyframe("antSlideDownOut", {
    "0%": {
      transform: "scaleY(1)",
      transformOrigin: "100% 100%",
      opacity: 1
    },
    "100%": {
      transform: "scaleY(0.8)",
      transformOrigin: "100% 100%",
      opacity: 0
    }
  });
  const slideLeftIn = new Keyframe("antSlideLeftIn", {
    "0%": {
      transform: "scaleX(0.8)",
      transformOrigin: "0% 0%",
      opacity: 0
    },
    "100%": {
      transform: "scaleX(1)",
      transformOrigin: "0% 0%",
      opacity: 1
    }
  });
  const slideLeftOut = new Keyframe("antSlideLeftOut", {
    "0%": {
      transform: "scaleX(1)",
      transformOrigin: "0% 0%",
      opacity: 1
    },
    "100%": {
      transform: "scaleX(0.8)",
      transformOrigin: "0% 0%",
      opacity: 0
    }
  });
  const slideRightIn = new Keyframe("antSlideRightIn", {
    "0%": {
      transform: "scaleX(0.8)",
      transformOrigin: "100% 0%",
      opacity: 0
    },
    "100%": {
      transform: "scaleX(1)",
      transformOrigin: "100% 0%",
      opacity: 1
    }
  });
  const slideRightOut = new Keyframe("antSlideRightOut", {
    "0%": {
      transform: "scaleX(1)",
      transformOrigin: "100% 0%",
      opacity: 1
    },
    "100%": {
      transform: "scaleX(0.8)",
      transformOrigin: "100% 0%",
      opacity: 0
    }
  });
  const slideMotion = {
    "slide-up": {
      inKeyframes: slideUpIn,
      outKeyframes: slideUpOut
    },
    "slide-down": {
      inKeyframes: slideDownIn,
      outKeyframes: slideDownOut
    },
    "slide-left": {
      inKeyframes: slideLeftIn,
      outKeyframes: slideLeftOut
    },
    "slide-right": {
      inKeyframes: slideRightIn,
      outKeyframes: slideRightOut
    }
  };
  const initSlideMotion = (token2, motionName) => {
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-${motionName}`;
    const {
      inKeyframes,
      outKeyframes
    } = slideMotion[motionName];
    return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
      [`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
        transform: "scale(0)",
        transformOrigin: "0% 0%",
        opacity: 0,
        animationTimingFunction: token2.motionEaseOutQuint,
        "&-prepare": {
          transform: "scale(1)"
        }
      },
      [`${motionCls}-leave`]: {
        animationTimingFunction: token2.motionEaseInQuint
      }
    }];
  };
  const genNoMotionStyle = () => {
    return {
      "@media (prefers-reduced-motion: reduce)": {
        transition: "none",
        animation: "none"
      }
    };
  };
  const zoomIn = new Keyframe("antZoomIn", {
    "0%": {
      transform: "scale(0.2)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      opacity: 1
    }
  });
  const zoomOut = new Keyframe("antZoomOut", {
    "0%": {
      transform: "scale(1)"
    },
    "100%": {
      transform: "scale(0.2)",
      opacity: 0
    }
  });
  const zoomBigIn = new Keyframe("antZoomBigIn", {
    "0%": {
      transform: "scale(0.8)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      opacity: 1
    }
  });
  const zoomBigOut = new Keyframe("antZoomBigOut", {
    "0%": {
      transform: "scale(1)"
    },
    "100%": {
      transform: "scale(0.8)",
      opacity: 0
    }
  });
  const zoomUpIn = new Keyframe("antZoomUpIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 0%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "50% 0%"
    }
  });
  const zoomUpOut = new Keyframe("antZoomUpOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "50% 0%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 0%",
      opacity: 0
    }
  });
  const zoomLeftIn = new Keyframe("antZoomLeftIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "0% 50%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "0% 50%"
    }
  });
  const zoomLeftOut = new Keyframe("antZoomLeftOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "0% 50%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "0% 50%",
      opacity: 0
    }
  });
  const zoomRightIn = new Keyframe("antZoomRightIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "100% 50%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "100% 50%"
    }
  });
  const zoomRightOut = new Keyframe("antZoomRightOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "100% 50%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "100% 50%",
      opacity: 0
    }
  });
  const zoomDownIn = new Keyframe("antZoomDownIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 100%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "50% 100%"
    }
  });
  const zoomDownOut = new Keyframe("antZoomDownOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "50% 100%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 100%",
      opacity: 0
    }
  });
  const zoomMotion = {
    zoom: {
      inKeyframes: zoomIn,
      outKeyframes: zoomOut
    },
    "zoom-big": {
      inKeyframes: zoomBigIn,
      outKeyframes: zoomBigOut
    },
    "zoom-big-fast": {
      inKeyframes: zoomBigIn,
      outKeyframes: zoomBigOut
    },
    "zoom-left": {
      inKeyframes: zoomLeftIn,
      outKeyframes: zoomLeftOut
    },
    "zoom-right": {
      inKeyframes: zoomRightIn,
      outKeyframes: zoomRightOut
    },
    "zoom-up": {
      inKeyframes: zoomUpIn,
      outKeyframes: zoomUpOut
    },
    "zoom-down": {
      inKeyframes: zoomDownIn,
      outKeyframes: zoomDownOut
    }
  };
  const initZoomMotion = (token2, motionName) => {
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-${motionName}`;
    const {
      inKeyframes,
      outKeyframes
    } = zoomMotion[motionName];
    return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid), {
      [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
        transform: "scale(0)",
        opacity: 0,
        animationTimingFunction: token2.motionEaseOutCirc,
        "&-prepare": {
          transform: "none"
        }
      },
      [`${motionCls}-leave`]: {
        animationTimingFunction: token2.motionEaseInOutCirc
      }
    }];
  };
  const genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
[`> span, > ${buttonTypeCls}`]: {
      "&:not(:last-child)": {
        [`&, & > ${buttonTypeCls}`]: {
          "&:not(:disabled)": {
            borderInlineEndColor: borderColor
          }
        }
      },
      "&:not(:first-child)": {
        [`&, & > ${buttonTypeCls}`]: {
          "&:not(:disabled)": {
            borderInlineStartColor: borderColor
          }
        }
      }
    }
  });
  const genGroupStyle$3 = (token2) => {
    const {
      componentCls,
      fontSize,
      lineWidth,
      groupBorderColor,
      colorErrorHover
    } = token2;
    return {
      [`${componentCls}-group`]: [
        {
          position: "relative",
          display: "inline-flex",
[`> span, > ${componentCls}`]: {
            "&:not(:last-child)": {
              [`&, & > ${componentCls}`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
              }
            },
            "&:not(:first-child)": {
              marginInlineStart: token2.calc(lineWidth).mul(-1).equal(),
              [`&, & > ${componentCls}`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0
              }
            }
          },
          [componentCls]: {
            position: "relative",
            zIndex: 1,
            "&:hover, &:focus, &:active": {
              zIndex: 2
            },
            "&[disabled]": {
              zIndex: 0
            }
          },
          [`${componentCls}-icon-only`]: {
            fontSize
          }
        },
genButtonBorderStyle(`${componentCls}-primary`, groupBorderColor),
        genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
      ]
    };
  };
  const getRoundNumber$1 = (value) => Math.round(Number(value || 0));
  const convertHsb2Hsv = (color2) => {
    if (color2 instanceof FastColor) {
      return color2;
    }
    if (color2 && typeof color2 === "object" && "h" in color2 && "b" in color2) {
      const {
        b,
        ...resets
      } = color2;
      return {
        ...resets,
        v: b
      };
    }
    if (typeof color2 === "string" && /hsb/.test(color2)) {
      return color2.replace(/hsb/, "hsv");
    }
    return color2;
  };
  class Color extends FastColor {
    constructor(color2) {
      super(convertHsb2Hsv(color2));
    }
    toHsbString() {
      const hsb = this.toHsb();
      const saturation = getRoundNumber$1(hsb.s * 100);
      const lightness = getRoundNumber$1(hsb.b * 100);
      const hue = getRoundNumber$1(hsb.h);
      const alpha2 = hsb.a;
      const hsbString = `hsb(${hue}, ${saturation}%, ${lightness}%)`;
      const hsbaString = `hsba(${hue}, ${saturation}%, ${lightness}%, ${alpha2.toFixed(alpha2 === 0 ? 0 : 2)})`;
      return alpha2 === 1 ? hsbString : hsbaString;
    }
    toHsb() {
      const {
        v,
        ...resets
      } = this.toHsv();
      return {
        ...resets,
        b: v,
        a: this.a
      };
    }
  }
  const ColorPickerPrefixCls = "rc-color-picker";
  const generateColor$1 = (color2) => {
    if (color2 instanceof Color) {
      return color2;
    }
    return new Color(color2);
  };
  const defaultColor = generateColor$1("#1677ff");
  const calculateColor = (props) => {
    const {
      offset: offset2,
      targetRef,
      containerRef,
      color: color2,
      type: type4
    } = props;
    const {
      width,
      height
    } = containerRef.current.getBoundingClientRect();
    const {
      width: targetWidth,
      height: targetHeight
    } = targetRef.current.getBoundingClientRect();
    const centerOffsetX = targetWidth / 2;
    const centerOffsetY = targetHeight / 2;
    const saturation = (offset2.x + centerOffsetX) / width;
    const bright = 1 - (offset2.y + centerOffsetY) / height;
    const hsb = color2.toHsb();
    const alphaOffset = saturation;
    const hueOffset = (offset2.x + centerOffsetX) / width * 360;
    if (type4) {
      switch (type4) {
        case "hue":
          return generateColor$1({
            ...hsb,
            h: hueOffset <= 0 ? 0 : hueOffset
          });
        case "alpha":
          return generateColor$1({
            ...hsb,
            a: alphaOffset <= 0 ? 0 : alphaOffset
          });
      }
    }
    return generateColor$1({
      h: hsb.h,
      s: saturation <= 0 ? 0 : saturation,
      b: bright >= 1 ? 1 : bright,
      a: hsb.a
    });
  };
  const calcOffset = (color2, type4) => {
    const hsb = color2.toHsb();
    switch (type4) {
      case "hue":
        return {
          x: hsb.h / 360 * 100,
          y: 50
        };
      case "alpha":
        return {
          x: color2.a * 100,
          y: 50
        };
default:
        return {
          x: hsb.s * 100,
          y: (1 - hsb.b) * 100
        };
    }
  };
  const ColorBlock = ({
    color: color2,
    prefixCls,
    className,
    style: style2,
    innerClassName,
    innerStyle,
    onClick
  }) => {
    const colorBlockCls = `${prefixCls}-color-block`;
    return React.createElement("div", {
      className: clsx(colorBlockCls, className),
      style: style2,
      onClick
    }, React.createElement("div", {
      className: clsx(`${colorBlockCls}-inner`, innerClassName),
      style: {
        background: color2,
        ...innerStyle
      }
    }));
  };
  function getPosition$1(e) {
    const obj = "touches" in e ? e.touches[0] : e;
    const scrollXOffset = document.documentElement.scrollLeft || document.body.scrollLeft || window.pageXOffset;
    const scrollYOffset = document.documentElement.scrollTop || document.body.scrollTop || window.pageYOffset;
    return {
      pageX: obj.pageX - scrollXOffset,
      pageY: obj.pageY - scrollYOffset
    };
  }
  function useColorDrag(props) {
    const {
      targetRef,
      containerRef,
      direction,
      onDragChange,
      onDragChangeComplete,
      calculate,
      color: color2,
      disabledDrag
    } = props;
    const [offsetValue, setOffsetValue] = reactExports.useState({
      x: 0,
      y: 0
    });
    const mouseMoveRef = reactExports.useRef(null);
    const mouseUpRef = reactExports.useRef(null);
    reactExports.useEffect(() => {
      setOffsetValue(calculate());
    }, [color2]);
    reactExports.useEffect(() => () => {
      document.removeEventListener("mousemove", mouseMoveRef.current);
      document.removeEventListener("mouseup", mouseUpRef.current);
      document.removeEventListener("touchmove", mouseMoveRef.current);
      document.removeEventListener("touchend", mouseUpRef.current);
      mouseMoveRef.current = null;
      mouseUpRef.current = null;
    }, []);
    const updateOffset = (e) => {
      const {
        pageX,
        pageY
      } = getPosition$1(e);
      const {
        x: rectX,
        y: rectY,
        width,
        height
      } = containerRef.current.getBoundingClientRect();
      const {
        width: targetWidth,
        height: targetHeight
      } = targetRef.current.getBoundingClientRect();
      const centerOffsetX = targetWidth / 2;
      const centerOffsetY = targetHeight / 2;
      const offsetX = Math.max(0, Math.min(pageX - rectX, width)) - centerOffsetX;
      const offsetY = Math.max(0, Math.min(pageY - rectY, height)) - centerOffsetY;
      const calcOffset2 = {
        x: offsetX,
        y: direction === "x" ? offsetValue.y : offsetY
      };
      if (targetWidth === 0 && targetHeight === 0 || targetWidth !== targetHeight) {
        return false;
      }
      onDragChange?.(calcOffset2);
    };
    const onDragMove = (e) => {
      e.preventDefault();
      updateOffset(e);
    };
    const onDragStop = (e) => {
      e.preventDefault();
      document.removeEventListener("mousemove", mouseMoveRef.current);
      document.removeEventListener("mouseup", mouseUpRef.current);
      document.removeEventListener("touchmove", mouseMoveRef.current);
      document.removeEventListener("touchend", mouseUpRef.current);
      mouseMoveRef.current = null;
      mouseUpRef.current = null;
      onDragChangeComplete?.();
    };
    const onDragStart = (e) => {
      document.removeEventListener("mousemove", mouseMoveRef.current);
      document.removeEventListener("mouseup", mouseUpRef.current);
      if (disabledDrag) {
        return;
      }
      updateOffset(e);
      document.addEventListener("mousemove", onDragMove);
      document.addEventListener("mouseup", onDragStop);
      document.addEventListener("touchmove", onDragMove);
      document.addEventListener("touchend", onDragStop);
      mouseMoveRef.current = onDragMove;
      mouseUpRef.current = onDragStop;
    };
    return [offsetValue, onDragStart];
  }
  const Handler = ({
    size = "default",
    color: color2,
    prefixCls
  }) => {
    return React.createElement("div", {
      className: clsx(`${prefixCls}-handler`, {
        [`${prefixCls}-handler-sm`]: size === "small"
      }),
      style: {
        backgroundColor: color2
      }
    });
  };
  const Palette = ({
    children,
    style: style2,
    prefixCls
  }) => {
    return React.createElement("div", {
      className: `${prefixCls}-palette`,
      style: {
        position: "relative",
        ...style2
      }
    }, children);
  };
  const Transform = reactExports.forwardRef((props, ref2) => {
    const {
      children,
      x,
      y
    } = props;
    return React.createElement("div", {
      ref: ref2,
      style: {
        position: "absolute",
        left: `${x}%`,
        top: `${y}%`,
        zIndex: 1,
        transform: "translate(-50%, -50%)"
      }
    }, children);
  });
  const Picker = ({
    color: color2,
    onChange,
    prefixCls,
    onChangeComplete,
    disabled
  }) => {
    const pickerRef = reactExports.useRef();
    const transformRef = reactExports.useRef();
    const colorRef = reactExports.useRef(color2);
    const onDragChange = useEvent$1((offsetValue) => {
      const calcColor = calculateColor({
        offset: offsetValue,
        targetRef: transformRef,
        containerRef: pickerRef,
        color: color2
      });
      colorRef.current = calcColor;
      onChange(calcColor);
    });
    const [offset2, dragStartHandle] = useColorDrag({
      color: color2,
      containerRef: pickerRef,
      targetRef: transformRef,
      calculate: () => calcOffset(color2),
      onDragChange,
      onDragChangeComplete: () => onChangeComplete?.(colorRef.current),
      disabledDrag: disabled
    });
    return React.createElement("div", {
      ref: pickerRef,
      className: `${prefixCls}-select`,
      onMouseDown: dragStartHandle,
      onTouchStart: dragStartHandle
    }, React.createElement(Palette, {
      prefixCls
    }, React.createElement(Transform, {
      x: offset2.x,
      y: offset2.y,
      ref: transformRef
    }, React.createElement(Handler, {
      color: color2.toRgbString(),
      prefixCls
    })), React.createElement("div", {
      className: `${prefixCls}-saturation`,
      style: {
        backgroundColor: `hsl(${color2.toHsb().h},100%, 50%)`,
        backgroundImage: "linear-gradient(0deg, #000, transparent),linear-gradient(90deg, #fff, hsla(0, 0%, 100%, 0))"
      }
    })));
  };
  const useColorState = (defaultValue2, value) => {
    const [mergedValue, setValue] = useControlledState(defaultValue2, value);
    const color2 = reactExports.useMemo(() => generateColor$1(mergedValue), [mergedValue]);
    return [color2, setValue];
  };
  const Gradient = ({
    colors: colors2,
    children,
    direction = "to right",
    type: type4,
    prefixCls
  }) => {
    const gradientColors = reactExports.useMemo(() => colors2.map((color2, idx) => {
      let result = generateColor$1(color2);
      if (type4 === "alpha" && idx === colors2.length - 1) {
        result = new Color(result.setA(1));
      }
      return result.toRgbString();
    }).join(","), [colors2, type4]);
    return React.createElement("div", {
      className: `${prefixCls}-gradient`,
      style: {
        position: "absolute",
        inset: 0,
        background: `linear-gradient(${direction}, ${gradientColors})`
      }
    }, children);
  };
  const Slider$2 = (props) => {
    const {
      prefixCls,
      colors: colors2,
      disabled,
      onChange,
      onChangeComplete,
      color: color2,
      type: type4
    } = props;
    const sliderRef = reactExports.useRef(null);
    const transformRef = reactExports.useRef(null);
    const colorRef = reactExports.useRef(color2);
    const getValue2 = (c2) => {
      return type4 === "hue" ? c2.getHue() : c2.a * 100;
    };
    const onDragChange = useEvent$1((offsetValue) => {
      const calcColor = calculateColor({
        offset: offsetValue,
        targetRef: transformRef,
        containerRef: sliderRef,
        color: color2,
        type: type4
      });
      colorRef.current = calcColor;
      onChange(getValue2(calcColor));
    });
    const [offset2, dragStartHandle] = useColorDrag({
      color: color2,
      targetRef: transformRef,
      containerRef: sliderRef,
      calculate: () => calcOffset(color2, type4),
      onDragChange,
      onDragChangeComplete() {
        onChangeComplete(getValue2(colorRef.current));
      },
      direction: "x",
      disabledDrag: disabled
    });
    const handleColor = React.useMemo(() => {
      if (type4 === "hue") {
        const hsb = color2.toHsb();
        hsb.s = 1;
        hsb.b = 1;
        hsb.a = 1;
        const lightColor = new Color(hsb);
        return lightColor;
      }
      return color2;
    }, [color2, type4]);
    const gradientList = React.useMemo(() => colors2.map((info) => `${info.color} ${info.percent}%`), [colors2]);
    return React.createElement("div", {
      ref: sliderRef,
      className: clsx(`${prefixCls}-slider`, `${prefixCls}-slider-${type4}`),
      onMouseDown: dragStartHandle,
      onTouchStart: dragStartHandle
    }, React.createElement(Palette, {
      prefixCls
    }, React.createElement(Transform, {
      x: offset2.x,
      y: offset2.y,
      ref: transformRef
    }, React.createElement(Handler, {
      size: "small",
      color: handleColor.toHexString(),
      prefixCls
    })), React.createElement(Gradient, {
      colors: gradientList,
      type: type4,
      prefixCls
    })));
  };
  function useComponent(components2) {
    return reactExports.useMemo(() => {
      const {
        slider
      } = components2 || {};
      return [slider || Slider$2];
    }, [components2]);
  }
  function _extends$S() {
    _extends$S = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$S.apply(this, arguments);
  }
  const HUE_COLORS = [{
    color: "rgb(255, 0, 0)",
    percent: 0
  }, {
    color: "rgb(255, 255, 0)",
    percent: 17
  }, {
    color: "rgb(0, 255, 0)",
    percent: 33
  }, {
    color: "rgb(0, 255, 255)",
    percent: 50
  }, {
    color: "rgb(0, 0, 255)",
    percent: 67
  }, {
    color: "rgb(255, 0, 255)",
    percent: 83
  }, {
    color: "rgb(255, 0, 0)",
    percent: 100
  }];
  const ColorPicker$1 = reactExports.forwardRef((props, ref2) => {
    const {
      value,
      defaultValue: defaultValue2,
      prefixCls = ColorPickerPrefixCls,
      onChange,
      onChangeComplete,
      className,
      style: style2,
      panelRender,
      disabledAlpha = false,
      disabled = false,
      components: components2
    } = props;
    const [Slider2] = useComponent(components2);
    const [colorValue, setColorValue] = useColorState(defaultValue2 || defaultColor, value);
    const alphaColor = reactExports.useMemo(() => colorValue.setA(1).toRgbString(), [colorValue]);
    const handleChange = (data2, type4) => {
      if (!value) {
        setColorValue(data2);
      }
      onChange?.(data2, type4);
    };
    const getHueColor = (hue) => new Color(colorValue.setHue(hue));
    const getAlphaColor2 = (alpha2) => new Color(colorValue.setA(alpha2 / 100));
    const onHueChange = (hue) => {
      handleChange(getHueColor(hue), {
        type: "hue",
        value: hue
      });
    };
    const onAlphaChange = (alpha2) => {
      handleChange(getAlphaColor2(alpha2), {
        type: "alpha",
        value: alpha2
      });
    };
    const onHueChangeComplete = (hue) => {
      if (onChangeComplete) {
        onChangeComplete(getHueColor(hue));
      }
    };
    const onAlphaChangeComplete = (alpha2) => {
      if (onChangeComplete) {
        onChangeComplete(getAlphaColor2(alpha2));
      }
    };
    const mergeCls = clsx(`${prefixCls}-panel`, className, {
      [`${prefixCls}-panel-disabled`]: disabled
    });
    const sharedSliderProps = {
      prefixCls,
      disabled,
      color: colorValue
    };
    const defaultPanel = React.createElement(React.Fragment, null, React.createElement(Picker, _extends$S({
      onChange: handleChange
    }, sharedSliderProps, {
      onChangeComplete
    })), React.createElement("div", {
      className: `${prefixCls}-slider-container`
    }, React.createElement("div", {
      className: clsx(`${prefixCls}-slider-group`, {
        [`${prefixCls}-slider-group-disabled-alpha`]: disabledAlpha
      })
    }, React.createElement(Slider2, _extends$S({}, sharedSliderProps, {
      type: "hue",
      colors: HUE_COLORS,
      min: 0,
      max: 359,
      value: colorValue.getHue(),
      onChange: onHueChange,
      onChangeComplete: onHueChangeComplete
    })), !disabledAlpha && React.createElement(Slider2, _extends$S({}, sharedSliderProps, {
      type: "alpha",
      colors: [{
        percent: 0,
        color: "rgba(255, 0, 4, 0)"
      }, {
        percent: 100,
        color: alphaColor
      }],
      min: 0,
      max: 100,
      value: colorValue.a * 100,
      onChange: onAlphaChange,
      onChangeComplete: onAlphaChangeComplete
    }))), React.createElement(ColorBlock, {
      color: colorValue.toRgbString(),
      prefixCls
    })));
    return React.createElement("div", {
      className: mergeCls,
      style: style2,
      ref: ref2
    }, typeof panelRender === "function" ? panelRender(defaultPanel) : defaultPanel);
  });
  const toHexFormat = (value, alpha2) => value?.replace(/[^0-9a-f]/gi, "").slice(0, alpha2 ? 8 : 6) || "";
  const getHex = (value, alpha2) => value ? toHexFormat(value, alpha2) : "";
  let AggregationColor = (function() {
    function AggregationColor2(color2) {
      _classCallCheck(this, AggregationColor2);
      this.cleared = false;
      if (color2 instanceof AggregationColor2) {
        this.metaColor = color2.metaColor.clone();
        this.colors = color2.colors?.map((info) => ({
          color: new AggregationColor2(info.color),
          percent: info.percent
        }));
        this.cleared = color2.cleared;
        return;
      }
      const isArray = Array.isArray(color2);
      if (isArray && color2.length) {
        this.colors = color2.map(({
          color: c2,
          percent: percent2
        }) => ({
          color: new AggregationColor2(c2),
          percent: percent2
        }));
        this.metaColor = new Color(this.colors[0].color.metaColor);
      } else {
        this.metaColor = new Color(isArray ? "" : color2);
      }
      if (!color2 || isArray && !this.colors) {
        this.metaColor = this.metaColor.setA(0);
        this.cleared = true;
      }
    }
    return _createClass(AggregationColor2, [{
      key: "toHsb",
      value: function toHsb() {
        return this.metaColor.toHsb();
      }
    }, {
      key: "toHsbString",
      value: function toHsbString() {
        return this.metaColor.toHsbString();
      }
    }, {
      key: "toHex",
      value: function toHex() {
        return getHex(this.toHexString(), this.metaColor.a < 1);
      }
    }, {
      key: "toHexString",
      value: function toHexString() {
        return this.metaColor.toHexString();
      }
    }, {
      key: "toRgb",
      value: function toRgb() {
        return this.metaColor.toRgb();
      }
    }, {
      key: "toRgbString",
      value: function toRgbString() {
        return this.metaColor.toRgbString();
      }
    }, {
      key: "isGradient",
      value: function isGradient() {
        return !!this.colors && !this.cleared;
      }
    }, {
      key: "getColors",
      value: function getColors() {
        return this.colors || [{
          color: this,
          percent: 0
        }];
      }
    }, {
      key: "toCssString",
      value: function toCssString() {
        const {
          colors: colors2
        } = this;
        if (colors2) {
          const colorsStr = colors2.map((c2) => `${c2.color.toRgbString()} ${c2.percent}%`).join(", ");
          return `linear-gradient(90deg, ${colorsStr})`;
        }
        return this.metaColor.toRgbString();
      }
    }, {
      key: "equals",
      value: function equals(color2) {
        if (!color2 || this.isGradient() !== color2.isGradient()) {
          return false;
        }
        if (!this.isGradient()) {
          return this.toHexString() === color2.toHexString();
        }
        return this.colors.length === color2.colors.length && this.colors.every((c2, i2) => {
          const target = color2.colors[i2];
          return c2.percent === target.percent && c2.color.equals(target.color);
        });
      }
    }]);
  })();
  var RightOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, "name": "right", "theme": "outlined" };
  function _extends$R() {
    _extends$R = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$R.apply(this, arguments);
  }
  const RightOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends$R({}, props, {
    ref: ref2,
    icon: RightOutlined$1
  }));
  const RefIcon$g = reactExports.forwardRef(RightOutlined);
  const PanelContent = React.forwardRef((props, ref2) => {
    const {
      prefixCls,
      forceRender,
      className,
      style: style2,
      children,
      isActive: isActive2,
      role,
      classNames: customizeClassNames,
      styles
    } = props;
    const [rendered, setRendered] = React.useState(isActive2 || forceRender);
    React.useEffect(() => {
      if (forceRender || isActive2) {
        setRendered(true);
      }
    }, [forceRender, isActive2]);
    if (!rendered) {
      return null;
    }
    return React.createElement("div", {
      ref: ref2,
      className: clsx(`${prefixCls}-panel`, {
        [`${prefixCls}-panel-active`]: isActive2,
        [`${prefixCls}-panel-inactive`]: !isActive2
      }, className),
      style: style2,
      role
    }, React.createElement("div", {
      className: clsx(`${prefixCls}-body`, customizeClassNames?.body),
      style: styles?.body
    }, children));
  });
  const CollapsePanel$2 = React.forwardRef((props, ref2) => {
    const {
      showArrow = true,
      headerClass,
      isActive: isActive2,
      onItemClick,
      forceRender,
      className,
      classNames: customizeClassNames = {},
      styles = {},
      prefixCls,
      collapsible,
      accordion,
      panelKey,
      extra,
      header,
      expandIcon,
      openMotion,
      destroyOnHidden,
      children,
      ...resetProps
    } = props;
    const disabled = collapsible === "disabled";
    const ifExtraExist = extra !== null && extra !== void 0 && typeof extra !== "boolean";
    const collapsibleProps = {
      onClick: () => {
        onItemClick?.(panelKey);
      },
      onKeyDown: (e) => {
        if (e.key === "Enter" || e.keyCode === KeyCode.ENTER || e.which === KeyCode.ENTER) {
          onItemClick?.(panelKey);
        }
      },
      role: accordion ? "tab" : "button",
      ["aria-expanded"]: isActive2,
      ["aria-disabled"]: disabled,
      tabIndex: disabled ? -1 : 0
    };
    const iconNodeInner = typeof expandIcon === "function" ? expandIcon(props) : React.createElement("i", {
      className: "arrow"
    });
    const iconNode = iconNodeInner && React.createElement("div", _extends$15({
      className: clsx(`${prefixCls}-expand-icon`, customizeClassNames?.icon),
      style: styles?.icon
    }, ["header", "icon"].includes(collapsible) ? collapsibleProps : {}), iconNodeInner);
    const collapsePanelClassNames = clsx(`${prefixCls}-item`, {
      [`${prefixCls}-item-active`]: isActive2,
      [`${prefixCls}-item-disabled`]: disabled
    }, className);
    const headerClassName = clsx(headerClass, `${prefixCls}-header`, {
      [`${prefixCls}-collapsible-${collapsible}`]: !!collapsible
    }, customizeClassNames?.header);
    const headerProps = {
      className: headerClassName,
      style: styles?.header,
      ...["header", "icon"].includes(collapsible) ? {} : collapsibleProps
    };
    return React.createElement("div", _extends$15({}, resetProps, {
      ref: ref2,
      className: collapsePanelClassNames
    }), React.createElement("div", headerProps, showArrow && iconNode, React.createElement("span", _extends$15({
      className: clsx(`${prefixCls}-title`, customizeClassNames?.title),
      style: styles?.title
    }, collapsible === "header" ? collapsibleProps : {}), header), ifExtraExist && React.createElement("div", {
      className: `${prefixCls}-extra`
    }, extra)), React.createElement(CSSMotion, _extends$15({
      visible: isActive2,
      leavedClassName: `${prefixCls}-panel-hidden`
    }, openMotion, {
      forceRender,
      removeOnLeave: destroyOnHidden
    }), ({
      className: motionClassName,
      style: motionStyle
    }, motionRef) => {
      return React.createElement(PanelContent, {
        ref: motionRef,
        prefixCls,
        className: motionClassName,
        classNames: customizeClassNames,
        style: motionStyle,
        styles,
        isActive: isActive2,
        forceRender,
        role: accordion ? "tabpanel" : void 0
      }, children);
    }));
  });
  function mergeSemantic(src, tgt, mergeFn) {
    if (!src || !tgt) {
      return src || tgt;
    }
    const keys2 = Array.from( new Set([...Object.keys(src), ...Object.keys(tgt)]));
    const result = {};
    keys2.forEach((key) => {
      result[key] = mergeFn(src[key], tgt[key]);
    });
    return result;
  }
  function mergeSemanticClassNames(src, tgt) {
    return mergeSemantic(src, tgt, (a2, b) => clsx(a2, b));
  }
  function mergeSemanticStyles(src, tgt) {
    return mergeSemantic(src, tgt, (a2, b) => ({
      ...a2,
      ...b
    }));
  }
  const convertItemsToNodes$1 = (items, props) => {
    const {
      prefixCls,
      accordion,
      collapsible,
      destroyOnHidden,
      onItemClick,
      activeKey,
      openMotion,
      expandIcon,
      classNames: collapseClassNames,
      styles: collapseStyles
    } = props;
    return items.map((item, index) => {
      const {
        children,
        label,
        key: rawKey,
        collapsible: rawCollapsible,
        onItemClick: rawOnItemClick,
        destroyOnHidden: rawDestroyOnHidden,
        classNames,
        styles,
        ...restProps
      } = item;
      const key = String(rawKey ?? index);
      const mergeCollapsible = rawCollapsible ?? collapsible;
      const mergedDestroyOnHidden = rawDestroyOnHidden ?? destroyOnHidden;
      const handleItemClick = (value) => {
        if (mergeCollapsible === "disabled") {
          return;
        }
        onItemClick(value);
        rawOnItemClick?.(value);
      };
      let isActive2 = false;
      if (accordion) {
        isActive2 = activeKey[0] === key;
      } else {
        isActive2 = activeKey.indexOf(key) > -1;
      }
      return React.createElement(CollapsePanel$2, _extends$15({}, restProps, {
        classNames: mergeSemanticClassNames(collapseClassNames, classNames),
        styles: mergeSemanticStyles(collapseStyles, styles),
        prefixCls,
        key,
        panelKey: key,
        isActive: isActive2,
        accordion,
        openMotion,
        expandIcon,
        header: label,
        collapsible: mergeCollapsible,
        onItemClick: handleItemClick,
        destroyOnHidden: mergedDestroyOnHidden
      }), children);
    });
  };
  const getNewChild = (child, index, props) => {
    if (!child) {
      return null;
    }
    const {
      prefixCls,
      accordion,
      collapsible,
      destroyOnHidden,
      onItemClick,
      activeKey,
      openMotion,
      expandIcon,
      classNames: collapseClassNames,
      styles
    } = props;
    const key = child.key || String(index);
    const {
      header,
      headerClass,
      destroyOnHidden: childDestroyOnHidden,
      collapsible: childCollapsible,
      onItemClick: childOnItemClick
    } = child.props;
    let isActive2 = false;
    if (accordion) {
      isActive2 = activeKey[0] === key;
    } else {
      isActive2 = activeKey.indexOf(key) > -1;
    }
    const mergeCollapsible = childCollapsible ?? collapsible;
    const handleItemClick = (value) => {
      if (mergeCollapsible === "disabled") {
        return;
      }
      onItemClick(value);
      childOnItemClick?.(value);
    };
    const childProps = {
      key,
      panelKey: key,
      header,
      headerClass,
      classNames: collapseClassNames,
      styles,
      isActive: isActive2,
      prefixCls,
      destroyOnHidden: childDestroyOnHidden ?? destroyOnHidden,
      openMotion,
      accordion,
      children: child.props.children,
      onItemClick: handleItemClick,
      expandIcon,
      collapsible: mergeCollapsible
    };
    if (typeof child.type === "string") {
      return child;
    }
    Object.keys(childProps).forEach((propName) => {
      if (typeof childProps[propName] === "undefined") {
        delete childProps[propName];
      }
    });
    return React.cloneElement(child, childProps);
  };
  function useItems(items, rawChildren, props) {
    if (Array.isArray(items)) {
      return convertItemsToNodes$1(items, props);
    }
    return toArray$4(rawChildren).map((child, index) => getNewChild(child, index, props));
  }
  function getActiveKeysArray(activeKey) {
    let currentActiveKey = activeKey;
    if (!Array.isArray(currentActiveKey)) {
      const activeKeyType = typeof currentActiveKey;
      currentActiveKey = activeKeyType === "number" || activeKeyType === "string" ? [currentActiveKey] : [];
    }
    return currentActiveKey.map((key) => String(key));
  }
  const Collapse$2 = React.forwardRef((props, ref2) => {
    const {
      prefixCls = "rc-collapse",
      destroyOnHidden = false,
      style: style2,
      accordion,
      className,
      children,
      collapsible,
      openMotion,
      expandIcon,
      activeKey: rawActiveKey,
      defaultActiveKey,
      onChange,
      items,
      classNames: customizeClassNames,
      styles
    } = props;
    const collapseClassName = clsx(prefixCls, className);
    const [internalActiveKey, setActiveKey] = useControlledState(defaultActiveKey, rawActiveKey);
    const activeKey = getActiveKeysArray(internalActiveKey);
    const triggerActiveKey = useEvent$1((next2) => {
      const nextKeys = getActiveKeysArray(next2);
      setActiveKey(nextKeys);
      onChange?.(nextKeys);
    });
    const onItemClick = (key) => {
      if (accordion) {
        triggerActiveKey(activeKey[0] === key ? [] : [key]);
      } else {
        triggerActiveKey(activeKey.includes(key) ? activeKey.filter((item) => item !== key) : [...activeKey, key]);
      }
    };
    warningOnce(!children, "[rc-collapse] `children` will be removed in next major version. Please use `items` instead.");
    const mergedChildren = useItems(items, children, {
      prefixCls,
      accordion,
      openMotion,
      expandIcon,
      collapsible,
      destroyOnHidden,
      onItemClick,
      activeKey,
      classNames: customizeClassNames,
      styles
    });
    return React.createElement("div", _extends$15({
      ref: ref2,
      className: collapseClassName,
      style: style2,
      role: accordion ? "tablist" : void 0
    }, pickAttrs(props, {
      aria: true,
      data: true
    })), mergedChildren);
  });
  const Collapse$3 = Object.assign(Collapse$2, {
Panel: CollapsePanel$2
  });
  const {
    Panel: Panel$1
  } = Collapse$3;
  const CollapsePanel$1 = reactExports.forwardRef((props, ref2) => {
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const {
      prefixCls: customizePrefixCls,
      className,
      showArrow = true
    } = props;
    const prefixCls = getPrefixCls("collapse", customizePrefixCls);
    const collapsePanelClassName = clsx({
      [`${prefixCls}-no-arrow`]: !showArrow
    }, className);
    return reactExports.createElement(Collapse$3.Panel, {
      ref: ref2,
      ...props,
      prefixCls,
      className: collapsePanelClassName
    });
  });
  const genBaseStyle$9 = (token2) => {
    const {
      componentCls,
      contentBg,
      padding,
      headerBg,
      headerPadding,
      collapseHeaderPaddingSM,
      collapseHeaderPaddingLG,
      collapsePanelBorderRadius,
      lineWidth,
      lineType,
      colorBorder,
      colorText,
      colorTextHeading,
      colorTextDisabled,
      fontSizeLG,
      lineHeight,
      lineHeightLG,
      marginSM,
      paddingSM,
      paddingLG,
      paddingXS,
      motionDurationSlow,
      fontSizeIcon,
      contentPadding,
      fontHeight,
      fontHeightLG
    } = token2;
    const borderBase = `${unit$1(lineWidth)} ${lineType} ${colorBorder}`;
    return {
      [componentCls]: {
        ...resetComponent(token2),
        backgroundColor: headerBg,
        border: borderBase,
        borderRadius: collapsePanelBorderRadius,
        "&-rtl": {
          direction: "rtl"
        },
        [`& > ${componentCls}-item`]: {
          borderBottom: borderBase,
          "&:first-child": {
            [`
            &,
            & > ${componentCls}-header`]: {
              borderRadius: `${unit$1(collapsePanelBorderRadius)} ${unit$1(collapsePanelBorderRadius)} 0 0`
            }
          },
          "&:last-child": {
            [`
            &,
            & > ${componentCls}-header`]: {
              borderRadius: `0 0 ${unit$1(collapsePanelBorderRadius)} ${unit$1(collapsePanelBorderRadius)}`
            }
          },
          [`> ${componentCls}-header`]: {
            position: "relative",
display: "flex",
            flexWrap: "nowrap",
            alignItems: "flex-start",
            padding: headerPadding,
            color: colorTextHeading,
            lineHeight,
            cursor: "pointer",
            transition: `all ${motionDurationSlow}, visibility 0s`,
            ...genFocusStyle(token2),
            [`> ${componentCls}-title`]: {
              flex: "auto"
            },
[`${componentCls}-expand-icon`]: {
              height: fontHeight,
              display: "flex",
              alignItems: "center",
              marginInlineEnd: marginSM
            },
            [`${componentCls}-arrow`]: {
              ...resetIcon(),
              fontSize: fontSizeIcon,
transition: `transform ${motionDurationSlow}`,
svg: {
                transition: `transform ${motionDurationSlow}`
              }
            },
[`${componentCls}-title`]: {
              marginInlineEnd: "auto"
            }
          },
          [`${componentCls}-collapsible-header`]: {
            cursor: "default",
            [`${componentCls}-title`]: {
              flex: "none",
              cursor: "pointer"
            },
            [`${componentCls}-expand-icon`]: {
              cursor: "pointer"
            }
          },
          [`${componentCls}-collapsible-icon`]: {
            cursor: "unset",
            [`${componentCls}-expand-icon`]: {
              cursor: "pointer"
            }
          }
        },
        [`${componentCls}-panel`]: {
          color: colorText,
          backgroundColor: contentBg,
          borderTop: borderBase,
          [`& > ${componentCls}-body`]: {
            padding: contentPadding
          },
          "&-hidden": {
            display: "none"
          }
        },
        "&-small": {
          [`> ${componentCls}-item`]: {
            [`> ${componentCls}-header`]: {
              padding: collapseHeaderPaddingSM,
              paddingInlineStart: paddingXS,
              [`> ${componentCls}-expand-icon`]: {
marginInlineStart: token2.calc(paddingSM).sub(paddingXS).equal()
              }
            },
            [`> ${componentCls}-panel > ${componentCls}-body`]: {
              padding: paddingSM
            }
          }
        },
        "&-large": {
          [`> ${componentCls}-item`]: {
            fontSize: fontSizeLG,
            lineHeight: lineHeightLG,
            [`> ${componentCls}-header`]: {
              padding: collapseHeaderPaddingLG,
              paddingInlineStart: padding,
              [`> ${componentCls}-expand-icon`]: {
                height: fontHeightLG,
marginInlineStart: token2.calc(paddingLG).sub(padding).equal()
              }
            },
            [`> ${componentCls}-panel > ${componentCls}-body`]: {
              padding: paddingLG
            }
          }
        },
        [`${componentCls}-item:last-child`]: {
          borderBottom: 0,
          [`> ${componentCls}-panel`]: {
            borderRadius: `0 0 ${unit$1(collapsePanelBorderRadius)} ${unit$1(collapsePanelBorderRadius)}`
          }
        },
        [`& ${componentCls}-item-disabled > ${componentCls}-header`]: {
          [`
          &,
          & > .arrow
        `]: {
            color: colorTextDisabled,
            cursor: "not-allowed"
          }
        },
[`&${componentCls}-icon-placement-end`]: {
          [`& > ${componentCls}-item`]: {
            [`> ${componentCls}-header`]: {
              [`${componentCls}-expand-icon`]: {
                order: 1,
                marginInlineEnd: 0,
                marginInlineStart: marginSM
              }
            }
          }
        }
      }
    };
  };
  const genArrowStyle = (token2) => {
    const {
      componentCls
    } = token2;
    const fixedSelector = `> ${componentCls}-item > ${componentCls}-header ${componentCls}-arrow`;
    return {
      [`${componentCls}-rtl`]: {
        [fixedSelector]: {
          transform: `rotate(180deg)`
        }
      }
    };
  };
  const genBorderlessStyle$1 = (token2) => {
    const {
      componentCls,
      headerBg,
      borderlessContentPadding,
      borderlessContentBg,
      colorBorder
    } = token2;
    return {
      [`${componentCls}-borderless`]: {
        backgroundColor: headerBg,
        border: 0,
        [`> ${componentCls}-item`]: {
          borderBottom: `1px solid ${colorBorder}`
        },
        [`
        > ${componentCls}-item:last-child,
        > ${componentCls}-item:last-child ${componentCls}-header
      `]: {
          borderRadius: 0
        },
        [`> ${componentCls}-item:last-child`]: {
          borderBottom: 0
        },
        [`> ${componentCls}-item > ${componentCls}-panel`]: {
          backgroundColor: borderlessContentBg,
          borderTop: 0
        },
        [`> ${componentCls}-item > ${componentCls}-panel > ${componentCls}-body`]: {
          padding: borderlessContentPadding
        }
      }
    };
  };
  const genGhostStyle = (token2) => {
    const {
      componentCls,
      paddingSM
    } = token2;
    return {
      [`${componentCls}-ghost`]: {
        backgroundColor: "transparent",
        border: 0,
        [`> ${componentCls}-item`]: {
          borderBottom: 0,
          [`> ${componentCls}-panel`]: {
            backgroundColor: "transparent",
            border: 0,
            [`> ${componentCls}-body`]: {
              paddingBlock: paddingSM
            }
          }
        }
      }
    };
  };
  const prepareComponentToken$r = (token2) => ({
    headerPadding: `${token2.paddingSM}px ${token2.padding}px`,
    headerBg: token2.colorFillAlter,
    contentPadding: `${token2.padding}px 16px`,
contentBg: token2.colorBgContainer,
    borderlessContentPadding: `${token2.paddingXXS}px 16px ${token2.padding}px`,
    borderlessContentBg: "transparent"
  });
  const useStyle$B = genStyleHooks("Collapse", (token2) => {
    const collapseToken = merge$1(token2, {
      collapseHeaderPaddingSM: `${unit$1(token2.paddingXS)} ${unit$1(token2.paddingSM)}`,
      collapseHeaderPaddingLG: `${unit$1(token2.padding)} ${unit$1(token2.paddingLG)}`,
      collapsePanelBorderRadius: token2.borderRadiusLG
    });
    return [genBaseStyle$9(collapseToken), genBorderlessStyle$1(collapseToken), genGhostStyle(collapseToken), genArrowStyle(collapseToken), genCollapseMotion(collapseToken)];
  }, prepareComponentToken$r);
  const Collapse = reactExports.forwardRef((props, ref2) => {
    const {
      getPrefixCls,
      direction,
      expandIcon: contextExpandIcon,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("collapse");
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style: style2,
      bordered = true,
      ghost,
      size: customizeSize,
      expandIconPlacement,
      expandIconPosition,
      children,
      destroyInactivePanel,
      destroyOnHidden,
      expandIcon,
      classNames,
      styles
    } = props;
    const mergedSize = useSize((ctx) => customizeSize ?? ctx ?? "middle");
    const prefixCls = getPrefixCls("collapse", customizePrefixCls);
    const rootPrefixCls = getPrefixCls();
    const [hashId, cssVarCls] = useStyle$B(prefixCls);
    const mergedPlacement = expandIconPlacement ?? expandIconPosition ?? "start";
    const mergedProps = {
      ...props,
      size: mergedSize,
      bordered,
      expandIconPlacement: mergedPlacement
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const mergedExpandIcon = expandIcon ?? contextExpandIcon;
    const renderExpandIcon = reactExports.useCallback((panelProps = {}) => {
      const icon = typeof mergedExpandIcon === "function" ? mergedExpandIcon(panelProps) : reactExports.createElement(RefIcon$g, {
        rotate: panelProps.isActive ? direction === "rtl" ? -90 : 90 : void 0,
        "aria-label": panelProps.isActive ? "expanded" : "collapsed"
      });
      return cloneElement(icon, (oriProps) => ({
        className: clsx(oriProps.className, `${prefixCls}-arrow`)
      }));
    }, [mergedExpandIcon, prefixCls, direction]);
    const collapseClassName = clsx(`${prefixCls}-icon-placement-${mergedPlacement}`, {
      [`${prefixCls}-borderless`]: !bordered,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-ghost`]: !!ghost,
      [`${prefixCls}-${mergedSize}`]: mergedSize !== "middle"
    }, contextClassName, className, rootClassName, hashId, cssVarCls, mergedClassNames.root);
    const openMotion = reactExports.useMemo(() => ({
      ...initCollapseMotion(rootPrefixCls),
      motionAppear: false,
      leavedClassName: `${prefixCls}-panel-hidden`
    }), [rootPrefixCls, prefixCls]);
    const items = reactExports.useMemo(() => {
      if (children) {
        return toArray$4(children).map((child) => child);
      }
      return null;
    }, [children]);
    return (

reactExports.createElement(Collapse$3, {
        ref: ref2,
        openMotion,
        ...omit(props, ["rootClassName"]),
        expandIcon: renderExpandIcon,
        prefixCls,
        className: collapseClassName,
        style: {
          ...mergedStyles.root,
          ...contextStyle,
          ...style2
        },
        classNames: mergedClassNames,
        styles: mergedStyles,
        destroyOnHidden: destroyOnHidden ?? destroyInactivePanel
      }, items)
    );
  });
  const Collapse$1 = Object.assign(Collapse, {
    Panel: CollapsePanel$1
  });
  const generateColor = (color2) => {
    if (color2 instanceof AggregationColor) {
      return color2;
    }
    return new AggregationColor(color2);
  };
  const getRoundNumber = (value) => Math.round(Number(value || 0));
  const getColorAlpha = (color2) => getRoundNumber(color2.toHsb().a * 100);
  const genAlphaColor = (color2, alpha2) => {
    const rgba2 = color2.toRgb();
    if (!rgba2.r && !rgba2.g && !rgba2.b) {
      const hsba = color2.toHsb();
      hsba.a = 1;
      return generateColor(hsba);
    }
    rgba2.a = 1;
    return generateColor(rgba2);
  };
  const getGradientPercentColor = (colors2, percent2) => {
    const filledColors = [{
      percent: 0,
      color: colors2[0].color
    }].concat(_toConsumableArray(colors2), [{
      percent: 100,
      color: colors2[colors2.length - 1].color
    }]);
    for (let i2 = 0; i2 < filledColors.length - 1; i2 += 1) {
      const startPtg = filledColors[i2].percent;
      const endPtg = filledColors[i2 + 1].percent;
      const startColor = filledColors[i2].color;
      const endColor = filledColors[i2 + 1].color;
      if (startPtg <= percent2 && percent2 <= endPtg) {
        const dist2 = endPtg - startPtg;
        if (dist2 === 0) {
          return startColor;
        }
        const ratio = (percent2 - startPtg) / dist2 * 100;
        const startRcColor = new Color(startColor);
        const endRcColor = new Color(endColor);
        return startRcColor.mix(endRcColor, ratio).toRgbString();
      }
    }
    return "";
  };
  const genPresetColor = (list2) => list2.map((value) => {
    value.colors = value.colors.map(generateColor);
    return value;
  });
  const isBright = (value, bgColorToken) => {
    const {
      r: r2,
      g: g2,
      b,
      a: a2
    } = value.toRgb();
    const hsv = new Color(value.toRgbString()).onBackground(bgColorToken).toHsv();
    if (a2 <= 0.5) {
      return hsv.v > 0.5;
    }
    return r2 * 0.299 + g2 * 0.587 + b * 0.114 > 192;
  };
  const genCollapsePanelKey = (preset, index) => {
    const mergedKey = preset.key ?? index;
    return `panel-${mergedKey}`;
  };
  const ColorPresets = ({
    prefixCls,
    presets,
    value: color2,
    onChange
  }) => {
    const [locale2] = useLocale("ColorPicker");
    const [, token2] = useToken$1();
    const presetsValue = reactExports.useMemo(() => genPresetColor(presets), [presets]);
    const colorPresetsPrefixCls = `${prefixCls}-presets`;
    const activeKeys = reactExports.useMemo(() => presetsValue.reduce((acc, preset, index) => {
      const {
        defaultOpen = true
      } = preset;
      if (defaultOpen) {
        acc.push(genCollapsePanelKey(preset, index));
      }
      return acc;
    }, []), [presetsValue]);
    const handleClick = (colorValue) => {
      onChange?.(colorValue);
    };
    const items = presetsValue.map((preset, index) => ({
      key: genCollapsePanelKey(preset, index),
      label: React.createElement("div", {
        className: `${colorPresetsPrefixCls}-label`
      }, preset?.label),
      children: React.createElement("div", {
        className: `${colorPresetsPrefixCls}-items`
      }, Array.isArray(preset?.colors) && preset.colors?.length > 0 ? preset.colors.map((presetColor, index2) => {
        const colorInst = generateColor(presetColor);
        return React.createElement(
          ColorBlock,
          {
key: `preset-${index2}-${presetColor.toHexString()}`,
            color: colorInst.toCssString(),
            prefixCls,
            className: clsx(`${colorPresetsPrefixCls}-color`, {
              [`${colorPresetsPrefixCls}-color-checked`]: presetColor.toCssString() === color2?.toCssString(),
              [`${colorPresetsPrefixCls}-color-bright`]: isBright(presetColor, token2.colorBgElevated)
            }),
            onClick: () => handleClick(presetColor)
          }
        );
      }) : React.createElement("span", {
        className: `${colorPresetsPrefixCls}-empty`
      }, locale2.presetEmpty))
    }));
    return React.createElement("div", {
      className: colorPresetsPrefixCls
    }, React.createElement(Collapse$1, {
      defaultActiveKey: activeKeys,
      ghost: true,
      items
    }));
  };
  const prepareToken$4 = (token2) => {
    const {
      paddingInline,
      onlyIconSize,
      borderColorDisabled
    } = token2;
    const buttonToken = merge$1(token2, {
      buttonPaddingHorizontal: paddingInline,
      buttonPaddingVertical: 0,
      buttonIconOnlyFontSize: onlyIconSize,
      colorBorderDisabled: borderColorDisabled
    });
    return buttonToken;
  };
  const prepareComponentToken$q = (token2) => {
    const contentFontSize = token2.contentFontSize ?? token2.fontSize;
    const contentFontSizeSM = token2.contentFontSizeSM ?? token2.fontSize;
    const contentFontSizeLG = token2.contentFontSizeLG ?? token2.fontSizeLG;
    const contentLineHeight = token2.contentLineHeight ?? getLineHeight(contentFontSize);
    const contentLineHeightSM = token2.contentLineHeightSM ?? getLineHeight(contentFontSizeSM);
    const contentLineHeightLG = token2.contentLineHeightLG ?? getLineHeight(contentFontSizeLG);
    const solidTextColor = isBright(new AggregationColor(token2.colorBgSolid), "#fff") ? "#000" : "#fff";
    const shadowColorTokens = PresetColors.reduce((prev2, colorKey) => ({
      ...prev2,
      [`${colorKey}ShadowColor`]: `0 ${unit$1(token2.controlOutlineWidth)} 0 ${getAlphaColor$1(token2[`${colorKey}1`], token2.colorBgContainer)}`
    }), {});
    const defaultBgDisabled = token2.colorBgContainerDisabled;
    const dashedBgDisabled = token2.colorBgContainerDisabled;
    return {
      ...shadowColorTokens,
      fontWeight: 400,
      iconGap: token2.marginXS,
      defaultShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`,
      primaryShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`,
      dangerShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`,
      primaryColor: token2.colorTextLightSolid,
      dangerColor: token2.colorTextLightSolid,
      borderColorDisabled: token2.colorBorderDisabled,
      defaultGhostColor: token2.colorBgContainer,
      ghostBg: "transparent",
      defaultGhostBorderColor: token2.colorBgContainer,
      paddingInline: token2.paddingContentHorizontal - token2.lineWidth,
      paddingInlineLG: token2.paddingContentHorizontal - token2.lineWidth,
      paddingInlineSM: 8 - token2.lineWidth,
      onlyIconSize: "inherit",
      onlyIconSizeSM: "inherit",
      onlyIconSizeLG: "inherit",
      groupBorderColor: token2.colorPrimaryHover,
      linkHoverBg: "transparent",
      textTextColor: token2.colorText,
      textTextHoverColor: token2.colorText,
      textTextActiveColor: token2.colorText,
      textHoverBg: token2.colorFillTertiary,
      defaultColor: token2.colorText,
      defaultBg: token2.colorBgContainer,
      defaultBorderColor: token2.colorBorder,
      defaultBorderColorDisabled: token2.colorBorder,
      defaultHoverBg: token2.colorBgContainer,
      defaultHoverColor: token2.colorPrimaryHover,
      defaultHoverBorderColor: token2.colorPrimaryHover,
      defaultActiveBg: token2.colorBgContainer,
      defaultActiveColor: token2.colorPrimaryActive,
      defaultActiveBorderColor: token2.colorPrimaryActive,
      solidTextColor,
      contentFontSize,
      contentFontSizeSM,
      contentFontSizeLG,
      contentLineHeight,
      contentLineHeightSM,
      contentLineHeightLG,
      paddingBlock: Math.max((token2.controlHeight - contentFontSize * contentLineHeight) / 2 - token2.lineWidth, 0),
      paddingBlockSM: Math.max((token2.controlHeightSM - contentFontSizeSM * contentLineHeightSM) / 2 - token2.lineWidth, 0),
      paddingBlockLG: Math.max((token2.controlHeightLG - contentFontSizeLG * contentLineHeightLG) / 2 - token2.lineWidth, 0),
      defaultBgDisabled,
      dashedBgDisabled
    };
  };
  const genVariantStyle = (token2) => {
    const {
      componentCls,
      antCls,
      lineWidth
    } = token2;
    const [varName, varRef] = genCssVar(antCls, "btn");
    return {
      [componentCls]: [


{
[varName("border-width")]: lineWidth,
          [varName("border-color")]: "#000",
          [varName("border-color-hover")]: varRef("border-color"),
          [varName("border-color-active")]: varRef("border-color"),
          [varName("border-color-disabled")]: varRef("border-color"),
          [varName("border-style")]: "solid",
[varName("text-color")]: "#000",
          [varName("text-color-hover")]: varRef("text-color"),
          [varName("text-color-active")]: varRef("text-color"),
          [varName("text-color-disabled")]: varRef("text-color"),
[varName("bg-color")]: "#ddd",
          [varName("bg-color-hover")]: varRef("bg-color"),
          [varName("bg-color-active")]: varRef("bg-color"),
          [varName("bg-color-disabled")]: token2.colorBgContainerDisabled,
          [varName("bg-color-container")]: token2.colorBgContainer,
[varName("shadow")]: "none"
        },


{
border: [varRef("border-width"), varRef("border-style"), varRef("border-color")].join(" "),
          color: varRef("text-color"),
          backgroundColor: varRef("bg-color"),
[`&:not(:disabled):not(${componentCls}-disabled)`]: {
"&:hover": {
              border: [varRef("border-width"), varRef("border-style"), varRef("border-color-hover")].join(" "),
              color: varRef("text-color-hover"),
              backgroundColor: varRef("bg-color-hover")
            },
"&:active": {
              border: [varRef("border-width"), varRef("border-style"), varRef("border-color-active")].join(" "),
              color: varRef("text-color-active"),
              backgroundColor: varRef("bg-color-active")
            }
          }
        },


{
[`&${componentCls}-variant-solid`]: {
[varName("solid-bg-color")]: varRef("color-base"),
            [varName("solid-bg-color-hover")]: varRef("color-hover"),
            [varName("solid-bg-color-active")]: varRef("color-active"),
[varName("border-color")]: "transparent",
            [varName("text-color")]: token2.colorTextLightSolid,
            [varName("bg-color")]: varRef("solid-bg-color"),
            [varName("bg-color-hover")]: varRef("solid-bg-color-hover"),
            [varName("bg-color-active")]: varRef("solid-bg-color-active"),
boxShadow: varRef("shadow")
          },
[`&${componentCls}-variant-outlined, &${componentCls}-variant-dashed`]: {
            [varName("border-color")]: varRef("color-base"),
            [varName("border-color-hover")]: varRef("color-hover"),
            [varName("border-color-active")]: varRef("color-active"),
            [varName("bg-color")]: varRef("bg-color-container"),
            [varName("text-color")]: varRef("color-base"),
            [varName("text-color-hover")]: varRef("color-hover"),
            [varName("text-color-active")]: varRef("color-active"),
boxShadow: varRef("shadow")
          },
[`&${componentCls}-variant-dashed`]: {
            [varName("border-style")]: "dashed",
            [varName("bg-color-disabled")]: token2.dashedBgDisabled
          },
[`&${componentCls}-variant-filled`]: {
            [varName("border-color")]: "transparent",
            [varName("text-color")]: varRef("color-base"),
            [varName("bg-color")]: varRef("color-light"),
            [varName("bg-color-hover")]: varRef("color-light-hover"),
            [varName("bg-color-active")]: varRef("color-light-active")
          },
[`&${componentCls}-variant-text, &${componentCls}-variant-link`]: {
            [varName("border-color")]: "transparent",
            [varName("text-color")]: varRef("color-base"),
            [varName("text-color-hover")]: varRef("color-hover"),
            [varName("text-color-active")]: varRef("color-active"),
            [varName("bg-color")]: "transparent",
            [varName("bg-color-hover")]: "transparent",
            [varName("bg-color-active")]: "transparent",
            [`&:disabled, &${token2.componentCls}-disabled`]: {
              background: "transparent",
              borderColor: "transparent"
            }
          },
[`&${componentCls}-variant-text`]: {
            [varName("bg-color-hover")]: varRef("color-light"),
            [varName("bg-color-active")]: varRef("color-light-active")
          }
        },


{

[`&${componentCls}-variant-link`]: {
            [varName("color-base")]: token2.colorLink,
            [varName("color-hover")]: token2.colorLinkHover,
            [varName("color-active")]: token2.colorLinkActive,
            [varName("bg-color-hover")]: token2.linkHoverBg
          },

[`&${componentCls}-color-primary`]: {
            [varName("color-base")]: token2.colorPrimary,
            [varName("color-hover")]: token2.colorPrimaryHover,
            [varName("color-active")]: token2.colorPrimaryActive,
            [varName("color-light")]: token2.colorPrimaryBg,
            [varName("color-light-hover")]: token2.colorPrimaryBgHover,
            [varName("color-light-active")]: token2.colorPrimaryBorder,
            [varName("shadow")]: token2.primaryShadow,
            [`&${componentCls}-variant-solid`]: {
              [varName("text-color")]: token2.primaryColor,
              [varName("text-color-hover")]: varRef("text-color"),
              [varName("text-color-active")]: varRef("text-color")
            }
          },
[`&${componentCls}-color-dangerous`]: {
            [varName("color-base")]: token2.colorError,
            [varName("color-hover")]: token2.colorErrorHover,
            [varName("color-active")]: token2.colorErrorActive,
            [varName("color-light")]: token2.colorErrorBg,
            [varName("color-light-hover")]: token2.colorErrorBgFilledHover,
            [varName("color-light-active")]: token2.colorErrorBgActive,
            [varName("shadow")]: token2.dangerShadow,
            [`&${componentCls}-variant-solid`]: {
              [varName("text-color")]: token2.dangerColor,
              [varName("text-color-hover")]: varRef("text-color"),
              [varName("text-color-active")]: varRef("text-color")
            }
          },
[`&${componentCls}-color-default`]: {
            [varName("solid-bg-color")]: token2.colorBgSolid,
            [varName("solid-bg-color-hover")]: token2.colorBgSolidHover,
            [varName("solid-bg-color-active")]: token2.colorBgSolidActive,
            [varName("color-base")]: token2.defaultBorderColor,
            [varName("color-hover")]: token2.defaultHoverBorderColor,
            [varName("color-active")]: token2.defaultActiveBorderColor,
            [varName("color-light")]: token2.colorFillTertiary,
            [varName("color-light-hover")]: token2.colorFillSecondary,
            [varName("color-light-active")]: token2.colorFill,
            [varName("text-color")]: token2.defaultColor,
            [varName("text-color-hover")]: token2.defaultHoverColor,
            [varName("text-color-active")]: token2.defaultActiveColor,
            [varName("shadow")]: token2.defaultShadow,
            [`&${componentCls}-variant-outlined`]: {
              [varName("bg-color-disabled")]: token2.defaultBgDisabled
            },
            [`&${componentCls}-variant-solid`]: {
              [varName("text-color")]: token2.solidTextColor,
              [varName("text-color-hover")]: varRef("text-color"),
              [varName("text-color-active")]: varRef("text-color")
            },
            [`&${componentCls}-variant-filled, &${componentCls}-variant-text`]: {
              [varName("text-color-hover")]: varRef("text-color"),
              [varName("text-color-active")]: varRef("text-color")
            },
            [`&${componentCls}-variant-outlined, &${componentCls}-variant-dashed`]: {
              [varName("text-color")]: token2.defaultColor,
              [varName("text-color-hover")]: token2.defaultHoverColor,
              [varName("text-color-active")]: token2.defaultActiveColor,
              [varName("bg-color-container")]: token2.defaultBg,
              [varName("bg-color-hover")]: token2.defaultHoverBg,
              [varName("bg-color-active")]: token2.defaultActiveBg
            },
            [`&${componentCls}-variant-text`]: {
              [varName("text-color")]: token2.textTextColor,
              [varName("text-color-hover")]: token2.textTextHoverColor,
              [varName("text-color-active")]: token2.textTextActiveColor,
              [varName("bg-color-hover")]: token2.textHoverBg
            },
            [`&${componentCls}-background-ghost`]: {
              [`&${componentCls}-variant-outlined, &${componentCls}-variant-dashed`]: {
                [varName("text-color")]: token2.defaultGhostColor,
                [varName("border-color")]: token2.defaultGhostBorderColor
              }
            }
          }
        },
PresetColors.map((colorKey) => {
          const darkColor = token2[`${colorKey}6`];
          const lightColor = token2[`${colorKey}1`];
          const hoverColor = token2[`${colorKey}Hover`];
          const lightHoverColor = token2[`${colorKey}2`];
          const lightActiveColor = token2[`${colorKey}3`];
          const activeColor = token2[`${colorKey}Active`];
          const shadowColor = token2[`${colorKey}ShadowColor`];
          return {
            [`&${componentCls}-color-${colorKey}`]: {
              [varName("color-base")]: darkColor,
              [varName("color-hover")]: hoverColor,
              [varName("color-active")]: activeColor,
              [varName("color-light")]: lightColor,
              [varName("color-light-hover")]: lightHoverColor,
              [varName("color-light-active")]: lightActiveColor,
              [varName("shadow")]: shadowColor
            }
          };
        }),


{
[`&:disabled, &${token2.componentCls}-disabled`]: {
            cursor: "not-allowed",
            borderColor: token2.colorBorderDisabled,
            background: varRef("bg-color-disabled"),
            color: token2.colorTextDisabled,
            boxShadow: "none"
          }
        },


{
[`&${componentCls}-background-ghost`]: {
            [varName("bg-color")]: token2.ghostBg,
            [varName("bg-color-hover")]: token2.ghostBg,
            [varName("bg-color-active")]: token2.ghostBg,
            [varName("shadow")]: "none",
            [`&${componentCls}-variant-outlined, &${componentCls}-variant-dashed`]: {
              [varName("bg-color-hover")]: token2.ghostBg,
              [varName("bg-color-active")]: token2.ghostBg
            }
          }
        }
      ]
    };
  };
  const genSharedButtonStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      fontWeight,
      opacityLoading,
      motionDurationSlow,
      motionEaseInOut,
      iconGap,
      calc
    } = token2;
    return {
      [componentCls]: {
        outline: "none",
        position: "relative",
        display: "inline-flex",
        gap: iconGap,
        alignItems: "center",
        justifyContent: "center",
        fontWeight,
        whiteSpace: "nowrap",
        textAlign: "center",
        backgroundImage: "none",
        cursor: "pointer",
        transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
        userSelect: "none",
        touchAction: "manipulation",
        ...genNoMotionStyle(),
        "&:disabled > *": {
          pointerEvents: "none"
        },
[`${componentCls}-icon > svg`]: resetIcon(),
        "> a": {
          color: "currentColor"
        },
        "&:not(:disabled)": genFocusStyle(token2),
        [`&${componentCls}-two-chinese-chars::first-letter`]: {
          letterSpacing: "0.34em"
        },
        [`&${componentCls}-two-chinese-chars > *:not(${iconCls})`]: {
          marginInlineEnd: "-0.34em",
          letterSpacing: "0.34em"
        },
        [`&${componentCls}-icon-only`]: {
          paddingInline: 0,
[`&${componentCls}-compact-item`]: {
            flex: "none"
          }
        },
[`&${componentCls}-loading`]: {
          opacity: opacityLoading,
          cursor: "default"
        },
        [`${componentCls}-loading-icon`]: {
          transition: ["width", "opacity", "margin"].map((prop) => `${prop} ${motionDurationSlow} ${motionEaseInOut}`).join(",")
        },
[`&:not(${componentCls}-icon-end)`]: {
          [`${componentCls}-loading-icon-motion`]: {
            "&-appear-start, &-enter-start": {
              marginInlineEnd: calc(iconGap).mul(-1).equal()
            },
            "&-appear-active, &-enter-active": {
              marginInlineEnd: 0
            },
            "&-leave-start": {
              marginInlineEnd: 0
            },
            "&-leave-active": {
              marginInlineEnd: calc(iconGap).mul(-1).equal()
            }
          }
        },
        "&-icon-end": {
          flexDirection: "row-reverse",
          [`${componentCls}-loading-icon-motion`]: {
            "&-appear-start, &-enter-start": {
              marginInlineStart: calc(iconGap).mul(-1).equal()
            },
            "&-appear-active, &-enter-active": {
              marginInlineStart: 0
            },
            "&-leave-start": {
              marginInlineStart: 0
            },
            "&-leave-active": {
              marginInlineStart: calc(iconGap).mul(-1).equal()
            }
          }
        }
      }
    };
  };
  const genCircleButtonStyle = (token2) => ({
    minWidth: token2.controlHeight,
    paddingInline: 0,
    borderRadius: "50%"
  });
  const genButtonStyle = (token2, prefixCls = "") => {
    const {
      componentCls,
      controlHeight,
      fontSize,
      borderRadius,
      buttonPaddingHorizontal,
      iconCls,
      buttonPaddingVertical,
      buttonIconOnlyFontSize
    } = token2;
    return [
      {
        [prefixCls]: {
          fontSize,
          height: controlHeight,
          padding: `${unit$1(buttonPaddingVertical)} ${unit$1(buttonPaddingHorizontal)}`,
          borderRadius,
          [`&${componentCls}-icon-only`]: {
            width: controlHeight,
            [iconCls]: {
              fontSize: buttonIconOnlyFontSize
            }
          }
        }
      },
{
        [`${componentCls}${componentCls}-circle${prefixCls}`]: genCircleButtonStyle(token2)
      },
      {
        [`${componentCls}${componentCls}-round${prefixCls}`]: {
          borderRadius: token2.controlHeight,
          [`&:not(${componentCls}-icon-only)`]: {
            paddingInline: token2.buttonPaddingHorizontal
          }
        }
      }
    ];
  };
  const genSizeBaseButtonStyle = (token2) => {
    const baseToken = merge$1(token2, {
      fontSize: token2.contentFontSize
    });
    return genButtonStyle(baseToken, token2.componentCls);
  };
  const genSizeSmallButtonStyle = (token2) => {
    const smallToken = merge$1(token2, {
      controlHeight: token2.controlHeightSM,
      fontSize: token2.contentFontSizeSM,
      padding: token2.paddingXS,
      buttonPaddingHorizontal: token2.paddingInlineSM,
      buttonPaddingVertical: 0,
      borderRadius: token2.borderRadiusSM,
      buttonIconOnlyFontSize: token2.onlyIconSizeSM
    });
    return genButtonStyle(smallToken, `${token2.componentCls}-sm`);
  };
  const genSizeLargeButtonStyle = (token2) => {
    const largeToken = merge$1(token2, {
      controlHeight: token2.controlHeightLG,
      fontSize: token2.contentFontSizeLG,
      buttonPaddingHorizontal: token2.paddingInlineLG,
      buttonPaddingVertical: 0,
      borderRadius: token2.borderRadiusLG,
      buttonIconOnlyFontSize: token2.onlyIconSizeLG
    });
    return genButtonStyle(largeToken, `${token2.componentCls}-lg`);
  };
  const genBlockButtonStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: {
        [`&${componentCls}-block`]: {
          width: "100%"
        }
      }
    };
  };
  const useStyle$A = genStyleHooks("Button", (token2) => {
    const buttonToken = prepareToken$4(token2);
    return [
genSharedButtonStyle(buttonToken),
genSizeBaseButtonStyle(buttonToken),
      genSizeSmallButtonStyle(buttonToken),
      genSizeLargeButtonStyle(buttonToken),
genBlockButtonStyle(buttonToken),
genVariantStyle(buttonToken),
genGroupStyle$3(buttonToken)
    ];
  }, prepareComponentToken$q, {
    unitless: {
      fontWeight: true,
      contentLineHeight: true,
      contentLineHeightSM: true,
      contentLineHeightLG: true
    }
  });
  function compactItemBorder(token2, parentCls, options, prefixCls) {
    const {
      focusElCls,
      focus,
      borderElCls
    } = options;
    const childCombinator = borderElCls ? "> *" : "";
    const hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n2) => `&:${n2} ${childCombinator}`).join(",");
    return {
      [`&-item:not(${parentCls}-last-item)`]: {
        marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal()
      },
      [`&-item:not(${prefixCls}-status-success)`]: {
        zIndex: 2
      },
      "&-item": {
        [hoverEffects]: {
          zIndex: 3
        },
        ...focusElCls ? {
          [`&${focusElCls}`]: {
            zIndex: 3
          }
        } : {},
        [`&[disabled] ${childCombinator}`]: {
          zIndex: 0
        }
      }
    };
  }
  function compactItemBorderRadius(prefixCls, parentCls, options) {
    const {
      borderElCls
    } = options;
    const childCombinator = borderElCls ? `> ${borderElCls}` : "";
    return {
      [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
        borderRadius: 0
      },
      [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
        [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        }
      },
      [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
        [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        }
      }
    };
  }
  function genCompactItemStyle(token2, options = {
    focus: true
  }) {
    const {
      componentCls
    } = token2;
    const {
      componentCls: customizePrefixCls
    } = options;
    const mergedComponentCls = customizePrefixCls || componentCls;
    const compactCls = `${mergedComponentCls}-compact`;
    return {
      [compactCls]: {
        ...compactItemBorder(token2, compactCls, options, mergedComponentCls),
        ...compactItemBorderRadius(mergedComponentCls, compactCls, options)
      }
    };
  }
  function compactItemVerticalBorder(token2, parentCls, prefixCls) {
    return {
[`&-item:not(${parentCls}-last-item)`]: {
        marginBottom: token2.calc(token2.lineWidth).mul(-1).equal()
      },
      [`&-item:not(${prefixCls}-status-success)`]: {
        zIndex: 2
      },
      "&-item": {
        "&:hover,&:focus,&:active": {
          zIndex: 3
        },
        "&[disabled]": {
          zIndex: 0
        }
      }
    };
  }
  function compactItemBorderVerticalRadius(prefixCls, parentCls) {
    return {
      [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
        borderRadius: 0
      },
      [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
        [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
          borderEndEndRadius: 0,
          borderEndStartRadius: 0
        }
      },
      [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
        [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
          borderStartStartRadius: 0,
          borderStartEndRadius: 0
        }
      }
    };
  }
  function genCompactItemVerticalStyle(token2) {
    const compactCls = `${token2.componentCls}-compact-vertical`;
    return {
      [compactCls]: {
        ...compactItemVerticalBorder(token2, compactCls, token2.componentCls),
        ...compactItemBorderVerticalRadius(token2.componentCls, compactCls)
      }
    };
  }
  const genButtonCompactStyle = (token2) => {
    const {
      antCls,
      componentCls,
      lineWidth,
      calc,
      colorBgContainer
    } = token2;
    const solidSelector = `${componentCls}-variant-solid:not([disabled])`;
    const insetOffset = calc(lineWidth).mul(-1).equal();
    const [varName, varRef] = genCssVar(antCls, "btn");
    const getCompactBorderStyle = (vertical) => {
      const itemCls = `${componentCls}-compact${vertical ? "-vertical" : ""}-item`;
      return {
[itemCls]: {
          [varName("compact-connect-border-color")]: varRef("bg-color-hover"),
          [`&${solidSelector}`]: {
            transition: `none`,
            [`& + ${solidSelector}:before`]: [{
              position: "absolute",
              backgroundColor: varRef("compact-connect-border-color"),
              content: '""'
            }, vertical ? {
              top: insetOffset,
              insetInline: insetOffset,
              height: lineWidth
            } : {
              insetBlock: insetOffset,
              insetInlineStart: insetOffset,
              width: lineWidth
            }],
            "&:hover:before": {
              display: "none"
            }
          }
        }
      };
    };
    return [getCompactBorderStyle(), getCompactBorderStyle(true), {
      [`${solidSelector}${componentCls}-color-default`]: {
        [varName("compact-connect-border-color")]: `color-mix(in srgb, ${varRef("bg-color-hover")} 75%, ${colorBgContainer})`
      }
    }];
  };
  const Compact = genSubStyleComponent(["Button", "compact"], (token2) => {
    const buttonToken = prepareToken$4(token2);
    return [
genCompactItemStyle(buttonToken),
      genCompactItemVerticalStyle(buttonToken),
      genButtonCompactStyle(buttonToken)
    ];
  }, prepareComponentToken$q);
  function getLoadingConfig(loading) {
    if (typeof loading === "object" && loading) {
      let delay2 = loading?.delay;
      delay2 = !Number.isNaN(delay2) && typeof delay2 === "number" ? delay2 : 0;
      return {
        loading: delay2 <= 0,
        delay: delay2
      };
    }
    return {
      loading: !!loading,
      delay: 0
    };
  }
  const ButtonTypeMap = {
    default: ["default", "outlined"],
    primary: ["primary", "solid"],
    dashed: ["default", "dashed"],
link: ["link", "link"],
    text: ["default", "text"]
  };
  const InternalCompoundedButton = React.forwardRef((props, ref2) => {
    const {
      _skipSemantic,
      loading = false,
      prefixCls: customizePrefixCls,
      color: color2,
      variant,
      type: type4,
      danger = false,
      shape: customizeShape,
      size: customizeSize,
      disabled: customDisabled,
      className,
      rootClassName,
      children,
      icon,
      iconPosition,
      iconPlacement,
      ghost = false,
      block = false,
htmlType = "button",
      classNames,
      styles,
      style: style2,
      autoInsertSpace,
      autoFocus,
      ...rest
    } = props;
    const childNodes = toArray$4(children);
    const mergedType = type4 || "default";
    const {
      getPrefixCls,
      direction,
      autoInsertSpace: contextAutoInsertSpace,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles,
      loadingIcon: contextLoadingIcon,
      shape: contextShape,
      color: contextColor,
      variant: contextVariant
    } = useComponentConfig("button");
    const mergedShape = customizeShape || contextShape || "default";
    const [parsedColor, parsedVariant] = reactExports.useMemo(() => {
      if (color2 && variant) {
        return [color2, variant];
      }
      if (type4 || danger) {
        const colorVariantPair = ButtonTypeMap[mergedType] || [];
        if (danger) {
          return ["danger", colorVariantPair[1]];
        }
        return colorVariantPair;
      }
      if (contextColor && contextVariant) {
        return [contextColor, contextVariant];
      }
      return ["default", "outlined"];
    }, [color2, variant, type4, danger, contextColor, contextVariant, mergedType]);
    const [mergedColor, mergedVariant] = reactExports.useMemo(() => {
      if (ghost && parsedVariant === "solid") {
        return [parsedColor, "outlined"];
      }
      return [parsedColor, parsedVariant];
    }, [parsedColor, parsedVariant, ghost]);
    const isDanger = mergedColor === "danger";
    const mergedColorText = isDanger ? "dangerous" : mergedColor;
    const mergedInsertSpace = autoInsertSpace ?? contextAutoInsertSpace ?? true;
    const prefixCls = getPrefixCls("btn", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$A(prefixCls);
    const disabled = reactExports.useContext(DisabledContext);
    const mergedDisabled = customDisabled ?? disabled;
    const groupSize = reactExports.useContext(GroupSizeContext);
    const loadingOrDelay = reactExports.useMemo(() => getLoadingConfig(loading), [loading]);
    const [innerLoading, setInnerLoading] = reactExports.useState(loadingOrDelay.loading);
    const [hasTwoCNChar, setHasTwoCNChar] = reactExports.useState(false);
    const buttonRef = reactExports.useRef(null);
    const mergedRef = useComposeRef(ref2, buttonRef);
    const needInserted = childNodes.length === 1 && !icon && !isUnBorderedButtonVariant(mergedVariant);
    const isMountRef = reactExports.useRef(true);
    React.useEffect(() => {
      isMountRef.current = false;
      return () => {
        isMountRef.current = true;
      };
    }, []);
    useLayoutEffect(() => {
      let delayTimer = null;
      if (loadingOrDelay.delay > 0) {
        delayTimer = setTimeout(() => {
          delayTimer = null;
          setInnerLoading(true);
        }, loadingOrDelay.delay);
      } else {
        setInnerLoading(loadingOrDelay.loading);
      }
      function cleanupTimer() {
        if (delayTimer) {
          clearTimeout(delayTimer);
          delayTimer = null;
        }
      }
      return cleanupTimer;
    }, [loadingOrDelay.delay, loadingOrDelay.loading]);
    reactExports.useEffect(() => {
      if (!buttonRef.current || !mergedInsertSpace) {
        return;
      }
      const buttonText = buttonRef.current.textContent || "";
      if (needInserted && isTwoCNChar(buttonText)) {
        if (!hasTwoCNChar) {
          setHasTwoCNChar(true);
        }
      } else if (hasTwoCNChar) {
        setHasTwoCNChar(false);
      }
    });
    reactExports.useEffect(() => {
      if (autoFocus && buttonRef.current) {
        buttonRef.current.focus();
      }
    }, []);
    const handleClick = React.useCallback((e) => {
      if (innerLoading || mergedDisabled) {
        e.preventDefault();
        return;
      }
      props.onClick?.("href" in props ? e : e);
    }, [props.onClick, innerLoading, mergedDisabled]);
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const sizeClassNameMap2 = {
      large: "lg",
      small: "sm",
      middle: void 0,
      medium: void 0
    };
    const sizeFullName = useSize((ctxSize) => customizeSize ?? compactSize ?? groupSize ?? ctxSize);
    const sizeCls = sizeFullName ? sizeClassNameMap2[sizeFullName] ?? "" : "";
    const iconType = innerLoading ? "loading" : icon;
    const mergedIconPlacement = iconPlacement ?? iconPosition ?? "start";
    const linkButtonRestProps = omit(rest, ["navigate"]);
    const mergedProps = {
      ...props,
      type: mergedType,
      color: mergedColor,
      variant: mergedVariant,
      danger: isDanger,
      shape: mergedShape,
      size: sizeFullName,
      disabled: mergedDisabled,
      loading: innerLoading,
      iconPlacement: mergedIconPlacement
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([_skipSemantic ? void 0 : contextClassNames, classNames], [_skipSemantic ? void 0 : contextStyles, styles], {
      props: mergedProps
    });
    const classes2 = clsx(prefixCls, hashId, cssVarCls, {
      [`${prefixCls}-${mergedShape}`]: mergedShape !== "default" && mergedShape !== "square" && mergedShape,
[`${prefixCls}-${mergedType}`]: mergedType,
      [`${prefixCls}-dangerous`]: danger,
      [`${prefixCls}-color-${mergedColorText}`]: mergedColorText,
      [`${prefixCls}-variant-${mergedVariant}`]: mergedVariant,
      [`${prefixCls}-${sizeCls}`]: sizeCls,
      [`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
      [`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonVariant(mergedVariant),
      [`${prefixCls}-loading`]: innerLoading,
      [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && mergedInsertSpace && !innerLoading,
      [`${prefixCls}-block`]: block,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-icon-end`]: mergedIconPlacement === "end"
    }, compactItemClassnames, className, rootClassName, contextClassName, mergedClassNames.root);
    const fullStyle = {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    };
    const iconSharedProps = {
      className: mergedClassNames.icon,
      style: mergedStyles.icon
    };
    const iconWrapperElement = (child) => React.createElement(IconWrapper, {
      prefixCls,
      ...iconSharedProps
    }, child);
    const defaultLoadingIconElement = React.createElement(DefaultLoadingIcon, {
      existIcon: !!icon,
      prefixCls,
      loading: innerLoading,
      mount: isMountRef.current,
      ...iconSharedProps
    });
    const mergedLoadingIcon = loading && typeof loading === "object" ? loading.icon || contextLoadingIcon : contextLoadingIcon;
    let iconNode;
    if (icon && !innerLoading) {
      iconNode = iconWrapperElement(icon);
    } else if (loading && mergedLoadingIcon) {
      iconNode = iconWrapperElement(mergedLoadingIcon);
    } else {
      iconNode = defaultLoadingIconElement;
    }
    const contentNode = isNonNullable(children) ? spaceChildren(children, needInserted && mergedInsertSpace, mergedStyles.content, mergedClassNames.content) : null;
    if (linkButtonRestProps.href !== void 0) {
      return React.createElement("a", {
        ...linkButtonRestProps,
        className: clsx(classes2, {
          [`${prefixCls}-disabled`]: mergedDisabled
        }),
        href: mergedDisabled ? void 0 : linkButtonRestProps.href,
        style: fullStyle,
        onClick: handleClick,
        ref: mergedRef,
        tabIndex: mergedDisabled ? -1 : 0,
        "aria-disabled": mergedDisabled
      }, iconNode, contentNode);
    }
    let buttonNode = React.createElement("button", {
      ...rest,
      type: htmlType,
      className: classes2,
      style: fullStyle,
      onClick: handleClick,
      disabled: mergedDisabled,
      ref: mergedRef
    }, iconNode, contentNode, compactItemClassnames && React.createElement(Compact, {
      prefixCls
    }));
    if (!isUnBorderedButtonVariant(mergedVariant)) {
      buttonNode = React.createElement(Wave, {
        component: "Button",
        disabled: innerLoading
      }, buttonNode);
    }
    return buttonNode;
  });
  const Button$1 = InternalCompoundedButton;
  Button$1.Group = ButtonGroup;
  Button$1.__ANT_BUTTON = true;
  const isThenable = (thing) => {
    return typeof thing?.then === "function";
  };
  const ActionButton$1 = (props) => {
    const {
      type: type4,
      children,
      prefixCls,
      buttonProps,
      close,
      autoFocus,
      emitEvent,
      isSilent,
      quitOnNullishReturnValue,
      actionFn
    } = props;
    const clickedRef = reactExports.useRef(false);
    const buttonRef = reactExports.useRef(null);
    const [loading, setLoading] = useSafeState(false);
    const onInternalClose = (...args) => {
      close?.(...args);
    };
    reactExports.useEffect(() => {
      let timeoutId = null;
      if (autoFocus) {
        timeoutId = setTimeout(() => {
          buttonRef.current?.focus({
            preventScroll: true
          });
        });
      }
      return () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
      };
    }, [autoFocus]);
    const handlePromiseOnOk = (returnValueOfOnOk) => {
      if (!isThenable(returnValueOfOnOk)) {
        return;
      }
      setLoading(true);
      returnValueOfOnOk.then((...args) => {
        setLoading(false, true);
        onInternalClose.apply(void 0, args);
        clickedRef.current = false;
      }, (e) => {
        setLoading(false, true);
        clickedRef.current = false;
        if (isSilent?.()) {
          return;
        }
        return Promise.reject(e);
      });
    };
    const onClick = (e) => {
      if (clickedRef.current) {
        return;
      }
      clickedRef.current = true;
      if (!actionFn) {
        onInternalClose();
        return;
      }
      let returnValueOfOnOk;
      if (emitEvent) {
        returnValueOfOnOk = actionFn(e);
        if (quitOnNullishReturnValue && !isThenable(returnValueOfOnOk)) {
          clickedRef.current = false;
          onInternalClose(e);
          return;
        }
      } else if (actionFn.length) {
        returnValueOfOnOk = actionFn(close);
        clickedRef.current = false;
      } else {
        returnValueOfOnOk = actionFn();
        if (!isThenable(returnValueOfOnOk)) {
          onInternalClose();
          return;
        }
      }
      handlePromiseOnOk(returnValueOfOnOk);
    };
    return reactExports.createElement(Button$1, {
      ...convertLegacyProps(type4),
      onClick,
      loading,
      prefixCls,
      ...buttonProps,
      ref: buttonRef
    }, children);
  };
  const ModalContext = React.createContext({});
  const {
    Provider: ModalContextProvider
  } = ModalContext;
  const ConfirmCancelBtn = () => {
    const {
      autoFocusButton,
      cancelButtonProps,
      cancelTextLocale,
      isSilent,
      mergedOkCancel,
      rootPrefixCls,
      close,
      onCancel,
      onConfirm,
      onClose
    } = reactExports.useContext(ModalContext);
    return mergedOkCancel ? React.createElement(ActionButton$1, {
      isSilent,
      actionFn: onCancel,
      close: (...args) => {
        close?.(...args);
        onConfirm?.(false);
        onClose?.();
      },
      autoFocus: autoFocusButton === "cancel",
      buttonProps: cancelButtonProps,
      prefixCls: `${rootPrefixCls}-btn`
    }, cancelTextLocale) : null;
  };
  const ConfirmOkBtn = () => {
    const {
      autoFocusButton,
      close,
      isSilent,
      okButtonProps,
      rootPrefixCls,
      okTextLocale,
      okType,
      onConfirm,
      onOk,
      onClose
    } = reactExports.useContext(ModalContext);
    return React.createElement(ActionButton$1, {
      isSilent,
      type: okType || "primary",
      actionFn: onOk,
      close: (...args) => {
        close?.(...args);
        onConfirm?.(true);
        onClose?.();
      },
      autoFocus: autoFocusButton === "ok",
      buttonProps: okButtonProps,
      prefixCls: `${rootPrefixCls}-btn`
    }, okTextLocale);
  };
  const RefContext = reactExports.createContext({});
  function getMotionName(prefixCls, transitionName, animationName) {
    let motionName = transitionName;
    if (!motionName && animationName) {
      motionName = `${prefixCls}-${animationName}`;
    }
    return motionName;
  }
  function getScroll(w, top) {
    let ret = w[`page${top ? "Y" : "X"}Offset`];
    const method4 = `scroll${top ? "Top" : "Left"}`;
    if (typeof ret !== "number") {
      const d2 = w.document;
      ret = d2.documentElement[method4];
      if (typeof ret !== "number") {
        ret = d2.body[method4];
      }
    }
    return ret;
  }
  function offset(el) {
    const rect = el.getBoundingClientRect();
    const pos = {
      left: rect.left,
      top: rect.top
    };
    const doc = el.ownerDocument;
    const w = doc.defaultView || doc.parentWindow;
    pos.left += getScroll(w);
    pos.top += getScroll(w, true);
    return pos;
  }
  function focusable(node2, includePositive = false) {
    if (isVisible(node2)) {
      const nodeName = node2.nodeName.toLowerCase();
      const isFocusableElement = (
["input", "select", "textarea", "button"].includes(nodeName) ||
node2.isContentEditable ||
nodeName === "a" && !!node2.getAttribute("href")
      );
      const tabIndexAttr = node2.getAttribute("tabindex");
      const tabIndexNum = Number(tabIndexAttr);
      let tabIndex = null;
      if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {
        tabIndex = tabIndexNum;
      } else if (isFocusableElement && tabIndex === null) {
        tabIndex = 0;
      }
      if (isFocusableElement && node2.disabled) {
        tabIndex = null;
      }
      return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
    }
    return false;
  }
  function getFocusNodeList(node2, includePositive = false) {
    const res = [...node2.querySelectorAll("*")].filter((child) => {
      return focusable(child, includePositive);
    });
    if (focusable(node2, includePositive)) {
      res.unshift(node2);
    }
    return res;
  }
  function triggerFocus(element, option) {
    if (!element) return;
    element.focus(option);
    const {
      cursor: cursor2
    } = option || {};
    if (cursor2 && (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement)) {
      const len = element.value.length;
      switch (cursor2) {
        case "start":
          element.setSelectionRange(0, 0);
          break;
        case "end":
          element.setSelectionRange(len, len);
          break;
        default:
          element.setSelectionRange(0, len);
      }
    }
  }
  let lastFocusElement = null;
  let focusElements = [];
  const idToElementMap = new Map();
  const ignoredElementMap = new Map();
  function getLastElement() {
    return focusElements[focusElements.length - 1];
  }
  function isIgnoredElement(element) {
    const lastElement = getLastElement();
    if (element && lastElement) {
      let lockId;
      for (const [id2, ele] of idToElementMap.entries()) {
        if (ele === lastElement) {
          lockId = id2;
          break;
        }
      }
      const ignoredEle = ignoredElementMap.get(lockId);
      return !!ignoredEle && (ignoredEle === element || ignoredEle.contains(element));
    }
    return false;
  }
  function hasFocus(element) {
    const {
      activeElement
    } = document;
    return element === activeElement || element.contains(activeElement);
  }
  function syncFocus() {
    const lastElement = getLastElement();
    const {
      activeElement
    } = document;
    if (isIgnoredElement(activeElement)) {
      return;
    }
    if (lastElement && !hasFocus(lastElement)) {
      const focusableList = getFocusNodeList(lastElement);
      const matchElement = focusableList.includes(lastFocusElement) ? lastFocusElement : focusableList[0];
      matchElement?.focus({
        preventScroll: true
      });
    } else {
      lastFocusElement = activeElement;
    }
  }
  function onWindowKeyDown(e) {
    if (e.key === "Tab") {
      const {
        activeElement
      } = document;
      const lastElement = getLastElement();
      const focusableList = getFocusNodeList(lastElement);
      const last = focusableList[focusableList.length - 1];
      if (e.shiftKey && activeElement === focusableList[0]) {
        lastFocusElement = last;
      } else if (!e.shiftKey && activeElement === last) {
        lastFocusElement = focusableList[0];
      }
    }
  }
  function lockFocus(element, id2) {
    if (element) {
      idToElementMap.set(id2, element);
      focusElements = focusElements.filter((ele) => ele !== element);
      focusElements.push(element);
      window.addEventListener("focusin", syncFocus);
      window.addEventListener("keydown", onWindowKeyDown, true);
      syncFocus();
    }
    return () => {
      lastFocusElement = null;
      focusElements = focusElements.filter((ele) => ele !== element);
      idToElementMap.delete(id2);
      ignoredElementMap.delete(id2);
      if (focusElements.length === 0) {
        window.removeEventListener("focusin", syncFocus);
        window.removeEventListener("keydown", onWindowKeyDown, true);
      }
    };
  }
  function useLockFocus(lock, getElement) {
    const id2 = useId();
    reactExports.useEffect(() => {
      if (lock) {
        const element = getElement();
        if (element) {
          return lockFocus(element, id2);
        }
      }
    }, [lock, id2]);
    const ignoreElement = (ele) => {
      if (ele) {
        ignoredElementMap.set(id2, ele);
      }
    };
    return [ignoreElement];
  }
  const MemoChildren = reactExports.memo(({
    children
  }) => children, (_2, {
    shouldUpdate
  }) => !shouldUpdate);
  function _extends$Q() {
    _extends$Q = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$Q.apply(this, arguments);
  }
  const Panel = React.forwardRef((props, ref2) => {
    const {
      prefixCls,
      className,
      style: style2,
      title,
      ariaId,
      footer,
      closable,
      closeIcon,
      onClose,
      children,
      bodyStyle,
      bodyProps,
      modalRender,
      onMouseDown,
      onMouseUp,
      holderRef,
      visible,
      forceRender,
      width,
      height,
      classNames: modalClassNames,
      styles: modalStyles,
      isFixedPos,
      focusTrap
    } = props;
    const {
      panel: panelRef
    } = React.useContext(RefContext);
    const internalRef = reactExports.useRef(null);
    const mergedRef = useComposeRef(holderRef, panelRef, internalRef);
    const [ignoreElement] = useLockFocus(visible && isFixedPos && focusTrap !== false, () => internalRef.current);
    React.useImperativeHandle(ref2, () => ({
      focus: () => {
        internalRef.current?.focus({
          preventScroll: true
        });
      }
    }));
    const contentStyle = {};
    if (width !== void 0) {
      contentStyle.width = width;
    }
    if (height !== void 0) {
      contentStyle.height = height;
    }
    const footerNode = footer ? React.createElement("div", {
      className: clsx(`${prefixCls}-footer`, modalClassNames?.footer),
      style: {
        ...modalStyles?.footer
      }
    }, footer) : null;
    const headerNode = title ? React.createElement("div", {
      className: clsx(`${prefixCls}-header`, modalClassNames?.header),
      style: {
        ...modalStyles?.header
      }
    }, React.createElement("div", {
      className: clsx(`${prefixCls}-title`, modalClassNames?.title),
      id: ariaId,
      style: {
        ...modalStyles?.title
      }
    }, title)) : null;
    const closableObj = reactExports.useMemo(() => {
      if (typeof closable === "object" && closable !== null) {
        return closable;
      }
      if (closable) {
        return {
          closeIcon: closeIcon ?? React.createElement("span", {
            className: `${prefixCls}-close-x`
          })
        };
      }
      return {};
    }, [closable, closeIcon, prefixCls]);
    const ariaProps = pickAttrs(closableObj, true);
    const closeBtnIsDisabled = typeof closable === "object" && closable.disabled;
    const closerNode = closable ? React.createElement("button", _extends$Q({
      type: "button",
      onClick: onClose,
      "aria-label": "Close"
    }, ariaProps, {
      className: `${prefixCls}-close`,
      disabled: closeBtnIsDisabled
    }), closableObj.closeIcon) : null;
    const content = React.createElement("div", {
      className: clsx(`${prefixCls}-container`, modalClassNames?.container),
      style: modalStyles?.container
    }, closerNode, headerNode, React.createElement("div", _extends$Q({
      className: clsx(`${prefixCls}-body`, modalClassNames?.body),
      style: {
        ...bodyStyle,
        ...modalStyles?.body
      }
    }, bodyProps), children), footerNode);
    return React.createElement("div", {
      key: "dialog-element",
      role: "dialog",
      "aria-labelledby": title ? ariaId : null,
      "aria-modal": "true",
      ref: mergedRef,
      style: {
        ...style2,
        ...contentStyle
      },
      className: clsx(prefixCls, className),
      onMouseDown,
      onMouseUp,
      tabIndex: -1,
      onFocus: (e) => {
        ignoreElement(e.target);
      }
    }, React.createElement(MemoChildren, {
      shouldUpdate: visible || forceRender
    }, modalRender ? modalRender(content) : content));
  });
  function _extends$P() {
    _extends$P = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$P.apply(this, arguments);
  }
  const Content = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls,
      title,
      style: style2,
      className,
      visible,
      forceRender,
      destroyOnHidden,
      motionName,
      ariaId,
      onVisibleChanged,
      mousePosition: mousePosition2
    } = props;
    const dialogRef = reactExports.useRef(null);
    const panelRef = reactExports.useRef(null);
    reactExports.useImperativeHandle(ref2, () => ({
      ...panelRef.current,
      inMotion: dialogRef.current.inMotion,
      enableMotion: dialogRef.current.enableMotion
    }));
    const [transformOrigin, setTransformOrigin] = reactExports.useState();
    const contentStyle = {};
    if (transformOrigin) {
      contentStyle.transformOrigin = transformOrigin;
    }
    function onPrepare() {
      if (!dialogRef.current?.nativeElement) {
        return;
      }
      const elementOffset = offset(dialogRef.current.nativeElement);
      setTransformOrigin(mousePosition2 && (mousePosition2.x || mousePosition2.y) ? `${mousePosition2.x - elementOffset.left}px ${mousePosition2.y - elementOffset.top}px` : "");
    }
    return reactExports.createElement(CSSMotion, {
      visible,
      onVisibleChanged,
      onAppearPrepare: onPrepare,
      onEnterPrepare: onPrepare,
      forceRender,
      motionName,
      removeOnLeave: destroyOnHidden,
      ref: dialogRef
    }, ({
      className: motionClassName,
      style: motionStyle
    }, motionRef) => reactExports.createElement(Panel, _extends$P({}, props, {
      ref: panelRef,
      title,
      ariaId,
      prefixCls,
      holderRef: motionRef,
      style: {
        ...motionStyle,
        ...style2,
        ...contentStyle
      },
      className: clsx(className, motionClassName)
    })));
  });
  function _extends$O() {
    _extends$O = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$O.apply(this, arguments);
  }
  const Mask = (props) => {
    const {
      prefixCls,
      style: style2,
      visible,
      maskProps,
      motionName,
      className
    } = props;
    return reactExports.createElement(CSSMotion, {
      key: "mask",
      visible,
      motionName,
      leavedClassName: `${prefixCls}-mask-hidden`
    }, ({
      className: motionClassName,
      style: motionStyle
    }, ref2) => reactExports.createElement("div", _extends$O({
      ref: ref2,
      style: {
        ...motionStyle,
        ...style2
      },
      className: clsx(`${prefixCls}-mask`, motionClassName, className)
    }, maskProps)));
  };
  function _extends$N() {
    _extends$N = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$N.apply(this, arguments);
  }
  const Dialog = (props) => {
    const {
      prefixCls = "rc-dialog",
      zIndex,
      visible = false,
      focusTriggerAfterClose = true,
      wrapStyle,
      wrapClassName,
      wrapProps,
      onClose,
      afterOpenChange,
      afterClose,
transitionName,
      animation,
      closable = true,
mask: mask2 = true,
      maskTransitionName,
      maskAnimation,
      maskClosable = true,
      maskStyle,
      maskProps,
      rootClassName,
      rootStyle,
      classNames: modalClassNames,
      styles: modalStyles
    } = props;
    const lastOutSideActiveElementRef = reactExports.useRef(null);
    const wrapperRef = reactExports.useRef(null);
    const contentRef = reactExports.useRef(null);
    const [animatedVisible, setAnimatedVisible] = reactExports.useState(visible);
    const [isFixedPos, setIsFixedPos] = reactExports.useState(false);
    const ariaId = useId();
    function saveLastOutSideActiveElementRef() {
      if (!contains(wrapperRef.current, document.activeElement)) {
        lastOutSideActiveElementRef.current = document.activeElement;
      }
    }
    function focusDialogContent() {
      if (!contains(wrapperRef.current, document.activeElement)) {
        contentRef.current?.focus();
      }
    }
    function doClose() {
      setAnimatedVisible(false);
      if (mask2 && lastOutSideActiveElementRef.current && focusTriggerAfterClose) {
        try {
          lastOutSideActiveElementRef.current.focus({
            preventScroll: true
          });
        } catch (e) {
        }
        lastOutSideActiveElementRef.current = null;
      }
      if (animatedVisible) {
        afterClose?.();
      }
    }
    function onDialogVisibleChanged(newVisible) {
      if (newVisible) {
        focusDialogContent();
      } else {
        doClose();
      }
      afterOpenChange?.(newVisible);
    }
    function onInternalClose(e) {
      onClose?.(e);
    }
    const mouseDownOnMaskRef = reactExports.useRef(false);
    let onWrapperClick = null;
    if (maskClosable) {
      onWrapperClick = (e) => {
        if (wrapperRef.current === e.target && mouseDownOnMaskRef.current) {
          onInternalClose(e);
        }
      };
    }
    function onWrapperMouseDown(e) {
      mouseDownOnMaskRef.current = e.target === wrapperRef.current;
    }
    reactExports.useEffect(() => {
      if (visible) {
        mouseDownOnMaskRef.current = false;
        setAnimatedVisible(true);
        saveLastOutSideActiveElementRef();
        if (wrapperRef.current) {
          const computedWrapStyle = getComputedStyle(wrapperRef.current);
          setIsFixedPos(computedWrapStyle.position === "fixed");
        }
      } else if (animatedVisible && contentRef.current.enableMotion() && !contentRef.current.inMotion()) {
        doClose();
      }
    }, [visible]);
    const mergedStyle = {
      zIndex,
      ...wrapStyle,
      ...modalStyles?.wrapper,
      display: !animatedVisible ? "none" : null
    };
    return reactExports.createElement("div", _extends$N({
      className: clsx(`${prefixCls}-root`, rootClassName),
      style: rootStyle
    }, pickAttrs(props, {
      data: true
    })), reactExports.createElement(Mask, {
      prefixCls,
      visible: mask2 && visible,
      motionName: getMotionName(prefixCls, maskTransitionName, maskAnimation),
      style: {
        zIndex,
        ...maskStyle,
        ...modalStyles?.mask
      },
      maskProps,
      className: modalClassNames?.mask
    }), reactExports.createElement("div", _extends$N({
      className: clsx(`${prefixCls}-wrap`, wrapClassName, modalClassNames?.wrapper),
      ref: wrapperRef,
      onClick: onWrapperClick,
      onMouseDown: onWrapperMouseDown,
      style: mergedStyle
    }, wrapProps), reactExports.createElement(Content, _extends$N({}, props, {
      isFixedPos,
      ref: contentRef,
      closable,
      ariaId,
      prefixCls,
      visible: visible && animatedVisible,
      onClose: onInternalClose,
      onVisibleChanged: onDialogVisibleChanged,
      motionName: getMotionName(prefixCls, transitionName, animation)
    }))));
  };
  function _extends$M() {
    _extends$M = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$M.apply(this, arguments);
  }
  const DialogWrap = (props) => {
    const {
      visible,
      getContainer: getContainer2,
      forceRender,
      destroyOnHidden = false,
      afterClose,
      closable,
      panelRef,
      keyboard = true,
      onClose
    } = props;
    const [animatedVisible, setAnimatedVisible] = reactExports.useState(visible);
    const refContext = reactExports.useMemo(() => ({
      panel: panelRef
    }), [panelRef]);
    const onEsc = ({
      top,
      event
    }) => {
      if (top && keyboard) {
        event.stopPropagation();
        onClose?.(event);
        return;
      }
    };
    reactExports.useEffect(() => {
      if (visible) {
        setAnimatedVisible(true);
      }
    }, [visible]);
    if (!forceRender && destroyOnHidden && !animatedVisible) {
      return null;
    }
    return reactExports.createElement(RefContext.Provider, {
      value: refContext
    }, reactExports.createElement(Portal, {
      open: visible || forceRender || animatedVisible,
      onEsc,
      autoDestroy: false,
      getContainer: getContainer2,
      autoLock: visible || animatedVisible
    }, reactExports.createElement(Dialog, _extends$M({}, props, {
      destroyOnHidden,
      afterClose: () => {
        const closableObj = closable && typeof closable === "object" ? closable : {};
        const {
          afterClose: closableAfterClose
        } = closableObj || {};
        closableAfterClose?.();
        afterClose?.();
        setAnimatedVisible(false);
      }
    }))));
  };
  const HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
  const warningFunc = () => {
    warningOnce(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
  };
  const Context$1 = reactExports.createContext({
    getFieldValue: warningFunc,
    getFieldsValue: warningFunc,
    getFieldError: warningFunc,
    getFieldWarning: warningFunc,
    getFieldsError: warningFunc,
    isFieldsTouched: warningFunc,
    isFieldTouched: warningFunc,
    isFieldValidating: warningFunc,
    isFieldsValidating: warningFunc,
    resetFields: warningFunc,
    setFields: warningFunc,
    setFieldValue: warningFunc,
    setFieldsValue: warningFunc,
    validateFields: warningFunc,
    submit: warningFunc,
    getInternalHooks: () => {
      warningFunc();
      return {
        dispatch: warningFunc,
        initEntityValue: warningFunc,
        registerField: warningFunc,
        useSubscribe: warningFunc,
        setInitialValues: warningFunc,
        destroyForm: warningFunc,
        setCallbacks: warningFunc,
        registerWatch: warningFunc,
        getFields: warningFunc,
        setValidateMessages: warningFunc,
        setPreserve: warningFunc,
        getInitialValue: warningFunc
      };
    }
  });
  const ListContext = reactExports.createContext(null);
  function toArray$2(value) {
    if (value === void 0 || value === null) {
      return [];
    }
    return Array.isArray(value) ? value : [value];
  }
  function isFormInstance(form) {
    return form && !!form._init;
  }
  function newMessages() {
    return {
      default: "Validation error on field %s",
      required: "%s is required",
      enum: "%s must be one of %s",
      whitespace: "%s cannot be empty",
      date: {
        format: "%s date %s is invalid for format %s",
        parse: "%s date could not be parsed, %s is invalid ",
        invalid: "%s date %s is invalid"
      },
      types: {
        string: "%s is not a %s",
        method: "%s is not a %s (function)",
        array: "%s is not an %s",
        object: "%s is not an %s",
        number: "%s is not a %s",
        date: "%s is not a %s",
        boolean: "%s is not a %s",
        integer: "%s is not an %s",
        float: "%s is not a %s",
        regexp: "%s is not a valid %s",
        email: "%s is not a valid %s",
        tel: "%s is not a valid %s",
        url: "%s is not a valid %s",
        hex: "%s is not a valid %s"
      },
      string: {
        len: "%s must be exactly %s characters",
        min: "%s must be at least %s characters",
        max: "%s cannot be longer than %s characters",
        range: "%s must be between %s and %s characters"
      },
      number: {
        len: "%s must equal %s",
        min: "%s cannot be less than %s",
        max: "%s cannot be greater than %s",
        range: "%s must be between %s and %s"
      },
      array: {
        len: "%s must be exactly %s in length",
        min: "%s cannot be less than %s in length",
        max: "%s cannot be greater than %s in length",
        range: "%s must be between %s and %s in length"
      },
      pattern: {
        mismatch: "%s value %s does not match pattern %s"
      },
      clone: function clone2() {
        var cloned = JSON.parse(JSON.stringify(this));
        cloned.clone = this.clone;
        return cloned;
      }
    };
  }
  var messages = newMessages();
  function _isNativeFunction(t2) {
    try {
      return -1 !== Function.toString.call(t2).indexOf("[native code]");
    } catch (n2) {
      return "function" == typeof t2;
    }
  }
  function _construct(t2, e, r2) {
    if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
    var o2 = [null];
    o2.push.apply(o2, e);
    var p2 = new (t2.bind.apply(t2, o2))();
    return r2 && _setPrototypeOf(p2, r2.prototype), p2;
  }
  function _wrapNativeSuper(t2) {
    var r2 = "function" == typeof Map ? new Map() : void 0;
    return _wrapNativeSuper = function _wrapNativeSuper2(t3) {
      if (null === t3 || !_isNativeFunction(t3)) return t3;
      if ("function" != typeof t3) throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== r2) {
        if (r2.has(t3)) return r2.get(t3);
        r2.set(t3, Wrapper2);
      }
      function Wrapper2() {
        return _construct(t3, arguments, _getPrototypeOf(this).constructor);
      }
      return Wrapper2.prototype = Object.create(t3.prototype, {
        constructor: {
          value: Wrapper2,
          enumerable: false,
          writable: true,
          configurable: true
        }
      }), _setPrototypeOf(Wrapper2, t3);
    }, _wrapNativeSuper(t2);
  }
  var formatRegExp = /%[sdj%]/g;
  var warning = function warning2() {
  };
  function convertFieldsError(errors) {
    if (!errors || !errors.length) return null;
    var fields = {};
    errors.forEach(function(error) {
      var field = error.field;
      fields[field] = fields[field] || [];
      fields[field].push(error);
    });
    return fields;
  }
  function format(template) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var i2 = 0;
    var len = args.length;
    if (typeof template === "function") {
      return template.apply(null, args);
    }
    if (typeof template === "string") {
      var str = template.replace(formatRegExp, function(x) {
        if (x === "%%") {
          return "%";
        }
        if (i2 >= len) {
          return x;
        }
        switch (x) {
          case "%s":
            return String(args[i2++]);
          case "%d":
            return Number(args[i2++]);
          case "%j":
            try {
              return JSON.stringify(args[i2++]);
            } catch (_2) {
              return "[Circular]";
            }
            break;
          default:
            return x;
        }
      });
      return str;
    }
    return template;
  }
  function isNativeStringType(type4) {
    return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern" || type4 === "tel";
  }
  function isEmptyValue(value, type4) {
    if (value === void 0 || value === null) {
      return true;
    }
    if (type4 === "array" && Array.isArray(value) && !value.length) {
      return true;
    }
    if (isNativeStringType(type4) && typeof value === "string" && !value) {
      return true;
    }
    return false;
  }
  function asyncParallelArray(arr, func, callback) {
    var results = [];
    var total = 0;
    var arrLength = arr.length;
    function count(errors) {
      results.push.apply(results, _toConsumableArray(errors || []));
      total++;
      if (total === arrLength) {
        callback(results);
      }
    }
    arr.forEach(function(a2) {
      func(a2, count);
    });
  }
  function asyncSerialArray(arr, func, callback) {
    var index = 0;
    var arrLength = arr.length;
    function next2(errors) {
      if (errors && errors.length) {
        callback(errors);
        return;
      }
      var original = index;
      index = index + 1;
      if (original < arrLength) {
        func(arr[original], next2);
      } else {
        callback([]);
      }
    }
    next2([]);
  }
  function flattenObjArr(objArr) {
    var ret = [];
    Object.keys(objArr).forEach(function(k) {
      ret.push.apply(ret, _toConsumableArray(objArr[k] || []));
    });
    return ret;
  }
  var AsyncValidationError = (function(_Error) {
    _inherits(AsyncValidationError2, _Error);
    var _super = _createSuper(AsyncValidationError2);
    function AsyncValidationError2(errors, fields) {
      var _this;
      _classCallCheck(this, AsyncValidationError2);
      _this = _super.call(this, "Async Validation Error");
      _defineProperty$1(_assertThisInitialized(_this), "errors", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "fields", void 0);
      _this.errors = errors;
      _this.fields = fields;
      return _this;
    }
    return _createClass(AsyncValidationError2);
  })( _wrapNativeSuper(Error));
  function asyncMap(objArr, option, func, callback, source) {
    if (option.first) {
      var _pending = new Promise(function(resolve, reject) {
        var next2 = function next22(errors) {
          callback(errors);
          return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
        };
        var flattenArr = flattenObjArr(objArr);
        asyncSerialArray(flattenArr, func, next2);
      });
      _pending.catch(function(e) {
        return e;
      });
      return _pending;
    }
    var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
    var objArrKeys = Object.keys(objArr);
    var objArrLength = objArrKeys.length;
    var total = 0;
    var results = [];
    var pending = new Promise(function(resolve, reject) {
      var next2 = function next22(errors) {
        results.push.apply(results, errors);
        total++;
        if (total === objArrLength) {
          callback(results);
          return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
        }
      };
      if (!objArrKeys.length) {
        callback(results);
        resolve(source);
      }
      objArrKeys.forEach(function(key) {
        var arr = objArr[key];
        if (firstFields.indexOf(key) !== -1) {
          asyncSerialArray(arr, func, next2);
        } else {
          asyncParallelArray(arr, func, next2);
        }
      });
    });
    pending.catch(function(e) {
      return e;
    });
    return pending;
  }
  function isErrorObj(obj) {
    return !!(obj && obj.message !== void 0);
  }
  function getValue(value, path) {
    var v = value;
    for (var i2 = 0; i2 < path.length; i2++) {
      if (v == void 0) {
        return v;
      }
      v = v[path[i2]];
    }
    return v;
  }
  function complementError(rule, source) {
    return function(oe) {
      var fieldValue;
      if (rule.fullFields) {
        fieldValue = getValue(source, rule.fullFields);
      } else {
        fieldValue = source[oe.field || rule.fullField];
      }
      if (isErrorObj(oe)) {
        oe.field = oe.field || rule.fullField;
        oe.fieldValue = fieldValue;
        return oe;
      }
      return {
        message: typeof oe === "function" ? oe() : oe,
        fieldValue,
        field: oe.field || rule.fullField
      };
    };
  }
  function deepMerge(target, source) {
    if (source) {
      for (var s2 in source) {
        if (source.hasOwnProperty(s2)) {
          var value = source[s2];
          if (_typeof$2(value) === "object" && _typeof$2(target[s2]) === "object") {
            target[s2] = _objectSpread2(_objectSpread2({}, target[s2]), value);
          } else {
            target[s2] = value;
          }
        }
      }
    }
    return target;
  }
  var ENUM$1 = "enum";
  var enumerable$1 = function enumerable(rule, value, source, errors, options) {
    rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
    if (rule[ENUM$1].indexOf(value) === -1) {
      errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
    }
  };
  var pattern$2 = function pattern(rule, value, source, errors, options) {
    if (rule.pattern) {
      if (rule.pattern instanceof RegExp) {
        rule.pattern.lastIndex = 0;
        if (!rule.pattern.test(value)) {
          errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      } else if (typeof rule.pattern === "string") {
        var _pattern = new RegExp(rule.pattern);
        if (!_pattern.test(value)) {
          errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      }
    }
  };
  var range = function range2(rule, value, source, errors, options) {
    var len = typeof rule.len === "number";
    var min = typeof rule.min === "number";
    var max = typeof rule.max === "number";
    var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var val = value;
    var key = null;
    var num = typeof value === "number";
    var str = typeof value === "string";
    var arr = Array.isArray(value);
    if (num) {
      key = "number";
    } else if (str) {
      key = "string";
    } else if (arr) {
      key = "array";
    }
    if (!key) {
      return false;
    }
    if (arr) {
      val = value.length;
    }
    if (str) {
      val = value.replace(spRegexp, "_").length;
    }
    if (len) {
      if (val !== rule.len) {
        errors.push(format(options.messages[key].len, rule.fullField, rule.len));
      }
    } else if (min && !max && val < rule.min) {
      errors.push(format(options.messages[key].min, rule.fullField, rule.min));
    } else if (max && !min && val > rule.max) {
      errors.push(format(options.messages[key].max, rule.fullField, rule.max));
    } else if (min && max && (val < rule.min || val > rule.max)) {
      errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
    }
  };
  var required$1 = function required(rule, value, source, errors, options, type4) {
    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
      errors.push(format(options.messages.required, rule.fullField));
    }
  };
  var urlReg;
  const getUrlRegex = (function() {
    if (urlReg) {
      return urlReg;
    }
    var word = "[a-fA-F\\d:]";
    var b = function b2(options) {
      return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=".concat(word, ")|(?<=").concat(word, ")(?=\\s|$))") : "";
    };
    var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
    var v6seg = "[a-fA-F\\d]{1,4}";
    var v6List = [
      "(?:".concat(v6seg, ":){7}(?:").concat(v6seg, "|:)"),
"(?:".concat(v6seg, ":){6}(?:").concat(v4, "|:").concat(v6seg, "|:)"),
"(?:".concat(v6seg, ":){5}(?::").concat(v4, "|(?::").concat(v6seg, "){1,2}|:)"),
"(?:".concat(v6seg, ":){4}(?:(?::").concat(v6seg, "){0,1}:").concat(v4, "|(?::").concat(v6seg, "){1,3}|:)"),
"(?:".concat(v6seg, ":){3}(?:(?::").concat(v6seg, "){0,2}:").concat(v4, "|(?::").concat(v6seg, "){1,4}|:)"),
"(?:".concat(v6seg, ":){2}(?:(?::").concat(v6seg, "){0,3}:").concat(v4, "|(?::").concat(v6seg, "){1,5}|:)"),
"(?:".concat(v6seg, ":){1}(?:(?::").concat(v6seg, "){0,4}:").concat(v4, "|(?::").concat(v6seg, "){1,6}|:)"),
"(?::(?:(?::".concat(v6seg, "){0,5}:").concat(v4, "|(?::").concat(v6seg, "){1,7}|:))")
];
    var v6Eth0 = "(?:%[0-9a-zA-Z]{1,})?";
    var v6 = "(?:".concat(v6List.join("|"), ")").concat(v6Eth0);
    var v46Exact = new RegExp("(?:^".concat(v4, "$)|(?:^").concat(v6, "$)"));
    var v4exact = new RegExp("^".concat(v4, "$"));
    var v6exact = new RegExp("^".concat(v6, "$"));
    var ip = function ip2(options) {
      return options && options.exact ? v46Exact : new RegExp("(?:".concat(b(options)).concat(v4).concat(b(options), ")|(?:").concat(b(options)).concat(v6).concat(b(options), ")"), "g");
    };
    ip.v4 = function(options) {
      return options && options.exact ? v4exact : new RegExp("".concat(b(options)).concat(v4).concat(b(options)), "g");
    };
    ip.v6 = function(options) {
      return options && options.exact ? v6exact : new RegExp("".concat(b(options)).concat(v6).concat(b(options)), "g");
    };
    var protocol = "(?:(?:[a-z]+:)?//)";
    var auth = "(?:\\S+(?::\\S*)?@)?";
    var ipv4 = ip.v4().source;
    var ipv6 = ip.v6().source;
    var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
    var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
    var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
    var port = "(?::\\d{2,5})?";
    var path = '(?:[/?#][^\\s"]*)?';
    var regex = "(?:".concat(protocol, "|www\\.)").concat(auth, "(?:localhost|").concat(ipv4, "|").concat(ipv6, "|").concat(host).concat(domain).concat(tld, ")").concat(port).concat(path);
    urlReg = new RegExp("(?:^".concat(regex, "$)"), "i");
    return urlReg;
  });
  var pattern$1 = {
email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,




tel: /^(\+[0-9]{1,3}[-\s\u2011]?)?(\([0-9]{1,4}\)[-\s\u2011]?)?([0-9]+[-\s\u2011]?)*[0-9]+$/,
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
  };
  var types = {
    integer: function integer(value) {
      return types.number(value) && parseInt(value, 10) === value;
    },
    float: function float(value) {
      return types.number(value) && !types.integer(value);
    },
    array: function array(value) {
      return Array.isArray(value);
    },
    regexp: function regexp(value) {
      if (value instanceof RegExp) {
        return true;
      }
      try {
        return !!new RegExp(value);
      } catch (e) {
        return false;
      }
    },
    date: function date(value) {
      return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
    },
    number: function number(value) {
      if (isNaN(value)) {
        return false;
      }
      return typeof value === "number";
    },
    object: function object(value) {
      return _typeof$2(value) === "object" && !types.array(value);
    },
    method: function method(value) {
      return typeof value === "function";
    },
    email: function email(value) {
      return typeof value === "string" && value.length <= 320 && !!value.match(pattern$1.email);
    },
    tel: function tel(value) {
      return typeof value === "string" && value.length <= 32 && !!value.match(pattern$1.tel);
    },
    url: function url(value) {
      return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
    },
    hex: function hex(value) {
      return typeof value === "string" && !!value.match(pattern$1.hex);
    }
  };
  var type$1 = function type(rule, value, source, errors, options) {
    if (rule.required && value === void 0) {
      required$1(rule, value, source, errors, options);
      return;
    }
    var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "tel", "number", "date", "url", "hex"];
    var ruleType = rule.type;
    if (custom.indexOf(ruleType) > -1) {
      if (!types[ruleType](value)) {
        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    } else if (ruleType && _typeof$2(value) !== rule.type) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  };
  var whitespace = function whitespace2(rule, value, source, errors, options) {
    if (/^\s+$/.test(value) || value === "") {
      errors.push(format(options.messages.whitespace, rule.fullField));
    }
  };
  const rules = {
    required: required$1,
    whitespace,
    type: type$1,
    range,
    enum: enumerable$1,
    pattern: pattern$2
  };
  var any = function any2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
    }
    callback(errors);
  };
  var array2 = function array3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if ((value === void 0 || value === null) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, "array");
      if (value !== void 0 && value !== null) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var boolean = function boolean2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var date2 = function date3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "date") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value, "date")) {
        var dateObject;
        if (value instanceof Date) {
          dateObject = value;
        } else {
          dateObject = new Date(value);
        }
        rules.type(rule, dateObject, source, errors, options);
        if (dateObject) {
          rules.range(rule, dateObject.getTime(), source, errors, options);
        }
      }
    }
    callback(errors);
  };
  var ENUM = "enum";
  var enumerable2 = function enumerable3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules[ENUM](rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var floatFn = function floatFn2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var integer2 = function integer3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var method2 = function method3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var number$1 = function number2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (value === "") {
        value = void 0;
      }
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var object2 = function object3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var pattern2 = function pattern3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value, "string")) {
        rules.pattern(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var regexp2 = function regexp3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var required2 = function required3(rule, value, callback, source, options) {
    var errors = [];
    var type4 = Array.isArray(value) ? "array" : _typeof$2(value);
    rules.required(rule, value, source, errors, options, type4);
    callback(errors);
  };
  var string = function string2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, "string");
      if (!isEmptyValue(value, "string")) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
        rules.pattern(rule, value, source, errors, options);
        if (rule.whitespace === true) {
          rules.whitespace(rule, value, source, errors, options);
        }
      }
    }
    callback(errors);
  };
  var type2 = function type3(rule, value, callback, source, options) {
    var ruleType = rule.type;
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, ruleType) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, ruleType);
      if (!isEmptyValue(value, ruleType)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  const validators = {
    string,
    method: method2,
    number: number$1,
    boolean,
    regexp: regexp2,
    integer: integer2,
    float: floatFn,
    array: array2,
    object: object2,
    enum: enumerable2,
    pattern: pattern2,
    date: date2,
    url: type2,
    hex: type2,
    email: type2,
    tel: type2,
    required: required2,
    any
  };
  var Schema = (function() {
    function Schema2(descriptor) {
      _classCallCheck(this, Schema2);
      _defineProperty$1(this, "rules", null);
      _defineProperty$1(this, "_messages", messages);
      this.define(descriptor);
    }
    _createClass(Schema2, [{
      key: "define",
      value: function define(rules2) {
        var _this = this;
        if (!rules2) {
          throw new Error("Cannot configure a schema with no rules");
        }
        if (_typeof$2(rules2) !== "object" || Array.isArray(rules2)) {
          throw new Error("Rules must be an object");
        }
        this.rules = {};
        Object.keys(rules2).forEach(function(name) {
          var item = rules2[name];
          _this.rules[name] = Array.isArray(item) ? item : [item];
        });
      }
    }, {
      key: "messages",
      value: function messages2(_messages) {
        if (_messages) {
          this._messages = deepMerge(newMessages(), _messages);
        }
        return this._messages;
      }
    }, {
      key: "validate",
      value: function validate(source_) {
        var _this2 = this;
        var o2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var oc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
        };
        var source = source_;
        var options = o2;
        var callback = oc;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (!this.rules || Object.keys(this.rules).length === 0) {
          if (callback) {
            callback(null, source);
          }
          return Promise.resolve(source);
        }
        function complete(results) {
          var errors = [];
          var fields = {};
          function add2(e) {
            if (Array.isArray(e)) {
              var _errors;
              errors = (_errors = errors).concat.apply(_errors, _toConsumableArray(e));
            } else {
              errors.push(e);
            }
          }
          for (var i2 = 0; i2 < results.length; i2++) {
            add2(results[i2]);
          }
          if (!errors.length) {
            callback(null, source);
          } else {
            fields = convertFieldsError(errors);
            callback(errors, fields);
          }
        }
        if (options.messages) {
          var messages$1 = this.messages();
          if (messages$1 === messages) {
            messages$1 = newMessages();
          }
          deepMerge(messages$1, options.messages);
          options.messages = messages$1;
        } else {
          options.messages = this.messages();
        }
        var series = {};
        var keys2 = options.keys || Object.keys(this.rules);
        keys2.forEach(function(z) {
          var arr = _this2.rules[z];
          var value = source[z];
          arr.forEach(function(r2) {
            var rule = r2;
            if (typeof rule.transform === "function") {
              if (source === source_) {
                source = _objectSpread2({}, source);
              }
              value = source[z] = rule.transform(value);
              if (value !== void 0 && value !== null) {
                rule.type = rule.type || (Array.isArray(value) ? "array" : _typeof$2(value));
              }
            }
            if (typeof rule === "function") {
              rule = {
                validator: rule
              };
            } else {
              rule = _objectSpread2({}, rule);
            }
            rule.validator = _this2.getValidationMethod(rule);
            if (!rule.validator) {
              return;
            }
            rule.field = z;
            rule.fullField = rule.fullField || z;
            rule.type = _this2.getType(rule);
            series[z] = series[z] || [];
            series[z].push({
              rule,
              value,
              source,
              field: z
            });
          });
        });
        var errorFields = {};
        return asyncMap(series, options, function(data2, doIt) {
          var rule = data2.rule;
          var deep = (rule.type === "object" || rule.type === "array") && (_typeof$2(rule.fields) === "object" || _typeof$2(rule.defaultField) === "object");
          deep = deep && (rule.required || !rule.required && data2.value);
          rule.field = data2.field;
          function addFullField(key, schema) {
            return _objectSpread2(_objectSpread2({}, schema), {}, {
              fullField: "".concat(rule.fullField, ".").concat(key),
              fullFields: rule.fullFields ? [].concat(_toConsumableArray(rule.fullFields), [key]) : [key]
            });
          }
          function cb() {
            var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            var errorList = Array.isArray(e) ? e : [e];
            if (!options.suppressWarning && errorList.length) {
              Schema2.warning("async-validator:", errorList);
            }
            if (errorList.length && rule.message !== void 0 && rule.message !== null) {
              errorList = [].concat(rule.message);
            }
            var filledErrors = errorList.map(complementError(rule, source));
            if (options.first && filledErrors.length) {
              errorFields[rule.field] = 1;
              return doIt(filledErrors);
            }
            if (!deep) {
              doIt(filledErrors);
            } else {
              if (rule.required && !data2.value) {
                if (rule.message !== void 0) {
                  filledErrors = [].concat(rule.message).map(complementError(rule, source));
                } else if (options.error) {
                  filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                }
                return doIt(filledErrors);
              }
              var fieldsSchema = {};
              if (rule.defaultField) {
                Object.keys(data2.value).map(function(key) {
                  fieldsSchema[key] = rule.defaultField;
                });
              }
              fieldsSchema = _objectSpread2(_objectSpread2({}, fieldsSchema), data2.rule.fields);
              var paredFieldsSchema = {};
              Object.keys(fieldsSchema).forEach(function(field) {
                var fieldSchema = fieldsSchema[field];
                var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
              });
              var schema = new Schema2(paredFieldsSchema);
              schema.messages(options.messages);
              if (data2.rule.options) {
                data2.rule.options.messages = options.messages;
                data2.rule.options.error = options.error;
              }
              schema.validate(data2.value, data2.rule.options || options, function(errs) {
                var finalErrors = [];
                if (filledErrors && filledErrors.length) {
                  finalErrors.push.apply(finalErrors, _toConsumableArray(filledErrors));
                }
                if (errs && errs.length) {
                  finalErrors.push.apply(finalErrors, _toConsumableArray(errs));
                }
                doIt(finalErrors.length ? finalErrors : null);
              });
            }
          }
          var res;
          if (rule.asyncValidator) {
            res = rule.asyncValidator(rule, data2.value, cb, data2.source, options);
          } else if (rule.validator) {
            try {
              res = rule.validator(rule, data2.value, cb, data2.source, options);
            } catch (error) {
              var _console$error, _console;
              (_console$error = (_console = console).error) === null || _console$error === void 0 || _console$error.call(_console, error);
              if (!options.suppressValidatorError) {
                setTimeout(function() {
                  throw error;
                }, 0);
              }
              cb(error.message);
            }
            if (res === true) {
              cb();
            } else if (res === false) {
              cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || "".concat(rule.fullField || rule.field, " fails"));
            } else if (res instanceof Array) {
              cb(res);
            } else if (res instanceof Error) {
              cb(res.message);
            }
          }
          if (res && res.then) {
            res.then(function() {
              return cb();
            }, function(e) {
              return cb(e);
            });
          }
        }, function(results) {
          complete(results);
        }, source);
      }
    }, {
      key: "getType",
      value: function getType(rule) {
        if (rule.type === void 0 && rule.pattern instanceof RegExp) {
          rule.type = "pattern";
        }
        if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
          throw new Error(format("Unknown rule type %s", rule.type));
        }
        return rule.type || "string";
      }
    }, {
      key: "getValidationMethod",
      value: function getValidationMethod(rule) {
        if (typeof rule.validator === "function") {
          return rule.validator;
        }
        var keys2 = Object.keys(rule);
        var messageIndex = keys2.indexOf("message");
        if (messageIndex !== -1) {
          keys2.splice(messageIndex, 1);
        }
        if (keys2.length === 1 && keys2[0] === "required") {
          return validators.required;
        }
        return validators[this.getType(rule)] || void 0;
      }
    }]);
    return Schema2;
  })();
  _defineProperty$1(Schema, "register", function register(type4, validator) {
    if (typeof validator !== "function") {
      throw new Error("Cannot register a validator by type, validator is not a function");
    }
    validators[type4] = validator;
  });
  _defineProperty$1(Schema, "warning", warning);
  _defineProperty$1(Schema, "messages", messages);
  _defineProperty$1(Schema, "validators", validators);
  const typeTemplate = "'${name}' is not a valid ${type}";
  const defaultValidateMessages = {
    default: "Validation error on field '${name}'",
    required: "'${name}' is required",
    enum: "'${name}' must be one of [${enum}]",
    whitespace: "'${name}' cannot be empty",
    date: {
      format: "'${name}' is invalid for format date",
      parse: "'${name}' could not be parsed as date",
      invalid: "'${name}' is invalid date"
    },
    types: {
      string: typeTemplate,
      method: typeTemplate,
      array: typeTemplate,
      object: typeTemplate,
      number: typeTemplate,
      date: typeTemplate,
      boolean: typeTemplate,
      integer: typeTemplate,
      float: typeTemplate,
      regexp: typeTemplate,
      email: typeTemplate,
      tel: typeTemplate,
      url: typeTemplate,
      hex: typeTemplate
    },
    string: {
      len: "'${name}' must be exactly ${len} characters",
      min: "'${name}' must be at least ${min} characters",
      max: "'${name}' cannot be longer than ${max} characters",
      range: "'${name}' must be between ${min} and ${max} characters"
    },
    number: {
      len: "'${name}' must equal ${len}",
      min: "'${name}' cannot be less than ${min}",
      max: "'${name}' cannot be greater than ${max}",
      range: "'${name}' must be between ${min} and ${max}"
    },
    array: {
      len: "'${name}' must be exactly ${len} in length",
      min: "'${name}' cannot be less than ${min} in length",
      max: "'${name}' cannot be greater than ${max} in length",
      range: "'${name}' must be between ${min} and ${max} in length"
    },
    pattern: {
      mismatch: "'${name}' does not match pattern ${pattern}"
    }
  };
  const AsyncValidator = Schema;
  function replaceMessage(template, kv) {
    return template.replace(/\\?\$\{\w+\}/g, (str) => {
      if (str.startsWith("\\")) {
        return str.slice(1);
      }
      const key = str.slice(2, -1);
      return kv[key];
    });
  }
  const CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
  async function validateRule(name, value, rule, options, messageVariables) {
    const cloneRule = {
      ...rule
    };
    delete cloneRule.ruleIndex;
    AsyncValidator.warning = () => void 0;
    if (cloneRule.validator) {
      const originValidator = cloneRule.validator;
      cloneRule.validator = (...args) => {
        try {
          return originValidator(...args);
        } catch (error) {
          console.error(error);
          return Promise.reject(CODE_LOGIC_ERROR);
        }
      };
    }
    let subRuleField = null;
    if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
      subRuleField = cloneRule.defaultField;
      delete cloneRule.defaultField;
    }
    const validator = new AsyncValidator({
      [name]: [cloneRule]
    });
    const messages2 = merge$2(defaultValidateMessages, options.validateMessages);
    validator.messages(messages2);
    let result = [];
    try {
      await Promise.resolve(validator.validate({
        [name]: value
      }, {
        ...options
      }));
    } catch (errObj) {
      if (errObj.errors) {
        result = errObj.errors.map(({
          message: message2
        }, index) => {
          const mergedMessage = message2 === CODE_LOGIC_ERROR ? messages2.default : message2;
          return reactExports.isValidElement(mergedMessage) ? (

reactExports.cloneElement(mergedMessage, {
              key: `error_${index}`
            })
          ) : mergedMessage;
        });
      }
    }
    if (!result.length && subRuleField && Array.isArray(value) && value.length > 0) {
      const subResults = await Promise.all(value.map((subValue, i2) => validateRule(`${name}.${i2}`, subValue, subRuleField, options, messageVariables)));
      return subResults.reduce((prev2, errors) => [...prev2, ...errors], []);
    }
    const kv = {
      ...rule,
      name,
      enum: (rule.enum || []).join(", "),
      ...messageVariables
    };
    const fillVariableResult = result.map((error) => {
      if (typeof error === "string") {
        return replaceMessage(error, kv);
      }
      return error;
    });
    return fillVariableResult;
  }
  function validateRules(namePath, value, rules2, options, validateFirst, messageVariables) {
    const name = namePath.join(".");
    const filledRules = rules2.map((currentRule, ruleIndex) => {
      const originValidatorFunc = currentRule.validator;
      const cloneRule = {
        ...currentRule,
        ruleIndex
      };
      if (originValidatorFunc) {
        cloneRule.validator = (rule, val, callback) => {
          let hasPromise = false;
          const wrappedCallback = (...args) => {
            Promise.resolve().then(() => {
              warningOnce(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
              if (!hasPromise) {
                callback(...args);
              }
            });
          };
          const promise = originValidatorFunc(rule, val, wrappedCallback);
          hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
          warningOnce(hasPromise, "`callback` is deprecated. Please return a promise instead.");
          if (hasPromise) {
            promise.then(() => {
              callback();
            }).catch((err) => {
              callback(err || " ");
            });
          }
        };
      }
      return cloneRule;
    }).sort(({
      warningOnly: w1,
      ruleIndex: i1
    }, {
      warningOnly: w2,
      ruleIndex: i2
    }) => {
      if (!!w1 === !!w2) {
        return i1 - i2;
      }
      if (w1) {
        return 1;
      }
      return -1;
    });
    let summaryPromise;
    if (validateFirst === true) {
      summaryPromise = new Promise(async (resolve, reject) => {
        for (let i2 = 0; i2 < filledRules.length; i2 += 1) {
          const rule = filledRules[i2];
          const errors = await validateRule(name, value, rule, options, messageVariables);
          if (errors.length) {
            reject([{
              errors,
              rule
            }]);
            return;
          }
        }
        resolve([]);
      });
    } else {
      const rulePromises = filledRules.map((rule) => validateRule(name, value, rule, options, messageVariables).then((errors) => ({
        errors,
        rule
      })));
      summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then((errors) => {
        return Promise.reject(errors);
      });
    }
    summaryPromise.catch((e) => e);
    return summaryPromise;
  }
  async function finishOnAllFailed(rulePromises) {
    return Promise.all(rulePromises).then((errorsList) => {
      const errors = [].concat(...errorsList);
      return errors;
    });
  }
  async function finishOnFirstFailed(rulePromises) {
    let count = 0;
    return new Promise((resolve) => {
      rulePromises.forEach((promise) => {
        promise.then((ruleError) => {
          if (ruleError.errors.length) {
            resolve([ruleError]);
          }
          count += 1;
          if (count === rulePromises.length) {
            resolve([]);
          }
        });
      });
    });
  }
  function getNamePath(path) {
    return toArray$2(path);
  }
  function cloneByNamePathList(store2, namePathList) {
    let newStore = {};
    namePathList.forEach((namePath) => {
      const value = get(store2, namePath);
      newStore = set(newStore, namePath, value);
    });
    return newStore;
  }
  function containsNamePath(namePathList, namePath, partialMatch = false) {
    return namePathList && namePathList.some((path) => matchNamePath(namePath, path, partialMatch));
  }
  function matchNamePath(namePath, subNamePath, partialMatch = false) {
    if (!namePath || !subNamePath) {
      return false;
    }
    if (!partialMatch && namePath.length !== subNamePath.length) {
      return false;
    }
    return subNamePath.every((nameUnit, i2) => namePath[i2] === nameUnit);
  }
  function isSimilar(source, target) {
    if (source === target) {
      return true;
    }
    if (!source && target || source && !target) {
      return false;
    }
    if (!source || !target || typeof source !== "object" || typeof target !== "object") {
      return false;
    }
    const sourceKeys = Object.keys(source);
    const targetKeys = Object.keys(target);
    const keys2 = new Set([...sourceKeys, ...targetKeys]);
    return [...keys2].every((key) => {
      const sourceValue = source[key];
      const targetValue = target[key];
      if (typeof sourceValue === "function" && typeof targetValue === "function") {
        return true;
      }
      return sourceValue === targetValue;
    });
  }
  function defaultGetValueFromEvent(valuePropName, ...args) {
    const event = args[0];
    if (event && event.target && typeof event.target === "object" && valuePropName in event.target) {
      return event.target[valuePropName];
    }
    return event;
  }
  function move(array4, moveIndex, toIndex) {
    const {
      length: length2
    } = array4;
    if (moveIndex < 0 || moveIndex >= length2 || toIndex < 0 || toIndex >= length2) {
      return array4;
    }
    const item = array4[moveIndex];
    const diff = moveIndex - toIndex;
    if (diff > 0) {
      return [...array4.slice(0, toIndex), item, ...array4.slice(toIndex, moveIndex), ...array4.slice(moveIndex + 1, length2)];
    }
    if (diff < 0) {
      return [...array4.slice(0, moveIndex), ...array4.slice(moveIndex + 1, toIndex + 1), item, ...array4.slice(toIndex + 1, length2)];
    }
    return array4;
  }
  function _extends$L() {
    _extends$L = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$L.apply(this, arguments);
  }
  const EMPTY_ERRORS = [];
  const EMPTY_WARNINGS = [];
  function requireUpdate(shouldUpdate, prev2, next2, prevValue, nextValue, info) {
    if (typeof shouldUpdate === "function") {
      return shouldUpdate(prev2, next2, "source" in info ? {
        source: info.source
      } : {});
    }
    return prevValue !== nextValue;
  }
  class Field extends reactExports.Component {
    static contextType = Context$1;
    state = {
      resetCount: 0
    };
    cancelRegisterFunc = null;
    mounted = false;
touched = false;
dirty = false;
    validatePromise;
    prevValidating;
    errors = EMPTY_ERRORS;
    warnings = EMPTY_WARNINGS;
constructor(props) {
      super(props);
      if (props.fieldContext) {
        const {
          getInternalHooks
        } = props.fieldContext;
        const {
          initEntityValue
        } = getInternalHooks(HOOK_MARK);
        initEntityValue(this);
      }
    }
    componentDidMount() {
      const {
        shouldUpdate,
        fieldContext
      } = this.props;
      this.mounted = true;
      if (fieldContext) {
        const {
          getInternalHooks
        } = fieldContext;
        const {
          registerField
        } = getInternalHooks(HOOK_MARK);
        this.cancelRegisterFunc = registerField(this);
      }
      if (shouldUpdate === true) {
        this.reRender();
      }
    }
    componentWillUnmount() {
      this.cancelRegister();
      this.triggerMetaEvent(true);
      this.mounted = false;
    }
    cancelRegister = () => {
      const {
        preserve: preserve2,
        isListField,
        name
      } = this.props;
      if (this.cancelRegisterFunc) {
        this.cancelRegisterFunc(isListField, preserve2, getNamePath(name));
      }
      this.cancelRegisterFunc = null;
    };
getNamePath = () => {
      const {
        name,
        fieldContext
      } = this.props;
      const {
        prefixName = []
      } = fieldContext;
      return name !== void 0 ? [...prefixName, ...name] : [];
    };
    getRules = () => {
      const {
        rules: rules2 = [],
        fieldContext
      } = this.props;
      return rules2.map((rule) => {
        if (typeof rule === "function") {
          return rule(fieldContext);
        }
        return rule;
      });
    };
    reRender() {
      if (!this.mounted) return;
      this.forceUpdate();
    }
    refresh = () => {
      if (!this.mounted) return;
      this.setState(({
        resetCount
      }) => ({
        resetCount: resetCount + 1
      }));
    };
metaCache = null;
    triggerMetaEvent = (destroy2) => {
      const {
        onMetaChange
      } = this.props;
      if (onMetaChange) {
        const meta = {
          ...this.getMeta(),
          destroy: destroy2
        };
        if (!isEqual$1(this.metaCache, meta)) {
          onMetaChange(meta);
        }
        this.metaCache = meta;
      } else {
        this.metaCache = null;
      }
    };

onStoreChange = (prevStore, namePathList, info) => {
      const {
        shouldUpdate,
        dependencies = [],
        onReset
      } = this.props;
      const {
        store: store2
      } = info;
      const namePath = this.getNamePath();
      const prevValue = this.getValue(prevStore);
      const curValue = this.getValue(store2);
      const namePathMatch = namePathList && containsNamePath(namePathList, namePath);
      if (info.type === "valueUpdate" && info.source === "external" && !isEqual$1(prevValue, curValue)) {
        this.touched = true;
        this.dirty = true;
        this.validatePromise = null;
        this.errors = EMPTY_ERRORS;
        this.warnings = EMPTY_WARNINGS;
        this.triggerMetaEvent();
      }
      switch (info.type) {
        case "reset":
          if (!namePathList || namePathMatch) {
            this.touched = false;
            this.dirty = false;
            this.validatePromise = void 0;
            this.errors = EMPTY_ERRORS;
            this.warnings = EMPTY_WARNINGS;
            this.triggerMetaEvent();
            onReset?.();
            this.refresh();
            return;
          }
          break;
case "remove": {
          if (shouldUpdate && requireUpdate(shouldUpdate, prevStore, store2, prevValue, curValue, info)) {
            this.reRender();
            return;
          }
          break;
        }
        case "setField": {
          const {
            data: data2
          } = info;
          if (namePathMatch) {
            if ("touched" in data2) {
              this.touched = data2.touched;
            }
            if ("validating" in data2 && !("originRCField" in data2)) {
              this.validatePromise = data2.validating ? Promise.resolve([]) : null;
            }
            if ("errors" in data2) {
              this.errors = data2.errors || EMPTY_ERRORS;
            }
            if ("warnings" in data2) {
              this.warnings = data2.warnings || EMPTY_WARNINGS;
            }
            this.dirty = true;
            this.triggerMetaEvent();
            this.reRender();
            return;
          } else if ("value" in data2 && containsNamePath(namePathList, namePath, true)) {
            this.reRender();
            return;
          }
          if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store2, prevValue, curValue, info)) {
            this.reRender();
            return;
          }
          break;
        }
        case "dependenciesUpdate": {
          const dependencyList = dependencies.map(getNamePath);
          if (dependencyList.some((dependency) => containsNamePath(info.relatedFields, dependency))) {
            this.reRender();
            return;
          }
          break;
        }
        default:
          if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store2, prevValue, curValue, info)) {
            this.reRender();
            return;
          }
          break;
      }
      if (shouldUpdate === true) {
        this.reRender();
      }
    };
    validateRules = (options) => {
      const namePath = this.getNamePath();
      const currentValue = this.getValue();
      const {
        triggerName,
        validateOnly = false
      } = options || {};
      const rootPromise = Promise.resolve().then(async () => {
        if (!this.mounted) {
          return [];
        }
        const {
          validateFirst = false,
          messageVariables,
          validateDebounce
        } = this.props;
        let filteredRules = this.getRules();
        if (triggerName) {
          filteredRules = filteredRules.filter((rule) => rule).filter((rule) => {
            const {
              validateTrigger
            } = rule;
            if (!validateTrigger) {
              return true;
            }
            const triggerList = toArray$2(validateTrigger);
            return triggerList.includes(triggerName);
          });
        }
        if (validateDebounce && triggerName) {
          await new Promise((resolve) => {
            setTimeout(resolve, validateDebounce);
          });
          if (this.validatePromise !== rootPromise) {
            return [];
          }
        }
        const promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
        promise.catch((e) => e).then((ruleErrors = EMPTY_ERRORS) => {
          if (this.validatePromise === rootPromise) {
            this.validatePromise = null;
            const nextErrors = [];
            const nextWarnings = [];
            ruleErrors.forEach?.(({
              rule: {
                warningOnly
              },
              errors = EMPTY_ERRORS
            }) => {
              if (warningOnly) {
                nextWarnings.push(...errors);
              } else {
                nextErrors.push(...errors);
              }
            });
            this.errors = nextErrors;
            this.warnings = nextWarnings;
            this.triggerMetaEvent();
            this.reRender();
          }
        });
        return promise;
      });
      if (validateOnly) {
        return rootPromise;
      }
      this.validatePromise = rootPromise;
      this.dirty = true;
      this.errors = EMPTY_ERRORS;
      this.warnings = EMPTY_WARNINGS;
      this.triggerMetaEvent();
      this.reRender();
      return rootPromise;
    };
    isFieldValidating = () => !!this.validatePromise;
    isFieldTouched = () => this.touched;
    isFieldDirty = () => {
      if (this.dirty || this.props.initialValue !== void 0) {
        return true;
      }
      const {
        fieldContext
      } = this.props;
      const {
        getInitialValue
      } = fieldContext.getInternalHooks(HOOK_MARK);
      if (getInitialValue(this.getNamePath()) !== void 0) {
        return true;
      }
      return false;
    };
    getErrors = () => this.errors;
    getWarnings = () => this.warnings;
    isListField = () => this.props.isListField;
    isList = () => this.props.isList;
    isPreserve = () => this.props.preserve;
getMeta = () => {
      this.prevValidating = this.isFieldValidating();
      const meta = {
        touched: this.isFieldTouched(),
        validating: this.prevValidating,
        errors: this.errors,
        warnings: this.warnings,
        name: this.getNamePath(),
        validated: this.validatePromise === null
      };
      return meta;
    };
getOnlyChild = (children) => {
      if (typeof children === "function") {
        const meta = this.getMeta();
        return {
          ...this.getOnlyChild(children(this.getControlled(), meta, this.props.fieldContext)),
          isFunction: true
        };
      }
      const childList = toArray$4(children);
      if (childList.length !== 1 || ! reactExports.isValidElement(childList[0])) {
        return {
          child: childList,
          isFunction: false
        };
      }
      return {
        child: childList[0],
        isFunction: false
      };
    };
getValue = (store2) => {
      const {
        getFieldsValue
      } = this.props.fieldContext;
      const namePath = this.getNamePath();
      return get(store2 || getFieldsValue(true), namePath);
    };
    getControlled = (childProps = {}) => {
      const {
        name,
        trigger: trigger2 = "onChange",
        validateTrigger,
        getValueFromEvent,
        normalize: normalize2,
        valuePropName = "value",
        getValueProps,
        fieldContext
      } = this.props;
      const mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
      const namePath = this.getNamePath();
      const {
        getInternalHooks,
        getFieldsValue
      } = fieldContext;
      const {
        dispatch
      } = getInternalHooks(HOOK_MARK);
      const value = this.getValue();
      const mergedGetValueProps = getValueProps || ((val) => ({
        [valuePropName]: val
      }));
      const originTriggerFunc = childProps[trigger2];
      const valueProps = name !== void 0 ? mergedGetValueProps(value) : {};
      const control = {
        ...childProps,
        ...valueProps
      };
      control[trigger2] = (...args) => {
        this.touched = true;
        this.dirty = true;
        this.triggerMetaEvent();
        let newValue;
        if (getValueFromEvent) {
          newValue = getValueFromEvent(...args);
        } else {
          newValue = defaultGetValueFromEvent(valuePropName, ...args);
        }
        if (normalize2) {
          newValue = normalize2(newValue, value, getFieldsValue(true));
        }
        if (newValue !== value) {
          dispatch({
            type: "updateValue",
            namePath,
            value: newValue
          });
        }
        if (originTriggerFunc) {
          originTriggerFunc(...args);
        }
      };
      const validateTriggerList = toArray$2(mergedValidateTrigger || []);
      validateTriggerList.forEach((triggerName) => {
        const originTrigger = control[triggerName];
        control[triggerName] = (...args) => {
          if (originTrigger) {
            originTrigger(...args);
          }
          const {
            rules: rules2
          } = this.props;
          if (rules2 && rules2.length) {
            dispatch({
              type: "validateField",
              namePath,
              triggerName
            });
          }
        };
      });
      return control;
    };
    render() {
      const {
        resetCount
      } = this.state;
      const {
        children
      } = this.props;
      const {
        child,
        isFunction: isFunction2
      } = this.getOnlyChild(children);
      let returnChildNode;
      if (isFunction2) {
        returnChildNode = child;
      } else if ( reactExports.isValidElement(child)) {
        returnChildNode = reactExports.cloneElement(child, this.getControlled(child.props));
      } else {
        warningOnce(!child, "`children` of Field is not validate ReactElement.");
        returnChildNode = child;
      }
      return reactExports.createElement(reactExports.Fragment, {
        key: resetCount
      }, returnChildNode);
    }
  }
  function WrapperField({
    name,
    ...restProps
  }) {
    const fieldContext = reactExports.useContext(Context$1);
    const listContext = reactExports.useContext(ListContext);
    const namePath = name !== void 0 ? getNamePath(name) : void 0;
    const isMergedListField = restProps.isListField ?? !!listContext;
    let key = "keep";
    if (!isMergedListField) {
      key = `_${(namePath || []).join("_")}`;
    }
    return reactExports.createElement(Field, _extends$L({
      key,
      name: namePath,
      isListField: isMergedListField
    }, restProps, {
      fieldContext
    }));
  }
  function List$1({
    name,
    initialValue: initialValue2,
    children,
    rules: rules2,
    validateTrigger,
    isListField
  }) {
    const context = reactExports.useContext(Context$1);
    const wrapperListContext = reactExports.useContext(ListContext);
    const keyRef = reactExports.useRef({
      keys: [],
      id: 0
    });
    const keyManager = keyRef.current;
    const prefixName = reactExports.useMemo(() => {
      const parentPrefixName = getNamePath(context.prefixName) || [];
      return [...parentPrefixName, ...getNamePath(name)];
    }, [context.prefixName, name]);
    const fieldContext = reactExports.useMemo(() => ({
      ...context,
      prefixName
    }), [context, prefixName]);
    const listContext = reactExports.useMemo(() => ({
      getKey: (namePath) => {
        const len = prefixName.length;
        const pathName = namePath[len];
        return [keyManager.keys[pathName], namePath.slice(len + 1)];
      }
    }), [keyManager, prefixName]);
    if (typeof children !== "function") {
      warningOnce(false, "Form.List only accepts function as children.");
      return null;
    }
    const shouldUpdate = (prevValue, nextValue, {
      source
    }) => {
      if (source === "internal") {
        return false;
      }
      return prevValue !== nextValue;
    };
    return reactExports.createElement(ListContext.Provider, {
      value: listContext
    }, reactExports.createElement(Context$1.Provider, {
      value: fieldContext
    }, reactExports.createElement(WrapperField, {
      name: [],
      shouldUpdate,
      rules: rules2,
      validateTrigger,
      initialValue: initialValue2,
      isList: true,
      isListField: isListField ?? !!wrapperListContext
    }, ({
      value = [],
      onChange
    }, meta) => {
      const {
        getFieldValue
      } = context;
      const getNewValue = () => {
        const values = getFieldValue(prefixName || []);
        return values || [];
      };
      const operations = {
        add: (defaultValue2, index) => {
          const newValue = getNewValue();
          if (index >= 0 && index <= newValue.length) {
            keyManager.keys = [...keyManager.keys.slice(0, index), keyManager.id, ...keyManager.keys.slice(index)];
            onChange([...newValue.slice(0, index), defaultValue2, ...newValue.slice(index)]);
          } else {
            keyManager.keys = [...keyManager.keys, keyManager.id];
            onChange([...newValue, defaultValue2]);
          }
          keyManager.id += 1;
        },
        remove: (index) => {
          const newValue = getNewValue();
          const indexSet = new Set(Array.isArray(index) ? index : [index]);
          if (indexSet.size <= 0) {
            return;
          }
          keyManager.keys = keyManager.keys.filter((_2, keysIndex) => !indexSet.has(keysIndex));
          onChange(newValue.filter((_2, valueIndex) => !indexSet.has(valueIndex)));
        },
        move(from2, to) {
          if (from2 === to) {
            return;
          }
          const newValue = getNewValue();
          if (from2 < 0 || from2 >= newValue.length || to < 0 || to >= newValue.length) {
            return;
          }
          keyManager.keys = move(keyManager.keys, from2, to);
          onChange(move(newValue, from2, to));
        }
      };
      let listValue = value || [];
      if (!Array.isArray(listValue)) {
        listValue = [];
      }
      return children(listValue.map((__, index) => {
        let key = keyManager.keys[index];
        if (key === void 0) {
          keyManager.keys[index] = keyManager.id;
          key = keyManager.keys[index];
          keyManager.id += 1;
        }
        return {
          name: index,
          key,
          isListField: true
        };
      }), operations, meta);
    })));
  }
  function allPromiseFinish(promiseList) {
    let hasError = false;
    let count = promiseList.length;
    const results = [];
    if (!promiseList.length) {
      return Promise.resolve([]);
    }
    return new Promise((resolve, reject) => {
      promiseList.forEach((promise, index) => {
        promise.catch((e) => {
          hasError = true;
          return e;
        }).then((result) => {
          count -= 1;
          results[index] = result;
          if (count > 0) {
            return;
          }
          if (hasError) {
            reject(results);
          }
          resolve(results);
        });
      });
    });
  }
  const SPLIT = "__@field_split__";
  function normalize(namePath) {
    return namePath.map((cell) => `${typeof cell}:${cell}`).join(SPLIT);
  }
  class NameMap {
    kvs = new Map();
    set(key, value) {
      this.kvs.set(normalize(key), value);
    }
    get(key) {
      return this.kvs.get(normalize(key));
    }
    getAsPrefix(key) {
      const normalizedKey = normalize(key);
      const normalizedPrefix = normalizedKey + SPLIT;
      const results = [];
      const current = this.kvs.get(normalizedKey);
      if (current !== void 0) {
        results.push(current);
      }
      this.kvs.forEach((value, itemNormalizedKey) => {
        if (itemNormalizedKey.startsWith(normalizedPrefix)) {
          results.push(value);
        }
      });
      return results;
    }
    update(key, updater) {
      const origin = this.get(key);
      const next2 = updater(origin);
      if (!next2) {
        this.delete(key);
      } else {
        this.set(key, next2);
      }
    }
    delete(key) {
      this.kvs.delete(normalize(key));
    }
map(callback) {
      return [...this.kvs.entries()].map(([key, value]) => {
        const cells = key.split(SPLIT);
        return callback({
          key: cells.map((cell) => {
            const [, type4, unit2] = cell.match(/^([^:]*):(.*)$/);
            return type4 === "number" ? Number(unit2) : unit2;
          }),
          value
        });
      });
    }
    toJSON() {
      const json = {};
      this.map(({
        key,
        value
      }) => {
        json[key.join(".")] = value;
        return null;
      });
      return json;
    }
  }
  const macroTask$1 = (fn) => {
    const channel = new MessageChannel();
    channel.port1.onmessage = fn;
    channel.port2.postMessage(null);
  };
  class WatcherCenter {
    namePathList = [];
    taskId = 0;
    watcherList = new Set();
    form;
    constructor(form) {
      this.form = form;
    }
    register(callback) {
      this.watcherList.add(callback);
      return () => {
        this.watcherList.delete(callback);
      };
    }
    notify(namePath) {
      namePath.forEach((path) => {
        if (this.namePathList.every((exist) => !matchNamePath(exist, path))) {
          this.namePathList.push(path);
        }
      });
      this.doBatch();
    }
    doBatch() {
      this.taskId += 1;
      const currentId = this.taskId;
      macroTask$1(() => {
        if (currentId === this.taskId && this.watcherList.size) {
          const formInst = this.form.getForm();
          const values = formInst.getFieldsValue();
          const allValues = formInst.getFieldsValue(true);
          this.watcherList.forEach((callback) => {
            callback(values, allValues, this.namePathList);
          });
          this.namePathList = [];
        }
      });
    }
  }
  class FormStore {
    formHooked = false;
    forceRootUpdate;
    subscribable = true;
    store = {};
    fieldEntities = [];
    initialValues = {};
    callbacks = {};
    validateMessages = null;
    preserve = null;
    lastValidatePromise = null;
    watcherCenter = new WatcherCenter(this);
    constructor(forceRootUpdate) {
      this.forceRootUpdate = forceRootUpdate;
    }
    getForm = () => ({
      getFieldValue: this.getFieldValue,
      getFieldsValue: this.getFieldsValue,
      getFieldError: this.getFieldError,
      getFieldWarning: this.getFieldWarning,
      getFieldsError: this.getFieldsError,
      isFieldsTouched: this.isFieldsTouched,
      isFieldTouched: this.isFieldTouched,
      isFieldValidating: this.isFieldValidating,
      isFieldsValidating: this.isFieldsValidating,
      resetFields: this.resetFields,
      setFields: this.setFields,
      setFieldValue: this.setFieldValue,
      setFieldsValue: this.setFieldsValue,
      validateFields: this.validateFields,
      submit: this.submit,
      _init: true,
      getInternalHooks: this.getInternalHooks
    });
getInternalHooks = (key) => {
      if (key === HOOK_MARK) {
        this.formHooked = true;
        return {
          dispatch: this.dispatch,
          initEntityValue: this.initEntityValue,
          registerField: this.registerField,
          useSubscribe: this.useSubscribe,
          setInitialValues: this.setInitialValues,
          destroyForm: this.destroyForm,
          setCallbacks: this.setCallbacks,
          setValidateMessages: this.setValidateMessages,
          getFields: this.getFields,
          setPreserve: this.setPreserve,
          getInitialValue: this.getInitialValue,
          registerWatch: this.registerWatch
        };
      }
      warningOnce(false, "`getInternalHooks` is internal usage. Should not call directly.");
      return null;
    };
    useSubscribe = (subscribable) => {
      this.subscribable = subscribable;
    };
prevWithoutPreserves = null;
setInitialValues = (initialValues, init) => {
      this.initialValues = initialValues || {};
      if (init) {
        let nextStore = merge$2(initialValues, this.store);
        this.prevWithoutPreserves?.map(({
          key: namePath
        }) => {
          nextStore = set(nextStore, namePath, get(initialValues, namePath));
        });
        this.prevWithoutPreserves = null;
        this.updateStore(nextStore);
      }
    };
    destroyForm = (clearOnDestroy) => {
      if (clearOnDestroy) {
        this.updateStore({});
      } else {
        const prevWithoutPreserves = new NameMap();
        this.getFieldEntities(true).forEach((entity) => {
          if (!this.isMergedPreserve(entity.isPreserve())) {
            prevWithoutPreserves.set(entity.getNamePath(), true);
          }
        });
        this.prevWithoutPreserves = prevWithoutPreserves;
      }
    };
    getInitialValue = (namePath) => {
      const initValue = get(this.initialValues, namePath);
      return namePath.length ? merge$2(initValue) : initValue;
    };
    setCallbacks = (callbacks) => {
      this.callbacks = callbacks;
    };
    setValidateMessages = (validateMessages) => {
      this.validateMessages = validateMessages;
    };
    setPreserve = (preserve2) => {
      this.preserve = preserve2;
    };
registerWatch = (callback) => {
      return this.watcherCenter.register(callback);
    };
    notifyWatch = (namePath = []) => {
      this.watcherCenter.notify(namePath);
    };
timeoutId = null;
    warningUnhooked = () => {
    };
updateStore = (nextStore) => {
      this.store = nextStore;
    };

getFieldEntities = (pure = false) => {
      if (!pure) {
        return this.fieldEntities;
      }
      return this.fieldEntities.filter((field) => field.getNamePath().length);
    };
getFieldsMap = (pure = false) => {
      const cache2 = new NameMap();
      this.getFieldEntities(pure).forEach((field) => {
        const namePath = field.getNamePath();
        cache2.set(namePath, field);
      });
      return cache2;
    };
getFieldEntitiesForNamePathList = (nameList, includesSubNamePath = false) => {
      if (!nameList) {
        return this.getFieldEntities(true);
      }
      const cache2 = this.getFieldsMap(true);
      if (!includesSubNamePath) {
        return nameList.map((name) => {
          const namePath = getNamePath(name);
          return cache2.get(namePath) || {
            INVALIDATE_NAME_PATH: getNamePath(name)
          };
        });
      }
      return nameList.flatMap((name) => {
        const namePath = getNamePath(name);
        const fields = cache2.getAsPrefix(namePath);
        if (fields.length) {
          return fields;
        }
        return [{
          INVALIDATE_NAME_PATH: namePath
        }];
      });
    };
    getFieldsValue = (nameList, filterFunc) => {
      this.warningUnhooked();
      let mergedNameList;
      let mergedFilterFunc;
      if (nameList === true || Array.isArray(nameList)) {
        mergedNameList = nameList;
        mergedFilterFunc = filterFunc;
      } else if (nameList && typeof nameList === "object") {
        mergedFilterFunc = nameList.filter;
      }
      if (mergedNameList === true && !mergedFilterFunc) {
        return this.store;
      }
      const fieldEntities = this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null, true);
      const filteredNameList = [];
      const listNamePaths = [];
      fieldEntities.forEach((entity) => {
        const namePath = entity.INVALIDATE_NAME_PATH || entity.getNamePath();
        if (entity.isList?.()) {
          listNamePaths.push(namePath);
          return;
        }
        if (!mergedFilterFunc) {
          filteredNameList.push(namePath);
        } else {
          const meta = "getMeta" in entity ? entity.getMeta() : null;
          if (mergedFilterFunc(meta)) {
            filteredNameList.push(namePath);
          }
        }
      });
      let mergedValues = cloneByNamePathList(this.store, filteredNameList.map(getNamePath));
      listNamePaths.forEach((namePath) => {
        if (!get(mergedValues, namePath)) {
          mergedValues = set(mergedValues, namePath, []);
        }
      });
      return mergedValues;
    };
    getFieldValue = (name) => {
      this.warningUnhooked();
      const namePath = getNamePath(name);
      return get(this.store, namePath);
    };
    getFieldsError = (nameList) => {
      this.warningUnhooked();
      const fieldEntities = this.getFieldEntitiesForNamePathList(nameList);
      return fieldEntities.map((entity, index) => {
        if (entity && !entity.INVALIDATE_NAME_PATH) {
          return {
            name: entity.getNamePath(),
            errors: entity.getErrors(),
            warnings: entity.getWarnings()
          };
        }
        return {
          name: getNamePath(nameList[index]),
          errors: [],
          warnings: []
        };
      });
    };
    getFieldError = (name) => {
      this.warningUnhooked();
      const namePath = getNamePath(name);
      const fieldError = this.getFieldsError([namePath])[0];
      return fieldError.errors;
    };
    getFieldWarning = (name) => {
      this.warningUnhooked();
      const namePath = getNamePath(name);
      const fieldError = this.getFieldsError([namePath])[0];
      return fieldError.warnings;
    };
    isFieldsTouched = (...args) => {
      this.warningUnhooked();
      const [arg0, arg1] = args;
      let namePathList;
      let isAllFieldsTouched = false;
      if (args.length === 0) {
        namePathList = null;
      } else if (args.length === 1) {
        if (Array.isArray(arg0)) {
          namePathList = arg0.map(getNamePath);
          isAllFieldsTouched = false;
        } else {
          namePathList = null;
          isAllFieldsTouched = arg0;
        }
      } else {
        namePathList = arg0.map(getNamePath);
        isAllFieldsTouched = arg1;
      }
      const fieldEntities = this.getFieldEntities(true);
      const isFieldTouched = (field) => field.isFieldTouched();
      if (!namePathList) {
        return isAllFieldsTouched ? fieldEntities.every((entity) => isFieldTouched(entity) || entity.isList()) : fieldEntities.some(isFieldTouched);
      }
      const map = new NameMap();
      namePathList.forEach((shortNamePath) => {
        map.set(shortNamePath, []);
      });
      fieldEntities.forEach((field) => {
        const fieldNamePath = field.getNamePath();
        namePathList.forEach((shortNamePath) => {
          if (shortNamePath.every((nameUnit, i2) => fieldNamePath[i2] === nameUnit)) {
            map.update(shortNamePath, (list2) => [...list2, field]);
          }
        });
      });
      const isNamePathListTouched = (entities) => entities.some(isFieldTouched);
      const namePathListEntities = map.map(({
        value
      }) => value);
      return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
    };
    isFieldTouched = (name) => {
      this.warningUnhooked();
      return this.isFieldsTouched([name]);
    };
    isFieldsValidating = (nameList) => {
      this.warningUnhooked();
      const fieldEntities = this.getFieldEntities();
      if (!nameList) {
        return fieldEntities.some((testField) => testField.isFieldValidating());
      }
      const namePathList = nameList.map(getNamePath);
      return fieldEntities.some((testField) => {
        const fieldNamePath = testField.getNamePath();
        return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
      });
    };
    isFieldValidating = (name) => {
      this.warningUnhooked();
      return this.isFieldsValidating([name]);
    };
resetWithFieldInitialValue = (info = {}) => {
      const cache2 = new NameMap();
      const fieldEntities = this.getFieldEntities(true);
      fieldEntities.forEach((field) => {
        const {
          initialValue: initialValue2
        } = field.props;
        const namePath = field.getNamePath();
        if (initialValue2 !== void 0) {
          const records = cache2.get(namePath) || new Set();
          records.add({
            entity: field,
            value: initialValue2
          });
          cache2.set(namePath, records);
        }
      });
      const resetWithFields = (entities) => {
        entities.forEach((field) => {
          const {
            initialValue: initialValue2
          } = field.props;
          if (initialValue2 !== void 0) {
            const namePath = field.getNamePath();
            const formInitialValue = this.getInitialValue(namePath);
            if (formInitialValue !== void 0) {
              warningOnce(false, `Form already set 'initialValues' with path '${namePath.join(".")}'. Field can not overwrite it.`);
            } else {
              const records = cache2.get(namePath);
              if (records && records.size > 1) {
                warningOnce(false, `Multiple Field with path '${namePath.join(".")}' set 'initialValue'. Can not decide which one to pick.`);
              } else if (records) {
                const originValue = this.getFieldValue(namePath);
                const isListField = field.isListField();
                if (!isListField && (!info.skipExist || originValue === void 0)) {
                  this.updateStore(set(this.store, namePath, [...records][0].value));
                }
              }
            }
          }
        });
      };
      let requiredFieldEntities;
      if (info.entities) {
        requiredFieldEntities = info.entities;
      } else if (info.namePathList) {
        requiredFieldEntities = [];
        info.namePathList.forEach((namePath) => {
          const records = cache2.get(namePath);
          if (records) {
            requiredFieldEntities.push(...[...records].map((r2) => r2.entity));
          }
        });
      } else {
        requiredFieldEntities = fieldEntities;
      }
      resetWithFields(requiredFieldEntities);
    };
    resetFields = (nameList) => {
      this.warningUnhooked();
      const prevStore = this.store;
      if (!nameList) {
        this.updateStore(merge$2(this.initialValues));
        this.resetWithFieldInitialValue();
        this.notifyObservers(prevStore, null, {
          type: "reset"
        });
        this.notifyWatch();
        return;
      }
      const namePathList = nameList.map(getNamePath);
      namePathList.forEach((namePath) => {
        const initialValue2 = this.getInitialValue(namePath);
        this.updateStore(set(this.store, namePath, initialValue2));
      });
      this.resetWithFieldInitialValue({
        namePathList
      });
      this.notifyObservers(prevStore, namePathList, {
        type: "reset"
      });
      this.notifyWatch(namePathList);
    };
    setFields = (fields) => {
      this.warningUnhooked();
      const prevStore = this.store;
      const namePathList = [];
      fields.forEach((fieldData) => {
        const {
          name,
          ...data2
        } = fieldData;
        const namePath = getNamePath(name);
        namePathList.push(namePath);
        if ("value" in data2) {
          this.updateStore(set(this.store, namePath, data2.value));
        }
        this.notifyObservers(prevStore, [namePath], {
          type: "setField",
          data: fieldData
        });
      });
      this.notifyWatch(namePathList);
    };
    getFields = () => {
      const entities = this.getFieldEntities(true);
      const fields = entities.map((field) => {
        const namePath = field.getNamePath();
        const meta = field.getMeta();
        const fieldData = {
          ...meta,
          name: namePath,
          value: this.getFieldValue(namePath)
        };
        Object.defineProperty(fieldData, "originRCField", {
          value: true
        });
        return fieldData;
      });
      return fields;
    };

initEntityValue = (entity) => {
      const {
        initialValue: initialValue2
      } = entity.props;
      if (initialValue2 !== void 0) {
        const namePath = entity.getNamePath();
        const prevValue = get(this.store, namePath);
        if (prevValue === void 0) {
          this.updateStore(set(this.store, namePath, initialValue2));
        }
      }
    };
    isMergedPreserve = (fieldPreserve) => {
      const mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : this.preserve;
      return mergedPreserve ?? true;
    };
    registerField = (entity) => {
      this.fieldEntities.push(entity);
      const namePath = entity.getNamePath();
      this.notifyWatch([namePath]);
      if (entity.props.initialValue !== void 0) {
        const prevStore = this.store;
        this.resetWithFieldInitialValue({
          entities: [entity],
          skipExist: true
        });
        this.notifyObservers(prevStore, [entity.getNamePath()], {
          type: "valueUpdate",
          source: "internal"
        });
      }
      return (isListField, preserve2, subNamePath = []) => {
        this.fieldEntities = this.fieldEntities.filter((item) => item !== entity);
        if (!this.isMergedPreserve(preserve2) && (!isListField || subNamePath.length > 1)) {
          const defaultValue2 = isListField ? void 0 : this.getInitialValue(namePath);
          if (namePath.length && this.getFieldValue(namePath) !== defaultValue2 && this.fieldEntities.every((field) => (
!matchNamePath(field.getNamePath(), namePath)
          ))) {
            const prevStore = this.store;
            this.updateStore(set(prevStore, namePath, defaultValue2, true));
            this.notifyObservers(prevStore, [namePath], {
              type: "remove"
            });
            this.triggerDependenciesUpdate(prevStore, namePath);
          }
        }
        this.notifyWatch([namePath]);
      };
    };
    dispatch = (action2) => {
      switch (action2.type) {
        case "updateValue": {
          const {
            namePath,
            value
          } = action2;
          this.updateValue(namePath, value);
          break;
        }
        case "validateField": {
          const {
            namePath,
            triggerName
          } = action2;
          this.validateFields([namePath], {
            triggerName
          });
          break;
        }
      }
    };
    notifyObservers = (prevStore, namePathList, info) => {
      if (this.subscribable) {
        const mergedInfo = {
          ...info,
          store: this.getFieldsValue(true)
        };
        this.getFieldEntities().forEach(({
          onStoreChange
        }) => {
          onStoreChange(prevStore, namePathList, mergedInfo);
        });
      } else {
        this.forceRootUpdate();
      }
    };
triggerDependenciesUpdate = (prevStore, namePath) => {
      const childrenFields = this.getDependencyChildrenFields(namePath);
      if (childrenFields.length) {
        this.validateFields(childrenFields);
      }
      this.notifyObservers(prevStore, childrenFields, {
        type: "dependenciesUpdate",
        relatedFields: [namePath, ...childrenFields]
      });
      return childrenFields;
    };
    updateValue = (name, value) => {
      const namePath = getNamePath(name);
      const prevStore = this.store;
      this.updateStore(set(this.store, namePath, value));
      this.notifyObservers(prevStore, [namePath], {
        type: "valueUpdate",
        source: "internal"
      });
      this.notifyWatch([namePath]);
      const childrenFields = this.triggerDependenciesUpdate(prevStore, namePath);
      const {
        onValuesChange
      } = this.callbacks;
      if (onValuesChange) {
        const fieldEntity = this.getFieldsMap(true).get(namePath);
        const changedValues = cloneByNamePathList(this.store, [namePath]);
        const allValues = this.getFieldsValue();
        const mergedAllValues = mergeWith([allValues, changedValues], {
prepareArray: (current) => fieldEntity?.isList() ? [] : [...current || []]
        });
        onValuesChange(changedValues, mergedAllValues);
      }
      this.triggerOnFieldsChange([namePath, ...childrenFields]);
    };
setFieldsValue = (store2) => {
      this.warningUnhooked();
      const prevStore = this.store;
      if (store2) {
        const nextStore = merge$2(this.store, store2);
        this.updateStore(nextStore);
      }
      this.notifyObservers(prevStore, null, {
        type: "valueUpdate",
        source: "external"
      });
      this.notifyWatch();
    };
    setFieldValue = (name, value) => {
      this.setFields([{
        name,
        value,
        errors: [],
        warnings: [],
        touched: true
      }]);
    };
    getDependencyChildrenFields = (rootNamePath) => {
      const children = new Set();
      const childrenFields = [];
      const dependencies2fields = new NameMap();
      this.getFieldEntities().forEach((field) => {
        const {
          dependencies
        } = field.props;
        (dependencies || []).forEach((dependency) => {
          const dependencyNamePath = getNamePath(dependency);
          dependencies2fields.update(dependencyNamePath, (fields = new Set()) => {
            fields.add(field);
            return fields;
          });
        });
      });
      const fillChildren = (namePath) => {
        const fields = dependencies2fields.get(namePath) || new Set();
        fields.forEach((field) => {
          if (!children.has(field)) {
            children.add(field);
            const fieldNamePath = field.getNamePath();
            if (field.isFieldDirty() && fieldNamePath.length) {
              childrenFields.push(fieldNamePath);
              fillChildren(fieldNamePath);
            }
          }
        });
      };
      fillChildren(rootNamePath);
      return childrenFields;
    };
    triggerOnFieldsChange = (namePathList, filedErrors) => {
      const {
        onFieldsChange
      } = this.callbacks;
      if (onFieldsChange) {
        const fields = this.getFields();
        if (filedErrors) {
          const cache2 = new NameMap();
          filedErrors.forEach(({
            name,
            errors
          }) => {
            cache2.set(name, errors);
          });
          fields.forEach((field) => {
            field.errors = cache2.get(field.name) || field.errors;
          });
        }
        const changedFields = fields.filter(({
          name: fieldName
        }) => containsNamePath(namePathList, fieldName));
        if (changedFields.length) {
          onFieldsChange(changedFields, fields);
        }
      }
    };
validateFields = (arg1, arg2) => {
      this.warningUnhooked();
      let nameList;
      let options;
      if (Array.isArray(arg1) || typeof arg1 === "string" || typeof arg2 === "string") {
        nameList = arg1;
        options = arg2;
      } else {
        options = arg1;
      }
      const provideNameList = !!nameList;
      const namePathList = provideNameList ? nameList.map(getNamePath) : [];
      const finalValueNamePathList = [...namePathList];
      const promiseList = [];
      const TMP_SPLIT = String(Date.now());
      const validateNamePathList = new Set();
      const {
        recursive,
        dirty
      } = options || {};
      this.getFieldEntities(true).forEach((field) => {
        const fieldNamePath = field.getNamePath();
        if (!provideNameList) {
          if (
!field.isList() ||
!namePathList.some((name) => matchNamePath(name, fieldNamePath, true))
          ) {
            finalValueNamePathList.push(fieldNamePath);
          }
          namePathList.push(fieldNamePath);
        }
        if (!field.props.rules || !field.props.rules.length) {
          return;
        }
        if (dirty && !field.isFieldDirty()) {
          return;
        }
        validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));
        if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {
          const promise = field.validateRules({
            validateMessages: {
              ...defaultValidateMessages,
              ...this.validateMessages
            },
            ...options
          });
          promiseList.push(promise.then(() => ({
            name: fieldNamePath,
            errors: [],
            warnings: []
          })).catch((ruleErrors) => {
            const mergedErrors = [];
            const mergedWarnings = [];
            ruleErrors.forEach?.(({
              rule: {
                warningOnly
              },
              errors
            }) => {
              if (warningOnly) {
                mergedWarnings.push(...errors);
              } else {
                mergedErrors.push(...errors);
              }
            });
            if (mergedErrors.length) {
              return Promise.reject({
                name: fieldNamePath,
                errors: mergedErrors,
                warnings: mergedWarnings
              });
            }
            return {
              name: fieldNamePath,
              errors: mergedErrors,
              warnings: mergedWarnings
            };
          }));
        }
      });
      const summaryPromise = allPromiseFinish(promiseList);
      this.lastValidatePromise = summaryPromise;
      summaryPromise.catch((results) => results).then((results) => {
        const resultNamePathList = results.map(({
          name
        }) => name);
        this.notifyObservers(this.store, resultNamePathList, {
          type: "validateFinish"
        });
        this.triggerOnFieldsChange(resultNamePathList, results);
      });
      const returnPromise = summaryPromise.then(() => {
        if (this.lastValidatePromise === summaryPromise) {
          return Promise.resolve(this.getFieldsValue(finalValueNamePathList));
        }
        return Promise.reject([]);
      }).catch((results) => {
        const errorList = results.filter((result) => result && result.errors.length);
        const errorMessage = errorList[0]?.errors?.[0];
        return Promise.reject({
          message: errorMessage,
          values: this.getFieldsValue(namePathList),
          errorFields: errorList,
          outOfDate: this.lastValidatePromise !== summaryPromise
        });
      });
      returnPromise.catch((e) => e);
      const triggerNamePathList = namePathList.filter((namePath) => validateNamePathList.has(namePath.join(TMP_SPLIT)));
      this.triggerOnFieldsChange(triggerNamePathList);
      return returnPromise;
    };
submit = () => {
      this.warningUnhooked();
      this.validateFields().then((values) => {
        const {
          onFinish
        } = this.callbacks;
        if (onFinish) {
          try {
            onFinish(values);
          } catch (err) {
            console.error(err);
          }
        }
      }).catch((e) => {
        const {
          onFinishFailed
        } = this.callbacks;
        if (onFinishFailed) {
          onFinishFailed(e);
        }
      });
    };
  }
  function useForm(form) {
    const formRef = reactExports.useRef(null);
    const [, forceUpdate] = reactExports.useState({});
    if (!formRef.current) {
      if (form) {
        formRef.current = form;
      } else {
        const forceReRender = () => {
          forceUpdate({});
        };
        const formStore = new FormStore(forceReRender);
        formRef.current = formStore.getForm();
      }
    }
    return [formRef.current];
  }
  const FormContext = reactExports.createContext({
    triggerFormChange: () => {
    },
    triggerFormFinish: () => {
    },
    registerForm: () => {
    },
    unregisterForm: () => {
    }
  });
  const FormProvider = ({
    validateMessages,
    onFormChange,
    onFormFinish,
    children
  }) => {
    const formContext = reactExports.useContext(FormContext);
    const formsRef = reactExports.useRef({});
    return reactExports.createElement(FormContext.Provider, {
      value: {
        ...formContext,
        validateMessages: {
          ...formContext.validateMessages,
          ...validateMessages
        },


triggerFormChange: (name, changedFields) => {
          if (onFormChange) {
            onFormChange(name, {
              changedFields,
              forms: formsRef.current
            });
          }
          formContext.triggerFormChange(name, changedFields);
        },
        triggerFormFinish: (name, values) => {
          if (onFormFinish) {
            onFormFinish(name, {
              values,
              forms: formsRef.current
            });
          }
          formContext.triggerFormFinish(name, values);
        },
        registerForm: (name, form) => {
          if (name) {
            formsRef.current = {
              ...formsRef.current,
              [name]: form
            };
          }
          formContext.registerForm(name, form);
        },
        unregisterForm: (name) => {
          const newForms = {
            ...formsRef.current
          };
          delete newForms[name];
          formsRef.current = newForms;
          formContext.unregisterForm(name);
        }
      }
    }, children);
  };
  function _extends$K() {
    _extends$K = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$K.apply(this, arguments);
  }
  const Form = ({
    name,
    initialValues,
    fields,
    form,
    preserve: preserve2,
    children,
    component: Component = "form",
    validateMessages,
    validateTrigger = "onChange",
    onValuesChange,
    onFieldsChange,
    onFinish,
    onFinishFailed,
    clearOnDestroy,
    ...restProps
  }, ref2) => {
    const nativeElementRef = reactExports.useRef(null);
    const formContext = reactExports.useContext(FormContext);
    const [formInstance] = useForm(form);
    const {
      useSubscribe,
      setInitialValues,
      setCallbacks,
      setValidateMessages,
      setPreserve,
      destroyForm
    } = formInstance.getInternalHooks(HOOK_MARK);
    reactExports.useImperativeHandle(ref2, () => ({
      ...formInstance,
      nativeElement: nativeElementRef.current
    }));
    reactExports.useEffect(() => {
      formContext.registerForm(name, formInstance);
      return () => {
        formContext.unregisterForm(name);
      };
    }, [formContext, formInstance, name]);
    setValidateMessages({
      ...formContext.validateMessages,
      ...validateMessages
    });
    setCallbacks({
      onValuesChange,
      onFieldsChange: (changedFields, ...rest) => {
        formContext.triggerFormChange(name, changedFields);
        if (onFieldsChange) {
          onFieldsChange(changedFields, ...rest);
        }
      },
      onFinish: (values) => {
        formContext.triggerFormFinish(name, values);
        if (onFinish) {
          onFinish(values);
        }
      },
      onFinishFailed
    });
    setPreserve(preserve2);
    const mountRef = reactExports.useRef(null);
    setInitialValues(initialValues, !mountRef.current);
    if (!mountRef.current) {
      mountRef.current = true;
    }
    reactExports.useEffect(
      () => () => destroyForm(clearOnDestroy),
[]
    );
    let childrenNode;
    const childrenRenderProps = typeof children === "function";
    if (childrenRenderProps) {
      const values = formInstance.getFieldsValue(true);
      childrenNode = children(values, formInstance);
    } else {
      childrenNode = children;
    }
    useSubscribe(!childrenRenderProps);
    const prevFieldsRef = reactExports.useRef(null);
    reactExports.useEffect(() => {
      if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
        formInstance.setFields(fields || []);
      }
      prevFieldsRef.current = fields;
    }, [fields, formInstance]);
    const formContextValue = reactExports.useMemo(() => ({
      ...formInstance,
      validateTrigger
    }), [formInstance, validateTrigger]);
    const wrapperNode = reactExports.createElement(ListContext.Provider, {
      value: null
    }, reactExports.createElement(Context$1.Provider, {
      value: formContextValue
    }, childrenNode));
    if (Component === false) {
      return wrapperNode;
    }
    return reactExports.createElement(Component, _extends$K({}, restProps, {
      ref: nativeElementRef,
      onSubmit: (event) => {
        event.preventDefault();
        event.stopPropagation();
        formInstance.submit();
      },
      onReset: (event) => {
        event.preventDefault();
        formInstance.resetFields();
        restProps.onReset?.(event);
      }
    }), wrapperNode);
  };
  function stringify$1(value) {
    try {
      return JSON.stringify(value);
    } catch {
      return Math.random();
    }
  }
  function useWatch(...args) {
    const [dependencies, _form = {}] = args;
    const options = isFormInstance(_form) ? {
      form: _form
    } : _form;
    const form = options.form;
    const [value, setValue] = reactExports.useState(() => typeof dependencies === "function" ? dependencies({}) : void 0);
    const valueStr = reactExports.useMemo(() => stringify$1(value), [value]);
    const valueStrRef = reactExports.useRef(valueStr);
    valueStrRef.current = valueStr;
    const fieldContext = reactExports.useContext(Context$1);
    const formInstance = form || fieldContext;
    const isValidForm = formInstance && formInstance._init;
    const {
      getFieldsValue,
      getInternalHooks
    } = formInstance;
    const {
      registerWatch
    } = getInternalHooks(HOOK_MARK);
    const triggerUpdate = useEvent$1((values, allValues) => {
      const watchValue = options.preserve ? allValues ?? getFieldsValue(true) : values ?? getFieldsValue();
      const nextValue = typeof dependencies === "function" ? dependencies(watchValue) : get(watchValue, getNamePath(dependencies));
      if (stringify$1(value) !== stringify$1(nextValue)) {
        setValue(nextValue);
      }
    });
    const flattenDeps = typeof dependencies === "function" ? dependencies : JSON.stringify(dependencies);
    reactExports.useEffect(() => {
      if (!isValidForm) {
        return;
      }
      triggerUpdate();
    }, [isValidForm, flattenDeps]);
    reactExports.useEffect(() => {
      if (!isValidForm) {
        return;
      }
      const cancelRegister = registerWatch((values, allValues) => {
        triggerUpdate(values, allValues);
      });
      return cancelRegister;
    }, [isValidForm]);
    return value;
  }
  const InternalForm = reactExports.forwardRef(Form);
  const RefForm = InternalForm;
  RefForm.FormProvider = FormProvider;
  RefForm.Field = WrapperField;
  RefForm.List = List$1;
  RefForm.useForm = useForm;
  RefForm.useWatch = useWatch;
  const FormItemInputContext = reactExports.createContext({});
  const NoFormStyle = ({
    children,
    status,
    override
  }) => {
    const formItemInputContext = reactExports.useContext(FormItemInputContext);
    const newFormItemInputContext = reactExports.useMemo(() => {
      const newContext = {
        ...formItemInputContext
      };
      if (override) {
        delete newContext.isFormItemInput;
      }
      if (status) {
        delete newContext.status;
        delete newContext.hasFeedback;
        delete newContext.feedbackIcon;
      }
      return newContext;
    }, [status, override, formItemInputContext]);
    return reactExports.createElement(FormItemInputContext.Provider, {
      value: newFormItemInputContext
    }, children);
  };
  const VariantContext = reactExports.createContext(void 0);
  const ContextIsolator = (props) => {
    const {
      space,
      form,
      children
    } = props;
    if (!isNonNullable(children)) {
      return null;
    }
    let result = children;
    if (form) {
      result = React.createElement(NoFormStyle, {
        override: true,
        status: true
      }, result);
    }
    if (space) {
      result = React.createElement(NoCompactStyle, null, result);
    }
    return result;
  };
  const canUseDocElement = () => canUseDom() && window.document.documentElement;
  function useFocusable(focusable2, defaultTrap, legacyFocusTriggerAfterClose) {
    return reactExports.useMemo(() => {
      const ret = {
        trap: defaultTrap ?? true,
        focusTriggerAfterClose: legacyFocusTriggerAfterClose ?? true
      };
      return {
        ...ret,
        ...focusable2
      };
    }, [focusable2, defaultTrap, legacyFocusTriggerAfterClose]);
  }
  const Element$1 = (props) => {
    const {
      prefixCls,
      className,
      style: style2,
      size,
      shape
    } = props;
    const sizeCls = clsx({
      [`${prefixCls}-lg`]: size === "large",
      [`${prefixCls}-sm`]: size === "small"
    });
    const shapeCls = clsx({
      [`${prefixCls}-circle`]: shape === "circle",
      [`${prefixCls}-square`]: shape === "square",
      [`${prefixCls}-round`]: shape === "round"
    });
    const sizeStyle = reactExports.useMemo(() => typeof size === "number" ? {
      width: size,
      height: size,
      lineHeight: `${size}px`
    } : {}, [size]);
    return reactExports.createElement("span", {
      className: clsx(prefixCls, sizeCls, shapeCls, className),
      style: {
        ...sizeStyle,
        ...style2
      }
    });
  };
  const skeletonClsLoading = new Keyframe(`ant-skeleton-loading`, {
    "0%": {
      backgroundPosition: "100% 50%"
    },
    "100%": {
      backgroundPosition: "0 50%"
    }
  });
  const genSkeletonElementCommonSize = (size) => ({
    height: size,
    lineHeight: unit$1(size)
  });
  const genSkeletonElementSize = (size) => ({
    width: size,
    ...genSkeletonElementCommonSize(size)
  });
  const genSkeletonColor = (token2) => ({
    background: token2.skeletonLoadingBackground,
    backgroundSize: "400% 100%",
    animationName: skeletonClsLoading,
    animationDuration: token2.skeletonLoadingMotionDuration,
    animationTimingFunction: "ease",
    animationIterationCount: "infinite"
  });
  const genSkeletonElementInputSize = (size, calc) => ({
    width: calc(size).mul(5).equal(),
    minWidth: calc(size).mul(5).equal(),
    ...genSkeletonElementCommonSize(size)
  });
  const genSkeletonElementAvatar = (token2) => {
    const {
      skeletonAvatarCls,
      gradientFromColor,
      controlHeight,
      controlHeightLG,
      controlHeightSM
    } = token2;
    return {
      [skeletonAvatarCls]: {
        display: "inline-block",
        verticalAlign: "top",
        background: gradientFromColor,
        ...genSkeletonElementSize(controlHeight)
      },
      [`${skeletonAvatarCls}${skeletonAvatarCls}-circle`]: {
        borderRadius: "50%"
      },
      [`${skeletonAvatarCls}${skeletonAvatarCls}-lg`]: {
        ...genSkeletonElementSize(controlHeightLG)
      },
      [`${skeletonAvatarCls}${skeletonAvatarCls}-sm`]: {
        ...genSkeletonElementSize(controlHeightSM)
      }
    };
  };
  const genSkeletonElementInput = (token2) => {
    const {
      controlHeight,
      borderRadiusSM,
      skeletonInputCls,
      controlHeightLG,
      controlHeightSM,
      gradientFromColor,
      calc
    } = token2;
    return {
      [skeletonInputCls]: {
        display: "inline-block",
        verticalAlign: "top",
        background: gradientFromColor,
        borderRadius: borderRadiusSM,
        ...genSkeletonElementInputSize(controlHeight, calc)
      },
      [`${skeletonInputCls}-lg`]: {
        ...genSkeletonElementInputSize(controlHeightLG, calc)
      },
      [`${skeletonInputCls}-sm`]: {
        ...genSkeletonElementInputSize(controlHeightSM, calc)
      }
    };
  };
  const genSkeletonElementShape = (token2) => {
    const {
      gradientFromColor,
      borderRadiusSM,
      imageSizeBase,
      calc
    } = token2;
    return {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      verticalAlign: "middle",
      background: gradientFromColor,
      borderRadius: borderRadiusSM,
      ...genSkeletonElementSize(calc(imageSizeBase).mul(2).equal())
    };
  };
  const genSkeletonElementNode = (token2) => {
    return {
      [token2.skeletonNodeCls]: {
        ...genSkeletonElementShape(token2)
      }
    };
  };
  const genSkeletonElementImage = (token2) => {
    const {
      skeletonImageCls,
      imageSizeBase,
      calc
    } = token2;
    return {
      [skeletonImageCls]: {
        ...genSkeletonElementShape(token2),
        [`${skeletonImageCls}-path`]: {
          fill: "#bfbfbf"
        },
        [`${skeletonImageCls}-svg`]: {
          ...genSkeletonElementSize(imageSizeBase),
          maxWidth: calc(imageSizeBase).mul(4).equal(),
          maxHeight: calc(imageSizeBase).mul(4).equal()
        },
        [`${skeletonImageCls}-svg${skeletonImageCls}-svg-circle`]: {
          borderRadius: "50%"
        }
      },
      [`${skeletonImageCls}${skeletonImageCls}-circle`]: {
        borderRadius: "50%"
      }
    };
  };
  const genSkeletonElementButtonShape = (token2, size, buttonCls) => {
    const {
      skeletonButtonCls
    } = token2;
    return {
      [`${buttonCls}${skeletonButtonCls}-circle`]: {
        width: size,
        minWidth: size,
        borderRadius: "50%"
      },
      [`${buttonCls}${skeletonButtonCls}-round`]: {
        borderRadius: size
      }
    };
  };
  const genSkeletonElementButtonSize = (size, calc) => ({
    width: calc(size).mul(2).equal(),
    minWidth: calc(size).mul(2).equal(),
    ...genSkeletonElementCommonSize(size)
  });
  const genSkeletonElementButton = (token2) => {
    const {
      borderRadiusSM,
      skeletonButtonCls,
      controlHeight,
      controlHeightLG,
      controlHeightSM,
      gradientFromColor,
      calc
    } = token2;
    return {
      [skeletonButtonCls]: {
        display: "inline-block",
        verticalAlign: "top",
        background: gradientFromColor,
        borderRadius: borderRadiusSM,
        width: calc(controlHeight).mul(2).equal(),
        minWidth: calc(controlHeight).mul(2).equal(),
        ...genSkeletonElementButtonSize(controlHeight, calc)
      },
      ...genSkeletonElementButtonShape(token2, controlHeight, skeletonButtonCls),
      [`${skeletonButtonCls}-lg`]: {
        ...genSkeletonElementButtonSize(controlHeightLG, calc)
      },
      ...genSkeletonElementButtonShape(token2, controlHeightLG, `${skeletonButtonCls}-lg`),
      [`${skeletonButtonCls}-sm`]: {
        ...genSkeletonElementButtonSize(controlHeightSM, calc)
      },
      ...genSkeletonElementButtonShape(token2, controlHeightSM, `${skeletonButtonCls}-sm`)
    };
  };
  const genBaseStyle$8 = (token2) => {
    const {
      componentCls,
      skeletonAvatarCls,
      skeletonTitleCls,
      skeletonParagraphCls,
      skeletonButtonCls,
      skeletonInputCls,
      skeletonNodeCls,
      skeletonImageCls,
      controlHeight,
      controlHeightLG,
      controlHeightSM,
      gradientFromColor,
      padding,
      marginSM,
      borderRadius,
      titleHeight,
      blockRadius,
      paragraphLiHeight,
      controlHeightXS,
      paragraphMarginTop
    } = token2;
    return {
      [componentCls]: {
        display: "table",
        width: "100%",
        [`${componentCls}-header`]: {
          display: "table-cell",
          paddingInlineEnd: padding,
          verticalAlign: "top",
[skeletonAvatarCls]: {
            display: "inline-block",
            verticalAlign: "top",
            background: gradientFromColor,
            ...genSkeletonElementSize(controlHeight)
          },
          [`${skeletonAvatarCls}-circle`]: {
            borderRadius: "50%"
          },
          [`${skeletonAvatarCls}-lg`]: {
            ...genSkeletonElementSize(controlHeightLG)
          },
          [`${skeletonAvatarCls}-sm`]: {
            ...genSkeletonElementSize(controlHeightSM)
          }
        },
        [`${componentCls}-section`]: {
          display: "table-cell",
          width: "100%",
          verticalAlign: "top",
[skeletonTitleCls]: {
            width: "100%",
            height: titleHeight,
            background: gradientFromColor,
            borderRadius: blockRadius,
            [`+ ${skeletonParagraphCls}`]: {
              marginBlockStart: controlHeightSM
            }
          },
[skeletonParagraphCls]: {
            padding: 0,
            "> li": {
              width: "100%",
              height: paragraphLiHeight,
              listStyle: "none",
              background: gradientFromColor,
              borderRadius: blockRadius,
              "+ li": {
                marginBlockStart: controlHeightXS
              }
            }
          },
          [`${skeletonParagraphCls}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
            width: "61%"
          }
        },
        [`&-round ${componentCls}-section`]: {
          [`${skeletonTitleCls}, ${skeletonParagraphCls} > li`]: {
            borderRadius
          }
        }
      },
      [`${componentCls}-with-avatar ${componentCls}-section`]: {
[skeletonTitleCls]: {
          marginBlockStart: marginSM,
          [`+ ${skeletonParagraphCls}`]: {
            marginBlockStart: paragraphMarginTop
          }
        }
      },
[`${componentCls}${componentCls}-element`]: {
        display: "inline-block",
        width: "auto",
        ...genSkeletonElementButton(token2),
        ...genSkeletonElementAvatar(token2),
        ...genSkeletonElementInput(token2),
        ...genSkeletonElementNode(token2),
        ...genSkeletonElementImage(token2)
      },
[`${componentCls}${componentCls}-block`]: {
        width: "100%",
        [skeletonButtonCls]: {
          width: "100%"
        },
        [skeletonInputCls]: {
          width: "100%"
        }
      },
[`${componentCls}${componentCls}-active`]: {
        [`
        ${skeletonTitleCls},
        ${skeletonParagraphCls} > li,
        ${skeletonAvatarCls},
        ${skeletonButtonCls},
        ${skeletonInputCls},
        ${skeletonNodeCls},
        ${skeletonImageCls}
      `]: {
          ...genSkeletonColor(token2)
        }
      }
    };
  };
  const prepareComponentToken$p = (token2) => {
    const {
      colorFillContent,
      colorFill
    } = token2;
    const gradientFromColor = colorFillContent;
    const gradientToColor = colorFill;
    return {
      color: gradientFromColor,
      colorGradientEnd: gradientToColor,
      gradientFromColor,
      gradientToColor,
      titleHeight: token2.controlHeight / 2,
      blockRadius: token2.borderRadiusSM,
      paragraphMarginTop: token2.marginLG + token2.marginXXS,
      paragraphLiHeight: token2.controlHeight / 2
    };
  };
  const useStyle$z = genStyleHooks("Skeleton", (token2) => {
    const {
      componentCls,
      calc
    } = token2;
    const skeletonToken = merge$1(token2, {
      skeletonAvatarCls: `${componentCls}-avatar`,
      skeletonTitleCls: `${componentCls}-title`,
      skeletonParagraphCls: `${componentCls}-paragraph`,
      skeletonButtonCls: `${componentCls}-button`,
      skeletonInputCls: `${componentCls}-input`,
      skeletonNodeCls: `${componentCls}-node`,
      skeletonImageCls: `${componentCls}-image`,
      imageSizeBase: calc(token2.controlHeight).mul(1.5).equal(),
      borderRadius: 100,
skeletonLoadingBackground: `linear-gradient(90deg, ${token2.gradientFromColor} 25%, ${token2.gradientToColor} 37%, ${token2.gradientFromColor} 63%)`,
      skeletonLoadingMotionDuration: "1.4s"
    });
    return genBaseStyle$8(skeletonToken);
  }, prepareComponentToken$p, {
    deprecatedTokens: [["color", "gradientFromColor"], ["colorGradientEnd", "gradientToColor"]]
  });
  const SkeletonAvatar = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      classNames,
      rootClassName,
      active,
      style: style2,
      styles,
      shape = "circle",
      size = "default",
      ...rest
    } = props;
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$z(prefixCls);
    const cls = clsx(prefixCls, `${prefixCls}-element`, {
      [`${prefixCls}-active`]: active
    }, classNames?.root, className, rootClassName, hashId, cssVarCls);
    return reactExports.createElement("div", {
      className: cls,
      style: styles?.root
    }, reactExports.createElement(Element$1, {
      prefixCls: `${prefixCls}-avatar`,
      className: classNames?.content,
      style: {
        ...styles?.content,
        ...style2
      },
      shape,
      size,
      ...rest
    }));
  };
  const SkeletonButton = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      classNames,
      active,
      style: style2,
      styles,
      block = false,
      size = "default",
      ...rest
    } = props;
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$z(prefixCls);
    const cls = clsx(prefixCls, `${prefixCls}-element`, {
      [`${prefixCls}-active`]: active,
      [`${prefixCls}-block`]: block
    }, classNames?.root, className, rootClassName, hashId, cssVarCls);
    return reactExports.createElement("div", {
      className: cls,
      style: styles?.root
    }, reactExports.createElement(Element$1, {
      prefixCls: `${prefixCls}-button`,
      className: classNames?.content,
      style: {
        ...styles?.content,
        ...style2
      },
      size,
      ...rest
    }));
  };
  const SkeletonNode = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      classNames,
      rootClassName,
      internalClassName,
      style: style2,
      styles,
      active,
      children
    } = props;
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$z(prefixCls);
    const cls = clsx(prefixCls, `${prefixCls}-element`, {
      [`${prefixCls}-active`]: active
    }, hashId, classNames?.root, className, rootClassName, cssVarCls);
    return reactExports.createElement("div", {
      className: cls,
      style: styles?.root
    }, reactExports.createElement("div", {
      className: clsx(classNames?.content, internalClassName || `${prefixCls}-node`),
      style: {
        ...styles?.content,
        ...style2
      }
    }, children));
  };
  const SkeletonImage = (props) => {
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const prefixCls = getPrefixCls("skeleton", props.prefixCls);
    return reactExports.createElement(SkeletonNode, {
      ...props,
      internalClassName: `${prefixCls}-image`
    }, reactExports.createElement("svg", {
      viewBox: "0 0 1098 1024",
      xmlns: "http://www.w3.org/2000/svg",
      className: `${prefixCls}-image-svg`
    }, reactExports.createElement("title", null, "Image placeholder"), reactExports.createElement("path", {
      d: "M365.7 329.1q0 45.8-32 77.7t-77.7 32-77.7-32-32-77.7 32-77.6 77.7-32 77.7 32 32 77.6M951 548.6v256H146.3V694.9L329 512l91.5 91.4L713 311zm54.8-402.3H91.4q-7.4 0-12.8 5.4T73 164.6v694.8q0 7.5 5.5 12.9t12.8 5.4h914.3q7.5 0 12.9-5.4t5.4-12.9V164.6q0-7.5-5.4-12.9t-12.9-5.4m91.4 18.3v694.8q0 37.8-26.8 64.6t-64.6 26.9H91.4q-37.7 0-64.6-26.9T0 859.4V164.6q0-37.8 26.8-64.6T91.4 73h914.3q37.8 0 64.6 26.9t26.8 64.6",
      className: `${prefixCls}-image-path`
    })));
  };
  const SkeletonInput = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      classNames,
      rootClassName,
      active,
      block,
      style: style2,
      styles,
      size = "default",
      ...rest
    } = props;
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$z(prefixCls);
    const cls = clsx(prefixCls, `${prefixCls}-element`, {
      [`${prefixCls}-active`]: active,
      [`${prefixCls}-block`]: block
    }, classNames?.root, className, rootClassName, hashId, cssVarCls);
    return reactExports.createElement("div", {
      className: cls,
      style: styles?.root
    }, reactExports.createElement(Element$1, {
      prefixCls: `${prefixCls}-input`,
      className: classNames?.content,
      style: {
        ...styles?.content,
        ...style2
      },
      size,
      ...rest
    }));
  };
  const getWidth$1 = (index, props) => {
    const {
      width,
      rows = 2
    } = props;
    if (Array.isArray(width)) {
      return width[index];
    }
    if (rows - 1 === index) {
      return width;
    }
    return void 0;
  };
  const Paragraph = (props) => {
    const {
      prefixCls,
      className,
      style: style2,
      rows = 0
    } = props;
    const rowList = Array.from({
      length: rows
    }).map((_2, index) => (

reactExports.createElement("li", {
        key: index,
        style: {
          width: getWidth$1(index, props)
        }
      })
    ));
    return reactExports.createElement("ul", {
      className: clsx(prefixCls, className),
      style: style2
    }, rowList);
  };
  const Title = ({
    prefixCls,
    className,
    width,
    style: style2
  }) => (

reactExports.createElement("h3", {
      className: clsx(prefixCls, className),
      style: {
        width,
        ...style2
      }
    })
  );
  function getComponentProps(prop) {
    if (prop && typeof prop === "object") {
      return prop;
    }
    return {};
  }
  function getAvatarBasicProps(hasTitle, hasParagraph) {
    if (hasTitle && !hasParagraph) {
      return {
        size: "large",
        shape: "square"
      };
    }
    return {
      size: "large",
      shape: "circle"
    };
  }
  function getTitleBasicProps(hasAvatar, hasParagraph) {
    if (!hasAvatar && hasParagraph) {
      return {
        width: "38%"
      };
    }
    if (hasAvatar && hasParagraph) {
      return {
        width: "50%"
      };
    }
    return {};
  }
  function getParagraphBasicProps(hasAvatar, hasTitle) {
    const basicProps = {};
    if (!hasAvatar || !hasTitle) {
      basicProps.width = "61%";
    }
    if (!hasAvatar && hasTitle) {
      basicProps.rows = 3;
    } else {
      basicProps.rows = 2;
    }
    return basicProps;
  }
  const Skeleton = (props) => {
    const {
      prefixCls: customizePrefixCls,
      loading,
      className,
      rootClassName,
      classNames,
      style: style2,
      styles,
      children,
      avatar = false,
      title = true,
      paragraph = true,
      active,
      round: round2
    } = props;
    const {
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("skeleton");
    const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$z(prefixCls);
    const mergedProps = {
      ...props,
      avatar,
      title,
      paragraph
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    if (loading || !("loading" in props)) {
      const hasAvatar = !!avatar;
      const hasTitle = !!title;
      const hasParagraph = !!paragraph;
      let avatarNode;
      if (hasAvatar) {
        const avatarProps = {
          className: mergedClassNames.avatar,
          prefixCls: `${prefixCls}-avatar`,
          ...getAvatarBasicProps(hasTitle, hasParagraph),
          ...getComponentProps(avatar),
          style: mergedStyles.avatar
        };
        avatarNode = reactExports.createElement("div", {
          className: clsx(mergedClassNames.header, `${prefixCls}-header`),
          style: mergedStyles.header
        }, reactExports.createElement(Element$1, {
          ...avatarProps
        }));
      }
      let contentNode;
      if (hasTitle || hasParagraph) {
        let $title;
        if (hasTitle) {
          const titleProps = {
            className: mergedClassNames.title,
            prefixCls: `${prefixCls}-title`,
            ...getTitleBasicProps(hasAvatar, hasParagraph),
            ...getComponentProps(title),
            style: mergedStyles.title
          };
          $title = reactExports.createElement(Title, {
            ...titleProps
          });
        }
        let paragraphNode;
        if (hasParagraph) {
          const paragraphProps = {
            className: mergedClassNames.paragraph,
            prefixCls: `${prefixCls}-paragraph`,
            ...getParagraphBasicProps(hasAvatar, hasTitle),
            ...getComponentProps(paragraph),
            style: mergedStyles.paragraph
          };
          paragraphNode = reactExports.createElement(Paragraph, {
            ...paragraphProps
          });
        }
        contentNode = reactExports.createElement("div", {
          className: clsx(mergedClassNames.section, `${prefixCls}-section`),
          style: mergedStyles.section
        }, $title, paragraphNode);
      }
      const cls = clsx(prefixCls, {
        [`${prefixCls}-with-avatar`]: hasAvatar,
        [`${prefixCls}-active`]: active,
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-round`]: round2
      }, mergedClassNames.root, contextClassName, className, rootClassName, hashId, cssVarCls);
      return reactExports.createElement("div", {
        className: cls,
        style: {
          ...mergedStyles.root,
          ...contextStyle,
          ...style2
        }
      }, avatarNode, contentNode);
    }
    return children ?? null;
  };
  Skeleton.Button = SkeletonButton;
  Skeleton.Avatar = SkeletonAvatar;
  Skeleton.Input = SkeletonInput;
  Skeleton.Image = SkeletonImage;
  Skeleton.Node = SkeletonNode;
  function voidFunc() {
  }
  const WatermarkContext = reactExports.createContext({
    add: voidFunc,
    remove: voidFunc
  });
  function usePanelRef(panelSelector) {
    const watermark = reactExports.useContext(WatermarkContext);
    const panelEleRef = reactExports.useRef(null);
    const panelRef = useEvent$1((ele) => {
      if (ele) {
        const innerContentEle = panelSelector ? ele.querySelector(panelSelector) : ele;
        if (innerContentEle) {
          watermark.add(innerContentEle);
          panelEleRef.current = innerContentEle;
        }
      } else {
        watermark.remove(panelEleRef.current);
      }
    });
    return panelRef;
  }
  const NormalCancelBtn = () => {
    const {
      cancelButtonProps,
      cancelTextLocale,
      onCancel
    } = reactExports.useContext(ModalContext);
    return React.createElement(Button$1, {
      onClick: onCancel,
      ...cancelButtonProps
    }, cancelTextLocale);
  };
  const NormalOkBtn = () => {
    const {
      confirmLoading,
      okButtonProps,
      okType,
      okTextLocale,
      onOk
    } = reactExports.useContext(ModalContext);
    return React.createElement(Button$1, {
      ...convertLegacyProps(okType),
      loading: confirmLoading,
      onClick: onOk,
      ...okButtonProps
    }, okTextLocale);
  };
  function renderCloseIcon(prefixCls, closeIcon) {
    return React.createElement("span", {
      className: `${prefixCls}-close-x`
    }, closeIcon || React.createElement(RefIcon$k, {
      className: `${prefixCls}-close-icon`
    }));
  }
  const Footer = (props) => {
    const {
      okText,
      okType = "primary",
      cancelText,
      confirmLoading,
      onOk,
      onCancel,
      okButtonProps,
      cancelButtonProps,
      footer
    } = props;
    const [locale2] = useLocale("Modal", getConfirmLocale());
    const okTextLocale = okText || locale2?.okText;
    const cancelTextLocale = cancelText || locale2?.cancelText;
    const memoizedValue = React.useMemo(() => {
      return {
        confirmLoading,
        okButtonProps,
        cancelButtonProps,
        okTextLocale,
        cancelTextLocale,
        okType,
        onOk,
        onCancel
      };
    }, [confirmLoading, okButtonProps, cancelButtonProps, okTextLocale, cancelTextLocale, okType, onOk, onCancel]);
    let footerNode;
    if (typeof footer === "function" || typeof footer === "undefined") {
      footerNode = React.createElement(React.Fragment, null, React.createElement(NormalCancelBtn, null), React.createElement(NormalOkBtn, null));
      if (typeof footer === "function") {
        footerNode = footer(footerNode, {
          OkBtn: NormalOkBtn,
          CancelBtn: NormalCancelBtn
        });
      }
      footerNode = React.createElement(ModalContextProvider, {
        value: memoizedValue
      }, footerNode);
    } else {
      footerNode = footer;
    }
    return React.createElement(DisabledContextProvider, {
      disabled: false
    }, footerNode);
  };
  const genGridRowStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
[componentCls]: {
        display: "flex",
        flexFlow: "row wrap",
        minWidth: 0,
        "&::before, &::after": {
          display: "flex"
        },
        "&-no-wrap": {
          flexWrap: "nowrap"
        },
"&-start": {
          justifyContent: "flex-start"
        },
"&-center": {
          justifyContent: "center"
        },
"&-end": {
          justifyContent: "flex-end"
        },
        "&-space-between": {
          justifyContent: "space-between"
        },
        "&-space-around": {
          justifyContent: "space-around"
        },
        "&-space-evenly": {
          justifyContent: "space-evenly"
        },
"&-top": {
          alignItems: "flex-start"
        },
"&-middle": {
          alignItems: "center"
        },
        "&-bottom": {
          alignItems: "flex-end"
        }
      }
    };
  };
  const genGridColStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
[componentCls]: {
        position: "relative",
        maxWidth: "100%",
minHeight: 1
      }
    };
  };
  const genLoopGridColumnsStyle = (token2, sizeCls) => {
    const {
      componentCls,
      gridColumns,
      antCls
    } = token2;
    const [gridVarName, gridVarRef] = genCssVar(antCls, "grid");
    const [, colVarRef] = genCssVar(antCls, "col");
    const gridColumnsStyle = {};
    for (let i2 = gridColumns; i2 >= 0; i2--) {
      if (i2 === 0) {
        gridColumnsStyle[`${componentCls}${sizeCls}-${i2}`] = {
          display: "none"
        };
        gridColumnsStyle[`${componentCls}-push-${i2}`] = {
          insetInlineStart: "auto"
        };
        gridColumnsStyle[`${componentCls}-pull-${i2}`] = {
          insetInlineEnd: "auto"
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-push-${i2}`] = {
          insetInlineStart: "auto"
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i2}`] = {
          insetInlineEnd: "auto"
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i2}`] = {
          marginInlineStart: 0
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-order-${i2}`] = {
          order: 0
        };
      } else {
        gridColumnsStyle[`${componentCls}${sizeCls}-${i2}`] = [


{
            [gridVarName("display")]: "block",
display: "block"
          },
          {
            display: gridVarRef("display"),
            flex: `0 0 ${i2 / gridColumns * 100}%`,
            maxWidth: `${i2 / gridColumns * 100}%`
          }
        ];
        gridColumnsStyle[`${componentCls}${sizeCls}-push-${i2}`] = {
          insetInlineStart: `${i2 / gridColumns * 100}%`
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i2}`] = {
          insetInlineEnd: `${i2 / gridColumns * 100}%`
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i2}`] = {
          marginInlineStart: `${i2 / gridColumns * 100}%`
        };
        gridColumnsStyle[`${componentCls}${sizeCls}-order-${i2}`] = {
          order: i2
        };
      }
    }
    gridColumnsStyle[`${componentCls}${sizeCls}-flex`] = {
      flex: colVarRef(`${sizeCls.replace(/-/, "")}-flex`)
    };
    return gridColumnsStyle;
  };
  const genGridStyle = (token2, sizeCls) => genLoopGridColumnsStyle(token2, sizeCls);
  const genGridMediaStyle = (token2, screenSize, sizeCls) => ({
    [`@media (min-width: ${unit$1(screenSize)})`]: {
      ...genGridStyle(token2, sizeCls)
    }
  });
  const prepareRowComponentToken = () => ({});
  const prepareColComponentToken = () => ({});
  genStyleHooks("Grid", genGridRowStyle, prepareRowComponentToken);
  const getMediaSize = (token2) => {
    const mediaSizesMap = {
      xs: token2.screenXSMin,
      sm: token2.screenSMMin,
      md: token2.screenMDMin,
      lg: token2.screenLGMin,
      xl: token2.screenXLMin,
      xxl: token2.screenXXLMin
    };
    return mediaSizesMap;
  };
  genStyleHooks("Grid", (token2) => {
    const gridToken = merge$1(token2, {
      gridColumns: 24
});
    const gridMediaSizesMap = getMediaSize(gridToken);
    delete gridMediaSizesMap.xs;
    return [genGridColStyle(gridToken), genGridStyle(gridToken, ""), genGridStyle(gridToken, "-xs"), Object.keys(gridMediaSizesMap).map((key) => genGridMediaStyle(gridToken, gridMediaSizesMap[key], `-${key}`)).reduce((pre, cur) => ({
      ...pre,
      ...cur
    }), {})];
  }, prepareColComponentToken);
  function box(position2) {
    return {
      position: position2,
      inset: 0
    };
  }
  const genModalMaskStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    return [{
      [`${componentCls}-root`]: {
        [`${componentCls}${antCls}-zoom-enter, ${componentCls}${antCls}-zoom-appear`]: {
transform: "none",
          opacity: 0,
          animationDuration: token2.motionDurationSlow,
userSelect: "none"
        },

[`${componentCls}${antCls}-zoom-leave ${componentCls}-container`]: {
          pointerEvents: "none"
        },
        [`${componentCls}-mask`]: {
          ...box("fixed"),
          zIndex: token2.zIndexPopupBase,
          height: "100%",
          backgroundColor: token2.colorBgMask,
          pointerEvents: "none",
          [`&${componentCls}-mask-blur`]: {
            backdropFilter: "blur(4px)"
          },
          [`${componentCls}-hidden`]: {
            display: "none"
          }
        },
        [`${componentCls}-wrap`]: {
          ...box("fixed"),
          zIndex: token2.zIndexPopupBase,
          overflow: "auto",
          outline: 0,
          WebkitOverflowScrolling: "touch"
        }
      }
    }, {
      [`${componentCls}-root`]: initFadeMotion(token2)
    }];
  };
  const genModalStyle = (token2) => {
    const {
      componentCls,
      motionDurationMid
    } = token2;
    return [
{
        [`${componentCls}-root`]: {
          [`${componentCls}-wrap-rtl`]: {
            direction: "rtl"
          },
          [`${componentCls}-centered`]: {
            textAlign: "center",
            "&::before": {
              display: "inline-block",
              width: 0,
              height: "100%",
              verticalAlign: "middle",
              content: '""'
            },
            [componentCls]: {
              top: 0,
              display: "inline-block",
              paddingBottom: 0,
              textAlign: "start",
              verticalAlign: "middle"
            }
          },
          [`@media (max-width: ${token2.screenSMMax}px)`]: {
            [componentCls]: {
              maxWidth: "calc(100vw - 16px)",
              margin: `${unit$1(token2.marginXS)} auto`
            },
            [`${componentCls}-centered`]: {
              [componentCls]: {
                flex: 1
              }
            }
          }
        }
      },
{
        [componentCls]: {
          ...resetComponent(token2),
          pointerEvents: "none",
          position: "relative",
          top: 100,
          width: "auto",
          maxWidth: `calc(100vw - ${unit$1(token2.calc(token2.margin).mul(2).equal())})`,
          margin: "0 auto",
          "&:focus-visible": {
            borderRadius: token2.borderRadiusLG,
            ...genFocusOutline(token2)
          },
          [`${componentCls}-title`]: {
            margin: 0,
            color: token2.titleColor,
            fontWeight: token2.fontWeightStrong,
            fontSize: token2.titleFontSize,
            lineHeight: token2.titleLineHeight,
            wordWrap: "break-word"
          },
          [`${componentCls}-container`]: {
            position: "relative",
            backgroundColor: token2.contentBg,
            backgroundClip: "padding-box",
            border: 0,
            borderRadius: token2.borderRadiusLG,
            boxShadow: token2.boxShadow,
            pointerEvents: "auto",
            padding: token2.contentPadding
          },
          [`${componentCls}-close`]: {
            position: "absolute",
            top: token2.calc(token2.modalHeaderHeight).sub(token2.modalCloseBtnSize).div(2).equal(),
            insetInlineEnd: token2.calc(token2.modalHeaderHeight).sub(token2.modalCloseBtnSize).div(2).equal(),
            zIndex: token2.calc(token2.zIndexPopupBase).add(10).equal(),
            padding: 0,
            color: token2.modalCloseIconColor,
            fontWeight: token2.fontWeightStrong,
            lineHeight: 1,
            textDecoration: "none",
            background: "transparent",
            borderRadius: token2.borderRadiusSM,
            width: token2.modalCloseBtnSize,
            height: token2.modalCloseBtnSize,
            border: 0,
            outline: 0,
            cursor: "pointer",
            transition: ["color", "background-color"].map((prop) => `${prop} ${motionDurationMid}`).join(", "),
            "&-x": {
              display: "flex",
              fontSize: token2.fontSizeLG,
              fontStyle: "normal",
              lineHeight: unit$1(token2.modalCloseBtnSize),
              justifyContent: "center",
              textTransform: "none",
              textRendering: "auto"
            },
            "&:disabled": {
              pointerEvents: "none"
            },
            "&:hover": {
              color: token2.modalCloseIconHoverColor,
              backgroundColor: token2.colorBgTextHover,
              textDecoration: "none"
            },
            "&:active": {
              backgroundColor: token2.colorBgTextActive
            },
            ...genFocusStyle(token2)
          },
          [`${componentCls}-header`]: {
            color: token2.colorText,
            background: token2.headerBg,
            borderRadius: `${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)} 0 0`,
            marginBottom: token2.headerMarginBottom,
            padding: token2.headerPadding,
            borderBottom: token2.headerBorderBottom
          },
          [`${componentCls}-body`]: {
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            wordWrap: "break-word",
            padding: token2.bodyPadding,
            [`${componentCls}-body-skeleton`]: {
              width: "100%",
              height: "100%",
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              margin: `${unit$1(token2.margin)} auto`
            }
          },
          [`${componentCls}-footer`]: {
            textAlign: "end",
            background: token2.footerBg,
            marginTop: token2.footerMarginTop,
            padding: token2.footerPadding,
            borderTop: token2.footerBorderTop,
            borderRadius: token2.footerBorderRadius,
            [`> ${token2.antCls}-btn + ${token2.antCls}-btn`]: {
              marginInlineStart: token2.marginXS
            }
          },
          [`${componentCls}-open`]: {
            overflow: "hidden"
          }
        }
      },
{
        [`${componentCls}-pure-panel`]: {
          top: "auto",
          padding: 0,
          display: "flex",
          flexDirection: "column",
          [`${componentCls}-container,
          ${componentCls}-body,
          ${componentCls}-confirm-body-wrapper`]: {
            display: "flex",
            flexDirection: "column",
            flex: "auto"
          },
          [`${componentCls}-confirm-body`]: {
            marginBottom: "auto"
          }
        }
      }
    ];
  };
  const genRTLStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-root`]: {
        [`${componentCls}-wrap-rtl`]: {
          direction: "rtl",
          [`${componentCls}-confirm-body`]: {
            direction: "rtl"
          }
        }
      }
    };
  };
  const genResponsiveWidthStyle = (token2) => {
    const {
      componentCls
    } = token2;
    const oriGridMediaSizesMap = getMediaSize(token2);
    const gridMediaSizesMap = {
      ...oriGridMediaSizesMap
    };
    delete gridMediaSizesMap.xs;
    const cssVarPrefix = `--${componentCls.replace(".", "")}-`;
    const responsiveStyles = Object.keys(gridMediaSizesMap).map((key) => ({
      [`@media (min-width: ${unit$1(gridMediaSizesMap[key])})`]: {
        width: `var(${cssVarPrefix}${key}-width)`
      }
    }));
    return {
      [`${componentCls}-root`]: {
        [componentCls]: [].concat(_toConsumableArray(Object.keys(oriGridMediaSizesMap).map((currentKey, index) => {
          const previousKey = Object.keys(oriGridMediaSizesMap)[index - 1];
          return previousKey ? {
            [`${cssVarPrefix}${currentKey}-width`]: `var(${cssVarPrefix}${previousKey}-width)`
          } : null;
        })), [{
          width: `var(${cssVarPrefix}xs-width)`
        }], _toConsumableArray(responsiveStyles))
      }
    };
  };
  const prepareToken$3 = (token2) => {
    const headerPaddingVertical = token2.padding;
    const headerFontSize = token2.fontSizeHeading5;
    const headerLineHeight = token2.lineHeightHeading5;
    const modalToken = merge$1(token2, {
      modalHeaderHeight: token2.calc(token2.calc(headerLineHeight).mul(headerFontSize).equal()).add(token2.calc(headerPaddingVertical).mul(2).equal()).equal(),
      modalFooterBorderColorSplit: token2.colorSplit,
      modalFooterBorderStyle: token2.lineType,
      modalFooterBorderWidth: token2.lineWidth,
      modalCloseIconColor: token2.colorIcon,
      modalCloseIconHoverColor: token2.colorIconHover,
      modalCloseBtnSize: token2.controlHeight,
      modalConfirmIconSize: token2.fontHeight,
      modalTitleHeight: token2.calc(token2.titleFontSize).mul(token2.titleLineHeight).equal()
    });
    return modalToken;
  };
  const prepareComponentToken$o = (token2) => ({
    footerBg: "transparent",
    headerBg: "transparent",
    titleLineHeight: token2.lineHeightHeading5,
    titleFontSize: token2.fontSizeHeading5,
    contentBg: token2.colorBgElevated,
    titleColor: token2.colorTextHeading,
contentPadding: token2.wireframe ? 0 : `${unit$1(token2.paddingMD)} ${unit$1(token2.paddingContentHorizontalLG)}`,
    headerPadding: token2.wireframe ? `${unit$1(token2.padding)} ${unit$1(token2.paddingLG)}` : 0,
    headerBorderBottom: token2.wireframe ? `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}` : "none",
    headerMarginBottom: token2.wireframe ? 0 : token2.marginXS,
    bodyPadding: token2.wireframe ? token2.paddingLG : 0,
    footerPadding: token2.wireframe ? `${unit$1(token2.paddingXS)} ${unit$1(token2.padding)}` : 0,
    footerBorderTop: token2.wireframe ? `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}` : "none",
    footerBorderRadius: token2.wireframe ? `0 0 ${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)}` : 0,
    footerMarginTop: token2.wireframe ? 0 : token2.marginSM,
    confirmBodyPadding: token2.wireframe ? `${unit$1(token2.padding * 2)} ${unit$1(token2.padding * 2)} ${unit$1(token2.paddingLG)}` : 0,
    confirmIconMarginInlineEnd: token2.wireframe ? token2.margin : token2.marginSM,
    confirmBtnsMarginTop: token2.wireframe ? token2.marginLG : token2.marginSM,
    mask: true
  });
  const useStyle$y = genStyleHooks("Modal", (token2) => {
    const modalToken = prepareToken$3(token2);
    return [genModalStyle(modalToken), genRTLStyle(modalToken), genModalMaskStyle(modalToken), initZoomMotion(modalToken, "zoom"), genResponsiveWidthStyle(modalToken)];
  }, prepareComponentToken$o, {
    unitless: {
      titleLineHeight: true
    }
  });
  let mousePosition;
  const getClickPosition = (e) => {
    mousePosition = {
      x: e.pageX,
      y: e.pageY
    };
    setTimeout(() => {
      mousePosition = null;
    }, 100);
  };
  if (canUseDocElement()) {
    document.documentElement.addEventListener("click", getClickPosition, true);
  }
  const Modal$1 = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      open: open2,
      wrapClassName,
      centered,
      getContainer: getContainer2,
      style: style2,
      width = 520,
      footer,
      classNames,
      styles,
      children,
      loading,
      confirmLoading,
      zIndex: customizeZIndex,
      mousePosition: customizeMousePosition,
      onOk,
      onCancel,
      okButtonProps,
      cancelButtonProps,
      destroyOnHidden,
      destroyOnClose,
      panelRef = null,
      closable,
      mask: modalMask,
      modalRender,
      maskClosable,
focusTriggerAfterClose,
      focusable: focusable2,
      ...restProps
    } = props;
    const {
      getPopupContainer: getContextPopupContainer,
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles,
      centered: contextCentered,
      cancelButtonProps: contextCancelButtonProps,
      okButtonProps: contextOkButtonProps,
      mask: contextMask
    } = useComponentConfig("modal");
    const {
      modal: modalContext
    } = reactExports.useContext(ConfigContext);
    const [closableAfterClose, onClose] = reactExports.useMemo(() => {
      if (typeof closable === "boolean") {
        return [void 0, void 0];
      }
      return [closable?.afterClose, closable?.onClose];
    }, [closable]);
    const prefixCls = getPrefixCls("modal", customizePrefixCls);
    const rootPrefixCls = getPrefixCls();
    const [mergedMask, maskBlurClassName, mergeMaskClosable] = useMergedMask(modalMask, contextMask, prefixCls, maskClosable);
    const mergedFocusable = useFocusable(focusable2, mergedMask, focusTriggerAfterClose);
    const handleCancel = (e) => {
      if (confirmLoading) {
        return;
      }
      onCancel?.(e);
      onClose?.();
    };
    const handleOk = (e) => {
      onOk?.(e);
      onClose?.();
    };
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$y(prefixCls, rootCls);
    const wrapClassNameExtended = clsx(wrapClassName, {
      [`${prefixCls}-centered`]: centered ?? contextCentered,
      [`${prefixCls}-wrap-rtl`]: direction === "rtl"
    });
    const dialogFooter = footer !== null && !loading ? reactExports.createElement(Footer, {
      ...props,
      okButtonProps: {
        ...contextOkButtonProps,
        ...okButtonProps
      },
      onOk: handleOk,
      cancelButtonProps: {
        ...contextCancelButtonProps,
        ...cancelButtonProps
      },
      onCancel: handleCancel
    }) : null;
    const [rawClosable, mergedCloseIcon, closeBtnIsDisabled, ariaProps] = useClosable(pickClosable(props), pickClosable(modalContext), {
      closable: true,
      closeIcon: reactExports.createElement(RefIcon$k, {
        className: `${prefixCls}-close-icon`
      }),
      closeIconRender: (icon) => renderCloseIcon(prefixCls, icon)
    });
    const mergedClosable = rawClosable ? {
      disabled: closeBtnIsDisabled,
      closeIcon: mergedCloseIcon,
      afterClose: closableAfterClose,
      ...ariaProps
    } : false;
    const mergedModalRender = modalRender ? (node2) => reactExports.createElement("div", {
      className: `${prefixCls}-render`
    }, modalRender(node2)) : void 0;
    const panelClassName = `.${prefixCls}-${modalRender ? "render" : "container"}`;
    const innerPanelRef = usePanelRef(panelClassName);
    const mergedPanelRef = composeRef(panelRef, innerPanelRef);
    const [zIndex, contextZIndex] = useZIndex("Modal", customizeZIndex);
    const mergedProps = {
      ...props,
      width,
      panelRef,
      focusTriggerAfterClose: mergedFocusable.focusTriggerAfterClose,
      focusable: mergedFocusable,
      mask: mergedMask,
      maskClosable: mergeMaskClosable,
      zIndex
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames, maskBlurClassName], [contextStyles, styles], {
      props: mergedProps
    });
    const [numWidth, responsiveWidth] = reactExports.useMemo(() => {
      if (width && typeof width === "object") {
        return [void 0, width];
      }
      return [width, void 0];
    }, [width]);
    const responsiveWidthVars = reactExports.useMemo(() => {
      const vars = {};
      if (responsiveWidth) {
        Object.keys(responsiveWidth).forEach((breakpoint) => {
          const breakpointWidth = responsiveWidth[breakpoint];
          if (breakpointWidth !== void 0) {
            vars[`--${prefixCls}-${breakpoint}-width`] = typeof breakpointWidth === "number" ? `${breakpointWidth}px` : breakpointWidth;
          }
        });
      }
      return vars;
    }, [prefixCls, responsiveWidth]);
    return reactExports.createElement(ContextIsolator, {
      form: true,
      space: true
    }, reactExports.createElement(ZIndexContext.Provider, {
      value: contextZIndex
    }, reactExports.createElement(DialogWrap, {
      width: numWidth,
      ...restProps,
      zIndex,
      getContainer: getContainer2 === void 0 ? getContextPopupContainer : getContainer2,
      prefixCls,
      rootClassName: clsx(hashId, rootClassName, cssVarCls, rootCls, mergedClassNames.root),
      rootStyle: mergedStyles.root,
      footer: dialogFooter,
      visible: open2,
      mousePosition: customizeMousePosition ?? mousePosition,
      onClose: handleCancel,
      closable: mergedClosable,
      closeIcon: mergedCloseIcon,
      transitionName: getTransitionName(rootPrefixCls, "zoom", props.transitionName),
      maskTransitionName: getTransitionName(rootPrefixCls, "fade", props.maskTransitionName),
      mask: mergedMask,
      maskClosable: mergeMaskClosable,
      className: clsx(hashId, className, contextClassName),
      style: {
        ...contextStyle,
        ...style2,
        ...responsiveWidthVars
      },
      classNames: {
        ...mergedClassNames,
        wrapper: clsx(mergedClassNames.wrapper, wrapClassNameExtended)
      },
      styles: mergedStyles,
      panelRef: mergedPanelRef,
      destroyOnHidden: destroyOnHidden ?? destroyOnClose,
      modalRender: mergedModalRender,
focusTriggerAfterClose: mergedFocusable.focusTriggerAfterClose,
      focusTrap: mergedFocusable.trap
    }, loading ? reactExports.createElement(Skeleton, {
      active: true,
      title: false,
      paragraph: {
        rows: 4
      },
      className: `${prefixCls}-body-skeleton`
    }) : children)));
  };
  const genModalConfirmStyle = (token2) => {
    const {
      componentCls,
      titleFontSize,
      titleLineHeight,
      modalConfirmIconSize,
      fontSize,
      lineHeight,
      modalTitleHeight,
      fontHeight,
      confirmBodyPadding
    } = token2;
    const confirmComponentCls = `${componentCls}-confirm`;
    return {
      [confirmComponentCls]: {
        "&-rtl": {
          direction: "rtl"
        },
        [`${token2.antCls}-modal-header`]: {
          display: "none"
        },
        [`${confirmComponentCls}-body-wrapper`]: {
          ...clearFix()
        },
        [`&${componentCls} ${componentCls}-body`]: {
          padding: confirmBodyPadding
        },
[`${confirmComponentCls}-body`]: {
          display: "flex",
          flexWrap: "nowrap",
          alignItems: "start",
          [`> ${token2.iconCls}`]: {
            flex: "none",
            fontSize: modalConfirmIconSize,
            marginInlineEnd: token2.confirmIconMarginInlineEnd,
            marginTop: token2.calc(token2.calc(fontHeight).sub(modalConfirmIconSize).equal()).div(2).equal()
          },
          [`&-has-title > ${token2.iconCls}`]: {
            marginTop: token2.calc(token2.calc(modalTitleHeight).sub(modalConfirmIconSize).equal()).div(2).equal()
          }
        },
        [`${confirmComponentCls}-paragraph`]: {
          display: "flex",
          flexDirection: "column",
          flex: "auto",
          rowGap: token2.marginXS,
maxWidth: `calc(100% - ${unit$1(token2.marginSM)})`
        },
        [`${confirmComponentCls}-body-no-icon ${confirmComponentCls}-paragraph`]: {
          maxWidth: "100%"
        },
[`${token2.iconCls} + ${confirmComponentCls}-paragraph`]: {
          maxWidth: `calc(100% - ${unit$1(token2.calc(token2.modalConfirmIconSize).add(token2.marginSM).equal())})`
        },
        [`${confirmComponentCls}-title`]: {
          color: token2.colorTextHeading,
          fontWeight: token2.fontWeightStrong,
          fontSize: titleFontSize,
          lineHeight: titleLineHeight
        },
        [`${confirmComponentCls}-container`]: {
          color: token2.colorText,
          fontSize,
          lineHeight
        },
[`${confirmComponentCls}-btns`]: {
          textAlign: "end",
          marginTop: token2.confirmBtnsMarginTop,
          [`${token2.antCls}-btn + ${token2.antCls}-btn`]: {
            marginBottom: 0,
            marginInlineStart: token2.marginXS
          }
        }
      },
      [`${confirmComponentCls}-error ${confirmComponentCls}-body > ${token2.iconCls}`]: {
        color: token2.colorError
      },
      [`${confirmComponentCls}-warning ${confirmComponentCls}-body > ${token2.iconCls},
        ${confirmComponentCls}-confirm ${confirmComponentCls}-body > ${token2.iconCls}`]: {
        color: token2.colorWarning
      },
      [`${confirmComponentCls}-info ${confirmComponentCls}-body > ${token2.iconCls}`]: {
        color: token2.colorInfo
      },
      [`${confirmComponentCls}-success ${confirmComponentCls}-body > ${token2.iconCls}`]: {
        color: token2.colorSuccess
      }
    };
  };
  const Confirm = genSubStyleComponent(["Modal", "confirm"], (token2) => {
    const modalToken = prepareToken$3(token2);
    return genModalConfirmStyle(modalToken);
  }, prepareComponentToken$o, {
order: -1e3
  });
  const ConfirmContent = (props) => {
    const {
      prefixCls,
      icon,
      okText,
      cancelText,
      confirmPrefixCls,
      type: type4,
      okCancel,
      footer,
locale: staticLocale,
      autoFocusButton,
      focusable: focusable2,
      ...restProps
    } = props;
    let mergedIcon = icon;
    if (!icon && icon !== null) {
      switch (type4) {
        case "info":
          mergedIcon = reactExports.createElement(RefIcon$i, null);
          break;
        case "success":
          mergedIcon = reactExports.createElement(RefIcon$m, null);
          break;
        case "error":
          mergedIcon = reactExports.createElement(RefIcon$l, null);
          break;
        default:
          mergedIcon = reactExports.createElement(RefIcon$j, null);
      }
    }
    const mergedOkCancel = okCancel ?? type4 === "confirm";
    const mergedAutoFocusButton = reactExports.useMemo(() => {
      const base = focusable2?.autoFocusButton || autoFocusButton;
      return base || base === null ? base : "ok";
    }, [autoFocusButton, focusable2?.autoFocusButton]);
    const [locale2] = useLocale("Modal");
    const mergedLocale = staticLocale || locale2;
    const okTextLocale = okText || (mergedOkCancel ? mergedLocale?.okText : mergedLocale?.justOkText);
    const cancelTextLocale = cancelText || mergedLocale?.cancelText;
    const {
      closable
    } = restProps;
    const {
      onClose
    } = closable && typeof closable === "object" ? closable : {};
    const memoizedValue = reactExports.useMemo(() => {
      return {
        autoFocusButton: mergedAutoFocusButton,
        cancelTextLocale,
        okTextLocale,
        mergedOkCancel,
        onClose,
        ...restProps
      };
    }, [mergedAutoFocusButton, cancelTextLocale, okTextLocale, mergedOkCancel, onClose, restProps]);
    const footerOriginNode = reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(ConfirmCancelBtn, null), reactExports.createElement(ConfirmOkBtn, null));
    const hasTitle = isNonNullable(props.title) && props.title !== "";
    const hasIcon = isNonNullable(mergedIcon);
    const bodyCls = `${confirmPrefixCls}-body`;
    return reactExports.createElement("div", {
      className: `${confirmPrefixCls}-body-wrapper`
    }, reactExports.createElement("div", {
      className: clsx(bodyCls, {
        [`${bodyCls}-has-title`]: hasTitle,
        [`${bodyCls}-no-icon`]: !hasIcon
      })
    }, mergedIcon, reactExports.createElement("div", {
      className: `${confirmPrefixCls}-paragraph`
    }, hasTitle && reactExports.createElement("span", {
      className: `${confirmPrefixCls}-title`
    }, props.title), reactExports.createElement("div", {
      className: `${confirmPrefixCls}-content`
    }, props.content))), footer === void 0 || typeof footer === "function" ? reactExports.createElement(ModalContextProvider, {
      value: memoizedValue
    }, reactExports.createElement("div", {
      className: `${confirmPrefixCls}-btns`
    }, typeof footer === "function" ? footer(footerOriginNode, {
      OkBtn: ConfirmOkBtn,
      CancelBtn: ConfirmCancelBtn
    }) : footerOriginNode)) : footer, reactExports.createElement(Confirm, {
      prefixCls
    }));
  };
  const ConfirmDialog = (props) => {
    const {
      close,
      zIndex,
      maskStyle,
      direction,
      prefixCls,
      wrapClassName,
      rootPrefixCls,
      bodyStyle,
      closable = false,
      onConfirm,
      styles,
      title,
      mask: mask2,
      maskClosable,
      okButtonProps,
      cancelButtonProps
    } = props;
    const {
      cancelButtonProps: contextCancelButtonProps,
      okButtonProps: contextOkButtonProps
    } = useComponentConfig("modal");
    const confirmPrefixCls = `${prefixCls}-confirm`;
    const width = props.width || 416;
    const style2 = props.style || {};
    const classString = clsx(confirmPrefixCls, `${confirmPrefixCls}-${props.type}`, {
      [`${confirmPrefixCls}-rtl`]: direction === "rtl"
    }, props.className);
    const mergedMask = reactExports.useMemo(() => {
      const nextMaskConfig = normalizeMaskConfig(mask2, maskClosable);
      nextMaskConfig.closable ?? (nextMaskConfig.closable = false);
      return nextMaskConfig;
    }, [mask2, maskClosable]);
    const [, token2] = useToken$1();
    const mergedZIndex = reactExports.useMemo(() => {
      if (zIndex !== void 0) {
        return zIndex;
      }
      return token2.zIndexPopupBase + CONTAINER_MAX_OFFSET;
    }, [zIndex, token2]);
    return reactExports.createElement(Modal$1, {
      ...props,
      className: classString,
      wrapClassName: clsx({
        [`${confirmPrefixCls}-centered`]: !!props.centered
      }, wrapClassName),
      onCancel: () => {
        close?.({
          triggerCancel: true
        });
        onConfirm?.(false);
      },
      title,
      footer: null,
      transitionName: getTransitionName(rootPrefixCls || "", "zoom", props.transitionName),
      maskTransitionName: getTransitionName(rootPrefixCls || "", "fade", props.maskTransitionName),
      mask: mergedMask,
      style: style2,
      styles: {
        body: bodyStyle,
        mask: maskStyle,
        ...styles
      },
      width,
      zIndex: mergedZIndex,
      closable
    }, reactExports.createElement(ConfirmContent, {
      ...props,
      confirmPrefixCls,
      okButtonProps: {
        ...contextOkButtonProps,
        ...okButtonProps
      },
      cancelButtonProps: {
        ...contextCancelButtonProps,
        ...cancelButtonProps
      }
    }));
  };
  const ConfirmDialogWrapper$1 = (props) => {
    const {
      rootPrefixCls,
      iconPrefixCls,
      direction,
      theme: theme2
    } = props;
    return reactExports.createElement(ConfigProvider, {
      prefixCls: rootPrefixCls,
      iconPrefixCls,
      direction,
      theme: theme2
    }, reactExports.createElement(ConfirmDialog, {
      ...props
    }));
  };
  const destroyFns = [];
  let defaultRootPrefixCls = "";
  function getRootPrefixCls() {
    return defaultRootPrefixCls;
  }
  const ConfirmDialogWrapper = (props) => {
    const {
      prefixCls: customizePrefixCls,
      getContainer: getContainer2,
      direction
    } = props;
    const runtimeLocale2 = getConfirmLocale();
    const config = reactExports.useContext(ConfigContext);
    const rootPrefixCls = getRootPrefixCls() || config.getPrefixCls();
    const prefixCls = customizePrefixCls || `${rootPrefixCls}-modal`;
    let mergedGetContainer = getContainer2;
    if (mergedGetContainer === false) {
      mergedGetContainer = void 0;
    }
    return React.createElement(ConfirmDialogWrapper$1, {
      ...props,
      rootPrefixCls,
      prefixCls,
      iconPrefixCls: config.iconPrefixCls,
      theme: config.theme,
      direction: direction ?? config.direction,
      locale: config.locale?.Modal ?? runtimeLocale2,
      getContainer: mergedGetContainer
    });
  };
  function confirm(config) {
    const global2 = globalConfig();
    const container = document.createDocumentFragment();
    let currentConfig = {
      ...config,
      close,
      open: true
    };
    let timeoutId;
    function destroy2(...args) {
      const triggerCancel = args.some((param) => param?.triggerCancel);
      if (triggerCancel) {
        config.onCancel?.(() => {
        }, ...args.slice(1));
      }
      for (let i2 = 0; i2 < destroyFns.length; i2++) {
        const fn = destroyFns[i2];
        if (fn === close) {
          destroyFns.splice(i2, 1);
          break;
        }
      }
      unmount(container).then(() => {
      });
    }
    const scheduleRender = (props) => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        const rootPrefixCls = global2.getPrefixCls(void 0, getRootPrefixCls());
        const iconPrefixCls = global2.getIconPrefixCls();
        const theme2 = global2.getTheme();
        const dom = React.createElement(ConfirmDialogWrapper, {
          ...props
        });
        render( React.createElement(ConfigProvider, {
          prefixCls: rootPrefixCls,
          iconPrefixCls,
          theme: theme2
        }, typeof global2.holderRender === "function" ? global2.holderRender(dom) : dom), container);
      });
    };
    function close(...args) {
      currentConfig = {
        ...currentConfig,
        open: false,
        afterClose: () => {
          if (typeof config.afterClose === "function") {
            config.afterClose();
          }
          destroy2.apply(this, args);
        }
      };
      scheduleRender(currentConfig);
    }
    function update(configUpdate) {
      if (typeof configUpdate === "function") {
        currentConfig = configUpdate(currentConfig);
      } else {
        currentConfig = {
          ...currentConfig,
          ...configUpdate
        };
      }
      scheduleRender(currentConfig);
    }
    scheduleRender(currentConfig);
    destroyFns.push(close);
    return {
      destroy: close,
      update
    };
  }
  function withWarn(props) {
    return {
      ...props,
      type: "warning"
    };
  }
  function withInfo(props) {
    return {
      ...props,
      type: "info"
    };
  }
  function withSuccess(props) {
    return {
      ...props,
      type: "success"
    };
  }
  function withError(props) {
    return {
      ...props,
      type: "error"
    };
  }
  function withConfirm(props) {
    return {
      ...props,
      type: "confirm"
    };
  }
  function modalGlobalConfig({
    rootPrefixCls
  }) {
    defaultRootPrefixCls = rootPrefixCls;
  }
  const HookModal = reactExports.forwardRef((props, ref2) => {
    const {
      afterClose: hookAfterClose,
      config,
      ...restProps
    } = props;
    const [open2, setOpen] = reactExports.useState(true);
    const [innerConfig, setInnerConfig] = reactExports.useState(config);
    const {
      direction,
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const prefixCls = getPrefixCls("modal");
    const rootPrefixCls = getPrefixCls();
    const afterClose = () => {
      hookAfterClose();
      innerConfig.afterClose?.();
    };
    const close = (...args) => {
      setOpen(false);
      const triggerCancel = args.some((param) => param?.triggerCancel);
      if (triggerCancel) {
        innerConfig.onCancel?.(() => {
        }, ...args.slice(1));
      }
    };
    reactExports.useImperativeHandle(ref2, () => ({
      destroy: close,
      update: (newConfig) => {
        setInnerConfig((originConfig) => {
          const nextConfig = typeof newConfig === "function" ? newConfig(originConfig) : newConfig;
          return {
            ...originConfig,
            ...nextConfig
          };
        });
      }
    }));
    const mergedOkCancel = innerConfig.okCancel ?? innerConfig.type === "confirm";
    const [contextLocale] = useLocale("Modal", localeValues.Modal);
    return reactExports.createElement(ConfirmDialogWrapper$1, {
      prefixCls,
      rootPrefixCls,
      ...innerConfig,
      close,
      open: open2,
      afterClose,
      okText: innerConfig.okText || (mergedOkCancel ? contextLocale?.okText : contextLocale?.justOkText),
      direction: innerConfig.direction || direction,
      cancelText: innerConfig.cancelText || contextLocale?.cancelText,
      ...restProps
    });
  });
  let uuid$1 = 0;
  const ElementsHolder = reactExports.memo( reactExports.forwardRef((_props, ref2) => {
    const [elements, patchElement] = usePatchElement();
    reactExports.useImperativeHandle(ref2, () => ({
      patchElement
    }), [patchElement]);
    return reactExports.createElement(reactExports.Fragment, null, elements);
  }));
  function useModal() {
    const holderRef = reactExports.useRef(null);
    const [actionQueue, setActionQueue] = reactExports.useState([]);
    reactExports.useEffect(() => {
      if (actionQueue.length) {
        const cloneQueue = _toConsumableArray(actionQueue);
        cloneQueue.forEach((action2) => {
          action2();
        });
        setActionQueue([]);
      }
    }, [actionQueue]);
    const getConfirmFunc = reactExports.useCallback((withFunc) => function hookConfirm(config) {
      uuid$1 += 1;
      const modalRef = reactExports.createRef();
      let resolvePromise;
      const promise = new Promise((resolve) => {
        resolvePromise = resolve;
      });
      let silent = false;
      let closeFunc;
      const modal = reactExports.createElement(HookModal, {
        key: `modal-${uuid$1}`,
        config: withFunc(config),
        ref: modalRef,
        afterClose: () => {
          closeFunc?.();
        },
        isSilent: () => silent,
        onConfirm: (confirmed) => {
          resolvePromise(confirmed);
        }
      });
      closeFunc = holderRef.current?.patchElement(modal);
      if (closeFunc) {
        destroyFns.push(closeFunc);
      }
      const instance = {
        destroy: () => {
          function destroyAction() {
            modalRef.current?.destroy();
          }
          if (modalRef.current) {
            destroyAction();
          } else {
            setActionQueue((prev2) => [].concat(_toConsumableArray(prev2), [destroyAction]));
          }
        },
        update: (newConfig) => {
          function updateAction() {
            modalRef.current?.update(newConfig);
          }
          if (modalRef.current) {
            updateAction();
          } else {
            setActionQueue((prev2) => [].concat(_toConsumableArray(prev2), [updateAction]));
          }
        },
        then: (resolve) => {
          silent = true;
          return promise.then(resolve);
        }
      };
      return instance;
    }, []);
    const fns = reactExports.useMemo(() => ({
      info: getConfirmFunc(withInfo),
      success: getConfirmFunc(withSuccess),
      error: getConfirmFunc(withError),
      warning: getConfirmFunc(withWarn),
      confirm: getConfirmFunc(withConfirm)
    }), [getConfirmFunc]);
    return [fns, reactExports.createElement(ElementsHolder, {
      key: "modal-holder",
      ref: holderRef
    })];
  }
  const genNotificationPlacementStyle = (token2) => {
    const {
      componentCls,
      notificationMarginEdge,
      animationMaxHeight
    } = token2;
    const noticeCls = `${componentCls}-notice`;
    const rightFadeIn = new Keyframe("antNotificationFadeIn", {
      "0%": {
        transform: `translate3d(100%, 0, 0)`,
        opacity: 0
      },
      "100%": {
        transform: `translate3d(0, 0, 0)`,
        opacity: 1
      }
    });
    const topFadeIn = new Keyframe("antNotificationTopFadeIn", {
      "0%": {
        top: -animationMaxHeight,
        opacity: 0
      },
      "100%": {
        top: 0,
        opacity: 1
      }
    });
    const bottomFadeIn = new Keyframe("antNotificationBottomFadeIn", {
      "0%": {
        bottom: token2.calc(animationMaxHeight).mul(-1).equal(),
        opacity: 0
      },
      "100%": {
        bottom: 0,
        opacity: 1
      }
    });
    const leftFadeIn = new Keyframe("antNotificationLeftFadeIn", {
      "0%": {
        transform: `translate3d(-100%, 0, 0)`,
        opacity: 0
      },
      "100%": {
        transform: `translate3d(0, 0, 0)`,
        opacity: 1
      }
    });
    return {
      [componentCls]: {
        [`&${componentCls}-top, &${componentCls}-bottom`]: {
          marginInline: 0,
          [noticeCls]: {
            marginInline: "auto auto"
          }
        },
        [`&${componentCls}-top`]: {
          [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
            animationName: topFadeIn
          }
        },
        [`&${componentCls}-bottom`]: {
          [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
            animationName: bottomFadeIn
          }
        },
        [`&${componentCls}-topRight, &${componentCls}-bottomRight`]: {
          [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
            animationName: rightFadeIn
          }
        },
        [`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {
          marginRight: {
            value: 0,
            _skip_check_: true
          },
          marginLeft: {
            value: notificationMarginEdge,
            _skip_check_: true
          },
          [noticeCls]: {
            marginInlineEnd: "auto",
            marginInlineStart: 0
          },
          [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
            animationName: leftFadeIn
          }
        }
      }
    };
  };
  const NotificationPlacements = ["top", "topLeft", "topRight", "bottom", "bottomLeft", "bottomRight"];
  const placementAlignProperty = {
    topLeft: "left",
    topRight: "right",
    bottomLeft: "left",
    bottomRight: "right",
    top: "left",
    bottom: "left"
  };
  const genPlacementStackStyle = (token2, placement) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-${placement}`]: {
        [`&${componentCls}-stack > ${componentCls}-notice-wrapper`]: {
          [placement.startsWith("top") ? "top" : "bottom"]: 0,
          [placementAlignProperty[placement]]: {
            value: 0,
            _skip_check_: true
          }
        }
      }
    };
  };
  const genStackChildrenStyle = (token2) => {
    const childrenStyle = {};
    for (let i2 = 1; i2 < token2.notificationStackLayer; i2++) {
      childrenStyle[`&:nth-last-child(${i2 + 1})`] = {
        overflow: "hidden",
        [`& > ${token2.componentCls}-notice`]: {
          opacity: 0,
          transition: `opacity ${token2.motionDurationMid}`
        }
      };
    }
    return {
      [`&:not(:nth-last-child(-n+${token2.notificationStackLayer}))`]: {
        opacity: 0,
        overflow: "hidden",
        color: "transparent",
        pointerEvents: "none"
      },
      ...childrenStyle
    };
  };
  const genStackedNoticeStyle = (token2) => {
    const childrenStyle = {};
    for (let i2 = 1; i2 < token2.notificationStackLayer; i2++) {
      childrenStyle[`&:nth-last-child(${i2 + 1})`] = {
        background: token2.colorBgBlur,
        backdropFilter: "blur(10px)",
        "-webkit-backdrop-filter": "blur(10px)"
      };
    }
    return childrenStyle;
  };
  const genStackStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-stack`]: {
        [`& > ${componentCls}-notice-wrapper`]: {
          transition: `transform ${token2.motionDurationSlow}, backdrop-filter 0s`,
          willChange: "transform, opacity",
          position: "absolute",
          ...genStackChildrenStyle(token2)
        }
      },
      [`${componentCls}-stack:not(${componentCls}-stack-expanded)`]: {
        [`& > ${componentCls}-notice-wrapper`]: {
          ...genStackedNoticeStyle(token2)
        }
      },
      [`${componentCls}-stack${componentCls}-stack-expanded`]: {
        [`& > ${componentCls}-notice-wrapper`]: {
          "&:not(:nth-last-child(-n + 1))": {
            opacity: 1,
            overflow: "unset",
            color: "inherit",
            pointerEvents: "auto",
            [`& > ${token2.componentCls}-notice`]: {
              opacity: 1
            }
          },
          "&:after": {
            content: '""',
            position: "absolute",
            height: token2.margin,
            width: "100%",
            insetInline: 0,
            bottom: token2.calc(token2.margin).mul(-1).equal(),
            background: "transparent",
            pointerEvents: "auto"
          }
        }
      },
      ...NotificationPlacements.map((placement) => genPlacementStackStyle(token2, placement)).reduce((acc, cur) => ({
        ...acc,
        ...cur
      }), {})
    };
  };
  const genNoticeStyle = (token2) => {
    const {
      iconCls,
      componentCls,
boxShadow,
      fontSizeLG,
      notificationMarginBottom,
      borderRadiusLG,
      colorSuccess,
      colorInfo,
      colorWarning,
      colorError,
      colorTextHeading,
      notificationBg,
      notificationPadding,
      notificationMarginEdge,
      progressBg,
      notificationProgressHeight,
      fontSize,
      lineHeight,
      width,
      notificationIconSize,
      colorText,
      colorSuccessBg,
      colorErrorBg,
      colorInfoBg,
      colorWarningBg,
      motionDurationMid
    } = token2;
    const noticeCls = `${componentCls}-notice`;
    return {
      position: "relative",
      marginBottom: notificationMarginBottom,
      marginInlineStart: "auto",
      background: notificationBg,
      borderRadius: borderRadiusLG,
      boxShadow,
      [noticeCls]: {
        padding: notificationPadding,
        width,
        maxWidth: `calc(100vw - ${unit$1(token2.calc(notificationMarginEdge).mul(2).equal())})`,
        lineHeight,
        wordWrap: "break-word",
        borderRadius: borderRadiusLG,
        overflow: "hidden",
"&-success": colorSuccessBg ? {
          background: colorSuccessBg
        } : {},
        "&-error": colorErrorBg ? {
          background: colorErrorBg
        } : {},
        "&-info": colorInfoBg ? {
          background: colorInfoBg
        } : {},
        "&-warning": colorWarningBg ? {
          background: colorWarningBg
        } : {}
      },
      [`${noticeCls}-title`]: {
        marginBottom: token2.marginXS,
        color: colorTextHeading,
        fontSize: fontSizeLG,
        lineHeight: token2.lineHeightLG
      },
      [`${noticeCls}-description`]: {
        fontSize,
        color: colorText,
        marginTop: token2.marginXS
      },
      [`${noticeCls}-closable ${noticeCls}-title`]: {
        paddingInlineEnd: token2.paddingLG
      },
      [`${noticeCls}-with-icon ${noticeCls}-title`]: {
        marginBottom: token2.marginXS,
        marginInlineStart: token2.calc(token2.marginSM).add(notificationIconSize).equal(),
        fontSize: fontSizeLG
      },
      [`${noticeCls}-with-icon ${noticeCls}-description`]: {
        marginInlineStart: token2.calc(token2.marginSM).add(notificationIconSize).equal(),
        fontSize
      },


[`${noticeCls}-icon`]: {
        position: "absolute",
        fontSize: notificationIconSize,
        lineHeight: 1,
[`&-success${iconCls}`]: {
          color: colorSuccess
        },
        [`&-info${iconCls}`]: {
          color: colorInfo
        },
        [`&-warning${iconCls}`]: {
          color: colorWarning
        },
        [`&-error${iconCls}`]: {
          color: colorError
        }
      },
      [`${noticeCls}-close`]: {
        position: "absolute",
        top: token2.notificationPaddingVertical,
        insetInlineEnd: token2.notificationPaddingHorizontal,
        color: token2.colorIcon,
        outline: "none",
        width: token2.notificationCloseButtonSize,
        height: token2.notificationCloseButtonSize,
        borderRadius: token2.borderRadiusSM,
        transition: ["color", "background-color"].map((prop) => `${prop} ${motionDurationMid}`).join(", "),
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        background: "none",
        border: "none",
        "&:hover": {
          color: token2.colorIconHover,
          backgroundColor: token2.colorBgTextHover
        },
        "&:active": {
          backgroundColor: token2.colorBgTextActive
        },
        ...genFocusStyle(token2)
      },
      [`${noticeCls}-progress`]: {
        position: "absolute",
        display: "block",
        appearance: "none",
        inlineSize: `calc(100% - ${unit$1(borderRadiusLG)} * 2)`,
        left: {
          _skip_check_: true,
          value: borderRadiusLG
        },
        right: {
          _skip_check_: true,
          value: borderRadiusLG
        },
        bottom: 0,
        blockSize: notificationProgressHeight,
        border: 0,
        "&, &::-webkit-progress-bar": {
          borderRadius: borderRadiusLG,
          backgroundColor: `rgba(0, 0, 0, 0.04)`
        },
        "&::-moz-progress-bar": {
          background: progressBg
        },
        "&::-webkit-progress-value": {
          borderRadius: borderRadiusLG,
          background: progressBg
        }
      },
      [`${noticeCls}-actions`]: {
        float: "right",
        marginTop: token2.marginSM
      }
    };
  };
  const genNotificationStyle = (token2) => {
    const {
      componentCls,
notificationMarginBottom,
      notificationMarginEdge,
      motionDurationMid,
      motionEaseInOut
    } = token2;
    const noticeCls = `${componentCls}-notice`;
    const fadeOut2 = new Keyframe("antNotificationFadeOut", {
      "0%": {
        maxHeight: token2.animationMaxHeight,
        marginBottom: notificationMarginBottom
      },
      "100%": {
        maxHeight: 0,
        marginBottom: 0,
        paddingTop: 0,
        paddingBottom: 0,
        opacity: 0
      }
    });
    return [
{
        [componentCls]: {
          ...resetComponent(token2),
          position: "fixed",
          zIndex: token2.zIndexPopup,
          marginRight: {
            value: notificationMarginEdge,
            _skip_check_: true
          },
          [`${componentCls}-hook-holder`]: {
            position: "relative"
          },
[`${componentCls}-fade-appear-prepare`]: {
            opacity: "0 !important"
          },
          [`${componentCls}-fade-enter, ${componentCls}-fade-appear`]: {
            animationDuration: token2.motionDurationMid,
            animationTimingFunction: motionEaseInOut,
            animationFillMode: "both",
            opacity: 0,
            animationPlayState: "paused"
          },
          [`${componentCls}-fade-leave`]: {
            animationTimingFunction: motionEaseInOut,
            animationFillMode: "both",
            animationDuration: motionDurationMid,
            animationPlayState: "paused"
          },
          [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
            animationPlayState: "running"
          },
          [`${componentCls}-fade-leave${componentCls}-fade-leave-active`]: {
            animationName: fadeOut2,
            animationPlayState: "running"
          },
"&-rtl": {
            direction: "rtl",
            [`${noticeCls}-actions`]: {
              float: "left"
            }
          }
        }
      },
{
        [componentCls]: {
          [`${noticeCls}-wrapper`]: genNoticeStyle(token2)
        }
      }
    ];
  };
  const prepareComponentToken$n = (token2) => ({
    zIndexPopup: token2.zIndexPopupBase + CONTAINER_MAX_OFFSET + 50,
    width: 384,
    progressBg: `linear-gradient(90deg, ${token2.colorPrimaryBorderHover}, ${token2.colorPrimary})`,


colorSuccessBg: void 0,
    colorErrorBg: void 0,
    colorInfoBg: void 0,
    colorWarningBg: void 0
  });
  const prepareNotificationToken = (token2) => {
    const notificationPaddingVertical = token2.paddingMD;
    const notificationPaddingHorizontal = token2.paddingLG;
    const notificationToken = merge$1(token2, {
      notificationBg: token2.colorBgElevated,
      notificationPaddingVertical,
      notificationPaddingHorizontal,
      notificationIconSize: token2.calc(token2.fontSizeLG).mul(token2.lineHeightLG).equal(),
      notificationCloseButtonSize: token2.calc(token2.controlHeightLG).mul(0.55).equal(),
      notificationMarginBottom: token2.margin,
      notificationPadding: `${unit$1(token2.paddingMD)} ${unit$1(token2.paddingContentHorizontalLG)}`,
      notificationMarginEdge: token2.marginLG,
      animationMaxHeight: 150,
      notificationStackLayer: 3,
      notificationProgressHeight: 2
    });
    return notificationToken;
  };
  const useStyle$x = genStyleHooks("Notification", (token2) => {
    const notificationToken = prepareNotificationToken(token2);
    return [genNotificationStyle(notificationToken), genNotificationPlacementStyle(notificationToken), genStackStyle(notificationToken)];
  }, prepareComponentToken$n);
  const PurePanelStyle = genSubStyleComponent(["Notification", "PurePanel"], (token2) => {
    const noticeCls = `${token2.componentCls}-notice`;
    const notificationToken = prepareNotificationToken(token2);
    return {
      [`${noticeCls}-pure-panel`]: {
        ...genNoticeStyle(notificationToken),
        width: notificationToken.width,
        maxWidth: `calc(100vw - ${unit$1(token2.calc(notificationToken.notificationMarginEdge).mul(2).equal())})`,
        margin: 0
      }
    };
  }, prepareComponentToken$n);
  function getCloseIcon(prefixCls, closeIcon) {
    if (closeIcon === null || closeIcon === false) {
      return null;
    }
    return closeIcon || reactExports.createElement(RefIcon$k, {
      className: `${prefixCls}-close-icon`
    });
  }
  const typeToIcon = {
    success: RefIcon$m,
    info: RefIcon$i,
    error: RefIcon$l,
    warning: RefIcon$j
  };
  const PureContent = (props) => {
    const {
      prefixCls,
      icon,
      type: type4,
      title,
      description,
      actions,
      role = "alert",
      styles,
      classNames: pureContentCls
    } = props;
    let iconNode = null;
    if (icon) {
      iconNode = reactExports.createElement("span", {
        className: clsx(`${prefixCls}-icon`, pureContentCls.icon),
        style: styles.icon
      }, icon);
    } else if (type4) {
      iconNode = reactExports.createElement(typeToIcon[type4] || null, {
        className: clsx(`${prefixCls}-icon`, pureContentCls.icon, `${prefixCls}-icon-${type4}`),
        style: styles.icon
      });
    }
    return reactExports.createElement("div", {
      className: clsx({
        [`${prefixCls}-with-icon`]: iconNode
      }),
      role
    }, iconNode, reactExports.createElement("div", {
      className: clsx(`${prefixCls}-title`, pureContentCls.title),
      style: styles.title
    }, title), description && reactExports.createElement("div", {
      className: clsx(`${prefixCls}-description`, pureContentCls.description),
      style: styles.description
    }, description), actions && reactExports.createElement("div", {
      className: clsx(`${prefixCls}-actions`, pureContentCls.actions),
      style: styles.actions
    }, actions));
  };
  const PurePanel$9 = (props) => {
    const {
      prefixCls: staticPrefixCls,
      icon,
      type: type4,
      message: message2,
      title,
      description,
      btn,
      actions,
      closeIcon: _closeIcon,
      className: notificationClassName,
      style: style2,
      styles,
      classNames: notificationClassNames,
      closable,
      ...restProps
    } = props;
    const {
      getPrefixCls,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("notification");
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, notificationClassNames], [contextStyles, styles], {
      props
    });
    const {
      notification: notificationContext
    } = reactExports.useContext(ConfigContext);
    const mergedActions = actions ?? btn;
    const mergedTitle = title ?? message2;
    const prefixCls = staticPrefixCls || getPrefixCls("notification");
    const noticePrefixCls = `${prefixCls}-notice`;
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$x(prefixCls, rootCls);
    const [rawClosable, mergedCloseIcon, , ariaProps] = useClosable(pickClosable(props), pickClosable(notificationContext), {
      closable: true,
      closeIcon: reactExports.createElement(RefIcon$k, {
        className: `${prefixCls}-close-icon`
      }),
      closeIconRender: (icon2) => getCloseIcon(prefixCls, icon2)
    });
    const mergedClosable = rawClosable ? {
      onClose: closable && typeof closable === "object" ? closable?.onClose : void 0,
      closeIcon: mergedCloseIcon,
      ...ariaProps
    } : false;
    return reactExports.createElement("div", {
      className: clsx(`${noticePrefixCls}-pure-panel`, hashId, notificationClassName, cssVarCls, rootCls, mergedClassNames.root),
      style: mergedStyles.root
    }, reactExports.createElement(PurePanelStyle, {
      prefixCls
    }), reactExports.createElement(Notify, {
      style: {
        ...contextStyle,
        ...style2
      },
      ...restProps,
      prefixCls,
      eventKey: "pure",
      duration: null,
      closable: mergedClosable,
      className: clsx(notificationClassName, contextClassName),
      content: reactExports.createElement(PureContent, {
        classNames: mergedClassNames,
        styles: mergedStyles,
        prefixCls: noticePrefixCls,
        icon,
        type: type4,
        title: mergedTitle,
        description,
        actions: mergedActions
      })
    }));
  };
  function getPlacementStyle(placement, top, bottom) {
    let style2;
    switch (placement) {
      case "top":
        style2 = {
          left: "50%",
          transform: "translateX(-50%)",
          right: "auto",
          top,
          bottom: "auto"
        };
        break;
      case "topLeft":
        style2 = {
          left: 0,
          top,
          bottom: "auto"
        };
        break;
      case "topRight":
        style2 = {
          right: 0,
          top,
          bottom: "auto"
        };
        break;
      case "bottom":
        style2 = {
          left: "50%",
          transform: "translateX(-50%)",
          right: "auto",
          top: "auto",
          bottom
        };
        break;
      case "bottomLeft":
        style2 = {
          left: 0,
          top: "auto",
          bottom
        };
        break;
      default:
        style2 = {
          right: 0,
          top: "auto",
          bottom
        };
        break;
    }
    return style2;
  }
  function getMotion$1(prefixCls) {
    return {
      motionName: `${prefixCls}-fade`
    };
  }
  function getCloseIconConfig(closeIcon, notificationConfig, notification2) {
    if (typeof closeIcon !== "undefined") {
      return closeIcon;
    }
    if (typeof notificationConfig?.closeIcon !== "undefined") {
      return notificationConfig.closeIcon;
    }
    return notification2?.closeIcon;
  }
  const DEFAULT_OFFSET = 24;
  const DEFAULT_DURATION = 4.5;
  const DEFAULT_PLACEMENT = "topRight";
  const Wrapper = ({
    children,
    prefixCls
  }) => {
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$x(prefixCls, rootCls);
    return React.createElement(NotificationProvider, {
      classNames: {
        list: clsx(hashId, cssVarCls, rootCls)
      }
    }, children);
  };
  const renderNotifications = (node2, {
    prefixCls,
    key
  }) => React.createElement(Wrapper, {
    prefixCls,
    key
  }, node2);
  const Holder = React.forwardRef((props, ref2) => {
    const {
      top,
      bottom,
      prefixCls: staticPrefixCls,
      getContainer: staticGetContainer,
      maxCount,
      rtl,
      onAllRemoved,
      stack: stack2,
      duration: duration2 = DEFAULT_DURATION,
      pauseOnHover = true,
      showProgress
    } = props;
    const {
      getPrefixCls,
      getPopupContainer,
      direction
    } = useComponentConfig("notification");
    const {
      notification: notification2
    } = reactExports.useContext(ConfigContext);
    const [, token2] = useToken$1();
    const prefixCls = staticPrefixCls || getPrefixCls("notification");
    const mergedDuration = reactExports.useMemo(() => typeof duration2 === "number" && duration2 > 0 ? duration2 : false, [duration2]);
    const getStyle2 = (placement) => getPlacementStyle(placement, top ?? DEFAULT_OFFSET, bottom ?? DEFAULT_OFFSET);
    const getClassName = () => clsx({
      [`${prefixCls}-rtl`]: rtl ?? direction === "rtl"
    });
    const getNotificationMotion = () => getMotion$1(prefixCls);
    const [api, holder] = useNotification$1({
      prefixCls,
      style: getStyle2,
      className: getClassName,
      motion: getNotificationMotion,
      closable: {
        closeIcon: getCloseIcon(prefixCls)
      },
      duration: mergedDuration,
      getContainer: () => staticGetContainer?.() || getPopupContainer?.() || document.body,
      maxCount,
      pauseOnHover,
      showProgress,
      onAllRemoved,
      renderNotifications,
      stack: stack2 === false ? false : {
        threshold: typeof stack2 === "object" ? stack2?.threshold : void 0,
        offset: 8,
        gap: token2.margin
      }
    });
    const [mergedClassNames, mergedStyles] = useMergeSemantic([notification2?.classNames, props?.classNames], [notification2?.styles, props?.styles], {
      props
    });
    React.useImperativeHandle(ref2, () => ({
      ...api,
      prefixCls,
      notification: notification2,
      classNames: mergedClassNames,
      styles: mergedStyles
    }));
    return holder;
  });
  function useInternalNotification(notificationConfig) {
    const holderRef = React.useRef(null);
    const {
      notification: notificationContext
    } = React.useContext(ConfigContext);
    const wrapAPI = React.useMemo(() => {
      const open2 = (config) => {
        if (!holderRef.current) {
          return;
        }
        const {
          open: originOpen,
          prefixCls,
          notification: notification2,
          classNames: originClassNames,
          styles: originStyles
        } = holderRef.current;
        const contextClassName = notification2?.className || {};
        const contextStyle = notification2?.style || {};
        const noticePrefixCls = `${prefixCls}-notice`;
        const {
          title,
          message: message2,
          description,
          icon,
          type: type4,
          btn,
          actions,
          className,
          style: style2,
          role = "alert",
          closeIcon,
          closable,
          classNames: configClassNames = {},
          styles = {},
          ...restConfig
        } = config;
        const mergedTitle = title ?? message2;
        const mergedActions = actions ?? btn;
        const realCloseIcon = getCloseIcon(noticePrefixCls, getCloseIconConfig(closeIcon, notificationConfig, notification2));
        const [rawClosable, mergedCloseIcon, , ariaProps] = computeClosable(pickClosable({
          ...notificationConfig || {},
          ...config
        }), pickClosable(notificationContext), {
          closable: true,
          closeIcon: realCloseIcon
        });
        const mergedClosable = rawClosable ? {
          onClose: closable && typeof closable === "object" ? closable.onClose : void 0,
          closeIcon: mergedCloseIcon,
          ...ariaProps
        } : false;
        const semanticClassNames = resolveStyleOrClass(configClassNames, {
          props: config
        });
        const semanticStyles = resolveStyleOrClass(styles, {
          props: config
        });
        const mergedClassNames = mergeClassNames(void 0, originClassNames, semanticClassNames);
        const mergedStyles = mergeStyles(originStyles, semanticStyles);
        return originOpen({
placement: notificationConfig?.placement ?? DEFAULT_PLACEMENT,
          ...restConfig,
          content: React.createElement(PureContent, {
            prefixCls: noticePrefixCls,
            icon,
            type: type4,
            title: mergedTitle,
            description,
            actions: mergedActions,
            role,
            classNames: mergedClassNames,
            styles: mergedStyles
          }),
          className: clsx({
            [`${noticePrefixCls}-${type4}`]: type4
          }, className, contextClassName, mergedClassNames.root),
          style: {
            ...contextStyle,
            ...mergedStyles.root,
            ...style2
          },
          closable: mergedClosable
        });
      };
      const destroy2 = (key) => {
        if (key !== void 0) {
          holderRef.current?.close(key);
        } else {
          holderRef.current?.destroy();
        }
      };
      const clone2 = {
        open: open2,
        destroy: destroy2
      };
      const keys2 = ["success", "info", "warning", "error"];
      keys2.forEach((type4) => {
        clone2[type4] = (config) => open2({
          ...config,
          type: type4
        });
      });
      return clone2;
    }, [notificationConfig, notificationContext]);
    return [wrapAPI, React.createElement(Holder, {
      key: "notification-holder",
      ...notificationConfig,
      ref: holderRef
    })];
  }
  function useNotification(notificationConfig) {
    return useInternalNotification(notificationConfig);
  }
  const AppConfigContext = React.createContext({});
  const AppContext = React.createContext({
    message: {},
    notification: {},
    modal: {}
  });
  const genBaseStyle$7 = (token2) => {
    const {
      componentCls,
      colorText,
      fontSize,
      lineHeight,
      fontFamily
    } = token2;
    return {
      [componentCls]: {
        color: colorText,
        fontSize,
        lineHeight,
        fontFamily,
        [`&${componentCls}-rtl`]: {
          direction: "rtl"
        }
      }
    };
  };
  const prepareComponentToken$m = () => ({});
  const useStyle$w = genStyleHooks("App", genBaseStyle$7, prepareComponentToken$m);
  const App$1 = (props) => {
    const {
      prefixCls: customizePrefixCls,
      children,
      className,
      rootClassName,
      message: message2,
      notification: notification2,
      style: style2,
      component = "div"
    } = props;
    const {
      direction,
      getPrefixCls,
      className: contextClassName,
      style: contextStyle
    } = useComponentConfig("app");
    const prefixCls = getPrefixCls("app", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$w(prefixCls);
    const customClassName = clsx(hashId, prefixCls, className, rootClassName, cssVarCls, {
      [`${prefixCls}-rtl`]: direction === "rtl"
    });
    const appConfig = reactExports.useContext(AppConfigContext);
    const mergedAppConfig = React.useMemo(() => ({
      message: {
        ...appConfig.message,
        ...message2
      },
      notification: {
        ...appConfig.notification,
        ...notification2
      }
    }), [message2, notification2, appConfig.message, appConfig.notification]);
    const [messageApi, messageContextHolder] = useMessage(mergedAppConfig.message);
    const [notificationApi, notificationContextHolder] = useNotification(mergedAppConfig.notification);
    const [ModalApi, ModalContextHolder] = useModal();
    const memoizedContextValue = React.useMemo(() => ({
      message: messageApi,
      notification: notificationApi,
      modal: ModalApi
    }), [messageApi, notificationApi, ModalApi]);
    const Component = component === false ? React.Fragment : component;
    const rootProps = {
      className: clsx(contextClassName, customClassName),
      style: {
        ...contextStyle,
        ...style2
      }
    };
    return React.createElement(AppContext.Provider, {
      value: memoizedContextValue
    }, React.createElement(AppConfigContext.Provider, {
      value: mergedAppConfig
    }, React.createElement(Component, {
      ...component === false ? void 0 : rootProps
    }, ModalContextHolder, messageContextHolder, notificationContextHolder, children)));
  };
  const useApp = () => React.useContext(AppContext);
  const App = App$1;
  App.useApp = useApp;
  function withPureRenderTheme(Component) {
    return (props) => reactExports.createElement(ConfigProvider, {
      theme: {
        token: {
          motion: false,
          zIndexPopupBase: 0
        }
      }
    }, reactExports.createElement(Component, {
      ...props
    }));
  }
  const genPurePanel = (Component, alignPropName, postProps, defaultPrefixCls2, getDropdownCls) => {
    const PurePanel2 = (props) => {
      const {
        prefixCls: customizePrefixCls,
        style: style2
      } = props;
      const holderRef = reactExports.useRef(null);
      const [popupHeight, setPopupHeight] = reactExports.useState(0);
      const [popupWidth, setPopupWidth] = reactExports.useState(0);
      const [open2, setOpen] = useControlledState(false, props.open);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls(defaultPrefixCls2 || "select", customizePrefixCls);
      reactExports.useEffect(() => {
        setOpen(true);
        if (typeof ResizeObserver !== "undefined") {
          const resizeObserver = new ResizeObserver((entries) => {
            const element = entries[0].target;
            setPopupHeight(element.offsetHeight + 8);
            setPopupWidth(element.offsetWidth);
          });
          const interval = setInterval(() => {
            const dropdownCls = getDropdownCls ? `.${getDropdownCls(prefixCls)}` : `.${prefixCls}-dropdown`;
            const popup = holderRef.current?.querySelector(dropdownCls);
            if (popup) {
              clearInterval(interval);
              resizeObserver.observe(popup);
            }
          }, 10);
          return () => {
            clearInterval(interval);
            resizeObserver.disconnect();
          };
        }
      }, [prefixCls]);
      let mergedProps = {
        ...props,
        style: {
          ...style2,
          margin: 0
        },
        open: open2,
        getPopupContainer: () => holderRef.current
      };
      if (postProps) {
        mergedProps = postProps(mergedProps);
      }
      if (alignPropName) {
        Object.assign(mergedProps, {
          [alignPropName]: {
            overflow: {
              adjustX: false,
              adjustY: false
            }
          }
        });
      }
      const mergedStyle = {
        paddingBottom: popupHeight,
        position: "relative",
        minWidth: popupWidth
      };
      return reactExports.createElement("div", {
        ref: holderRef,
        style: mergedStyle
      }, reactExports.createElement(Component, {
        ...mergedProps
      }));
    };
    return withPureRenderTheme(PurePanel2);
  };
  const useAllowClear = (prefixCls, displayValues, allowClear, clearIcon, disabled = false, mergedSearchValue, mode) => {
    const allowClearConfig = reactExports.useMemo(() => {
      if (typeof allowClear === "boolean") {
        return {
          allowClear
        };
      }
      if (allowClear && typeof allowClear === "object") {
        return allowClear;
      }
      return {
        allowClear: false
      };
    }, [allowClear]);
    return reactExports.useMemo(() => {
      const mergedAllowClear = !disabled && allowClearConfig.allowClear !== false && (displayValues.length || mergedSearchValue) && !(mode === "combobox" && mergedSearchValue === "");
      return {
        allowClear: mergedAllowClear,
        clearIcon: mergedAllowClear ? allowClearConfig.clearIcon || clearIcon || "×" : null
      };
    }, [allowClearConfig, clearIcon, disabled, displayValues.length, mergedSearchValue, mode]);
  };
  const BaseSelectContext = reactExports.createContext(null);
  function useBaseProps() {
    return reactExports.useContext(BaseSelectContext);
  }
  function useLock(duration2 = 250) {
    const lockRef = reactExports.useRef(null);
    const timeoutRef = reactExports.useRef(null);
    reactExports.useEffect(() => () => {
      window.clearTimeout(timeoutRef.current);
    }, []);
    function doLock(locked) {
      if (locked || lockRef.current === null) {
        lockRef.current = locked;
      }
      window.clearTimeout(timeoutRef.current);
      timeoutRef.current = window.setTimeout(() => {
        lockRef.current = null;
      }, duration2);
    }
    return [() => lockRef.current, doLock];
  }
  function isInside(elements, target) {
    return elements.filter((element) => element).some((element) => element.contains(target) || element === target);
  }
  function useSelectTriggerControl(elements, open2, triggerOpen, customizedTrigger) {
    const onGlobalMouseDown = useEvent$1((event) => {
      if (customizedTrigger) {
        return;
      }
      let target = event.target;
      if (target.shadowRoot && event.composed) {
        target = event.composedPath()[0] || target;
      }
      if (event._ori_target) {
        target = event._ori_target;
      }
      if (open2 &&
!isInside(elements(), target)) {
        triggerOpen(false);
      }
    });
    reactExports.useEffect(() => {
      window.addEventListener("mousedown", onGlobalMouseDown);
      return () => window.removeEventListener("mousedown", onGlobalMouseDown);
    }, [onGlobalMouseDown]);
  }
  function _extends$J() {
    _extends$J = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$J.apply(this, arguments);
  }
  const getBuiltInPlacements$1 = (popupMatchSelectWidth) => {
    const adjustX = popupMatchSelectWidth === true ? 0 : 1;
    return {
      bottomLeft: {
        points: ["tl", "bl"],
        offset: [0, 4],
        overflow: {
          adjustX,
          adjustY: 1
        },
        htmlRegion: "scroll"
      },
      bottomRight: {
        points: ["tr", "br"],
        offset: [0, 4],
        overflow: {
          adjustX,
          adjustY: 1
        },
        htmlRegion: "scroll"
      },
      topLeft: {
        points: ["bl", "tl"],
        offset: [0, -4],
        overflow: {
          adjustX,
          adjustY: 1
        },
        htmlRegion: "scroll"
      },
      topRight: {
        points: ["br", "tr"],
        offset: [0, -4],
        overflow: {
          adjustX,
          adjustY: 1
        },
        htmlRegion: "scroll"
      }
    };
  };
  const SelectTrigger = (props, ref2) => {
    const {
      prefixCls,
      disabled,
      visible,
      children,
      popupElement,
      animation,
      transitionName,
      popupStyle,
      popupClassName,
      direction = "ltr",
      placement,
      builtinPlacements,
      popupMatchSelectWidth,
      popupRender,
      popupAlign,
      getPopupContainer,
      empty,
      onPopupVisibleChange,
      onPopupMouseEnter,
      onPopupMouseDown,
      onPopupBlur,
      ...restProps
    } = props;
    const popupPrefixCls = `${prefixCls}-dropdown`;
    let popupNode = popupElement;
    if (popupRender) {
      popupNode = popupRender(popupElement);
    }
    const mergedBuiltinPlacements2 = reactExports.useMemo(() => builtinPlacements || getBuiltInPlacements$1(popupMatchSelectWidth), [builtinPlacements, popupMatchSelectWidth]);
    const mergedTransitionName = animation ? `${popupPrefixCls}-${animation}` : transitionName;
    const isNumberPopupWidth = typeof popupMatchSelectWidth === "number";
    const stretch = reactExports.useMemo(() => {
      if (isNumberPopupWidth) {
        return null;
      }
      return popupMatchSelectWidth === false ? "minWidth" : "width";
    }, [popupMatchSelectWidth, isNumberPopupWidth]);
    let mergedPopupStyle = popupStyle;
    if (isNumberPopupWidth) {
      mergedPopupStyle = {
        ...popupStyle,
        width: popupMatchSelectWidth
      };
    }
    const triggerPopupRef = reactExports.useRef(null);
    reactExports.useImperativeHandle(ref2, () => ({
      getPopupElement: () => triggerPopupRef.current?.popupElement
    }));
    return reactExports.createElement(Trigger, _extends$J({}, restProps, {
      showAction: onPopupVisibleChange ? ["click"] : [],
      hideAction: onPopupVisibleChange ? ["click"] : [],
      popupPlacement: placement || (direction === "rtl" ? "bottomRight" : "bottomLeft"),
      builtinPlacements: mergedBuiltinPlacements2,
      prefixCls: popupPrefixCls,
      popupMotion: {
        motionName: mergedTransitionName
      },
      popup: reactExports.createElement("div", {
        onMouseEnter: onPopupMouseEnter,
        onMouseDown: onPopupMouseDown,
        onBlur: onPopupBlur
      }, popupNode),
      ref: triggerPopupRef,
      stretch,
      popupAlign,
      popupVisible: visible,
      getPopupContainer,
      popupClassName: clsx(popupClassName, {
        [`${popupPrefixCls}-empty`]: empty
      }),
      popupStyle: mergedPopupStyle,
      onPopupVisibleChange
    }), children);
  };
  const RefSelectTrigger = reactExports.forwardRef(SelectTrigger);
  function getKey(data2, index) {
    const {
      key
    } = data2;
    let value;
    if ("value" in data2) {
      ({
        value
      } = data2);
    }
    if (key !== null && key !== void 0) {
      return key;
    }
    if (value !== void 0) {
      return value;
    }
    return `rc-index-key-${index}`;
  }
  function isValidCount(value) {
    return typeof value !== "undefined" && !Number.isNaN(value);
  }
  function fillFieldNames(fieldNames, childrenAsData) {
    const {
      label,
      value,
      options,
      groupLabel
    } = fieldNames || {};
    const mergedLabel = label || (childrenAsData ? "children" : "label");
    return {
      label: mergedLabel,
      value: value || "value",
      options: options || "options",
      groupLabel: groupLabel || mergedLabel
    };
  }
  function flattenOptions(options, {
    fieldNames,
    childrenAsData
  } = {}) {
    const flattenList = [];
    const {
      label: fieldLabel,
      value: fieldValue,
      options: fieldOptions,
      groupLabel
    } = fillFieldNames(fieldNames, false);
    function dig(list2, isGroupOption) {
      if (!Array.isArray(list2)) {
        return;
      }
      list2.forEach((data2) => {
        if (isGroupOption || !(fieldOptions in data2)) {
          const value = data2[fieldValue];
          flattenList.push({
            key: getKey(data2, flattenList.length),
            groupOption: isGroupOption,
            data: data2,
            label: data2[fieldLabel],
            value
          });
        } else {
          let grpLabel = data2[groupLabel];
          if (grpLabel === void 0 && childrenAsData) {
            grpLabel = data2.label;
          }
          flattenList.push({
            key: getKey(data2, flattenList.length),
            group: true,
            data: data2,
            label: grpLabel
          });
          dig(data2[fieldOptions], true);
        }
      });
    }
    dig(options, false);
    return flattenList;
  }
  function injectPropsWithOption(option) {
    const newOption = {
      ...option
    };
    if (!("props" in newOption)) {
      Object.defineProperty(newOption, "props", {
        get() {
          warningOnce(false, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`.");
          return newOption;
        }
      });
    }
    return newOption;
  }
  const getSeparatedContent = (text, tokens, end) => {
    if (!tokens || !tokens.length) {
      return null;
    }
    let match2 = false;
    const separate = (str, [token2, ...restTokens]) => {
      if (!token2) {
        return [str];
      }
      const list3 = str.split(token2);
      match2 = match2 || list3.length > 1;
      return list3.reduce((prevList, unitStr) => [...prevList, ...separate(unitStr, restTokens)], []).filter(Boolean);
    };
    const list2 = separate(text, tokens);
    if (match2) {
      return typeof end !== "undefined" ? list2.slice(0, end) : list2;
    } else {
      return null;
    }
  };
  function Polite(props) {
    const {
      visible,
      values
    } = props;
    if (!visible) {
      return null;
    }
    const MAX_COUNT = 50;
    return reactExports.createElement("span", {
      "aria-live": "polite",
      style: {
        width: 0,
        height: 0,
        position: "absolute",
        overflow: "hidden",
        opacity: 0
      }
    }, `${values.slice(0, MAX_COUNT).map(({
    label,
    value
  }) => ["number", "string"].includes(typeof label) ? label : value).join(", ")}`, values.length > MAX_COUNT ? ", ..." : null);
  }
  const internalMacroTask = (fn) => {
    const channel = new MessageChannel();
    channel.port1.onmessage = fn;
    channel.port2.postMessage(null);
  };
  const macroTask = (fn, times2 = 1) => {
    if (times2 <= 0) {
      fn();
      return;
    }
    internalMacroTask(() => {
      macroTask(fn, times2 - 1);
    });
  };
  function useOpen(defaultOpen, propOpen, onOpen, postOpen) {
    const [rendered, setRendered] = reactExports.useState(false);
    reactExports.useEffect(() => {
      setRendered(true);
    }, []);
    const [stateOpen, internalSetOpen] = useControlledState(defaultOpen, propOpen);
    const [lock, setLock] = reactExports.useState(false);
    const ssrSafeOpen = rendered ? stateOpen : false;
    const mergedOpen = postOpen(ssrSafeOpen);
    const taskIdRef = reactExports.useRef(0);
    const triggerEvent = useEvent$1((nextOpen) => {
      if (onOpen && mergedOpen !== nextOpen) {
        onOpen(nextOpen);
      }
      internalSetOpen(nextOpen);
    });
    const toggleOpen = useEvent$1((nextOpen, config = {}) => {
      const {
        cancelFun
      } = config;
      taskIdRef.current += 1;
      const id2 = taskIdRef.current;
      const nextOpenVal = typeof nextOpen === "boolean" ? nextOpen : !mergedOpen;
      setLock(!nextOpenVal);
      function triggerUpdate() {
        if (
id2 === taskIdRef.current &&
!cancelFun?.()
        ) {
          triggerEvent(nextOpenVal);
          setLock(false);
        }
      }
      if (nextOpenVal) {
        triggerUpdate();
      } else {
        macroTask(() => {
          triggerUpdate();
        });
      }
    });
    return [ssrSafeOpen, mergedOpen, toggleOpen, lock];
  }
  function Affix(props) {
    const {
      children,
      ...restProps
    } = props;
    if (!children) {
      return null;
    }
    return reactExports.createElement("div", restProps, children);
  }
  const SelectInputContext = reactExports.createContext(null);
  function useSelectInputContext() {
    return reactExports.useContext(SelectInputContext);
  }
  const Input$3 = reactExports.forwardRef((props, ref2) => {
    const {
      onChange,
      onKeyDown,
      onBlur,
      style: style2,
      syncWidth,
      value,
      className,
      autoComplete,
      ...restProps
    } = props;
    const {
      prefixCls,
      mode,
      onSearch,
      onSearchSubmit,
      onInputBlur,
      autoFocus,
      tokenWithEnter,
      placeholder,
      components: {
        input: InputComponent = "input"
      }
    } = useSelectInputContext();
    const {
      id: id2,
      classNames,
      styles,
      open: open2,
      activeDescendantId,
      role,
      disabled
    } = useBaseProps() || {};
    const inputCls = clsx(`${prefixCls}-input`, classNames?.input, className);
    const compositionStatusRef = reactExports.useRef(false);
    const pastedTextRef = reactExports.useRef(null);
    const inputRef = reactExports.useRef(null);
    reactExports.useImperativeHandle(ref2, () => inputRef.current);
    const handleChange = (event) => {
      let {
        value: nextVal
      } = event.target;
      if (tokenWithEnter && pastedTextRef.current && /[\r\n]/.test(pastedTextRef.current)) {
        const replacedText = pastedTextRef.current.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
        nextVal = nextVal.replace(replacedText, pastedTextRef.current);
      }
      pastedTextRef.current = null;
      if (onSearch) {
        onSearch(nextVal, true, compositionStatusRef.current);
      }
      onChange?.(event);
    };
    const handleKeyDown = (event) => {
      const {
        key
      } = event;
      const {
        value: nextVal
      } = event.currentTarget;
      if (key === "Enter" && mode === "tags" && !compositionStatusRef.current && onSearchSubmit) {
        onSearchSubmit(nextVal);
      }
      onKeyDown?.(event);
    };
    const handleBlur = (event) => {
      onInputBlur?.();
      onBlur?.(event);
    };
    const handleCompositionStart = () => {
      compositionStatusRef.current = true;
    };
    const handleCompositionEnd = (event) => {
      compositionStatusRef.current = false;
      if (mode !== "combobox") {
        const {
          value: nextVal
        } = event.currentTarget;
        onSearch?.(nextVal, true, false);
      }
    };
    const handlePaste = (event) => {
      const {
        clipboardData
      } = event;
      const pastedValue = clipboardData?.getData("text");
      pastedTextRef.current = pastedValue || "";
    };
    const [widthCssVar, setWidthCssVar] = reactExports.useState(void 0);
    useLayoutEffect(() => {
      const input = inputRef.current;
      if (syncWidth && input) {
        input.style.width = "0px";
        const scrollWidth = input.scrollWidth;
        setWidthCssVar(scrollWidth);
        input.style.width = "";
      }
    }, [syncWidth, value]);
    const sharedInputProps = {
      id: id2,
      type: mode === "combobox" ? "text" : "search",
      ...restProps,
      ref: inputRef,
      style: {
        ...styles?.input,
        ...style2,
        "--select-input-width": widthCssVar
      },
      autoFocus,
      autoComplete: autoComplete || "off",
      className: inputCls,
      disabled,
      value: value || "",
      onChange: handleChange,
      onKeyDown: handleKeyDown,
      onBlur: handleBlur,
      onPaste: handlePaste,
      onCompositionStart: handleCompositionStart,
      onCompositionEnd: handleCompositionEnd,
role: role || "combobox",
      "aria-expanded": open2 || false,
      "aria-haspopup": "listbox",
      "aria-owns": open2 ? `${id2}_list` : void 0,
      "aria-autocomplete": "list",
      "aria-controls": open2 ? `${id2}_list` : void 0,
      "aria-activedescendant": open2 ? activeDescendantId : void 0
    };
    if ( reactExports.isValidElement(InputComponent)) {
      const existingProps = InputComponent.props || {};
      const mergedProps = {
        placeholder: props.placeholder || placeholder,
        ...sharedInputProps,
        ...existingProps
      };
      Object.keys(existingProps).forEach((key) => {
        const existingValue = existingProps[key];
        if (typeof existingValue === "function") {
          mergedProps[key] = (...args) => {
            existingValue(...args);
            sharedInputProps[key]?.(...args);
          };
        }
      });
      mergedProps.ref = composeRef(InputComponent.ref, sharedInputProps.ref);
      return reactExports.cloneElement(InputComponent, mergedProps);
    }
    const Component = InputComponent;
    return reactExports.createElement(Component, sharedInputProps);
  });
  function Placeholder(props) {
    const {
      prefixCls,
      placeholder,
      displayValues
    } = useSelectInputContext();
    const {
      classNames,
      styles
    } = useBaseProps();
    const {
      show = true
    } = props;
    if (displayValues.length) {
      return null;
    }
    return reactExports.createElement("div", {
      className: clsx(`${prefixCls}-placeholder`, classNames?.placeholder),
      style: {
        visibility: show ? "visible" : "hidden",
        ...styles?.placeholder
      }
    }, placeholder);
  }
  const SelectContext = reactExports.createContext(null);
  function toArray$1(value) {
    if (Array.isArray(value)) {
      return value;
    }
    return value !== void 0 ? [value] : [];
  }
  function hasValue(value) {
    return value !== void 0 && value !== null;
  }
  function isComboNoValue(value) {
    return !value && value !== 0;
  }
  function isTitleType$1(title) {
    return ["string", "number"].includes(typeof title);
  }
  function getTitle(item) {
    let title = void 0;
    if (item) {
      if (isTitleType$1(item.title)) {
        title = item.title.toString();
      } else if (isTitleType$1(item.label)) {
        title = item.label.toString();
      }
    }
    return title;
  }
  function _extends$I() {
    _extends$I = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$I.apply(this, arguments);
  }
  const SingleContent = reactExports.forwardRef(({
    inputProps
  }, ref2) => {
    const {
      prefixCls,
      searchValue,
      activeValue,
      displayValues,
      maxLength,
      mode,
      components: components2
    } = useSelectInputContext();
    const {
      triggerOpen,
      title: rootTitle,
      showSearch,
      classNames,
      styles
    } = useBaseProps();
    const selectContext = reactExports.useContext(SelectContext);
    const [inputChanged, setInputChanged] = reactExports.useState(false);
    const combobox = mode === "combobox";
    const displayValue = displayValues[0];
    const mergedSearchValue = reactExports.useMemo(() => {
      if (combobox && activeValue && !inputChanged && triggerOpen) {
        return activeValue;
      }
      return showSearch ? searchValue : "";
    }, [combobox, activeValue, inputChanged, triggerOpen, searchValue, showSearch]);
    const [optionClassName, optionStyle, optionTitle, hasOptionStyle] = reactExports.useMemo(() => {
      let className;
      let style2;
      let titleValue;
      if (displayValue && selectContext?.flattenOptions) {
        const option = selectContext.flattenOptions.find((opt) => opt.value === displayValue.value);
        if (option?.data) {
          className = option.data.className;
          style2 = option.data.style;
          titleValue = getTitle(option.data);
        }
      }
      if (displayValue && !titleValue) {
        titleValue = getTitle(displayValue);
      }
      if (rootTitle !== void 0) {
        titleValue = rootTitle;
      }
      const nextHasStyle = !!className || !!style2;
      return [className, style2, titleValue, nextHasStyle];
    }, [displayValue, selectContext?.flattenOptions, rootTitle]);
    reactExports.useEffect(() => {
      if (combobox) {
        setInputChanged(false);
      }
    }, [combobox, activeValue]);
    const showHasValueCls = displayValue && displayValue.label !== null && displayValue.label !== void 0 && String(displayValue.label).trim() !== "";
    const shouldRenderValue = !(combobox && components2?.input);
    const renderValue = shouldRenderValue ? displayValue ? hasOptionStyle ? reactExports.createElement("div", {
      className: clsx(`${prefixCls}-content-value`, optionClassName),
      style: {
        ...mergedSearchValue ? {
          visibility: "hidden"
        } : {},
        ...optionStyle
      },
      title: optionTitle
    }, displayValue.label) : displayValue.label : reactExports.createElement(Placeholder, {
      show: !mergedSearchValue
    }) : null;
    return reactExports.createElement("div", {
      className: clsx(`${prefixCls}-content`, showHasValueCls && `${prefixCls}-content-has-value`, mergedSearchValue && `${prefixCls}-content-has-search-value`, hasOptionStyle && `${prefixCls}-content-has-option-style`, classNames?.content),
      style: styles?.content,
      title: hasOptionStyle ? void 0 : optionTitle
    }, renderValue, reactExports.createElement(Input$3, _extends$I({
      ref: ref2
    }, inputProps, {
      value: mergedSearchValue,
      maxLength: mode === "combobox" ? maxLength : void 0,
      onChange: (e) => {
        setInputChanged(true);
        inputProps.onChange?.(e);
      }
    })));
  });
  const UNDEFINED = void 0;
  function InternalItem(props, ref2) {
    const {
      prefixCls,
      invalidate,
      item,
      renderItem,
      responsive,
      responsiveDisabled,
      registerSize,
      itemKey: itemKey2,
      className,
      style: style2,
      children,
      display,
      order,
      component: Component = "div",
      ...restProps
    } = props;
    const mergedHidden = responsive && !display;
    function internalRegisterSize(width) {
      registerSize(itemKey2, width);
    }
    reactExports.useEffect(() => () => {
      internalRegisterSize(null);
    }, []);
    const childNode = renderItem && item !== UNDEFINED ? renderItem(item, {
      index: order
    }) : children;
    let overflowStyle;
    if (!invalidate) {
      overflowStyle = {
        opacity: mergedHidden ? 0 : 1,
        height: mergedHidden ? 0 : UNDEFINED,
        overflowY: mergedHidden ? "hidden" : UNDEFINED,
        order: responsive ? order : UNDEFINED,
        pointerEvents: mergedHidden ? "none" : UNDEFINED,
        position: mergedHidden ? "absolute" : UNDEFINED
      };
    }
    const overflowProps = {};
    if (mergedHidden) {
      overflowProps["aria-hidden"] = true;
    }
    let itemNode = reactExports.createElement(Component, _extends$15({
      className: clsx(!invalidate && prefixCls, className),
      style: {
        ...overflowStyle,
        ...style2
      }
    }, overflowProps, restProps, {
      ref: ref2
    }), childNode);
    if (responsive) {
      itemNode = reactExports.createElement(RefResizeObserver, {
        onResize: ({
          offsetWidth
        }) => {
          internalRegisterSize(offsetWidth);
        },
        disabled: responsiveDisabled
      }, itemNode);
    }
    return itemNode;
  }
  const Item$2 = reactExports.forwardRef(InternalItem);
  function channelUpdate(callback) {
    if (typeof MessageChannel === "undefined") {
      wrapperRaf(callback);
    } else {
      const channel = new MessageChannel();
      channel.port1.onmessage = () => callback();
      channel.port2.postMessage(void 0);
    }
  }
  function useBatcher() {
    const updateFuncRef = reactExports.useRef(null);
    const notifyEffectUpdate = (callback) => {
      if (!updateFuncRef.current) {
        updateFuncRef.current = [];
        channelUpdate(() => {
          reactDomExports.unstable_batchedUpdates(() => {
            updateFuncRef.current.forEach((fn) => {
              fn();
            });
            updateFuncRef.current = null;
          });
        });
      }
      updateFuncRef.current.push(callback);
    };
    return notifyEffectUpdate;
  }
  function useEffectState(notifyEffectUpdate, defaultValue2) {
    const [stateValue, setStateValue] = reactExports.useState(defaultValue2);
    const setEffectVal = useEvent$1((nextValue) => {
      notifyEffectUpdate(() => {
        setStateValue(nextValue);
      });
    });
    return [stateValue, setEffectVal];
  }
  const OverflowContext = React.createContext(null);
  const InternalRawItem = (props, ref2) => {
    const context = reactExports.useContext(OverflowContext);
    if (!context) {
      const {
        component: Component = "div",
        ...restProps2
      } = props;
      return reactExports.createElement(Component, _extends$15({}, restProps2, {
        ref: ref2
      }));
    }
    const {
      className: contextClassName,
      ...restContext
    } = context;
    const {
      className,
      ...restProps
    } = props;
    return reactExports.createElement(OverflowContext.Provider, {
      value: null
    }, reactExports.createElement(Item$2, _extends$15({
      ref: ref2,
      className: clsx(contextClassName, className)
    }, restContext, restProps)));
  };
  const RawItem = reactExports.forwardRef(InternalRawItem);
  const RESPONSIVE = "responsive";
  const INVALIDATE = "invalidate";
  function defaultRenderRest(omittedItems) {
    return `+ ${omittedItems.length} ...`;
  }
  function Overflow(props, ref2) {
    const {
      prefixCls = "rc-overflow",
      data: data2 = [],
      renderItem,
      renderRawItem,
      itemKey: itemKey2,
      itemWidth = 10,
      ssr,
      style: style2,
      className,
      maxCount,
      renderRest,
      renderRawRest,
      prefix: prefix2,
      suffix,
      component: Component = "div",
      itemComponent,
      onVisibleChange,
      ...restProps
    } = props;
    const fullySSR = ssr === "full";
    const notifyEffectUpdate = useBatcher();
    const [containerWidth, setContainerWidth] = useEffectState(notifyEffectUpdate, null);
    const mergedContainerWidth = containerWidth || 0;
    const [itemWidths, setItemWidths] = useEffectState(notifyEffectUpdate, new Map());
    const [prevRestWidth, setPrevRestWidth] = useEffectState(notifyEffectUpdate, 0);
    const [restWidth, setRestWidth] = useEffectState(notifyEffectUpdate, 0);
    const [prefixWidth, setPrefixWidth] = useEffectState(notifyEffectUpdate, 0);
    const [suffixWidth, setSuffixWidth] = useEffectState(notifyEffectUpdate, 0);
    const [suffixFixedStart, setSuffixFixedStart] = reactExports.useState(null);
    const [displayCount, setDisplayCount] = reactExports.useState(null);
    const mergedDisplayCount = reactExports.useMemo(() => {
      if (displayCount === null && fullySSR) {
        return Number.MAX_SAFE_INTEGER;
      }
      return displayCount || 0;
    }, [displayCount, containerWidth]);
    const [restReady, setRestReady] = reactExports.useState(false);
    const itemPrefixCls = `${prefixCls}-item`;
    const mergedRestWidth = Math.max(prevRestWidth, restWidth);
    const isResponsive = maxCount === RESPONSIVE;
    const shouldResponsive = data2.length && isResponsive;
    const invalidate = maxCount === INVALIDATE;
    const showRest = shouldResponsive || typeof maxCount === "number" && data2.length > maxCount;
    const mergedData = reactExports.useMemo(() => {
      let items = data2;
      if (shouldResponsive) {
        if (containerWidth === null && fullySSR) {
          items = data2;
        } else {
          items = data2.slice(0, Math.min(data2.length, mergedContainerWidth / itemWidth));
        }
      } else if (typeof maxCount === "number") {
        items = data2.slice(0, maxCount);
      }
      return items;
    }, [data2, itemWidth, containerWidth, maxCount, shouldResponsive]);
    const omittedItems = reactExports.useMemo(() => {
      if (shouldResponsive) {
        return data2.slice(mergedDisplayCount + 1);
      }
      return data2.slice(mergedData.length);
    }, [data2, mergedData, shouldResponsive, mergedDisplayCount]);
    const getKey2 = reactExports.useCallback((item, index) => {
      if (typeof itemKey2 === "function") {
        return itemKey2(item);
      }
      return (itemKey2 && item?.[itemKey2]) ?? index;
    }, [itemKey2]);
    const mergedRenderItem = reactExports.useCallback(renderItem || ((item) => item), [renderItem]);
    function updateDisplayCount(count, suffixFixedStartVal, notReady) {
      if (displayCount === count && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart)) {
        return;
      }
      setDisplayCount(count);
      if (!notReady) {
        setRestReady(count < data2.length - 1);
        onVisibleChange?.(count);
      }
      if (suffixFixedStartVal !== void 0) {
        setSuffixFixedStart(suffixFixedStartVal);
      }
    }
    function onOverflowResize(_2, element) {
      setContainerWidth(element.clientWidth);
    }
    function registerSize(key, width) {
      setItemWidths((origin) => {
        const clone2 = new Map(origin);
        if (width === null) {
          clone2.delete(key);
        } else {
          clone2.set(key, width);
        }
        return clone2;
      });
    }
    function registerOverflowSize(_2, width) {
      setRestWidth(width);
      setPrevRestWidth(restWidth);
    }
    function registerPrefixSize(_2, width) {
      setPrefixWidth(width);
    }
    function registerSuffixSize(_2, width) {
      setSuffixWidth(width);
    }
    function getItemWidth(index) {
      return itemWidths.get(getKey2(mergedData[index], index));
    }
    useLayoutEffect(() => {
      if (mergedContainerWidth && typeof mergedRestWidth === "number" && mergedData) {
        let totalWidth = prefixWidth + suffixWidth;
        const len = mergedData.length;
        const lastIndex = len - 1;
        if (!len) {
          updateDisplayCount(0, null);
          return;
        }
        for (let i2 = 0; i2 < len; i2 += 1) {
          let currentItemWidth = getItemWidth(i2);
          if (fullySSR) {
            currentItemWidth = currentItemWidth || 0;
          }
          if (currentItemWidth === void 0) {
            updateDisplayCount(i2 - 1, void 0, true);
            break;
          }
          totalWidth += currentItemWidth;
          if (
lastIndex === 0 && totalWidth <= mergedContainerWidth ||
i2 === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth
          ) {
            updateDisplayCount(lastIndex, null);
            break;
          } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
            updateDisplayCount(i2 - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
            break;
          }
        }
        if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
          setSuffixFixedStart(null);
        }
      }
    }, [mergedContainerWidth, itemWidths, restWidth, prefixWidth, suffixWidth, getKey2, mergedData]);
    const displayRest = restReady && !!omittedItems.length;
    let suffixStyle = {};
    if (suffixFixedStart !== null && shouldResponsive) {
      suffixStyle = {
        position: "absolute",
        left: suffixFixedStart,
        top: 0
      };
    }
    const itemSharedProps = {
      prefixCls: itemPrefixCls,
      responsive: shouldResponsive,
      component: itemComponent,
      invalidate
    };
    const internalRenderItemNode = renderRawItem ? (item, index) => {
      const key = getKey2(item, index);
      return reactExports.createElement(OverflowContext.Provider, {
        key,
        value: {
          ...itemSharedProps,
          order: index,
          item,
          itemKey: key,
          registerSize,
          display: index <= mergedDisplayCount
        }
      }, renderRawItem(item, index));
    } : (item, index) => {
      const key = getKey2(item, index);
      return reactExports.createElement(Item$2, _extends$15({}, itemSharedProps, {
        order: index,
        key,
        item,
        renderItem: mergedRenderItem,
        itemKey: key,
        registerSize,
        display: index <= mergedDisplayCount
      }));
    };
    const restContextProps = {
      order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
      className: `${itemPrefixCls}-rest`,
      registerSize: registerOverflowSize,
      display: displayRest
    };
    const mergedRenderRest = renderRest || defaultRenderRest;
    const restNode = renderRawRest ? reactExports.createElement(OverflowContext.Provider, {
      value: {
        ...itemSharedProps,
        ...restContextProps
      }
    }, renderRawRest(omittedItems)) : reactExports.createElement(Item$2, _extends$15({}, itemSharedProps, restContextProps), typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems) : mergedRenderRest);
    const overflowNode = reactExports.createElement(Component, _extends$15({
      className: clsx(!invalidate && prefixCls, className),
      style: style2,
      ref: ref2
    }, restProps), prefix2 && reactExports.createElement(Item$2, _extends$15({}, itemSharedProps, {
      responsive: isResponsive,
      responsiveDisabled: !shouldResponsive,
      order: -1,
      className: `${itemPrefixCls}-prefix`,
      registerSize: registerPrefixSize,
      display: true
    }), prefix2), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && reactExports.createElement(Item$2, _extends$15({}, itemSharedProps, {
      responsive: isResponsive,
      responsiveDisabled: !shouldResponsive,
      order: mergedDisplayCount,
      className: `${itemPrefixCls}-suffix`,
      registerSize: registerSuffixSize,
      display: true,
      style: suffixStyle
    }), suffix));
    return isResponsive ? reactExports.createElement(RefResizeObserver, {
      onResize: onOverflowResize,
      disabled: !shouldResponsive
    }, overflowNode) : overflowNode;
  }
  const ForwardOverflow = reactExports.forwardRef(Overflow);
  ForwardOverflow.Item = RawItem;
  ForwardOverflow.RESPONSIVE = RESPONSIVE;
  ForwardOverflow.INVALIDATE = INVALIDATE;
  const TransBtn = (props) => {
    const {
      className,
      style: style2,
      customizeIcon,
      customizeIconProps,
      children,
      onMouseDown,
      onClick
    } = props;
    const icon = typeof customizeIcon === "function" ? customizeIcon(customizeIconProps) : customizeIcon;
    return reactExports.createElement("span", {
      className,
      onMouseDown: (event) => {
        event.preventDefault();
        onMouseDown?.(event);
      },
      style: {
        userSelect: "none",
        WebkitUserSelect: "none",
        ...style2
      },
      unselectable: "on",
      onClick,
      "aria-hidden": true
    }, icon !== void 0 ? icon : reactExports.createElement("span", {
      className: clsx(className.split(/\s+/).map((cls) => `${cls}-icon`))
    }, children));
  };
  function _extends$H() {
    _extends$H = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$H.apply(this, arguments);
  }
  function itemKey(value) {
    return value.key ?? value.value;
  }
  const onPreventMouseDown = (event) => {
    event.preventDefault();
    event.stopPropagation();
  };
  const MultipleContent = reactExports.forwardRef(function MultipleContent2({
    inputProps
  }, ref2) {
    const {
      prefixCls,
      displayValues,
      searchValue,
      mode,
      onSelectorRemove,
      removeIcon: removeIconFromContext
    } = useSelectInputContext();
    const {
      disabled,
      showSearch,
      triggerOpen,
      rawOpen,
      toggleOpen,
      autoClearSearchValue,
      tagRender: tagRenderFromContext,
      maxTagPlaceholder: maxTagPlaceholderFromContext,
      maxTagTextLength,
      maxTagCount,
      classNames,
      styles
    } = useBaseProps();
    const selectionItemPrefixCls = `${prefixCls}-selection-item`;
    let computedSearchValue = searchValue;
    if (!rawOpen && mode === "multiple" && autoClearSearchValue !== false) {
      computedSearchValue = "";
    }
    const inputValue = showSearch ? computedSearchValue || "" : "";
    const inputEditable = showSearch && !disabled;
    const removeIcon = removeIconFromContext ?? "×";
    const maxTagPlaceholder = maxTagPlaceholderFromContext ?? ((omittedValues) => `+ ${omittedValues.length} ...`);
    const tagRender = tagRenderFromContext;
    const onToggleOpen = (newOpen) => {
      toggleOpen(newOpen);
    };
    const onRemove = (value) => {
      onSelectorRemove?.(value);
    };
    const defaultRenderSelector = (item, content, itemDisabled, closable, onClose) => reactExports.createElement("span", {
      title: getTitle(item),
      className: clsx(selectionItemPrefixCls, {
        [`${selectionItemPrefixCls}-disabled`]: itemDisabled
      }, classNames?.item),
      style: styles?.item
    }, reactExports.createElement("span", {
      className: clsx(`${selectionItemPrefixCls}-content`, classNames?.itemContent),
      style: styles?.itemContent
    }, content), closable && reactExports.createElement(TransBtn, {
      className: clsx(`${selectionItemPrefixCls}-remove`, classNames?.itemRemove),
      style: styles?.itemRemove,
      onMouseDown: onPreventMouseDown,
      onClick: onClose,
      customizeIcon: removeIcon
    }, "×"));
    const customizeRenderSelector = (value, content, itemDisabled, closable, onClose, isMaxTag, info) => {
      const onMouseDown = (e) => {
        onPreventMouseDown(e);
        onToggleOpen(!triggerOpen);
      };
      return reactExports.createElement("span", {
        onMouseDown
      }, tagRender({
        label: content,
        value,
        index: info?.index,
        disabled: itemDisabled,
        closable,
        onClose,
        isMaxTag: !!isMaxTag
      }));
    };
    const renderItem = (valueItem, info) => {
      const {
        disabled: itemDisabled,
        label,
        value
      } = valueItem;
      const closable = !disabled && !itemDisabled;
      let displayLabel = label;
      if (typeof maxTagTextLength === "number") {
        if (typeof label === "string" || typeof label === "number") {
          const strLabel = String(displayLabel);
          if (strLabel.length > maxTagTextLength) {
            displayLabel = `${strLabel.slice(0, maxTagTextLength)}...`;
          }
        }
      }
      const onClose = (event) => {
        if (event) {
          event.stopPropagation();
        }
        onRemove(valueItem);
      };
      return typeof tagRender === "function" ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose, void 0, info) : defaultRenderSelector(valueItem, displayLabel, itemDisabled, closable, onClose);
    };
    const renderRest = (omittedValues) => {
      if (!displayValues.length) {
        return null;
      }
      const content = typeof maxTagPlaceholder === "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
      return typeof tagRender === "function" ? customizeRenderSelector(void 0, content, false, false, void 0, true) : defaultRenderSelector({
        title: content
      }, content, false);
    };
    return reactExports.createElement(ForwardOverflow, {
      prefixCls: `${prefixCls}-content`,
      className: classNames?.content,
      style: styles?.content,
      prefix: !displayValues.length && !inputValue && reactExports.createElement(Placeholder, null),
      data: displayValues,
      renderItem,
      renderRest,
      suffix: reactExports.createElement(Input$3, _extends$H({
        ref: ref2,
        disabled,
        readOnly: !inputEditable
      }, inputProps, {
        value: inputValue || "",
        syncWidth: true
      })),
      itemKey,
      maxCount: maxTagCount
    });
  });
  const SelectContent = reactExports.forwardRef(function SelectContent2(_2, ref2) {
    const {
      multiple,
      onInputKeyDown,
      tabIndex
    } = useSelectInputContext();
    const baseProps = useBaseProps();
    const {
      showSearch
    } = baseProps;
    const ariaProps = pickAttrs(baseProps, {
      aria: true
    });
    const sharedInputProps = {
      ...ariaProps,
      onKeyDown: onInputKeyDown,
      readOnly: !showSearch,
      tabIndex
    };
    if (multiple) {
      return reactExports.createElement(MultipleContent, {
        ref: ref2,
        inputProps: sharedInputProps
      });
    }
    return reactExports.createElement(SingleContent, {
      ref: ref2,
      inputProps: sharedInputProps
    });
  });
  function isValidateOpenKey(currentKeyCode) {
    return (

currentKeyCode &&
![
KeyCode.ESC,
        KeyCode.SHIFT,
        KeyCode.BACKSPACE,
        KeyCode.TAB,
        KeyCode.WIN_KEY,
        KeyCode.ALT,
        KeyCode.META,
        KeyCode.WIN_KEY_RIGHT,
        KeyCode.CTRL,
        KeyCode.SEMICOLON,
        KeyCode.EQUALS,
        KeyCode.CAPS_LOCK,
        KeyCode.CONTEXT_MENU,
KeyCode.UP,
KeyCode.LEFT,
        KeyCode.RIGHT,
KeyCode.F1,
        KeyCode.F2,
        KeyCode.F3,
        KeyCode.F4,
        KeyCode.F5,
        KeyCode.F6,
        KeyCode.F7,
        KeyCode.F8,
        KeyCode.F9,
        KeyCode.F10,
        KeyCode.F11,
        KeyCode.F12
      ].includes(currentKeyCode)
    );
  }
  function _extends$G() {
    _extends$G = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$G.apply(this, arguments);
  }
  const DEFAULT_OMIT_PROPS = ["value", "onChange", "removeIcon", "placeholder", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabIndex", "activeValue", "onSelectorRemove", "focused"];
  const SelectInput = reactExports.forwardRef(function SelectInput2(props, ref2) {
    const {
prefixCls,
      className,
      style: style2,
prefix: prefix2,
      suffix,
      clearIcon,
      children,
multiple,
      displayValues,
      placeholder,
      mode,
searchValue,
      onSearch,
      onSearchSubmit,
      onInputBlur,
maxLength,
      autoFocus,
onMouseDown,
      onClearMouseDown,
      onInputKeyDown,
      onSelectorRemove,
tokenWithEnter,
components: components2,
      ...restProps
    } = props;
    const {
      triggerOpen,
      toggleOpen,
      showSearch,
      disabled,
      loading,
      classNames,
      styles
    } = useBaseProps();
    const rootRef = reactExports.useRef(null);
    const inputRef = reactExports.useRef(null);
    const onInternalInputKeyDown = useEvent$1((event) => {
      const {
        which
      } = event;
      const isTextAreaElement = inputRef.current instanceof HTMLTextAreaElement;
      if (!isTextAreaElement && triggerOpen && (which === KeyCode.UP || which === KeyCode.DOWN)) {
        event.preventDefault();
      }
      if (onInputKeyDown) {
        onInputKeyDown(event);
      }
      if (isTextAreaElement && !triggerOpen && ~[KeyCode.UP, KeyCode.DOWN, KeyCode.LEFT, KeyCode.RIGHT].indexOf(which)) {
        return;
      }
      const isModifier = event.ctrlKey || event.altKey || event.metaKey;
      if (!isModifier && isValidateOpenKey(which)) {
        toggleOpen(true);
      }
    });
    reactExports.useImperativeHandle(ref2, () => {
      return {
        focus: (options) => {
          (inputRef.current || rootRef.current).focus?.(options);
        },
        blur: () => {
          (inputRef.current || rootRef.current).blur?.();
        },
        nativeElement: rootRef.current
      };
    });
    const onInternalMouseDown = useEvent$1((event) => {
      if (!disabled) {
        const inputDOM = getDOM(inputRef.current);
        event.nativeEvent._ori_target = inputDOM;
        if (inputDOM && event.target !== inputDOM && !inputDOM.contains(event.target)) {
          event.preventDefault();
        }
        const shouldPreventClose = triggerOpen && !multiple && (mode === "combobox" || showSearch);
        if (!event.nativeEvent._select_lazy) {
          inputRef.current?.focus();
          if (!shouldPreventClose) {
            toggleOpen();
          }
        } else if (triggerOpen) {
          toggleOpen(false);
        }
      }
      onMouseDown?.(event);
    });
    const {
      root: RootComponent
    } = components2;
    const domProps = omit(restProps, DEFAULT_OMIT_PROPS);
    const ariaProps = pickAttrs(domProps, {
      aria: true
    });
    const ariaKeys = Object.keys(ariaProps);
    const contextValue = {
      ...props,
      onInputKeyDown: onInternalInputKeyDown
    };
    if (RootComponent) {
      if ( reactExports.isValidElement(RootComponent)) {
        return reactExports.cloneElement(RootComponent, {
          ...domProps,
          ref: composeRef(RootComponent.ref, rootRef)
        });
      }
      return reactExports.createElement(RootComponent, _extends$G({}, domProps, {
        ref: rootRef
      }));
    }
    return reactExports.createElement(SelectInputContext.Provider, {
      value: contextValue
    }, reactExports.createElement("div", _extends$G({}, omit(domProps, ariaKeys), {
ref: rootRef,
      className,
      style: style2,
      onMouseDown: onInternalMouseDown
    }), reactExports.createElement(Affix, {
      className: clsx(`${prefixCls}-prefix`, classNames?.prefix),
      style: styles?.prefix
    }, prefix2), reactExports.createElement(SelectContent, {
      ref: inputRef
    }), reactExports.createElement(Affix, {
      className: clsx(`${prefixCls}-suffix`, {
        [`${prefixCls}-suffix-loading`]: loading
      }, classNames?.suffix),
      style: styles?.suffix
    }, suffix), clearIcon && reactExports.createElement(Affix, {
      className: clsx(`${prefixCls}-clear`, classNames?.clear),
      style: styles?.clear,
      onMouseDown: (e) => {
        e.nativeEvent._select_lazy = true;
        onClearMouseDown?.(e);
      }
    }, clearIcon), children));
  });
  function useComponents(components2, getInputElement, getRawInputElement) {
    return reactExports.useMemo(() => {
      let {
        root: root2,
        input
      } = components2 || {};
      if (getRawInputElement) {
        root2 = getRawInputElement();
      }
      if (getInputElement) {
        input = getInputElement();
      }
      return {
        root: root2,
        input
      };
    }, [components2, getInputElement, getRawInputElement]);
  }
  function _extends$F() {
    _extends$F = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$F.apply(this, arguments);
  }
  const isMultiple = (mode) => mode === "tags" || mode === "multiple";
  const BaseSelect = reactExports.forwardRef((props, ref2) => {
    const {
      id: id2,
      prefixCls,
      className,
      styles,
      classNames,
      showSearch,
      tagRender,
      showScrollBar = "optional",
      direction,
      omitDomProps,
displayValues,
      onDisplayValuesChange,
      emptyOptions,
      notFoundContent = "Not Found",
      onClear,
      maxCount,
      placeholder,
mode,
disabled,
      loading,
getInputElement,
      getRawInputElement,
open: open2,
      defaultOpen,
      onPopupVisibleChange,
activeValue,
      onActiveValueChange,
      activeDescendantId,
searchValue,
      autoClearSearchValue,
      onSearch,
      onSearchSplit,
      tokenSeparators,
allowClear,
      prefix: prefix2,
      suffix,
      suffixIcon,
      clearIcon,
OptionList: OptionList2,
      animation,
      transitionName,
      popupStyle,
      popupClassName,
      popupMatchSelectWidth,
      popupRender,
      popupAlign,
      placement,
      builtinPlacements,
      getPopupContainer,
showAction = [],
      onFocus,
      onBlur,
onKeyUp,
      onKeyDown,
      onMouseDown,
components: components2,
...restProps
    } = props;
    const multiple = isMultiple(mode);
    const containerRef = reactExports.useRef(null);
    const triggerRef = reactExports.useRef(null);
    const listRef = reactExports.useRef(null);
    const [focused, setFocused] = reactExports.useState(false);
    reactExports.useImperativeHandle(ref2, () => ({
      focus: containerRef.current?.focus,
      blur: containerRef.current?.blur,
      scrollTo: (arg) => listRef.current?.scrollTo(arg),
      nativeElement: getDOM(containerRef.current)
    }));
    const mergedComponents = useComponents(components2, getInputElement, getRawInputElement);
    const mergedSearchValue = reactExports.useMemo(() => {
      if (mode !== "combobox") {
        return searchValue;
      }
      const val = displayValues[0]?.value;
      return typeof val === "string" || typeof val === "number" ? String(val) : "";
    }, [searchValue, mode, displayValues]);
    const customizeInputElement = mode === "combobox" && typeof getInputElement === "function" && getInputElement() || null;
    const emptyListContent = !notFoundContent && emptyOptions;
    const [rawOpen, mergedOpen, triggerOpen, lockOptions] = useOpen(defaultOpen || false, open2, onPopupVisibleChange, (nextOpen) => disabled || emptyListContent ? false : nextOpen);
    const tokenWithEnter = reactExports.useMemo(() => (tokenSeparators || []).some((tokenSeparator) => ["\n", "\r\n"].includes(tokenSeparator)), [tokenSeparators]);
    const onInternalSearch = (searchText, fromTyping, isCompositing) => {
      if (multiple && isValidCount(maxCount) && displayValues.length >= maxCount) {
        return;
      }
      let ret = true;
      let newSearchText = searchText;
      onActiveValueChange?.(null);
      const separatedList = getSeparatedContent(searchText, tokenSeparators, isValidCount(maxCount) ? maxCount - displayValues.length : void 0);
      const patchLabels = isCompositing ? null : separatedList;
      if (mode !== "combobox" && patchLabels) {
        newSearchText = "";
        onSearchSplit?.(patchLabels);
        triggerOpen(false);
        ret = false;
      }
      if (onSearch && mergedSearchValue !== newSearchText) {
        onSearch(newSearchText, {
          source: fromTyping ? "typing" : "effect"
        });
      }
      if (searchText && fromTyping && ret) {
        triggerOpen(true);
      }
      return ret;
    };
    const onInternalSearchSubmit = (searchText) => {
      if (!searchText || !searchText.trim()) {
        return;
      }
      onSearch(searchText, {
        source: "submit"
      });
    };
    reactExports.useEffect(() => {
      if (!rawOpen && !multiple && mode !== "combobox") {
        onInternalSearch("", false, false);
      }
    }, [rawOpen]);
    reactExports.useEffect(() => {
      if (disabled) {
        triggerOpen(false);
        setFocused(false);
      }
    }, [disabled, mergedOpen]);
    const [getClearLock, setClearLock] = useLock();
    const keyLockRef = reactExports.useRef(false);
    const onInternalKeyDown = (event) => {
      const clearLock = getClearLock();
      const {
        key
      } = event;
      const isEnterKey = key === "Enter";
      const isSpaceKey = key === " ";
      if (isEnterKey || isSpaceKey) {
        const isCombobox = mode === "combobox";
        const isEditable = isCombobox || showSearch;
        if (isSpaceKey && !isEditable || isEnterKey && !isCombobox) {
          event.preventDefault();
        }
        if (!mergedOpen) {
          triggerOpen(true);
        }
      }
      setClearLock(!!mergedSearchValue);
      if (key === "Backspace" && !clearLock && multiple && !mergedSearchValue && displayValues.length) {
        const cloneDisplayValues = [...displayValues];
        let removedDisplayValue = null;
        for (let i2 = cloneDisplayValues.length - 1; i2 >= 0; i2 -= 1) {
          const current = cloneDisplayValues[i2];
          if (!current.disabled) {
            cloneDisplayValues.splice(i2, 1);
            removedDisplayValue = current;
            break;
          }
        }
        if (removedDisplayValue) {
          onDisplayValuesChange(cloneDisplayValues, {
            type: "remove",
            values: [removedDisplayValue]
          });
        }
      }
      if (mergedOpen && (!isEnterKey || !keyLockRef.current) && !isSpaceKey) {
        if (isEnterKey) {
          keyLockRef.current = true;
        }
        listRef.current?.onKeyDown(event);
      }
      onKeyDown?.(event);
    };
    const onInternalKeyUp = (event, ...rest) => {
      if (mergedOpen) {
        listRef.current?.onKeyUp(event, ...rest);
      }
      if (event.key === "Enter") {
        keyLockRef.current = false;
      }
      onKeyUp?.(event, ...rest);
    };
    const onSelectorRemove = useEvent$1((val) => {
      const newValues = displayValues.filter((i2) => i2 !== val);
      onDisplayValuesChange(newValues, {
        type: "remove",
        values: [val]
      });
    });
    const onInputBlur = () => {
      keyLockRef.current = false;
    };
    const getSelectElements = () => [getDOM(containerRef.current), triggerRef.current?.getPopupElement()];
    useSelectTriggerControl(getSelectElements, mergedOpen, triggerOpen, !!mergedComponents.root);
    const internalMouseDownRef = reactExports.useRef(false);
    const onInternalFocus = (event) => {
      setFocused(true);
      if (!disabled) {
        if (showAction.includes("focus")) {
          triggerOpen(true);
        }
        onFocus?.(event);
      }
    };
    const onRootBlur = () => {
      if (mergedOpen && !internalMouseDownRef.current) {
        triggerOpen(false, {
          cancelFun: () => isInside(getSelectElements(), document.activeElement)
        });
      }
    };
    const onInternalBlur = (event) => {
      setFocused(false);
      if (mergedSearchValue) {
        if (mode === "tags") {
          onSearch(mergedSearchValue, {
            source: "submit"
          });
        } else if (mode === "multiple") {
          onSearch("", {
            source: "blur"
          });
        }
      }
      onRootBlur();
      if (!disabled) {
        onBlur?.(event);
      }
    };
    const onRootMouseDown = (event, ...restArgs) => {
      const {
        target
      } = event;
      const popupElement = triggerRef.current?.getPopupElement();
      if (popupElement?.contains(target) && triggerOpen) {
        triggerOpen(true);
      }
      onMouseDown?.(event, ...restArgs);
      internalMouseDownRef.current = true;
      macroTask(() => {
        internalMouseDownRef.current = false;
      });
    };
    const [, forceUpdate] = reactExports.useState({});
    function onPopupMouseEnter() {
      forceUpdate({});
    }
    let onTriggerVisibleChange;
    if (!!mergedComponents.root) {
      onTriggerVisibleChange = (newOpen) => {
        triggerOpen(newOpen);
      };
    }
    const baseSelectContext = reactExports.useMemo(() => ({
      ...props,
      notFoundContent,
      open: mergedOpen,
      triggerOpen: mergedOpen,
      rawOpen,
      id: id2,
      showSearch,
      multiple,
      toggleOpen: triggerOpen,
      showScrollBar,
      styles,
      classNames,
      lockOptions
    }), [props, notFoundContent, triggerOpen, id2, showSearch, multiple, mergedOpen, rawOpen, showScrollBar, styles, classNames, lockOptions]);
    const mergedSuffixIcon = reactExports.useMemo(() => {
      const nextSuffix = suffix ?? suffixIcon;
      if (typeof nextSuffix === "function") {
        return nextSuffix({
          searchValue: mergedSearchValue,
          open: mergedOpen,
          focused,
          showSearch,
          loading
        });
      }
      return nextSuffix;
    }, [suffix, suffixIcon, mergedSearchValue, mergedOpen, focused, showSearch, loading]);
    const onClearMouseDown = () => {
      onClear?.();
      containerRef.current?.focus();
      onDisplayValuesChange([], {
        type: "clear",
        values: displayValues
      });
      onInternalSearch("", false, false);
    };
    const {
      allowClear: mergedAllowClear,
      clearIcon: clearNode
    } = useAllowClear(prefixCls, displayValues, allowClear, clearIcon, disabled, mergedSearchValue, mode);
    const optionList = reactExports.createElement(OptionList2, {
      ref: listRef
    });
    const mergedClassName = clsx(prefixCls, className, {
      [`${prefixCls}-focused`]: focused,
      [`${prefixCls}-multiple`]: multiple,
      [`${prefixCls}-single`]: !multiple,
      [`${prefixCls}-allow-clear`]: mergedAllowClear,
      [`${prefixCls}-show-arrow`]: mergedSuffixIcon !== void 0 && mergedSuffixIcon !== null,
      [`${prefixCls}-disabled`]: disabled,
      [`${prefixCls}-loading`]: loading,
      [`${prefixCls}-open`]: mergedOpen,
      [`${prefixCls}-customize-input`]: customizeInputElement,
      [`${prefixCls}-show-search`]: showSearch
    });
    let renderNode = reactExports.createElement(SelectInput, _extends$F({}, restProps, {
ref: containerRef,
      prefixCls,
      className: mergedClassName,
      focused,
      prefix: prefix2,
      suffix: mergedSuffixIcon,
      clearIcon: clearNode,
      multiple,
      mode,
      displayValues,
      placeholder,
      searchValue: mergedSearchValue,
      activeValue,
      onSearch: onInternalSearch,
      onSearchSubmit: onInternalSearchSubmit,
      onInputBlur,
      onFocus: onInternalFocus,
      onBlur: onInternalBlur,
      onClearMouseDown,
      onKeyDown: onInternalKeyDown,
      onKeyUp: onInternalKeyUp,
      onSelectorRemove,
      tokenWithEnter,
      onMouseDown: onRootMouseDown,
      components: mergedComponents
    }));
    renderNode = reactExports.createElement(RefSelectTrigger, {
      ref: triggerRef,
      disabled,
      prefixCls,
      visible: mergedOpen,
      popupElement: optionList,
      animation,
      transitionName,
      popupStyle,
      popupClassName,
      direction,
      popupMatchSelectWidth,
      popupRender,
      popupAlign,
      placement,
      builtinPlacements,
      getPopupContainer,
      empty: emptyOptions,
      onPopupVisibleChange: onTriggerVisibleChange,
      onPopupMouseEnter,
      onPopupMouseDown: onRootMouseDown,
      onPopupBlur: onRootBlur
    }, renderNode);
    return reactExports.createElement(BaseSelectContext.Provider, {
      value: baseSelectContext
    }, reactExports.createElement(Polite, {
      visible: focused && !mergedOpen,
      values: displayValues
    }), renderNode);
  });
  const OptGroup = () => null;
  OptGroup.isSelectOptGroup = true;
  const Option = () => null;
  Option.isSelectOption = true;
  const Filler = reactExports.forwardRef(({
    height,
    offsetY,
    offsetX,
    children,
    prefixCls,
    onInnerResize,
    innerProps,
    rtl,
    extra
  }, ref2) => {
    let outerStyle = {};
    let innerStyle = {
      display: "flex",
      flexDirection: "column"
    };
    if (offsetY !== void 0) {
      outerStyle = {
        height,
        position: "relative",
        overflow: "hidden"
      };
      innerStyle = {
        ...innerStyle,
        transform: `translateY(${offsetY}px)`,
        [rtl ? "marginRight" : "marginLeft"]: -offsetX,
        position: "absolute",
        left: 0,
        right: 0,
        top: 0
      };
    }
    return reactExports.createElement("div", {
      style: outerStyle
    }, reactExports.createElement(RefResizeObserver, {
      onResize: ({
        offsetHeight
      }) => {
        if (offsetHeight && onInnerResize) {
          onInnerResize();
        }
      }
    }, reactExports.createElement("div", _extends$15({
      style: innerStyle,
      className: clsx({
        [`${prefixCls}-holder-inner`]: prefixCls
      }),
      ref: ref2
    }, innerProps), children, extra)));
  });
  Filler.displayName = "Filler";
  function Item$1({
    children,
    setRef: setRef2
  }) {
    const refFunc = reactExports.useCallback((node2) => {
      setRef2(node2);
    }, []);
    return reactExports.cloneElement(children, {
      ref: refFunc
    });
  }
  function useChildren(list2, startIndex, endIndex, scrollWidth, offsetX, setNodeRef, renderFunc, {
    getKey: getKey2
  }) {
    return list2.slice(startIndex, endIndex + 1).map((item, index) => {
      const eleIndex = startIndex + index;
      const node2 = renderFunc(item, eleIndex, {
        style: {
          width: scrollWidth
        },
        offsetX
      });
      const key = getKey2(item);
      return reactExports.createElement(Item$1, {
        key,
        setRef: (ele) => setNodeRef(item, ele)
      }, node2);
    });
  }
  function findListDiffIndex(originList, targetList, getKey2) {
    const originLen = originList.length;
    const targetLen = targetList.length;
    let shortList;
    let longList;
    if (originLen === 0 && targetLen === 0) {
      return null;
    }
    if (originLen < targetLen) {
      shortList = originList;
      longList = targetList;
    } else {
      shortList = targetList;
      longList = originList;
    }
    const notExistKey = {
      __EMPTY_ITEM__: true
    };
    function getItemKey(item) {
      if (item !== void 0) {
        return getKey2(item);
      }
      return notExistKey;
    }
    let diffIndex = null;
    let multiple = Math.abs(originLen - targetLen) !== 1;
    for (let i2 = 0; i2 < longList.length; i2 += 1) {
      const shortKey = getItemKey(shortList[i2]);
      const longKey = getItemKey(longList[i2]);
      if (shortKey !== longKey) {
        diffIndex = i2;
        multiple = multiple || shortKey !== getItemKey(longList[i2 + 1]);
        break;
      }
    }
    return diffIndex === null ? null : {
      index: diffIndex,
      multiple
    };
  }
  function useDiffItem(data2, getKey2, onDiff) {
    const [prevData, setPrevData] = reactExports.useState(data2);
    const [diffItem, setDiffItem] = reactExports.useState(null);
    reactExports.useEffect(() => {
      const diff = findListDiffIndex(prevData || [], data2 || [], getKey2);
      if (diff?.index !== void 0) {
        setDiffItem(data2[diff.index]);
      }
      setPrevData(data2);
    }, [data2]);
    return [diffItem];
  }
  const isFF = typeof navigator === "object" && /Firefox/i.test(navigator.userAgent);
  const useOriginScroll = ((isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight) => {
    const lockRef = reactExports.useRef(false);
    const lockTimeoutRef = reactExports.useRef(null);
    function lockScroll() {
      clearTimeout(lockTimeoutRef.current);
      lockRef.current = true;
      lockTimeoutRef.current = setTimeout(() => {
        lockRef.current = false;
      }, 50);
    }
    const scrollPingRef = reactExports.useRef({
      top: isScrollAtTop,
      bottom: isScrollAtBottom,
      left: isScrollAtLeft,
      right: isScrollAtRight
    });
    scrollPingRef.current.top = isScrollAtTop;
    scrollPingRef.current.bottom = isScrollAtBottom;
    scrollPingRef.current.left = isScrollAtLeft;
    scrollPingRef.current.right = isScrollAtRight;
    return (isHorizontal, delta, smoothOffset = false) => {
      const originScroll = isHorizontal ? (
delta < 0 && scrollPingRef.current.left ||
delta > 0 && scrollPingRef.current.right
      ) : delta < 0 && scrollPingRef.current.top ||
delta > 0 && scrollPingRef.current.bottom;
      if (smoothOffset && originScroll) {
        clearTimeout(lockTimeoutRef.current);
        lockRef.current = false;
      } else if (!originScroll || lockRef.current) {
        lockScroll();
      }
      return !lockRef.current && originScroll;
    };
  });
  function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, horizontalScroll, onWheelDelta) {
    const offsetRef = reactExports.useRef(0);
    const nextFrameRef = reactExports.useRef(null);
    const wheelValueRef = reactExports.useRef(null);
    const isMouseScrollRef = reactExports.useRef(false);
    const originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);
    function onWheelY(e, deltaY) {
      wrapperRaf.cancel(nextFrameRef.current);
      if (originScroll(false, deltaY)) return;
      const event = e;
      if (!event._virtualHandled) {
        event._virtualHandled = true;
      } else {
        return;
      }
      offsetRef.current += deltaY;
      wheelValueRef.current = deltaY;
      if (!isFF) {
        event.preventDefault();
      }
      nextFrameRef.current = wrapperRaf(() => {
        const patchMultiple = isMouseScrollRef.current ? 10 : 1;
        onWheelDelta(offsetRef.current * patchMultiple, false);
        offsetRef.current = 0;
      });
    }
    function onWheelX(event, deltaX) {
      onWheelDelta(deltaX, true);
      if (!isFF) {
        event.preventDefault();
      }
    }
    const wheelDirectionRef = reactExports.useRef(null);
    const wheelDirectionCleanRef = reactExports.useRef(null);
    function onWheel(event) {
      if (!inVirtual) return;
      wrapperRaf.cancel(wheelDirectionCleanRef.current);
      wheelDirectionCleanRef.current = wrapperRaf(() => {
        wheelDirectionRef.current = null;
      }, 2);
      const {
        deltaX,
        deltaY,
        shiftKey
      } = event;
      let mergedDeltaX = deltaX;
      let mergedDeltaY = deltaY;
      if (wheelDirectionRef.current === "sx" || !wheelDirectionRef.current && (shiftKey || false) && deltaY && !deltaX) {
        mergedDeltaX = deltaY;
        mergedDeltaY = 0;
        wheelDirectionRef.current = "sx";
      }
      const absX = Math.abs(mergedDeltaX);
      const absY = Math.abs(mergedDeltaY);
      if (wheelDirectionRef.current === null) {
        wheelDirectionRef.current = horizontalScroll && absX > absY ? "x" : "y";
      }
      if (wheelDirectionRef.current === "y") {
        onWheelY(event, mergedDeltaY);
      } else {
        onWheelX(event, mergedDeltaX);
      }
    }
    function onFireFoxScroll(event) {
      if (!inVirtual) return;
      isMouseScrollRef.current = event.detail === wheelValueRef.current;
    }
    return [onWheel, onFireFoxScroll];
  }
  function useGetSize(mergedData, getKey2, heights, itemHeight) {
    const [key2Index, bottomList] = reactExports.useMemo(() => [ new Map(), []], [mergedData, heights.id, itemHeight]);
    const getSize2 = (startKey, endKey = startKey) => {
      let startIndex = key2Index.get(startKey);
      let endIndex = key2Index.get(endKey);
      if (startIndex === void 0 || endIndex === void 0) {
        const dataLen = mergedData.length;
        for (let i2 = bottomList.length; i2 < dataLen; i2 += 1) {
          const item = mergedData[i2];
          const key = getKey2(item);
          key2Index.set(key, i2);
          const cacheHeight = heights.get(key) ?? itemHeight;
          bottomList[i2] = (bottomList[i2 - 1] || 0) + cacheHeight;
          if (key === startKey) {
            startIndex = i2;
          }
          if (key === endKey) {
            endIndex = i2;
          }
          if (startIndex !== void 0 && endIndex !== void 0) {
            break;
          }
        }
      }
      return {
        top: bottomList[startIndex - 1] || 0,
        bottom: bottomList[endIndex]
      };
    };
    return getSize2;
  }
  class CacheMap {
    maps;

id = 0;
    diffRecords = new Map();
    constructor() {
      this.maps = Object.create(null);
    }
    set(key, value) {
      this.diffRecords.set(key, this.maps[key]);
      this.maps[key] = value;
      this.id += 1;
    }
    get(key) {
      return this.maps[key];
    }
resetRecord() {
      this.diffRecords.clear();
    }
    getRecord() {
      return this.diffRecords;
    }
  }
  function parseNumber(value) {
    const num = parseFloat(value);
    return isNaN(num) ? 0 : num;
  }
  function useHeights(getKey2, onItemAdd, onItemRemove) {
    const [updatedMark, setUpdatedMark] = reactExports.useState(0);
    const instanceRef = reactExports.useRef( new Map());
    const heightsRef = reactExports.useRef(new CacheMap());
    const promiseIdRef = reactExports.useRef(0);
    function cancelRaf() {
      promiseIdRef.current += 1;
    }
    function collectHeight(sync = false) {
      cancelRaf();
      const doCollect = () => {
        let changed = false;
        instanceRef.current.forEach((element, key) => {
          if (element && element.offsetParent) {
            const {
              offsetHeight
            } = element;
            const {
              marginTop,
              marginBottom
            } = getComputedStyle(element);
            const marginTopNum = parseNumber(marginTop);
            const marginBottomNum = parseNumber(marginBottom);
            const totalHeight = offsetHeight + marginTopNum + marginBottomNum;
            if (heightsRef.current.get(key) !== totalHeight) {
              heightsRef.current.set(key, totalHeight);
              changed = true;
            }
          }
        });
        if (changed) {
          setUpdatedMark((c2) => c2 + 1);
        }
      };
      if (sync) {
        doCollect();
      } else {
        promiseIdRef.current += 1;
        const id2 = promiseIdRef.current;
        Promise.resolve().then(() => {
          if (id2 === promiseIdRef.current) {
            doCollect();
          }
        });
      }
    }
    function setInstanceRef(item, instance) {
      const key = getKey2(item);
      instanceRef.current.get(key);
      if (instance) {
        instanceRef.current.set(key, instance);
        collectHeight();
      } else {
        instanceRef.current.delete(key);
      }
    }
    reactExports.useEffect(() => {
      return cancelRaf;
    }, []);
    return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
  }
  const SMOOTH_PTG = 14 / 15;
  function useMobileTouchMove(inVirtual, listRef, callback) {
    const touchedRef = reactExports.useRef(false);
    const touchXRef = reactExports.useRef(0);
    const touchYRef = reactExports.useRef(0);
    const elementRef = reactExports.useRef(null);
    const intervalRef = reactExports.useRef(null);
    let cleanUpEvents;
    const onTouchMove = (e) => {
      if (touchedRef.current) {
        const currentX = Math.ceil(e.touches[0].pageX);
        const currentY = Math.ceil(e.touches[0].pageY);
        let offsetX = touchXRef.current - currentX;
        let offsetY = touchYRef.current - currentY;
        const isHorizontal = Math.abs(offsetX) > Math.abs(offsetY);
        if (isHorizontal) {
          touchXRef.current = currentX;
        } else {
          touchYRef.current = currentY;
        }
        const scrollHandled = callback(isHorizontal, isHorizontal ? offsetX : offsetY, false, e);
        if (scrollHandled) {
          e.preventDefault();
        }
        clearInterval(intervalRef.current);
        if (scrollHandled) {
          intervalRef.current = setInterval(() => {
            if (isHorizontal) {
              offsetX *= SMOOTH_PTG;
            } else {
              offsetY *= SMOOTH_PTG;
            }
            const offset2 = Math.floor(isHorizontal ? offsetX : offsetY);
            if (!callback(isHorizontal, offset2, true) || Math.abs(offset2) <= 0.1) {
              clearInterval(intervalRef.current);
            }
          }, 16);
        }
      }
    };
    const onTouchEnd = () => {
      touchedRef.current = false;
      cleanUpEvents();
    };
    const onTouchStart = (e) => {
      cleanUpEvents();
      if (e.touches.length === 1 && !touchedRef.current) {
        touchedRef.current = true;
        touchXRef.current = Math.ceil(e.touches[0].pageX);
        touchYRef.current = Math.ceil(e.touches[0].pageY);
        elementRef.current = e.target;
        elementRef.current.addEventListener("touchmove", onTouchMove, {
          passive: false
        });
        elementRef.current.addEventListener("touchend", onTouchEnd, {
          passive: true
        });
      }
    };
    cleanUpEvents = () => {
      if (elementRef.current) {
        elementRef.current.removeEventListener("touchmove", onTouchMove);
        elementRef.current.removeEventListener("touchend", onTouchEnd);
      }
    };
    useLayoutEffect(() => {
      if (inVirtual) {
        listRef.current.addEventListener("touchstart", onTouchStart, {
          passive: true
        });
      }
      return () => {
        listRef.current?.removeEventListener("touchstart", onTouchStart);
        cleanUpEvents();
        clearInterval(intervalRef.current);
      };
    }, [inVirtual]);
  }
  function smoothScrollOffset(offset2) {
    return Math.floor(offset2 ** 0.5);
  }
  function getPageXY(e, horizontal) {
    const obj = "touches" in e ? e.touches[0] : e;
    return obj[horizontal ? "pageX" : "pageY"] - window[horizontal ? "scrollX" : "scrollY"];
  }
  function useScrollDrag(inVirtual, componentRef, onScrollOffset) {
    reactExports.useEffect(() => {
      const ele = componentRef.current;
      if (inVirtual && ele) {
        let mouseDownLock = false;
        let rafId;
        let offset2;
        const stopScroll = () => {
          wrapperRaf.cancel(rafId);
        };
        const continueScroll = () => {
          stopScroll();
          rafId = wrapperRaf(() => {
            onScrollOffset(offset2);
            continueScroll();
          });
        };
        const clearDragState = () => {
          mouseDownLock = false;
          stopScroll();
        };
        const onMouseDown = (e) => {
          if (e.target.draggable || e.button !== 0) {
            return;
          }
          const event = e;
          if (!event._virtualHandled) {
            event._virtualHandled = true;
            mouseDownLock = true;
          }
        };
        const onMouseMove = (e) => {
          if (mouseDownLock) {
            const mouseY = getPageXY(e, false);
            const {
              top,
              bottom
            } = ele.getBoundingClientRect();
            if (mouseY <= top) {
              const diff = top - mouseY;
              offset2 = -smoothScrollOffset(diff);
              continueScroll();
            } else if (mouseY >= bottom) {
              const diff = mouseY - bottom;
              offset2 = smoothScrollOffset(diff);
              continueScroll();
            } else {
              stopScroll();
            }
          }
        };
        ele.addEventListener("mousedown", onMouseDown);
        ele.ownerDocument.addEventListener("mouseup", clearDragState);
        ele.ownerDocument.addEventListener("mousemove", onMouseMove);
        ele.ownerDocument.addEventListener("dragend", clearDragState);
        return () => {
          ele.removeEventListener("mousedown", onMouseDown);
          ele.ownerDocument.removeEventListener("mouseup", clearDragState);
          ele.ownerDocument.removeEventListener("mousemove", onMouseMove);
          ele.ownerDocument.removeEventListener("dragend", clearDragState);
          stopScroll();
        };
      }
    }, [inVirtual]);
  }
  const MAX_TIMES = 10;
  function useScrollTo(containerRef, data2, heights, itemHeight, getKey2, collectHeight, syncScrollTop, triggerFlash) {
    const scrollRef = reactExports.useRef();
    const [syncState, setSyncState] = reactExports.useState(null);
    useLayoutEffect(() => {
      if (syncState && syncState.times < MAX_TIMES) {
        if (!containerRef.current) {
          setSyncState((ori) => ({
            ...ori
          }));
          return;
        }
        collectHeight();
        const {
          targetAlign,
          originAlign,
          index,
          offset: offset2
        } = syncState;
        const height = containerRef.current.clientHeight;
        let needCollectHeight = false;
        let newTargetAlign = targetAlign;
        let targetTop = null;
        if (height) {
          const mergedAlign = targetAlign || originAlign;
          let stackTop = 0;
          let itemTop = 0;
          let itemBottom = 0;
          const maxLen = Math.min(data2.length - 1, index);
          for (let i2 = 0; i2 <= maxLen; i2 += 1) {
            const key = getKey2(data2[i2]);
            itemTop = stackTop;
            const cacheHeight = heights.get(key);
            itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
            stackTop = itemBottom;
          }
          let leftHeight = mergedAlign === "top" ? offset2 : height - offset2;
          for (let i2 = maxLen; i2 >= 0; i2 -= 1) {
            const key = getKey2(data2[i2]);
            const cacheHeight = heights.get(key);
            if (cacheHeight === void 0) {
              needCollectHeight = true;
              break;
            }
            leftHeight -= cacheHeight;
            if (leftHeight <= 0) {
              break;
            }
          }
          switch (mergedAlign) {
            case "top":
              targetTop = itemTop - offset2;
              break;
            case "bottom":
              targetTop = itemBottom - height + offset2;
              break;
            default: {
              const {
                scrollTop
              } = containerRef.current;
              const scrollBottom = scrollTop + height;
              if (itemTop < scrollTop) {
                newTargetAlign = "top";
              } else if (itemBottom > scrollBottom) {
                newTargetAlign = "bottom";
              }
            }
          }
          if (targetTop !== null) {
            syncScrollTop(targetTop);
          }
          if (targetTop !== syncState.lastTop) {
            needCollectHeight = true;
          }
        }
        if (needCollectHeight) {
          setSyncState({
            ...syncState,
            times: syncState.times + 1,
            targetAlign: newTargetAlign,
            lastTop: targetTop
          });
        }
      }
    }, [syncState, containerRef.current]);
    return (arg) => {
      if (arg === null || arg === void 0) {
        triggerFlash();
        return;
      }
      wrapperRaf.cancel(scrollRef.current);
      if (typeof arg === "number") {
        syncScrollTop(arg);
      } else if (arg && typeof arg === "object") {
        let index;
        const {
          align
        } = arg;
        if ("index" in arg) {
          ({
            index
          } = arg);
        } else {
          index = data2.findIndex((item) => getKey2(item) === arg.key);
        }
        const {
          offset: offset2 = 0
        } = arg;
        setSyncState({
          times: 0,
          index,
          offset: offset2,
          originAlign: align
        });
      }
    };
  }
  const ScrollBar = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls,
      rtl,
      scrollOffset,
      scrollRange,
      onStartMove,
      onStopMove,
      onScroll,
      horizontal,
      spinSize,
      containerSize,
      style: style2,
      thumbStyle: propsThumbStyle,
      showScrollBar
    } = props;
    const [dragging, setDragging] = reactExports.useState(false);
    const [pageXY, setPageXY] = reactExports.useState(null);
    const [startTop, setStartTop] = reactExports.useState(null);
    const isLTR = !rtl;
    const scrollbarRef = reactExports.useRef();
    const thumbRef = reactExports.useRef();
    const [visible, setVisible] = reactExports.useState(showScrollBar);
    const visibleTimeoutRef = reactExports.useRef();
    const delayHidden = () => {
      if (showScrollBar === true || showScrollBar === false) return;
      clearTimeout(visibleTimeoutRef.current);
      setVisible(true);
      visibleTimeoutRef.current = setTimeout(() => {
        setVisible(false);
      }, 3e3);
    };
    const enableScrollRange = scrollRange - containerSize || 0;
    const enableOffsetRange = containerSize - spinSize || 0;
    const top = reactExports.useMemo(() => {
      if (scrollOffset === 0 || enableScrollRange === 0) {
        return 0;
      }
      const ptg = scrollOffset / enableScrollRange;
      return ptg * enableOffsetRange;
    }, [scrollOffset, enableScrollRange, enableOffsetRange]);
    const onContainerMouseDown = (e) => {
      e.stopPropagation();
      e.preventDefault();
    };
    const stateRef = reactExports.useRef({
      top,
      dragging,
      pageY: pageXY,
      startTop
    });
    stateRef.current = {
      top,
      dragging,
      pageY: pageXY,
      startTop
    };
    const onThumbMouseDown = (e) => {
      setDragging(true);
      setPageXY(getPageXY(e, horizontal));
      setStartTop(stateRef.current.top);
      onStartMove();
      e.stopPropagation();
      e.preventDefault();
    };
    reactExports.useEffect(() => {
      const onScrollbarTouchStart = (e) => {
        e.preventDefault();
      };
      const scrollbarEle = scrollbarRef.current;
      const thumbEle = thumbRef.current;
      scrollbarEle.addEventListener("touchstart", onScrollbarTouchStart, {
        passive: false
      });
      thumbEle.addEventListener("touchstart", onThumbMouseDown, {
        passive: false
      });
      return () => {
        scrollbarEle.removeEventListener("touchstart", onScrollbarTouchStart);
        thumbEle.removeEventListener("touchstart", onThumbMouseDown);
      };
    }, []);
    const enableScrollRangeRef = reactExports.useRef();
    enableScrollRangeRef.current = enableScrollRange;
    const enableOffsetRangeRef = reactExports.useRef();
    enableOffsetRangeRef.current = enableOffsetRange;
    reactExports.useEffect(() => {
      if (dragging) {
        let moveRafId;
        const onMouseMove = (e) => {
          const {
            dragging: stateDragging,
            pageY: statePageY,
            startTop: stateStartTop
          } = stateRef.current;
          wrapperRaf.cancel(moveRafId);
          const rect = scrollbarRef.current.getBoundingClientRect();
          const scale2 = containerSize / (horizontal ? rect.width : rect.height);
          if (stateDragging) {
            const offset2 = (getPageXY(e, horizontal) - statePageY) * scale2;
            let newTop = stateStartTop;
            if (!isLTR && horizontal) {
              newTop -= offset2;
            } else {
              newTop += offset2;
            }
            const tmpEnableScrollRange = enableScrollRangeRef.current;
            const tmpEnableOffsetRange = enableOffsetRangeRef.current;
            const ptg = tmpEnableOffsetRange ? newTop / tmpEnableOffsetRange : 0;
            let newScrollTop = Math.ceil(ptg * tmpEnableScrollRange);
            newScrollTop = Math.max(newScrollTop, 0);
            newScrollTop = Math.min(newScrollTop, tmpEnableScrollRange);
            moveRafId = wrapperRaf(() => {
              onScroll(newScrollTop, horizontal);
            });
          }
        };
        const onMouseUp = () => {
          setDragging(false);
          onStopMove();
        };
        window.addEventListener("mousemove", onMouseMove, {
          passive: true
        });
        window.addEventListener("touchmove", onMouseMove, {
          passive: true
        });
        window.addEventListener("mouseup", onMouseUp, {
          passive: true
        });
        window.addEventListener("touchend", onMouseUp, {
          passive: true
        });
        return () => {
          window.removeEventListener("mousemove", onMouseMove);
          window.removeEventListener("touchmove", onMouseMove);
          window.removeEventListener("mouseup", onMouseUp);
          window.removeEventListener("touchend", onMouseUp);
          wrapperRaf.cancel(moveRafId);
        };
      }
    }, [dragging]);
    reactExports.useEffect(() => {
      delayHidden();
      return () => {
        clearTimeout(visibleTimeoutRef.current);
      };
    }, [scrollOffset]);
    reactExports.useImperativeHandle(ref2, () => ({
      delayHidden
    }));
    const scrollbarPrefixCls = `${prefixCls}-scrollbar`;
    const containerStyle = {
      position: "absolute",
      visibility: visible ? null : "hidden"
    };
    const thumbStyle = {
      position: "absolute",
      borderRadius: 99,
      background: "var(--rc-virtual-list-scrollbar-bg, rgba(0, 0, 0, 0.5))",
      cursor: "pointer",
      userSelect: "none"
    };
    if (horizontal) {
      Object.assign(containerStyle, {
        height: 8,
        left: 0,
        right: 0,
        bottom: 0
      });
      Object.assign(thumbStyle, {
        height: "100%",
        width: spinSize,
        [isLTR ? "left" : "right"]: top
      });
    } else {
      Object.assign(containerStyle, {
        width: 8,
        top: 0,
        bottom: 0,
        [isLTR ? "right" : "left"]: 0
      });
      Object.assign(thumbStyle, {
        width: "100%",
        height: spinSize,
        top
      });
    }
    return reactExports.createElement("div", {
      ref: scrollbarRef,
      className: clsx(scrollbarPrefixCls, {
        [`${scrollbarPrefixCls}-horizontal`]: horizontal,
        [`${scrollbarPrefixCls}-vertical`]: !horizontal,
        [`${scrollbarPrefixCls}-visible`]: visible
      }),
      style: {
        ...containerStyle,
        ...style2
      },
      onMouseDown: onContainerMouseDown,
      onMouseMove: delayHidden
    }, reactExports.createElement("div", {
      ref: thumbRef,
      className: clsx(`${scrollbarPrefixCls}-thumb`, {
        [`${scrollbarPrefixCls}-thumb-moving`]: dragging
      }),
      style: {
        ...thumbStyle,
        ...propsThumbStyle
      },
      onMouseDown: onThumbMouseDown
    }));
  });
  const MIN_SIZE = 20;
  function getSpinSize(containerSize = 0, scrollRange = 0) {
    let baseSize = containerSize / scrollRange * containerSize;
    if (isNaN(baseSize)) {
      baseSize = 0;
    }
    baseSize = Math.max(baseSize, MIN_SIZE);
    return Math.floor(baseSize);
  }
  const EMPTY_DATA = [];
  const ScrollStyle = {
    overflowY: "auto",
    overflowAnchor: "none"
  };
  function RawList(props, ref2) {
    const {
      prefixCls = "rc-virtual-list",
      className,
      height,
      itemHeight,
      fullHeight = true,
      style: style2,
      data: data2,
      children,
      itemKey: itemKey2,
      virtual,
      direction,
      scrollWidth,
      component: Component = "div",
      onScroll,
      onVirtualScroll,
      onVisibleChange,
      innerProps,
      extraRender,
      styles,
      showScrollBar = "optional",
      ...restProps
    } = props;
    const getKey2 = reactExports.useCallback((item) => {
      if (typeof itemKey2 === "function") {
        return itemKey2(item);
      }
      return item?.[itemKey2];
    }, [itemKey2]);
    const [setInstanceRef, collectHeight, heights, heightUpdatedMark] = useHeights(getKey2);
    const useVirtual = !!(virtual !== false && height && itemHeight);
    const containerHeight = reactExports.useMemo(() => Object.values(heights.maps).reduce((total, curr) => total + curr, 0), [heights.id, heights.maps]);
    const inVirtual = useVirtual && data2 && (Math.max(itemHeight * data2.length, containerHeight) > height || !!scrollWidth);
    const isRTL = direction === "rtl";
    const mergedClassName = clsx(prefixCls, {
      [`${prefixCls}-rtl`]: isRTL
    }, className);
    const mergedData = data2 || EMPTY_DATA;
    const componentRef = reactExports.useRef();
    const fillerInnerRef = reactExports.useRef();
    const containerRef = reactExports.useRef();
    const [offsetTop, setOffsetTop] = reactExports.useState(0);
    const [offsetLeft, setOffsetLeft] = reactExports.useState(0);
    const [scrollMoving, setScrollMoving] = reactExports.useState(false);
    const onScrollbarStartMove = () => {
      setScrollMoving(true);
    };
    const onScrollbarStopMove = () => {
      setScrollMoving(false);
    };
    const sharedConfig = {
      getKey: getKey2
    };
    function syncScrollTop(newTop) {
      setOffsetTop((origin) => {
        let value;
        if (typeof newTop === "function") {
          value = newTop(origin);
        } else {
          value = newTop;
        }
        const alignedTop = keepInRange(value);
        componentRef.current.scrollTop = alignedTop;
        return alignedTop;
      });
    }
    const rangeRef = reactExports.useRef({
      start: 0,
      end: mergedData.length
    });
    const diffItemRef = reactExports.useRef();
    const [diffItem] = useDiffItem(mergedData, getKey2);
    diffItemRef.current = diffItem;
    const {
      scrollHeight,
      start,
      end,
      offset: fillerOffset
    } = reactExports.useMemo(() => {
      if (!useVirtual) {
        return {
          scrollHeight: void 0,
          start: 0,
          end: mergedData.length - 1,
          offset: void 0
        };
      }
      if (!inVirtual) {
        return {
          scrollHeight: fillerInnerRef.current?.offsetHeight || 0,
          start: 0,
          end: mergedData.length - 1,
          offset: void 0
        };
      }
      let itemTop = 0;
      let startIndex;
      let startOffset;
      let endIndex;
      const dataLen = mergedData.length;
      for (let i2 = 0; i2 < dataLen; i2 += 1) {
        const item = mergedData[i2];
        const key = getKey2(item);
        const cacheHeight = heights.get(key);
        const currentItemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
        if (currentItemBottom >= offsetTop && startIndex === void 0) {
          startIndex = i2;
          startOffset = itemTop;
        }
        if (currentItemBottom > offsetTop + height && endIndex === void 0) {
          endIndex = i2;
        }
        itemTop = currentItemBottom;
      }
      if (startIndex === void 0) {
        startIndex = 0;
        startOffset = 0;
        endIndex = Math.ceil(height / itemHeight);
      }
      if (endIndex === void 0) {
        endIndex = mergedData.length - 1;
      }
      endIndex = Math.min(endIndex + 1, mergedData.length - 1);
      return {
        scrollHeight: itemTop,
        start: startIndex,
        end: endIndex,
        offset: startOffset
      };
    }, [inVirtual, useVirtual, offsetTop, mergedData, heightUpdatedMark, height]);
    rangeRef.current.start = start;
    rangeRef.current.end = end;
    reactExports.useLayoutEffect(() => {
      const changedRecord = heights.getRecord();
      if (changedRecord.size === 1) {
        const recordKey = Array.from(changedRecord.keys())[0];
        const prevCacheHeight = changedRecord.get(recordKey);
        const startItem = mergedData[start];
        if (startItem && prevCacheHeight === void 0) {
          const startIndexKey = getKey2(startItem);
          if (startIndexKey === recordKey) {
            const realStartHeight = heights.get(recordKey);
            const diffHeight = realStartHeight - itemHeight;
            syncScrollTop((ori) => {
              return ori + diffHeight;
            });
          }
        }
      }
      heights.resetRecord();
    }, [scrollHeight]);
    const [size, setSize] = reactExports.useState({
      width: 0,
      height
    });
    const onHolderResize = (sizeInfo) => {
      setSize({
        width: sizeInfo.offsetWidth,
        height: sizeInfo.offsetHeight
      });
    };
    const verticalScrollBarRef = reactExports.useRef();
    const horizontalScrollBarRef = reactExports.useRef();
    const horizontalScrollBarSpinSize = reactExports.useMemo(() => getSpinSize(size.width, scrollWidth), [size.width, scrollWidth]);
    const verticalScrollBarSpinSize = reactExports.useMemo(() => getSpinSize(size.height, scrollHeight), [size.height, scrollHeight]);
    const maxScrollHeight = scrollHeight - height;
    const maxScrollHeightRef = reactExports.useRef(maxScrollHeight);
    maxScrollHeightRef.current = maxScrollHeight;
    function keepInRange(newScrollTop) {
      let newTop = newScrollTop;
      if (!Number.isNaN(maxScrollHeightRef.current)) {
        newTop = Math.min(newTop, maxScrollHeightRef.current);
      }
      newTop = Math.max(newTop, 0);
      return newTop;
    }
    const isScrollAtTop = offsetTop <= 0;
    const isScrollAtBottom = offsetTop >= maxScrollHeight;
    const isScrollAtLeft = offsetLeft <= 0;
    const isScrollAtRight = offsetLeft >= scrollWidth;
    const originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);
    const getVirtualScrollInfo = () => ({
      x: isRTL ? -offsetLeft : offsetLeft,
      y: offsetTop
    });
    const lastVirtualScrollInfoRef = reactExports.useRef(getVirtualScrollInfo());
    const triggerScroll = useEvent$1((params) => {
      if (onVirtualScroll) {
        const nextInfo = {
          ...getVirtualScrollInfo(),
          ...params
        };
        if (lastVirtualScrollInfoRef.current.x !== nextInfo.x || lastVirtualScrollInfoRef.current.y !== nextInfo.y) {
          onVirtualScroll(nextInfo);
          lastVirtualScrollInfoRef.current = nextInfo;
        }
      }
    });
    function onScrollBar(newScrollOffset, horizontal) {
      const newOffset = newScrollOffset;
      if (horizontal) {
        reactDomExports.flushSync(() => {
          setOffsetLeft(newOffset);
        });
        triggerScroll();
      } else {
        syncScrollTop(newOffset);
      }
    }
    function onFallbackScroll(e) {
      const {
        scrollTop: newScrollTop
      } = e.currentTarget;
      if (newScrollTop !== offsetTop) {
        syncScrollTop(newScrollTop);
      }
      onScroll?.(e);
      triggerScroll();
    }
    const keepInHorizontalRange = (nextOffsetLeft) => {
      let tmpOffsetLeft = nextOffsetLeft;
      const max = !!scrollWidth ? scrollWidth - size.width : 0;
      tmpOffsetLeft = Math.max(tmpOffsetLeft, 0);
      tmpOffsetLeft = Math.min(tmpOffsetLeft, max);
      return tmpOffsetLeft;
    };
    const onWheelDelta = useEvent$1((offsetXY, fromHorizontal) => {
      if (fromHorizontal) {
        reactDomExports.flushSync(() => {
          setOffsetLeft((left) => {
            const nextOffsetLeft = left + (isRTL ? -offsetXY : offsetXY);
            return keepInHorizontalRange(nextOffsetLeft);
          });
        });
        triggerScroll();
      } else {
        syncScrollTop((top) => {
          const newTop = top + offsetXY;
          return newTop;
        });
      }
    });
    const [onRawWheel, onFireFoxScroll] = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, !!scrollWidth, onWheelDelta);
    useMobileTouchMove(useVirtual, componentRef, (isHorizontal, delta, smoothOffset, e) => {
      const event = e;
      if (originScroll(isHorizontal, delta, smoothOffset)) {
        return false;
      }
      if (!event || !event._virtualHandled) {
        if (event) {
          event._virtualHandled = true;
        }
        onRawWheel({
          preventDefault() {
          },
          deltaX: isHorizontal ? delta : 0,
          deltaY: isHorizontal ? 0 : delta
        });
        return true;
      }
      return false;
    });
    useScrollDrag(inVirtual, componentRef, (offset2) => {
      syncScrollTop((top) => top + offset2);
    });
    useLayoutEffect(() => {
      function onMozMousePixelScroll(e) {
        const scrollingUpAtTop = isScrollAtTop && e.detail < 0;
        const scrollingDownAtBottom = isScrollAtBottom && e.detail > 0;
        if (useVirtual && !scrollingUpAtTop && !scrollingDownAtBottom) {
          e.preventDefault();
        }
      }
      const componentEle = componentRef.current;
      componentEle.addEventListener("wheel", onRawWheel, {
        passive: false
      });
      componentEle.addEventListener("DOMMouseScroll", onFireFoxScroll, {
        passive: true
      });
      componentEle.addEventListener("MozMousePixelScroll", onMozMousePixelScroll, {
        passive: false
      });
      return () => {
        componentEle.removeEventListener("wheel", onRawWheel);
        componentEle.removeEventListener("DOMMouseScroll", onFireFoxScroll);
        componentEle.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
      };
    }, [useVirtual, isScrollAtTop, isScrollAtBottom]);
    useLayoutEffect(() => {
      if (scrollWidth) {
        const newOffsetLeft = keepInHorizontalRange(offsetLeft);
        setOffsetLeft(newOffsetLeft);
        triggerScroll({
          x: newOffsetLeft
        });
      }
    }, [size.width, scrollWidth]);
    const delayHideScrollBar = () => {
      verticalScrollBarRef.current?.delayHidden();
      horizontalScrollBarRef.current?.delayHidden();
    };
    const scrollTo2 = useScrollTo(componentRef, mergedData, heights, itemHeight, getKey2, () => collectHeight(true), syncScrollTop, delayHideScrollBar);
    reactExports.useImperativeHandle(ref2, () => ({
      nativeElement: containerRef.current,
      getScrollInfo: getVirtualScrollInfo,
      scrollTo: (config) => {
        function isPosScroll(arg) {
          return arg && typeof arg === "object" && ("left" in arg || "top" in arg);
        }
        if (isPosScroll(config)) {
          if (config.left !== void 0) {
            setOffsetLeft(keepInHorizontalRange(config.left));
          }
          scrollTo2(config.top);
        } else {
          scrollTo2(config);
        }
      }
    }));
    useLayoutEffect(() => {
      if (onVisibleChange) {
        const renderList = mergedData.slice(start, end + 1);
        onVisibleChange(renderList, mergedData);
      }
    }, [start, end, mergedData]);
    const getSize2 = useGetSize(mergedData, getKey2, heights, itemHeight);
    const extraContent = extraRender?.({
      start,
      end,
      virtual: inVirtual,
      offsetX: offsetLeft,
      offsetY: fillerOffset,
      rtl: isRTL,
      getSize: getSize2
    });
    const listChildren = useChildren(mergedData, start, end, scrollWidth, offsetLeft, setInstanceRef, children, sharedConfig);
    let componentStyle = null;
    if (height) {
      componentStyle = {
        [fullHeight ? "height" : "maxHeight"]: height,
        ...ScrollStyle
      };
      if (useVirtual) {
        componentStyle.overflowY = "hidden";
        if (scrollWidth) {
          componentStyle.overflowX = "hidden";
        }
        if (scrollMoving) {
          componentStyle.pointerEvents = "none";
        }
      }
    }
    const containerProps = {};
    if (isRTL) {
      containerProps.dir = "rtl";
    }
    return reactExports.createElement("div", _extends$15({
      ref: containerRef,
      style: {
        ...style2,
        position: "relative"
      },
      className: mergedClassName
    }, containerProps, restProps), reactExports.createElement(RefResizeObserver, {
      onResize: onHolderResize
    }, reactExports.createElement(Component, {
      className: `${prefixCls}-holder`,
      style: componentStyle,
      ref: componentRef,
      onScroll: onFallbackScroll,
      onMouseEnter: delayHideScrollBar
    }, reactExports.createElement(Filler, {
      prefixCls,
      height: scrollHeight,
      offsetX: offsetLeft,
      offsetY: fillerOffset,
      scrollWidth,
      onInnerResize: collectHeight,
      ref: fillerInnerRef,
      innerProps,
      rtl: isRTL,
      extra: extraContent
    }, listChildren))), inVirtual && scrollHeight > height && reactExports.createElement(ScrollBar, {
      ref: verticalScrollBarRef,
      prefixCls,
      scrollOffset: offsetTop,
      scrollRange: scrollHeight,
      rtl: isRTL,
      onScroll: onScrollBar,
      onStartMove: onScrollbarStartMove,
      onStopMove: onScrollbarStopMove,
      spinSize: verticalScrollBarSpinSize,
      containerSize: size.height,
      style: styles?.verticalScrollBar,
      thumbStyle: styles?.verticalScrollBarThumb,
      showScrollBar
    }), inVirtual && scrollWidth > size.width && reactExports.createElement(ScrollBar, {
      ref: horizontalScrollBarRef,
      prefixCls,
      scrollOffset: offsetLeft,
      scrollRange: scrollWidth,
      rtl: isRTL,
      onScroll: onScrollBar,
      onStartMove: onScrollbarStartMove,
      onStopMove: onScrollbarStopMove,
      spinSize: horizontalScrollBarSpinSize,
      containerSize: size.width,
      horizontal: true,
      style: styles?.horizontalScrollBar,
      thumbStyle: styles?.horizontalScrollBarThumb,
      showScrollBar
    }));
  }
  const List = reactExports.forwardRef(RawList);
  List.displayName = "List";
  function isPlatformMac() {
    return /(mac\sos|macintosh)/i.test(navigator.appVersion);
  }
  function _extends$E() {
    _extends$E = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$E.apply(this, arguments);
  }
  function isTitleType(content) {
    return typeof content === "string" || typeof content === "number";
  }
  const OptionList = (_2, ref2) => {
    const {
      prefixCls,
      id: id2,
      open: open2,
      multiple,
      mode,
      searchValue,
      toggleOpen,
      notFoundContent,
      onPopupScroll,
      showScrollBar,
      lockOptions
    } = useBaseProps();
    const {
      maxCount,
      flattenOptions: flattenOptions2,
      onActiveValue,
      defaultActiveFirstOption,
      onSelect,
      menuItemSelectedIcon,
      rawValues,
      fieldNames,
      virtual,
      direction,
      listHeight,
      listItemHeight,
      optionRender,
      classNames: contextClassNames,
      styles: contextStyles
    } = reactExports.useContext(SelectContext);
    const itemPrefixCls = `${prefixCls}-item`;
    const memoFlattenOptions = useMemo(() => flattenOptions2, [open2, lockOptions], (prev2, next2) => next2[0] && !next2[1]);
    const listRef = reactExports.useRef(null);
    const overMaxCount = reactExports.useMemo(() => multiple && isValidCount(maxCount) && rawValues?.size >= maxCount, [multiple, maxCount, rawValues?.size]);
    const onListMouseDown = (event) => {
      event.preventDefault();
    };
    const scrollIntoView = (args) => {
      listRef.current?.scrollTo(typeof args === "number" ? {
        index: args
      } : args);
    };
    const isSelected = reactExports.useCallback((value) => {
      if (mode === "combobox") {
        return false;
      }
      return rawValues.has(value);
    }, [mode, [...rawValues].toString(), rawValues.size]);
    const getEnabledActiveIndex = (index, offset2 = 1) => {
      const len = memoFlattenOptions.length;
      for (let i2 = 0; i2 < len; i2 += 1) {
        const current = (index + i2 * offset2 + len) % len;
        const {
          group,
          data: data2
        } = memoFlattenOptions[current] || {};
        if (!group && !data2?.disabled && (isSelected(data2.value) || !overMaxCount)) {
          return current;
        }
      }
      return -1;
    };
    const [activeIndex, setActiveIndex] = reactExports.useState(() => getEnabledActiveIndex(0));
    const setActive = (index, fromKeyboard = false) => {
      setActiveIndex(index);
      const info = {
        source: fromKeyboard ? "keyboard" : "mouse"
      };
      const flattenItem = memoFlattenOptions[index];
      if (!flattenItem) {
        onActiveValue(null, -1, info);
        return;
      }
      onActiveValue(flattenItem.value, index, info);
    };
    reactExports.useEffect(() => {
      setActive(defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
    }, [memoFlattenOptions.length, searchValue]);
    const isAriaSelected = reactExports.useCallback((value) => {
      if (mode === "combobox") {
        return String(value).toLowerCase() === searchValue.toLowerCase();
      }
      return rawValues.has(value);
    }, [mode, searchValue, [...rawValues].toString(), rawValues.size]);
    reactExports.useEffect(() => {
      let timeoutId;
      if (!multiple && open2 && rawValues.size === 1) {
        const value = Array.from(rawValues)[0];
        const index = memoFlattenOptions.findIndex(({
          data: data2
        }) => searchValue ? String(data2.value).startsWith(searchValue) : data2.value === value);
        if (index !== -1) {
          setActive(index);
          timeoutId = setTimeout(() => {
            scrollIntoView(index);
          });
        }
      }
      if (open2) {
        listRef.current?.scrollTo(void 0);
      }
      return () => clearTimeout(timeoutId);
    }, [open2, searchValue]);
    const onSelectValue = (value) => {
      if (value !== void 0) {
        onSelect(value, {
          selected: !rawValues.has(value)
        });
      }
      if (!multiple) {
        toggleOpen(false);
      }
    };
    reactExports.useImperativeHandle(ref2, () => ({
      onKeyDown: (event) => {
        const {
          which,
          ctrlKey
        } = event;
        switch (which) {
case KeyCode.N:
          case KeyCode.P:
          case KeyCode.UP:
          case KeyCode.DOWN: {
            let offset2 = 0;
            if (which === KeyCode.UP) {
              offset2 = -1;
            } else if (which === KeyCode.DOWN) {
              offset2 = 1;
            } else if (isPlatformMac() && ctrlKey) {
              if (which === KeyCode.N) {
                offset2 = 1;
              } else if (which === KeyCode.P) {
                offset2 = -1;
              }
            }
            if (offset2 !== 0) {
              const nextActiveIndex = getEnabledActiveIndex(activeIndex + offset2, offset2);
              scrollIntoView(nextActiveIndex);
              setActive(nextActiveIndex, true);
            }
            break;
          }
case KeyCode.TAB:
          case KeyCode.ENTER: {
            const item = memoFlattenOptions[activeIndex];
            if (!item || item.data.disabled) {
              return onSelectValue(void 0);
            }
            if (!overMaxCount || rawValues.has(item.value)) {
              onSelectValue(item.value);
            } else {
              onSelectValue(void 0);
            }
            if (open2) {
              event.preventDefault();
            }
            break;
          }
case KeyCode.ESC: {
            toggleOpen(false);
            if (open2) {
              event.stopPropagation();
            }
          }
        }
      },
      onKeyUp: () => {
      },
      scrollTo: (index) => {
        scrollIntoView(index);
      }
    }));
    if (memoFlattenOptions.length === 0) {
      return reactExports.createElement("div", {
        role: "listbox",
        id: `${id2}_list`,
        className: `${itemPrefixCls}-empty`,
        onMouseDown: onListMouseDown
      }, notFoundContent);
    }
    const omitFieldNameList = Object.keys(fieldNames).map((key) => fieldNames[key]);
    const getLabel = (item) => item.label;
    function getItemAriaProps(item, index) {
      const {
        group
      } = item;
      return {
        role: group ? "presentation" : "option",
        id: `${id2}_list_${index}`
      };
    }
    const renderItem = (index) => {
      const item = memoFlattenOptions[index];
      if (!item) {
        return null;
      }
      const itemData = item.data || {};
      const {
        value,
        disabled
      } = itemData;
      const {
        group
      } = item;
      const attrs = pickAttrs(itemData, true);
      const mergedLabel = getLabel(item);
      return item ? reactExports.createElement("div", _extends$E({
        "aria-label": typeof mergedLabel === "string" && !group ? mergedLabel : null
      }, attrs, {
        key: index
      }, getItemAriaProps(item, index), {
        "aria-selected": isAriaSelected(value),
        "aria-disabled": disabled
      }), value) : null;
    };
    const a11yProps = {
      role: "listbox",
      id: `${id2}_list`
    };
    return reactExports.createElement(reactExports.Fragment, null, virtual && reactExports.createElement("div", _extends$E({}, a11yProps, {
      style: {
        height: 0,
        width: 0,
        overflow: "hidden"
      }
    }), renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1)), reactExports.createElement(List, {
      itemKey: "key",
      ref: listRef,
      data: memoFlattenOptions,
      height: listHeight,
      itemHeight: listItemHeight,
      fullHeight: false,
      onMouseDown: onListMouseDown,
      onScroll: onPopupScroll,
      virtual,
      direction,
      innerProps: virtual ? null : a11yProps,
      showScrollBar,
      className: contextClassNames?.popup?.list,
      style: contextStyles?.popup?.list
    }, (item, itemIndex) => {
      const {
        group,
        groupOption,
        data: data2,
        label,
        value
      } = item;
      const {
        key
      } = data2;
      if (group) {
        const groupTitle = data2.title ?? (isTitleType(label) ? label.toString() : void 0);
        return reactExports.createElement("div", {
          className: clsx(itemPrefixCls, `${itemPrefixCls}-group`, data2.className),
          title: groupTitle
        }, label !== void 0 ? label : key);
      }
      const {
        disabled,
        title,
        children,
        style: style2,
        className,
        ...otherProps
      } = data2;
      const passedProps = omit(otherProps, omitFieldNameList);
      const selected = isSelected(value);
      const mergedDisabled = disabled || !selected && overMaxCount;
      const optionPrefixCls = `${itemPrefixCls}-option`;
      const optionClassName = clsx(itemPrefixCls, optionPrefixCls, className, contextClassNames?.popup?.listItem, {
        [`${optionPrefixCls}-grouped`]: groupOption,
        [`${optionPrefixCls}-active`]: activeIndex === itemIndex && !mergedDisabled,
        [`${optionPrefixCls}-disabled`]: mergedDisabled,
        [`${optionPrefixCls}-selected`]: selected
      });
      const mergedLabel = getLabel(item);
      const iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === "function" || selected;
      const content = typeof mergedLabel === "number" ? mergedLabel : mergedLabel || value;
      let optionTitle = isTitleType(content) ? content.toString() : void 0;
      if (title !== void 0) {
        optionTitle = title;
      }
      return reactExports.createElement("div", _extends$E({}, pickAttrs(passedProps), !virtual ? getItemAriaProps(item, itemIndex) : {}, {
        "aria-selected": virtual ? void 0 : isAriaSelected(value),
        "aria-disabled": mergedDisabled,
        className: optionClassName,
        title: optionTitle,
        onMouseMove: () => {
          if (activeIndex === itemIndex || mergedDisabled) {
            return;
          }
          setActive(itemIndex);
        },
        onClick: () => {
          if (!mergedDisabled) {
            onSelectValue(value);
          }
        },
        style: {
          ...contextStyles?.popup?.listItem,
          ...style2
        }
      }), reactExports.createElement("div", {
        className: `${optionPrefixCls}-content`
      }, typeof optionRender === "function" ? optionRender(item, {
        index: itemIndex
      }) : content), reactExports.isValidElement(menuItemSelectedIcon) || selected, iconVisible && reactExports.createElement(TransBtn, {
        className: `${itemPrefixCls}-option-state`,
        customizeIcon: menuItemSelectedIcon,
        customizeIconProps: {
          value,
          disabled: mergedDisabled,
          isSelected: selected
        }
      }, selected ? "✓" : null));
    }));
  };
  const RefOptionList = reactExports.forwardRef(OptionList);
  const useCache = ((labeledValues, valueOptions) => {
    const cacheRef = reactExports.useRef({
      values: new Map(),
      options: new Map()
    });
    const filledLabeledValues = reactExports.useMemo(() => {
      const {
        values: prevValueCache,
        options: prevOptionCache
      } = cacheRef.current;
      const patchedValues = labeledValues.map((item) => {
        if (item.label === void 0) {
          return {
            ...item,
            label: prevValueCache.get(item.value)?.label
          };
        }
        return item;
      });
      const valueCache = new Map();
      const optionCache = new Map();
      patchedValues.forEach((item) => {
        valueCache.set(item.value, item);
        optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));
      });
      cacheRef.current.values = valueCache;
      cacheRef.current.options = optionCache;
      return patchedValues;
    }, [labeledValues, valueOptions]);
    const getOption = reactExports.useCallback((val) => valueOptions.get(val) || cacheRef.current.options.get(val), [valueOptions]);
    return [filledLabeledValues, getOption];
  });
  function includes(test2, search) {
    return toArray$1(test2).join("").toUpperCase().includes(search);
  }
  const useFilterOptions = ((options, fieldNames, searchValue, filterOption, optionFilterProp) => {
    return reactExports.useMemo(() => {
      if (!searchValue || filterOption === false) {
        return options;
      }
      const {
        options: fieldOptions,
        label: fieldLabel,
        value: fieldValue
      } = fieldNames;
      const filteredOptions = [];
      const customizeFilter = typeof filterOption === "function";
      const upperSearch = searchValue.toUpperCase();
      const filterFunc = customizeFilter ? filterOption : (_2, option) => {
        if (optionFilterProp && optionFilterProp.length) {
          return optionFilterProp.some((prop) => includes(option[prop], upperSearch));
        }
        if (option[fieldOptions]) {
          return includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch);
        }
        return includes(option[fieldValue], upperSearch);
      };
      const wrapOption = customizeFilter ? (opt) => injectPropsWithOption(opt) : (opt) => opt;
      options.forEach((item) => {
        if (item[fieldOptions]) {
          const matchGroup = filterFunc(searchValue, wrapOption(item));
          if (matchGroup) {
            filteredOptions.push(item);
          } else {
            const subOptions = item[fieldOptions].filter((subItem) => filterFunc(searchValue, wrapOption(subItem)));
            if (subOptions.length) {
              filteredOptions.push({
                ...item,
                [fieldOptions]: subOptions
              });
            }
          }
          return;
        }
        if (filterFunc(searchValue, wrapOption(item))) {
          filteredOptions.push(item);
        }
      });
      return filteredOptions;
    }, [options, filterOption, optionFilterProp, searchValue, fieldNames]);
  });
  function convertNodeToOption(node2) {
    const {
      key,
      props: {
        children,
        value,
        ...restProps
      }
    } = node2;
    return {
      key,
      value: value !== void 0 ? value : key,
      children,
      ...restProps
    };
  }
  function convertChildrenToData(nodes, optionOnly = false) {
    return toArray$4(nodes).map((node2, index) => {
      if (! reactExports.isValidElement(node2) || !node2.type) {
        return null;
      }
      const {
        type: {
          isSelectOptGroup
        },
        key,
        props: {
          children,
          ...restProps
        }
      } = node2;
      if (optionOnly || !isSelectOptGroup) {
        return convertNodeToOption(node2);
      }
      return {
        key: `__RC_SELECT_GRP__${key === null ? index : key}__`,
        label: key,
        ...restProps,
        options: convertChildrenToData(children)
      };
    }).filter((data2) => data2);
  }
  const useOptions = (options, children, fieldNames, optionFilterProp, optionLabelProp) => {
    return reactExports.useMemo(() => {
      let mergedOptions = options;
      const childrenAsData = !options;
      if (childrenAsData) {
        mergedOptions = convertChildrenToData(children);
      }
      const valueOptions = new Map();
      const labelOptions = new Map();
      const setLabelOptions = (labelOptionsMap, option, key) => {
        if (key && typeof key === "string") {
          labelOptionsMap.set(option[key], option);
        }
      };
      const dig = (optionList, isChildren = false) => {
        for (let i2 = 0; i2 < optionList.length; i2 += 1) {
          const option = optionList[i2];
          if (!option[fieldNames.options] || isChildren) {
            valueOptions.set(option[fieldNames.value], option);
            setLabelOptions(labelOptions, option, fieldNames.label);
            optionFilterProp.forEach((prop) => {
              setLabelOptions(labelOptions, option, prop);
            });
            setLabelOptions(labelOptions, option, optionLabelProp);
          } else {
            dig(option[fieldNames.options], true);
          }
        }
      };
      dig(mergedOptions);
      return {
        options: mergedOptions,
        valueOptions,
        labelOptions
      };
    }, [options, children, fieldNames, optionFilterProp, optionLabelProp]);
  };
  function useRefFunc(callback) {
    const funcRef = reactExports.useRef();
    funcRef.current = callback;
    const cacheFn = reactExports.useCallback((...args) => {
      return funcRef.current(...args);
    }, []);
    return cacheFn;
  }
  function useSearchConfig(showSearch, props, mode) {
    const {
      filterOption,
      searchValue,
      optionFilterProp,
      filterSort,
      onSearch,
      autoClearSearchValue
    } = props;
    return reactExports.useMemo(() => {
      const isObject2 = typeof showSearch === "object";
      const searchConfig = {
        filterOption,
        searchValue,
        optionFilterProp,
        filterSort,
        onSearch,
        autoClearSearchValue,
        ...isObject2 ? showSearch : {}
      };
      return [isObject2 || mode === "combobox" || mode === "tags" || mode === "multiple" && showSearch === void 0 ? true : showSearch, searchConfig];
    }, [mode, showSearch, filterOption, searchValue, optionFilterProp, filterSort, onSearch, autoClearSearchValue]);
  }
  function _extends$D() {
    _extends$D = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$D.apply(this, arguments);
  }
  const OMIT_DOM_PROPS = ["inputValue"];
  function isRawValue(value) {
    return !value || typeof value !== "object";
  }
  const Select$1 = reactExports.forwardRef((props, ref2) => {
    const {
      id: id2,
      mode,
      prefixCls = "rc-select",
      backfill,
      fieldNames,
showSearch,
      searchValue: legacySearchValue,
      onSearch: legacyOnSearch,
      autoClearSearchValue: legacyAutoClearSearchValue,
      filterOption: legacyFilterOption,
      optionFilterProp: legacyOptionFilterProp,
      filterSort: legacyFilterSort,
onSelect,
      onDeselect,
      onActive,
      popupMatchSelectWidth = true,
      optionLabelProp,
      options,
      optionRender,
      children,
      defaultActiveFirstOption,
      menuItemSelectedIcon,
      virtual,
      direction,
      listHeight = 200,
      listItemHeight = 20,
      labelRender,
value,
      defaultValue: defaultValue2,
      labelInValue,
      onChange,
      maxCount,
      classNames,
      styles,
      ...restProps
    } = props;
    const searchProps = {
      searchValue: legacySearchValue,
      onSearch: legacyOnSearch,
      autoClearSearchValue: legacyAutoClearSearchValue,
      filterOption: legacyFilterOption,
      optionFilterProp: legacyOptionFilterProp,
      filterSort: legacyFilterSort
    };
    const [mergedShowSearch, searchConfig] = useSearchConfig(showSearch, searchProps, mode);
    const {
      filterOption,
      searchValue,
      optionFilterProp,
      filterSort,
      onSearch,
      autoClearSearchValue = true
    } = searchConfig;
    const normalizedOptionFilterProp = reactExports.useMemo(() => {
      if (!optionFilterProp) return [];
      return Array.isArray(optionFilterProp) ? optionFilterProp : [optionFilterProp];
    }, [optionFilterProp]);
    const mergedId = useId(id2);
    const multiple = isMultiple(mode);
    const childrenAsData = !!(!options && children);
    const mergedFilterOption = reactExports.useMemo(() => {
      if (filterOption === void 0 && mode === "combobox") {
        return false;
      }
      return filterOption;
    }, [filterOption, mode]);
    const mergedFieldNames = reactExports.useMemo(
      () => fillFieldNames(fieldNames, childrenAsData),
[
JSON.stringify(fieldNames),
        childrenAsData
      ]
);
    const [internalSearchValue, setSearchValue] = useControlledState("", searchValue);
    const mergedSearchValue = internalSearchValue || "";
    const parsedOptions = useOptions(options, children, mergedFieldNames, normalizedOptionFilterProp, optionLabelProp);
    const {
      valueOptions,
      labelOptions,
      options: mergedOptions
    } = parsedOptions;
    const convert2LabelValues = reactExports.useCallback((draftValues) => {
      const valueList = toArray$1(draftValues);
      return valueList.map((val) => {
        let rawValue;
        let rawLabel;
        let rawDisabled;
        let rawTitle;
        if (isRawValue(val)) {
          rawValue = val;
        } else {
          rawLabel = val.label;
          rawValue = val.value;
        }
        const option = valueOptions.get(rawValue);
        if (option) {
          if (rawLabel === void 0) rawLabel = option?.[optionLabelProp || mergedFieldNames.label];
          rawDisabled = option?.disabled;
          rawTitle = option?.title;
        }
        return {
          label: rawLabel,
          value: rawValue,
          key: rawValue,
          disabled: rawDisabled,
          title: rawTitle
        };
      });
    }, [mergedFieldNames, optionLabelProp, valueOptions]);
    const [internalValue, setInternalValue] = useControlledState(defaultValue2, value);
    const rawLabeledValues = reactExports.useMemo(() => {
      const newInternalValue = multiple && internalValue === null ? [] : internalValue;
      const values = convert2LabelValues(newInternalValue);
      if (mode === "combobox" && isComboNoValue(values[0]?.value)) {
        return [];
      }
      return values;
    }, [internalValue, convert2LabelValues, mode, multiple]);
    const [mergedValues, getMixedOption] = useCache(rawLabeledValues, valueOptions);
    const displayValues = reactExports.useMemo(() => {
      if (!mode && mergedValues.length === 1) {
        const firstValue = mergedValues[0];
        if (firstValue.value === null && (firstValue.label === null || firstValue.label === void 0)) {
          return [];
        }
      }
      return mergedValues.map((item) => ({
        ...item,
        label: (typeof labelRender === "function" ? labelRender(item) : item.label) ?? item.value
      }));
    }, [mode, mergedValues, labelRender]);
    const rawValues = reactExports.useMemo(() => new Set(mergedValues.map((val) => val.value)), [mergedValues]);
    reactExports.useEffect(() => {
      if (mode === "combobox") {
        const strValue = mergedValues[0]?.value;
        setSearchValue(hasValue(strValue) ? String(strValue) : "");
      }
    }, [mergedValues]);
    const createTagOption = useRefFunc((val, label) => {
      const mergedLabel = label ?? val;
      return {
        [mergedFieldNames.value]: val,
        [mergedFieldNames.label]: mergedLabel
      };
    });
    const filledTagOptions = reactExports.useMemo(() => {
      if (mode !== "tags") {
        return mergedOptions;
      }
      const cloneOptions = [...mergedOptions];
      const existOptions = (val) => valueOptions.has(val);
      [...mergedValues].sort((a2, b) => a2.value < b.value ? -1 : 1).forEach((item) => {
        const val = item.value;
        if (!existOptions(val)) {
          cloneOptions.push(createTagOption(val, item.label));
        }
      });
      return cloneOptions;
    }, [createTagOption, mergedOptions, valueOptions, mergedValues, mode]);
    const filteredOptions = useFilterOptions(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, normalizedOptionFilterProp);
    const filledSearchOptions = reactExports.useMemo(() => {
      const hasItemMatchingSearch = (item) => {
        if (normalizedOptionFilterProp.length) {
          return normalizedOptionFilterProp.some((prop) => item?.[prop] === mergedSearchValue);
        }
        return item?.value === mergedSearchValue;
      };
      if (mode !== "tags" || !mergedSearchValue || filteredOptions.some((item) => hasItemMatchingSearch(item))) {
        return filteredOptions;
      }
      if (filteredOptions.some((item) => item[mergedFieldNames.value] === mergedSearchValue)) {
        return filteredOptions;
      }
      return [createTagOption(mergedSearchValue), ...filteredOptions];
    }, [createTagOption, normalizedOptionFilterProp, mode, filteredOptions, mergedSearchValue, mergedFieldNames]);
    const sorter = (inputOptions) => {
      const sortedOptions = [...inputOptions].sort((a2, b) => filterSort(a2, b, {
        searchValue: mergedSearchValue
      }));
      return sortedOptions.map((item) => {
        if (Array.isArray(item.options)) {
          return {
            ...item,
            options: item.options.length > 0 ? sorter(item.options) : item.options
          };
        }
        return item;
      });
    };
    const orderedFilteredOptions = reactExports.useMemo(() => {
      if (!filterSort) {
        return filledSearchOptions;
      }
      return sorter(filledSearchOptions);
    }, [filledSearchOptions, filterSort, mergedSearchValue]);
    const displayOptions = reactExports.useMemo(() => flattenOptions(orderedFilteredOptions, {
      fieldNames: mergedFieldNames,
      childrenAsData
    }), [orderedFilteredOptions, mergedFieldNames, childrenAsData]);
    const triggerChange = (values) => {
      const labeledValues = convert2LabelValues(values);
      setInternalValue(labeledValues);
      if (onChange &&
(labeledValues.length !== mergedValues.length || labeledValues.some((newVal, index) => mergedValues[index]?.value !== newVal?.value))) {
        const returnValues = labelInValue ? labeledValues.map(({
          label: l2,
          value: v
        }) => ({
          label: l2,
          value: v
        })) : labeledValues.map((v) => v.value);
        const returnOptions = labeledValues.map((v) => injectPropsWithOption(getMixedOption(v.value)));
        onChange(
multiple ? returnValues : returnValues[0],
multiple ? returnOptions : returnOptions[0]
        );
      }
    };
    const [activeValue, setActiveValue] = reactExports.useState(null);
    const [accessibilityIndex, setAccessibilityIndex] = reactExports.useState(0);
    const mergedDefaultActiveFirstOption = defaultActiveFirstOption !== void 0 ? defaultActiveFirstOption : mode !== "combobox";
    const activeEventRef = reactExports.useRef();
    const onActiveValue = reactExports.useCallback((active, index, {
      source = "keyboard"
    } = {}) => {
      setAccessibilityIndex(index);
      if (backfill && mode === "combobox" && active !== null && source === "keyboard") {
        setActiveValue(String(active));
      }
      const promise = Promise.resolve().then(() => {
        if (activeEventRef.current === promise) {
          onActive?.(active);
        }
      });
      activeEventRef.current = promise;
    }, [backfill, mode, onActive]);
    const triggerSelect = (val, selected, type4) => {
      const getSelectEnt = () => {
        const option = getMixedOption(val);
        return [labelInValue ? {
          label: option?.[mergedFieldNames.label],
          value: val
        } : val, injectPropsWithOption(option)];
      };
      if (selected && onSelect) {
        const [wrappedValue, option] = getSelectEnt();
        onSelect(wrappedValue, option);
      } else if (!selected && onDeselect && type4 !== "clear") {
        const [wrappedValue, option] = getSelectEnt();
        onDeselect(wrappedValue, option);
      }
    };
    const onInternalSelect = useRefFunc((val, info) => {
      let cloneValues;
      const mergedSelect = multiple ? info.selected : true;
      if (mergedSelect) {
        cloneValues = multiple ? [...mergedValues, val] : [val];
      } else {
        cloneValues = mergedValues.filter((v) => v.value !== val);
      }
      triggerChange(cloneValues);
      triggerSelect(val, mergedSelect);
      if (mode === "combobox") {
        setActiveValue("");
      } else if (!isMultiple || autoClearSearchValue) {
        setSearchValue("");
        setActiveValue("");
      }
    });
    const onDisplayValuesChange = (nextValues, info) => {
      triggerChange(nextValues);
      const {
        type: type4,
        values
      } = info;
      if (type4 === "remove" || type4 === "clear") {
        values.forEach((item) => {
          triggerSelect(item.value, false, type4);
        });
      }
    };
    const onInternalSearch = (searchText, info) => {
      setSearchValue(searchText);
      setActiveValue(null);
      if (info.source === "submit") {
        const formatted = (searchText || "").trim();
        if (formatted) {
          const newRawValues = Array.from( new Set([...rawValues, formatted]));
          triggerChange(newRawValues);
          triggerSelect(formatted, true);
          setSearchValue("");
        }
        return;
      }
      if (info.source !== "blur") {
        if (mode === "combobox") {
          triggerChange(searchText);
        }
        onSearch?.(searchText);
      }
    };
    const onInternalSearchSplit = (words2) => {
      let patchValues = words2;
      if (mode !== "tags") {
        patchValues = words2.map((word) => {
          const opt = labelOptions.get(word);
          return opt?.value;
        }).filter((val) => val !== void 0);
      }
      const newRawValues = Array.from( new Set([...rawValues, ...patchValues]));
      triggerChange(newRawValues);
      newRawValues.forEach((newRawValue) => {
        triggerSelect(newRawValue, true);
      });
    };
    const selectContext = reactExports.useMemo(() => {
      const realVirtual = virtual !== false && popupMatchSelectWidth !== false;
      return {
        ...parsedOptions,
        flattenOptions: displayOptions,
        onActiveValue,
        defaultActiveFirstOption: mergedDefaultActiveFirstOption,
        onSelect: onInternalSelect,
        menuItemSelectedIcon,
        rawValues,
        fieldNames: mergedFieldNames,
        virtual: realVirtual,
        direction,
        listHeight,
        listItemHeight,
        childrenAsData,
        maxCount,
        optionRender,
        classNames,
        styles
      };
    }, [maxCount, parsedOptions, displayOptions, onActiveValue, mergedDefaultActiveFirstOption, onInternalSelect, menuItemSelectedIcon, rawValues, mergedFieldNames, virtual, popupMatchSelectWidth, direction, listHeight, listItemHeight, childrenAsData, optionRender, classNames, styles]);
    return reactExports.createElement(SelectContext.Provider, {
      value: selectContext
    }, reactExports.createElement(BaseSelect, _extends$D({}, restProps, {
id: mergedId,
      prefixCls,
      ref: ref2,
      omitDomProps: OMIT_DOM_PROPS,
      mode,
      classNames,
      styles,
      displayValues,
      onDisplayValuesChange,
      maxCount,
      direction,
      showSearch: mergedShowSearch,
      searchValue: mergedSearchValue,
      onSearch: onInternalSearch,
      autoClearSearchValue,
      onSearchSplit: onInternalSearchSplit,
      popupMatchSelectWidth,
      OptionList: RefOptionList,
      emptyOptions: !displayOptions.length,
      activeValue,
      activeDescendantId: `${mergedId}_list_${accessibilityIndex}`
    })));
  });
  const TypedSelect = Select$1;
  TypedSelect.Option = Option;
  TypedSelect.OptGroup = OptGroup;
  const getStatusClassNames = (prefixCls, status, hasFeedback) => {
    return clsx({
      [`${prefixCls}-status-success`]: status === "success",
      [`${prefixCls}-status-warning`]: status === "warning",
      [`${prefixCls}-status-error`]: status === "error",
      [`${prefixCls}-status-validating`]: status === "validating",
      [`${prefixCls}-has-feedback`]: hasFeedback
    });
  };
  const getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;
  const Empty$1 = () => {
    const [, token2] = useToken$1();
    const [locale2] = useLocale("Empty");
    const bgColor = new FastColor(token2.colorBgBase);
    const themeStyle = bgColor.toHsl().l < 0.5 ? {
      opacity: 0.65
    } : {};
    return reactExports.createElement("svg", {
      style: themeStyle,
      width: "184",
      height: "152",
      viewBox: "0 0 184 152",
      xmlns: "http://www.w3.org/2000/svg"
    }, reactExports.createElement("title", null, locale2?.description || "Empty"), reactExports.createElement("g", {
      fill: "none",
      fillRule: "evenodd"
    }, reactExports.createElement("g", {
      transform: "translate(24 31.7)"
    }, reactExports.createElement("ellipse", {
      fillOpacity: ".8",
      fill: "#F5F5F7",
      cx: "67.8",
      cy: "106.9",
      rx: "67.8",
      ry: "12.7"
    }), reactExports.createElement("path", {
      fill: "#aeb8c2",
      d: "M122 69.7 98.1 40.2a6 6 0 0 0-4.6-2.2H42.1a6 6 0 0 0-4.6 2.2l-24 29.5V85H122z"
    }), reactExports.createElement("path", {
      fill: "#f5f5f7",
      d: "M33.8 0h68a4 4 0 0 1 4 4v93.3a4 4 0 0 1-4 4h-68a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4"
    }), reactExports.createElement("path", {
      fill: "#dce0e6",
      d: "M42.7 10h50.2a2 2 0 0 1 2 2v25a2 2 0 0 1-2 2H42.7a2 2 0 0 1-2-2V12a2 2 0 0 1 2-2m.2 39.8h49.8a2.3 2.3 0 1 1 0 4.5H42.9a2.3 2.3 0 0 1 0-4.5m0 11.7h49.8a2.3 2.3 0 1 1 0 4.6H42.9a2.3 2.3 0 0 1 0-4.6m79 43.5a7 7 0 0 1-6.8 5.4H20.5a7 7 0 0 1-6.7-5.4l-.2-1.8V69.7h26.3c2.9 0 5.2 2.4 5.2 5.4s2.4 5.4 5.3 5.4h34.8c2.9 0 5.3-2.4 5.3-5.4s2.3-5.4 5.2-5.4H122v33.5q0 1-.2 1.8"
    })), reactExports.createElement("path", {
      fill: "#dce0e6",
      d: "m149.1 33.3-6.8 2.6a1 1 0 0 1-1.3-1.2l2-6.2q-4.1-4.5-4.2-10.4c0-10 10.1-18.1 22.6-18.1S184 8.1 184 18.1s-10.1 18-22.6 18q-6.8 0-12.3-2.8"
    }), reactExports.createElement("g", {
      fill: "#fff",
      transform: "translate(149.7 15.4)"
    }, reactExports.createElement("circle", {
      cx: "20.7",
      cy: "3.2",
      r: "2.8"
    }), reactExports.createElement("path", {
      d: "M5.7 5.6H0L2.9.7zM9.3.7h5v5h-5z"
    }))));
  };
  const Simple = () => {
    const [, token2] = useToken$1();
    const [locale2] = useLocale("Empty");
    const {
      colorFill,
      colorFillTertiary,
      colorFillQuaternary,
      colorBgContainer
    } = token2;
    const {
      borderColor,
      shadowColor,
      contentColor
    } = reactExports.useMemo(() => ({
      borderColor: new FastColor(colorFill).onBackground(colorBgContainer).toHexString(),
      shadowColor: new FastColor(colorFillTertiary).onBackground(colorBgContainer).toHexString(),
      contentColor: new FastColor(colorFillQuaternary).onBackground(colorBgContainer).toHexString()
    }), [colorFill, colorFillTertiary, colorFillQuaternary, colorBgContainer]);
    return reactExports.createElement("svg", {
      width: "64",
      height: "41",
      viewBox: "0 0 64 41",
      xmlns: "http://www.w3.org/2000/svg"
    }, reactExports.createElement("title", null, locale2?.description || "Empty"), reactExports.createElement("g", {
      transform: "translate(0 1)",
      fill: "none",
      fillRule: "evenodd"
    }, reactExports.createElement("ellipse", {
      fill: shadowColor,
      cx: "32",
      cy: "33",
      rx: "32",
      ry: "7"
    }), reactExports.createElement("g", {
      fillRule: "nonzero",
      stroke: borderColor
    }, reactExports.createElement("path", {
      d: "M55 12.8 44.9 1.3Q44 0 42.9 0H21.1q-1.2 0-2 1.3L9 12.8V22h46z"
    }), reactExports.createElement("path", {
      d: "M41.6 16c0-1.7 1-3 2.2-3H55v18.1c0 2.2-1.3 3.9-3 3.9H12c-1.7 0-3-1.7-3-3.9V13h11.2c1.2 0 2.2 1.3 2.2 3s1 2.9 2.2 2.9h14.8c1.2 0 2.2-1.4 2.2-3",
      fill: contentColor
    }))));
  };
  const genSharedEmptyStyle = (token2) => {
    const {
      componentCls,
      margin,
      marginXS,
      marginXL,
      fontSize,
      lineHeight
    } = token2;
    return {
      [componentCls]: {
        marginInline: marginXS,
        fontSize,
        lineHeight,
        textAlign: "center",
[`${componentCls}-image`]: {
          height: token2.emptyImgHeight,
          marginBottom: marginXS,
          opacity: token2.opacityImage,
          img: {
            height: "100%"
          },
          svg: {
            maxWidth: "100%",
            height: "100%",
            margin: "auto"
          }
        },
        [`${componentCls}-description`]: {
          color: token2.colorTextDescription
        },
[`${componentCls}-footer`]: {
          marginTop: margin
        },
        "&-normal": {
          marginBlock: marginXL,
          color: token2.colorTextDescription,
          [`${componentCls}-description`]: {
            color: token2.colorTextDescription
          },
          [`${componentCls}-image`]: {
            height: token2.emptyImgHeightMD
          }
        },
        "&-small": {
          marginBlock: marginXS,
          color: token2.colorTextDescription,
          [`${componentCls}-image`]: {
            height: token2.emptyImgHeightSM
          }
        }
      }
    };
  };
  const useStyle$v = genStyleHooks("Empty", (token2) => {
    const {
      componentCls,
      controlHeightLG,
      calc
    } = token2;
    const emptyToken = merge$1(token2, {
      emptyImgCls: `${componentCls}-img`,
      emptyImgHeight: calc(controlHeightLG).mul(2.5).equal(),
      emptyImgHeightMD: controlHeightLG,
      emptyImgHeightSM: calc(controlHeightLG).mul(0.875).equal()
    });
    return genSharedEmptyStyle(emptyToken);
  });
  const defaultEmptyImg = reactExports.createElement(Empty$1, null);
  const simpleEmptyImg = reactExports.createElement(Simple, null);
  const Empty = (props) => {
    const {
      className,
      rootClassName,
      prefixCls: customizePrefixCls,
      image,
      description,
      children,
      imageStyle,
      style: style2,
      classNames,
      styles,
      ...restProps
    } = props;
    const {
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles,
      image: contextImage
    } = useComponentConfig("empty");
    const prefixCls = getPrefixCls("empty", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$v(prefixCls);
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props
    });
    const [locale2] = useLocale("Empty");
    const des = typeof description !== "undefined" ? description : locale2?.description;
    const alt = typeof des === "string" ? des : "empty";
    const mergedImage = image ?? contextImage ?? defaultEmptyImg;
    let imageNode = null;
    if (typeof mergedImage === "string") {
      imageNode = reactExports.createElement("img", {
        draggable: false,
        alt,
        src: mergedImage
      });
    } else {
      imageNode = mergedImage;
    }
    return reactExports.createElement("div", {
      className: clsx(hashId, cssVarCls, prefixCls, contextClassName, {
        [`${prefixCls}-normal`]: mergedImage === simpleEmptyImg,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, mergedClassNames.root),
      style: {
        ...mergedStyles.root,
        ...contextStyle,
        ...style2
      },
      ...restProps
    }, reactExports.createElement("div", {
      className: clsx(`${prefixCls}-image`, mergedClassNames.image),
      style: {
        ...imageStyle,
        ...mergedStyles.image
      }
    }, imageNode), des && reactExports.createElement("div", {
      className: clsx(`${prefixCls}-description`, mergedClassNames.description),
      style: mergedStyles.description
    }, des), children && reactExports.createElement("div", {
      className: clsx(`${prefixCls}-footer`, mergedClassNames.footer),
      style: mergedStyles.footer
    }, children));
  };
  Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
  Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
  const DefaultRenderEmpty = (props) => {
    const {
      componentName
    } = props;
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const prefix2 = getPrefixCls("empty");
    switch (componentName) {
      case "Table":
      case "List":
        return React.createElement(Empty, {
          image: Empty.PRESENTED_IMAGE_SIMPLE
        });
      case "Select":
      case "TreeSelect":
      case "Cascader":
      case "Transfer":
      case "Mentions":
        return React.createElement(Empty, {
          image: Empty.PRESENTED_IMAGE_SIMPLE,
          className: `${prefix2}-small`
        });
case "Table.filter":
        return null;
      default:
        return React.createElement(Empty, null);
    }
  };
  const useVariant = (component, variant, legacyBordered) => {
    const {
      variant: configVariant,
      [component]: componentConfig
    } = reactExports.useContext(ConfigContext);
    const ctxVariant = reactExports.useContext(VariantContext);
    const configComponentVariant = componentConfig?.variant;
    let mergedVariant;
    if (typeof variant !== "undefined") {
      mergedVariant = variant;
    } else if (legacyBordered === false) {
      mergedVariant = "borderless";
    } else {
      mergedVariant = ctxVariant ?? configComponentVariant ?? configVariant ?? "outlined";
    }
    const enableVariantCls = Variants.includes(mergedVariant);
    return [mergedVariant, enableVariantCls];
  };
  const getBuiltInPlacements = (popupOverflow) => {
    const htmlRegion = popupOverflow === "scroll" ? "scroll" : "visible";
    const sharedConfig = {
      overflow: {
        adjustX: true,
        adjustY: true,
        shiftY: true
      },
      htmlRegion,
      dynamicInset: true
    };
    return {
      bottomLeft: {
        ...sharedConfig,
        points: ["tl", "bl"],
        offset: [0, 4]
      },
      bottomRight: {
        ...sharedConfig,
        points: ["tr", "br"],
        offset: [0, 4]
      },
      topLeft: {
        ...sharedConfig,
        points: ["bl", "tl"],
        offset: [0, -4]
      },
      topRight: {
        ...sharedConfig,
        points: ["br", "tr"],
        offset: [0, -4]
      }
    };
  };
  function mergedBuiltinPlacements(buildInPlacements, popupOverflow) {
    return buildInPlacements || getBuiltInPlacements(popupOverflow);
  }
  const genItemStyle = (token2) => {
    const {
      optionHeight,
      optionFontSize,
      optionLineHeight,
      optionPadding
    } = token2;
    return {
      position: "relative",
      display: "block",
      minHeight: optionHeight,
      padding: optionPadding,
      color: token2.colorText,
      fontWeight: "normal",
      fontSize: optionFontSize,
      lineHeight: optionLineHeight,
      boxSizing: "border-box"
    };
  };
  const genSingleStyle = (token2) => {
    const {
      antCls,
      componentCls
    } = token2;
    const selectItemCls = `${componentCls}-item`;
    const slideUpEnterActive = `&${antCls}-slide-up-enter${antCls}-slide-up-enter-active`;
    const slideUpAppearActive = `&${antCls}-slide-up-appear${antCls}-slide-up-appear-active`;
    const slideUpLeaveActive = `&${antCls}-slide-up-leave${antCls}-slide-up-leave-active`;
    const dropdownPlacementCls = `${componentCls}-dropdown-placement-`;
    const selectedItemCls = `${selectItemCls}-option-selected`;
    return [
      {
        [`${componentCls}-dropdown`]: {
...resetComponent(token2),
          position: "absolute",
          top: -9999,
          zIndex: token2.zIndexPopup,
          boxSizing: "border-box",
          padding: token2.paddingXXS,
          overflow: "hidden",
          fontSize: token2.fontSize,


fontVariant: "initial",
          backgroundColor: token2.colorBgElevated,
          borderRadius: token2.borderRadiusLG,
          outline: "none",
          boxShadow: token2.boxShadowSecondary,
          [`
          ${slideUpEnterActive}${dropdownPlacementCls}bottomLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}bottomLeft
        `]: {
            animationName: slideUpIn
          },
          [`
          ${slideUpEnterActive}${dropdownPlacementCls}topLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}topLeft,
          ${slideUpEnterActive}${dropdownPlacementCls}topRight,
          ${slideUpAppearActive}${dropdownPlacementCls}topRight
        `]: {
            animationName: slideDownIn
          },
          [`${slideUpLeaveActive}${dropdownPlacementCls}bottomLeft`]: {
            animationName: slideUpOut
          },
          [`
          ${slideUpLeaveActive}${dropdownPlacementCls}topLeft,
          ${slideUpLeaveActive}${dropdownPlacementCls}topRight
        `]: {
            animationName: slideDownOut
          },
          "&-hidden": {
            display: "none"
          },
          [selectItemCls]: {
            ...genItemStyle(token2),
            cursor: "pointer",
            transition: `background-color ${token2.motionDurationSlow} ease`,
            borderRadius: token2.borderRadiusSM,
"&-group": {
              color: token2.colorTextDescription,
              fontSize: token2.fontSizeSM,
              cursor: "default"
            },
"&-option": {
              display: "flex",
              "&-content": {
                flex: "auto",
                ...textEllipsis
              },
              "&-state": {
                flex: "none",
                display: "flex",
                alignItems: "center"
              },
              [`&-active:not(${selectItemCls}-option-disabled)`]: {
                backgroundColor: token2.optionActiveBg
              },
              [`&-selected:not(${selectItemCls}-option-disabled)`]: {
                color: token2.optionSelectedColor,
                fontWeight: token2.optionSelectedFontWeight,
                backgroundColor: token2.optionSelectedBg,
                [`${selectItemCls}-option-state`]: {
                  color: token2.colorPrimary
                }
              },
              "&-disabled": {
                [`&${selectItemCls}-option-selected`]: {
                  backgroundColor: token2.colorBgContainerDisabled
                },
                color: token2.colorTextDisabled,
                cursor: "not-allowed"
              },
              "&-grouped": {
                paddingInlineStart: token2.calc(token2.controlPaddingHorizontal).mul(2).equal()
              }
            },
            "&-empty": {
              ...genItemStyle(token2),
              color: token2.colorTextDisabled
            }
          },
[`${selectedItemCls}:has(+ ${selectedItemCls})`]: {
            borderEndStartRadius: 0,
            borderEndEndRadius: 0,
            [`& + ${selectedItemCls}`]: {
              borderStartStartRadius: 0,
              borderStartEndRadius: 0
            }
          },
"&-rtl": {
            direction: "rtl"
          }
        }
      },
initSlideMotion(token2, "slide-up"),
      initSlideMotion(token2, "slide-down"),
      initMoveMotion(token2, "move-up"),
      initMoveMotion(token2, "move-down")
    ];
  };
  const genSelectInputCustomizeStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`&${componentCls}-customize`]: {
        border: 0,
        padding: 0,
        fontSize: "inherit",
        lineHeight: "inherit",
        [`${componentCls}-placeholder`]: {
          display: "none"
        },
        [`${componentCls}-content`]: {
          margin: 0,
          padding: 0,
          "&-value": {
            display: "none"
          }
        }
      }
    };
  };
  const FIXED_INPUT_MIN_WIDTH = 4;
  const genSelectInputMultipleStyle = (token2) => {
    const {
      componentCls,
      calc,
      iconCls,
      paddingXS,
      paddingXXS,
      INTERNAL_FIXED_ITEM_MARGIN,
      lineWidth,
      colorIcon,
      colorIconHover,
      inputPaddingHorizontalBase,
      antCls
    } = token2;
    const [varName, varRef] = genCssVar(antCls, "select");
    return {
      "&-multiple": {
        [varName("multi-item-background")]: token2.multipleItemBg,
        [varName("multi-item-border-color")]: "transparent",
        [varName("multi-item-border-radius")]: token2.borderRadiusSM,
        [varName("multi-item-height")]: token2.multipleItemHeight,
        [varName("multi-padding-base")]: `calc((${varRef("height")} - ${varRef("multi-item-height")}) / 2)`,
        [varName("multi-padding-vertical")]: `calc(${varRef("multi-padding-base")} - ${INTERNAL_FIXED_ITEM_MARGIN} - ${lineWidth})`,
        [varName("multi-item-padding-horizontal")]: `calc(${inputPaddingHorizontalBase} - ${varRef("multi-padding-vertical")} - ${lineWidth} * 2)`,



paddingBlock: varRef("multi-padding-vertical"),
        paddingInlineStart: `calc(${varRef("multi-padding-base")} - ${lineWidth})`,
[`${componentCls}-prefix`]: {
          marginInlineStart: varRef("multi-item-padding-horizontal")
        },
        [`${componentCls}-prefix + ${componentCls}-content`]: {
          [`${componentCls}-placeholder`]: {
            insetInlineStart: 0
          },
          [`${componentCls}-content-item${componentCls}-content-item-suffix`]: {
            marginInlineStart: 0
          }
        },
[`${componentCls}-placeholder`]: {
          position: "absolute",
          lineHeight: varRef("line-height"),
          insetInlineStart: varRef("multi-item-padding-horizontal"),
          width: `calc(100% - ${varRef("multi-item-padding-horizontal")})`,
          top: "50%",
          transform: "translateY(-50%)"
        },
[`${componentCls}-content`]: {
          flexWrap: "wrap",
          alignItems: "center",
          lineHeight: 1,
          "&-item-prefix": {
            height: varRef("font-size")
          },
          "&-item": {
            lineHeight: 1,
            maxWidth: `calc(100% - ${FIXED_INPUT_MIN_WIDTH}px)`
          },
          [`${componentCls}-content-item-prefix + ${componentCls}-content-item-suffix,
          ${componentCls}-content-item-suffix:first-child`]: {
            marginInlineStart: varRef("multi-item-padding-horizontal")
          },
          [`${componentCls}-selection-item`]: {
            lineHeight: `calc(${varRef("multi-item-height")} - ${lineWidth} * 2)`,
            border: `${lineWidth} solid ${varRef("multi-item-border-color")}`,
            display: "flex",
            marginBlock: INTERNAL_FIXED_ITEM_MARGIN,
            marginInlineEnd: calc(INTERNAL_FIXED_ITEM_MARGIN).mul(2).equal(),
            background: varRef("multi-item-background"),
            borderRadius: varRef("multi-item-border-radius"),
            paddingInlineStart: paddingXS,
            paddingInlineEnd: paddingXXS,
            transition: ["height", "line-height", "padding"].map((key) => `${key} ${token2.motionDurationSlow}`).join(","),
"&-content": {
              ...textEllipsis,
              marginInlineEnd: paddingXXS
            },
"&-remove": {
              ...resetIcon(),
              display: "inline-flex",
              alignItems: "center",
              color: colorIcon,
              fontWeight: "bold",
              fontSize: 10,
              lineHeight: "inherit",
              cursor: "pointer",
              [`> ${iconCls}`]: {
                verticalAlign: "-0.2em"
              },
              "&:hover": {
                color: colorIconHover
              }
            }
          },
          [`${componentCls}-input`]: {
            lineHeight: calc(INTERNAL_FIXED_ITEM_MARGIN).mul(2).add(varRef("multi-item-height")).equal(),
            width: `calc(var(--select-input-width, 0) * 1px)`,
            minWidth: FIXED_INPUT_MIN_WIDTH,
            maxWidth: "100%",
            transition: `line-height ${token2.motionDurationSlow}`
          }
        },


[`&${componentCls}-sm`]: {
          [varName("multi-item-height")]: token2.multipleItemHeightSM,
          [varName("multi-item-border-radius")]: token2.borderRadiusXS
        },
        [`&${componentCls}-lg`]: {
          [varName("multi-item-height")]: token2.multipleItemHeightLG,
          [varName("multi-item-border-radius")]: token2.borderRadius
        },


[`&${componentCls}-filled`]: {
          [varName("multi-item-border-color")]: token2.colorSplit,
          [varName("multi-item-background")]: token2.colorBgContainer,
          [`&${componentCls}-disabled`]: {
            [varName("multi-item-border-color")]: "transparent"
          }
        }
      }
    };
  };
  const genSelectInputVariableStyle = (token2, colors2) => {
    const {
      componentCls,
      antCls
    } = token2;
    const [varName] = genCssVar(antCls, "select");
    const {
      border,
      borderHover,
      borderActive,
      borderOutline
    } = colors2;
    const baseBG = colors2.background || token2.selectorBg || token2.colorBgContainer;
    return {
      [varName("border-color")]: border,
      [varName("background-color")]: baseBG,
      [varName("color")]: colors2.color || token2.colorText,
      [`&:not(${componentCls}-disabled)`]: {
        "&:hover": {
          [varName("border-color")]: borderHover,
          [varName("background-color")]: colors2.backgroundHover || baseBG
        },
        [`&${componentCls}-focused`]: {
          [varName("border-color")]: borderActive,
          [varName("background-color")]: colors2.backgroundActive || baseBG,
          boxShadow: `0 0 0 ${unit$1(token2.controlOutlineWidth)} ${borderOutline}`
        }
      },
      [`&${componentCls}-disabled`]: {
        [varName("border-color")]: colors2.borderDisabled || colors2.border,
        [varName("background-color")]: colors2.backgroundDisabled || colors2.background
      }
    };
  };
  const genSelectInputVariantStyle = (token2, variant, colors2, errorColors = {}, warningColors = {}, patchStyle) => {
    const {
      componentCls
    } = token2;
    return {
      [`&${componentCls}-${variant}`]: [genSelectInputVariableStyle(token2, colors2), {
        [`&${componentCls}-status-error`]: genSelectInputVariableStyle(token2, {
          ...colors2,
          color: errorColors.color || token2.colorError,
          ...errorColors
        }),
        [`&${componentCls}-status-warning`]: genSelectInputVariableStyle(token2, {
          ...colors2,
          color: warningColors.color || token2.colorWarning,
          ...warningColors
        })
      }, patchStyle]
    };
  };
  const genSelectInputStyle = (token2) => {
    const {
      componentCls,
      fontHeight,
      controlHeight,
      iconCls,
      antCls,
      calc
    } = token2;
    const [varName, varRef] = genCssVar(antCls, "select");
    return {
      [componentCls]: [
        {
[varName("border-radius")]: token2.borderRadius,
          [varName("border-color")]: "#000",
          [varName("border-size")]: token2.lineWidth,
[varName("background-color")]: token2.colorBgContainer,
[varName("font-size")]: token2.fontSize,
          [varName("line-height")]: token2.lineHeight,
          [varName("font-height")]: fontHeight,
          [varName("color")]: token2.colorText,
[varName("height")]: controlHeight,
          [varName("padding-horizontal")]: calc(token2.paddingSM).sub(token2.lineWidth).equal(),
          [varName("padding-vertical")]: `calc((${varRef("height")} - ${varRef("font-height")}) / 2 - ${varRef("border-size")})`,


...resetComponent(token2, true),
          display: "inline-flex",
flexWrap: "nowrap",
          position: "relative",
          transition: `all ${token2.motionDurationSlow}`,
          alignItems: "flex-start",
          outline: 0,
          cursor: "pointer",
borderRadius: varRef("border-radius"),
          borderWidth: varRef("border-size"),
          borderStyle: token2.lineType,
          borderColor: varRef("border-color"),
background: varRef("background-color"),
fontSize: varRef("font-size"),
          lineHeight: varRef("line-height"),
          color: varRef("color"),
paddingInline: varRef("padding-horizontal"),
          paddingBlock: varRef("padding-vertical"),
[`${componentCls}-prefix`]: {
            flex: "none",
            lineHeight: 1
          },
[`${componentCls}-placeholder`]: {
            ...textEllipsis,
            color: token2.colorTextPlaceholder,
            pointerEvents: "none",
            zIndex: 1
          },
[`${componentCls}-content`]: {
            flex: "auto",
            minWidth: 0,
            position: "relative",
            display: "flex",
            marginInlineEnd: calc(token2.paddingXXS).mul(1.5).equal(),
            "&:before": {
              content: '"\\a0"',
              width: 0,
              overflow: "hidden"
            },

"input[readonly]": {
              cursor: "inherit",
              caretColor: "transparent"
            }
          },
[`${componentCls}-suffix`]: {
            flex: "none",
            color: token2.colorTextQuaternary,
            fontSize: token2.fontSizeIcon,
            lineHeight: 1,
            "> :not(:last-child)": {
              marginInlineEnd: token2.marginXS
            }
          },
          [`${componentCls}-prefix, ${componentCls}-suffix`]: {
            alignSelf: "center",
            [iconCls]: {
              verticalAlign: "top"
            }
          },


"&-disabled": {
            background: token2.colorBgContainerDisabled,
            color: token2.colorTextDisabled,
            cursor: "not-allowed",
            input: {
              cursor: "not-allowed"
            }
          },


"&-sm": {
            [varName("height")]: token2.controlHeightSM,
            [varName("padding-horizontal")]: calc(token2.paddingXS).sub(token2.lineWidth).equal(),
            [varName("border-radius")]: token2.borderRadiusSM,
            [`${componentCls}-clear`]: {
              insetInlineEnd: varRef("padding-horizontal")
            }
          },
          "&-lg": {
            [varName("height")]: token2.controlHeightLG,
            [varName("font-size")]: token2.fontSizeLG,
            [varName("line-height")]: token2.lineHeightLG,
            [varName("font-height")]: token2.fontHeightLG,
            [varName("border-radius")]: token2.borderRadiusLG
          }
        },


{
          [`&:not(${componentCls}-customize)`]: {
            [`${componentCls}-input`]: {
              outline: "none",
              background: "transparent",
              appearance: "none",
              border: 0,
              margin: 0,
              padding: 0,
              color: varRef("color"),
              "&::-webkit-search-cancel-button": {
                display: "none",
                appearance: "none"
              }
            }
          }
        },


{
          [`&-single:not(${componentCls}-customize)`]: {
            [`${componentCls}-input`]: {
              position: "absolute",
              insetInline: 0,
              insetBlock: `calc(${varRef("padding-vertical")} * -1)`,
              lineHeight: `calc(${varRef("font-height")} + ${varRef("padding-vertical")} * 2)`
            },
[`${componentCls}-content`]: {
              ...textEllipsis,
              alignSelf: "center",
              "&-has-value": {
                display: "block",
                "&:before": {
                  display: "none"
                }
              },
              "&-has-search-value": {
                color: "transparent"
              },
"&-value": {
                transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
                zIndex: 1
              }
            },
            [`&${componentCls}-open ${componentCls}-content`]: {
              color: token2.colorTextPlaceholder,
              "&-has-search-value": {
                color: "transparent"
              }
            }
          }
        },
{
          [`&-show-search:not(${componentCls}-customize-input):not(${componentCls}-disabled)`]: {
            cursor: "text"
          }
        },


genSelectInputMultipleStyle(token2),

genSelectInputVariantStyle(
          token2,
          "outlined",
          {
            border: token2.colorBorder,
            borderHover: token2.hoverBorderColor,
            borderActive: token2.activeBorderColor,
            borderOutline: token2.activeOutlineColor,
            borderDisabled: token2.colorBorderDisabled
          },
{
            border: token2.colorError,
            borderHover: token2.colorErrorHover,
            borderActive: token2.colorError,
            borderOutline: token2.colorErrorOutline
          },
{
            border: token2.colorWarning,
            borderHover: token2.colorWarningHover,
            borderActive: token2.colorWarning,
            borderOutline: token2.colorWarningOutline
          }
        ),
genSelectInputVariantStyle(
          token2,
          "filled",
          {
            border: "transparent",
            borderHover: "transparent",
            borderActive: token2.activeBorderColor,
            borderOutline: "transparent",
            borderDisabled: token2.colorBorderDisabled,
            background: token2.colorFillTertiary,
            backgroundHover: token2.colorFillSecondary,
            backgroundActive: token2.colorBgContainer
          },
{
            background: token2.colorErrorBg,
            backgroundHover: token2.colorErrorBgHover,
            borderActive: token2.colorError
          },
{
            background: token2.colorWarningBg,
            backgroundHover: token2.colorWarningBgHover,
            borderActive: token2.colorWarning
          }
        ),
genSelectInputVariantStyle(token2, "borderless", {
          border: "transparent",
          borderHover: "transparent",
          borderActive: "transparent",
          borderOutline: "transparent",
          background: "transparent"
        }),
genSelectInputVariantStyle(
          token2,
          "underlined",
          {
            border: token2.colorBorder,
            borderHover: token2.hoverBorderColor,
            borderActive: token2.activeBorderColor,
            borderOutline: "transparent"
          },
{
            border: token2.colorError,
            borderHover: token2.colorErrorHover,
            borderActive: token2.colorError
          },
{
            border: token2.colorWarning,
            borderHover: token2.colorWarningHover,
            borderActive: token2.colorWarning
          },
          {
            borderRadius: 0,
            borderTopColor: "transparent",
            borderRightColor: "transparent",
            borderLeftColor: "transparent"
          }
        ),


genSelectInputCustomizeStyle(token2)
      ]
    };
  };
  const prepareComponentToken$l = (token2) => {
    const {
      fontSize,
      lineHeight,
      lineWidth,
      controlHeight,
      controlHeightSM,
      controlHeightLG,
      paddingXXS,
      controlPaddingHorizontal,
      zIndexPopupBase,
      colorText,
      fontWeightStrong,
      controlItemBgActive,
      controlItemBgHover,
      colorBgContainer,
      colorFillSecondary,
      colorBgContainerDisabled,
      colorTextDisabled,
      colorPrimaryHover,
      colorPrimary,
      controlOutline
    } = token2;
    const dblPaddingXXS = paddingXXS * 2;
    const dblLineWidth = lineWidth * 2;
    const multipleItemHeight = Math.min(controlHeight - dblPaddingXXS, controlHeight - dblLineWidth);
    const multipleItemHeightSM = Math.min(controlHeightSM - dblPaddingXXS, controlHeightSM - dblLineWidth);
    const multipleItemHeightLG = Math.min(controlHeightLG - dblPaddingXXS, controlHeightLG - dblLineWidth);
    const INTERNAL_FIXED_ITEM_MARGIN = Math.floor(paddingXXS / 2);
    return {
      INTERNAL_FIXED_ITEM_MARGIN,
      zIndexPopup: zIndexPopupBase + 50,
      optionSelectedColor: colorText,
      optionSelectedFontWeight: fontWeightStrong,
      optionSelectedBg: controlItemBgActive,
      optionActiveBg: controlItemBgHover,
      optionPadding: `${(controlHeight - fontSize * lineHeight) / 2}px ${controlPaddingHorizontal}px`,
      optionFontSize: fontSize,
      optionLineHeight: lineHeight,
      optionHeight: controlHeight,
      selectorBg: colorBgContainer,
      clearBg: colorBgContainer,
      singleItemHeightLG: controlHeightLG,
      multipleItemBg: colorFillSecondary,
      multipleItemBorderColor: "transparent",
      multipleItemHeight,
      multipleItemHeightSM,
      multipleItemHeightLG,
      multipleSelectorBgDisabled: colorBgContainerDisabled,
      multipleItemColorDisabled: colorTextDisabled,
      multipleItemBorderColorDisabled: "transparent",
      showArrowPaddingInlineEnd: Math.ceil(token2.fontSize * 1.25),
      hoverBorderColor: colorPrimaryHover,
      activeBorderColor: colorPrimary,
      activeOutlineColor: controlOutline,
      selectAffixPadding: paddingXXS
    };
  };
  const genBaseStyle$6 = (token2) => {
    const {
      antCls,
      componentCls,
      motionDurationMid,
      inputPaddingHorizontalBase
    } = token2;
    const hoverShowClearStyle = {
      [`${componentCls}-clear`]: {
        opacity: 1,
        background: token2.colorBgBase,
        borderRadius: "50%"
      }
    };
    return {
      [componentCls]: {
        ...resetComponent(token2),
[`${componentCls}-selection-item`]: {
          flex: 1,
          fontWeight: "normal",
          position: "relative",
          userSelect: "none",
          ...textEllipsis,
[`> ${antCls}-typography`]: {
            display: "inline"
          }
        },
[`${componentCls}-prefix`]: {
          flex: "none",
          marginInlineEnd: token2.selectAffixPadding
        },
[`${componentCls}-clear`]: {
          position: "absolute",
          top: "50%",
          insetInlineStart: "auto",
          insetInlineEnd: inputPaddingHorizontalBase,
          zIndex: 1,
          display: "inline-block",
          width: token2.fontSizeIcon,
          height: token2.fontSizeIcon,
          marginTop: token2.calc(token2.fontSizeIcon).mul(-1).div(2).equal(),
          color: token2.colorTextQuaternary,
          fontSize: token2.fontSizeIcon,
          fontStyle: "normal",
          lineHeight: 1,
          textAlign: "center",
          textTransform: "none",
          cursor: "pointer",
          opacity: 0,
          transition: ["color", "opacity"].map((prop) => `${prop} ${motionDurationMid} ease`).join(", "),
          textRendering: "auto",

transform: "translateZ(0)",
          "&:before": {
            display: "block"
          },
          "&:hover": {
            color: token2.colorIcon
          }
        },
        "@media(hover:none)": hoverShowClearStyle,
        "&:hover": hoverShowClearStyle
      },
[`${componentCls}-status`]: {
        "&-error, &-warning, &-success, &-validating": {
          [`&${componentCls}-has-feedback`]: {
            [`${componentCls}-clear`]: {
              insetInlineEnd: token2.calc(inputPaddingHorizontalBase).add(token2.fontSize).add(token2.paddingXS).equal()
            }
          }
        }
      }
    };
  };
  const genSelectStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return [
      {
        [componentCls]: {
[`&${componentCls}-in-form-item`]: {
            width: "100%"
          }
        }
      },



genBaseStyle$6(token2),
genSingleStyle(token2),


{
        [`${componentCls}-rtl`]: {
          direction: "rtl"
        }
      },


genCompactItemStyle(token2, {
        focusElCls: `${componentCls}-focused`
      })
    ];
  };
  const useSelectStyle = genStyleHooks("Select", (token2, {
    rootPrefixCls
  }) => {
    const selectToken = merge$1(token2, {
      rootPrefixCls,
      inputPaddingHorizontalBase: token2.calc(token2.paddingSM).sub(token2.lineWidth).equal(),
      multipleSelectItemHeight: token2.multipleItemHeight,
      selectHeight: token2.controlHeight
    });
    return [genSelectStyle(selectToken), genSelectInputStyle(selectToken)];
  }, prepareComponentToken$l, {
    unitless: {
      optionLineHeight: true,
      optionSelectedFontWeight: true
    }
  });
  var CheckOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, "name": "check", "theme": "outlined" };
  function _extends$C() {
    _extends$C = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$C.apply(this, arguments);
  }
  const CheckOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends$C({}, props, {
    ref: ref2,
    icon: CheckOutlined$1
  }));
  const RefIcon$f = reactExports.forwardRef(CheckOutlined);
  var DownOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, "name": "down", "theme": "outlined" };
  function _extends$B() {
    _extends$B = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$B.apply(this, arguments);
  }
  const DownOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends$B({}, props, {
    ref: ref2,
    icon: DownOutlined$1
  }));
  const RefIcon$e = reactExports.forwardRef(DownOutlined);
  var SearchOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
  function _extends$A() {
    _extends$A = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$A.apply(this, arguments);
  }
  const SearchOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends$A({}, props, {
    ref: ref2,
    icon: SearchOutlined$1
  }));
  const RefIcon$d = reactExports.forwardRef(SearchOutlined);
  function useIcons({
    suffixIcon,
    clearIcon,
    menuItemSelectedIcon,
    removeIcon,
    loading,
    loadingIcon,
    multiple,
    hasFeedback,
    showSuffixIcon,
    feedbackIcon,
    showArrow,
    componentName
  }) {
    const mergedClearIcon = clearIcon ?? reactExports.createElement(RefIcon$l, null);
    const getSuffixIconNode = (arrowIcon) => {
      if (suffixIcon === null && !hasFeedback && !showArrow) {
        return null;
      }
      return reactExports.createElement(reactExports.Fragment, null, showSuffixIcon !== false && arrowIcon, hasFeedback && feedbackIcon);
    };
    let mergedSuffixIcon = null;
    if (suffixIcon !== void 0) {
      mergedSuffixIcon = getSuffixIconNode(suffixIcon);
    } else if (loading) {
      mergedSuffixIcon = getSuffixIconNode(loadingIcon ?? reactExports.createElement(RefIcon$h, {
        spin: true
      }));
    } else {
      mergedSuffixIcon = ({
        open: open2,
        showSearch
      }) => {
        if (open2 && showSearch) {
          return getSuffixIconNode( reactExports.createElement(RefIcon$d, null));
        }
        return getSuffixIconNode( reactExports.createElement(RefIcon$e, null));
      };
    }
    let mergedItemIcon = null;
    if (menuItemSelectedIcon !== void 0) {
      mergedItemIcon = menuItemSelectedIcon;
    } else if (multiple) {
      mergedItemIcon = reactExports.createElement(RefIcon$f, null);
    } else {
      mergedItemIcon = null;
    }
    let mergedRemoveIcon = null;
    if (removeIcon !== void 0) {
      mergedRemoveIcon = removeIcon;
    } else {
      mergedRemoveIcon = reactExports.createElement(RefIcon$k, null);
    }
    return {
clearIcon: mergedClearIcon,
      suffixIcon: mergedSuffixIcon,
      itemIcon: mergedItemIcon,
      removeIcon: mergedRemoveIcon
    };
  }
  function usePopupRender(renderFn) {
    return React.useMemo(() => {
      if (!renderFn) {
        return void 0;
      }
      return (...args) => React.createElement(ContextIsolator, {
        space: true
      }, renderFn.apply(void 0, args));
    }, [renderFn]);
  }
  function useShowArrow(suffixIcon, showArrow) {
    return showArrow !== void 0 ? showArrow : suffixIcon !== null;
  }
  const SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE";
  const InternalSelect = (props, ref2) => {
    const {
      prefixCls: customizePrefixCls,
      bordered,
      className,
      rootClassName,
      getPopupContainer,
      popupClassName,
      dropdownClassName,
      listHeight = 256,
      placement,
      listItemHeight: customListItemHeight,
      size: customizeSize,
      disabled: customDisabled,
      notFoundContent,
      status: customStatus,
      builtinPlacements,
      dropdownMatchSelectWidth,
      popupMatchSelectWidth,
      direction: propDirection,
      style: style2,
      allowClear,
      variant: customizeVariant,
      popupStyle,
      dropdownStyle,
      transitionName,
      tagRender,
      maxCount,
      prefix: prefix2,
      dropdownRender,
popupRender,
      onDropdownVisibleChange,
      onOpenChange,
      styles,
      classNames,
      ...rest
    } = props;
    const {
      getPopupContainer: getContextPopupContainer,
      getPrefixCls,
      renderEmpty,
      direction: contextDirection,
      virtual,
      popupMatchSelectWidth: contextPopupMatchSelectWidth,
      popupOverflow
    } = reactExports.useContext(ConfigContext);
    const {
      showSearch,
      style: contextStyle,
      styles: contextStyles,
      className: contextClassName,
      classNames: contextClassNames
    } = useComponentConfig("select");
    const [, token2] = useToken$1();
    const listItemHeight = customListItemHeight ?? token2?.controlHeight;
    const prefixCls = getPrefixCls("select", customizePrefixCls);
    const rootPrefixCls = getPrefixCls();
    const direction = propDirection ?? contextDirection;
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const [variant, enableVariantCls] = useVariant("select", customizeVariant, bordered);
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useSelectStyle(prefixCls, rootCls);
    const mode = reactExports.useMemo(() => {
      const {
        mode: m2
      } = props;
      if (m2 === "combobox") {
        return void 0;
      }
      if (m2 === SECRET_COMBOBOX_MODE_DO_NOT_USE) {
        return "combobox";
      }
      return m2;
    }, [props.mode]);
    const isMultiple2 = mode === "multiple" || mode === "tags";
    const showSuffixIcon = useShowArrow(props.suffixIcon, props.showArrow);
    const mergedPopupMatchSelectWidth = popupMatchSelectWidth ?? dropdownMatchSelectWidth ?? contextPopupMatchSelectWidth;
    const mergedPopupRender = usePopupRender(popupRender || dropdownRender);
    const mergedOnOpenChange = onOpenChange || onDropdownVisibleChange;
    const {
      status: contextStatus,
      hasFeedback,
      isFormItemInput,
      feedbackIcon
    } = reactExports.useContext(FormItemInputContext);
    const mergedStatus = getMergedStatus(contextStatus, customStatus);
    let mergedNotFound;
    if (notFoundContent !== void 0) {
      mergedNotFound = notFoundContent;
    } else if (mode === "combobox") {
      mergedNotFound = null;
    } else {
      mergedNotFound = renderEmpty?.("Select") || reactExports.createElement(DefaultRenderEmpty, {
        componentName: "Select"
      });
    }
    const {
      suffixIcon,
      itemIcon,
      removeIcon,
      clearIcon
    } = useIcons({
      ...rest,
      multiple: isMultiple2,
      hasFeedback,
      feedbackIcon,
      showSuffixIcon,
      componentName: "Select"
    });
    const mergedAllowClear = allowClear === true ? {
      clearIcon
    } : allowClear;
    const selectProps = omit(rest, ["suffixIcon", "itemIcon"]);
    const mergedSize = useSize((ctx) => customizeSize ?? compactSize ?? ctx);
    const disabled = reactExports.useContext(DisabledContext);
    const mergedDisabled = customDisabled ?? disabled;
    const mergedProps = {
      ...props,
      variant,
      status: mergedStatus,
      disabled: mergedDisabled,
      size: mergedSize
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    }, {
      popup: {
        _default: "root"
      }
    });
    const mergedPopupClassName = clsx(mergedClassNames.popup?.root, popupClassName, dropdownClassName, {
      [`${prefixCls}-dropdown-${direction}`]: direction === "rtl"
    }, rootClassName, cssVarCls, rootCls, hashId);
    const mergedPopupStyle = {
      ...mergedStyles.popup?.root,
      ...popupStyle ?? dropdownStyle
    };
    const mergedClassName = clsx({
      [`${prefixCls}-lg`]: mergedSize === "large",
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-${variant}`]: enableVariantCls,
      [`${prefixCls}-in-form-item`]: isFormItemInput
    }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, contextClassName, className, mergedClassNames.root, rootClassName, cssVarCls, rootCls, hashId);
    const memoPlacement = reactExports.useMemo(() => {
      if (placement !== void 0) {
        return placement;
      }
      return direction === "rtl" ? "bottomRight" : "bottomLeft";
    }, [placement, direction]);
    const [zIndex] = useZIndex("SelectLike", mergedStyles.popup?.root?.zIndex ?? mergedPopupStyle?.zIndex);
    return reactExports.createElement(TypedSelect, {
      ref: ref2,
      virtual,
      classNames: mergedClassNames,
      styles: mergedStyles,
      showSearch,
      ...selectProps,
      style: {
        ...mergedStyles.root,
        ...contextStyle,
        ...style2
      },
      popupMatchSelectWidth: mergedPopupMatchSelectWidth,
      transitionName: getTransitionName(rootPrefixCls, "slide-up", transitionName),
      builtinPlacements: mergedBuiltinPlacements(builtinPlacements, popupOverflow),
      listHeight,
      listItemHeight,
      mode,
      prefixCls,
      placement: memoPlacement,
      direction,
      prefix: prefix2,
      suffixIcon,
      menuItemSelectedIcon: itemIcon,
      removeIcon,
      allowClear: mergedAllowClear,
      notFoundContent: mergedNotFound,
      className: mergedClassName,
      getPopupContainer: getPopupContainer || getContextPopupContainer,
      popupClassName: mergedPopupClassName,
      disabled: mergedDisabled,
      popupStyle: {
        ...mergedStyles.popup?.root,
        ...mergedPopupStyle,
        zIndex
      },
      maxCount: isMultiple2 ? maxCount : void 0,
      tagRender: isMultiple2 ? tagRender : void 0,
      popupRender: mergedPopupRender,
      onPopupVisibleChange: mergedOnOpenChange
    });
  };
  const Select = reactExports.forwardRef(InternalSelect);
  const PurePanel$8 = genPurePanel(Select, "popupAlign");
  Select.SECRET_COMBOBOX_MODE_DO_NOT_USE = SECRET_COMBOBOX_MODE_DO_NOT_USE;
  Select.Option = Option;
  Select.OptGroup = OptGroup;
  Select._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$8;
  const responsiveArray = ["xxxl", "xxl", "xl", "lg", "md", "sm", "xs"];
  const getResponsiveMap = (token2) => ({
    xs: `(max-width: ${token2.screenXSMax}px)`,
    sm: `(min-width: ${token2.screenSM}px)`,
    md: `(min-width: ${token2.screenMD}px)`,
    lg: `(min-width: ${token2.screenLG}px)`,
    xl: `(min-width: ${token2.screenXL}px)`,
    xxl: `(min-width: ${token2.screenXXL}px)`,
    xxxl: `(min-width: ${token2.screenXXXL}px)`
  });
  const validateBreakpoints = (token2) => {
    const indexableToken = token2;
    const revBreakpoints = [].concat(responsiveArray).reverse();
    revBreakpoints.forEach((breakpoint, i2) => {
      const breakpointUpper = breakpoint.toUpperCase();
      const screenMin = `screen${breakpointUpper}Min`;
      const screen = `screen${breakpointUpper}`;
      if (!(indexableToken[screenMin] <= indexableToken[screen])) {
        throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);
      }
      if (i2 < revBreakpoints.length - 1) {
        const screenMax = `screen${breakpointUpper}Max`;
        if (!(indexableToken[screen] <= indexableToken[screenMax])) {
          throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);
        }
        const nextBreakpointUpperMin = revBreakpoints[i2 + 1].toUpperCase();
        const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;
        if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {
          throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);
        }
      }
    });
    return token2;
  };
  const useResponsiveObserver = () => {
    const [, token2] = useToken$1();
    const responsiveMap = getResponsiveMap(validateBreakpoints(token2));
    return React.useMemo(() => {
      const subscribers = new Map();
      let subUid = -1;
      let screens = {};
      return {
        responsiveMap,
        matchHandlers: {},
        dispatch(pointMap) {
          screens = pointMap;
          subscribers.forEach((func) => func(screens));
          return subscribers.size >= 1;
        },
        subscribe(func) {
          if (!subscribers.size) {
            this.register();
          }
          subUid += 1;
          subscribers.set(subUid, func);
          func(screens);
          return subUid;
        },
        unsubscribe(paramToken) {
          subscribers.delete(paramToken);
          if (!subscribers.size) {
            this.unregister();
          }
        },
        register() {
          Object.entries(responsiveMap).forEach(([screen, mediaQuery]) => {
            const listener = ({
              matches
            }) => {
              this.dispatch({
                ...screens,
                [screen]: matches
              });
            };
            const mql = window.matchMedia(mediaQuery);
            if (typeof mql?.addEventListener === "function") {
              mql.addEventListener("change", listener);
            }
            this.matchHandlers[mediaQuery] = {
              mql,
              listener
            };
            listener(mql);
          });
        },
        unregister() {
          Object.values(responsiveMap).forEach((mediaQuery) => {
            const handler = this.matchHandlers[mediaQuery];
            if (typeof handler?.mql?.removeEventListener === "function") {
              handler.mql.removeEventListener("change", handler?.listener);
            }
          });
          subscribers.clear();
        }
      };
    }, [responsiveMap]);
  };
  function useBreakpoint(refreshOnChange = true, defaultScreens = {}) {
    const screensRef = reactExports.useRef(defaultScreens);
    const [, forceUpdate] = useForceUpdate();
    const responsiveObserver = useResponsiveObserver();
    useLayoutEffect(() => {
      const token2 = responsiveObserver.subscribe((supportScreens) => {
        screensRef.current = supportScreens;
        if (refreshOnChange) {
          forceUpdate();
        }
      });
      return () => responsiveObserver.unsubscribe(token2);
    }, []);
    return screensRef.current;
  }
  const AvatarContext = reactExports.createContext({});
  const genBaseStyle$5 = (token2) => {
    const {
      antCls,
      componentCls,
      iconCls,
      avatarBg,
      avatarColor,
      containerSize,
      containerSizeLG,
      containerSizeSM,
      textFontSize,
      textFontSizeLG,
      textFontSizeSM,
      iconFontSize,
      iconFontSizeLG,
      iconFontSizeSM,
      borderRadius,
      borderRadiusLG,
      borderRadiusSM,
      lineWidth,
      lineType
    } = token2;
    const avatarSizeStyle = (size, fontSize, iconFontSize2, radius2) => ({
      width: size,
      height: size,
      borderRadius: "50%",
      fontSize,
      [`&${componentCls}-square`]: {
        borderRadius: radius2
      },
      [`&${componentCls}-icon`]: {
        fontSize: iconFontSize2,
        [`> ${iconCls}`]: {
          margin: 0
        }
      }
    });
    return {
      [componentCls]: {
        ...resetComponent(token2),
        position: "relative",
        display: "inline-flex",
        justifyContent: "center",
        alignItems: "center",
        overflow: "hidden",
        color: avatarColor,
        whiteSpace: "nowrap",
        textAlign: "center",
        verticalAlign: "middle",
        background: avatarBg,
        border: `${unit$1(lineWidth)} ${lineType} transparent`,
        "&-image": {
          background: "transparent"
        },
        [`${antCls}-image-img`]: {
          display: "block"
        },
        ...avatarSizeStyle(containerSize, textFontSize, iconFontSize, borderRadius),
        "&-lg": {
          ...avatarSizeStyle(containerSizeLG, textFontSizeLG, iconFontSizeLG, borderRadiusLG)
        },
        "&-sm": {
          ...avatarSizeStyle(containerSizeSM, textFontSizeSM, iconFontSizeSM, borderRadiusSM)
        },
        "> img": {
          display: "block",
          width: "100%",
          height: "100%",
          objectFit: "cover"
        }
      }
    };
  };
  const genGroupStyle$2 = (token2) => {
    const {
      componentCls,
      groupBorderColor,
      groupOverlapping,
      groupSpace
    } = token2;
    return {
      [`${componentCls}-group`]: {
        display: "inline-flex",
        [componentCls]: {
          borderColor: groupBorderColor
        },
        "> *:not(:first-child)": {
          marginInlineStart: groupOverlapping
        }
      },
      [`${componentCls}-group-popover`]: {
        [`${componentCls} + ${componentCls}`]: {
          marginInlineStart: groupSpace
        }
      }
    };
  };
  const prepareComponentToken$k = (token2) => {
    const {
      controlHeight,
      controlHeightLG,
      controlHeightSM,
      fontSize,
      fontSizeLG,
      fontSizeXL,
      fontSizeHeading3,
      marginXS,
      marginXXS,
      colorBorderBg
    } = token2;
    return {
      containerSize: controlHeight,
      containerSizeLG: controlHeightLG,
      containerSizeSM: controlHeightSM,
      textFontSize: fontSize,
      textFontSizeLG: fontSize,
      textFontSizeSM: fontSize,
      iconFontSize: Math.round((fontSizeLG + fontSizeXL) / 2),
      iconFontSizeLG: fontSizeHeading3,
      iconFontSizeSM: fontSize,
      groupSpace: marginXXS,
      groupOverlapping: -marginXS,
      groupBorderColor: colorBorderBg
    };
  };
  const useStyle$u = genStyleHooks("Avatar", (token2) => {
    const {
      colorTextLightSolid,
      colorTextPlaceholder
    } = token2;
    const avatarToken = merge$1(token2, {
      avatarBg: colorTextPlaceholder,
      avatarColor: colorTextLightSolid
    });
    return [genBaseStyle$5(avatarToken), genGroupStyle$2(avatarToken)];
  }, prepareComponentToken$k);
  const Avatar$1 = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls: customizePrefixCls,
      shape,
      size: customSize,
      src,
      srcSet,
      icon,
      className,
      rootClassName,
      style: style2,
      alt,
      draggable,
      children,
      crossOrigin,
      gap = 4,
      onError,
      ...others
    } = props;
    const [scale2, setScale] = reactExports.useState(1);
    const [mounted, setMounted] = reactExports.useState(false);
    const [isImgExist, setIsImgExist] = reactExports.useState(true);
    const avatarNodeRef = reactExports.useRef(null);
    const avatarChildrenRef = reactExports.useRef(null);
    const avatarNodeMergedRef = composeRef(ref2, avatarNodeRef);
    const {
      getPrefixCls,
      className: contextClassName,
      style: contextStyle
    } = useComponentConfig("avatar");
    const avatarCtx = reactExports.useContext(AvatarContext);
    const setScaleParam = () => {
      if (!avatarChildrenRef.current || !avatarNodeRef.current) {
        return;
      }
      const childrenWidth = avatarChildrenRef.current.offsetWidth;
      const nodeWidth = avatarNodeRef.current.offsetWidth;
      if (childrenWidth !== 0 && nodeWidth !== 0) {
        if (gap * 2 < nodeWidth) {
          setScale(nodeWidth - gap * 2 < childrenWidth ? (nodeWidth - gap * 2) / childrenWidth : 1);
        }
      }
    };
    reactExports.useEffect(() => {
      setMounted(true);
    }, []);
    reactExports.useEffect(() => {
      setIsImgExist(true);
      setScale(1);
    }, [src]);
    reactExports.useEffect(setScaleParam, [gap]);
    const handleImgLoadError = () => {
      const errorFlag = onError?.();
      if (errorFlag !== false) {
        setIsImgExist(false);
      }
    };
    const size = useSize((ctxSize) => customSize ?? avatarCtx?.size ?? ctxSize ?? "medium");
    const needResponsive = Object.keys(typeof size === "object" ? size || {} : {}).some((key) => responsiveArray.includes(key));
    const screens = useBreakpoint(needResponsive);
    const responsiveSizeStyle = reactExports.useMemo(() => {
      if (typeof size !== "object") {
        return {};
      }
      const currentBreakpoint = responsiveArray.find((screen) => screens[screen]);
      const currentSize = size[currentBreakpoint];
      return currentSize ? {
        width: currentSize,
        height: currentSize,
        fontSize: currentSize && (icon || children) ? currentSize / 2 : 18
      } : {};
    }, [screens, size, icon, children]);
    const prefixCls = getPrefixCls("avatar", customizePrefixCls);
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$u(prefixCls, rootCls);
    const sizeCls = clsx({
      [`${prefixCls}-lg`]: size === "large",
      [`${prefixCls}-sm`]: size === "small"
    });
    const hasImageElement = reactExports.isValidElement(src);
    const mergedShape = shape || avatarCtx?.shape || "circle";
    const classString = clsx(prefixCls, sizeCls, contextClassName, `${prefixCls}-${mergedShape}`, {
      [`${prefixCls}-image`]: hasImageElement || src && isImgExist,
      [`${prefixCls}-icon`]: !!icon
    }, cssVarCls, rootCls, className, rootClassName, hashId);
    const sizeStyle = typeof size === "number" ? {
      width: size,
      height: size,
      fontSize: icon ? size / 2 : 18
    } : {};
    let childrenToRender;
    if (typeof src === "string" && isImgExist) {
      childrenToRender = reactExports.createElement("img", {
        src,
        draggable,
        srcSet,
        onError: handleImgLoadError,
        alt,
        crossOrigin
      });
    } else if (hasImageElement) {
      childrenToRender = src;
    } else if (icon) {
      childrenToRender = icon;
    } else if (mounted || scale2 !== 1) {
      const transformString = `scale(${scale2})`;
      const childrenStyle = {
        msTransform: transformString,
        WebkitTransform: transformString,
        transform: transformString
      };
      childrenToRender = reactExports.createElement(RefResizeObserver, {
        onResize: setScaleParam
      }, reactExports.createElement("span", {
        className: `${prefixCls}-string`,
        ref: avatarChildrenRef,
        style: childrenStyle
      }, children));
    } else {
      childrenToRender = reactExports.createElement("span", {
        className: `${prefixCls}-string`,
        style: {
          opacity: 0
        },
        ref: avatarChildrenRef
      }, children);
    }
    return reactExports.createElement("span", {
      ...others,
      style: {
        ...sizeStyle,
        ...responsiveSizeStyle,
        ...contextStyle,
        ...style2
      },
      className: classString,
      ref: avatarNodeMergedRef
    }, childrenToRender);
  });
  const getRenderPropValue = (propValue) => {
    if (!propValue) {
      return null;
    }
    return typeof propValue === "function" ? propValue() : propValue;
  };
  const Popup = (props) => {
    const {
      children,
      prefixCls,
      id: id2,
      classNames,
      styles,
      className,
      style: style2
    } = props;
    return reactExports.createElement("div", {
      id: id2,
      className: clsx(`${prefixCls}-container`, classNames?.container, className),
      style: {
        ...styles?.container,
        ...style2
      },
      role: "tooltip"
    }, typeof children === "function" ? children() : children);
  };
  const autoAdjustOverflowTopBottom = {
    shiftX: 64,
    adjustY: 1
  };
  const autoAdjustOverflowLeftRight = {
    adjustX: 1,
    shiftY: true
  };
  const targetOffset$1 = [0, 0];
  const placements$2 = {
    left: {
      points: ["cr", "cl"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [-4, 0],
      targetOffset: targetOffset$1
    },
    right: {
      points: ["cl", "cr"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [4, 0],
      targetOffset: targetOffset$1
    },
    top: {
      points: ["bc", "tc"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, -4],
      targetOffset: targetOffset$1
    },
    bottom: {
      points: ["tc", "bc"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, 4],
      targetOffset: targetOffset$1
    },
    topLeft: {
      points: ["bl", "tl"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, -4],
      targetOffset: targetOffset$1
    },
    leftTop: {
      points: ["tr", "tl"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [-4, 0],
      targetOffset: targetOffset$1
    },
    topRight: {
      points: ["br", "tr"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, -4],
      targetOffset: targetOffset$1
    },
    rightTop: {
      points: ["tl", "tr"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [4, 0],
      targetOffset: targetOffset$1
    },
    bottomRight: {
      points: ["tr", "br"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, 4],
      targetOffset: targetOffset$1
    },
    rightBottom: {
      points: ["bl", "br"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [4, 0],
      targetOffset: targetOffset$1
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, 4],
      targetOffset: targetOffset$1
    },
    leftBottom: {
      points: ["br", "bl"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [-4, 0],
      targetOffset: targetOffset$1
    }
  };
  function _extends$z() {
    _extends$z = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$z.apply(this, arguments);
  }
  const Tooltip$1 = reactExports.forwardRef((props, ref2) => {
    const {
      trigger: trigger2 = ["hover"],
      mouseEnterDelay = 0,
      mouseLeaveDelay = 0.1,
      prefixCls = "rc-tooltip",
      children,
      onVisibleChange,
      afterVisibleChange,
      motion: motion2,
      placement = "right",
      align = {},
      destroyOnHidden = false,
      defaultVisible,
      getTooltipContainer,
      arrowContent,
      overlay,
      id: id2,
      showArrow = true,
      classNames,
      styles,
      ...restProps
    } = props;
    const mergedId = useId(id2);
    const triggerRef = reactExports.useRef(null);
    reactExports.useImperativeHandle(ref2, () => triggerRef.current);
    const extraProps = {
      ...restProps
    };
    if ("visible" in props) {
      extraProps.popupVisible = props.visible;
    }
    const mergedArrow = reactExports.useMemo(() => {
      if (!showArrow) {
        return false;
      }
      const arrowConfig = showArrow === true ? {} : showArrow;
      return {
        ...arrowConfig,
        className: clsx(arrowConfig.className, classNames?.arrow),
        style: {
          ...arrowConfig.style,
          ...styles?.arrow
        },
        content: arrowConfig.content ?? arrowContent
      };
    }, [showArrow, classNames?.arrow, styles?.arrow, arrowContent]);
    const getChildren = ({
      open: open2
    }) => {
      const child = reactExports.Children.only(children);
      const ariaProps = {
        "aria-describedby": overlay && open2 ? mergedId : void 0
      };
      return reactExports.cloneElement(child, ariaProps);
    };
    return reactExports.createElement(Trigger, _extends$z({
      popupClassName: classNames?.root,
      prefixCls,
      popup: reactExports.createElement(Popup, {
        key: "content",
        prefixCls,
        id: mergedId,
        classNames,
        styles
      }, overlay),
      action: trigger2,
      builtinPlacements: placements$2,
      popupPlacement: placement,
      ref: triggerRef,
      popupAlign: align,
      getPopupContainer: getTooltipContainer,
      onOpenChange: onVisibleChange,
      afterOpenChange: afterVisibleChange,
      popupMotion: motion2,
      defaultPopupVisible: defaultVisible,
      autoDestroy: destroyOnHidden,
      mouseLeaveDelay,
      popupStyle: styles?.root,
      mouseEnterDelay,
      arrow: mergedArrow,
      uniqueContainerClassName: classNames?.uniqueContainer,
      uniqueContainerStyle: styles?.uniqueContainer
    }, extraProps), getChildren);
  });
  function getArrowToken(token2) {
    const {
      sizePopupArrow,
      borderRadiusXS,
      borderRadiusOuter
    } = token2;
    const unitWidth = sizePopupArrow / 2;
    const ax = 0;
    const ay = unitWidth;
    const bx = borderRadiusOuter * 1 / Math.sqrt(2);
    const by = unitWidth - borderRadiusOuter * (1 - 1 / Math.sqrt(2));
    const cx = unitWidth - borderRadiusXS * (1 / Math.sqrt(2));
    const cy = borderRadiusOuter * (Math.sqrt(2) - 1) + borderRadiusXS * (1 / Math.sqrt(2));
    const dx = 2 * unitWidth - cx;
    const dy = cy;
    const ex = 2 * unitWidth - bx;
    const ey = by;
    const fx = 2 * unitWidth - ax;
    const fy = ay;
    const shadowWidth = unitWidth * Math.sqrt(2) + borderRadiusOuter * (Math.sqrt(2) - 2);
    const polygonOffset = borderRadiusOuter * (Math.sqrt(2) - 1);
    const arrowPolygon = `polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`;
    const arrowPath = `path('M ${ax} ${ay} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${borderRadiusXS} ${borderRadiusXS} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${fx} ${fy} Z')`;
    return {
      arrowShadowWidth: shadowWidth,
      arrowPath,
      arrowPolygon
    };
  }
  const genRoundedArrow = (token2, bgColor, boxShadow) => {
    const {
      sizePopupArrow,
      arrowPolygon,
      arrowPath,
      arrowShadowWidth,
      borderRadiusXS,
      calc
    } = token2;
    return {
      pointerEvents: "none",
      width: sizePopupArrow,
      height: sizePopupArrow,
      overflow: "hidden",
      "&::before": {
        position: "absolute",
        bottom: 0,
        insetInlineStart: 0,
        width: sizePopupArrow,
        height: calc(sizePopupArrow).div(2).equal(),
        background: bgColor,
        clipPath: {
          _multi_value_: true,
          value: [arrowPolygon, arrowPath]
        },
        content: '""'
      },
      "&::after": {
        content: '""',
        position: "absolute",
        width: arrowShadowWidth,
        height: arrowShadowWidth,
        bottom: 0,
        insetInline: 0,
        margin: "auto",
        borderRadius: {
          _skip_check_: true,
          value: `0 0 ${unit$1(borderRadiusXS)} 0`
        },
        transform: "translateY(50%) rotate(-135deg)",
        boxShadow,
        zIndex: 0,
        background: "transparent"
      }
    };
  };
  const MAX_VERTICAL_CONTENT_RADIUS = 8;
  function getArrowOffsetToken(options) {
    const {
      contentRadius,
      limitVerticalRadius
    } = options;
    const arrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
    const arrowOffsetVertical = limitVerticalRadius ? MAX_VERTICAL_CONTENT_RADIUS : arrowOffset;
    return {
      arrowOffsetHorizontal: arrowOffset,
      arrowOffsetVertical
    };
  }
  function isInject(valid, code) {
    if (!valid) {
      return {};
    }
    return code;
  }
  const getArrowStyle = (token2, colorBg, options) => {
    const {
      componentCls,
      boxShadowPopoverArrow,
      arrowOffsetVertical,
      arrowOffsetHorizontal,
      antCls
    } = token2;
    const [varName] = genCssVar(antCls, "tooltip");
    const {
      arrowDistance = 0,
      arrowPlacement = {
        left: true,
        right: true,
        top: true,
        bottom: true
      }
    } = options || {};
    return {
      [componentCls]: {
[`${componentCls}-arrow`]: [{
          position: "absolute",
          zIndex: 1,
display: "block",
          ...genRoundedArrow(token2, colorBg, boxShadowPopoverArrow),
          "&:before": {
            background: colorBg
          }
        }],


...isInject(!!arrowPlacement.top, {
          [[`&-placement-top > ${componentCls}-arrow`, `&-placement-topLeft > ${componentCls}-arrow`, `&-placement-topRight > ${componentCls}-arrow`].join(",")]: {
            bottom: arrowDistance,
            transform: "translateY(100%) rotate(180deg)"
          },
          [`&-placement-top > ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateX(-50%) translateY(100%) rotate(180deg)"
          },
          "&-placement-topLeft": {
            [varName("arrow-offset-x")]: arrowOffsetHorizontal,
            [`> ${componentCls}-arrow`]: {
              left: {
                _skip_check_: true,
                value: arrowOffsetHorizontal
              }
            }
          },
          "&-placement-topRight": {
            [varName("arrow-offset-x")]: `calc(100% - ${unit$1(arrowOffsetHorizontal)})`,
            [`> ${componentCls}-arrow`]: {
              right: {
                _skip_check_: true,
                value: arrowOffsetHorizontal
              }
            }
          }
        }),
...isInject(!!arrowPlacement.bottom, {
          [[`&-placement-bottom > ${componentCls}-arrow`, `&-placement-bottomLeft > ${componentCls}-arrow`, `&-placement-bottomRight > ${componentCls}-arrow`].join(",")]: {
            top: arrowDistance,
            transform: `translateY(-100%)`
          },
          [`&-placement-bottom > ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: "50%"
            },
            transform: `translateX(-50%) translateY(-100%)`
          },
          "&-placement-bottomLeft": {
            [varName("arrow-offset-x")]: arrowOffsetHorizontal,
            [`> ${componentCls}-arrow`]: {
              left: {
                _skip_check_: true,
                value: arrowOffsetHorizontal
              }
            }
          },
          "&-placement-bottomRight": {
            [varName("arrow-offset-x")]: `calc(100% - ${unit$1(arrowOffsetHorizontal)})`,
            [`> ${componentCls}-arrow`]: {
              right: {
                _skip_check_: true,
                value: arrowOffsetHorizontal
              }
            }
          }
        }),
...isInject(!!arrowPlacement.left, {
          [[`&-placement-left > ${componentCls}-arrow`, `&-placement-leftTop > ${componentCls}-arrow`, `&-placement-leftBottom > ${componentCls}-arrow`].join(",")]: {
            right: {
              _skip_check_: true,
              value: arrowDistance
            },
            transform: "translateX(100%) rotate(90deg)"
          },
          [`&-placement-left > ${componentCls}-arrow`]: {
            top: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateY(-50%) translateX(100%) rotate(90deg)"
          },
          [`&-placement-leftTop > ${componentCls}-arrow`]: {
            top: arrowOffsetVertical
          },
          [`&-placement-leftBottom > ${componentCls}-arrow`]: {
            bottom: arrowOffsetVertical
          }
        }),
...isInject(!!arrowPlacement.right, {
          [[`&-placement-right > ${componentCls}-arrow`, `&-placement-rightTop > ${componentCls}-arrow`, `&-placement-rightBottom > ${componentCls}-arrow`].join(",")]: {
            left: {
              _skip_check_: true,
              value: arrowDistance
            },
            transform: "translateX(-100%) rotate(-90deg)"
          },
          [`&-placement-right > ${componentCls}-arrow`]: {
            top: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
          },
          [`&-placement-rightTop > ${componentCls}-arrow`]: {
            top: arrowOffsetVertical
          },
          [`&-placement-rightBottom > ${componentCls}-arrow`]: {
            bottom: arrowOffsetVertical
          }
        })
      }
    };
  };
  function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow2) {
    if (autoAdjustOverflow2 === false) {
      return {
        adjustX: false,
        adjustY: false
      };
    }
    const overflow = autoAdjustOverflow2 && typeof autoAdjustOverflow2 === "object" ? autoAdjustOverflow2 : {};
    const baseOverflow = {};
    switch (placement) {
      case "top":
      case "bottom":
        baseOverflow.shiftX = arrowOffset.arrowOffsetHorizontal * 2 + arrowWidth;
        baseOverflow.shiftY = true;
        baseOverflow.adjustY = true;
        break;
      case "left":
      case "right":
        baseOverflow.shiftY = arrowOffset.arrowOffsetVertical * 2 + arrowWidth;
        baseOverflow.shiftX = true;
        baseOverflow.adjustX = true;
        break;
    }
    const mergedOverflow = {
      ...baseOverflow,
      ...overflow
    };
    if (!mergedOverflow.shiftX) {
      mergedOverflow.adjustX = true;
    }
    if (!mergedOverflow.shiftY) {
      mergedOverflow.adjustY = true;
    }
    return mergedOverflow;
  }
  const PlacementAlignMap = {
    left: {
      points: ["cr", "cl"]
    },
    right: {
      points: ["cl", "cr"]
    },
    top: {
      points: ["bc", "tc"]
    },
    bottom: {
      points: ["tc", "bc"]
    },
    topLeft: {
      points: ["bl", "tl"]
    },
    leftTop: {
      points: ["tr", "tl"]
    },
    topRight: {
      points: ["br", "tr"]
    },
    rightTop: {
      points: ["tl", "tr"]
    },
    bottomRight: {
      points: ["tr", "br"]
    },
    rightBottom: {
      points: ["bl", "br"]
    },
    bottomLeft: {
      points: ["tl", "bl"]
    },
    leftBottom: {
      points: ["br", "bl"]
    }
  };
  const ArrowCenterPlacementAlignMap = {
    topLeft: {
      points: ["bl", "tc"]
    },
    leftTop: {
      points: ["tr", "cl"]
    },
    topRight: {
      points: ["br", "tc"]
    },
    rightTop: {
      points: ["tl", "cr"]
    },
    bottomRight: {
      points: ["tr", "bc"]
    },
    rightBottom: {
      points: ["bl", "cr"]
    },
    bottomLeft: {
      points: ["tl", "bc"]
    },
    leftBottom: {
      points: ["br", "cl"]
    }
  };
  const DisableAutoArrowList = new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
  function getPlacements(config) {
    const {
      arrowWidth,
      autoAdjustOverflow: autoAdjustOverflow2,
      arrowPointAtCenter,
      offset: offset2,
      borderRadius,
      visibleFirst
    } = config;
    const halfArrowWidth = arrowWidth / 2;
    const placementMap = {};
    const arrowOffset = getArrowOffsetToken({
      contentRadius: borderRadius,
      limitVerticalRadius: true
    });
    Object.keys(PlacementAlignMap).forEach((key) => {
      const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key];
      const placementInfo = {
        ...template,
        offset: [0, 0],
        dynamicInset: true
      };
      placementMap[key] = placementInfo;
      if (DisableAutoArrowList.has(key)) {
        placementInfo.autoArrow = false;
      }
      switch (key) {
        case "top":
        case "topLeft":
        case "topRight":
          placementInfo.offset[1] = -halfArrowWidth - offset2;
          break;
        case "bottom":
        case "bottomLeft":
        case "bottomRight":
          placementInfo.offset[1] = halfArrowWidth + offset2;
          break;
        case "left":
        case "leftTop":
        case "leftBottom":
          placementInfo.offset[0] = -halfArrowWidth - offset2;
          break;
        case "right":
        case "rightTop":
        case "rightBottom":
          placementInfo.offset[0] = halfArrowWidth + offset2;
          break;
      }
      if (arrowPointAtCenter) {
        switch (key) {
          case "topLeft":
          case "bottomLeft":
            placementInfo.offset[0] = -arrowOffset.arrowOffsetHorizontal - halfArrowWidth;
            break;
          case "topRight":
          case "bottomRight":
            placementInfo.offset[0] = arrowOffset.arrowOffsetHorizontal + halfArrowWidth;
            break;
          case "leftTop":
          case "rightTop":
            placementInfo.offset[1] = -arrowOffset.arrowOffsetHorizontal * 2 + halfArrowWidth;
            break;
          case "leftBottom":
          case "rightBottom":
            placementInfo.offset[1] = arrowOffset.arrowOffsetHorizontal * 2 - halfArrowWidth;
            break;
        }
      }
      placementInfo.overflow = getOverflowOptions(key, arrowOffset, arrowWidth, autoAdjustOverflow2);
      if (visibleFirst) {
        placementInfo.htmlRegion = "visibleFirst";
      }
    });
    return placementMap;
  }
  const useMergedArrow = (providedArrow, providedContextArrow) => {
    const toConfig = (arrow) => typeof arrow === "boolean" ? {
      show: arrow
    } : arrow || {};
    return React.useMemo(() => {
      const arrowConfig = toConfig(providedArrow);
      const contextArrowConfig = toConfig(providedContextArrow);
      return {
        ...contextArrowConfig,
        ...arrowConfig,
        show: arrowConfig.show ?? contextArrowConfig.show ?? true
      };
    }, [providedArrow, providedContextArrow]);
  };
  const FALL_BACK_ORIGIN$1 = "50%";
  const genTooltipStyle = (token2) => {
    const {
      calc,
      componentCls,
tooltipMaxWidth,
      tooltipColor,
      tooltipBg,
      tooltipBorderRadius,
      zIndexPopup,
      controlHeight,
      boxShadowSecondary,
      paddingSM,
      paddingXS,
      arrowOffsetHorizontal,
      sizePopupArrow,
      antCls
    } = token2;
    const [varName, varRef] = genCssVar(antCls, "tooltip");
    const edgeAlignMinWidth = calc(tooltipBorderRadius).add(sizePopupArrow).add(arrowOffsetHorizontal).equal();
    const centerAlignMinWidth = calc(tooltipBorderRadius).mul(2).add(sizePopupArrow).equal();
    const sharedBodyStyle = {
      minWidth: centerAlignMinWidth,
      minHeight: controlHeight,
      padding: `${unit$1(token2.calc(paddingSM).div(2).equal())} ${unit$1(paddingXS)}`,
      color: varRef("overlay-color", tooltipColor),
      textAlign: "start",
      textDecoration: "none",
      wordWrap: "break-word",
      backgroundColor: tooltipBg,
      borderRadius: tooltipBorderRadius,
      boxShadow: boxShadowSecondary,
      boxSizing: "border-box"
    };
    const sharedTransformOrigin = {
[varName("valid-offset-x")]: varRef("arrow-offset-x", "var(--arrow-x)"),
      transformOrigin: [varRef("valid-offset-x", FALL_BACK_ORIGIN$1), `var(--arrow-y, ${FALL_BACK_ORIGIN$1})`].join(" ")
    };
    return [
      {
        [componentCls]: {
          ...resetComponent(token2),
          position: "absolute",
          zIndex: zIndexPopup,
          display: "block",
          width: "max-content",
          maxWidth: tooltipMaxWidth,
          visibility: "visible",
          ...sharedTransformOrigin,
          "&-hidden": {
            display: "none"
          },
          [varName("arrow-background-color")]: tooltipBg,
[`${componentCls}-container`]: [sharedBodyStyle, initFadeMotion(token2, true)],
          [`&:has(~ ${componentCls}-unique-container)`]: {
            [`${componentCls}-container`]: {
              border: "none",
              background: "transparent",
              boxShadow: "none"
            }
          },
[[`&-placement-topLeft`, `&-placement-topRight`, `&-placement-bottomLeft`, `&-placement-bottomRight`].join(",")]: {
            minWidth: edgeAlignMinWidth
          },
[[`&-placement-left`, `&-placement-leftTop`, `&-placement-leftBottom`, `&-placement-right`, `&-placement-rightTop`, `&-placement-rightBottom`].join(",")]: {
            [`${componentCls}-inner`]: {
              borderRadius: token2.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
            }
          },
          [`${componentCls}-content`]: {
            position: "relative"
          },
...genPresetColor$1(token2, (colorKey, {
            darkColor
          }) => ({
            [`&${componentCls}-${colorKey}`]: {
              [`${componentCls}-container`]: {
                backgroundColor: darkColor
              },
              [`${componentCls}-arrow`]: {
                [varName("arrow-background-color")]: darkColor
              }
            }
          })),
"&-rtl": {
            direction: "rtl"
          }
        }
      },
getArrowStyle(token2, varRef("arrow-background-color")),
{
        [`${componentCls}-pure`]: {
          position: "relative",
          maxWidth: "none",
          margin: token2.sizePopupArrow
        }
      },
{
        [`${componentCls}-unique-container`]: {
          ...sharedBodyStyle,
          ...sharedTransformOrigin,
          position: "absolute",
          zIndex: calc(zIndexPopup).sub(1).equal(),
          "&-hidden": {
            display: "none"
          },
          "&-visible": {
            transition: `all ${token2.motionDurationSlow}`
          }
        }
      }
    ];
  };
  const prepareComponentToken$j = (token2) => ({
    zIndexPopup: token2.zIndexPopupBase + 70,
    maxWidth: 250,
    ...getArrowOffsetToken({
      contentRadius: token2.borderRadius,
      limitVerticalRadius: true
    }),
    ...getArrowToken(merge$1(token2, {
      borderRadiusOuter: Math.min(token2.borderRadiusOuter, 4)
    }))
  });
  const useStyle$t = (prefixCls, rootCls, injectStyle = true) => {
    const useStyle2 = genStyleHooks("Tooltip", (token2) => {
      const {
        borderRadius,
        colorTextLightSolid,
        colorBgSpotlight,
        maxWidth
      } = token2;
      const TooltipToken = merge$1(token2, {
tooltipMaxWidth: maxWidth,
        tooltipColor: colorTextLightSolid,
        tooltipBorderRadius: borderRadius,
        tooltipBg: colorBgSpotlight
      });
      return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
    }, prepareComponentToken$j, {
      resetStyle: false,
injectStyle
    });
    return useStyle2(prefixCls, rootCls);
  };
  const inverseColors = PresetColors.map((color2) => `${color2}-inverse`);
  const PresetStatusColors = ["success", "processing", "error", "default", "warning"];
  function isPresetColor(color2, includeInverse = true) {
    if (includeInverse) {
      return [].concat(_toConsumableArray(inverseColors), _toConsumableArray(PresetColors)).includes(color2);
    }
    return PresetColors.includes(color2);
  }
  function isPresetStatusColor(color2) {
    return PresetStatusColors.includes(color2);
  }
  const parseColor = (rootPrefixCls, prefixCls, color2) => {
    const isInternalColor = isPresetColor(color2);
    const [varName] = genCssVar(rootPrefixCls, "tooltip");
    const className = clsx({
      [`${prefixCls}-${color2}`]: color2 && isInternalColor
    });
    const overlayStyle = {};
    const arrowStyle = {};
    const rgb = generateColor(color2).toRgb();
    const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
    const textColor = luminance < 0.5 ? "#FFF" : "#000";
    if (color2 && !isInternalColor) {
      overlayStyle.background = color2;
      overlayStyle[varName("overlay-color")] = textColor;
      arrowStyle[varName("arrow-background-color")] = color2;
    }
    return {
      className,
      overlayStyle,
      arrowStyle
    };
  };
  const PurePanel$7 = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      placement = "top",
      title,
      color: color2,
      overlayInnerStyle,
      classNames,
      styles
    } = props;
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
    const rootPrefixCls = getPrefixCls();
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$t(prefixCls, rootCls);
    const colorInfo = parseColor(rootPrefixCls, prefixCls, color2);
    const arrowContentStyle = colorInfo.arrowStyle;
    const innerStyles = reactExports.useMemo(() => {
      const mergedStyle = {
        ...overlayInnerStyle,
        ...colorInfo.overlayStyle
      };
      return {
        container: mergedStyle
      };
    }, [overlayInnerStyle, colorInfo.overlayStyle]);
    const mergedProps = {
      ...props,
      placement
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([classNames], [innerStyles, styles], {
      props: mergedProps
    });
    const rootClassName = clsx(rootCls, hashId, cssVarCls, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className, colorInfo.className);
    return reactExports.createElement("div", {
      className: rootClassName,
      style: arrowContentStyle
    }, reactExports.createElement("div", {
      className: `${prefixCls}-arrow`
    }), reactExports.createElement(Popup, {
      ...props,
      className: hashId,
      prefixCls,
      classNames: mergedClassNames,
      styles: mergedStyles
    }, title));
  };
  const InternalTooltip = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls: customizePrefixCls,
      openClassName,
      getTooltipContainer,
      color: color2,
      children,
      afterOpenChange,
      arrow: tooltipArrow,
      destroyTooltipOnHide,
      destroyOnHidden,
      title,
      overlay,
      trigger: trigger2,
      builtinPlacements,
      autoAdjustOverflow: autoAdjustOverflow2 = true,
      motion: motion2,
      getPopupContainer,
      placement = "top",
      mouseEnterDelay = 0.1,
      mouseLeaveDelay = 0.1,
      rootClassName,
      styles,
      classNames,
      onOpenChange,
overlayInnerStyle,
      overlayStyle,
      overlayClassName,
      ...restProps
    } = props;
    const [, token2] = useToken$1();
    const {
      getPopupContainer: getContextPopupContainer,
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles,
      arrow: contextArrow,
      trigger: contextTrigger
    } = useComponentConfig("tooltip");
    const mergedArrow = useMergedArrow(tooltipArrow, contextArrow);
    const mergedShowArrow = mergedArrow.show;
    const mergedTrigger = trigger2 || contextTrigger || "hover";
    const tooltipRef = reactExports.useRef(null);
    const forceAlign = () => {
      tooltipRef.current?.forceAlign();
    };
    reactExports.useImperativeHandle(ref2, () => ({
      forceAlign,
      nativeElement: tooltipRef.current?.nativeElement,
      popupElement: tooltipRef.current?.popupElement
    }));
    const [open2, setOpen] = useControlledState(props.defaultOpen ?? false, props.open);
    const noTitle = !title && !overlay && title !== 0;
    const onInternalOpenChange = (vis) => {
      setOpen(noTitle ? false : vis);
      if (!noTitle && onOpenChange) {
        onOpenChange(vis);
      }
    };
    const tooltipPlacements = reactExports.useMemo(() => {
      return builtinPlacements || getPlacements({
        arrowPointAtCenter: mergedArrow?.pointAtCenter ?? false,
        autoAdjustOverflow: autoAdjustOverflow2,
        arrowWidth: mergedShowArrow ? token2.sizePopupArrow : 0,
        borderRadius: token2.borderRadius,
        offset: token2.marginXXS,
        visibleFirst: true
      });
    }, [mergedArrow, builtinPlacements, token2, mergedShowArrow, autoAdjustOverflow2]);
    const memoOverlay = reactExports.useMemo(() => {
      if (title === 0) {
        return title;
      }
      return overlay || title || "";
    }, [overlay, title]);
    const memoOverlayWrapper = reactExports.createElement(ContextIsolator, {
      space: true,
      form: true
    }, typeof memoOverlay === "function" ? memoOverlay() : memoOverlay);
    const mergedProps = {
      ...props,
      trigger: mergedTrigger,
      color: color2,
      placement,
      builtinPlacements,
      openClassName,
      arrow: tooltipArrow,
      autoAdjustOverflow: autoAdjustOverflow2,
      getPopupContainer,
      children,
      destroyTooltipOnHide,
      destroyOnHidden
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
    const rootPrefixCls = getPrefixCls();
    const injectFromPopover = props["data-popover-inject"];
    let tempOpen = open2;
    if (!("open" in props) && noTitle) {
      tempOpen = false;
    }
    const child = reactExports.isValidElement(children) && !isFragment(children) ? children : reactExports.createElement("span", null, children);
    const childProps = child.props;
    const childCls = !childProps.className || typeof childProps.className === "string" ? clsx(childProps.className, openClassName || `${prefixCls}-open`) : childProps.className;
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$t(prefixCls, rootCls, !injectFromPopover);
    const colorInfo = parseColor(rootPrefixCls, prefixCls, color2);
    const arrowContentStyle = colorInfo.arrowStyle;
    const themeCls = clsx(rootCls, hashId, cssVarCls);
    const rootClassNames = clsx(overlayClassName, {
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, colorInfo.className, rootClassName, themeCls, contextClassName, mergedClassNames.root);
    const [zIndex, contextZIndex] = useZIndex("Tooltip", restProps.zIndex);
    const containerStyle = {
      ...mergedStyles.container,
      ...overlayInnerStyle,
      ...colorInfo.overlayStyle
    };
    const content = reactExports.createElement(Tooltip$1, {
      unique: true,
      ...restProps,
      trigger: mergedTrigger,
      zIndex,
      showArrow: mergedShowArrow,
      placement,
      mouseEnterDelay,
      mouseLeaveDelay,
      prefixCls,
      classNames: {
        root: rootClassNames,
        container: mergedClassNames.container,
        arrow: mergedClassNames.arrow,
        uniqueContainer: clsx(themeCls, mergedClassNames.container)
      },
      styles: {
        root: {
          ...arrowContentStyle,
          ...mergedStyles.root,
          ...contextStyle,
          ...overlayStyle
        },
        container: containerStyle,
        uniqueContainer: containerStyle,
        arrow: mergedStyles.arrow
      },
      getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
      ref: tooltipRef,
      builtinPlacements: tooltipPlacements,
      overlay: memoOverlayWrapper,
      visible: tempOpen,
      onVisibleChange: onInternalOpenChange,
      afterVisibleChange: afterOpenChange,
      arrowContent: reactExports.createElement("span", {
        className: `${prefixCls}-arrow-content`
      }),
      motion: {
        motionName: getTransitionName(rootPrefixCls, "zoom-big-fast", typeof motion2?.motionName === "string" ? motion2?.motionName : void 0),
        motionDeadline: 1e3
      },
      destroyOnHidden: destroyOnHidden ?? !!destroyTooltipOnHide
    }, tempOpen ? cloneElement(child, {
      className: childCls
    }) : child);
    return reactExports.createElement(ZIndexContext.Provider, {
      value: contextZIndex
    }, content);
  });
  const Tooltip = InternalTooltip;
  Tooltip._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$7;
  Tooltip.UniqueProvider = UniqueProvider;
  const FALL_BACK_ORIGIN = "50%";
  const genBaseStyle$4 = (token2) => {
    const {
      componentCls,
      popoverColor,
      titleMinWidth,
      fontWeightStrong,
      innerPadding,
      boxShadowSecondary,
      colorTextHeading,
      borderRadiusLG,
      zIndexPopup,
      titleMarginBottom,
      colorBgElevated,
      popoverBg,
      titleBorderBottom,
      innerContentPadding,
      titlePadding,
      antCls
    } = token2;
    const [varName, varRef] = genCssVar(antCls, "tooltip");
    return [
      {
        [componentCls]: {
          ...resetComponent(token2),
          position: "absolute",
          top: 0,
left: {
            _skip_check_: true,
            value: 0
          },
          zIndex: zIndexPopup,
          fontWeight: "normal",
          whiteSpace: "normal",
          textAlign: "start",
          cursor: "auto",
          userSelect: "text",
[varName("valid-offset-x")]: varRef("arrow-offset-x", "var(--arrow-x)"),
          transformOrigin: [varRef("valid-offset-x", FALL_BACK_ORIGIN), `var(--arrow-y, ${FALL_BACK_ORIGIN})`].join(" "),
          [varName("arrow-background-color")]: colorBgElevated,
          width: "max-content",
          maxWidth: "100vw",
          "&-rtl": {
            direction: "rtl"
          },
          "&-hidden": {
            display: "none"
          },
          [`${componentCls}-content`]: {
            position: "relative"
          },
          [`${componentCls}-container`]: {
            backgroundColor: popoverBg,
            backgroundClip: "padding-box",
            borderRadius: borderRadiusLG,
            boxShadow: boxShadowSecondary,
            padding: innerPadding
          },
          [`${componentCls}-title`]: {
            minWidth: titleMinWidth,
            marginBottom: titleMarginBottom,
            color: colorTextHeading,
            fontWeight: fontWeightStrong,
            borderBottom: titleBorderBottom,
            padding: titlePadding
          },
          [`${componentCls}-content`]: {
            color: popoverColor,
            padding: innerContentPadding
          }
        }
      },
getArrowStyle(token2, varRef("arrow-background-color")),
{
        [`${componentCls}-pure`]: {
          position: "relative",
          maxWidth: "none",
          margin: token2.sizePopupArrow,
          display: "inline-block"
        }
      }
    ];
  };
  const genColorStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    const [varName] = genCssVar(antCls, "tooltip");
    return {
      [componentCls]: PresetColors.map((colorKey) => {
        const lightColor = token2[`${colorKey}6`];
        return {
          [`&${componentCls}-${colorKey}`]: {
            [varName("arrow-background-color")]: lightColor,
            [`${componentCls}-inner`]: {
              backgroundColor: lightColor
            },
            [`${componentCls}-arrow`]: {
              background: "transparent"
            }
          }
        };
      })
    };
  };
  const prepareComponentToken$i = (token2) => {
    const {
      lineWidth,
      controlHeight,
      fontHeight,
      padding,
      wireframe,
      zIndexPopupBase,
      borderRadiusLG,
      marginXS,
      lineType,
      colorSplit,
      paddingSM
    } = token2;
    const titlePaddingBlockDist = controlHeight - fontHeight;
    const popoverTitlePaddingBlockTop = titlePaddingBlockDist / 2;
    const popoverTitlePaddingBlockBottom = titlePaddingBlockDist / 2 - lineWidth;
    const popoverPaddingHorizontal = padding;
    return {
      titleMinWidth: 177,
      zIndexPopup: zIndexPopupBase + 30,
      ...getArrowToken(token2),
      ...getArrowOffsetToken({
        contentRadius: borderRadiusLG,
        limitVerticalRadius: true
      }),
innerPadding: wireframe ? 0 : 12,
      titleMarginBottom: wireframe ? 0 : marginXS,
      titlePadding: wireframe ? `${popoverTitlePaddingBlockTop}px ${popoverPaddingHorizontal}px ${popoverTitlePaddingBlockBottom}px` : 0,
      titleBorderBottom: wireframe ? `${lineWidth}px ${lineType} ${colorSplit}` : "none",
      innerContentPadding: wireframe ? `${paddingSM}px ${popoverPaddingHorizontal}px` : 0
    };
  };
  const useStyle$s = genStyleHooks("Popover", (token2) => {
    const {
      colorBgElevated,
      colorText
    } = token2;
    const popoverToken = merge$1(token2, {
      popoverBg: colorBgElevated,
      popoverColor: colorText
    });
    return [genBaseStyle$4(popoverToken), genColorStyle(popoverToken), initZoomMotion(popoverToken, "zoom-big")];
  }, prepareComponentToken$i, {
    resetStyle: false,
    deprecatedTokens: [["width", "titleMinWidth"], ["minWidth", "titleMinWidth"]]
  });
  const Overlay$2 = (props) => {
    const {
      title,
      content,
      prefixCls,
      classNames,
      styles
    } = props;
    if (!title && !content) {
      return null;
    }
    return reactExports.createElement(reactExports.Fragment, null, title && reactExports.createElement("div", {
      className: clsx(`${prefixCls}-title`, classNames?.title),
      style: styles?.title
    }, title), content && reactExports.createElement("div", {
      className: clsx(`${prefixCls}-content`, classNames?.content),
      style: styles?.content
    }, content));
  };
  const RawPurePanel = (props) => {
    const {
      hashId,
      prefixCls,
      className,
      style: style2,
      placement = "top",
      title,
      content,
      children,
      classNames,
      styles
    } = props;
    const titleNode = getRenderPropValue(title);
    const contentNode = getRenderPropValue(content);
    const mergedProps = {
      ...props,
      placement
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([classNames], [styles], {
      props: mergedProps
    });
    const rootClassName = clsx(hashId, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className);
    return reactExports.createElement("div", {
      className: rootClassName,
      style: style2
    }, reactExports.createElement("div", {
      className: `${prefixCls}-arrow`
    }), reactExports.createElement(Popup, {
      ...props,
      className: hashId,
      prefixCls,
      classNames: mergedClassNames,
      styles: mergedStyles
    }, children || reactExports.createElement(Overlay$2, {
      prefixCls,
      title: titleNode,
      content: contentNode,
      classNames: mergedClassNames,
      styles: mergedStyles
    })));
  };
  const PurePanel$6 = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      ...restProps
    } = props;
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const prefixCls = getPrefixCls("popover", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$s(prefixCls);
    return reactExports.createElement(RawPurePanel, {
      ...restProps,
      prefixCls,
      hashId,
      className: clsx(className, cssVarCls)
    });
  };
  const InternalPopover = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls: customizePrefixCls,
      title,
      content,
      overlayClassName,
      placement = "top",
      trigger: trigger2,
      children,
      mouseEnterDelay = 0.1,
      mouseLeaveDelay = 0.1,
      onOpenChange,
      overlayStyle = {},
      styles,
      classNames,
      motion: motion2,
      arrow: popoverArrow,
      ...restProps
    } = props;
    const {
      getPrefixCls,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles,
      arrow: contextArrow,
      trigger: contextTrigger
    } = useComponentConfig("popover");
    const prefixCls = getPrefixCls("popover", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$s(prefixCls);
    const rootPrefixCls = getPrefixCls();
    const mergedArrow = useMergedArrow(popoverArrow, contextArrow);
    const mergedTrigger = trigger2 || contextTrigger || "hover";
    const mergedProps = {
      ...props,
      placement,
      trigger: mergedTrigger,
      mouseEnterDelay,
      mouseLeaveDelay,
      overlayStyle,
      styles,
      classNames
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const rootClassNames = clsx(overlayClassName, hashId, cssVarCls, contextClassName, mergedClassNames.root);
    const [open2, setOpen] = useControlledState(props.defaultOpen ?? false, props.open);
    const settingOpen = (value) => {
      setOpen(value);
      onOpenChange?.(value);
    };
    const titleNode = getRenderPropValue(title);
    const contentNode = getRenderPropValue(content);
    return reactExports.createElement(Tooltip, {
      unique: false,
      arrow: mergedArrow,
      placement,
      trigger: mergedTrigger,
      mouseEnterDelay,
      mouseLeaveDelay,
      ...restProps,
      prefixCls,
      classNames: {
        root: rootClassNames,
        container: mergedClassNames.container,
        arrow: mergedClassNames.arrow
      },
      styles: {
        root: {
          ...mergedStyles.root,
          ...contextStyle,
          ...overlayStyle
        },
        container: mergedStyles.container,
        arrow: mergedStyles.arrow
      },
      ref: ref2,
      open: open2,
      onOpenChange: settingOpen,
      overlay: titleNode || contentNode ? reactExports.createElement(Overlay$2, {
        prefixCls,
        title: titleNode,
        content: contentNode,
        classNames: mergedClassNames,
        styles: mergedStyles
      }) : null,
      motion: {
        motionName: getTransitionName(rootPrefixCls, "zoom-big", typeof motion2?.motionName === "string" ? motion2?.motionName : void 0)
      },
      "data-popover-inject": true
    }, children);
  });
  const Popover = InternalPopover;
  Popover._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$6;
  const AvatarContextProvider = (props) => {
    const {
      size,
      shape
    } = reactExports.useContext(AvatarContext);
    const avatarContextValue = reactExports.useMemo(() => ({
      size: props.size || size,
      shape: props.shape || shape
    }), [props.size, props.shape, size, shape]);
    return reactExports.createElement(AvatarContext.Provider, {
      value: avatarContextValue
    }, props.children);
  };
  const AvatarGroup = (props) => {
    const {
      getPrefixCls,
      direction
    } = reactExports.useContext(ConfigContext);
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style: style2,
      maxCount,
      maxStyle,
      size,
      shape,
      maxPopoverPlacement,
      maxPopoverTrigger,
      children,
      max
    } = props;
    const prefixCls = getPrefixCls("avatar", customizePrefixCls);
    const groupPrefixCls = `${prefixCls}-group`;
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$u(prefixCls, rootCls);
    const cls = clsx(groupPrefixCls, {
      [`${groupPrefixCls}-rtl`]: direction === "rtl"
    }, cssVarCls, rootCls, className, rootClassName, hashId);
    const childrenWithProps = toArray$4(children).map((child, index) => cloneElement(child, {
key: `avatar-key-${index}`
    }));
    const mergeCount = max?.count || maxCount;
    const numOfChildren = childrenWithProps.length;
    if (mergeCount && mergeCount < numOfChildren) {
      const childrenShow = childrenWithProps.slice(0, mergeCount);
      const childrenHidden = childrenWithProps.slice(mergeCount, numOfChildren);
      const mergeStyle = max?.style || maxStyle;
      const mergePopoverTrigger = max?.popover?.trigger || maxPopoverTrigger || "hover";
      const mergePopoverPlacement = max?.popover?.placement || maxPopoverPlacement || "top";
      const popoverProps = {
        content: childrenHidden,
        ...max?.popover,
        placement: mergePopoverPlacement,
        trigger: mergePopoverTrigger,
        rootClassName: clsx(`${groupPrefixCls}-popover`, max?.popover?.rootClassName)
      };
      childrenShow.push( reactExports.createElement(Popover, {
        key: "avatar-popover-key",
        destroyOnHidden: true,
        ...popoverProps
      }, reactExports.createElement(Avatar$1, {
        style: mergeStyle
      }, `+${numOfChildren - mergeCount}`)));
      return reactExports.createElement(AvatarContextProvider, {
        shape,
        size
      }, reactExports.createElement("div", {
        className: cls,
        style: style2
      }, childrenShow));
    }
    return reactExports.createElement(AvatarContextProvider, {
      shape,
      size
    }, reactExports.createElement("div", {
      className: cls,
      style: style2
    }, childrenWithProps));
  };
  const Avatar = Avatar$1;
  Avatar.Group = AvatarGroup;
  var VerticalAlignTopOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M859.9 168H164.1c-4.5 0-8.1 3.6-8.1 8v60c0 4.4 3.6 8 8.1 8h695.8c4.5 0 8.1-3.6 8.1-8v-60c0-4.4-3.6-8-8.1-8zM518.3 355a8 8 0 00-12.6 0l-112 141.7a7.98 7.98 0 006.3 12.9h73.9V848c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V509.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 355z" } }] }, "name": "vertical-align-top", "theme": "outlined" };
  function _extends$y() {
    _extends$y = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$y.apply(this, arguments);
  }
  const VerticalAlignTopOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends$y({}, props, {
    ref: ref2,
    icon: VerticalAlignTopOutlined$1
  }));
  const RefIcon$c = reactExports.forwardRef(VerticalAlignTopOutlined);
  const UnitNumber = (props) => {
    const {
      prefixCls,
      value,
      current,
      offset: offset2 = 0
    } = props;
    let style2;
    if (offset2) {
      style2 = {
        position: "absolute",
        top: `${offset2}00%`,
        left: 0
      };
    }
    return reactExports.createElement("span", {
      style: style2,
      className: clsx(`${prefixCls}-only-unit`, {
        current
      })
    }, value);
  };
  function getOffset$2(start, end, unit2) {
    let index = start;
    let offset2 = 0;
    while ((index + 10) % 10 !== end) {
      index += unit2;
      offset2 += unit2;
    }
    return offset2;
  }
  const SingleNumber = (props) => {
    const {
      prefixCls,
      count: originCount,
      value: originValue
    } = props;
    const value = Number(originValue);
    const count = Math.abs(originCount);
    const [prevValue, setPrevValue] = reactExports.useState(value);
    const [prevCount, setPrevCount] = reactExports.useState(count);
    const onTransitionEnd = () => {
      setPrevValue(value);
      setPrevCount(count);
    };
    reactExports.useEffect(() => {
      const timer = setTimeout(onTransitionEnd, 1e3);
      return () => clearTimeout(timer);
    }, [value]);
    let unitNodes;
    let offsetStyle;
    if (prevValue === value || Number.isNaN(value) || Number.isNaN(prevValue)) {
      unitNodes = [ reactExports.createElement(UnitNumber, {
        ...props,
        key: value,
        current: true
      })];
      offsetStyle = {
        transition: "none"
      };
    } else {
      unitNodes = [];
      const end = value + 10;
      const unitNumberList = [];
      for (let index = value; index <= end; index += 1) {
        unitNumberList.push(index);
      }
      const unit2 = prevCount < count ? 1 : -1;
      const prevIndex = unitNumberList.findIndex((n2) => n2 % 10 === prevValue);
      const cutUnitNumberList = unit2 < 0 ? unitNumberList.slice(0, prevIndex + 1) : unitNumberList.slice(prevIndex);
      unitNodes = cutUnitNumberList.map((n2, index) => {
        const singleUnit = n2 % 10;
        return reactExports.createElement(UnitNumber, {
          ...props,
          key: n2,
          value: singleUnit,
          offset: unit2 < 0 ? index - prevIndex : index,
          current: index === prevIndex
        });
      });
      offsetStyle = {
        transform: `translateY(${-getOffset$2(prevValue, value, unit2)}00%)`
      };
    }
    return reactExports.createElement("span", {
      className: `${prefixCls}-only`,
      style: offsetStyle,
      onTransitionEnd
    }, unitNodes);
  };
  const ScrollNumber = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls: customizePrefixCls,
      count,
      className,
      motionClassName,
      style: style2,
      title,
      show,
      component: Component = "sup",
      children,
      ...restProps
    } = props;
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const prefixCls = getPrefixCls("scroll-number", customizePrefixCls);
    const newProps = {
      ...restProps,
      "data-show": show,
      style: style2,
      className: clsx(prefixCls, className, motionClassName),
      title
    };
    let numberNodes = count;
    if (count && Number(count) % 1 === 0) {
      const numberList = String(count).split("");
      numberNodes = reactExports.createElement("bdi", null, numberList.map((num, i2) => reactExports.createElement(SingleNumber, {
        prefixCls,
        count: Number(count),
        value: num,
key: numberList.length - i2
      })));
    }
    if (style2?.borderColor) {
      newProps.style = {
        ...style2,
        boxShadow: `0 0 0 1px ${style2.borderColor} inset`
      };
    }
    if (children) {
      return cloneElement(children, (oriProps) => ({
        className: clsx(`${prefixCls}-custom-component`, oriProps?.className, motionClassName)
      }));
    }
    return reactExports.createElement(Component, {
      ...newProps,
      ref: ref2
    }, numberNodes);
  });
  const antStatusProcessing = new Keyframe("antStatusProcessing", {
    "0%": {
      transform: "scale(0.8)",
      opacity: 0.5
    },
    "100%": {
      transform: "scale(2.4)",
      opacity: 0
    }
  });
  const antZoomBadgeIn = new Keyframe("antZoomBadgeIn", {
    "0%": {
      transform: "scale(0) translate(50%, -50%)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1) translate(50%, -50%)"
    }
  });
  const antZoomBadgeOut = new Keyframe("antZoomBadgeOut", {
    "0%": {
      transform: "scale(1) translate(50%, -50%)"
    },
    "100%": {
      transform: "scale(0) translate(50%, -50%)",
      opacity: 0
    }
  });
  const antNoWrapperZoomBadgeIn = new Keyframe("antNoWrapperZoomBadgeIn", {
    "0%": {
      transform: "scale(0)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)"
    }
  });
  const antNoWrapperZoomBadgeOut = new Keyframe("antNoWrapperZoomBadgeOut", {
    "0%": {
      transform: "scale(1)"
    },
    "100%": {
      transform: "scale(0)",
      opacity: 0
    }
  });
  const antBadgeLoadingCircle = new Keyframe("antBadgeLoadingCircle", {
    "0%": {
      transformOrigin: "50%"
    },
    "100%": {
      transform: "translate(50%, -50%) rotate(360deg)",
      transformOrigin: "50%"
    }
  });
  const genSharedBadgeStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      antCls,
      badgeShadowSize,
      textFontSize,
      textFontSizeSM,
      statusSize,
      dotSize,
      textFontWeight,
      indicatorHeight,
      indicatorHeightSM,
      marginXS,
      calc
    } = token2;
    const numberPrefixCls = `${antCls}-scroll-number`;
    const colorPreset = genPresetColor$1(token2, (colorKey, {
      darkColor
    }) => ({
      [`&${componentCls} ${componentCls}-color-${colorKey}`]: {
        background: darkColor,
        [`&:not(${componentCls}-count)`]: {
          color: darkColor
        },
        "a:hover &": {
          background: darkColor
        }
      }
    }));
    return {
      [componentCls]: {
        ...resetComponent(token2),
        position: "relative",
        display: "inline-block",
        width: "fit-content",
        lineHeight: 1,
        [`${componentCls}-count`]: {
          display: "inline-flex",
          justifyContent: "center",
          zIndex: token2.indicatorZIndex,
          minWidth: indicatorHeight,
          height: indicatorHeight,
          color: token2.badgeTextColor,
          fontWeight: textFontWeight,
          fontSize: textFontSize,
          lineHeight: unit$1(indicatorHeight),
          whiteSpace: "nowrap",
          textAlign: "center",
          background: token2.badgeColor,
          borderRadius: calc(indicatorHeight).div(2).equal(),
          boxShadow: `0 0 0 ${unit$1(badgeShadowSize)} ${token2.badgeShadowColor}`,
          transition: `background-color ${token2.motionDurationMid}`,
          a: {
            color: token2.badgeTextColor
          },
          "a:hover": {
            color: token2.badgeTextColor
          },
          "a:hover &": {
            background: token2.badgeColorHover
          }
        },
        [`${componentCls}-count-sm`]: {
          minWidth: indicatorHeightSM,
          height: indicatorHeightSM,
          fontSize: textFontSizeSM,
          lineHeight: unit$1(indicatorHeightSM),
          borderRadius: calc(indicatorHeightSM).div(2).equal()
        },
        [`${componentCls}-multiple-words`]: {
          padding: `0 ${unit$1(token2.paddingXS)}`,
          bdi: {
            unicodeBidi: "plaintext"
          }
        },
        [`${componentCls}-dot`]: {
          zIndex: token2.indicatorZIndex,
          width: dotSize,
          minWidth: dotSize,
          height: dotSize,
          background: token2.badgeColor,
          borderRadius: "100%",
          boxShadow: `0 0 0 ${unit$1(badgeShadowSize)} ${token2.badgeShadowColor}`
        },
        [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          transform: "translate(50%, -50%)",
          transformOrigin: "100% 0%",
          [`&${iconCls}-spin`]: {
            animationName: antBadgeLoadingCircle,
            animationDuration: "1s",
            animationIterationCount: "infinite",
            animationTimingFunction: "linear"
          }
        },
        [`&${componentCls}-status`]: {
          lineHeight: "inherit",
          verticalAlign: "baseline",
          [`${componentCls}-status-dot`]: {
            position: "relative",
            top: -1,
display: "inline-block",
            width: statusSize,
            height: statusSize,
            verticalAlign: "middle",
            borderRadius: "50%"
          },
          [`${componentCls}-status-success`]: {
            backgroundColor: token2.colorSuccess
          },
          [`${componentCls}-status-processing`]: {
            overflow: "visible",
            color: token2.colorInfo,
            backgroundColor: token2.colorInfo,
            borderColor: "currentcolor",
            "&::after": {
              position: "absolute",
              top: 0,
              insetInlineStart: 0,
              width: "100%",
              height: "100%",
              borderWidth: badgeShadowSize,
              borderStyle: "solid",
              borderColor: "inherit",
              borderRadius: "50%",
              animationName: antStatusProcessing,
              animationDuration: token2.badgeProcessingDuration,
              animationIterationCount: "infinite",
              animationTimingFunction: "ease-in-out",
              content: '""'
            }
          },
          [`${componentCls}-status-default`]: {
            backgroundColor: token2.colorTextPlaceholder
          },
          [`${componentCls}-status-error`]: {
            backgroundColor: token2.colorError
          },
          [`${componentCls}-status-warning`]: {
            backgroundColor: token2.colorWarning
          },
          [`${componentCls}-status-text`]: {
            marginInlineStart: marginXS,
            color: token2.colorText,
            fontSize: token2.fontSize
          }
        },
        ...colorPreset,
        [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
          animationName: antZoomBadgeIn,
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: token2.motionEaseOutBack,
          animationFillMode: "both"
        },
        [`${componentCls}-zoom-leave`]: {
          animationName: antZoomBadgeOut,
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: token2.motionEaseOutBack,
          animationFillMode: "both"
        },
        [`&${componentCls}-not-a-wrapper`]: {
          [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
            animationName: antNoWrapperZoomBadgeIn,
            animationDuration: token2.motionDurationSlow,
            animationTimingFunction: token2.motionEaseOutBack
          },
          [`${componentCls}-zoom-leave`]: {
            animationName: antNoWrapperZoomBadgeOut,
            animationDuration: token2.motionDurationSlow,
            animationTimingFunction: token2.motionEaseOutBack
          },
          [`&:not(${componentCls}-status)`]: {
            verticalAlign: "middle"
          },
          [`${numberPrefixCls}-custom-component, ${componentCls}-count`]: {
            transform: "none"
          },
          [`${numberPrefixCls}-custom-component, ${numberPrefixCls}`]: {
            position: "relative",
            top: "auto",
            display: "block",
            transformOrigin: "50% 50%"
          }
        },
        [numberPrefixCls]: {
          overflow: "hidden",
          transition: `all ${token2.motionDurationMid} ${token2.motionEaseOutBack}`,
          [`${numberPrefixCls}-only`]: {
            position: "relative",
            display: "inline-block",
            height: indicatorHeight,
            transition: `all ${token2.motionDurationSlow} ${token2.motionEaseOutBack}`,
            WebkitTransformStyle: "preserve-3d",
            WebkitBackfaceVisibility: "hidden",
            [`> p${numberPrefixCls}-only-unit`]: {
              height: indicatorHeight,
              margin: 0,
              WebkitTransformStyle: "preserve-3d",
              WebkitBackfaceVisibility: "hidden"
            }
          },
          [`${numberPrefixCls}-symbol`]: {
            verticalAlign: "top"
          }
        },
"&-rtl": {
          direction: "rtl",
          [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
            transform: "translate(-50%, -50%)"
          }
        }
      }
    };
  };
  const prepareToken$2 = (token2) => {
    const {
      fontHeight,
      lineWidth,
      marginXS,
      colorBorderBg
    } = token2;
    const badgeFontHeight = fontHeight;
    const badgeShadowSize = lineWidth;
    const badgeTextColor = token2.colorTextLightSolid;
    const badgeColor = token2.colorError;
    const badgeColorHover = token2.colorErrorHover;
    const badgeToken = merge$1(token2, {
      badgeFontHeight,
      badgeShadowSize,
      badgeTextColor,
      badgeColor,
      badgeColorHover,
      badgeShadowColor: colorBorderBg,
      badgeProcessingDuration: "1.2s",
      badgeRibbonOffset: marginXS,
badgeRibbonCornerTransform: "scaleY(0.75)",
      badgeRibbonCornerFilter: `brightness(75%)`
    });
    return badgeToken;
  };
  const prepareComponentToken$h = (token2) => {
    const {
      fontSize,
      lineHeight,
      fontSizeSM,
      lineWidth
    } = token2;
    return {
      indicatorZIndex: "auto",
      indicatorHeight: Math.round(fontSize * lineHeight) - 2 * lineWidth,
      indicatorHeightSM: fontSize,
      dotSize: fontSizeSM / 2,
      textFontSize: fontSizeSM,
      textFontSizeSM: fontSizeSM,
      textFontWeight: "normal",
      statusSize: fontSizeSM / 2
    };
  };
  const useStyle$r = genStyleHooks("Badge", (token2) => {
    const badgeToken = prepareToken$2(token2);
    return genSharedBadgeStyle(badgeToken);
  }, prepareComponentToken$h);
  const Badge$1 = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls: customizePrefixCls,
      scrollNumberPrefixCls: customizeScrollNumberPrefixCls,
      children,
      status,
      text,
      color: color2,
      count = null,
      overflowCount = 99,
      dot = false,
      size = "default",
      title,
      offset: offset2,
      style: style2,
      className,
      rootClassName,
      classNames,
      styles,
      showZero = false,
      ...restProps
    } = props;
    const {
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("badge");
    const prefixCls = getPrefixCls("badge", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$r(prefixCls);
    const mergedProps = {
      ...props,
      overflowCount,
      size,
      dot,
      showZero
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const numberedDisplayCount = count > overflowCount ? `${overflowCount}+` : count;
    const isZero = numberedDisplayCount === "0" || numberedDisplayCount === 0 || text === "0" || text === 0;
    const ignoreCount = count === null || isZero && !showZero;
    const hasStatus = (isNonNullable(status) || isNonNullable(color2)) && ignoreCount;
    const hasStatusValue = isNonNullable(status) || !isZero;
    const showAsDot = dot && !isZero;
    const mergedCount = showAsDot ? "" : numberedDisplayCount;
    const isHidden = reactExports.useMemo(() => {
      const isEmpty2 = (!isNonNullable(mergedCount) || mergedCount === "") && (!isNonNullable(text) || text === "");
      return (isEmpty2 || isZero && !showZero) && !showAsDot;
    }, [mergedCount, isZero, showZero, showAsDot, text]);
    const countRef = reactExports.useRef(count);
    if (!isHidden) {
      countRef.current = count;
    }
    const livingCount = countRef.current;
    const displayCountRef = reactExports.useRef(mergedCount);
    if (!isHidden) {
      displayCountRef.current = mergedCount;
    }
    const displayCount = displayCountRef.current;
    const isDotRef = reactExports.useRef(showAsDot);
    if (!isHidden) {
      isDotRef.current = showAsDot;
    }
    const mergedStyle = reactExports.useMemo(() => {
      if (!offset2) {
        return {
          ...contextStyle,
          ...style2
        };
      }
      const horizontalOffset = Number.parseInt(offset2[0], 10);
      const offsetStyle = {
        marginTop: offset2[1],
        insetInlineEnd: -horizontalOffset
      };
      return {
        ...offsetStyle,
        ...contextStyle,
        ...style2
      };
    }, [offset2, style2, contextStyle]);
    const titleNode = title ?? (typeof livingCount === "string" || typeof livingCount === "number" ? livingCount : void 0);
    const showStatusTextNode = !isHidden && (text === 0 ? showZero : !!text && text !== true);
    const statusTextNode = !showStatusTextNode ? null : reactExports.createElement("span", {
      className: `${prefixCls}-status-text`
    }, text);
    const displayNode = !livingCount || typeof livingCount !== "object" ? void 0 : cloneElement(livingCount, (oriProps) => ({
      style: {
        ...mergedStyle,
        ...oriProps.style
      }
    }));
    const isInternalColor = isPresetColor(color2, false);
    const statusCls = clsx(mergedClassNames.indicator, {
      [`${prefixCls}-status-dot`]: hasStatus,
      [`${prefixCls}-status-${status}`]: !!status,
      [`${prefixCls}-color-${color2}`]: isInternalColor
    });
    const statusStyle = {};
    if (color2 && !isInternalColor) {
      statusStyle.color = color2;
      statusStyle.background = color2;
    }
    const badgeClassName = clsx(prefixCls, {
      [`${prefixCls}-status`]: hasStatus,
      [`${prefixCls}-not-a-wrapper`]: !children,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, rootClassName, contextClassName, mergedClassNames.root, hashId, cssVarCls);
    if (!children && hasStatus && (text || hasStatusValue || !ignoreCount)) {
      const statusTextColor = mergedStyle.color;
      return reactExports.createElement("span", {
        ref: ref2,
        ...restProps,
        className: badgeClassName,
        style: {
          ...mergedStyles.root,
          ...mergedStyle
        }
      }, reactExports.createElement("span", {
        className: statusCls,
        style: {
          ...mergedStyles.indicator,
          ...statusStyle
        }
      }), showStatusTextNode && reactExports.createElement("span", {
        style: {
          color: statusTextColor
        },
        className: `${prefixCls}-status-text`
      }, text));
    }
    return reactExports.createElement("span", {
      ref: ref2,
      ...restProps,
      className: badgeClassName,
      style: mergedStyles.root
    }, children, reactExports.createElement(CSSMotion, {
      visible: !isHidden,
      motionName: `${prefixCls}-zoom`,
      motionAppear: false,
      motionDeadline: 1e3
    }, ({
      className: motionClassName
    }) => {
      const scrollNumberPrefixCls = getPrefixCls("scroll-number", customizeScrollNumberPrefixCls);
      const isDot = isDotRef.current;
      const scrollNumberCls = clsx(mergedClassNames.indicator, {
        [`${prefixCls}-dot`]: isDot,
        [`${prefixCls}-count`]: !isDot,
        [`${prefixCls}-count-sm`]: size === "small",
        [`${prefixCls}-multiple-words`]: !isDot && displayCount && displayCount.toString().length > 1,
        [`${prefixCls}-status-${status}`]: !!status,
        [`${prefixCls}-color-${color2}`]: isInternalColor
      });
      let scrollNumberStyle = {
        ...mergedStyles.indicator,
        ...mergedStyle
      };
      if (color2 && !isInternalColor) {
        scrollNumberStyle = scrollNumberStyle || {};
        scrollNumberStyle.background = color2;
      }
      return reactExports.createElement(ScrollNumber, {
        prefixCls: scrollNumberPrefixCls,
        show: !isHidden,
        motionClassName,
        className: scrollNumberCls,
        count: displayCount,
        title: titleNode,
        style: scrollNumberStyle,
        key: "scrollNumber"
      }, displayNode);
    }), statusTextNode);
  });
  const genRibbonStyle = (token2) => {
    const {
      antCls,
      badgeFontHeight,
      marginXS,
      badgeRibbonOffset,
      calc
    } = token2;
    const ribbonPrefixCls = `${antCls}-ribbon`;
    const ribbonWrapperPrefixCls = `${antCls}-ribbon-wrapper`;
    const statusRibbonPreset = genPresetColor$1(token2, (colorKey, {
      darkColor
    }) => ({
      [`&${ribbonPrefixCls}-color-${colorKey}`]: {
        background: darkColor,
        color: darkColor
      }
    }));
    return {
      [ribbonWrapperPrefixCls]: {
        position: "relative"
      },
      [ribbonPrefixCls]: {
        ...resetComponent(token2),
        position: "absolute",
        top: marginXS,
        padding: `0 ${unit$1(token2.paddingXS)}`,
        color: token2.colorPrimary,
        lineHeight: unit$1(badgeFontHeight),
        whiteSpace: "nowrap",
        backgroundColor: token2.colorPrimary,
        borderRadius: token2.borderRadiusSM,
        [`${ribbonPrefixCls}-content`]: {
          color: token2.badgeTextColor
        },
        [`${ribbonPrefixCls}-corner`]: {
          position: "absolute",
          top: "100%",
          width: badgeRibbonOffset,
          height: badgeRibbonOffset,
          color: "currentcolor",
          border: `${unit$1(calc(badgeRibbonOffset).div(2).equal())} solid`,
          transform: token2.badgeRibbonCornerTransform,
          transformOrigin: "top",
          filter: token2.badgeRibbonCornerFilter
        },
        ...statusRibbonPreset,
        [`&${ribbonPrefixCls}-placement-end`]: {
          insetInlineEnd: calc(badgeRibbonOffset).mul(-1).equal(),
          borderEndEndRadius: 0,
          [`${ribbonPrefixCls}-corner`]: {
            insetInlineEnd: 0,
            borderInlineEndColor: "transparent",
            borderBlockEndColor: "transparent"
          }
        },
        [`&${ribbonPrefixCls}-placement-start`]: {
          insetInlineStart: calc(badgeRibbonOffset).mul(-1).equal(),
          borderEndStartRadius: 0,
          [`${ribbonPrefixCls}-corner`]: {
            insetInlineStart: 0,
            borderBlockEndColor: "transparent",
            borderInlineStartColor: "transparent"
          }
        },
"&-rtl": {
          direction: "rtl"
        }
      }
    };
  };
  const useStyle$q = genStyleHooks(["Badge", "Ribbon"], (token2) => {
    const badgeToken = prepareToken$2(token2);
    return genRibbonStyle(badgeToken);
  }, prepareComponentToken$h);
  const Ribbon = (props) => {
    const {
      className,
      prefixCls: customizePrefixCls,
      style: style2,
      color: color2,
      children,
      text,
      placement = "end",
      rootClassName,
      styles,
      classNames: ribbonClassNames
    } = props;
    const {
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("ribbon");
    const prefixCls = getPrefixCls("ribbon", customizePrefixCls);
    const wrapperCls = `${prefixCls}-wrapper`;
    const [hashId, cssVarCls] = useStyle$q(prefixCls, wrapperCls);
    const mergedProps = {
      ...props,
      placement
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, ribbonClassNames], [contextStyles, styles], {
      props: mergedProps
    });
    const colorInPreset = isPresetColor(color2, false);
    const ribbonCls = clsx(prefixCls, `${prefixCls}-placement-${placement}`, {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-color-${color2}`]: colorInPreset
    }, className, contextClassName, mergedClassNames.indicator);
    const colorStyle = {};
    const cornerColorStyle = {};
    if (color2 && !colorInPreset) {
      colorStyle.background = color2;
      cornerColorStyle.color = color2;
    }
    return reactExports.createElement("div", {
      className: clsx(wrapperCls, rootClassName, hashId, cssVarCls, mergedClassNames.root),
      style: mergedStyles.root
    }, children, reactExports.createElement("div", {
      className: clsx(ribbonCls, hashId),
      style: {
        ...colorStyle,
        ...mergedStyles.indicator,
        ...contextStyle,
        ...style2
      }
    }, reactExports.createElement("span", {
      className: clsx(`${prefixCls}-content`, mergedClassNames.content),
      style: mergedStyles.content
    }, text), reactExports.createElement("div", {
      className: `${prefixCls}-corner`,
      style: cornerColorStyle
    })));
  };
  const Badge = Badge$1;
  Badge.Ribbon = Ribbon;
  var LeftOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, "name": "left", "theme": "outlined" };
  function _extends$x() {
    _extends$x = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$x.apply(this, arguments);
  }
  const LeftOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends$x({}, props, {
    ref: ref2,
    icon: LeftOutlined$1
  }));
  const RefIcon$b = reactExports.forwardRef(LeftOutlined);
  const {
    ESC: ESC$1,
    TAB
  } = KeyCode;
  function useAccessibility$1({
    visible,
    triggerRef,
    onVisibleChange,
    autoFocus,
    overlayRef
  }) {
    const focusMenuRef = reactExports.useRef(false);
    const handleCloseMenuAndReturnFocus = () => {
      if (visible) {
        triggerRef.current?.focus?.();
        onVisibleChange?.(false);
      }
    };
    const focusMenu = () => {
      if (overlayRef.current?.focus) {
        overlayRef.current.focus();
        focusMenuRef.current = true;
        return true;
      }
      return false;
    };
    const handleKeyDown = (event) => {
      switch (event.keyCode) {
        case ESC$1:
          handleCloseMenuAndReturnFocus();
          break;
        case TAB: {
          let focusResult = false;
          if (!focusMenuRef.current) {
            focusResult = focusMenu();
          }
          if (focusResult) {
            event.preventDefault();
          } else {
            handleCloseMenuAndReturnFocus();
          }
          break;
        }
      }
    };
    reactExports.useEffect(() => {
      if (visible) {
        window.addEventListener("keydown", handleKeyDown);
        if (autoFocus) {
          wrapperRaf(focusMenu, 3);
        }
        return () => {
          window.removeEventListener("keydown", handleKeyDown);
          focusMenuRef.current = false;
        };
      }
      return () => {
        focusMenuRef.current = false;
      };
    }, [visible]);
  }
  const Overlay$1 = reactExports.forwardRef((props, ref2) => {
    const {
      overlay,
      arrow,
      prefixCls
    } = props;
    const overlayNode = reactExports.useMemo(() => {
      let overlayElement;
      if (typeof overlay === "function") {
        overlayElement = overlay();
      } else {
        overlayElement = overlay;
      }
      return overlayElement;
    }, [overlay]);
    const composedRef = composeRef(ref2, getNodeRef(overlayNode));
    return React.createElement(React.Fragment, null, arrow && React.createElement("div", {
      className: `${prefixCls}-arrow`
    }), React.cloneElement(overlayNode, {
      ref: supportRef(overlayNode) ? composedRef : void 0
    }));
  });
  const autoAdjustOverflow$1 = {
    adjustX: 1,
    adjustY: 1
  };
  const targetOffset = [0, 0];
  const placements$1 = {
    topLeft: {
      points: ["bl", "tl"],
      overflow: autoAdjustOverflow$1,
      offset: [0, -4],
      targetOffset
    },
    top: {
      points: ["bc", "tc"],
      overflow: autoAdjustOverflow$1,
      offset: [0, -4],
      targetOffset
    },
    topRight: {
      points: ["br", "tr"],
      overflow: autoAdjustOverflow$1,
      offset: [0, -4],
      targetOffset
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: autoAdjustOverflow$1,
      offset: [0, 4],
      targetOffset
    },
    bottom: {
      points: ["tc", "bc"],
      overflow: autoAdjustOverflow$1,
      offset: [0, 4],
      targetOffset
    },
    bottomRight: {
      points: ["tr", "br"],
      overflow: autoAdjustOverflow$1,
      offset: [0, 4],
      targetOffset
    }
  };
  function _extends$w() {
    _extends$w = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$w.apply(this, arguments);
  }
  const Dropdown$2 = React.forwardRef((props, ref2) => {
    const {
      arrow = false,
      prefixCls = "rc-dropdown",
      transitionName,
      animation,
      align,
      placement = "bottomLeft",
      placements: placements2 = placements$1,
      getPopupContainer,
      showAction,
      hideAction,
      overlayClassName,
      overlayStyle,
      visible,
      trigger: trigger2 = ["hover"],
      autoFocus,
      overlay,
      children,
      onVisibleChange,
      ...otherProps
    } = props;
    const [triggerVisible, setTriggerVisible] = React.useState();
    const mergedVisible = "visible" in props ? visible : triggerVisible;
    const mergedMotionName = animation ? `${prefixCls}-${animation}` : transitionName;
    const triggerRef = React.useRef(null);
    const overlayRef = React.useRef(null);
    const childRef = React.useRef(null);
    React.useImperativeHandle(ref2, () => triggerRef.current);
    const handleVisibleChange = (newVisible) => {
      setTriggerVisible(newVisible);
      onVisibleChange?.(newVisible);
    };
    useAccessibility$1({
      visible: mergedVisible,
      triggerRef: childRef,
      onVisibleChange: handleVisibleChange,
      autoFocus,
      overlayRef
    });
    const onClick = (e) => {
      const {
        onOverlayClick
      } = props;
      setTriggerVisible(false);
      if (onOverlayClick) {
        onOverlayClick(e);
      }
    };
    const getMenuElement = () => React.createElement(Overlay$1, {
      ref: overlayRef,
      overlay,
      prefixCls,
      arrow
    });
    const getMenuElementOrLambda = () => {
      if (typeof overlay === "function") {
        return getMenuElement;
      }
      return getMenuElement();
    };
    const getMinOverlayWidthMatchTrigger = () => {
      const {
        minOverlayWidthMatchTrigger,
        alignPoint
      } = props;
      if ("minOverlayWidthMatchTrigger" in props) {
        return minOverlayWidthMatchTrigger;
      }
      return !alignPoint;
    };
    const getOpenClassName = () => {
      const {
        openClassName
      } = props;
      if (openClassName !== void 0) {
        return openClassName;
      }
      return `${prefixCls}-open`;
    };
    const childrenNode = React.cloneElement(children, {
      className: clsx(children.props?.className, mergedVisible && getOpenClassName()),
      ref: supportRef(children) ? composeRef(childRef, getNodeRef(children)) : void 0
    });
    let triggerHideAction = hideAction;
    if (!triggerHideAction && trigger2.indexOf("contextMenu") !== -1) {
      triggerHideAction = ["click"];
    }
    return React.createElement(Trigger, _extends$w({
      builtinPlacements: placements2
    }, otherProps, {
      prefixCls,
      ref: triggerRef,
      popupClassName: clsx(overlayClassName, {
        [`${prefixCls}-show-arrow`]: arrow
      }),
      popupStyle: overlayStyle,
      action: trigger2,
      showAction,
      hideAction: triggerHideAction,
      popupPlacement: placement,
      popupAlign: align,
      popupMotion: {
        motionName: mergedMotionName
      },
      popupVisible: mergedVisible,
      stretch: getMinOverlayWidthMatchTrigger() ? "minWidth" : "",
      popup: getMenuElementOrLambda(),
      onOpenChange: handleVisibleChange,
      onPopupClick: onClick,
      getPopupContainer
    }), childrenNode);
  });
  const isPrimitive = (value) => typeof value !== "object" && typeof value !== "function" || value === null;
  const IdContext = reactExports.createContext(null);
  function getMenuId(uuid2, eventKey) {
    return `${uuid2}-${eventKey}`;
  }
  function useMenuId(eventKey) {
    const id2 = reactExports.useContext(IdContext);
    return getMenuId(id2, eventKey);
  }
  const MenuContext$1 = reactExports.createContext(null);
  function mergeProps(origin, target) {
    const clone2 = {
      ...origin
    };
    Object.keys(target).forEach((key) => {
      const value = target[key];
      if (value !== void 0) {
        clone2[key] = value;
      }
    });
    return clone2;
  }
  function InheritableContextProvider({
    children,
    locked,
    ...restProps
  }) {
    const context = reactExports.useContext(MenuContext$1);
    const inheritableContext = useMemo(() => mergeProps(context, restProps), [context, restProps], (prev2, next2) => !locked && (prev2[0] !== next2[0] || !isEqual$1(prev2[1], next2[1], true)));
    return reactExports.createElement(MenuContext$1.Provider, {
      value: inheritableContext
    }, children);
  }
  const EmptyList = [];
  const PathRegisterContext = reactExports.createContext(null);
  function useMeasure() {
    return reactExports.useContext(PathRegisterContext);
  }
  const PathTrackerContext = reactExports.createContext(EmptyList);
  function useFullPath(eventKey) {
    const parentKeyPath = reactExports.useContext(PathTrackerContext);
    return reactExports.useMemo(() => eventKey !== void 0 ? [...parentKeyPath, eventKey] : parentKeyPath, [parentKeyPath, eventKey]);
  }
  const PathUserContext = reactExports.createContext(null);
  const PrivateContext = reactExports.createContext({});
  const {
    LEFT,
    RIGHT,
    UP,
    DOWN,
    ENTER,
    ESC,
    HOME,
    END
  } = KeyCode;
  const ArrowKeys = [UP, DOWN, LEFT, RIGHT];
  function getOffset$1(mode, isRootLevel, isRtl, which) {
    const prev2 = "prev";
    const next2 = "next";
    const children = "children";
    const parent = "parent";
    if (mode === "inline" && which === ENTER) {
      return {
        inlineTrigger: true
      };
    }
    const inline2 = {
      [UP]: prev2,
      [DOWN]: next2
    };
    const horizontal = {
      [LEFT]: isRtl ? next2 : prev2,
      [RIGHT]: isRtl ? prev2 : next2,
      [DOWN]: children,
      [ENTER]: children
    };
    const vertical = {
      [UP]: prev2,
      [DOWN]: next2,
      [ENTER]: children,
      [ESC]: parent,
      [LEFT]: isRtl ? children : parent,
      [RIGHT]: isRtl ? parent : children
    };
    const offsets = {
      inline: inline2,
      horizontal,
      vertical,
      inlineSub: inline2,
      horizontalSub: vertical,
      verticalSub: vertical
    };
    const type4 = offsets[`${mode}${isRootLevel ? "" : "Sub"}`]?.[which];
    switch (type4) {
      case prev2:
        return {
          offset: -1,
          sibling: true
        };
      case next2:
        return {
          offset: 1,
          sibling: true
        };
      case parent:
        return {
          offset: -1,
          sibling: false
        };
      case children:
        return {
          offset: 1,
          sibling: false
        };
      default:
        return null;
    }
  }
  function findContainerUL(element) {
    let current = element;
    while (current) {
      if (current.getAttribute("data-menu-list")) {
        return current;
      }
      current = current.parentElement;
    }
    return null;
  }
  function getFocusElement(activeElement, elements) {
    let current = activeElement || document.activeElement;
    while (current) {
      if (elements.has(current)) {
        return current;
      }
      current = current.parentElement;
    }
    return null;
  }
  function getFocusableElements(container, elements) {
    const list2 = getFocusNodeList(container, true);
    return list2.filter((ele) => elements.has(ele));
  }
  function getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offset2 = 1) {
    if (!parentQueryContainer) {
      return null;
    }
    const sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);
    const count = sameLevelFocusableMenuElementList.length;
    let focusIndex = sameLevelFocusableMenuElementList.findIndex((ele) => focusMenuElement === ele);
    if (offset2 < 0) {
      if (focusIndex === -1) {
        focusIndex = count - 1;
      } else {
        focusIndex -= 1;
      }
    } else if (offset2 > 0) {
      focusIndex += 1;
    }
    focusIndex = (focusIndex + count) % count;
    return sameLevelFocusableMenuElementList[focusIndex];
  }
  const refreshElements = (keys2, id2) => {
    const elements = new Set();
    const key2element = new Map();
    const element2key = new Map();
    keys2.forEach((key) => {
      const element = document.querySelector(`[data-menu-id='${getMenuId(id2, key)}']`);
      if (element) {
        elements.add(element);
        element2key.set(element, key);
        key2element.set(key, element);
      }
    });
    return {
      elements,
      key2element,
      element2key
    };
  };
  function useAccessibility(mode, activeKey, isRtl, id2, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
    const rafRef = reactExports.useRef();
    const activeRef = reactExports.useRef();
    activeRef.current = activeKey;
    const cleanRaf = () => {
      wrapperRaf.cancel(rafRef.current);
    };
    reactExports.useEffect(() => () => {
      cleanRaf();
    }, []);
    return (e) => {
      const {
        which
      } = e;
      if ([...ArrowKeys, ENTER, ESC, HOME, END].includes(which)) {
        const keys2 = getKeys();
        let refreshedElements = refreshElements(keys2, id2);
        const {
          elements,
          key2element,
          element2key
        } = refreshedElements;
        const activeElement = key2element.get(activeKey);
        const focusMenuElement = getFocusElement(activeElement, elements);
        const focusMenuKey = element2key.get(focusMenuElement);
        const offsetObj = getOffset$1(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);
        if (!offsetObj && which !== HOME && which !== END) {
          return;
        }
        if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {
          e.preventDefault();
        }
        const tryFocus = (menuElement) => {
          if (menuElement) {
            let focusTargetElement = menuElement;
            const link = menuElement.querySelector("a");
            if (link?.getAttribute("href")) {
              focusTargetElement = link;
            }
            const targetKey = element2key.get(menuElement);
            triggerActiveKey(targetKey);
            cleanRaf();
            rafRef.current = wrapperRaf(() => {
              if (activeRef.current === targetKey) {
                focusTargetElement.focus();
              }
            });
          }
        };
        if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
          let parentQueryContainer;
          if (!focusMenuElement || mode === "inline") {
            parentQueryContainer = containerRef.current;
          } else {
            parentQueryContainer = findContainerUL(focusMenuElement);
          }
          let targetElement;
          const focusableElements = getFocusableElements(parentQueryContainer, elements);
          if (which === HOME) {
            targetElement = focusableElements[0];
          } else if (which === END) {
            targetElement = focusableElements[focusableElements.length - 1];
          } else {
            targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);
          }
          tryFocus(targetElement);
        } else if (offsetObj.inlineTrigger) {
          triggerAccessibilityOpen(focusMenuKey);
        } else if (offsetObj.offset > 0) {
          triggerAccessibilityOpen(focusMenuKey, true);
          cleanRaf();
          rafRef.current = wrapperRaf(() => {
            refreshedElements = refreshElements(keys2, id2);
            const controlId = focusMenuElement.getAttribute("aria-controls");
            const subQueryContainer = document.getElementById(controlId);
            const targetElement = getNextFocusElement(subQueryContainer, refreshedElements.elements);
            tryFocus(targetElement);
          }, 5);
        } else if (offsetObj.offset < 0) {
          const keyPath = getKeyPath(focusMenuKey, true);
          const parentKey = keyPath[keyPath.length - 2];
          const parentMenuElement = key2element.get(parentKey);
          triggerAccessibilityOpen(parentKey, false);
          tryFocus(parentMenuElement);
        }
      }
      originOnKeyDown?.(e);
    };
  }
  function nextSlice(callback) {
    Promise.resolve().then(callback);
  }
  const PATH_SPLIT = "__RC_UTIL_PATH_SPLIT__";
  const getPathStr = (keyPath) => keyPath.join(PATH_SPLIT);
  const getPathKeys = (keyPathStr) => keyPathStr.split(PATH_SPLIT);
  const OVERFLOW_KEY = "rc-menu-more";
  function useKeyRecords() {
    const [, internalForceUpdate] = reactExports.useState({});
    const key2pathRef = reactExports.useRef( new Map());
    const path2keyRef = reactExports.useRef( new Map());
    const [overflowKeys, setOverflowKeys] = reactExports.useState([]);
    const updateRef = reactExports.useRef(0);
    const destroyRef = reactExports.useRef(false);
    const forceUpdate = () => {
      if (!destroyRef.current) {
        internalForceUpdate({});
      }
    };
    const registerPath = reactExports.useCallback((key, keyPath) => {
      const connectedPath = getPathStr(keyPath);
      path2keyRef.current.set(connectedPath, key);
      key2pathRef.current.set(key, connectedPath);
      updateRef.current += 1;
      const id2 = updateRef.current;
      nextSlice(() => {
        if (id2 === updateRef.current) {
          forceUpdate();
        }
      });
    }, []);
    const unregisterPath = reactExports.useCallback((key, keyPath) => {
      const connectedPath = getPathStr(keyPath);
      path2keyRef.current.delete(connectedPath);
      key2pathRef.current.delete(key);
    }, []);
    const refreshOverflowKeys = reactExports.useCallback((keys2) => {
      setOverflowKeys(keys2);
    }, []);
    const getKeyPath = reactExports.useCallback((eventKey, includeOverflow) => {
      const fullPath = key2pathRef.current.get(eventKey) || "";
      const keys2 = getPathKeys(fullPath);
      if (includeOverflow && overflowKeys.includes(keys2[0])) {
        keys2.unshift(OVERFLOW_KEY);
      }
      return keys2;
    }, [overflowKeys]);
    const isSubPathKey = reactExports.useCallback((pathKeys, eventKey) => pathKeys.filter((item) => item !== void 0).some((pathKey2) => {
      const pathKeyList = getKeyPath(pathKey2, true);
      return pathKeyList.includes(eventKey);
    }), [getKeyPath]);
    const getKeys = () => {
      const keys2 = [...key2pathRef.current.keys()];
      if (overflowKeys.length) {
        keys2.push(OVERFLOW_KEY);
      }
      return keys2;
    };
    const getSubPathKeys = reactExports.useCallback((key) => {
      const connectedPath = `${key2pathRef.current.get(key)}${PATH_SPLIT}`;
      const pathKeys = new Set();
      [...path2keyRef.current.keys()].forEach((pathKey2) => {
        if (pathKey2.startsWith(connectedPath)) {
          pathKeys.add(path2keyRef.current.get(pathKey2));
        }
      });
      return pathKeys;
    }, []);
    reactExports.useEffect(() => () => {
      destroyRef.current = true;
    }, []);
    return {
registerPath,
      unregisterPath,
      refreshOverflowKeys,
isSubPathKey,
      getKeyPath,
      getKeys,
      getSubPathKeys
    };
  }
  function useMemoCallback(func) {
    const funRef = reactExports.useRef(func);
    funRef.current = func;
    const callback = reactExports.useCallback((...args) => funRef.current?.(...args), []);
    return func ? callback : void 0;
  }
  function useActive(eventKey, disabled, onMouseEnter, onMouseLeave) {
    const {
activeKey,
      onActive,
      onInactive
    } = reactExports.useContext(MenuContext$1);
    const ret = {
      active: activeKey === eventKey
    };
    if (!disabled) {
      ret.onMouseEnter = (domEvent) => {
        onMouseEnter?.({
          key: eventKey,
          domEvent
        });
        onActive(eventKey);
      };
      ret.onMouseLeave = (domEvent) => {
        onMouseLeave?.({
          key: eventKey,
          domEvent
        });
        onInactive(eventKey);
      };
    }
    return ret;
  }
  function useDirectionStyle(level) {
    const {
      mode,
      rtl,
      inlineIndent
    } = reactExports.useContext(MenuContext$1);
    if (mode !== "inline") {
      return null;
    }
    const len = level;
    return rtl ? {
      paddingRight: len * inlineIndent
    } : {
      paddingLeft: len * inlineIndent
    };
  }
  function Icon({
    icon,
    props,
    children
  }) {
    let iconNode;
    if (icon === null || icon === false) {
      return null;
    }
    if (typeof icon === "function") {
      iconNode = reactExports.createElement(icon, {
        ...props
      });
    } else if (typeof icon !== "boolean") {
      iconNode = icon;
    }
    return iconNode || children || null;
  }
  function warnItemProp({
    item,
    ...restInfo
  }) {
    Object.defineProperty(restInfo, "item", {
      get: () => {
        warningOnce(false, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future.");
        return item;
      }
    });
    return restInfo;
  }
  function _extends$v() {
    _extends$v = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$v.apply(this, arguments);
  }
  class LegacyMenuItem extends reactExports.Component {
    render() {
      const {
        title,
        attribute,
        elementRef,
        ...restProps
      } = this.props;
      const passedProps = omit(restProps, ["eventKey", "popupClassName", "popupOffset", "onTitleClick"]);
      warningOnce(!attribute, "`attribute` of Menu.Item is deprecated. Please pass attribute directly.");
      return reactExports.createElement(ForwardOverflow.Item, _extends$v({}, attribute, {
        title: typeof title === "string" ? title : void 0
      }, passedProps, {
        ref: elementRef
      }));
    }
  }
  const InternalMenuItem = reactExports.forwardRef((props, ref2) => {
    const {
      style: style2,
      className,
      eventKey,
      warnKey,
      disabled,
      itemIcon,
      children,
role,
onMouseEnter,
      onMouseLeave,
      onClick,
      onKeyDown,
      onFocus,
      ...restProps
    } = props;
    const domDataId = useMenuId(eventKey);
    const {
      prefixCls,
      onItemClick,
      disabled: contextDisabled,
      overflowDisabled,
itemIcon: contextItemIcon,
selectedKeys,
onActive
    } = reactExports.useContext(MenuContext$1);
    const {
      _internalRenderMenuItem
    } = reactExports.useContext(PrivateContext);
    const itemCls = `${prefixCls}-item`;
    const legacyMenuItemRef = reactExports.useRef();
    const elementRef = reactExports.useRef();
    const mergedDisabled = contextDisabled || disabled;
    const mergedEleRef = useComposeRef(ref2, elementRef);
    const connectedKeys = useFullPath(eventKey);
    const getEventInfo = (e) => {
      return {
        key: eventKey,
keyPath: [...connectedKeys].reverse(),
        item: legacyMenuItemRef.current,
        domEvent: e
      };
    };
    const mergedItemIcon = itemIcon || contextItemIcon;
    const {
      active,
      ...activeProps
    } = useActive(eventKey, mergedDisabled, onMouseEnter, onMouseLeave);
    const selected = selectedKeys.includes(eventKey);
    const directionStyle = useDirectionStyle(connectedKeys.length);
    const onInternalClick = (e) => {
      if (mergedDisabled) {
        return;
      }
      const info = getEventInfo(e);
      onClick?.(warnItemProp(info));
      onItemClick(info);
    };
    const onInternalKeyDown = (e) => {
      onKeyDown?.(e);
      if (e.which === KeyCode.ENTER) {
        const info = getEventInfo(e);
        onClick?.(warnItemProp(info));
        onItemClick(info);
      }
    };
    const onInternalFocus = (e) => {
      onActive(eventKey);
      onFocus?.(e);
    };
    const optionRoleProps = {};
    if (props.role === "option") {
      optionRoleProps["aria-selected"] = selected;
    }
    let renderNode = reactExports.createElement(LegacyMenuItem, _extends$v({
      ref: legacyMenuItemRef,
      elementRef: mergedEleRef,
      role: role === null ? "none" : role || "menuitem",
      tabIndex: disabled ? null : -1,
      "data-menu-id": overflowDisabled && domDataId ? null : domDataId
    }, omit(restProps, ["extra"]), activeProps, optionRoleProps, {
      component: "li",
      "aria-disabled": disabled,
      style: {
        ...directionStyle,
        ...style2
      },
      className: clsx(itemCls, {
        [`${itemCls}-active`]: active,
        [`${itemCls}-selected`]: selected,
        [`${itemCls}-disabled`]: mergedDisabled
      }, className),
      onClick: onInternalClick,
      onKeyDown: onInternalKeyDown,
      onFocus: onInternalFocus
    }), children, reactExports.createElement(Icon, {
      props: {
        ...props,
        isSelected: selected
      },
      icon: mergedItemIcon
    }));
    if (_internalRenderMenuItem) {
      renderNode = _internalRenderMenuItem(renderNode, props, {
        selected
      });
    }
    return renderNode;
  });
  function MenuItem$1(props, ref2) {
    const {
      eventKey
    } = props;
    const measure = useMeasure();
    const connectedKeyPath = useFullPath(eventKey);
    reactExports.useEffect(() => {
      if (measure) {
        measure.registerPath(eventKey, connectedKeyPath);
        return () => {
          measure.unregisterPath(eventKey, connectedKeyPath);
        };
      }
    }, [connectedKeyPath]);
    if (measure) {
      return null;
    }
    return reactExports.createElement(InternalMenuItem, _extends$v({}, props, {
      ref: ref2
    }));
  }
  const MenuItem$2 = reactExports.forwardRef(MenuItem$1);
  function _extends$u() {
    _extends$u = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$u.apply(this, arguments);
  }
  const InternalSubMenuList = ({
    className,
    children,
    ...restProps
  }, ref2) => {
    const {
      prefixCls,
      mode,
      rtl
    } = reactExports.useContext(MenuContext$1);
    return reactExports.createElement("ul", _extends$u({
      className: clsx(prefixCls, rtl && `${prefixCls}-rtl`, `${prefixCls}-sub`, `${prefixCls}-${mode === "inline" ? "inline" : "vertical"}`, className),
      role: "menu"
    }, restProps, {
      "data-menu-list": true,
      ref: ref2
    }), children);
  };
  const SubMenuList = reactExports.forwardRef(InternalSubMenuList);
  function parseChildren(children, keyPath) {
    return toArray$4(children).map((child, index) => {
      if ( reactExports.isValidElement(child)) {
        const {
          key
        } = child;
        let eventKey = child.props?.eventKey ?? key;
        const emptyKey = eventKey === null || eventKey === void 0;
        if (emptyKey) {
          eventKey = `tmp_key-${[...keyPath, index].join("-")}`;
        }
        const cloneProps = {
          key: eventKey,
          eventKey
        };
        return reactExports.cloneElement(child, cloneProps);
      }
      return child;
    });
  }
  const autoAdjustOverflow = {
    adjustX: 1,
    adjustY: 1
  };
  const placements = {
    topLeft: {
      points: ["bl", "tl"],
      overflow: autoAdjustOverflow
    },
    topRight: {
      points: ["br", "tr"],
      overflow: autoAdjustOverflow
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: autoAdjustOverflow
    },
    bottomRight: {
      points: ["tr", "br"],
      overflow: autoAdjustOverflow
    },
    leftTop: {
      points: ["tr", "tl"],
      overflow: autoAdjustOverflow
    },
    leftBottom: {
      points: ["br", "bl"],
      overflow: autoAdjustOverflow
    },
    rightTop: {
      points: ["tl", "tr"],
      overflow: autoAdjustOverflow
    },
    rightBottom: {
      points: ["bl", "br"],
      overflow: autoAdjustOverflow
    }
  };
  const placementsRtl = {
    topLeft: {
      points: ["bl", "tl"],
      overflow: autoAdjustOverflow
    },
    topRight: {
      points: ["br", "tr"],
      overflow: autoAdjustOverflow
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: autoAdjustOverflow
    },
    bottomRight: {
      points: ["tr", "br"],
      overflow: autoAdjustOverflow
    },
    rightTop: {
      points: ["tr", "tl"],
      overflow: autoAdjustOverflow
    },
    rightBottom: {
      points: ["br", "bl"],
      overflow: autoAdjustOverflow
    },
    leftTop: {
      points: ["tl", "tr"],
      overflow: autoAdjustOverflow
    },
    leftBottom: {
      points: ["bl", "br"],
      overflow: autoAdjustOverflow
    }
  };
  function getMotion(mode, motion2, defaultMotions) {
    if (motion2) {
      return motion2;
    }
    if (defaultMotions) {
      return defaultMotions[mode] || defaultMotions.other;
    }
    return void 0;
  }
  const popupPlacementMap = {
    horizontal: "bottomLeft",
    vertical: "rightTop",
    "vertical-left": "rightTop",
    "vertical-right": "leftTop"
  };
  function PopupTrigger({
    prefixCls,
    visible,
    children,
    popup,
    popupStyle,
    popupClassName,
    popupOffset,
    disabled,
    mode,
    onVisibleChange
  }) {
    const {
      getPopupContainer,
      rtl,
      subMenuOpenDelay,
      subMenuCloseDelay,
      builtinPlacements,
      triggerSubMenuAction,
      forceSubMenuRender,
      rootClassName,
motion: motion2,
      defaultMotions
    } = reactExports.useContext(MenuContext$1);
    const [innerVisible, setInnerVisible] = reactExports.useState(false);
    const placement = rtl ? {
      ...placementsRtl,
      ...builtinPlacements
    } : {
      ...placements,
      ...builtinPlacements
    };
    const popupPlacement = popupPlacementMap[mode];
    const targetMotion = getMotion(mode, motion2, defaultMotions);
    const targetMotionRef = reactExports.useRef(targetMotion);
    if (mode !== "inline") {
      targetMotionRef.current = targetMotion;
    }
    const mergedMotion = {
      ...targetMotionRef.current,
      leavedClassName: `${prefixCls}-hidden`,
      removeOnLeave: false,
      motionAppear: true
    };
    const visibleRef = reactExports.useRef();
    reactExports.useEffect(() => {
      visibleRef.current = wrapperRaf(() => {
        setInnerVisible(visible);
      });
      return () => {
        wrapperRaf.cancel(visibleRef.current);
      };
    }, [visible]);
    return reactExports.createElement(Trigger, {
      prefixCls,
      popupClassName: clsx(`${prefixCls}-popup`, {
        [`${prefixCls}-rtl`]: rtl
      }, popupClassName, rootClassName),
      stretch: mode === "horizontal" ? "minWidth" : null,
      getPopupContainer,
      builtinPlacements: placement,
      popupPlacement,
      popupVisible: innerVisible,
      popup,
      popupStyle,
      popupAlign: popupOffset && {
        offset: popupOffset
      },
      action: disabled ? [] : [triggerSubMenuAction],
      mouseEnterDelay: subMenuOpenDelay,
      mouseLeaveDelay: subMenuCloseDelay,
      onPopupVisibleChange: onVisibleChange,
      forceRender: forceSubMenuRender,
      popupMotion: mergedMotion,
      fresh: true
    }, children);
  }
  function _extends$t() {
    _extends$t = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$t.apply(this, arguments);
  }
  function InlineSubMenuList({
    id: id2,
    open: open2,
    keyPath,
    children
  }) {
    const fixedMode = "inline";
    const {
      prefixCls,
      forceSubMenuRender,
      motion: motion2,
      defaultMotions,
      mode
    } = reactExports.useContext(MenuContext$1);
    const sameModeRef = reactExports.useRef(false);
    sameModeRef.current = mode === fixedMode;
    const [destroy2, setDestroy] = reactExports.useState(!sameModeRef.current);
    const mergedOpen = sameModeRef.current ? open2 : false;
    reactExports.useEffect(() => {
      if (sameModeRef.current) {
        setDestroy(false);
      }
    }, [mode]);
    const mergedMotion = {
      ...getMotion(fixedMode, motion2, defaultMotions)
    };
    if (keyPath.length > 1) {
      mergedMotion.motionAppear = false;
    }
    const originOnVisibleChanged = mergedMotion.onVisibleChanged;
    mergedMotion.onVisibleChanged = (newVisible) => {
      if (!sameModeRef.current && !newVisible) {
        setDestroy(true);
      }
      return originOnVisibleChanged?.(newVisible);
    };
    if (destroy2) {
      return null;
    }
    return reactExports.createElement(InheritableContextProvider, {
      mode: fixedMode,
      locked: !sameModeRef.current
    }, reactExports.createElement(CSSMotion, _extends$t({
      visible: mergedOpen
    }, mergedMotion, {
      forceRender: forceSubMenuRender,
      removeOnLeave: false,
      leavedClassName: `${prefixCls}-hidden`
    }), ({
      className: motionClassName,
      style: motionStyle
    }) => {
      return reactExports.createElement(SubMenuList, {
        id: id2,
        className: motionClassName,
        style: motionStyle
      }, children);
    }));
  }
  function _extends$s() {
    _extends$s = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$s.apply(this, arguments);
  }
  const InternalSubMenu = reactExports.forwardRef((props, ref2) => {
    const {
      style: style2,
      className,
      styles,
      classNames: menuClassNames,
      title,
      eventKey,
      warnKey,
      disabled,
      internalPopupClose,
      children,
itemIcon,
      expandIcon,
popupClassName,
      popupOffset,
      popupStyle,
onClick,
      onMouseEnter,
      onMouseLeave,
      onTitleClick,
      onTitleMouseEnter,
      onTitleMouseLeave,
      popupRender: propsPopupRender,
      ...restProps
    } = props;
    const domDataId = useMenuId(eventKey);
    const {
      prefixCls,
      mode,
      openKeys,
disabled: contextDisabled,
      overflowDisabled,
activeKey,
selectedKeys,
itemIcon: contextItemIcon,
      expandIcon: contextExpandIcon,
onItemClick,
      onOpenChange,
      onActive,
      popupRender: contextPopupRender
    } = reactExports.useContext(MenuContext$1);
    const {
      _internalRenderSubMenuItem
    } = reactExports.useContext(PrivateContext);
    const {
      isSubPathKey
    } = reactExports.useContext(PathUserContext);
    const connectedPath = useFullPath();
    const subMenuPrefixCls = `${prefixCls}-submenu`;
    const mergedDisabled = contextDisabled || disabled;
    const elementRef = reactExports.useRef();
    const popupRef = reactExports.useRef();
    const mergedItemIcon = itemIcon ?? contextItemIcon;
    const mergedExpandIcon = expandIcon ?? contextExpandIcon;
    const originOpen = openKeys.includes(eventKey);
    const open2 = !overflowDisabled && originOpen;
    const childrenSelected = isSubPathKey(selectedKeys, eventKey);
    const {
      active,
      ...activeProps
    } = useActive(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave);
    const [childrenActive, setChildrenActive] = reactExports.useState(false);
    const triggerChildrenActive = (newActive) => {
      if (!mergedDisabled) {
        setChildrenActive(newActive);
      }
    };
    const onInternalMouseEnter = (domEvent) => {
      triggerChildrenActive(true);
      onMouseEnter?.({
        key: eventKey,
        domEvent
      });
    };
    const onInternalMouseLeave = (domEvent) => {
      triggerChildrenActive(false);
      onMouseLeave?.({
        key: eventKey,
        domEvent
      });
    };
    const mergedActive = reactExports.useMemo(() => {
      if (active) {
        return active;
      }
      if (mode !== "inline") {
        return childrenActive || isSubPathKey([activeKey], eventKey);
      }
      return false;
    }, [mode, active, activeKey, childrenActive, eventKey, isSubPathKey]);
    const directionStyle = useDirectionStyle(connectedPath.length);
    const onInternalTitleClick = (e) => {
      if (mergedDisabled) {
        return;
      }
      onTitleClick?.({
        key: eventKey,
        domEvent: e
      });
      if (mode === "inline") {
        onOpenChange(eventKey, !originOpen);
      }
    };
    const onMergedItemClick = useMemoCallback((info) => {
      onClick?.(warnItemProp(info));
      onItemClick(info);
    });
    const onPopupVisibleChange = (newVisible) => {
      if (mode !== "inline") {
        onOpenChange(eventKey, newVisible);
      }
    };
    const onInternalFocus = () => {
      onActive(eventKey);
    };
    const popupId = domDataId && `${domDataId}-popup`;
    const expandIconNode = reactExports.useMemo(() => reactExports.createElement(Icon, {
      icon: mode !== "horizontal" ? mergedExpandIcon : void 0,
      props: {
        ...props,
        isOpen: open2,
isSubMenu: true
      }
    }, reactExports.createElement("i", {
      className: `${subMenuPrefixCls}-arrow`
    })), [mode, mergedExpandIcon, props, open2, subMenuPrefixCls]);
    let titleNode = reactExports.createElement("div", _extends$s({
      role: "menuitem",
      style: directionStyle,
      className: `${subMenuPrefixCls}-title`,
      tabIndex: mergedDisabled ? null : -1,
      ref: elementRef,
      title: typeof title === "string" ? title : null,
      "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
      "aria-expanded": open2,
      "aria-haspopup": true,
      "aria-controls": popupId,
      "aria-disabled": mergedDisabled,
      onClick: onInternalTitleClick,
      onFocus: onInternalFocus
    }, activeProps), title, expandIconNode);
    const triggerModeRef = reactExports.useRef(mode);
    if (mode !== "inline" && connectedPath.length > 1) {
      triggerModeRef.current = "vertical";
    } else {
      triggerModeRef.current = mode;
    }
    const popupContentTriggerMode = triggerModeRef.current;
    const renderPopupContent = reactExports.useMemo(() => {
      const originNode = reactExports.createElement(InheritableContextProvider, {
        classNames: menuClassNames,
        styles,
        mode: popupContentTriggerMode === "horizontal" ? "vertical" : popupContentTriggerMode
      }, reactExports.createElement(SubMenuList, {
        id: popupId,
        ref: popupRef
      }, children));
      const mergedPopupRender = propsPopupRender || contextPopupRender;
      if (mergedPopupRender) {
        const node2 = mergedPopupRender(originNode, {
          item: props,
          keys: connectedPath
        });
        return node2;
      }
      return originNode;
    }, [propsPopupRender, contextPopupRender, connectedPath, popupId, children, props, popupContentTriggerMode]);
    if (!overflowDisabled) {
      const triggerMode = triggerModeRef.current;
      titleNode = reactExports.createElement(PopupTrigger, {
        mode: triggerMode,
        prefixCls: subMenuPrefixCls,
        visible: !internalPopupClose && open2 && mode !== "inline",
        popupClassName,
        popupOffset,
        popupStyle,
        popup: renderPopupContent,
        disabled: mergedDisabled,
        onVisibleChange: onPopupVisibleChange
      }, titleNode);
    }
    let listNode = reactExports.createElement(ForwardOverflow.Item, _extends$s({
      ref: ref2,
      role: "none"
    }, restProps, {
      component: "li",
      style: style2,
      className: clsx(subMenuPrefixCls, `${subMenuPrefixCls}-${mode}`, className, {
        [`${subMenuPrefixCls}-open`]: open2,
        [`${subMenuPrefixCls}-active`]: mergedActive,
        [`${subMenuPrefixCls}-selected`]: childrenSelected,
        [`${subMenuPrefixCls}-disabled`]: mergedDisabled
      }),
      onMouseEnter: onInternalMouseEnter,
      onMouseLeave: onInternalMouseLeave
    }), titleNode, !overflowDisabled && reactExports.createElement(InlineSubMenuList, {
      id: popupId,
      open: open2,
      keyPath: connectedPath
    }, children));
    if (_internalRenderSubMenuItem) {
      listNode = _internalRenderSubMenuItem(listNode, props, {
        selected: childrenSelected,
        active: mergedActive,
        open: open2,
        disabled: mergedDisabled
      });
    }
    return reactExports.createElement(InheritableContextProvider, {
      classNames: menuClassNames,
      styles,
      onItemClick: onMergedItemClick,
      mode: mode === "horizontal" ? "vertical" : mode,
      itemIcon: mergedItemIcon,
      expandIcon: mergedExpandIcon
    }, listNode);
  });
  const SubMenu$1 = reactExports.forwardRef((props, ref2) => {
    const {
      eventKey,
      children
    } = props;
    const connectedKeyPath = useFullPath(eventKey);
    const childList = parseChildren(children, connectedKeyPath);
    const measure = useMeasure();
    reactExports.useEffect(() => {
      if (measure) {
        measure.registerPath(eventKey, connectedKeyPath);
        return () => {
          measure.unregisterPath(eventKey, connectedKeyPath);
        };
      }
    }, [connectedKeyPath]);
    let renderNode;
    if (measure) {
      renderNode = childList;
    } else {
      renderNode = reactExports.createElement(InternalSubMenu, _extends$s({
        ref: ref2
      }, props), childList);
    }
    return reactExports.createElement(PathTrackerContext.Provider, {
      value: connectedKeyPath
    }, renderNode);
  });
  function Divider$1({
    className,
    style: style2
  }) {
    const {
      prefixCls
    } = reactExports.useContext(MenuContext$1);
    const measure = useMeasure();
    if (measure) {
      return null;
    }
    return reactExports.createElement("li", {
      role: "separator",
      className: clsx(`${prefixCls}-item-divider`, className),
      style: style2
    });
  }
  function _extends$r() {
    _extends$r = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$r.apply(this, arguments);
  }
  const InternalMenuItemGroup = reactExports.forwardRef((props, ref2) => {
    const {
      className,
      title,
      eventKey,
      children,
      ...restProps
    } = props;
    const {
      prefixCls,
      classNames: menuClassNames,
      styles
    } = reactExports.useContext(MenuContext$1);
    const groupPrefixCls = `${prefixCls}-item-group`;
    return reactExports.createElement("li", _extends$r({
      ref: ref2,
      role: "presentation"
    }, restProps, {
      onClick: (e) => e.stopPropagation(),
      className: clsx(groupPrefixCls, className)
    }), reactExports.createElement("div", {
      role: "presentation",
      className: clsx(`${groupPrefixCls}-title`, menuClassNames?.listTitle),
      style: styles?.listTitle,
      title: typeof title === "string" ? title : void 0
    }, title), reactExports.createElement("ul", {
      role: "group",
      className: clsx(`${groupPrefixCls}-list`, menuClassNames?.list),
      style: styles?.list
    }, children));
  });
  const MenuItemGroup = reactExports.forwardRef((props, ref2) => {
    const {
      eventKey,
      children
    } = props;
    const connectedKeyPath = useFullPath(eventKey);
    const childList = parseChildren(children, connectedKeyPath);
    const measure = useMeasure();
    if (measure) {
      return childList;
    }
    return reactExports.createElement(InternalMenuItemGroup, _extends$r({
      ref: ref2
    }, omit(props, ["warnKey"])), childList);
  });
  function _extends$q() {
    _extends$q = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$q.apply(this, arguments);
  }
  function convertItemsToNodes(list2, components2, prefixCls) {
    const {
      item: MergedMenuItem,
      group: MergedMenuItemGroup,
      submenu: MergedSubMenu,
      divider: MergedDivider
    } = components2;
    return (list2 || []).map((opt, index) => {
      if (opt && typeof opt === "object") {
        const {
          label,
          children,
          key,
          type: type4,
          extra,
          ...restProps
        } = opt;
        const mergedKey = key ?? `tmp-${index}`;
        if (children || type4 === "group") {
          if (type4 === "group") {
            return reactExports.createElement(MergedMenuItemGroup, _extends$q({
              key: mergedKey
            }, restProps, {
              title: label
            }), convertItemsToNodes(children, components2, prefixCls));
          }
          return reactExports.createElement(MergedSubMenu, _extends$q({
            key: mergedKey
          }, restProps, {
            title: label
          }), convertItemsToNodes(children, components2, prefixCls));
        }
        if (type4 === "divider") {
          return reactExports.createElement(MergedDivider, _extends$q({
            key: mergedKey
          }, restProps));
        }
        return reactExports.createElement(MergedMenuItem, _extends$q({
          key: mergedKey
        }, restProps, {
          extra
        }), label, (!!extra || extra === 0) && reactExports.createElement("span", {
          className: `${prefixCls}-item-extra`
        }, extra));
      }
      return null;
    }).filter((opt) => opt);
  }
  function parseItems(children, items, keyPath, components2, prefixCls) {
    let childNodes = children;
    const mergedComponents = {
      divider: Divider$1,
      item: MenuItem$2,
      group: MenuItemGroup,
      submenu: SubMenu$1,
      ...components2
    };
    if (items) {
      childNodes = convertItemsToNodes(items, mergedComponents, prefixCls);
    }
    return parseChildren(childNodes, keyPath);
  }
  function _extends$p() {
    _extends$p = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$p.apply(this, arguments);
  }
  const EMPTY_LIST = [];
  const Menu$1 = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls = "rc-menu",
      rootClassName,
      style: style2,
      className,
      styles,
      classNames: menuClassNames,
      tabIndex = 0,
      items,
      children,
      direction,
      id: id2,
mode = "vertical",
      inlineCollapsed,
disabled,
      disabledOverflow,
subMenuOpenDelay = 0.1,
      subMenuCloseDelay = 0.1,
      forceSubMenuRender,
      defaultOpenKeys,
      openKeys,
activeKey,
      defaultActiveFirst,
selectable = true,
      multiple = false,
      defaultSelectedKeys,
      selectedKeys,
      onSelect,
      onDeselect,
inlineIndent = 24,
motion: motion2,
      defaultMotions,
triggerSubMenuAction = "hover",
      builtinPlacements,
itemIcon,
      expandIcon,
      overflowedIndicator = "...",
      overflowedIndicatorPopupClassName,
getPopupContainer,
onClick,
      onOpenChange,
      onKeyDown,
openAnimation,
      openTransitionName,
_internalRenderMenuItem,
      _internalRenderSubMenuItem,
      _internalComponents,
      popupRender,
      ...restProps
    } = props;
    const [childList, measureChildList] = reactExports.useMemo(() => [parseItems(children, items, EMPTY_LIST, _internalComponents, prefixCls), parseItems(children, items, EMPTY_LIST, {}, prefixCls)], [children, items, _internalComponents]);
    const [mounted, setMounted] = reactExports.useState(false);
    const containerRef = reactExports.useRef();
    const uuid2 = useId(id2 ? `rc-menu-uuid-${id2}` : "rc-menu-uuid");
    const isRtl = direction === "rtl";
    const [innerOpenKeys, setMergedOpenKeys] = useControlledState(defaultOpenKeys, openKeys);
    const mergedOpenKeys = innerOpenKeys || EMPTY_LIST;
    const triggerOpenKeys = (keys2, forceFlush = false) => {
      function doUpdate() {
        setMergedOpenKeys(keys2);
        onOpenChange?.(keys2);
      }
      if (forceFlush) {
        reactDomExports.flushSync(doUpdate);
      } else {
        doUpdate();
      }
    };
    const [inlineCacheOpenKeys, setInlineCacheOpenKeys] = reactExports.useState(mergedOpenKeys);
    const mountRef = reactExports.useRef(false);
    const [mergedMode, mergedInlineCollapsed] = reactExports.useMemo(() => {
      if ((mode === "inline" || mode === "vertical") && inlineCollapsed) {
        return ["vertical", inlineCollapsed];
      }
      return [mode, false];
    }, [mode, inlineCollapsed]);
    const isInlineMode = mergedMode === "inline";
    const [internalMode, setInternalMode] = reactExports.useState(mergedMode);
    const [internalInlineCollapsed, setInternalInlineCollapsed] = reactExports.useState(mergedInlineCollapsed);
    reactExports.useEffect(() => {
      setInternalMode(mergedMode);
      setInternalInlineCollapsed(mergedInlineCollapsed);
      if (!mountRef.current) {
        return;
      }
      if (isInlineMode) {
        setMergedOpenKeys(inlineCacheOpenKeys);
      } else {
        triggerOpenKeys(EMPTY_LIST);
      }
    }, [mergedMode, mergedInlineCollapsed]);
    const [lastVisibleIndex, setLastVisibleIndex] = reactExports.useState(0);
    const allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== "horizontal" || disabledOverflow;
    reactExports.useEffect(() => {
      if (isInlineMode) {
        setInlineCacheOpenKeys(mergedOpenKeys);
      }
    }, [mergedOpenKeys]);
    reactExports.useEffect(() => {
      mountRef.current = true;
      return () => {
        mountRef.current = false;
      };
    }, []);
    const {
      registerPath,
      unregisterPath,
      refreshOverflowKeys,
      isSubPathKey,
      getKeyPath,
      getKeys,
      getSubPathKeys
    } = useKeyRecords();
    const registerPathContext = reactExports.useMemo(() => ({
      registerPath,
      unregisterPath
    }), [registerPath, unregisterPath]);
    const pathUserContext = reactExports.useMemo(() => ({
      isSubPathKey
    }), [isSubPathKey]);
    reactExports.useEffect(() => {
      refreshOverflowKeys(allVisible ? EMPTY_LIST : childList.slice(lastVisibleIndex + 1).map((child) => child.key));
    }, [lastVisibleIndex, allVisible]);
    const [mergedActiveKey, setMergedActiveKey] = useControlledState(activeKey || defaultActiveFirst && childList[0]?.key, activeKey);
    const onActive = useMemoCallback((key) => {
      setMergedActiveKey(key);
    });
    const onInactive = useMemoCallback(() => {
      setMergedActiveKey(void 0);
    });
    reactExports.useImperativeHandle(ref2, () => {
      return {
        list: containerRef.current,
        focus: (options) => {
          const keys2 = getKeys();
          const {
            elements,
            key2element,
            element2key
          } = refreshElements(keys2, uuid2);
          const focusableElements = getFocusableElements(containerRef.current, elements);
          let shouldFocusKey;
          if (mergedActiveKey && keys2.includes(mergedActiveKey)) {
            shouldFocusKey = mergedActiveKey;
          } else {
            shouldFocusKey = focusableElements[0] ? element2key.get(focusableElements[0]) : childList.find((node2) => !node2.props.disabled)?.key;
          }
          const elementToFocus = key2element.get(shouldFocusKey);
          if (shouldFocusKey && elementToFocus) {
            elementToFocus?.focus?.(options);
          }
        },
        findItem: ({
          key: itemKey2
        }) => {
          const keys2 = getKeys();
          const {
            key2element
          } = refreshElements(keys2, uuid2);
          return key2element.get(itemKey2) || null;
        }
      };
    });
    const [internalSelectKeys, setMergedSelectKeys] = useControlledState(defaultSelectedKeys || [], selectedKeys);
    const mergedSelectKeys = reactExports.useMemo(() => {
      if (Array.isArray(internalSelectKeys)) {
        return internalSelectKeys;
      }
      if (internalSelectKeys === null || internalSelectKeys === void 0) {
        return EMPTY_LIST;
      }
      return [internalSelectKeys];
    }, [internalSelectKeys]);
    const triggerSelection = (info) => {
      if (selectable) {
        const {
          key: targetKey
        } = info;
        const exist = mergedSelectKeys.includes(targetKey);
        let newSelectKeys;
        if (multiple) {
          if (exist) {
            newSelectKeys = mergedSelectKeys.filter((key) => key !== targetKey);
          } else {
            newSelectKeys = [...mergedSelectKeys, targetKey];
          }
        } else {
          newSelectKeys = [targetKey];
        }
        setMergedSelectKeys(newSelectKeys);
        const selectInfo = {
          ...info,
          selectedKeys: newSelectKeys
        };
        if (exist) {
          onDeselect?.(selectInfo);
        } else {
          onSelect?.(selectInfo);
        }
      }
      if (!multiple && mergedOpenKeys.length && internalMode !== "inline") {
        triggerOpenKeys(EMPTY_LIST);
      }
    };
    const onInternalClick = useMemoCallback((info) => {
      onClick?.(warnItemProp(info));
      triggerSelection(info);
    });
    const onInternalOpenChange = useMemoCallback((key, open2) => {
      let newOpenKeys = mergedOpenKeys.filter((k) => k !== key);
      if (open2) {
        newOpenKeys.push(key);
      } else if (internalMode !== "inline") {
        const subPathKeys = getSubPathKeys(key);
        newOpenKeys = newOpenKeys.filter((k) => !subPathKeys.has(k));
      }
      if (!isEqual$1(mergedOpenKeys, newOpenKeys, true)) {
        triggerOpenKeys(newOpenKeys, true);
      }
    });
    const triggerAccessibilityOpen = (key, open2) => {
      const nextOpen = open2 ?? !mergedOpenKeys.includes(key);
      onInternalOpenChange(key, nextOpen);
    };
    const onInternalKeyDown = useAccessibility(internalMode, mergedActiveKey, isRtl, uuid2, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown);
    reactExports.useEffect(() => {
      setMounted(true);
    }, []);
    const privateContext = reactExports.useMemo(() => ({
      _internalRenderMenuItem,
      _internalRenderSubMenuItem
    }), [_internalRenderMenuItem, _internalRenderSubMenuItem]);
    const wrappedChildList = internalMode !== "horizontal" || disabledOverflow ? childList : (
childList.map((child, index) => (

reactExports.createElement(InheritableContextProvider, {
          key: child.key,
          overflowDisabled: index > lastVisibleIndex,
          classNames: menuClassNames,
          styles
        }, child)
      ))
    );
    const container = reactExports.createElement(ForwardOverflow, _extends$p({
      id: id2,
      ref: containerRef,
      prefixCls: `${prefixCls}-overflow`,
      component: "ul",
      itemComponent: MenuItem$2,
      className: clsx(prefixCls, `${prefixCls}-root`, `${prefixCls}-${internalMode}`, className, {
        [`${prefixCls}-inline-collapsed`]: internalInlineCollapsed,
        [`${prefixCls}-rtl`]: isRtl
      }, rootClassName),
      dir: direction,
      style: style2,
      role: "menu",
      tabIndex,
      data: wrappedChildList,
      renderRawItem: (node2) => node2,
      renderRawRest: (omitItems) => {
        const len = omitItems.length;
        const originOmitItems = len ? childList.slice(-len) : null;
        return reactExports.createElement(SubMenu$1, {
          eventKey: OVERFLOW_KEY,
          title: overflowedIndicator,
          disabled: allVisible,
          internalPopupClose: len === 0,
          popupClassName: overflowedIndicatorPopupClassName
        }, originOmitItems);
      },
      maxCount: internalMode !== "horizontal" || disabledOverflow ? ForwardOverflow.INVALIDATE : ForwardOverflow.RESPONSIVE,
      ssr: "full",
      "data-menu-list": true,
      onVisibleChange: (newLastIndex) => {
        setLastVisibleIndex(newLastIndex);
      },
      onKeyDown: onInternalKeyDown
    }, restProps));
    return reactExports.createElement(PrivateContext.Provider, {
      value: privateContext
    }, reactExports.createElement(IdContext.Provider, {
      value: uuid2
    }, reactExports.createElement(InheritableContextProvider, {
      prefixCls,
      rootClassName,
      classNames: menuClassNames,
      styles,
      mode: internalMode,
      openKeys: mergedOpenKeys,
      rtl: isRtl,
      disabled,
      motion: mounted ? motion2 : null,
      defaultMotions: mounted ? defaultMotions : null,
      activeKey: mergedActiveKey,
      onActive,
      onInactive,
      selectedKeys: mergedSelectKeys,
      inlineIndent,
      subMenuOpenDelay,
      subMenuCloseDelay,
      forceSubMenuRender,
      builtinPlacements,
      triggerSubMenuAction,
      getPopupContainer,
      itemIcon,
      expandIcon,
      onItemClick: onInternalClick,
      onOpenChange: onInternalOpenChange,
      popupRender
    }, reactExports.createElement(PathUserContext.Provider, {
      value: pathUserContext
    }, container), reactExports.createElement("div", {
      style: {
        display: "none"
      },
      "aria-hidden": true
    }, reactExports.createElement(PathRegisterContext.Provider, {
      value: registerPathContext
    }, measureChildList)))));
  });
  const ExportMenu = Menu$1;
  ExportMenu.Item = MenuItem$2;
  ExportMenu.SubMenu = SubMenu$1;
  ExportMenu.ItemGroup = MenuItemGroup;
  ExportMenu.Divider = Divider$1;
  const SiderContext = reactExports.createContext({});
  var EllipsisOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "ellipsis", "theme": "outlined" };
  function _extends$o() {
    _extends$o = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$o.apply(this, arguments);
  }
  const EllipsisOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends$o({}, props, {
    ref: ref2,
    icon: EllipsisOutlined$1
  }));
  const RefIcon$a = reactExports.forwardRef(EllipsisOutlined);
  const MenuContext = reactExports.createContext({
    prefixCls: "",
    firstLevel: true,
    inlineCollapsed: false,
    styles: null,
    classNames: null
  });
  const MenuDivider = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      dashed,
      ...restProps
    } = props;
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const prefixCls = getPrefixCls("menu", customizePrefixCls);
    const classString = clsx({
      [`${prefixCls}-item-divider-dashed`]: !!dashed
    }, className);
    return reactExports.createElement(Divider$1, {
      className: classString,
      ...restProps
    });
  };
  const MenuItem = (props) => {
    const {
      className,
      children,
      icon,
      title,
      danger,
      extra
    } = props;
    const {
      prefixCls,
      firstLevel,
      direction,
      disableMenuItemTitleTooltip,
      tooltip,
      inlineCollapsed: isInlineCollapsed,
      styles,
      classNames
    } = reactExports.useContext(MenuContext);
    const renderItemChildren = (inlineCollapsed) => {
      const label = children?.[0];
      const wrapNode = reactExports.createElement("span", {
        className: clsx(`${prefixCls}-title-content`, firstLevel ? classNames?.itemContent : classNames?.subMenu?.itemContent, {
          [`${prefixCls}-title-content-with-extra`]: !!extra || extra === 0
        }),
        style: firstLevel ? styles?.itemContent : styles?.subMenu?.itemContent
      }, children);
      if (!icon || reactExports.isValidElement(children) && children.type === "span") {
        if (children && inlineCollapsed && firstLevel && typeof label === "string") {
          return reactExports.createElement("div", {
            className: `${prefixCls}-inline-collapsed-noicon`
          }, label.charAt(0));
        }
      }
      return wrapNode;
    };
    const {
      siderCollapsed
    } = reactExports.useContext(SiderContext);
    let tooltipTitle = title;
    if (typeof title === "undefined") {
      tooltipTitle = firstLevel ? children : "";
    } else if (title === false) {
      tooltipTitle = "";
    }
    const tooltipConfig = tooltip === false ? void 0 : tooltip;
    const mergedTooltipTitle = tooltipConfig && tooltipConfig.title !== void 0 ? tooltipConfig.title : tooltipTitle;
    const tooltipProps = {
      ...tooltipConfig ?? null,
      title: mergedTooltipTitle
    };
    if (!siderCollapsed && !isInlineCollapsed) {
      tooltipProps.title = null;
      tooltipProps.open = false;
    }
    const childrenLength = toArray$4(children).length;
    let returnNode = reactExports.createElement(MenuItem$2, {
      ...omit(props, ["title", "icon", "danger"]),
      className: clsx(firstLevel ? classNames?.item : classNames?.subMenu?.item, {
        [`${prefixCls}-item-danger`]: danger,
        [`${prefixCls}-item-only-child`]: (icon ? childrenLength + 1 : childrenLength) === 1
      }, className),
      style: {
        ...firstLevel ? styles?.item : styles?.subMenu?.item,
        ...props.style
      },
      title: typeof title === "string" ? title : void 0
    }, cloneElement(icon, (oriProps) => ({
      className: clsx(`${prefixCls}-item-icon`, firstLevel ? classNames?.itemIcon : classNames?.subMenu?.itemIcon, oriProps.className),
      style: {
        ...firstLevel ? styles?.itemIcon : styles?.subMenu?.itemIcon,
        ...oriProps.style
      }
    })), renderItemChildren(isInlineCollapsed));
    if (!disableMenuItemTitleTooltip && tooltip !== false) {
      const mergedTooltipPlacement = tooltipConfig && tooltipConfig.placement ? tooltipConfig.placement : direction === "rtl" ? "left" : "right";
      const baseTooltipClassName = `${prefixCls}-inline-collapsed-tooltip`;
      const mergeTooltipRootClassName = (classNames2) => ({
        ...classNames2,
        root: clsx(baseTooltipClassName, classNames2?.root)
      });
      const mergedTooltipClassNames = tooltipConfig && typeof tooltipConfig.classNames === "function" ? (info) => {
        const resolvedClassNames = tooltipConfig.classNames(info);
        return mergeTooltipRootClassName(resolvedClassNames);
      } : mergeTooltipRootClassName(tooltipConfig?.classNames);
      returnNode = reactExports.createElement(Tooltip, {
        ...tooltipProps,
        placement: mergedTooltipPlacement,
        classNames: mergedTooltipClassNames
      }, returnNode);
    }
    return returnNode;
  };
  const OverrideContext = reactExports.createContext(null);
  const OverrideProvider = reactExports.forwardRef((props, ref2) => {
    const {
      children,
      ...restProps
    } = props;
    const override = reactExports.useContext(OverrideContext);
    const context = reactExports.useMemo(() => ({
      ...override,
      ...restProps
    }), [
      override,
      restProps.prefixCls,
restProps.mode,
      restProps.selectable,
      restProps.rootClassName
]);
    const canRef = supportNodeRef(children);
    const mergedRef = useComposeRef(ref2, canRef ? getNodeRef(children) : null);
    return reactExports.createElement(OverrideContext.Provider, {
      value: context
    }, reactExports.createElement(ContextIsolator, {
      space: true
    }, canRef ? reactExports.cloneElement(children, {
      ref: mergedRef
    }) : children));
  });
  const getHorizontalStyle = (token2) => {
    const {
      componentCls,
      motionDurationSlow,
      horizontalLineHeight,
      colorSplit,
      lineWidth,
      lineType,
      itemPaddingInline
    } = token2;
    return {
      [`${componentCls}-horizontal`]: {
        lineHeight: horizontalLineHeight,
        border: 0,
        borderBottom: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
        boxShadow: "none",
        "&::after": {
          display: "block",
          clear: "both",
          height: 0,
          content: '"\\20"'
        },
[`${componentCls}-item, ${componentCls}-submenu`]: {
          position: "relative",
          display: "inline-block",
          verticalAlign: "bottom",
          paddingInline: itemPaddingInline
        },
        [`> ${componentCls}-item:hover,
        > ${componentCls}-item-active,
        > ${componentCls}-submenu ${componentCls}-submenu-title:hover`]: {
          backgroundColor: "transparent"
        },
        [`${componentCls}-item, ${componentCls}-submenu-title`]: {
          transition: [`border-color`, `background-color`].map((prop) => `${prop} ${motionDurationSlow}`).join(",")
        },
[`${componentCls}-submenu-arrow`]: {
          display: "none"
        }
      }
    };
  };
  const getRTLStyle = ({
    componentCls,
    menuArrowOffset,
    calc
  }) => ({
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    },
    [`${componentCls}-submenu-rtl`]: {
      transformOrigin: "100% 0"
    },
[`${componentCls}-rtl${componentCls}-vertical,
    ${componentCls}-submenu-rtl ${componentCls}-vertical`]: {
      [`${componentCls}-submenu-arrow`]: {
        "&::before": {
          transform: `rotate(-45deg) translateY(${unit$1(calc(menuArrowOffset).mul(-1).equal())})`
        },
        "&::after": {
          transform: `rotate(45deg) translateY(${unit$1(menuArrowOffset)})`
        }
      }
    }
  });
  const accessibilityFocus = (token2) => genFocusOutline(token2);
  const getThemeStyle = (token2, themeSuffix) => {
    const {
      componentCls,
      itemColor,
      itemSelectedColor,
      subMenuItemSelectedColor,
      groupTitleColor,
      itemBg,
      subMenuItemBg,
      itemSelectedBg,
      activeBarHeight,
      activeBarWidth,
      activeBarBorderWidth,
      motionDurationSlow,
      motionEaseInOut,
      motionEaseOut,
      itemPaddingInline,
      motionDurationMid,
      itemHoverColor,
      lineType,
      colorSplit,
itemDisabledColor,
dangerItemColor,
      dangerItemHoverColor,
      dangerItemSelectedColor,
      dangerItemActiveBg,
      dangerItemSelectedBg,
popupBg,
      itemHoverBg,
      itemActiveBg,
      menuSubMenuBg,
horizontalItemSelectedColor,
      horizontalItemSelectedBg,
      horizontalItemBorderRadius,
      horizontalItemHoverBg
    } = token2;
    return {
      [`${componentCls}-${themeSuffix}, ${componentCls}-${themeSuffix} > ${componentCls}`]: {
        color: itemColor,
        background: itemBg,
        [`&${componentCls}-root:focus-visible`]: {
          ...accessibilityFocus(token2)
        },
[`${componentCls}-item`]: {
          "&-group-title, &-extra": {
            color: groupTitleColor
          }
        },
        [`${componentCls}-submenu-selected > ${componentCls}-submenu-title`]: {
          color: subMenuItemSelectedColor
        },
        [`${componentCls}-item, ${componentCls}-submenu-title`]: {
          color: itemColor,
          [`&:not(${componentCls}-item-disabled):focus-visible`]: {
            ...accessibilityFocus(token2)
          }
        },
[`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
          color: `${itemDisabledColor} !important`
        },
[`${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
          [`&:hover, > ${componentCls}-submenu-title:hover`]: {
            color: itemHoverColor
          }
        },
        [`&:not(${componentCls}-horizontal)`]: {
          [`${componentCls}-item:not(${componentCls}-item-selected)`]: {
            "&:hover": {
              backgroundColor: itemHoverBg
            },
            "&:active": {
              backgroundColor: itemActiveBg
            }
          },
          [`${componentCls}-submenu-title`]: {
            "&:hover": {
              backgroundColor: itemHoverBg
            },
            "&:active": {
              backgroundColor: itemActiveBg
            }
          }
        },
[`${componentCls}-item-danger`]: {
          color: dangerItemColor,
          [`&${componentCls}-item:hover`]: {
            [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
              color: dangerItemHoverColor
            }
          },
          [`&${componentCls}-item:active`]: {
            background: dangerItemActiveBg
          }
        },
        [`${componentCls}-item a`]: {
          "&, &:hover": {
            color: "inherit"
          }
        },
        [`${componentCls}-item-selected`]: {
          color: itemSelectedColor,
[`&${componentCls}-item-danger`]: {
            color: dangerItemSelectedColor
          },
          "a, a:hover": {
            color: "inherit"
          }
        },
        [`& ${componentCls}-item-selected`]: {
          backgroundColor: itemSelectedBg,
[`&${componentCls}-item-danger`]: {
            backgroundColor: dangerItemSelectedBg
          }
        },
        [`&${componentCls}-submenu > ${componentCls}`]: {
          backgroundColor: menuSubMenuBg
        },

[`&${componentCls}-popup > ${componentCls}`]: {
          backgroundColor: popupBg
        },
        [`&${componentCls}-submenu-popup > ${componentCls}`]: {
          backgroundColor: popupBg
        },

[`&${componentCls}-horizontal`]: {
          ...themeSuffix === "dark" ? {
            borderBottom: 0
          } : {},
          [`> ${componentCls}-item, > ${componentCls}-submenu`]: {
            top: activeBarBorderWidth,
            marginTop: token2.calc(activeBarBorderWidth).mul(-1).equal(),
            marginBottom: 0,
            borderRadius: horizontalItemBorderRadius,
            "&::after": {
              position: "absolute",
              insetInline: itemPaddingInline,
              bottom: 0,
              borderBottom: `${unit$1(activeBarHeight)} solid transparent`,
              transition: `border-color ${motionDurationSlow} ${motionEaseInOut}`,
              content: '""'
            },
            "&:hover, &-active, &-open": {
              background: horizontalItemHoverBg,
              "&::after": {
                borderBottomWidth: activeBarHeight,
                borderBottomColor: horizontalItemSelectedColor
              }
            },
            "&-selected": {
              color: horizontalItemSelectedColor,
              backgroundColor: horizontalItemSelectedBg,
              "&:hover": {
                backgroundColor: horizontalItemSelectedBg
              },
              "&::after": {
                borderBottomWidth: activeBarHeight,
                borderBottomColor: horizontalItemSelectedColor
              }
            }
          }
        },

[`&${componentCls}-root`]: {
          [`&${componentCls}-inline, &${componentCls}-vertical`]: {
            borderInlineEnd: `${unit$1(activeBarBorderWidth)} ${lineType} ${colorSplit}`
          }
        },
[`&${componentCls}-inline`]: {
[`${componentCls}-sub${componentCls}-inline`]: {
            background: subMenuItemBg
          },
          [`${componentCls}-item`]: {
            position: "relative",
            "&::after": {
              position: "absolute",
              insetBlock: 0,
              insetInlineEnd: 0,
              borderInlineEnd: `${unit$1(activeBarWidth)} solid ${itemSelectedColor}`,
              transform: "scaleY(0.0001)",
              opacity: 0,
              transition: [`transform`, `opacity`].map((prop) => `${prop} ${motionDurationMid} ${motionEaseOut}`).join(","),
              content: '""'
            },
[`&${componentCls}-item-danger`]: {
              "&::after": {
                borderInlineEndColor: dangerItemSelectedColor
              }
            }
          },
          [`${componentCls}-selected, ${componentCls}-item-selected`]: {
            "&::after": {
              transform: "scaleY(1)",
              opacity: 1,
              transition: [`transform`, `opacity`].map((prop) => `${prop} ${motionDurationMid} ${motionEaseInOut}`).join(",")
            }
          }
        }
      }
    };
  };
  const getVerticalInlineStyle = (token2) => {
    const {
      componentCls,
      itemHeight,
      itemMarginInline,
      padding,
      menuArrowSize,
      marginXS,
      itemMarginBlock,
      itemWidth,
      itemPaddingInline
    } = token2;
    const paddingWithArrow = token2.calc(menuArrowSize).add(padding).add(marginXS).equal();
    return {
      [`${componentCls}-item`]: {
        position: "relative",
        overflow: "hidden"
      },
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        height: itemHeight,
        lineHeight: unit$1(itemHeight),
        paddingInline: itemPaddingInline,
        overflow: "hidden",
        textOverflow: "ellipsis",
        marginInline: itemMarginInline,
        marginBlock: itemMarginBlock,
        width: itemWidth
      },
      [`> ${componentCls}-item,
            > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
        height: itemHeight,
        lineHeight: unit$1(itemHeight)
      },
      [`${componentCls}-item-group-list ${componentCls}-submenu-title,
            ${componentCls}-submenu-title`]: {
        paddingInlineEnd: paddingWithArrow
      }
    };
  };
  const getVerticalStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      itemHeight,
      colorTextLightSolid,
      dropdownWidth,
      controlHeightLG,
      motionEaseOut,
      paddingXL,
      itemMarginInline,
      fontSizeLG,
      motionDurationFast,
      motionDurationSlow,
      paddingXS,
      boxShadowSecondary,
      collapsedWidth,
      collapsedIconSize
    } = token2;
    const inlineItemStyle = {
      height: itemHeight,
      lineHeight: unit$1(itemHeight),
      listStylePosition: "inside",
      listStyleType: "disc"
    };
    return [
      {
        [componentCls]: {
          "&-inline, &-vertical": {
            [`&${componentCls}-root`]: {
              boxShadow: "none"
            },
            ...getVerticalInlineStyle(token2)
          }
        },
        [`${componentCls}-submenu-popup`]: {
          [`${componentCls}-vertical`]: {
            ...getVerticalInlineStyle(token2),
            boxShadow: boxShadowSecondary
          }
        }
      },
{
        [`${componentCls}-submenu-popup ${componentCls}-vertical${componentCls}-sub`]: {
          minWidth: dropdownWidth,
          maxHeight: `calc(100vh - ${unit$1(token2.calc(controlHeightLG).mul(2.5).equal())})`,
          padding: "0",
          overflow: "hidden",
          borderInlineEnd: 0,

"&:not([class*='-active'])": {
            overflowX: "hidden",
            overflowY: "auto"
          }
        }
      },
{
        [`${componentCls}-inline`]: {
          width: "100%",
[`&${componentCls}-root`]: {
            [`${componentCls}-item, ${componentCls}-submenu-title`]: {
              display: "flex",
              alignItems: "center",
              transition: [`border-color ${motionDurationSlow}`, `background-color ${motionDurationSlow}`, `padding ${motionDurationFast} ${motionEaseOut}`].join(","),
              [`> ${componentCls}-title-content`]: {
                flex: "auto",
                minWidth: 0,
                overflow: "hidden",
                textOverflow: "ellipsis"
              },
              "> *": {
                flex: "none"
              }
            }
          },
[`${componentCls}-sub${componentCls}-inline`]: {
            padding: 0,
            border: 0,
            borderRadius: 0,
            boxShadow: "none",
            [`& > ${componentCls}-submenu > ${componentCls}-submenu-title`]: inlineItemStyle,
            [`& ${componentCls}-item-group-title`]: {
              paddingInlineStart: paddingXL
            }
          },
[`${componentCls}-item`]: inlineItemStyle
        }
      },
{
        [`${componentCls}-inline-collapsed`]: {
          width: collapsedWidth,
          [`&${componentCls}-root`]: {
            [`${componentCls}-item, ${componentCls}-submenu ${componentCls}-submenu-title`]: {
              [`> ${componentCls}-inline-collapsed-noicon`]: {
                fontSize: fontSizeLG,
                textAlign: "center"
              }
            }
          },
          [`> ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-submenu > ${componentCls}-submenu-title,
          > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
            insetInlineStart: 0,
            paddingInline: `calc(50% - ${unit$1(token2.calc(collapsedIconSize).div(2).equal())} - ${unit$1(itemMarginInline)})`,
            textOverflow: "clip",
            [`
            ${componentCls}-submenu-arrow,
            ${componentCls}-submenu-expand-icon
          `]: {
              opacity: 0
            },
            [`${componentCls}-item-icon, ${iconCls}`]: {
              margin: 0,
              fontSize: collapsedIconSize,
              lineHeight: unit$1(itemHeight),
              "+ span": {
                display: "inline-block",
                opacity: 0
              }
            }
          },
          [`${componentCls}-item-icon, ${iconCls}`]: {
            display: "inline-block"
          },
          "&-tooltip": {
            pointerEvents: "none",
            [`${componentCls}-item-icon, ${iconCls}`]: {
              display: "none"
            },
            "a, a:hover": {
              color: colorTextLightSolid
            }
          },
          [`${componentCls}-item-group-title`]: {
            ...textEllipsis,
            paddingInline: paddingXS
          }
        }
      }
    ];
  };
  const genMenuItemStyle = (token2) => {
    const {
      componentCls,
      motionDurationSlow,
      motionDurationMid,
      motionEaseInOut,
      motionEaseOut,
      iconCls,
      iconSize,
      iconMarginInlineEnd
    } = token2;
    return {
[`${componentCls}-item, ${componentCls}-submenu-title`]: {
        position: "relative",
        display: "block",
        margin: 0,
        whiteSpace: "nowrap",
        cursor: "pointer",
        transition: [`border-color ${motionDurationSlow}`, `background-color ${motionDurationSlow}`, `padding calc(${motionDurationSlow} + 0.1s) ${motionEaseInOut}`].join(","),
        [`${componentCls}-item-icon, ${iconCls}`]: {
          minWidth: iconSize,
          fontSize: iconSize,
          transition: [`font-size ${motionDurationMid} ${motionEaseOut}`, `margin ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow}`].join(","),
          "+ span": {
            marginInlineStart: iconMarginInlineEnd,
            opacity: 1,
            transition: [`opacity ${motionDurationSlow} ${motionEaseInOut}`, `margin ${motionDurationSlow}`, `color ${motionDurationSlow}`].join(",")
          }
        },
        [`${componentCls}-item-icon`]: {
          ...resetIcon()
        },
        [`&${componentCls}-item-only-child`]: {
          [`> ${iconCls}, > ${componentCls}-item-icon`]: {
            marginInlineEnd: 0
          }
        }
      },
[`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
        background: "none !important",
        cursor: "not-allowed",
        "&::after": {
          borderColor: "transparent !important"
        },
        a: {
          color: "inherit !important",
          cursor: "not-allowed",
          pointerEvents: "none"
        },
        [`> ${componentCls}-submenu-title`]: {
          color: "inherit !important",
          cursor: "not-allowed"
        }
      }
    };
  };
  const genSubMenuArrowStyle = (token2) => {
    const {
      componentCls,
      motionDurationSlow,
      motionEaseInOut,
      borderRadius,
      menuArrowSize,
      menuArrowOffset
    } = token2;
    return {
      [`${componentCls}-submenu`]: {
        "&-expand-icon, &-arrow": {
          position: "absolute",
          top: "50%",
          insetInlineEnd: token2.margin,
          width: menuArrowSize,
          color: "currentcolor",
          transform: "translateY(-50%)",
          transition: ["transform", "opacity"].map((prop) => `${prop} ${motionDurationSlow}`).join(",")
        },
        "&-arrow": {
"&::before, &::after": {
            position: "absolute",
            width: token2.calc(menuArrowSize).mul(0.6).equal(),
            height: token2.calc(menuArrowSize).mul(0.15).equal(),
            backgroundColor: "currentcolor",
            borderRadius,
            transition: [`background-color`, `transform`, `top`, `color`].map((prop) => `${prop} ${motionDurationSlow} ${motionEaseInOut}`).join(","),
            content: '""'
          },
          "&::before": {
            transform: `rotate(45deg) translateY(${unit$1(token2.calc(menuArrowOffset).mul(-1).equal())})`
          },
          "&::after": {
            transform: `rotate(-45deg) translateY(${unit$1(menuArrowOffset)})`
          }
        }
      }
    };
  };
  const getBaseStyle = (token2) => {
    const {
      antCls,
      componentCls,
      fontSize,
      motionDurationSlow,
      motionDurationMid,
      motionEaseInOut,
      paddingXS,
      padding,
      colorSplit,
      lineWidth,
      zIndexPopup,
      borderRadiusLG,
      subMenuItemBorderRadius,
      menuArrowSize,
      menuArrowOffset,
      lineType,
      groupTitleLineHeight,
      groupTitleFontSize
    } = token2;
    return [
{
        "": {
          [componentCls]: {
            ...clearFix(),
"&-hidden": {
              display: "none"
            }
          }
        },
        [`${componentCls}-submenu-hidden`]: {
          display: "none"
        }
      },
      {
        [componentCls]: {
          ...resetComponent(token2),
          ...clearFix(),
          marginBottom: 0,
          paddingInlineStart: 0,
fontSize,
          lineHeight: 0,
listStyle: "none",
          outline: "none",
transition: `width ${motionDurationSlow} cubic-bezier(0.2, 0, 0, 1) 0s`,
          "ul, ol": {
            margin: 0,
            padding: 0,
            listStyle: "none"
          },
"&-overflow": {
            display: "flex",
            [`${componentCls}-item`]: {
              flex: "none"
            }
          },
          [`${componentCls}-item, ${componentCls}-submenu, ${componentCls}-submenu-title`]: {
            borderRadius: token2.itemBorderRadius
          },
          [`${componentCls}-item-group-title`]: {
            padding: `${unit$1(paddingXS)} ${unit$1(padding)}`,
            fontSize: groupTitleFontSize,
            lineHeight: groupTitleLineHeight,
            transition: `all ${motionDurationSlow}`
          },
          [`&-horizontal ${componentCls}-submenu`]: {
            transition: [`border-color`, `background-color`].map((prop) => `${prop} ${motionDurationSlow} ${motionEaseInOut}`).join(",")
          },
          [`${componentCls}-submenu, ${componentCls}-submenu-inline`]: {
            transition: [`border-color ${motionDurationSlow}`, `background-color ${motionDurationSlow}`, `padding ${motionDurationMid}`].map((prop) => `${prop} ${motionEaseInOut}`).join(",")
          },
          [`${componentCls}-submenu ${componentCls}-sub`]: {
            cursor: "initial",
            transition: [`background-color`, `padding`].map((prop) => `${prop} ${motionDurationSlow} ${motionEaseInOut}`).join(",")
          },
          [`${componentCls}-title-content`]: {
            transition: `color ${motionDurationSlow}`,
            "&-with-extra": {
              display: "inline-flex",
              alignItems: "center",
              width: "100%"
            },
[`> ${antCls}-typography-ellipsis-single-line`]: {
              display: "inline",
              verticalAlign: "unset"
            },
            [`${componentCls}-item-extra`]: {
              marginInlineStart: "auto",
              paddingInlineStart: token2.padding
            }
          },
          [`${componentCls}-item a`]: {
            "&::before": {
              position: "absolute",
              inset: 0,
              backgroundColor: "transparent",
              content: '""'
            }
          },


[`${componentCls}-item-divider`]: {
            overflow: "hidden",
            lineHeight: 0,
            borderColor: colorSplit,
            borderStyle: lineType,
            borderWidth: 0,
            borderTopWidth: lineWidth,
            marginBlock: lineWidth,
            padding: 0,
            "&-dashed": {
              borderStyle: "dashed"
            }
          },
...genMenuItemStyle(token2),
          [`${componentCls}-item-group`]: {
            [`${componentCls}-item-group-list`]: {
              margin: 0,
              padding: 0,
              [`${componentCls}-item, ${componentCls}-submenu-title`]: {
                paddingInline: `${unit$1(token2.calc(fontSize).mul(2).equal())} ${unit$1(padding)}`
              }
            }
          },
"&-submenu": {
            "&-popup": {
              position: "absolute",
              zIndex: zIndexPopup,
              borderRadius: borderRadiusLG,
              boxShadow: "none",
              transformOrigin: "0 0",
              [`&${componentCls}-submenu`]: {
                background: "transparent"
              },
"&::before": {
                position: "absolute",
                inset: 0,
                zIndex: -1,
                width: "100%",
                height: "100%",
                opacity: 0,
                content: '""'
              },
              [`> ${componentCls}`]: {
                borderRadius: borderRadiusLG,
                ...genMenuItemStyle(token2),
                ...genSubMenuArrowStyle(token2),
                [`${componentCls}-item, ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
                  borderRadius: subMenuItemBorderRadius
                },
                [`${componentCls}-submenu-title::after`]: {
                  transition: `transform ${motionDurationSlow} ${motionEaseInOut}`
                }
              }
            },
            [`
          &-placement-leftTop,
          &-placement-bottomRight,
          `]: {
              transformOrigin: "100% 0"
            },
            [`
          &-placement-leftBottom,
          &-placement-topRight,
          `]: {
              transformOrigin: "100% 100%"
            },
            [`
          &-placement-rightBottom,
          &-placement-topLeft,
          `]: {
              transformOrigin: "0 100%"
            },
            [`
          &-placement-bottomLeft,
          &-placement-rightTop,
          `]: {
              transformOrigin: "0 0"
            },
            [`
          &-placement-leftTop,
          &-placement-leftBottom
          `]: {
              paddingInlineEnd: token2.paddingXS
            },
            [`
          &-placement-rightTop,
          &-placement-rightBottom
          `]: {
              paddingInlineStart: token2.paddingXS
            },
            [`
          &-placement-topRight,
          &-placement-topLeft
          `]: {
              paddingBottom: token2.paddingXS
            },
            [`
          &-placement-bottomRight,
          &-placement-bottomLeft
          `]: {
              paddingTop: token2.paddingXS
            }
          },
          ...genSubMenuArrowStyle(token2),
          [`&-inline-collapsed ${componentCls}-submenu-arrow,
        &-inline ${componentCls}-submenu-arrow`]: {
"&::before": {
              transform: `rotate(-45deg) translateX(${unit$1(menuArrowOffset)})`
            },
            "&::after": {
              transform: `rotate(45deg) translateX(${unit$1(token2.calc(menuArrowOffset).mul(-1).equal())})`
            }
          },
          [`${componentCls}-submenu-open${componentCls}-submenu-inline > ${componentCls}-submenu-title > ${componentCls}-submenu-arrow`]: {
transform: `translateY(${unit$1(token2.calc(menuArrowSize).mul(0.2).mul(-1).equal())})`,
            "&::after": {
              transform: `rotate(-45deg) translateX(${unit$1(token2.calc(menuArrowOffset).mul(-1).equal())})`
            },
            "&::before": {
              transform: `rotate(45deg) translateX(${unit$1(menuArrowOffset)})`
            }
          }
        }
      },
{
        [`${antCls}-layout-header`]: {
          [componentCls]: {
            lineHeight: "inherit"
          }
        }
      }
    ];
  };
  const prepareComponentToken$g = (token2) => {
    const {
      colorPrimary,
      colorError,
      colorTextDisabled,
      colorErrorBg,
      colorText,
      colorTextDescription,
      colorBgContainer,
      colorFillAlter,
      colorFillContent,
      lineWidth,
      lineWidthBold,
      controlItemBgActive,
      colorBgTextHover,
      controlHeightLG,
      lineHeight,
      colorBgElevated,
      marginXXS,
      padding,
      fontSize,
      controlHeightSM,
      fontSizeLG,
      colorTextLightSolid,
      colorErrorHover
    } = token2;
    const activeBarWidth = token2.activeBarWidth ?? 0;
    const activeBarBorderWidth = token2.activeBarBorderWidth ?? lineWidth;
    const itemMarginInline = token2.itemMarginInline ?? token2.marginXXS;
    const colorTextDark = new FastColor(colorTextLightSolid).setA(0.65).toRgbString();
    return {
      dropdownWidth: 160,
      zIndexPopup: token2.zIndexPopupBase + 50,
      radiusItem: token2.borderRadiusLG,
      itemBorderRadius: token2.borderRadiusLG,
      radiusSubMenuItem: token2.borderRadiusSM,
      subMenuItemBorderRadius: token2.borderRadiusSM,
      colorItemText: colorText,
      itemColor: colorText,
      colorItemTextHover: colorText,
      itemHoverColor: colorText,
      colorItemTextHoverHorizontal: colorPrimary,
      horizontalItemHoverColor: colorPrimary,
      colorGroupTitle: colorTextDescription,
      groupTitleColor: colorTextDescription,
      colorItemTextSelected: colorPrimary,
      itemSelectedColor: colorPrimary,
      subMenuItemSelectedColor: colorPrimary,
      colorItemTextSelectedHorizontal: colorPrimary,
      horizontalItemSelectedColor: colorPrimary,
      colorItemBg: colorBgContainer,
      itemBg: colorBgContainer,
      colorItemBgHover: colorBgTextHover,
      itemHoverBg: colorBgTextHover,
      colorItemBgActive: colorFillContent,
      itemActiveBg: controlItemBgActive,
      colorSubItemBg: colorFillAlter,
      subMenuItemBg: colorFillAlter,
      colorItemBgSelected: controlItemBgActive,
      itemSelectedBg: controlItemBgActive,
      colorItemBgSelectedHorizontal: "transparent",
      horizontalItemSelectedBg: "transparent",
      colorActiveBarWidth: 0,
      activeBarWidth,
      colorActiveBarHeight: lineWidthBold,
      activeBarHeight: lineWidthBold,
      colorActiveBarBorderSize: lineWidth,
      activeBarBorderWidth,
colorItemTextDisabled: colorTextDisabled,
      itemDisabledColor: colorTextDisabled,
colorDangerItemText: colorError,
      dangerItemColor: colorError,
      colorDangerItemTextHover: colorError,
      dangerItemHoverColor: colorError,
      colorDangerItemTextSelected: colorError,
      dangerItemSelectedColor: colorError,
      colorDangerItemBgActive: colorErrorBg,
      dangerItemActiveBg: colorErrorBg,
      colorDangerItemBgSelected: colorErrorBg,
      dangerItemSelectedBg: colorErrorBg,
      itemMarginInline,
      horizontalItemBorderRadius: 0,
      horizontalItemHoverBg: "transparent",
      itemHeight: controlHeightLG,
      groupTitleLineHeight: lineHeight,
      collapsedWidth: controlHeightLG * 2,
      popupBg: colorBgElevated,
      itemMarginBlock: marginXXS,
      itemPaddingInline: padding,
      horizontalLineHeight: `${controlHeightLG * 1.15}px`,
      iconSize: fontSize,
      iconMarginInlineEnd: controlHeightSM - fontSize,
      collapsedIconSize: fontSizeLG,
      groupTitleFontSize: fontSize,
darkItemDisabledColor: new FastColor(colorTextLightSolid).setA(0.25).toRgbString(),
darkItemColor: colorTextDark,
      darkDangerItemColor: colorError,
      darkItemBg: "#001529",
      darkPopupBg: "#001529",
      darkSubMenuItemBg: "#000c17",
      darkItemSelectedColor: colorTextLightSolid,
      darkItemSelectedBg: colorPrimary,
      darkDangerItemSelectedBg: colorError,
      darkItemHoverBg: "transparent",
      darkGroupTitleColor: colorTextDark,
      darkItemHoverColor: colorTextLightSolid,
      darkDangerItemHoverColor: colorErrorHover,
      darkDangerItemSelectedColor: colorTextLightSolid,
      darkDangerItemActiveBg: colorError,
itemWidth: activeBarWidth ? `calc(100% + ${activeBarBorderWidth}px)` : `calc(100% - ${itemMarginInline * 2}px)`
    };
  };
  const useStyle$p = (prefixCls, rootCls = prefixCls, injectStyle = true) => {
    const useStyle2 = genStyleHooks("Menu", (token2) => {
      const {
        colorBgElevated,
        controlHeightLG,
        fontSize,
        darkItemColor,
        darkDangerItemColor,
        darkItemBg,
        darkSubMenuItemBg,
        darkItemSelectedColor,
        darkItemSelectedBg,
        darkDangerItemSelectedBg,
        darkItemHoverBg,
        darkGroupTitleColor,
        darkItemHoverColor,
        darkItemDisabledColor,
        darkDangerItemHoverColor,
        darkDangerItemSelectedColor,
        darkDangerItemActiveBg,
        popupBg,
        darkPopupBg
      } = token2;
      const menuArrowSize = token2.calc(fontSize).div(7).mul(5).equal();
      const menuToken = merge$1(token2, {
        menuArrowSize,
        menuHorizontalHeight: token2.calc(controlHeightLG).mul(1.15).equal(),
        menuArrowOffset: token2.calc(menuArrowSize).mul(0.25).equal(),
        menuSubMenuBg: colorBgElevated,
        calc: token2.calc,
        popupBg
      });
      const menuDarkToken = merge$1(menuToken, {
        itemColor: darkItemColor,
        itemHoverColor: darkItemHoverColor,
        groupTitleColor: darkGroupTitleColor,
        itemSelectedColor: darkItemSelectedColor,
        subMenuItemSelectedColor: darkItemSelectedColor,
        itemBg: darkItemBg,
        popupBg: darkPopupBg,
        subMenuItemBg: darkSubMenuItemBg,
        itemActiveBg: "transparent",
        itemSelectedBg: darkItemSelectedBg,
        activeBarHeight: 0,
        activeBarBorderWidth: 0,
        itemHoverBg: darkItemHoverBg,
itemDisabledColor: darkItemDisabledColor,
dangerItemColor: darkDangerItemColor,
        dangerItemHoverColor: darkDangerItemHoverColor,
        dangerItemSelectedColor: darkDangerItemSelectedColor,
        dangerItemActiveBg: darkDangerItemActiveBg,
        dangerItemSelectedBg: darkDangerItemSelectedBg,
        menuSubMenuBg: darkSubMenuItemBg,
horizontalItemSelectedColor: darkItemSelectedColor,
        horizontalItemSelectedBg: darkItemSelectedBg
      });
      return [
getBaseStyle(menuToken),
getHorizontalStyle(menuToken),

getVerticalStyle(menuToken),

getThemeStyle(menuToken, "light"),
        getThemeStyle(menuDarkToken, "dark"),
getRTLStyle(menuToken),
genCollapseMotion(menuToken),
        initSlideMotion(menuToken, "slide-up"),
        initSlideMotion(menuToken, "slide-down"),
        initZoomMotion(menuToken, "zoom-big")
      ];
    }, prepareComponentToken$g, {
      deprecatedTokens: [["colorGroupTitle", "groupTitleColor"], ["radiusItem", "itemBorderRadius"], ["radiusSubMenuItem", "subMenuItemBorderRadius"], ["colorItemText", "itemColor"], ["colorItemTextHover", "itemHoverColor"], ["colorItemTextHoverHorizontal", "horizontalItemHoverColor"], ["colorItemTextSelected", "itemSelectedColor"], ["colorItemTextSelectedHorizontal", "horizontalItemSelectedColor"], ["colorItemTextDisabled", "itemDisabledColor"], ["colorDangerItemText", "dangerItemColor"], ["colorDangerItemTextHover", "dangerItemHoverColor"], ["colorDangerItemTextSelected", "dangerItemSelectedColor"], ["colorDangerItemBgActive", "dangerItemActiveBg"], ["colorDangerItemBgSelected", "dangerItemSelectedBg"], ["colorItemBg", "itemBg"], ["colorItemBgHover", "itemHoverBg"], ["colorSubItemBg", "subMenuItemBg"], ["colorItemBgActive", "itemActiveBg"], ["colorItemBgSelectedHorizontal", "horizontalItemSelectedBg"], ["colorActiveBarWidth", "activeBarWidth"], ["colorActiveBarHeight", "activeBarHeight"], ["colorActiveBarBorderSize", "activeBarBorderWidth"], ["colorItemBgSelected", "itemSelectedBg"]],
injectStyle,
      unitless: {
        groupTitleLineHeight: true
      }
    });
    return useStyle2(prefixCls, rootCls);
  };
  const SubMenu = (props) => {
    const {
      popupClassName,
      icon,
      title,
      theme: customTheme
    } = props;
    const context = reactExports.useContext(MenuContext);
    const {
      prefixCls,
      inlineCollapsed,
      theme: contextTheme,
      classNames,
      styles
    } = context;
    const parentPath = useFullPath();
    let titleNode;
    if (!icon) {
      titleNode = inlineCollapsed && !parentPath.length && title && typeof title === "string" ? reactExports.createElement("div", {
        className: `${prefixCls}-inline-collapsed-noicon`
      }, title.charAt(0)) : reactExports.createElement("span", {
        className: `${prefixCls}-title-content`
      }, title);
    } else {
      const titleIsSpan = reactExports.isValidElement(title) && title.type === "span";
      titleNode = reactExports.createElement(reactExports.Fragment, null, cloneElement(icon, (oriProps) => ({
        className: clsx(oriProps.className, `${prefixCls}-item-icon`, classNames?.itemIcon),
        style: {
          ...oriProps.style,
          ...styles?.itemIcon
        }
      })), titleIsSpan ? title : reactExports.createElement("span", {
        className: `${prefixCls}-title-content`
      }, title));
    }
    const contextValue = reactExports.useMemo(() => ({
      ...context,
      firstLevel: false
    }), [context]);
    const [zIndex] = useZIndex("Menu");
    return reactExports.createElement(MenuContext.Provider, {
      value: contextValue
    }, reactExports.createElement(SubMenu$1, {
      ...omit(props, ["icon"]),
      title: titleNode,
      classNames: {
        list: classNames?.subMenu?.list,
        listTitle: classNames?.subMenu?.itemTitle
      },
      styles: {
        list: styles?.subMenu?.list,
        listTitle: styles?.subMenu?.itemTitle
      },
      popupClassName: clsx(prefixCls, popupClassName, classNames?.popup?.root, `${prefixCls}-${customTheme || contextTheme}`),
      popupStyle: {
        zIndex,
...props.popupStyle,
        ...styles?.popup?.root
      }
    }));
  };
  function isEmptyIcon(icon) {
    return icon === null || icon === false;
  }
  const MENU_COMPONENTS = {
    item: MenuItem,
    submenu: SubMenu,
    divider: MenuDivider
  };
  const InternalMenu = reactExports.forwardRef((props, ref2) => {
    const override = reactExports.useContext(OverrideContext);
    const overrideObj = override || {};
    const {
      prefixCls: customizePrefixCls,
      className,
      style: style2,
      theme: theme2 = "light",
      expandIcon,
      _internalDisableMenuItemTitleTooltip,
      tooltip,
      inlineCollapsed,
      siderCollapsed,
      rootClassName,
      mode,
      selectable,
      onClick,
      overflowedIndicatorPopupClassName,
      classNames,
      styles,
      ...restProps
    } = props;
    const {
      menu
    } = reactExports.useContext(ConfigContext);
    const {
      getPrefixCls,
      getPopupContainer,
      direction,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("menu");
    const rootPrefixCls = getPrefixCls();
    const passedProps = omit(restProps, ["collapsedWidth"]);
    overrideObj.validator?.({
      mode
    });
    const onItemClick = useEvent$1((...args) => {
      onClick?.(...args);
      overrideObj.onClick?.();
    });
    const mergedMode = overrideObj.mode || mode;
    const mergedSelectable = selectable ?? overrideObj.selectable;
    const mergedInlineCollapsed = inlineCollapsed ?? siderCollapsed;
    const mergedProps = {
      ...props,
      mode: mergedMode,
      inlineCollapsed: mergedInlineCollapsed,
      selectable: mergedSelectable,
      theme: theme2
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    }, {
      popup: {
        _default: "root"
      },
      subMenu: {
        _default: "item"
      }
    });
    const defaultMotions = {
      horizontal: {
        motionName: `${rootPrefixCls}-slide-up`
      },
      inline: initCollapseMotion(rootPrefixCls),
      other: {
        motionName: `${rootPrefixCls}-zoom-big`
      }
    };
    const prefixCls = getPrefixCls("menu", customizePrefixCls || overrideObj.prefixCls);
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$p(prefixCls, rootCls, !override);
    const menuClassName = clsx(`${prefixCls}-${theme2}`, contextClassName, className);
    const mergedExpandIcon = reactExports.useMemo(() => {
      if (typeof expandIcon === "function" || isEmptyIcon(expandIcon)) {
        return expandIcon || null;
      }
      if (typeof overrideObj.expandIcon === "function" || isEmptyIcon(overrideObj.expandIcon)) {
        return overrideObj.expandIcon || null;
      }
      if (typeof menu?.expandIcon === "function" || isEmptyIcon(menu?.expandIcon)) {
        return menu?.expandIcon || null;
      }
      const mergedIcon = expandIcon ?? overrideObj?.expandIcon ?? menu?.expandIcon;
      return cloneElement(mergedIcon, {
        className: clsx(`${prefixCls}-submenu-expand-icon`, reactExports.isValidElement(mergedIcon) ? mergedIcon.props?.className : void 0)
      });
    }, [expandIcon, overrideObj?.expandIcon, menu?.expandIcon, prefixCls]);
    const contextValue = reactExports.useMemo(() => ({
      prefixCls,
      inlineCollapsed: mergedInlineCollapsed || false,
      direction,
      firstLevel: true,
      theme: theme2,
      mode: mergedMode,
      disableMenuItemTitleTooltip: _internalDisableMenuItemTitleTooltip,
      tooltip,
      classNames: mergedClassNames,
      styles: mergedStyles
    }), [prefixCls, mergedInlineCollapsed, direction, _internalDisableMenuItemTitleTooltip, theme2, mergedMode, mergedClassNames, mergedStyles, tooltip]);
    return reactExports.createElement(OverrideContext.Provider, {
      value: null
    }, reactExports.createElement(MenuContext.Provider, {
      value: contextValue
    }, reactExports.createElement(ExportMenu, {
      getPopupContainer,
      overflowedIndicator: reactExports.createElement(RefIcon$a, null),
      overflowedIndicatorPopupClassName: clsx(prefixCls, `${prefixCls}-${theme2}`, overflowedIndicatorPopupClassName),
      classNames: {
        list: mergedClassNames.list,
        listTitle: mergedClassNames.itemTitle
      },
      styles: {
        list: mergedStyles.list,
        listTitle: mergedStyles.itemTitle
      },
      mode: mergedMode,
      selectable: mergedSelectable,
      onClick: onItemClick,
      ...passedProps,
      inlineCollapsed: mergedInlineCollapsed,
      style: {
        ...mergedStyles.root,
        ...contextStyle,
        ...style2
      },
      className: menuClassName,
      prefixCls,
      direction,
      defaultMotions,
      expandIcon: mergedExpandIcon,
      ref: ref2,
      rootClassName: clsx(rootClassName, hashId, overrideObj.rootClassName, cssVarCls, rootCls, mergedClassNames.root),
      _internalComponents: MENU_COMPONENTS
    })));
  });
  const Menu = reactExports.forwardRef((props, ref2) => {
    const menuRef = reactExports.useRef(null);
    const context = reactExports.useContext(SiderContext);
    reactExports.useImperativeHandle(ref2, () => ({
      menu: menuRef.current,
      focus: (options) => {
        menuRef.current?.focus(options);
      }
    }));
    return reactExports.createElement(InternalMenu, {
      ref: menuRef,
      ...props,
      ...context
    });
  });
  Menu.Item = MenuItem;
  Menu.SubMenu = SubMenu;
  Menu.Divider = MenuDivider;
  Menu.ItemGroup = MenuItemGroup;
  const genStatusStyle$1 = (token2) => {
    const {
      componentCls,
      menuCls,
      colorError,
      colorTextLightSolid
    } = token2;
    const itemCls = `${menuCls}-item`;
    return {
      [`${componentCls}, ${componentCls}-menu-submenu`]: {
        [`${menuCls} ${itemCls}`]: {
          [`&${itemCls}-danger:not(${itemCls}-disabled)`]: {
            color: colorError,
            "&:hover": {
              color: colorTextLightSolid,
              backgroundColor: colorError
            }
          }
        }
      }
    };
  };
  const genBaseStyle$3 = (token2) => {
    const {
      componentCls,
      menuCls,
      zIndexPopup,
      dropdownArrowDistance,
      sizePopupArrow,
      antCls,
      iconCls,
      motionDurationMid,
      paddingBlock,
      fontSize,
      dropdownEdgeChildPadding,
      colorTextDisabled,
      fontSizeIcon,
      controlPaddingHorizontal,
      colorBgElevated
    } = token2;
    return [
      {
        [componentCls]: {
          position: "absolute",
          top: -9999,
          left: {
            _skip_check_: true,
            value: -9999
          },
          zIndex: zIndexPopup,
          display: "block",
"&::before": {
            position: "absolute",
            insetBlock: token2.calc(sizePopupArrow).div(2).sub(dropdownArrowDistance).equal(),
zIndex: -9999,
            opacity: 1e-4,
            content: '""'
          },
"&-menu-vertical": {
            maxHeight: "100vh",
            overflowY: "auto"
          },
          [`&-trigger${antCls}-btn`]: {
            [`& > ${iconCls}-down, & > ${antCls}-btn-icon > ${iconCls}-down`]: {
              fontSize: fontSizeIcon
            }
          },
          [`${componentCls}-wrap`]: {
            position: "relative",
            [`${antCls}-btn > ${iconCls}-down`]: {
              fontSize: fontSizeIcon
            },
            [`${iconCls}-down::before`]: {
              transition: `transform ${motionDurationMid}`
            }
          },
          [`${componentCls}-wrap-open`]: {
            [`${iconCls}-down::before`]: {
              transform: `rotate(180deg)`
            }
          },
          [`
        &-hidden,
        &-menu-hidden,
        &-menu-submenu-hidden
      `]: {
            display: "none"
          },




[`&${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomRight,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomRight`]: {
            animationName: slideUpIn
          },
          [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-top,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-top,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topRight`]: {
            animationName: slideDownIn
          },
          [`&${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomRight`]: {
            animationName: slideUpOut
          },
          [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-top,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topRight`]: {
            animationName: slideDownOut
          }
        }
      },


getArrowStyle(token2, colorBgElevated, {
        arrowPlacement: {
          top: true,
          bottom: true
        }
      }),
      {


[`${componentCls} ${menuCls}`]: {
          position: "relative",
          margin: 0
        },
        [`${menuCls}-submenu-popup`]: {
          position: "absolute",
          zIndex: zIndexPopup,
          background: "transparent",
          boxShadow: "none",
          transformOrigin: "0 0",
          "ul, li": {
            listStyle: "none",
            margin: 0
          }
        },
        [`${componentCls}, ${componentCls}-menu-submenu`]: {
          ...resetComponent(token2),
          [menuCls]: {
            padding: dropdownEdgeChildPadding,
            listStyleType: "none",
            backgroundColor: colorBgElevated,
            backgroundClip: "padding-box",
            borderRadius: token2.borderRadiusLG,
            outline: "none",
            boxShadow: token2.boxShadowSecondary,
            ...genFocusStyle(token2),
            "&:empty": {
              padding: 0,
              boxShadow: "none"
            },
            [`${menuCls}-item-group-title`]: {
              padding: `${unit$1(paddingBlock)} ${unit$1(controlPaddingHorizontal)}`,
              color: token2.colorTextDescription,
              transition: `all ${motionDurationMid}`
            },
[`${menuCls}-item`]: {
              position: "relative",
              display: "flex",
              alignItems: "center"
            },
            [`${menuCls}-item-icon`]: {
              minWidth: fontSize,
              marginInlineEnd: token2.marginXS,
              fontSize: token2.fontSizeSM
            },
            [`${menuCls}-title-content`]: {
              flex: "auto",
              "&-with-extra": {
                display: "inline-flex",
                alignItems: "center",
                width: "100%"
              },
              "> a": {
                color: "inherit",
                transition: `all ${motionDurationMid}`,
                "&:hover": {
                  color: "inherit"
                },
                "&::after": {
                  position: "absolute",
                  inset: 0,
                  content: '""'
                }
              },
              [`${menuCls}-item-extra`]: {
                paddingInlineStart: token2.padding,
                marginInlineStart: "auto",
                fontSize: token2.fontSizeSM,
                color: token2.colorTextDescription
              }
            },
[`${menuCls}-item, ${menuCls}-submenu-title`]: {
              display: "flex",
              margin: 0,
              padding: `${unit$1(paddingBlock)} ${unit$1(controlPaddingHorizontal)}`,
              color: token2.colorText,
              fontWeight: "normal",
              fontSize,
              lineHeight: token2.lineHeight,
              cursor: "pointer",
              transition: `all ${motionDurationMid}`,
              borderRadius: token2.borderRadiusSM,
              "&:hover, &-active": {
                backgroundColor: token2.controlItemBgHover
              },
              ...genFocusStyle(token2),
              "&-selected": {
                color: token2.colorPrimary,
                backgroundColor: token2.controlItemBgActive,
                "&:hover, &-active": {
                  backgroundColor: token2.controlItemBgActiveHover
                }
              },
              "&-disabled": {
                color: colorTextDisabled,
                cursor: "not-allowed",
                "&:hover": {
                  color: colorTextDisabled,
                  backgroundColor: colorBgElevated,
                  cursor: "not-allowed"
                },
                a: {
                  pointerEvents: "none"
                }
              },
              "&-divider": {
                height: 1,
margin: `${unit$1(token2.marginXXS)} 0`,
                overflow: "hidden",
                lineHeight: 0,
                backgroundColor: token2.colorSplit
              },
              [`${componentCls}-menu-submenu-expand-icon`]: {
                position: "absolute",
                insetInlineEnd: token2.paddingXS,
                [`${componentCls}-menu-submenu-arrow-icon`]: {
                  marginInlineEnd: "0 !important",
                  color: token2.colorIcon,
                  fontSize: fontSizeIcon,
                  fontStyle: "normal"
                }
              }
            },
            [`${menuCls}-item-group-list`]: {
              margin: `0 ${unit$1(token2.marginXS)}`,
              padding: 0,
              listStyle: "none"
            },
            [`${menuCls}-submenu-title`]: {
              paddingInlineEnd: token2.calc(controlPaddingHorizontal).add(token2.fontSizeSM).equal()
            },
            [`${menuCls}-submenu-vertical`]: {
              position: "relative"
            },
            [`${menuCls}-submenu${menuCls}-submenu-disabled ${componentCls}-menu-submenu-title`]: {
              [`&, ${componentCls}-menu-submenu-arrow-icon`]: {
                color: colorTextDisabled,
                backgroundColor: colorBgElevated,
                cursor: "not-allowed"
              }
            },
[`${menuCls}-submenu-selected ${componentCls}-menu-submenu-title`]: {
              color: token2.colorPrimary
            }
          }
        }
      },
[initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down"), initMoveMotion(token2, "move-up"), initMoveMotion(token2, "move-down"), initZoomMotion(token2, "zoom-big")]
    ];
  };
  const prepareComponentToken$f = (token2) => ({
    zIndexPopup: token2.zIndexPopupBase + 50,
    paddingBlock: (token2.controlHeight - token2.fontSize * token2.lineHeight) / 2,
    ...getArrowOffsetToken({
      contentRadius: token2.borderRadiusLG,
      limitVerticalRadius: true
    }),
    ...getArrowToken(token2)
  });
  const useStyle$o = genStyleHooks("Dropdown", (token2) => {
    const {
      marginXXS,
      sizePopupArrow,
      paddingXXS,
      componentCls
    } = token2;
    const dropdownToken = merge$1(token2, {
      menuCls: `${componentCls}-menu`,
      dropdownArrowDistance: token2.calc(sizePopupArrow).div(2).add(marginXXS).equal(),
      dropdownEdgeChildPadding: paddingXXS
    });
    return [genBaseStyle$3(dropdownToken), genStatusStyle$1(dropdownToken)];
  }, prepareComponentToken$f, {
    resetStyle: false
  });
  const Dropdown$1 = (props) => {
    const {
      menu,
      arrow,
      prefixCls: customizePrefixCls,
      children,
      trigger: trigger2,
      disabled,
      dropdownRender,
      popupRender,
      getPopupContainer,
      overlayClassName,
      rootClassName,
      overlayStyle,
      open: open2,
      onOpenChange,
      mouseEnterDelay = 0.15,
      mouseLeaveDelay = 0.1,
      autoAdjustOverflow: autoAdjustOverflow2 = true,
      placement = "",
      transitionName,
      classNames,
      styles,
      destroyPopupOnHide,
      destroyOnHidden
    } = props;
    const {
      getPrefixCls,
      direction,
      getPopupContainer: getContextPopupContainer,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("dropdown");
    const mergedProps = {
      ...props,
      mouseEnterDelay,
      mouseLeaveDelay,
      autoAdjustOverflow: autoAdjustOverflow2
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const mergedRootStyles = {
      ...contextStyle,
      ...overlayStyle,
      ...mergedStyles.root
    };
    const mergedPopupRender = popupRender || dropdownRender;
    const memoTransitionName = reactExports.useMemo(() => {
      const rootPrefixCls = getPrefixCls();
      if (transitionName !== void 0) {
        return transitionName;
      }
      if (placement.includes("top")) {
        return `${rootPrefixCls}-slide-down`;
      }
      return `${rootPrefixCls}-slide-up`;
    }, [getPrefixCls, placement, transitionName]);
    const memoPlacement = reactExports.useMemo(() => {
      if (!placement) {
        return direction === "rtl" ? "bottomRight" : "bottomLeft";
      }
      if (placement.includes("Center")) {
        return placement.slice(0, placement.indexOf("Center"));
      }
      return placement;
    }, [placement, direction]);
    const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$o(prefixCls, rootCls);
    const [, token2] = useToken$1();
    const child = reactExports.Children.only(isPrimitive(children) ? reactExports.createElement("span", null, children) : children);
    const popupTrigger = cloneElement(child, {
      className: clsx(`${prefixCls}-trigger`, {
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, child.props.className),
      disabled: child.props.disabled ?? disabled
    });
    const triggerActions = disabled ? [] : trigger2;
    const alignPoint = !!triggerActions?.includes("contextMenu");
    const [mergedOpen, setOpen] = useControlledState(false, open2);
    const onInnerOpenChange = useEvent$1((nextOpen) => {
      onOpenChange?.(nextOpen, {
        source: "trigger"
      });
      setOpen(nextOpen);
    });
    const overlayClassNameCustomized = clsx(overlayClassName, rootClassName, hashId, cssVarCls, rootCls, contextClassName, mergedClassNames.root, {
      [`${prefixCls}-rtl`]: direction === "rtl"
    });
    const builtinPlacements = getPlacements({
      arrowPointAtCenter: typeof arrow === "object" && arrow.pointAtCenter,
      autoAdjustOverflow: autoAdjustOverflow2,
      offset: token2.marginXXS,
      arrowWidth: arrow ? token2.sizePopupArrow : 0,
      borderRadius: token2.borderRadius
    });
    const onMenuClick = useEvent$1(() => {
      if (menu?.selectable && menu?.multiple) {
        return;
      }
      onOpenChange?.(false, {
        source: "menu"
      });
      setOpen(false);
    });
    const renderOverlay = () => {
      const menuClassNames = omit(mergedClassNames, ["root"]);
      const menuStyles = omit(mergedStyles, ["root"]);
      let overlayNode;
      if (menu?.items) {
        overlayNode = reactExports.createElement(Menu, {
          ...menu,
          classNames: {
            ...menuClassNames,
            subMenu: {
              ...menuClassNames
            }
          },
          styles: {
            ...menuStyles,
            subMenu: {
              ...menuStyles
            }
          }
        });
      }
      if (mergedPopupRender) {
        overlayNode = mergedPopupRender(overlayNode);
      }
      overlayNode = reactExports.Children.only(typeof overlayNode === "string" ? reactExports.createElement("span", null, overlayNode) : overlayNode);
      return reactExports.createElement(OverrideProvider, {
        prefixCls: `${prefixCls}-menu`,
        rootClassName: clsx(cssVarCls, rootCls),
        expandIcon: reactExports.createElement("span", {
          className: `${prefixCls}-menu-submenu-arrow`
        }, direction === "rtl" ? reactExports.createElement(RefIcon$b, {
          className: `${prefixCls}-menu-submenu-arrow-icon`
        }) : reactExports.createElement(RefIcon$g, {
          className: `${prefixCls}-menu-submenu-arrow-icon`
        })),
        mode: "vertical",
        selectable: false,
        onClick: onMenuClick,
        validator: ({
          mode
        }) => {
        }
      }, overlayNode);
    };
    const [zIndex, contextZIndex] = useZIndex("Dropdown", mergedRootStyles.zIndex);
    let renderNode = reactExports.createElement(Dropdown$2, {
      alignPoint,
      ...omit(props, ["rootClassName", "onOpenChange"]),
      mouseEnterDelay,
      mouseLeaveDelay,
      visible: mergedOpen,
      builtinPlacements,
      arrow: !!arrow,
      overlayClassName: overlayClassNameCustomized,
      prefixCls,
      getPopupContainer: getPopupContainer || getContextPopupContainer,
      transitionName: memoTransitionName,
      trigger: triggerActions,
      overlay: renderOverlay,
      placement: memoPlacement,
      onVisibleChange: onInnerOpenChange,
      overlayStyle: {
        ...mergedRootStyles,
        zIndex
      },
      autoDestroy: destroyOnHidden ?? destroyPopupOnHide
    }, popupTrigger);
    if (zIndex) {
      renderNode = reactExports.createElement(ZIndexContext.Provider, {
        value: contextZIndex
      }, renderNode);
    }
    return renderNode;
  };
  const PurePanel$5 = genPurePanel(Dropdown$1, "align", void 0, "dropdown", (prefixCls) => prefixCls);
  const WrapPurePanel = (props) => reactExports.createElement(PurePanel$5, {
    ...props
  }, reactExports.createElement("span", null));
  Dropdown$1._InternalPanelDoNotUseOrYouWillBeFired = WrapPurePanel;
  var dayjs_min$1 = { exports: {} };
  var dayjs_min = dayjs_min$1.exports;
  var hasRequiredDayjs_min;
  function requireDayjs_min() {
    if (hasRequiredDayjs_min) return dayjs_min$1.exports;
    hasRequiredDayjs_min = 1;
    (function(module, exports$1) {
      !(function(t2, e) {
        module.exports = e();
      })(dayjs_min, (function() {
        var t2 = 1e3, e = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
          var e2 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
          return "[" + t3 + (e2[(n3 - 20) % 10] || e2[n3] || e2[0]) + "]";
        } }, m2 = function(t3, e2, n3) {
          var r3 = String(t3);
          return !r3 || r3.length >= e2 ? t3 : "" + Array(e2 + 1 - r3.length).join(n3) + t3;
        }, v = { s: m2, z: function(t3) {
          var e2 = -t3.utcOffset(), n3 = Math.abs(e2), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
          return (e2 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
        }, m: function t3(e2, n3) {
          if (e2.date() < n3.date()) return -t3(n3, e2);
          var r3 = 12 * (n3.year() - e2.year()) + (n3.month() - e2.month()), i3 = e2.clone().add(r3, c2), s3 = n3 - i3 < 0, u3 = e2.clone().add(r3 + (s3 ? -1 : 1), c2);
          return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
        }, a: function(t3) {
          return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
        }, p: function(t3) {
          return { M: c2, y: h2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i2, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t3) {
          return void 0 === t3;
        } }, g2 = "en", D = {};
        D[g2] = M;
        var p2 = "$isDayjsObject", S = function(t3) {
          return t3 instanceof _2 || !(!t3 || !t3[p2]);
        }, w = function t3(e2, n3, r3) {
          var i3;
          if (!e2) return g2;
          if ("string" == typeof e2) {
            var s3 = e2.toLowerCase();
            D[s3] && (i3 = s3), n3 && (D[s3] = n3, i3 = s3);
            var u3 = e2.split("-");
            if (!i3 && u3.length > 1) return t3(u3[0]);
          } else {
            var a3 = e2.name;
            D[a3] = e2, i3 = a3;
          }
          return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
        }, O = function(t3, e2) {
          if (S(t3)) return t3.clone();
          var n3 = "object" == typeof e2 ? e2 : {};
          return n3.date = t3, n3.args = arguments, new _2(n3);
        }, b = v;
        b.l = w, b.i = S, b.w = function(t3, e2) {
          return O(t3, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
        };
        var _2 = (function() {
          function M2(t3) {
            this.$L = w(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
          }
          var m3 = M2.prototype;
          return m3.parse = function(t3) {
            this.$d = (function(t4) {
              var e2 = t4.date, n3 = t4.utc;
              if (null === e2) return new Date(NaN);
              if (b.u(e2)) return new Date();
              if (e2 instanceof Date) return new Date(e2);
              if ("string" == typeof e2 && !/Z$/i.test(e2)) {
                var r3 = e2.match($);
                if (r3) {
                  var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
                  return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
                }
              }
              return new Date(e2);
            })(t3), this.init();
          }, m3.init = function() {
            var t3 = this.$d;
            this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
          }, m3.$utils = function() {
            return b;
          }, m3.isValid = function() {
            return !(this.$d.toString() === l2);
          }, m3.isSame = function(t3, e2) {
            var n3 = O(t3);
            return this.startOf(e2) <= n3 && n3 <= this.endOf(e2);
          }, m3.isAfter = function(t3, e2) {
            return O(t3) < this.startOf(e2);
          }, m3.isBefore = function(t3, e2) {
            return this.endOf(e2) < O(t3);
          }, m3.$g = function(t3, e2, n3) {
            return b.u(t3) ? this[e2] : this.set(n3, t3);
          }, m3.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m3.valueOf = function() {
            return this.$d.getTime();
          }, m3.startOf = function(t3, e2) {
            var n3 = this, r3 = !!b.u(e2) || e2, f3 = b.p(t3), l3 = function(t4, e3) {
              var i3 = b.w(n3.$u ? Date.UTC(n3.$y, e3, t4) : new Date(n3.$y, e3, t4), n3);
              return r3 ? i3 : i3.endOf(a2);
            }, $2 = function(t4, e3) {
              return b.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n3);
            }, y2 = this.$W, M3 = this.$M, m4 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
            switch (f3) {
              case h2:
                return r3 ? l3(1, 0) : l3(31, 11);
              case c2:
                return r3 ? l3(1, M3) : l3(0, M3 + 1);
              case o2:
                var g3 = this.$locale().weekStart || 0, D2 = (y2 < g3 ? y2 + 7 : y2) - g3;
                return l3(r3 ? m4 - D2 : m4 + (6 - D2), M3);
              case a2:
              case d2:
                return $2(v2 + "Hours", 0);
              case u2:
                return $2(v2 + "Minutes", 1);
              case s2:
                return $2(v2 + "Seconds", 2);
              case i2:
                return $2(v2 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m3.endOf = function(t3) {
            return this.startOf(t3, false);
          }, m3.$set = function(t3, e2) {
            var n3, o3 = b.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = f3 + "Date", n3[d2] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s2] = f3 + "Minutes", n3[i2] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $2 = o3 === a2 ? this.$D + (e2 - this.$W) : e2;
            if (o3 === c2 || o3 === h2) {
              var y2 = this.clone().set(d2, 1);
              y2.$d[l3]($2), y2.init(), this.$d = y2.set(d2, Math.min(this.$D, y2.daysInMonth())).$d;
            } else l3 && this.$d[l3]($2);
            return this.init(), this;
          }, m3.set = function(t3, e2) {
            return this.clone().$set(t3, e2);
          }, m3.get = function(t3) {
            return this[b.p(t3)]();
          }, m3.add = function(r3, f3) {
            var d3, l3 = this;
            r3 = Number(r3);
            var $2 = b.p(f3), y2 = function(t3) {
              var e2 = O(l3);
              return b.w(e2.date(e2.date() + Math.round(t3 * r3)), l3);
            };
            if ($2 === c2) return this.set(c2, this.$M + r3);
            if ($2 === h2) return this.set(h2, this.$y + r3);
            if ($2 === a2) return y2(1);
            if ($2 === o2) return y2(7);
            var M3 = (d3 = {}, d3[s2] = e, d3[u2] = n2, d3[i2] = t2, d3)[$2] || 1, m4 = this.$d.getTime() + r3 * M3;
            return b.w(m4, this);
          }, m3.subtract = function(t3, e2) {
            return this.add(-1 * t3, e2);
          }, m3.format = function(t3) {
            var e2 = this, n3 = this.$locale();
            if (!this.isValid()) return n3.invalidDate || l2;
            var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = function(t4, n4, i4, s4) {
              return t4 && (t4[n4] || t4(e2, r3)) || i4[n4].slice(0, s4);
            }, d3 = function(t4) {
              return b.s(s3 % 12 || 12, t4, "0");
            }, $2 = f3 || function(t4, e3, n4) {
              var r4 = t4 < 12 ? "AM" : "PM";
              return n4 ? r4.toLowerCase() : r4;
            };
            return r3.replace(y, (function(t4, r4) {
              return r4 || (function(t5) {
                switch (t5) {
                  case "YY":
                    return String(e2.$y).slice(-2);
                  case "YYYY":
                    return b.s(e2.$y, 4, "0");
                  case "M":
                    return a3 + 1;
                  case "MM":
                    return b.s(a3 + 1, 2, "0");
                  case "MMM":
                    return h3(n3.monthsShort, a3, c3, 3);
                  case "MMMM":
                    return h3(c3, a3);
                  case "D":
                    return e2.$D;
                  case "DD":
                    return b.s(e2.$D, 2, "0");
                  case "d":
                    return String(e2.$W);
                  case "dd":
                    return h3(n3.weekdaysMin, e2.$W, o3, 2);
                  case "ddd":
                    return h3(n3.weekdaysShort, e2.$W, o3, 3);
                  case "dddd":
                    return o3[e2.$W];
                  case "H":
                    return String(s3);
                  case "HH":
                    return b.s(s3, 2, "0");
                  case "h":
                    return d3(1);
                  case "hh":
                    return d3(2);
                  case "a":
                    return $2(s3, u3, true);
                  case "A":
                    return $2(s3, u3, false);
                  case "m":
                    return String(u3);
                  case "mm":
                    return b.s(u3, 2, "0");
                  case "s":
                    return String(e2.$s);
                  case "ss":
                    return b.s(e2.$s, 2, "0");
                  case "SSS":
                    return b.s(e2.$ms, 3, "0");
                  case "Z":
                    return i3;
                }
                return null;
              })(t4) || i3.replace(":", "");
            }));
          }, m3.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m3.diff = function(r3, d3, l3) {
            var $2, y2 = this, M3 = b.p(d3), m4 = O(r3), v2 = (m4.utcOffset() - this.utcOffset()) * e, g3 = this - m4, D2 = function() {
              return b.m(y2, m4);
            };
            switch (M3) {
              case h2:
                $2 = D2() / 12;
                break;
              case c2:
                $2 = D2();
                break;
              case f2:
                $2 = D2() / 3;
                break;
              case o2:
                $2 = (g3 - v2) / 6048e5;
                break;
              case a2:
                $2 = (g3 - v2) / 864e5;
                break;
              case u2:
                $2 = g3 / n2;
                break;
              case s2:
                $2 = g3 / e;
                break;
              case i2:
                $2 = g3 / t2;
                break;
              default:
                $2 = g3;
            }
            return l3 ? $2 : b.a($2);
          }, m3.daysInMonth = function() {
            return this.endOf(c2).$D;
          }, m3.$locale = function() {
            return D[this.$L];
          }, m3.locale = function(t3, e2) {
            if (!t3) return this.$L;
            var n3 = this.clone(), r3 = w(t3, e2, true);
            return r3 && (n3.$L = r3), n3;
          }, m3.clone = function() {
            return b.w(this.$d, this);
          }, m3.toDate = function() {
            return new Date(this.valueOf());
          }, m3.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m3.toISOString = function() {
            return this.$d.toISOString();
          }, m3.toString = function() {
            return this.$d.toUTCString();
          }, M2;
        })(), k = _2.prototype;
        return O.prototype = k, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d2]].forEach((function(t3) {
          k[t3[1]] = function(e2) {
            return this.$g(e2, t3[0], t3[1]);
          };
        })), O.extend = function(t3, e2) {
          return t3.$i || (t3(e2, _2, O), t3.$i = true), O;
        }, O.locale = w, O.isDayjs = S, O.unix = function(t3) {
          return O(1e3 * t3);
        }, O.en = D[g2], O.Ls = D, O.p = {}, O;
      }));
    })(dayjs_min$1);
    return dayjs_min$1.exports;
  }
  var dayjs_minExports = requireDayjs_min();
  const dayjs = getDefaultExportFromCjs(dayjs_minExports);
  function toArray(candidate) {
    if (candidate === void 0 || candidate === false) {
      return [];
    }
    return Array.isArray(candidate) ? candidate : [candidate];
  }
  function toNamePathStr(name) {
    const namePath = toArray(name);
    return namePath.join("_");
  }
  const RadioGroupContext = reactExports.createContext(void 0);
  const RadioGroupContextProvider = RadioGroupContext.Provider;
  const RadioOptionTypeContext = reactExports.createContext(void 0);
  const RadioOptionTypeContextProvider = RadioOptionTypeContext.Provider;
  function _extends$n() {
    _extends$n = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$n.apply(this, arguments);
  }
  const Checkbox$2 = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls = "rc-checkbox",
      className,
      style: style2,
      checked,
      disabled,
      defaultChecked = false,
      type: type4 = "checkbox",
      title,
      onChange,
      ...inputProps
    } = props;
    const inputRef = reactExports.useRef(null);
    const holderRef = reactExports.useRef(null);
    const [rawValue, setRawValue] = useControlledState(defaultChecked, checked);
    reactExports.useImperativeHandle(ref2, () => ({
      focus: (options) => {
        inputRef.current?.focus(options);
      },
      blur: () => {
        inputRef.current?.blur();
      },
      input: inputRef.current,
      nativeElement: holderRef.current
    }));
    const classString = clsx(prefixCls, className, {
      [`${prefixCls}-checked`]: rawValue,
      [`${prefixCls}-disabled`]: disabled
    });
    const handleChange = (e) => {
      if (disabled) {
        return;
      }
      if (!("checked" in props)) {
        setRawValue(e.target.checked);
      }
      onChange?.({
        target: {
          ...props,
          type: type4,
          checked: e.target.checked
        },
        stopPropagation() {
          e.stopPropagation();
        },
        preventDefault() {
          e.preventDefault();
        },
        nativeEvent: e.nativeEvent
      });
    };
    return reactExports.createElement("span", {
      className: classString,
      title,
      style: style2,
      ref: holderRef
    }, reactExports.createElement("input", _extends$n({}, inputProps, {
      className: `${prefixCls}-input`,
      ref: inputRef,
      onChange: handleChange,
      disabled,
      checked: !!rawValue,
      type: type4
    })));
  });
  function useBubbleLock(onOriginInputClick) {
    const labelClickLockRef = React.useRef(null);
    const clearLock = () => {
      wrapperRaf.cancel(labelClickLockRef.current);
      labelClickLockRef.current = null;
    };
    const onLabelClick = () => {
      clearLock();
      labelClickLockRef.current = wrapperRaf(() => {
        labelClickLockRef.current = null;
      });
    };
    const onInputClick = (e) => {
      if (labelClickLockRef.current) {
        e.stopPropagation();
        clearLock();
      }
      onOriginInputClick?.(e);
    };
    return [onLabelClick, onInputClick];
  }
  const getGroupRadioStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    const groupPrefixCls = `${componentCls}-group`;
    return {
      [groupPrefixCls]: {
        ...resetComponent(token2),
        display: "inline-block",
        fontSize: 0,
[`&${groupPrefixCls}-rtl`]: {
          direction: "rtl"
        },
        [`&${groupPrefixCls}-block`]: {
          display: "flex"
        },
        [`${antCls}-badge ${antCls}-badge-count`]: {
          zIndex: 1
        },
        [`> ${antCls}-badge:not(:first-child) > ${antCls}-button-wrapper`]: {
          borderInlineStart: "none"
        },
        "&-vertical": {
          display: "flex",
          flexDirection: "column",
          rowGap: token2.marginXS,
          [`${componentCls}-wrapper`]: {
            marginInlineEnd: 0
          }
        }
      }
    };
  };
  const getRadioBasicStyle = (token2) => {
    const {
      componentCls,
      wrapperMarginInlineEnd,
      colorPrimary,
      colorPrimaryHover,
      radioSize,
      motionDurationSlow,
      motionDurationMid,
      motionEaseInOutCirc,
      colorBgContainer,
      colorBorder,
      lineWidth,
      colorBgContainerDisabled,
      colorTextDisabled,
      paddingXS,
      dotColorDisabled,
      dotSize,
      lineType,
      radioColor,
      radioBgColor
    } = token2;
    return {
      [`${componentCls}-wrapper`]: {
        ...resetComponent(token2),
        display: "inline-flex",
        alignItems: "baseline",
        marginInlineStart: 0,
        marginInlineEnd: wrapperMarginInlineEnd,
        cursor: "pointer",
        "&:last-child": {
          marginInlineEnd: 0
        },
[`&${componentCls}-wrapper-rtl`]: {
          direction: "rtl"
        },
        "&-disabled": {
          cursor: "not-allowed",
          color: token2.colorTextDisabled
        },
        "&::after": {
          display: "inline-block",
          width: 0,
          overflow: "hidden",
          content: '"\\a0"'
        },
        "&-block": {
          flex: 1,
          justifyContent: "center"
        },
[componentCls]: {
          ...resetComponent(token2),
          position: "relative",
          whiteSpace: "nowrap",
          lineHeight: 1,
          cursor: "pointer",
          alignSelf: "center",
boxSizing: "border-box",
          display: "block",
          width: `calc(${radioSize} * 1px)`,
          height: `calc(${radioSize} * 1px)`,
          backgroundColor: colorBgContainer,
          border: `${unit$1(lineWidth)} ${lineType} ${colorBorder}`,
          borderRadius: "50%",
          transition: `all ${motionDurationMid}`,
"&:after": {
            content: '""',
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%) scale(0)",
            width: `calc(${dotSize} * 1px)`,
            height: `calc(${dotSize} * 1px)`,
            backgroundColor: radioColor,
            borderRadius: "50%",
            transformOrigin: "50% 50%",
            opacity: 0,
            transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`
          },
[`${componentCls}-input`]: {
            position: "absolute",
            inset: 0,
            zIndex: 1,
            cursor: "pointer",
            opacity: 0,
            margin: 0
          },
[`&:has(${componentCls}-input:focus-visible)`]: genFocusOutline(token2)
        },
[`&:hover ${componentCls}`]: {
          borderColor: colorPrimary
        },
        [`&:hover ${componentCls}-checked:not(${componentCls}-disabled)`]: {
          backgroundColor: colorPrimaryHover,
          borderColor: "transparent"
        },
[`${componentCls}-checked`]: {
          backgroundColor: radioBgColor,
          borderColor: colorPrimary,
          "&::after": {
            transform: `translate(-50%, -50%)`,
            opacity: 1
          }
        },
[`${componentCls}-disabled`]: {
[`&, ${componentCls}-input`]: {
            cursor: "not-allowed",
pointerEvents: "none"
          },
background: colorBgContainerDisabled,
          borderColor: colorBorder,
          "&::after": {
            backgroundColor: dotColorDisabled
          }
        },
        [`${componentCls}-disabled + span`]: {
          color: colorTextDisabled,
          cursor: "not-allowed"
        },
        [`span${componentCls} + *`]: {
          paddingInlineStart: paddingXS,
          paddingInlineEnd: paddingXS
        }
      }
    };
  };
  const getRadioButtonStyle = (token2) => {
    const {
      buttonColor,
      controlHeight,
      componentCls,
      lineWidth,
      lineType,
      colorBorder,
      motionDurationMid,
      buttonPaddingInline,
      fontSize,
      buttonBg,
      fontSizeLG,
      controlHeightLG,
      controlHeightSM,
      paddingXS,
      borderRadius,
      borderRadiusSM,
      borderRadiusLG,
      buttonCheckedBg,
      buttonSolidCheckedColor,
      colorTextDisabled,
      colorBgContainerDisabled,
      buttonCheckedBgDisabled,
      buttonCheckedColorDisabled,
      colorPrimary,
      colorPrimaryHover,
      colorPrimaryActive,
      buttonSolidCheckedBg,
      buttonSolidCheckedHoverBg,
      buttonSolidCheckedActiveBg,
      calc
    } = token2;
    return {
      [`${componentCls}-button-wrapper`]: {
        position: "relative",
        display: "inline-block",
        height: controlHeight,
        margin: 0,
        paddingInline: buttonPaddingInline,
        paddingBlock: 0,
        color: buttonColor,
        fontSize,
        lineHeight: unit$1(calc(controlHeight).sub(calc(lineWidth).mul(2)).equal()),
        background: buttonBg,
        border: `${unit$1(lineWidth)} ${lineType} ${colorBorder}`,

borderBlockStartWidth: calc(lineWidth).add(0.02).equal(),
        borderInlineEndWidth: lineWidth,
        cursor: "pointer",
        transition: [`color`, `background-color`, `box-shadow`].map((prop) => `${prop} ${motionDurationMid}`).join(","),
        a: {
          color: buttonColor
        },
        [`> ${componentCls}-button`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          zIndex: -1,
          width: "100%",
          height: "100%"
        },
        "&:not(:last-child)": {
          marginInlineEnd: calc(lineWidth).mul(-1).equal()
        },
        "&:first-child": {
          borderInlineStart: `${unit$1(lineWidth)} ${lineType} ${colorBorder}`,
          borderStartStartRadius: borderRadius,
          borderEndStartRadius: borderRadius
        },
        "&:last-child": {
          borderStartEndRadius: borderRadius,
          borderEndEndRadius: borderRadius
        },
        "&:first-child:last-child": {
          borderRadius
        },
        [`${componentCls}-group-large &`]: {
          height: controlHeightLG,
          fontSize: fontSizeLG,
          lineHeight: unit$1(calc(controlHeightLG).sub(calc(lineWidth).mul(2)).equal()),
          "&:first-child": {
            borderStartStartRadius: borderRadiusLG,
            borderEndStartRadius: borderRadiusLG
          },
          "&:last-child": {
            borderStartEndRadius: borderRadiusLG,
            borderEndEndRadius: borderRadiusLG
          }
        },
        [`${componentCls}-group-small &`]: {
          height: controlHeightSM,
          paddingInline: calc(paddingXS).sub(lineWidth).equal(),
          paddingBlock: 0,
          lineHeight: unit$1(calc(controlHeightSM).sub(calc(lineWidth).mul(2)).equal()),
          "&:first-child": {
            borderStartStartRadius: borderRadiusSM,
            borderEndStartRadius: borderRadiusSM
          },
          "&:last-child": {
            borderStartEndRadius: borderRadiusSM,
            borderEndEndRadius: borderRadiusSM
          }
        },
        "&:hover": {
          position: "relative",
          color: colorPrimary
        },
        "&:has(:focus-visible)": genFocusOutline(token2),
        [`${componentCls}, input[type='checkbox'], input[type='radio']`]: {
          width: 0,
          height: 0,
          opacity: 0,
          pointerEvents: "none"
        },
        [`&-checked:not(${componentCls}-button-wrapper-disabled)`]: {
          zIndex: 1,
          color: colorPrimary,
          background: buttonCheckedBg,
          borderColor: colorPrimary,
          "&::before": {
            backgroundColor: colorPrimary
          },
          "&:first-child": {
            borderColor: colorPrimary
          },
          "&:hover": {
            color: colorPrimaryHover,
            borderColor: colorPrimaryHover,
            "&::before": {
              backgroundColor: colorPrimaryHover
            }
          },
          "&:active": {
            color: colorPrimaryActive,
            borderColor: colorPrimaryActive,
            "&::before": {
              backgroundColor: colorPrimaryActive
            }
          }
        },
        [`${componentCls}-group-solid &-checked:not(${componentCls}-button-wrapper-disabled)`]: {
          color: buttonSolidCheckedColor,
          background: buttonSolidCheckedBg,
          borderColor: buttonSolidCheckedBg,
          "&:hover": {
            color: buttonSolidCheckedColor,
            background: buttonSolidCheckedHoverBg,
            borderColor: buttonSolidCheckedHoverBg
          },
          "&:active": {
            color: buttonSolidCheckedColor,
            background: buttonSolidCheckedActiveBg,
            borderColor: buttonSolidCheckedActiveBg
          }
        },
        "&-disabled": {
          color: colorTextDisabled,
          backgroundColor: colorBgContainerDisabled,
          borderColor: colorBorder,
          cursor: "not-allowed",
          "&:first-child, &:hover": {
            color: colorTextDisabled,
            backgroundColor: colorBgContainerDisabled,
            borderColor: colorBorder
          }
        },
        [`&-disabled${componentCls}-button-wrapper-checked`]: {
          color: buttonCheckedColorDisabled,
          backgroundColor: buttonCheckedBgDisabled,
          borderColor: colorBorder,
          boxShadow: "none"
        },
        "&-block": {
          flex: 1,
          textAlign: "center"
        }
      }
    };
  };
  const prepareComponentToken$e = (token2) => {
    const {
      wireframe,
      padding,
      marginXS,
      lineWidth,
      fontSizeLG,
      colorText,
      colorBgContainer,
      colorTextDisabled,
      controlItemBgActiveDisabled,
      colorTextLightSolid,
      colorPrimary,
      colorPrimaryHover,
      colorPrimaryActive,
      colorWhite
    } = token2;
    const dotPadding = 4;
    const radioSize = fontSizeLG;
    const radioDotSize = wireframe ? radioSize - dotPadding * 2 : radioSize - (dotPadding + lineWidth) * 2;
    return {
radioSize,
      dotSize: radioDotSize,
      dotColorDisabled: colorTextDisabled,
buttonSolidCheckedColor: colorTextLightSolid,
      buttonSolidCheckedBg: colorPrimary,
      buttonSolidCheckedHoverBg: colorPrimaryHover,
      buttonSolidCheckedActiveBg: colorPrimaryActive,
      buttonBg: colorBgContainer,
      buttonCheckedBg: colorBgContainer,
      buttonColor: colorText,
      buttonCheckedBgDisabled: controlItemBgActiveDisabled,
      buttonCheckedColorDisabled: colorTextDisabled,
      buttonPaddingInline: padding - lineWidth,
      wrapperMarginInlineEnd: marginXS,
radioColor: wireframe ? colorPrimary : colorWhite,
      radioBgColor: wireframe ? colorBgContainer : colorPrimary
    };
  };
  const useStyle$n = genStyleHooks("Radio", (token2) => {
    const {
      controlOutline,
      controlOutlineWidth
    } = token2;
    const radioFocusShadow = `0 0 0 ${unit$1(controlOutlineWidth)} ${controlOutline}`;
    const radioButtonFocusShadow = radioFocusShadow;
    const radioToken = merge$1(token2, {
      radioFocusShadow,
      radioButtonFocusShadow
    });
    return [getGroupRadioStyle(radioToken), getRadioBasicStyle(radioToken), getRadioButtonStyle(radioToken)];
  }, prepareComponentToken$e, {
    unitless: {
      radioSize: true,
      dotSize: true
    }
  });
  const InternalRadio = (props, ref2) => {
    const groupContext = reactExports.useContext(RadioGroupContext);
    const radioOptionTypeContext = reactExports.useContext(RadioOptionTypeContext);
    const {
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("radio");
    const innerRef = reactExports.useRef(null);
    const mergedRef = composeRef(ref2, innerRef);
    const {
      isFormItemInput
    } = reactExports.useContext(FormItemInputContext);
    const onChange = (e) => {
      props.onChange?.(e);
      groupContext?.onChange?.(e);
    };
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      children,
      style: style2,
      title,
      classNames,
      styles,
      ...restProps
    } = props;
    const radioPrefixCls = getPrefixCls("radio", customizePrefixCls);
    const isButtonType = (groupContext?.optionType || radioOptionTypeContext) === "button";
    const prefixCls = isButtonType ? `${radioPrefixCls}-button` : radioPrefixCls;
    const rootCls = useCSSVarCls(radioPrefixCls);
    const [hashId, cssVarCls] = useStyle$n(radioPrefixCls, rootCls);
    const radioProps = {
      ...restProps
    };
    const disabled = reactExports.useContext(DisabledContext);
    let mergedChecked = radioProps.checked;
    if (groupContext) {
      radioProps.name = groupContext.name;
      radioProps.onChange = onChange;
      mergedChecked = props.value === groupContext.value;
      radioProps.disabled = radioProps.disabled ?? groupContext.disabled;
    }
    radioProps.disabled = radioProps.disabled ?? disabled;
    const mergedProps = {
      ...props,
      ...radioProps,
      checked: mergedChecked
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const wrapperClassString = clsx(`${prefixCls}-wrapper`, {
      [`${prefixCls}-wrapper-checked`]: mergedChecked,
      [`${prefixCls}-wrapper-disabled`]: radioProps.disabled,
      [`${prefixCls}-wrapper-rtl`]: direction === "rtl",
      [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput,
      [`${prefixCls}-wrapper-block`]: !!groupContext?.block
    }, contextClassName, className, rootClassName, mergedClassNames.root, hashId, cssVarCls, rootCls);
    const [onLabelClick, onInputClick] = useBubbleLock(radioProps.onClick);
    return reactExports.createElement(Wave, {
      component: "Radio",
      disabled: radioProps.disabled
    }, reactExports.createElement("label", {
      className: wrapperClassString,
      style: {
        ...mergedStyles.root,
        ...contextStyle,
        ...style2
      },
      onMouseEnter: props.onMouseEnter,
      onMouseLeave: props.onMouseLeave,
      title,
      onClick: onLabelClick
    }, reactExports.createElement(Checkbox$2, {
      ...radioProps,
      checked: mergedChecked,
      className: clsx(mergedClassNames.icon, {
        [TARGET_CLS]: !isButtonType
      }),
      style: mergedStyles.icon,
      type: "radio",
      prefixCls,
      ref: mergedRef,
      onClick: onInputClick
    }), children !== void 0 ? reactExports.createElement("span", {
      className: clsx(`${prefixCls}-label`, mergedClassNames.label),
      style: mergedStyles.label
    }, children) : null));
  };
  const Radio$1 = reactExports.forwardRef(InternalRadio);
  const RadioGroup = reactExports.forwardRef((props, ref2) => {
    const {
      getPrefixCls,
      direction
    } = reactExports.useContext(ConfigContext);
    const {
      name: formItemName
    } = reactExports.useContext(FormItemInputContext);
    const defaultName = useId(toNamePathStr(formItemName));
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      options,
      buttonStyle = "outline",
      disabled,
      children,
      size: customizeSize,
      style: style2,
      id: id2,
      optionType,
      name = defaultName,
      defaultValue: defaultValue2,
      value: customizedValue,
      block = false,
      onChange,
      onMouseEnter,
      onMouseLeave,
      onFocus,
      onBlur,
      orientation,
      vertical,
      role = "radiogroup"
    } = props;
    const [value, setValue] = useControlledState(defaultValue2, customizedValue);
    const onRadioChange = reactExports.useCallback((event) => {
      const lastValue = value;
      const val = event.target.value;
      if (!("value" in props)) {
        setValue(val);
      }
      if (val !== lastValue) {
        onChange?.(event);
      }
    }, [value, setValue, onChange]);
    const prefixCls = getPrefixCls("radio", customizePrefixCls);
    const groupPrefixCls = `${prefixCls}-group`;
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$n(prefixCls, rootCls);
    let childrenToRender = children;
    if (options && options.length > 0) {
      childrenToRender = options.map((option) => {
        if (typeof option === "string" || typeof option === "number") {
          return reactExports.createElement(Radio$1, {
            key: option.toString(),
            prefixCls,
            disabled,
            value: option,
            checked: value === option
          }, option);
        }
        return reactExports.createElement(Radio$1, {
          key: `radio-group-value-options-${option.value}`,
          prefixCls,
          disabled: option.disabled || disabled,
          value: option.value,
          checked: value === option.value,
          title: option.title,
          style: option.style,
          className: option.className,
          id: option.id,
          required: option.required
        }, option.label);
      });
    }
    const mergedSize = useSize(customizeSize);
    const [, mergedVertical] = useOrientation(orientation, vertical);
    const classString = clsx(groupPrefixCls, `${groupPrefixCls}-${buttonStyle}`, {
      [`${groupPrefixCls}-${mergedSize}`]: mergedSize,
      [`${groupPrefixCls}-rtl`]: direction === "rtl",
      [`${groupPrefixCls}-block`]: block
    }, className, rootClassName, hashId, cssVarCls, rootCls);
    const memoizedValue = reactExports.useMemo(() => ({
      onChange: onRadioChange,
      value,
      disabled,
      name,
      optionType,
      block
    }), [onRadioChange, value, disabled, name, optionType, block]);
    return reactExports.createElement("div", {
      ...pickAttrs(props, {
        aria: true,
        data: true
      }),
      role,
      className: clsx(classString, {
        [`${prefixCls}-group-vertical`]: mergedVertical
      }),
      style: style2,
      onMouseEnter,
      onMouseLeave,
      onFocus,
      onBlur,
      id: id2,
      ref: ref2
    }, reactExports.createElement(RadioGroupContextProvider, {
      value: memoizedValue
    }, childrenToRender));
  });
  const Group$1 = reactExports.memo(RadioGroup);
  const RadioButton = (props, ref2) => {
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const {
      prefixCls: customizePrefixCls,
      ...radioProps
    } = props;
    const prefixCls = getPrefixCls("radio", customizePrefixCls);
    return reactExports.createElement(RadioOptionTypeContextProvider, {
      value: "button"
    }, reactExports.createElement(Radio$1, {
      prefixCls,
      ...radioProps,
      type: "radio",
      ref: ref2
    }));
  };
  const Button = reactExports.forwardRef(RadioButton);
  const Radio = Radio$1;
  Radio.Button = Button;
  Radio.Group = Group$1;
  Radio.__ANT_RADIO = true;
  function initInputToken(token2) {
    return merge$1(token2, {
      inputAffixPadding: token2.paddingXXS
    });
  }
  const initComponentToken = (token2) => {
    const {
      controlHeight,
      fontSize,
      lineHeight,
      lineWidth,
      controlHeightSM,
      controlHeightLG,
      fontSizeLG,
      lineHeightLG,
      paddingSM,
      controlPaddingHorizontalSM,
      controlPaddingHorizontal,
      colorFillAlter,
      colorPrimaryHover,
      colorPrimary,
      controlOutlineWidth,
      controlOutline,
      colorErrorOutline,
      colorWarningOutline,
      colorBgContainer,
      inputFontSize,
      inputFontSizeLG,
      inputFontSizeSM
    } = token2;
    const mergedFontSize = inputFontSize || fontSize;
    const mergedFontSizeSM = inputFontSizeSM || mergedFontSize;
    const mergedFontSizeLG = inputFontSizeLG || fontSizeLG;
    const paddingBlock = Math.round((controlHeight - mergedFontSize * lineHeight) / 2 * 10) / 10 - lineWidth;
    const paddingBlockSM = Math.round((controlHeightSM - mergedFontSizeSM * lineHeight) / 2 * 10) / 10 - lineWidth;
    const paddingBlockLG = Math.ceil((controlHeightLG - mergedFontSizeLG * lineHeightLG) / 2 * 10) / 10 - lineWidth;
    return {
      paddingBlock: Math.max(paddingBlock, 0),
      paddingBlockSM: Math.max(paddingBlockSM, 0),
      paddingBlockLG: Math.max(paddingBlockLG, 0),
      paddingInline: paddingSM - lineWidth,
      paddingInlineSM: controlPaddingHorizontalSM - lineWidth,
      paddingInlineLG: controlPaddingHorizontal - lineWidth,
      addonBg: colorFillAlter,
      activeBorderColor: colorPrimary,
      hoverBorderColor: colorPrimaryHover,
      activeShadow: `0 0 0 ${controlOutlineWidth}px ${controlOutline}`,
      errorActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorErrorOutline}`,
      warningActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorWarningOutline}`,
      hoverBg: colorBgContainer,
      activeBg: colorBgContainer,
      inputFontSize: mergedFontSize,
      inputFontSizeLG: mergedFontSizeLG,
      inputFontSizeSM: mergedFontSizeSM
    };
  };
  const genHoverStyle = (token2) => ({
    borderColor: token2.hoverBorderColor,
    backgroundColor: token2.hoverBg
  });
  const genDisabledStyle = (token2) => ({
    color: token2.colorTextDisabled,
    backgroundColor: token2.colorBgContainerDisabled,
    borderColor: token2.colorBorder,
    boxShadow: "none",
    cursor: "not-allowed",
    opacity: 1,
    "input[disabled], textarea[disabled]": {
      cursor: "not-allowed"
    },
    "&:hover:not([disabled])": {
      ...genHoverStyle(merge$1(token2, {
        hoverBorderColor: token2.colorBorder,
        hoverBg: token2.colorBgContainerDisabled
      }))
    }
  });
  const genBaseOutlinedStyle = (token2, options) => ({
    background: token2.colorBgContainer,
    borderWidth: token2.lineWidth,
    borderStyle: token2.lineType,
    borderColor: options.borderColor,
    "&:hover": {
      borderColor: options.hoverBorderColor,
      backgroundColor: token2.hoverBg
    },
    "&:focus, &:focus-within": {
      borderColor: options.activeBorderColor,
      boxShadow: options.activeShadow,
      outline: 0,
      backgroundColor: token2.activeBg
    }
  });
  const genOutlinedStatusStyle = (token2, options) => ({
    [`&${token2.componentCls}-status-${options.status}:not(${token2.componentCls}-disabled)`]: {
      ...genBaseOutlinedStyle(token2, options),
      [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
        color: options.affixColor
      }
    },
    [`&${token2.componentCls}-status-${options.status}${token2.componentCls}-disabled`]: {
      borderColor: options.borderColor
    }
  });
  const genOutlinedStyle = (token2, extraStyles) => ({
    "&-outlined": {
      ...genBaseOutlinedStyle(token2, {
        borderColor: token2.colorBorder,
        hoverBorderColor: token2.hoverBorderColor,
        activeBorderColor: token2.activeBorderColor,
        activeShadow: token2.activeShadow
      }),
      [`&${token2.componentCls}-disabled, &[disabled]`]: {
        ...genDisabledStyle(token2)
      },
      ...genOutlinedStatusStyle(token2, {
        status: "error",
        borderColor: token2.colorError,
        hoverBorderColor: token2.colorErrorBorderHover,
        activeBorderColor: token2.colorError,
        activeShadow: token2.errorActiveShadow,
        affixColor: token2.colorError
      }),
      ...genOutlinedStatusStyle(token2, {
        status: "warning",
        borderColor: token2.colorWarning,
        hoverBorderColor: token2.colorWarningBorderHover,
        activeBorderColor: token2.colorWarning,
        activeShadow: token2.warningActiveShadow,
        affixColor: token2.colorWarning
      }),
      ...extraStyles
    }
  });
  const genOutlinedGroupStatusStyle = (token2, options) => ({
    [`&${token2.componentCls}-group-wrapper-status-${options.status}`]: {
      [`${token2.componentCls}-group-addon`]: {
        borderColor: options.addonBorderColor,
        color: options.addonColor
      }
    }
  });
  const genOutlinedGroupStyle = (token2) => ({
    "&-outlined": {
      [`${token2.componentCls}-group`]: {
        "&-addon": {
          background: token2.addonBg,
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
        },
        "&-addon:first-child": {
          borderInlineEnd: 0
        },
        "&-addon:last-child": {
          borderInlineStart: 0
        }
      },
      ...genOutlinedGroupStatusStyle(token2, {
        status: "error",
        addonBorderColor: token2.colorError,
        addonColor: token2.colorErrorText
      }),
      ...genOutlinedGroupStatusStyle(token2, {
        status: "warning",
        addonBorderColor: token2.colorWarning,
        addonColor: token2.colorWarningText
      }),
      [`&${token2.componentCls}-group-wrapper-disabled`]: {
        [`${token2.componentCls}-group-addon`]: {
          ...genDisabledStyle(token2)
        }
      }
    }
  });
  const genBorderlessStyle = (token2, extraStyles) => {
    const {
      componentCls
    } = token2;
    return {
      "&-borderless": {
        background: "transparent",
        border: "none",

paddingBlock: token2.calc(token2.paddingBlock).add(token2.lineWidth).equal(),
        [`&${componentCls}-sm, &${componentCls}-affix-wrapper-sm`]: {
          paddingBlock: token2.calc(token2.paddingBlockSM).add(token2.lineWidth).equal()
        },
        [`&${componentCls}-lg, &${componentCls}-affix-wrapper-lg`]: {
          paddingBlock: token2.calc(token2.paddingBlockLG).add(token2.lineWidth).equal()
        },
        "&:focus, &:focus-within": {
          outline: "none"
        },
[`&${componentCls}-disabled, &[disabled]`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        },
[`&${componentCls}-status-error`]: {
          "&, & input, & textarea": {
            color: token2.colorError
          }
        },
        [`&${componentCls}-status-warning`]: {
          "&, & input, & textarea": {
            color: token2.colorWarning
          }
        },
        ...extraStyles
      }
    };
  };
  const genBaseFilledStyle = (token2, options) => ({
    background: options.bg,
    borderWidth: token2.lineWidth,
    borderStyle: token2.lineType,
    borderColor: "transparent",
    "input&, & input, textarea&, & textarea": {
      color: options?.inputColor ?? "unset"
    },
    "&:hover": {
      background: options.hoverBg
    },
    "&:focus, &:focus-within": {
      outline: 0,
      borderColor: options.activeBorderColor,
      backgroundColor: token2.activeBg
    }
  });
  const genFilledStatusStyle = (token2, options) => ({
    [`&${token2.componentCls}-status-${options.status}:not(${token2.componentCls}-disabled)`]: {
      ...genBaseFilledStyle(token2, options),
      [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
        color: options.affixColor
      }
    }
  });
  const genFilledStyle = (token2, extraStyles) => ({
    "&-filled": {
      ...genBaseFilledStyle(token2, {
        bg: token2.colorFillTertiary,
        hoverBg: token2.colorFillSecondary,
        activeBorderColor: token2.activeBorderColor,
        inputColor: token2.colorText
      }),
      [`&${token2.componentCls}-disabled, &[disabled]`]: {
        ...genDisabledStyle(token2)
      },
      ...genFilledStatusStyle(token2, {
        status: "error",
        bg: token2.colorErrorBg,
        hoverBg: token2.colorErrorBgHover,
        activeBorderColor: token2.colorError,
        inputColor: token2.colorErrorText,
        affixColor: token2.colorError
      }),
      ...genFilledStatusStyle(token2, {
        status: "warning",
        bg: token2.colorWarningBg,
        hoverBg: token2.colorWarningBgHover,
        activeBorderColor: token2.colorWarning,
        inputColor: token2.colorWarningText,
        affixColor: token2.colorWarning
      }),
      ...extraStyles
    }
  });
  const genFilledGroupStatusStyle = (token2, options) => ({
    [`&${token2.componentCls}-group-wrapper-status-${options.status}`]: {
      [`${token2.componentCls}-group-addon`]: {
        background: options.addonBg,
        color: options.addonColor
      }
    }
  });
  const genFilledGroupStyle = (token2) => ({
    "&-filled": {
      [`${token2.componentCls}-group-addon`]: {
        background: token2.colorFillTertiary,
        "&:last-child": {
          position: "static"
        }
      },
      ...genFilledGroupStatusStyle(token2, {
        status: "error",
        addonBg: token2.colorErrorBg,
        addonColor: token2.colorErrorText
      }),
      ...genFilledGroupStatusStyle(token2, {
        status: "warning",
        addonBg: token2.colorWarningBg,
        addonColor: token2.colorWarningText
      }),
      [`&${token2.componentCls}-group-wrapper-disabled`]: {
        [`${token2.componentCls}-group`]: {
          "&-addon": {
            background: token2.colorFillTertiary,
            color: token2.colorTextDisabled
          },
          "&-addon:first-child": {
            borderInlineStart: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
            borderTop: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
            borderBottom: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
          },
          "&-addon:last-child": {
            borderInlineEnd: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
            borderTop: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
            borderBottom: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
          }
        }
      }
    }
  });
  const genBaseUnderlinedStyle = (token2, options) => ({
    background: token2.colorBgContainer,
    borderWidth: `${unit$1(token2.lineWidth)} 0`,
    borderStyle: `${token2.lineType} none`,
    borderColor: `transparent transparent ${options.borderColor} transparent`,
    borderRadius: 0,
    "&:hover": {
      borderColor: `transparent transparent ${options.hoverBorderColor} transparent`,
      backgroundColor: token2.hoverBg
    },
    "&:focus, &:focus-within": {
      borderColor: `transparent transparent ${options.activeBorderColor} transparent`,
      outline: 0,
      backgroundColor: token2.activeBg
    }
  });
  const genUnderlinedStatusStyle = (token2, options) => ({
    [`&${token2.componentCls}-status-${options.status}:not(${token2.componentCls}-disabled)`]: {
      ...genBaseUnderlinedStyle(token2, options),
      [`${token2.componentCls}-prefix, ${token2.componentCls}-suffix`]: {
        color: options.affixColor
      }
    },
    [`&${token2.componentCls}-status-${options.status}${token2.componentCls}-disabled`]: {
      borderColor: `transparent transparent ${options.borderColor} transparent`
    }
  });
  const genUnderlinedStyle = (token2, extraStyles) => ({
    "&-underlined": {
      ...genBaseUnderlinedStyle(token2, {
        borderColor: token2.colorBorder,
        hoverBorderColor: token2.hoverBorderColor,
        activeBorderColor: token2.activeBorderColor,
        activeShadow: token2.activeShadow
      }),
[`&${token2.componentCls}-disabled, &[disabled]`]: {
        color: token2.colorTextDisabled,
        boxShadow: "none",
        cursor: "not-allowed",
        "&:hover": {
          borderColor: `transparent transparent ${token2.colorBorder} transparent`
        }
      },
      "input[disabled], textarea[disabled]": {
        cursor: "not-allowed"
      },
      ...genUnderlinedStatusStyle(token2, {
        status: "error",
        borderColor: token2.colorError,
        hoverBorderColor: token2.colorErrorBorderHover,
        activeBorderColor: token2.colorError,
        activeShadow: token2.errorActiveShadow,
        affixColor: token2.colorError
      }),
      ...genUnderlinedStatusStyle(token2, {
        status: "warning",
        borderColor: token2.colorWarning,
        hoverBorderColor: token2.colorWarningBorderHover,
        activeBorderColor: token2.colorWarning,
        activeShadow: token2.warningActiveShadow,
        affixColor: token2.colorWarning
      }),
      ...extraStyles
    }
  });
  const genPlaceholderStyle = (color2) => ({
"&::-moz-placeholder": {
      opacity: 1
    },
    "&::placeholder": {
      color: color2,
      userSelect: "none"
},
    "&:placeholder-shown": {
      textOverflow: "ellipsis"
    }
  });
  const genInputLargeStyle = (token2) => {
    const {
      paddingBlockLG,
      lineHeightLG,
      borderRadiusLG,
      paddingInlineLG
    } = token2;
    return {
      padding: `${unit$1(paddingBlockLG)} ${unit$1(paddingInlineLG)}`,
      fontSize: token2.inputFontSizeLG,
      lineHeight: lineHeightLG,
      borderRadius: borderRadiusLG
    };
  };
  const genInputSmallStyle = (token2) => ({
    padding: `${unit$1(token2.paddingBlockSM)} ${unit$1(token2.paddingInlineSM)}`,
    fontSize: token2.inputFontSizeSM,
    borderRadius: token2.borderRadiusSM
  });
  const genBasicInputStyle = (token2, option = {}) => ({
    position: "relative",
    display: "inline-block",
    width: "100%",
    minWidth: 0,
    padding: `${unit$1(token2.paddingBlock)} ${unit$1(token2.paddingInline)}`,
    color: token2.colorText,
    fontSize: token2.inputFontSize,
    lineHeight: token2.lineHeight,
    borderRadius: token2.borderRadius,
    transition: `all ${token2.motionDurationMid}`,
    ...genPlaceholderStyle(token2.colorTextPlaceholder),
"&-lg": {
      ...genInputLargeStyle(token2),
      ...option.largeStyle
    },
    "&-sm": {
      ...genInputSmallStyle(token2),
      ...option.smallStyle
    },
"&-rtl, &-textarea-rtl": {
      direction: "rtl"
    }
  });
  const genInputGroupStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    return {
      position: "relative",
      display: "table",
      width: "100%",
      borderCollapse: "separate",
      borderSpacing: 0,
"&[class*='col-']": {
        paddingInlineEnd: token2.paddingXS,
        "&:last-child": {
          paddingInlineEnd: 0
        }
      },
[`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: {
        ...genInputLargeStyle(token2)
      },
      [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: {
        ...genInputSmallStyle(token2)
      },
[`&-lg ${antCls}-select-single`]: {
        height: token2.controlHeightLG
      },
      [`&-sm ${antCls}-select-single`]: {
        height: token2.controlHeightSM
      },
      [`> ${componentCls}`]: {
        display: "table-cell",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      [`${componentCls}-group`]: {
        "&-addon, &-wrap": {
          display: "table-cell",
          width: 1,
          whiteSpace: "nowrap",
          verticalAlign: "middle",
          "&:not(:first-child):not(:last-child)": {
            borderRadius: 0
          }
        },
        "&-wrap > *": {
          display: "block !important"
        },
        "&-addon": {
          position: "relative",
          padding: `0 ${unit$1(token2.paddingInline)}`,
          color: token2.colorText,
          fontWeight: "normal",
          fontSize: token2.inputFontSize,
          textAlign: "center",
          borderRadius: token2.borderRadius,
          transition: `all ${token2.motionDurationSlow}`,
          lineHeight: 1,
[`${antCls}-select`]: {
            margin: `${unit$1(token2.calc(token2.paddingBlock).add(1).mul(-1).equal())} ${unit$1(token2.calc(token2.paddingInline).mul(-1).equal())}`,
            [`&${antCls}-select-single:not(${antCls}-select-customize-input):not(${antCls}-pagination-size-changer)`]: {
              backgroundColor: "inherit",
              border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`,
              boxShadow: "none"
            }
          },
[`${antCls}-cascader-picker`]: {
            margin: `-9px ${unit$1(token2.calc(token2.paddingInline).mul(-1).equal())}`,
            backgroundColor: "transparent",
            [`${antCls}-cascader-input`]: {
              textAlign: "start",
              border: 0,
              boxShadow: "none"
            }
          }
        }
      },
      [componentCls]: {
        width: "100%",
        marginBottom: 0,
        textAlign: "inherit",
        "&:focus": {
          zIndex: 1,
borderInlineEndWidth: 1
        },
        "&:hover": {
          zIndex: 1,
          borderInlineEndWidth: 1
        }
      },
[`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
[`${antCls}-select`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        }
      },
      [`> ${componentCls}-affix-wrapper`]: {
        [`&:not(:first-child) ${componentCls}`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        },
        [`&:not(:last-child) ${componentCls}`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        }
      },
      [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0,
[`${antCls}-select`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        }
      },
      [`${componentCls}-affix-wrapper`]: {
        "&:not(:last-child)": {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        },
        "&:not(:first-child)": {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        }
      },
      [`&${componentCls}-group-compact`]: {
        display: "block",
        ...clearFix(),
        [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
          "&:not(:first-child):not(:last-child)": {
            borderInlineEndWidth: token2.lineWidth,
            "&:hover, &:focus": {
              zIndex: 1
            }
          }
        },
        "& > *": {
          display: "inline-flex",
          float: "none",
          verticalAlign: "top",
borderRadius: 0
        },
        [`
        & > ${componentCls}-affix-wrapper,
        & > ${componentCls}-number-affix-wrapper,
        & > ${antCls}-picker-range
      `]: {
          display: "inline-flex"
        },
        "& > *:not(:last-child)": {
          marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal(),
          borderInlineEndWidth: token2.lineWidth
        },
[componentCls]: {
          float: "none"
        },
[`& > ${antCls}-select,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
          borderInlineEndWidth: token2.lineWidth,
          borderRadius: 0,
          "&:hover, &:focus": {
            zIndex: 1
          }
        },
        [`& > ${antCls}-select-focused`]: {
          zIndex: 1
        },
[`& > ${antCls}-select > ${antCls}-select-arrow`]: {
          zIndex: 1
},
        [`& > *:first-child,
      & > ${antCls}-select:first-child,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
          borderStartStartRadius: token2.borderRadius,
          borderEndStartRadius: token2.borderRadius
        },
        [`& > *:last-child,
      & > ${antCls}-select:last-child,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
          borderInlineEndWidth: token2.lineWidth,
          borderStartEndRadius: token2.borderRadius,
          borderEndEndRadius: token2.borderRadius
        },
[`& > ${antCls}-select-auto-complete ${componentCls}`]: {
          verticalAlign: "top"
        },
        [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
          marginInlineStart: token2.calc(token2.lineWidth).mul(-1).equal(),
          [`${componentCls}-affix-wrapper`]: {
}
        }
      }
    };
  };
  const genInputStyle$1 = (token2) => {
    const {
      componentCls,
      controlHeightSM,
      lineWidth,
      calc
    } = token2;
    const FIXED_CHROME_COLOR_HEIGHT = 16;
    const colorSmallPadding = calc(controlHeightSM).sub(calc(lineWidth).mul(2)).sub(FIXED_CHROME_COLOR_HEIGHT).div(2).equal();
    return {
      [componentCls]: {
        ...resetComponent(token2),
        ...genBasicInputStyle(token2),
...genOutlinedStyle(token2),
        ...genFilledStyle(token2),
        ...genBorderlessStyle(token2),
        ...genUnderlinedStyle(token2),
        '&[type="color"]': {
          height: token2.controlHeight,
          [`&${componentCls}-lg`]: {
            height: token2.controlHeightLG
          },
          [`&${componentCls}-sm`]: {
            height: controlHeightSM,
            paddingTop: colorSmallPadding,
            paddingBottom: colorSmallPadding
          }
        },
        '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
          appearance: "none"
        }
      }
    };
  };
  const genAllowClearStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
[`${componentCls}-clear-icon`]: {
        margin: 0,
        padding: 0,
        lineHeight: 0,
        color: token2.colorTextQuaternary,
        fontSize: token2.fontSizeIcon,
        verticalAlign: -1,

cursor: "pointer",
        transition: `color ${token2.motionDurationSlow}`,
        border: "none",
        outline: "none",
        backgroundColor: "transparent",
        "&:hover": {
          color: token2.colorIcon
        },
        "&:active": {
          color: token2.colorText
        },
        "&-hidden": {
          visibility: "hidden"
        },
        "&-has-suffix": {
          margin: `0 ${unit$1(token2.inputAffixPadding)}`
        }
      }
    };
  };
  const genAffixStyle = (token2) => {
    const {
      componentCls,
      inputAffixPadding,
      colorTextDescription,
      motionDurationSlow,
      colorIcon,
      colorIconHover,
      iconCls
    } = token2;
    const affixCls = `${componentCls}-affix-wrapper`;
    const affixClsDisabled = `${componentCls}-affix-wrapper-disabled`;
    return {
      [affixCls]: {
        ...genBasicInputStyle(token2),
        display: "inline-flex",
        "&-focused, &:focus": {
          zIndex: 1
        },
        [`> input${componentCls}`]: {
          padding: 0
        },
        [`> input${componentCls}, > textarea${componentCls}`]: {
          fontSize: "inherit",
          border: "none",
          borderRadius: 0,
          outline: "none",
          background: "transparent",
          color: "inherit",
          "&::-ms-reveal": {
            display: "none"
          },
          "&:focus": {
            boxShadow: "none !important"
          }
        },
        "&::before": {
          display: "inline-block",
          width: 0,
          visibility: "hidden",
          content: '"\\a0"'
        },
        [componentCls]: {
          "&-prefix, &-suffix": {
            display: "flex",
            flex: "none",
            alignItems: "center",
            "> *:not(:last-child)": {
              marginInlineEnd: token2.paddingXS
            }
          },
          "&-show-count-suffix": {
            color: colorTextDescription,
            direction: "ltr"
          },
          "&-show-count-has-suffix": {
            marginInlineEnd: token2.paddingXXS
          },
          "&-prefix": {
            marginInlineEnd: inputAffixPadding
          },
          "&-suffix": {
            marginInlineStart: inputAffixPadding
          }
        },
        ...genAllowClearStyle(token2),
[`${iconCls}${componentCls}-password-icon`]: {
          color: colorIcon,
          cursor: "pointer",
          transition: `all ${motionDurationSlow}`,
          "&:hover": {
            color: colorIconHover
          }
        }
      },
[`${componentCls}-underlined`]: {
        borderRadius: 0
      },
      [affixClsDisabled]: {
[`${iconCls}${componentCls}-password-icon`]: {
          color: colorIcon,
          cursor: "not-allowed",
          "&:hover": {
            color: colorIcon
          }
        }
      }
    };
  };
  const genGroupStyle$1 = (token2) => {
    const {
      componentCls,
      borderRadiusLG,
      borderRadiusSM
    } = token2;
    return {
      [`${componentCls}-group`]: {
...resetComponent(token2),
        ...genInputGroupStyle(token2),
        "&-rtl": {
          direction: "rtl"
        },
        "&-wrapper": {
          display: "inline-block",
          width: "100%",
          textAlign: "start",
          verticalAlign: "top",
"&-rtl": {
            direction: "rtl"
          },
"&-lg": {
            [`${componentCls}-group-addon`]: {
              borderRadius: borderRadiusLG,
              fontSize: token2.inputFontSizeLG
            }
          },
          "&-sm": {
            [`${componentCls}-group-addon`]: {
              borderRadius: borderRadiusSM
            }
          },
...genOutlinedGroupStyle(token2),
          ...genFilledGroupStyle(token2),






[`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
            [`${componentCls}, ${componentCls}-group-addon`]: {
              borderRadius: 0
            }
          },
          [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: {
            [`${componentCls}, ${componentCls}-group-addon`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: {
            [`${componentCls}, ${componentCls}-group-addon`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          },

[`&:not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
            [`${componentCls}-affix-wrapper`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },

[`&:not(${componentCls}-compact-first-item)${componentCls}-compact-item`]: {
            [`${componentCls}-affix-wrapper`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        }
      }
    };
  };
  const genRangeStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-out-of-range`]: {
        [`&, & input, & textarea, ${componentCls}-show-count-suffix, ${componentCls}-data-count`]: {
          color: token2.colorError
        }
      }
    };
  };
  const useSharedStyle = genStyleHooks(["Input", "Shared"], (token2) => {
    const inputToken = merge$1(token2, initInputToken(token2));
    return [genInputStyle$1(inputToken), genAffixStyle(inputToken)];
  }, initComponentToken, {
    resetFont: false
  });
  const useStyle$m = genStyleHooks(["Input", "Component"], (token2) => {
    const inputToken = merge$1(token2, initInputToken(token2));
    return [
      genGroupStyle$1(inputToken),
      genRangeStyle(inputToken),


genCompactItemStyle(inputToken, {
        focus: true,
        focusElCls: `${inputToken.componentCls}-affix-wrapper-focused`
      })
    ];
  }, initComponentToken, {
    resetFont: false
  });
  var PlusOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { "tag": "path", "attrs": { "d": "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z" } }] }, "name": "plus", "theme": "outlined" };
  function _extends$m() {
    _extends$m = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$m.apply(this, arguments);
  }
  const PlusOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends$m({}, props, {
    ref: ref2,
    icon: PlusOutlined$1
  }));
  const RefIcon$9 = reactExports.forwardRef(PlusOutlined);
  var isMobile$2 = { exports: {} };
  var hasRequiredIsMobile;
  function requireIsMobile() {
    if (hasRequiredIsMobile) return isMobile$2.exports;
    hasRequiredIsMobile = 1;
    isMobile$2.exports = isMobile2;
    isMobile$2.exports.isMobile = isMobile2;
    isMobile$2.exports.default = isMobile2;
    const mobileRE = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|redmi|series[46]0|samsungbrowser.*mobile|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;
    const notMobileRE = /CrOS/;
    const tabletRE = /android|ipad|playbook|silk/i;
    function isMobile2(opts) {
      if (!opts) opts = {};
      let ua = opts.ua;
      if (!ua && typeof navigator !== "undefined") ua = navigator.userAgent;
      if (ua && ua.headers && typeof ua.headers["user-agent"] === "string") {
        ua = ua.headers["user-agent"];
      }
      if (typeof ua !== "string") return false;
      let result = mobileRE.test(ua) && !notMobileRE.test(ua) || !!opts.tablet && tabletRE.test(ua);
      if (!result && opts.tablet && opts.featureDetect && navigator && navigator.maxTouchPoints > 1 && ua.indexOf("Macintosh") !== -1 && ua.indexOf("Safari") !== -1) {
        result = true;
      }
      return result;
    }
    return isMobile$2.exports;
  }
  var isMobileExports = requireIsMobile();
  const isMobile$1 = getDefaultExportFromCjs(isMobileExports);
  let cached;
  const isMobile = (() => {
    if (typeof cached === "undefined") {
      cached = isMobile$1();
    }
    return cached;
  });
  const TabContext = reactExports.createContext(null);
  const useIndicator = (options) => {
    const {
      activeTabOffset,
      horizontal,
      rtl,
      indicator = {}
    } = options;
    const {
      size,
      align = "center"
    } = indicator;
    const [inkStyle, setInkStyle] = reactExports.useState();
    const inkBarRafRef = reactExports.useRef();
    const getLength = React.useCallback((origin) => {
      if (typeof size === "function") {
        return size(origin);
      }
      if (typeof size === "number") {
        return size;
      }
      return origin;
    }, [size]);
    function cleanInkBarRaf() {
      wrapperRaf.cancel(inkBarRafRef.current);
    }
    reactExports.useEffect(() => {
      const newInkStyle = {};
      if (activeTabOffset) {
        if (horizontal) {
          newInkStyle.width = getLength(activeTabOffset.width);
          const key = rtl ? "right" : "left";
          if (align === "start") {
            newInkStyle[key] = activeTabOffset[key];
          }
          if (align === "center") {
            newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width / 2;
            newInkStyle.transform = rtl ? "translateX(50%)" : "translateX(-50%)";
          }
          if (align === "end") {
            newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width;
            newInkStyle.transform = "translateX(-100%)";
          }
        } else {
          newInkStyle.height = getLength(activeTabOffset.height);
          if (align === "start") {
            newInkStyle.top = activeTabOffset.top;
          }
          if (align === "center") {
            newInkStyle.top = activeTabOffset.top + activeTabOffset.height / 2;
            newInkStyle.transform = "translateY(-50%)";
          }
          if (align === "end") {
            newInkStyle.top = activeTabOffset.top + activeTabOffset.height;
            newInkStyle.transform = "translateY(-100%)";
          }
        }
      }
      cleanInkBarRaf();
      inkBarRafRef.current = wrapperRaf(() => {
        const isEqual2 = inkStyle && newInkStyle && Object.keys(newInkStyle).every((key) => {
          const newValue = newInkStyle[key];
          const oldValue = inkStyle[key];
          return typeof newValue === "number" && typeof oldValue === "number" ? Math.round(newValue) === Math.round(oldValue) : newValue === oldValue;
        });
        if (!isEqual2) {
          setInkStyle(newInkStyle);
        }
      });
      return cleanInkBarRaf;
    }, [JSON.stringify(activeTabOffset), horizontal, rtl, align, getLength]);
    return {
      style: inkStyle
    };
  };
  const DEFAULT_SIZE$2 = {
    width: 0,
    height: 0,
    left: 0,
    top: 0
  };
  function useOffsets(tabs, tabSizes, holderScrollWidth) {
    return reactExports.useMemo(() => {
      const map = new Map();
      const lastOffset = tabSizes.get(tabs[0]?.key) || DEFAULT_SIZE$2;
      const rightOffset = lastOffset.left + lastOffset.width;
      for (let i2 = 0; i2 < tabs.length; i2 += 1) {
        const {
          key
        } = tabs[i2];
        let data2 = tabSizes.get(key);
        if (!data2) {
          data2 = tabSizes.get(tabs[i2 - 1]?.key) || DEFAULT_SIZE$2;
        }
        const entity = map.get(key) || {
          ...data2
        };
        entity.right = rightOffset - entity.left - entity.width;
        map.set(key, entity);
      }
      return map;
    }, [tabs.map((tab2) => tab2.key).join("_"), tabSizes, holderScrollWidth]);
  }
  function useSyncState(defaultState, onChange) {
    const stateRef = reactExports.useRef(defaultState);
    const [, forceUpdate] = reactExports.useState({});
    function setState(updater) {
      const newValue = typeof updater === "function" ? updater(stateRef.current) : updater;
      if (newValue !== stateRef.current) {
        onChange(newValue, stateRef.current);
      }
      stateRef.current = newValue;
      forceUpdate({});
    }
    return [stateRef.current, setState];
  }
  const MIN_SWIPE_DISTANCE = 0.1;
  const STOP_SWIPE_DISTANCE = 0.01;
  const REFRESH_INTERVAL = 20;
  const SPEED_OFF_MULTIPLE = 0.995 ** REFRESH_INTERVAL;
  function useTouchMove(ref2, onOffset) {
    const [touchPosition, setTouchPosition] = reactExports.useState();
    const [lastTimestamp, setLastTimestamp] = reactExports.useState(0);
    const [lastTimeDiff, setLastTimeDiff] = reactExports.useState(0);
    const [lastOffset, setLastOffset] = reactExports.useState();
    const motionRef = reactExports.useRef();
    function onTouchStart(e) {
      const {
        screenX,
        screenY
      } = e.touches[0];
      setTouchPosition({
        x: screenX,
        y: screenY
      });
      window.clearInterval(motionRef.current);
    }
    function onTouchMove(e) {
      if (!touchPosition) return;
      const {
        screenX,
        screenY
      } = e.touches[0];
      setTouchPosition({
        x: screenX,
        y: screenY
      });
      const offsetX = screenX - touchPosition.x;
      const offsetY = screenY - touchPosition.y;
      onOffset(offsetX, offsetY);
      const now2 = Date.now();
      setLastTimestamp(now2);
      setLastTimeDiff(now2 - lastTimestamp);
      setLastOffset({
        x: offsetX,
        y: offsetY
      });
    }
    function onTouchEnd() {
      if (!touchPosition) return;
      setTouchPosition(null);
      setLastOffset(null);
      if (lastOffset) {
        const distanceX = lastOffset.x / lastTimeDiff;
        const distanceY = lastOffset.y / lastTimeDiff;
        const absX = Math.abs(distanceX);
        const absY = Math.abs(distanceY);
        if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE) return;
        let currentX = distanceX;
        let currentY = distanceY;
        motionRef.current = window.setInterval(() => {
          if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
            window.clearInterval(motionRef.current);
            return;
          }
          currentX *= SPEED_OFF_MULTIPLE;
          currentY *= SPEED_OFF_MULTIPLE;
          onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL);
        }, REFRESH_INTERVAL);
      }
    }
    const lastWheelDirectionRef = reactExports.useRef();
    function onWheel(e) {
      const {
        deltaX,
        deltaY
      } = e;
      let mixed = 0;
      const absX = Math.abs(deltaX);
      const absY = Math.abs(deltaY);
      if (absX === absY) {
        mixed = lastWheelDirectionRef.current === "x" ? deltaX : deltaY;
      } else if (absX > absY) {
        mixed = deltaX;
        lastWheelDirectionRef.current = "x";
      } else {
        mixed = deltaY;
        lastWheelDirectionRef.current = "y";
      }
      if (onOffset(-mixed, -mixed)) {
        e.preventDefault();
      }
    }
    const touchEventsRef = reactExports.useRef(null);
    touchEventsRef.current = {
      onTouchStart,
      onTouchMove,
      onTouchEnd,
      onWheel
    };
    reactExports.useEffect(() => {
      function onProxyTouchStart(e) {
        touchEventsRef.current.onTouchStart(e);
      }
      function onProxyTouchMove(e) {
        touchEventsRef.current.onTouchMove(e);
      }
      function onProxyTouchEnd(e) {
        touchEventsRef.current.onTouchEnd(e);
      }
      function onProxyWheel(e) {
        touchEventsRef.current.onWheel(e);
      }
      document.addEventListener("touchmove", onProxyTouchMove, {
        passive: false
      });
      document.addEventListener("touchend", onProxyTouchEnd, {
        passive: true
      });
      ref2.current.addEventListener("touchstart", onProxyTouchStart, {
        passive: true
      });
      ref2.current.addEventListener("wheel", onProxyWheel, {
        passive: false
      });
      return () => {
        document.removeEventListener("touchmove", onProxyTouchMove);
        document.removeEventListener("touchend", onProxyTouchEnd);
      };
    }, []);
  }
  function useUpdate$1(callback) {
    const [count, setCount] = reactExports.useState(0);
    const effectRef = reactExports.useRef(0);
    const callbackRef = reactExports.useRef();
    callbackRef.current = callback;
    useLayoutUpdateEffect(() => {
      callbackRef.current?.();
    }, [count]);
    return () => {
      if (effectRef.current !== count) {
        return;
      }
      effectRef.current += 1;
      setCount(effectRef.current);
    };
  }
  function useUpdateState(defaultState) {
    const batchRef = reactExports.useRef([]);
    const [, forceUpdate] = reactExports.useState({});
    const state2 = reactExports.useRef(typeof defaultState === "function" ? defaultState() : defaultState);
    const flushUpdate = useUpdate$1(() => {
      let current = state2.current;
      batchRef.current.forEach((callback) => {
        current = callback(current);
      });
      batchRef.current = [];
      state2.current = current;
      forceUpdate({});
    });
    function updater(callback) {
      batchRef.current.push(callback);
      flushUpdate();
    }
    return [state2.current, updater];
  }
  const DEFAULT_SIZE$1 = {
    width: 0,
    height: 0,
    left: 0,
    top: 0,
    right: 0
  };
  function useVisibleRange(tabOffsets, visibleTabContentValue, transform, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, {
    tabs,
    tabPosition,
    rtl
  }) {
    let charUnit;
    let position2;
    let transformSize;
    if (["top", "bottom"].includes(tabPosition)) {
      charUnit = "width";
      position2 = rtl ? "right" : "left";
      transformSize = Math.abs(transform);
    } else {
      charUnit = "height";
      position2 = "top";
      transformSize = -transform;
    }
    return reactExports.useMemo(() => {
      if (!tabs.length) {
        return [0, 0];
      }
      const len = tabs.length;
      let endIndex = len;
      for (let i2 = 0; i2 < len; i2 += 1) {
        const offset2 = tabOffsets.get(tabs[i2].key) || DEFAULT_SIZE$1;
        if (Math.floor(offset2[position2] + offset2[charUnit]) > Math.floor(transformSize + visibleTabContentValue)) {
          endIndex = i2 - 1;
          break;
        }
      }
      let startIndex = 0;
      for (let i2 = len - 1; i2 >= 0; i2 -= 1) {
        const offset2 = tabOffsets.get(tabs[i2].key) || DEFAULT_SIZE$1;
        if (offset2[position2] < transformSize) {
          startIndex = i2 + 1;
          break;
        }
      }
      return startIndex > endIndex ? [0, -1] : [startIndex, endIndex];
    }, [tabOffsets, visibleTabContentValue, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, transformSize, tabPosition, tabs.map((tab2) => tab2.key).join("_"), rtl]);
  }
  function stringify(obj) {
    let tgt;
    if (obj instanceof Map) {
      tgt = {};
      obj.forEach((v, k) => {
        tgt[k] = v;
      });
    } else {
      tgt = obj;
    }
    return JSON.stringify(tgt);
  }
  const RC_TABS_DOUBLE_QUOTE = "TABS_DQ";
  function genDataNodeKey(key) {
    return String(key).replace(/"/g, RC_TABS_DOUBLE_QUOTE);
  }
  function getRemovable(closable, closeIcon, editable, disabled) {
    if (
!editable ||
disabled ||
closable === false ||
closable === void 0 && (closeIcon === false || closeIcon === null)
    ) {
      return false;
    }
    return true;
  }
  const AddButton = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls,
      editable,
      locale: locale2,
      style: style2
    } = props;
    if (!editable || editable.showAdd === false) {
      return null;
    }
    return reactExports.createElement("button", {
      ref: ref2,
      type: "button",
      className: `${prefixCls}-nav-add`,
      style: style2,
      "aria-label": locale2?.addAriaLabel || "Add tab",
      onClick: (event) => {
        editable.onEdit("add", {
          event
        });
      }
    }, editable.addIcon || "+");
  });
  const ExtraContent = reactExports.forwardRef((props, ref2) => {
    const {
      position: position2,
      prefixCls,
      extra
    } = props;
    if (!extra) {
      return null;
    }
    let content;
    let assertExtra = {};
    if (typeof extra === "object" && ! reactExports.isValidElement(extra)) {
      assertExtra = extra;
    } else {
      assertExtra.right = extra;
    }
    if (position2 === "right") {
      content = assertExtra.right;
    }
    if (position2 === "left") {
      content = assertExtra.left;
    }
    return content ? reactExports.createElement("div", {
      className: `${prefixCls}-extra-content`,
      ref: ref2
    }, content) : null;
  });
  function _extends$l() {
    _extends$l = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$l.apply(this, arguments);
  }
  const OperationNode = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls,
      id: id2,
      tabs,
      locale: locale2,
      mobile,
      more: moreProps = {},
      style: style2,
      className,
      editable,
      tabBarGutter,
      rtl,
      removeAriaLabel,
      onTabClick,
      getPopupContainer,
      popupClassName,
      popupStyle
    } = props;
    const [open2, setOpen] = reactExports.useState(false);
    const [selectedKey, setSelectedKey] = reactExports.useState(null);
    const {
      icon: moreIcon = "More"
    } = moreProps;
    const popupId = `${id2}-more-popup`;
    const dropdownPrefix = `${prefixCls}-dropdown`;
    const selectedItemId = selectedKey !== null ? `${popupId}-${selectedKey}` : null;
    const dropdownAriaLabel = locale2?.dropdownAriaLabel;
    function onRemoveTab(event, key) {
      event.preventDefault();
      event.stopPropagation();
      editable.onEdit("remove", {
        key,
        event
      });
    }
    const menu = reactExports.createElement(ExportMenu, {
      onClick: ({
        key,
        domEvent
      }) => {
        onTabClick(key, domEvent);
        setOpen(false);
      },
      prefixCls: `${dropdownPrefix}-menu`,
      id: popupId,
      tabIndex: -1,
      role: "listbox",
      "aria-activedescendant": selectedItemId,
      selectedKeys: [selectedKey],
      "aria-label": dropdownAriaLabel !== void 0 ? dropdownAriaLabel : "expanded dropdown"
    }, tabs.map((tab2) => {
      const {
        closable,
        disabled,
        closeIcon,
        key,
        label
      } = tab2;
      const removable = getRemovable(closable, closeIcon, editable, disabled);
      return reactExports.createElement(MenuItem$2, {
        key,
        id: `${popupId}-${key}`,
        role: "option",
        "aria-controls": id2 && `${id2}-panel-${key}`,
        disabled
      }, reactExports.createElement("span", null, label), removable && reactExports.createElement("button", {
        type: "button",
        "aria-label": removeAriaLabel || "remove",
        tabIndex: 0,
        className: `${dropdownPrefix}-menu-item-remove`,
        onClick: (e) => {
          e.stopPropagation();
          onRemoveTab(e, key);
        }
      }, closeIcon || editable.removeIcon || "×"));
    }));
    function selectOffset(offset2) {
      const enabledTabs = tabs.filter((tab2) => !tab2.disabled);
      let selectedIndex = enabledTabs.findIndex((tab2) => tab2.key === selectedKey) || 0;
      const len = enabledTabs.length;
      for (let i2 = 0; i2 < len; i2 += 1) {
        selectedIndex = (selectedIndex + offset2 + len) % len;
        const tab2 = enabledTabs[selectedIndex];
        if (!tab2.disabled) {
          setSelectedKey(tab2.key);
          return;
        }
      }
    }
    function onKeyDown(e) {
      const {
        which
      } = e;
      if (!open2) {
        if ([KeyCode.DOWN, KeyCode.SPACE, KeyCode.ENTER].includes(which)) {
          setOpen(true);
          e.preventDefault();
        }
        return;
      }
      switch (which) {
        case KeyCode.UP:
          selectOffset(-1);
          e.preventDefault();
          break;
        case KeyCode.DOWN:
          selectOffset(1);
          e.preventDefault();
          break;
        case KeyCode.ESC:
          setOpen(false);
          break;
        case KeyCode.SPACE:
        case KeyCode.ENTER:
          if (selectedKey !== null) {
            onTabClick(selectedKey, e);
          }
          break;
      }
    }
    reactExports.useEffect(() => {
      const ele = document.getElementById(selectedItemId);
      if (ele?.scrollIntoView) {
        ele.scrollIntoView(false);
      }
    }, [selectedItemId, selectedKey]);
    reactExports.useEffect(() => {
      if (!open2) {
        setSelectedKey(null);
      }
    }, [open2]);
    const moreStyle = {
      marginInlineStart: tabBarGutter
    };
    if (!tabs.length) {
      moreStyle.visibility = "hidden";
      moreStyle.order = 1;
    }
    const overlayClassName = clsx(popupClassName, {
      [`${dropdownPrefix}-rtl`]: rtl
    });
    const moreNode = mobile ? null : reactExports.createElement(Dropdown$2, _extends$l({
      prefixCls: dropdownPrefix,
      overlay: menu,
      visible: tabs.length ? open2 : false,
      onVisibleChange: setOpen,
      overlayClassName,
      overlayStyle: popupStyle,
      mouseEnterDelay: 0.1,
      mouseLeaveDelay: 0.1,
      getPopupContainer
    }, moreProps), reactExports.createElement("button", {
      type: "button",
      className: `${prefixCls}-nav-more`,
      style: moreStyle,
      "aria-haspopup": "listbox",
      "aria-controls": popupId,
      id: `${id2}-more`,
      "aria-expanded": open2,
      onKeyDown
    }, moreIcon));
    return reactExports.createElement("div", {
      className: clsx(`${prefixCls}-nav-operations`, className),
      style: style2,
      ref: ref2
    }, moreNode, reactExports.createElement(AddButton, {
      prefixCls,
      locale: locale2,
      editable
    }));
  });
  const OperationNode$1 = reactExports.memo(OperationNode, (_2, next2) => (

next2.tabMoving
  ));
  const TabNode = (props) => {
    const {
      prefixCls,
      id: id2,
      active,
      focus,
      tab: {
        key,
        label,
        disabled,
        closeIcon,
        icon
      },
      closable,
      renderWrapper,
      removeAriaLabel,
      editable,
      onClick,
      onFocus,
      onBlur,
      onKeyDown,
      onMouseDown,
      onMouseUp,
      style: style2,
      className,
      tabCount,
      currentPosition
    } = props;
    const tabPrefix = `${prefixCls}-tab`;
    const removable = getRemovable(closable, closeIcon, editable, disabled);
    function onInternalClick(e) {
      if (disabled) {
        return;
      }
      onClick(e);
    }
    function onRemoveTab(event) {
      event.preventDefault();
      event.stopPropagation();
      editable.onEdit("remove", {
        key,
        event
      });
    }
    const labelNode = reactExports.useMemo(() => icon && typeof label === "string" ? reactExports.createElement("span", null, label) : label, [label, icon]);
    const btnRef = reactExports.useRef(null);
    reactExports.useEffect(() => {
      if (focus && btnRef.current) {
        btnRef.current.focus();
      }
    }, [focus]);
    const node2 = reactExports.createElement("div", {
      key,
      "data-node-key": genDataNodeKey(key),
      className: clsx(tabPrefix, className, {
        [`${tabPrefix}-with-remove`]: removable,
        [`${tabPrefix}-active`]: active,
        [`${tabPrefix}-disabled`]: disabled,
        [`${tabPrefix}-focus`]: focus
      }),
      style: style2,
      onClick: onInternalClick
    }, reactExports.createElement("div", {
      ref: btnRef,
      role: "tab",
      "aria-selected": active,
      id: id2 && `${id2}-tab-${key}`,
      className: `${tabPrefix}-btn`,
      "aria-controls": id2 && `${id2}-panel-${key}`,
      "aria-disabled": disabled,
      tabIndex: disabled ? null : active ? 0 : -1,
      onClick: (e) => {
        e.stopPropagation();
        onInternalClick(e);
      },
      onKeyDown,
      onMouseDown,
      onMouseUp,
      onFocus,
      onBlur
    }, focus && reactExports.createElement("div", {
      "aria-live": "polite",
      style: {
        width: 0,
        height: 0,
        position: "absolute",
        overflow: "hidden",
        opacity: 0
      }
    }, `Tab ${currentPosition} of ${tabCount}`), icon && reactExports.createElement("span", {
      className: `${tabPrefix}-icon`
    }, icon), label && labelNode), removable && reactExports.createElement("button", {
      type: "button",
      "aria-label": removeAriaLabel || "remove",
      tabIndex: active ? 0 : -1,
      className: `${tabPrefix}-remove`,
      onClick: (e) => {
        e.stopPropagation();
        onRemoveTab(e);
      }
    }, closeIcon || editable.removeIcon || "×"));
    return renderWrapper ? renderWrapper(node2) : node2;
  };
  function _extends$k() {
    _extends$k = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$k.apply(this, arguments);
  }
  const getTabSize = (tab2, containerRect) => {
    const {
      offsetWidth,
      offsetHeight,
      offsetTop,
      offsetLeft
    } = tab2;
    const {
      width,
      height,
      left,
      top
    } = tab2.getBoundingClientRect();
    if (Math.abs(width - offsetWidth) < 1) {
      return [width, height, left - containerRect.left, top - containerRect.top];
    }
    return [offsetWidth, offsetHeight, offsetLeft, offsetTop];
  };
  const getSize$1 = (refObj) => {
    const {
      offsetWidth = 0,
      offsetHeight = 0
    } = refObj.current || {};
    if (refObj.current) {
      const {
        width,
        height
      } = refObj.current.getBoundingClientRect();
      if (Math.abs(width - offsetWidth) < 1) {
        return [width, height];
      }
    }
    return [offsetWidth, offsetHeight];
  };
  const getUnitValue = (size, tabPositionTopOrBottom) => {
    return size[tabPositionTopOrBottom ? 0 : 1];
  };
  const TabNavList = reactExports.forwardRef((props, ref2) => {
    const {
      className,
      style: style2,
      id: id2,
      animated,
      activeKey,
      rtl,
      extra,
      editable,
      locale: locale2,
      tabPosition,
      tabBarGutter,
      children,
      onTabClick,
      onTabScroll,
      indicator,
      classNames: tabsClassNames,
      styles
    } = props;
    const {
      prefixCls,
      tabs
    } = reactExports.useContext(TabContext);
    const containerRef = reactExports.useRef(null);
    const extraLeftRef = reactExports.useRef(null);
    const extraRightRef = reactExports.useRef(null);
    const tabsWrapperRef = reactExports.useRef(null);
    const tabListRef = reactExports.useRef(null);
    const operationsRef = reactExports.useRef(null);
    const innerAddButtonRef = reactExports.useRef(null);
    const tabPositionTopOrBottom = tabPosition === "top" || tabPosition === "bottom";
    const [transformLeft, setTransformLeft] = useSyncState(0, (next2, prev2) => {
      if (tabPositionTopOrBottom && onTabScroll) {
        onTabScroll({
          direction: next2 > prev2 ? "left" : "right"
        });
      }
    });
    const [transformTop, setTransformTop] = useSyncState(0, (next2, prev2) => {
      if (!tabPositionTopOrBottom && onTabScroll) {
        onTabScroll({
          direction: next2 > prev2 ? "top" : "bottom"
        });
      }
    });
    const [containerExcludeExtraSize, setContainerExcludeExtraSize] = reactExports.useState([0, 0]);
    const [tabContentSize, setTabContentSize] = reactExports.useState([0, 0]);
    const [addSize, setAddSize] = reactExports.useState([0, 0]);
    const [operationSize, setOperationSize] = reactExports.useState([0, 0]);
    const [tabSizes, setTabSizes] = useUpdateState( new Map());
    const tabOffsets = useOffsets(tabs, tabSizes, tabContentSize[0]);
    const containerExcludeExtraSizeValue = getUnitValue(containerExcludeExtraSize, tabPositionTopOrBottom);
    const tabContentSizeValue = getUnitValue(tabContentSize, tabPositionTopOrBottom);
    const addSizeValue = getUnitValue(addSize, tabPositionTopOrBottom);
    const operationSizeValue = getUnitValue(operationSize, tabPositionTopOrBottom);
    const needScroll = Math.floor(containerExcludeExtraSizeValue) < Math.floor(tabContentSizeValue + addSizeValue);
    const visibleTabContentValue = needScroll ? containerExcludeExtraSizeValue - operationSizeValue : containerExcludeExtraSizeValue - addSizeValue;
    const operationsHiddenClassName = `${prefixCls}-nav-operations-hidden`;
    let transformMin = 0;
    let transformMax = 0;
    if (!tabPositionTopOrBottom) {
      transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
      transformMax = 0;
    } else if (rtl) {
      transformMin = 0;
      transformMax = Math.max(0, tabContentSizeValue - visibleTabContentValue);
    } else {
      transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
      transformMax = 0;
    }
    function alignInRange(value) {
      if (value < transformMin) {
        return transformMin;
      }
      if (value > transformMax) {
        return transformMax;
      }
      return value;
    }
    const touchMovingRef = reactExports.useRef(null);
    const [lockAnimation, setLockAnimation] = reactExports.useState();
    function doLockAnimation() {
      setLockAnimation(Date.now());
    }
    function clearTouchMoving() {
      if (touchMovingRef.current) {
        clearTimeout(touchMovingRef.current);
      }
    }
    useTouchMove(tabsWrapperRef, (offsetX, offsetY) => {
      function doMove(setState, offset2) {
        setState((value) => {
          const newValue = alignInRange(value + offset2);
          return newValue;
        });
      }
      if (!needScroll) {
        return false;
      }
      if (tabPositionTopOrBottom) {
        doMove(setTransformLeft, offsetX);
      } else {
        doMove(setTransformTop, offsetY);
      }
      clearTouchMoving();
      doLockAnimation();
      return true;
    });
    reactExports.useEffect(() => {
      clearTouchMoving();
      if (lockAnimation) {
        touchMovingRef.current = setTimeout(() => {
          setLockAnimation(0);
        }, 100);
      }
      return clearTouchMoving;
    }, [lockAnimation]);
    const [visibleStart, visibleEnd] = useVisibleRange(
      tabOffsets,
visibleTabContentValue,
tabPositionTopOrBottom ? transformLeft : transformTop,
tabContentSizeValue,
addSizeValue,
operationSizeValue,
      {
        ...props,
        tabs
      }
    );
    const scrollToTab = useEvent$1((key = activeKey) => {
      const tabOffset = tabOffsets.get(key) || {
        width: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0
      };
      if (tabPositionTopOrBottom) {
        let newTransform = transformLeft;
        if (rtl) {
          if (tabOffset.right < transformLeft) {
            newTransform = tabOffset.right;
          } else if (tabOffset.right + tabOffset.width > transformLeft + visibleTabContentValue) {
            newTransform = tabOffset.right + tabOffset.width - visibleTabContentValue;
          }
        } else if (tabOffset.left < -transformLeft) {
          newTransform = -tabOffset.left;
        } else if (tabOffset.left + tabOffset.width > -transformLeft + visibleTabContentValue) {
          newTransform = -(tabOffset.left + tabOffset.width - visibleTabContentValue);
        }
        setTransformTop(0);
        setTransformLeft(alignInRange(newTransform));
      } else {
        let newTransform = transformTop;
        if (tabOffset.top < -transformTop) {
          newTransform = -tabOffset.top;
        } else if (tabOffset.top + tabOffset.height > -transformTop + visibleTabContentValue) {
          newTransform = -(tabOffset.top + tabOffset.height - visibleTabContentValue);
        }
        setTransformLeft(0);
        setTransformTop(alignInRange(newTransform));
      }
    });
    const [focusKey, setFocusKey] = reactExports.useState();
    const [isMouse, setIsMouse] = reactExports.useState(false);
    const enabledTabs = tabs.filter((tab2) => !tab2.disabled).map((tab2) => tab2.key);
    const onOffset = (offset2) => {
      const currentIndex = enabledTabs.indexOf(focusKey || activeKey);
      const len = enabledTabs.length;
      const nextIndex = (currentIndex + offset2 + len) % len;
      const newKey = enabledTabs[nextIndex];
      setFocusKey(newKey);
    };
    const handleRemoveTab = (removalTabKey, e) => {
      const removeIndex = enabledTabs.indexOf(removalTabKey);
      const removeTab = tabs.find((tab2) => tab2.key === removalTabKey);
      const removable = getRemovable(removeTab?.closable, removeTab?.closeIcon, editable, removeTab?.disabled);
      if (removable) {
        e.preventDefault();
        e.stopPropagation();
        editable.onEdit("remove", {
          key: removalTabKey,
          event: e
        });
        if (removeIndex === enabledTabs.length - 1) {
          onOffset(-1);
        } else {
          onOffset(1);
        }
      }
    };
    const handleMouseDown = (key, e) => {
      setIsMouse(true);
      if (e.button === 1) {
        handleRemoveTab(key, e);
      }
    };
    const handleKeyDown = (e) => {
      const {
        code
      } = e;
      const isRTL = rtl && tabPositionTopOrBottom;
      const firstEnabledTab = enabledTabs[0];
      const lastEnabledTab = enabledTabs[enabledTabs.length - 1];
      switch (code) {
case "ArrowLeft": {
          if (tabPositionTopOrBottom) {
            onOffset(isRTL ? 1 : -1);
          }
          break;
        }
case "ArrowRight": {
          if (tabPositionTopOrBottom) {
            onOffset(isRTL ? -1 : 1);
          }
          break;
        }
case "ArrowUp": {
          e.preventDefault();
          if (!tabPositionTopOrBottom) {
            onOffset(-1);
          }
          break;
        }
case "ArrowDown": {
          e.preventDefault();
          if (!tabPositionTopOrBottom) {
            onOffset(1);
          }
          break;
        }
case "Home": {
          e.preventDefault();
          setFocusKey(firstEnabledTab);
          break;
        }
case "End": {
          e.preventDefault();
          setFocusKey(lastEnabledTab);
          break;
        }
case "Enter":
        case "Space": {
          e.preventDefault();
          onTabClick(focusKey ?? activeKey, e);
          break;
        }
case "Backspace":
        case "Delete": {
          handleRemoveTab(focusKey, e);
          break;
        }
      }
    };
    const tabNodeStyle = {};
    if (tabPositionTopOrBottom) {
      tabNodeStyle.marginInlineStart = tabBarGutter;
    } else {
      tabNodeStyle.marginTop = tabBarGutter;
    }
    const tabNodes = tabs.map((tab2, i2) => {
      const {
        key
      } = tab2;
      return reactExports.createElement(TabNode, {
        id: id2,
        prefixCls,
        key,
        tab: tab2,
        className: tabsClassNames?.item,
        style: i2 === 0 ? styles?.item : {
          ...tabNodeStyle,
          ...styles?.item
        },
        closable: tab2.closable,
        editable,
        active: key === activeKey,
        focus: key === focusKey,
        renderWrapper: children,
        removeAriaLabel: locale2?.removeAriaLabel,
        tabCount: enabledTabs.length,
        currentPosition: i2 + 1,
        onClick: (e) => {
          onTabClick(key, e);
        },
        onKeyDown: handleKeyDown,
        onFocus: () => {
          if (!isMouse) {
            setFocusKey(key);
          }
          scrollToTab(key);
          doLockAnimation();
          if (!tabsWrapperRef.current) {
            return;
          }
          if (!rtl) {
            tabsWrapperRef.current.scrollLeft = 0;
          }
          tabsWrapperRef.current.scrollTop = 0;
        },
        onBlur: () => {
          setFocusKey(void 0);
        },
        onMouseDown: (e) => handleMouseDown(key, e),
        onMouseUp: () => {
          setIsMouse(false);
        }
      });
    });
    const updateTabSizes = () => setTabSizes(() => {
      const newSizes = new Map();
      const listRect = tabListRef.current?.getBoundingClientRect();
      tabs.forEach(({
        key
      }) => {
        const btnNode = tabListRef.current?.querySelector(`[data-node-key="${genDataNodeKey(key)}"]`);
        if (btnNode) {
          const [width, height, left, top] = getTabSize(btnNode, listRect);
          newSizes.set(key, {
            width,
            height,
            left,
            top
          });
        }
      });
      return newSizes;
    });
    reactExports.useEffect(() => {
      updateTabSizes();
    }, [tabs.map((tab2) => tab2.key).join("_")]);
    const onListHolderResize = useUpdate$1(() => {
      const containerSize = getSize$1(containerRef);
      const extraLeftSize = getSize$1(extraLeftRef);
      const extraRightSize = getSize$1(extraRightRef);
      setContainerExcludeExtraSize([containerSize[0] - extraLeftSize[0] - extraRightSize[0], containerSize[1] - extraLeftSize[1] - extraRightSize[1]]);
      const newAddSize = getSize$1(innerAddButtonRef);
      setAddSize(newAddSize);
      const newOperationSize = getSize$1(operationsRef);
      setOperationSize(newOperationSize);
      const tabContentFullSize = getSize$1(tabListRef);
      setTabContentSize([tabContentFullSize[0] - newAddSize[0], tabContentFullSize[1] - newAddSize[1]]);
      updateTabSizes();
    });
    const startHiddenTabs = tabs.slice(0, visibleStart);
    const endHiddenTabs = tabs.slice(visibleEnd + 1);
    const hiddenTabs = [...startHiddenTabs, ...endHiddenTabs];
    const activeTabOffset = tabOffsets.get(activeKey);
    const {
      style: indicatorStyle
    } = useIndicator({
      activeTabOffset,
      horizontal: tabPositionTopOrBottom,
      indicator,
      rtl
    });
    reactExports.useEffect(() => {
      scrollToTab();
    }, [activeKey, transformMin, transformMax, stringify(activeTabOffset), stringify(tabOffsets), tabPositionTopOrBottom]);
    reactExports.useEffect(() => {
      onListHolderResize();
    }, [rtl]);
    const hasDropdown = !!hiddenTabs.length;
    const wrapPrefix = `${prefixCls}-nav-wrap`;
    let pingLeft;
    let pingRight;
    let pingTop;
    let pingBottom;
    if (tabPositionTopOrBottom) {
      if (rtl) {
        pingRight = transformLeft > 0;
        pingLeft = transformLeft !== transformMax;
      } else {
        pingLeft = transformLeft < 0;
        pingRight = transformLeft !== transformMin;
      }
    } else {
      pingTop = transformTop < 0;
      pingBottom = transformTop !== transformMin;
    }
    return reactExports.createElement(RefResizeObserver, {
      onResize: onListHolderResize
    }, reactExports.createElement("div", {
      ref: useComposeRef(ref2, containerRef),
      role: "tablist",
      "aria-orientation": tabPositionTopOrBottom ? "horizontal" : "vertical",
      className: clsx(`${prefixCls}-nav`, className, tabsClassNames?.header),
      style: {
        ...styles?.header,
        ...style2
      },
      onKeyDown: () => {
        doLockAnimation();
      }
    }, reactExports.createElement(ExtraContent, {
      ref: extraLeftRef,
      position: "left",
      extra,
      prefixCls
    }), reactExports.createElement(RefResizeObserver, {
      onResize: onListHolderResize
    }, reactExports.createElement("div", {
      className: clsx(wrapPrefix, {
        [`${wrapPrefix}-ping-left`]: pingLeft,
        [`${wrapPrefix}-ping-right`]: pingRight,
        [`${wrapPrefix}-ping-top`]: pingTop,
        [`${wrapPrefix}-ping-bottom`]: pingBottom
      }),
      ref: tabsWrapperRef
    }, reactExports.createElement(RefResizeObserver, {
      onResize: onListHolderResize
    }, reactExports.createElement("div", {
      ref: tabListRef,
      className: `${prefixCls}-nav-list`,
      style: {
        transform: `translate(${transformLeft}px, ${transformTop}px)`,
        transition: lockAnimation ? "none" : void 0
      }
    }, tabNodes, reactExports.createElement(AddButton, {
      ref: innerAddButtonRef,
      prefixCls,
      locale: locale2,
      editable,
      style: {
        ...tabNodes.length === 0 ? void 0 : tabNodeStyle,
        visibility: hasDropdown ? "hidden" : null
      }
    }), reactExports.createElement("div", {
      className: clsx(`${prefixCls}-ink-bar`, tabsClassNames?.indicator, {
        [`${prefixCls}-ink-bar-animated`]: animated.inkBar
      }),
      style: {
        ...indicatorStyle,
        ...styles?.indicator
      }
    }))))), reactExports.createElement(OperationNode$1, _extends$k({}, props, {
      removeAriaLabel: locale2?.removeAriaLabel,
      ref: operationsRef,
      prefixCls,
      tabs: hiddenTabs,
      className: !hasDropdown && operationsHiddenClassName,
      popupStyle: styles?.popup,
      tabMoving: !!lockAnimation
    })), reactExports.createElement(ExtraContent, {
      ref: extraRightRef,
      position: "right",
      extra,
      prefixCls
    })));
  });
  const TabNavListWrapper = ({
    renderTabBar,
    ...restProps
  }) => {
    if (renderTabBar) {
      return renderTabBar(restProps, TabNavList);
    }
    return reactExports.createElement(TabNavList, restProps);
  };
  const TabPane$1 = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls,
      className,
      style: style2,
      id: id2,
      active,
      tabKey,
      children
    } = props;
    const hasContent = reactExports.Children.count(children) > 0;
    return reactExports.createElement("div", {
      id: id2 && `${id2}-panel-${tabKey}`,
      role: "tabpanel",
      tabIndex: active && hasContent ? 0 : -1,
      "aria-labelledby": id2 && `${id2}-tab-${tabKey}`,
      "aria-hidden": !active,
      style: style2,
      className: clsx(prefixCls, active && `${prefixCls}-active`, className),
      ref: ref2
    }, children);
  });
  function _extends$j() {
    _extends$j = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$j.apply(this, arguments);
  }
  const TabPanelList = (props) => {
    const {
      id: id2,
      activeKey,
      animated,
      tabPosition,
      destroyOnHidden,
      contentStyle,
      contentClassName
    } = props;
    const {
      prefixCls,
      tabs
    } = reactExports.useContext(TabContext);
    const tabPaneAnimated = animated.tabPane;
    const tabPanePrefixCls = `${prefixCls}-tabpane`;
    return reactExports.createElement("div", {
      className: clsx(`${prefixCls}-content-holder`)
    }, reactExports.createElement("div", {
      className: clsx(`${prefixCls}-content`, `${prefixCls}-content-${tabPosition}`, {
        [`${prefixCls}-content-animated`]: tabPaneAnimated
      })
    }, tabs.map((item) => {
      const {
        key,
        forceRender,
        style: paneStyle,
        className: paneClassName,
        destroyOnHidden: itemDestroyOnHidden,
        ...restTabProps
      } = item;
      const active = key === activeKey;
      return reactExports.createElement(CSSMotion, _extends$j({
        key,
        visible: active,
        forceRender,
        removeOnLeave: !!(destroyOnHidden ?? itemDestroyOnHidden),
        leavedClassName: `${tabPanePrefixCls}-hidden`
      }, animated.tabPaneMotion), ({
        style: motionStyle,
        className: motionClassName
      }, ref2) => reactExports.createElement(TabPane$1, _extends$j({}, restTabProps, {
        prefixCls: tabPanePrefixCls,
        id: id2,
        tabKey: key,
        animated: tabPaneAnimated,
        active,
        style: {
          ...contentStyle,
          ...paneStyle,
          ...motionStyle
        },
        className: clsx(contentClassName, paneClassName, motionClassName),
        ref: ref2
      })));
    })));
  };
  function useAnimateConfig$1(animated = {
    inkBar: true,
    tabPane: false
  }) {
    let mergedAnimated;
    if (animated === false) {
      mergedAnimated = {
        inkBar: false,
        tabPane: false
      };
    } else if (animated === true) {
      mergedAnimated = {
        inkBar: true,
        tabPane: false
      };
    } else {
      mergedAnimated = {
        inkBar: true,
        ...typeof animated === "object" ? animated : {}
      };
    }
    if (mergedAnimated.tabPaneMotion && mergedAnimated.tabPane === void 0) {
      mergedAnimated.tabPane = true;
    }
    if (!mergedAnimated.tabPaneMotion && mergedAnimated.tabPane) {
      mergedAnimated.tabPane = false;
    }
    return mergedAnimated;
  }
  function _extends$i() {
    _extends$i = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$i.apply(this, arguments);
  }
  let uuid = 0;
  const Tabs$1 = reactExports.forwardRef((props, ref2) => {
    const {
      id: id2,
      prefixCls = "rc-tabs",
      className,
      items,
      direction,
      activeKey,
      defaultActiveKey,
      editable,
      animated,
      tabPosition = "top",
      tabBarGutter,
      tabBarStyle,
      tabBarExtraContent,
      locale: locale2,
      more,
      destroyOnHidden,
      renderTabBar,
      onChange,
      onTabClick,
      onTabScroll,
      getPopupContainer,
      popupClassName,
      indicator,
      classNames: tabsClassNames,
      styles,
      ...restProps
    } = props;
    const tabs = reactExports.useMemo(() => (items || []).filter((item) => item && typeof item === "object" && "key" in item), [items]);
    const rtl = direction === "rtl";
    const mergedAnimated = useAnimateConfig$1(animated);
    const [mobile, setMobile] = reactExports.useState(false);
    reactExports.useEffect(() => {
      setMobile(isMobile());
    }, []);
    const [mergedActiveKey, setMergedActiveKey] = useControlledState(defaultActiveKey ?? tabs[0]?.key, activeKey);
    const [activeIndex, setActiveIndex] = reactExports.useState(() => tabs.findIndex((tab2) => tab2.key === mergedActiveKey));
    reactExports.useEffect(() => {
      let newActiveIndex = tabs.findIndex((tab2) => tab2.key === mergedActiveKey);
      if (newActiveIndex === -1) {
        newActiveIndex = Math.max(0, Math.min(activeIndex, tabs.length - 1));
        setMergedActiveKey(tabs[newActiveIndex]?.key);
      }
      setActiveIndex(newActiveIndex);
    }, [tabs.map((tab2) => tab2.key).join("_"), mergedActiveKey, activeIndex]);
    const [mergedId, setMergedId] = useControlledState(null, id2);
    reactExports.useEffect(() => {
      if (!id2) {
        setMergedId(`rc-tabs-${uuid}`);
        uuid += 1;
      }
    }, []);
    function onInternalTabClick(key, e) {
      onTabClick?.(key, e);
      const isActiveChanged = key !== mergedActiveKey;
      setMergedActiveKey(key);
      if (isActiveChanged) {
        onChange?.(key);
      }
    }
    const sharedProps = {
      id: mergedId,
      activeKey: mergedActiveKey,
      animated: mergedAnimated,
      tabPosition,
      rtl,
      mobile
    };
    const tabNavBarProps = {
      ...sharedProps,
      editable,
      locale: locale2,
      more,
      tabBarGutter,
      onTabClick: onInternalTabClick,
      onTabScroll,
      extra: tabBarExtraContent,
      style: tabBarStyle,
      getPopupContainer,
      popupClassName: clsx(popupClassName, tabsClassNames?.popup),
      indicator,
      styles,
      classNames: tabsClassNames
    };
    const memoizedValue = reactExports.useMemo(() => {
      return {
        tabs,
        prefixCls
      };
    }, [tabs, prefixCls]);
    return reactExports.createElement(TabContext.Provider, {
      value: memoizedValue
    }, reactExports.createElement("div", _extends$i({
      ref: ref2,
      id: id2,
      className: clsx(prefixCls, `${prefixCls}-${tabPosition}`, {
        [`${prefixCls}-mobile`]: mobile,
        [`${prefixCls}-editable`]: editable,
        [`${prefixCls}-rtl`]: rtl
      }, className)
    }, restProps), reactExports.createElement(TabNavListWrapper, _extends$i({}, tabNavBarProps, {
      renderTabBar
    })), reactExports.createElement(TabPanelList, _extends$i({
      destroyOnHidden
    }, sharedProps, {
      contentStyle: styles?.content,
      contentClassName: tabsClassNames?.content,
      animated: mergedAnimated
    }))));
  });
  const motion$1 = {
    motionAppear: false,
    motionEnter: true,
    motionLeave: true
  };
  function useAnimateConfig(prefixCls, animated = {
    inkBar: true,
    tabPane: false
  }) {
    let mergedAnimated;
    if (animated === false) {
      mergedAnimated = {
        inkBar: false,
        tabPane: false
      };
    } else if (animated === true) {
      mergedAnimated = {
        inkBar: true,
        tabPane: true
      };
    } else {
      mergedAnimated = {
        inkBar: true,
        ...typeof animated === "object" ? animated : {}
      };
    }
    if (mergedAnimated.tabPane) {
      mergedAnimated.tabPaneMotion = {
        ...motion$1,
        motionName: getTransitionName(prefixCls, "switch")
      };
    }
    return mergedAnimated;
  }
  function filter$1(items) {
    return items.filter((item) => item);
  }
  function useLegacyItems(items, children) {
    if (items) {
      return items.map((item) => ({
        ...item,
        destroyOnHidden: item.destroyOnHidden ?? item.destroyInactiveTabPane
      }));
    }
    const childrenItems = toArray$4(children).map((node2) => {
      if ( reactExports.isValidElement(node2)) {
        const {
          key,
          props
        } = node2;
        const {
          tab: tab2,
          ...restProps
        } = props || {};
        const item = {
          key: String(key),
          ...restProps,
          label: tab2
        };
        return item;
      }
      return null;
    });
    return filter$1(childrenItems);
  }
  const genMotionStyle = (token2) => {
    const {
      componentCls,
      motionDurationSlow
    } = token2;
    return [
      {
        [componentCls]: {
          [`${componentCls}-switch`]: {
            "&-appear, &-enter": {
              transition: "none",
              "&-start": {
                opacity: 0
              },
              "&-active": {
                opacity: 1,
                transition: `opacity ${motionDurationSlow}`
              }
            },
            "&-leave": {
              position: "absolute",
              transition: "none",
              inset: 0,
              "&-start": {
                opacity: 1
              },
              "&-active": {
                opacity: 0,
                transition: `opacity ${motionDurationSlow}`
              }
            }
          }
        }
      },
[initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down")]
    ];
  };
  const genCardStyle = (token2) => {
    const {
      componentCls,
      tabsCardPadding,
      cardBg,
      cardGutter,
      colorBorderSecondary,
      itemSelectedColor
    } = token2;
    return {
      [`${componentCls}-card`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            margin: 0,
            padding: tabsCardPadding,
            background: cardBg,
            border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
            transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
          },
          [`${componentCls}-tab-active`]: {
            color: itemSelectedColor,
            background: token2.colorBgContainer
          },
          [`${componentCls}-tab-focus:has(${componentCls}-tab-btn:focus-visible)`]: genFocusOutline(token2, -3),
          [`& ${componentCls}-tab${componentCls}-tab-focus ${componentCls}-tab-btn:focus-visible`]: {
            outline: "none"
          },
          [`${componentCls}-ink-bar`]: {
            visibility: "hidden"
          }
        },
[`&${componentCls}-top, &${componentCls}-bottom`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab + ${componentCls}-tab`]: {
              marginLeft: {
                _skip_check_: true,
                value: unit$1(cardGutter)
              }
            }
          }
        },
        [`&${componentCls}-top`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              borderRadius: `${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)} 0 0`
            },
            [`${componentCls}-tab-active`]: {
              borderBottomColor: token2.colorBgContainer
            }
          }
        },
        [`&${componentCls}-bottom`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              borderRadius: `0 0 ${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)}`
            },
            [`${componentCls}-tab-active`]: {
              borderTopColor: token2.colorBgContainer
            }
          }
        },
[`&${componentCls}-left, &${componentCls}-right`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab + ${componentCls}-tab`]: {
              marginTop: unit$1(cardGutter)
            }
          }
        },
        [`&${componentCls}-left`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              borderRadius: {
                _skip_check_: true,
                value: `${unit$1(token2.borderRadiusLG)} 0 0 ${unit$1(token2.borderRadiusLG)}`
              }
            },
            [`${componentCls}-tab-active`]: {
              borderRightColor: {
                _skip_check_: true,
                value: token2.colorBgContainer
              }
            }
          }
        },
        [`&${componentCls}-right`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              borderRadius: {
                _skip_check_: true,
                value: `0 ${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)} 0`
              }
            },
            [`${componentCls}-tab-active`]: {
              borderLeftColor: {
                _skip_check_: true,
                value: token2.colorBgContainer
              }
            }
          }
        }
      }
    };
  };
  const genDropdownStyle = (token2) => {
    const {
      componentCls,
      itemHoverColor,
      dropdownEdgeChildVerticalPadding
    } = token2;
    return {
      [`${componentCls}-dropdown`]: {
        ...resetComponent(token2),
        position: "absolute",
        top: -9999,
        left: {
          _skip_check_: true,
          value: -9999
        },
        zIndex: token2.zIndexPopup,
        display: "block",
        "&-hidden": {
          display: "none"
        },
        [`${componentCls}-dropdown-menu`]: {
          maxHeight: token2.tabsDropdownHeight,
          margin: 0,
          padding: `${unit$1(dropdownEdgeChildVerticalPadding)} 0`,
          overflowX: "hidden",
          overflowY: "auto",
          textAlign: {
            _skip_check_: true,
            value: "left"
          },
          listStyleType: "none",
          backgroundColor: token2.colorBgContainer,
          backgroundClip: "padding-box",
          borderRadius: token2.borderRadiusLG,
          outline: "none",
          boxShadow: token2.boxShadowSecondary,
          "&-item": {
            ...textEllipsis,
            display: "flex",
            alignItems: "center",
            minWidth: token2.tabsDropdownWidth,
            margin: 0,
            padding: `${unit$1(token2.paddingXXS)} ${unit$1(token2.paddingSM)}`,
            color: token2.colorText,
            fontWeight: "normal",
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            cursor: "pointer",
            transition: `all ${token2.motionDurationSlow}`,
            "> span": {
              flex: 1,
              whiteSpace: "nowrap"
            },
            "&-remove": {
              flex: "none",
              marginLeft: {
                _skip_check_: true,
                value: token2.marginSM
              },
              color: token2.colorIcon,
              fontSize: token2.fontSizeSM,
              background: "transparent",
              border: 0,
              cursor: "pointer",
              "&:hover": {
                color: itemHoverColor
              }
            },
            "&:hover": {
              background: token2.controlItemBgHover
            },
            "&-disabled": {
              "&, &:hover": {
                color: token2.colorTextDisabled,
                background: "transparent",
                cursor: "not-allowed"
              }
            }
          }
        }
      }
    };
  };
  const genPositionStyle = (token2) => {
    const {
      componentCls,
      margin,
      colorBorderSecondary,
      horizontalMargin,
      verticalItemPadding,
      verticalItemMargin,
      motionDurationSlow,
      calc
    } = token2;
    return {
[`${componentCls}-top, ${componentCls}-bottom`]: {
        flexDirection: "column",
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          margin: horizontalMargin,
          "&::before": {
            position: "absolute",
            right: {
              _skip_check_: true,
              value: 0
            },
            left: {
              _skip_check_: true,
              value: 0
            },
            borderBottom: `${unit$1(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
            content: "''"
          },
          [`${componentCls}-ink-bar`]: {
            height: token2.lineWidthBold,
            "&-animated": {
              transition: ["width", "left", "right"].map((prop) => `${prop} ${motionDurationSlow}`).join(", ")
            }
          },
          [`${componentCls}-nav-wrap`]: {
            "&::before, &::after": {
              top: 0,
              bottom: 0,
              width: token2.controlHeight
            },
            "&::before": {
              left: {
                _skip_check_: true,
                value: 0
              },
              boxShadow: token2.boxShadowTabsOverflowLeft
            },
            "&::after": {
              right: {
                _skip_check_: true,
                value: 0
              },
              boxShadow: token2.boxShadowTabsOverflowRight
            },
            [`&${componentCls}-nav-wrap-ping-left::before`]: {
              opacity: 1
            },
            [`&${componentCls}-nav-wrap-ping-right::after`]: {
              opacity: 1
            }
          }
        }
      },
      [`${componentCls}-top`]: {
        [`> ${componentCls}-nav,
        > div > ${componentCls}-nav`]: {
          "&::before": {
            bottom: 0
          },
          [`${componentCls}-ink-bar`]: {
            bottom: 0
          }
        }
      },
      [`${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          order: 1,
          marginTop: margin,
          marginBottom: 0,
          "&::before": {
            top: 0
          },
          [`${componentCls}-ink-bar`]: {
            top: 0
          }
        },
        [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
          order: 0
        }
      },
[`${componentCls}-left, ${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          flexDirection: "column",
          minWidth: calc(token2.controlHeight).mul(1.25).equal(),
[`${componentCls}-tab`]: {
            padding: verticalItemPadding,
            textAlign: "center"
          },
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            margin: verticalItemMargin
          },
[`${componentCls}-nav-wrap`]: {
            flexDirection: "column",
            "&::before, &::after": {
              right: {
                _skip_check_: true,
                value: 0
              },
              left: {
                _skip_check_: true,
                value: 0
              },
              height: token2.controlHeight
            },
            "&::before": {
              top: 0,
              boxShadow: token2.boxShadowTabsOverflowTop
            },
            "&::after": {
              bottom: 0,
              boxShadow: token2.boxShadowTabsOverflowBottom
            },
            [`&${componentCls}-nav-wrap-ping-top::before`]: {
              opacity: 1
            },
            [`&${componentCls}-nav-wrap-ping-bottom::after`]: {
              opacity: 1
            }
          },
[`${componentCls}-ink-bar`]: {
            width: token2.lineWidthBold,
            "&-animated": {
              transition: ["height", "top"].map((prop) => `${prop} ${motionDurationSlow}`).join(", ")
            }
          },
          [`${componentCls}-nav-list, ${componentCls}-nav-operations`]: {
            flex: "1 0 auto",
flexDirection: "column"
          }
        }
      },
      [`${componentCls}-left`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-ink-bar`]: {
            right: {
              _skip_check_: true,
              value: 0
            }
          }
        },
        [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
          marginLeft: {
            _skip_check_: true,
            value: unit$1(calc(token2.lineWidth).mul(-1).equal())
          },
          borderLeft: {
            _skip_check_: true,
            value: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
          },
          [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
            paddingLeft: {
              _skip_check_: true,
              value: token2.paddingLG
            }
          }
        }
      },
      [`${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          order: 1,
          [`${componentCls}-ink-bar`]: {
            left: {
              _skip_check_: true,
              value: 0
            }
          }
        },
        [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
          order: 0,
          marginRight: {
            _skip_check_: true,
            value: calc(token2.lineWidth).mul(-1).equal()
          },
          borderRight: {
            _skip_check_: true,
            value: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
          },
          [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
            paddingRight: {
              _skip_check_: true,
              value: token2.paddingLG
            }
          }
        }
      }
    };
  };
  const genSizeStyle$2 = (token2) => {
    const {
      componentCls,
      cardPaddingSM,
      cardPaddingLG,
      cardHeightSM,
      cardHeightLG,
      horizontalItemPaddingSM,
      horizontalItemPaddingLG
    } = token2;
    return {
[componentCls]: {
        "&-small": {
          [`> ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              padding: horizontalItemPaddingSM,
              fontSize: token2.titleFontSizeSM
            }
          }
        },
        "&-large": {
          [`> ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              padding: horizontalItemPaddingLG,
              fontSize: token2.titleFontSizeLG,
              lineHeight: token2.lineHeightLG
            }
          }
        }
      },
[`${componentCls}-card`]: {
[`&${componentCls}-small`]: {
          [`> ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              padding: cardPaddingSM
            },
            [`${componentCls}-nav-add`]: {
              minWidth: cardHeightSM,
              minHeight: cardHeightSM
            }
          },
          [`&${componentCls}-bottom`]: {
            [`> ${componentCls}-nav ${componentCls}-tab`]: {
              borderRadius: `0 0 ${unit$1(token2.borderRadius)} ${unit$1(token2.borderRadius)}`
            }
          },
          [`&${componentCls}-top`]: {
            [`> ${componentCls}-nav ${componentCls}-tab`]: {
              borderRadius: `${unit$1(token2.borderRadius)} ${unit$1(token2.borderRadius)} 0 0`
            }
          },
          [`&${componentCls}-right`]: {
            [`> ${componentCls}-nav ${componentCls}-tab`]: {
              borderRadius: {
                _skip_check_: true,
                value: `0 ${unit$1(token2.borderRadius)} ${unit$1(token2.borderRadius)} 0`
              }
            }
          },
          [`&${componentCls}-left`]: {
            [`> ${componentCls}-nav ${componentCls}-tab`]: {
              borderRadius: {
                _skip_check_: true,
                value: `${unit$1(token2.borderRadius)} 0 0 ${unit$1(token2.borderRadius)}`
              }
            }
          }
        },
[`&${componentCls}-large`]: {
          [`> ${componentCls}-nav`]: {
            [`${componentCls}-tab`]: {
              padding: cardPaddingLG
            },
            [`${componentCls}-nav-add`]: {
              minWidth: cardHeightLG,
              minHeight: cardHeightLG
            }
          }
        }
      }
    };
  };
  const genTabStyle = (token2) => {
    const {
      componentCls,
      itemActiveColor,
      itemHoverColor,
      iconCls,
      tabsHorizontalItemMargin,
      horizontalItemPadding,
      itemSelectedColor,
      itemColor
    } = token2;
    const tabCls = `${componentCls}-tab`;
    return {
      [tabCls]: {
        position: "relative",
        WebkitTouchCallout: "none",
        WebkitTapHighlightColor: "transparent",
        display: "inline-flex",
        alignItems: "center",
        padding: horizontalItemPadding,
        fontSize: token2.titleFontSize,
        background: "transparent",
        border: 0,
        outline: "none",
        cursor: "pointer",
        color: itemColor,
        "&-btn, &-remove": {
          "&:focus:not(:focus-visible), &:active": {
            color: itemActiveColor
          }
        },
        "&-btn": {
          outline: "none",
          transition: `all ${token2.motionDurationSlow}`,
          [`${tabCls}-icon:not(:last-child)`]: {
            marginInlineEnd: token2.marginSM
          }
        },
        "&-remove": {
          flex: "none",
          lineHeight: 1,
          marginRight: {
            _skip_check_: true,
            value: token2.calc(token2.marginXXS).mul(-1).equal()
          },
          marginLeft: {
            _skip_check_: true,
            value: token2.marginXS
          },
          color: token2.colorIcon,
          fontSize: token2.fontSizeSM,
          background: "transparent",
          border: "none",
          outline: "none",
          cursor: "pointer",
          transition: `all ${token2.motionDurationSlow}`,
          "&:hover": {
            color: token2.colorTextHeading
          },
          ...genFocusStyle(token2)
        },
        "&:hover": {
          color: itemHoverColor
        },
        [`&${tabCls}-active ${tabCls}-btn`]: {
          color: itemSelectedColor
        },
        [`&${tabCls}-focus ${tabCls}-btn:focus-visible`]: genFocusOutline(token2),
        [`&${tabCls}-disabled`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        },
        [`&${tabCls}-disabled ${tabCls}-btn, &${tabCls}-disabled ${componentCls}-remove`]: {
          "&:focus, &:active": {
            color: token2.colorTextDisabled
          }
        },
        [`& ${tabCls}-remove ${iconCls}`]: {
          margin: 0,
          verticalAlign: "middle"
        },
        [`${iconCls}:not(:last-child)`]: {
          marginRight: {
            _skip_check_: true,
            value: token2.marginSM
          }
        }
      },
      [`${tabCls} + ${tabCls}`]: {
        margin: {
          _skip_check_: true,
          value: tabsHorizontalItemMargin
        }
      }
    };
  };
  const genRtlStyle$1 = (token2) => {
    const {
      componentCls,
      tabsHorizontalItemMarginRTL,
      iconCls,
      cardGutter,
      calc
    } = token2;
    const rtlCls = `${componentCls}-rtl`;
    return {
      [rtlCls]: {
        direction: "rtl",
        [`${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            margin: {
              _skip_check_: true,
              value: tabsHorizontalItemMarginRTL
            },
            [`${componentCls}-tab:last-of-type`]: {
              marginLeft: {
                _skip_check_: true,
                value: 0
              }
            },
            [iconCls]: {
              marginRight: {
                _skip_check_: true,
                value: 0
              },
              marginLeft: {
                _skip_check_: true,
                value: unit$1(token2.marginSM)
              }
            },
            [`${componentCls}-tab-remove`]: {
              marginRight: {
                _skip_check_: true,
                value: unit$1(token2.marginXS)
              },
              marginLeft: {
                _skip_check_: true,
                value: unit$1(calc(token2.marginXXS).mul(-1).equal())
              },
              [iconCls]: {
                margin: 0
              }
            }
          }
        },
        [`&${componentCls}-left`]: {
          [`> ${componentCls}-nav`]: {
            order: 1
          },
          [`> ${componentCls}-content-holder`]: {
            order: 0
          }
        },
        [`&${componentCls}-right`]: {
          [`> ${componentCls}-nav`]: {
            order: 0
          },
          [`> ${componentCls}-content-holder`]: {
            order: 1
          }
        },
[`&${componentCls}-card${componentCls}-top, &${componentCls}-card${componentCls}-bottom`]: {
          [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
            [`${componentCls}-tab + ${componentCls}-tab`]: {
              marginRight: {
                _skip_check_: true,
                value: cardGutter
              },
              marginLeft: {
                _skip_check_: true,
                value: 0
              }
            }
          }
        }
      },
      [`${componentCls}-dropdown-rtl`]: {
        direction: "rtl"
      },
      [`${componentCls}-menu-item`]: {
        [`${componentCls}-dropdown-rtl`]: {
          textAlign: {
            _skip_check_: true,
            value: "right"
          }
        }
      }
    };
  };
  const genTabsStyle = (token2) => {
    const {
      componentCls,
      tabsCardPadding,
      cardHeight,
      cardGutter,
      itemHoverColor,
      itemActiveColor,
      colorBorderSecondary
    } = token2;
    return {
      [componentCls]: {
        ...resetComponent(token2),
        display: "flex",
[`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          position: "relative",
          display: "flex",
          flex: "none",
          alignItems: "center",
          [`${componentCls}-nav-wrap`]: {
            position: "relative",
            display: "flex",
            flex: "auto",
            alignSelf: "stretch",
            overflow: "hidden",
            whiteSpace: "nowrap",
            transform: "translate(0)",

"&::before, &::after": {
              position: "absolute",
              zIndex: 1,
              opacity: 0,
              transition: `opacity ${token2.motionDurationSlow}`,
              content: "''",
              pointerEvents: "none"
            }
          },
          [`${componentCls}-nav-list`]: {
            position: "relative",
            display: "flex",
            transition: `opacity ${token2.motionDurationSlow}`
          },
[`${componentCls}-nav-operations`]: {
            display: "flex",
            alignSelf: "stretch"
          },
          [`${componentCls}-nav-operations-hidden`]: {
            position: "absolute",
            visibility: "hidden",
            pointerEvents: "none"
          },
          [`${componentCls}-nav-more`]: {
            position: "relative",
            padding: tabsCardPadding,
            background: "transparent",
            border: 0,
            color: token2.colorText,
            "&::after": {
              position: "absolute",
              right: {
                _skip_check_: true,
                value: 0
              },
              bottom: 0,
              left: {
                _skip_check_: true,
                value: 0
              },
              height: token2.calc(token2.controlHeightLG).div(8).equal(),
              transform: "translateY(100%)",
              content: "''"
            }
          },
          [`${componentCls}-nav-add`]: {
            minWidth: cardHeight,
            minHeight: cardHeight,
            marginLeft: {
              _skip_check_: true,
              value: cardGutter
            },
            background: "transparent",
            border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${colorBorderSecondary}`,
            borderRadius: `${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)} 0 0`,
            outline: "none",
            cursor: "pointer",
            color: token2.colorText,
            transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
            "&:hover": {
              color: itemHoverColor
            },
            "&:active, &:focus:not(:focus-visible)": {
              color: itemActiveColor
            },
            ...genFocusStyle(token2, -3)
          }
        },
        [`${componentCls}-extra-content`]: {
          flex: "none"
        },
[`${componentCls}-ink-bar`]: {
          position: "absolute",
          background: token2.inkBarColor,
          pointerEvents: "none"
        },
...genTabStyle(token2),
[`${componentCls}-content`]: {
          position: "relative",
          width: "100%"
        },
        [`${componentCls}-content-holder`]: {
          flex: "auto",
          minWidth: 0,
          minHeight: 0
        },
        [`${componentCls}-tabpane`]: {
          ...genFocusStyle(token2),
          "&-hidden": {
            display: "none"
          }
        }
      },
      [`${componentCls}-centered`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-nav-wrap`]: {
            [`&:not([class*='${componentCls}-nav-wrap-ping']) > ${componentCls}-nav-list`]: {
              margin: "auto"
            }
          }
        }
      }
    };
  };
  const prepareComponentToken$d = (token2) => {
    const {
      cardHeight,
      cardHeightSM,
      cardHeightLG,
      controlHeight,
      controlHeightLG
    } = token2;
    const mergedCardHeight = cardHeight || controlHeightLG;
    const mergedCardHeightSM = cardHeightSM || controlHeight;
    const mergedCardHeightLG = cardHeightLG || controlHeightLG + 8;
    return {
      zIndexPopup: token2.zIndexPopupBase + 50,
      cardBg: token2.colorFillAlter,

cardHeight: mergedCardHeight,
      cardHeightSM: mergedCardHeightSM,
      cardHeightLG: mergedCardHeightLG,
cardPadding: `${(mergedCardHeight - token2.fontHeight) / 2 - token2.lineWidth}px ${token2.padding}px`,
      cardPaddingSM: `${(mergedCardHeightSM - token2.fontHeight) / 2 - token2.lineWidth}px ${token2.paddingXS}px`,
      cardPaddingLG: `${(mergedCardHeightLG - token2.fontHeightLG) / 2 - token2.lineWidth}px ${token2.padding}px`,
      titleFontSize: token2.fontSize,
      titleFontSizeLG: token2.fontSizeLG,
      titleFontSizeSM: token2.fontSize,
      inkBarColor: token2.colorPrimary,
      horizontalMargin: `0 0 ${token2.margin}px 0`,
      horizontalItemGutter: 32,

horizontalItemMargin: ``,
      horizontalItemMarginRTL: ``,
      horizontalItemPadding: `${token2.paddingSM}px 0`,
      horizontalItemPaddingSM: `${token2.paddingXS}px 0`,
      horizontalItemPaddingLG: `${token2.padding}px 0`,
      verticalItemPadding: `${token2.paddingXS}px ${token2.paddingLG}px`,
      verticalItemMargin: `${token2.margin}px 0 0 0`,
      itemColor: token2.colorText,
      itemSelectedColor: token2.colorPrimary,
      itemHoverColor: token2.colorPrimaryHover,
      itemActiveColor: token2.colorPrimaryActive,
      cardGutter: token2.marginXXS / 2
    };
  };
  const useStyle$l = genStyleHooks("Tabs", (token2) => {
    const tabsToken = merge$1(token2, {
tabsCardPadding: token2.cardPadding,
      dropdownEdgeChildVerticalPadding: token2.paddingXXS,
      tabsDropdownHeight: 200,
      tabsDropdownWidth: 120,
      tabsHorizontalItemMargin: `0 0 0 ${unit$1(token2.horizontalItemGutter)}`,
      tabsHorizontalItemMarginRTL: `0 0 0 ${unit$1(token2.horizontalItemGutter)}`
    });
    return [genSizeStyle$2(tabsToken), genRtlStyle$1(tabsToken), genPositionStyle(tabsToken), genDropdownStyle(tabsToken), genCardStyle(tabsToken), genTabsStyle(tabsToken), genMotionStyle(tabsToken)];
  }, prepareComponentToken$d);
  const TabPane = () => null;
  const InternalTabs = reactExports.forwardRef((props, ref2) => {
    const {
      type: type4,
      className,
      rootClassName,
      size: customSize,
      onEdit,
      hideAdd,
      centered,
      addIcon,
      removeIcon,
      moreIcon,
      more,
      popupClassName,
      children,
      items,
      animated,
      style: style2,
      indicatorSize,
      indicator,
      classNames,
      styles,
      destroyInactiveTabPane,
      destroyOnHidden,
      tabPlacement,
      tabPosition,
      ...restProps
    } = props;
    const {
      prefixCls: customizePrefixCls
    } = restProps;
    const {
      getPrefixCls,
      direction,
      getPopupContainer,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("tabs");
    const {
      tabs
    } = reactExports.useContext(ConfigContext);
    const prefixCls = getPrefixCls("tabs", customizePrefixCls);
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$l(prefixCls, rootCls);
    const tabsRef = reactExports.useRef(null);
    reactExports.useImperativeHandle(ref2, () => ({
      nativeElement: tabsRef.current
    }));
    let editable;
    if (type4 === "editable-card") {
      editable = {
        onEdit: (editType, {
          key,
          event
        }) => {
          onEdit?.(editType === "add" ? event : key, editType);
        },
        removeIcon: removeIcon ?? tabs?.removeIcon ?? reactExports.createElement(RefIcon$k, null),
        addIcon: (addIcon ?? tabs?.addIcon) || reactExports.createElement(RefIcon$9, null),
        showAdd: hideAdd !== true
      };
    }
    const rootPrefixCls = getPrefixCls();
    const size = useSize(customSize);
    const mergedItems = useLegacyItems(items, children);
    const mergedAnimated = useAnimateConfig(prefixCls, animated);
    const mergedIndicator = {
      align: indicator?.align ?? tabs?.indicator?.align,
      size: indicator?.size ?? indicatorSize ?? tabs?.indicator?.size ?? tabs?.indicatorSize
    };
    const mergedPlacement = reactExports.useMemo(() => {
      const placement = tabPlacement ?? tabPosition ?? void 0;
      const isRTL = direction === "rtl";
      switch (placement) {
        case "start":
          return isRTL ? "right" : "left";
        case "end":
          return isRTL ? "left" : "right";
        default:
          return placement;
      }
    }, [tabPlacement, tabPosition, direction]);
    const mergedProps = {
      ...props,
      size,
      tabPlacement: mergedPlacement,
      items: mergedItems
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    }, {
      popup: {
        _default: "root"
      }
    });
    return reactExports.createElement(Tabs$1, {
      ref: tabsRef,
      direction,
      getPopupContainer,
      ...restProps,
      items: mergedItems,
      className: clsx({
        [`${prefixCls}-${size}`]: size,
        [`${prefixCls}-card`]: ["card", "editable-card"].includes(type4),
        [`${prefixCls}-editable-card`]: type4 === "editable-card",
        [`${prefixCls}-centered`]: centered
      }, contextClassName, className, rootClassName, mergedClassNames.root, hashId, cssVarCls, rootCls),
      classNames: {
        ...mergedClassNames,
        popup: clsx(popupClassName, hashId, cssVarCls, rootCls, mergedClassNames.popup?.root)
      },
      styles: mergedStyles,
      style: {
        ...mergedStyles.root,
        ...contextStyle,
        ...style2
      },
      editable,
      more: {
        icon: tabs?.more?.icon ?? tabs?.moreIcon ?? moreIcon ?? reactExports.createElement(RefIcon$a, null),
        transitionName: `${rootPrefixCls}-slide-up`,
        ...more
      },
      prefixCls,
      animated: mergedAnimated,
      indicator: mergedIndicator,
      destroyOnHidden: destroyOnHidden ?? destroyInactiveTabPane,
      tabPosition: mergedPlacement
    });
  });
  const Tabs = InternalTabs;
  Tabs.TabPane = TabPane;
  function _objectWithoutPropertiesLoose(r2, e) {
    if (null == r2) return {};
    var t2 = {};
    for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
      if (-1 !== e.indexOf(n2)) continue;
      t2[n2] = r2[n2];
    }
    return t2;
  }
  function _objectWithoutProperties(e, t2) {
    if (null == e) return {};
    var o2, r2, i2 = _objectWithoutPropertiesLoose(e, t2);
    if (Object.getOwnPropertySymbols) {
      var n2 = Object.getOwnPropertySymbols(e);
      for (r2 = 0; r2 < n2.length; r2++) o2 = n2[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e, o2) && (i2[o2] = e[o2]);
    }
    return i2;
  }
  function throttle$1(delay2, callback, options) {
    var _ref4 = options || {}, _ref$noTrailing = _ref4.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref4.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref4.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
    var timeoutID;
    var cancelled = false;
    var lastExec = 0;
    function clearExistingTimeout() {
      if (timeoutID) {
        clearTimeout(timeoutID);
      }
    }
    function cancel(options2) {
      var _ref22 = options2 || {}, _ref2$upcomingOnly = _ref22.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
      clearExistingTimeout();
      cancelled = !upcomingOnly;
    }
    function wrapper() {
      for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
        arguments_[_key] = arguments[_key];
      }
      var self2 = this;
      var elapsed = Date.now() - lastExec;
      if (cancelled) {
        return;
      }
      function exec() {
        lastExec = Date.now();
        callback.apply(self2, arguments_);
      }
      function clear() {
        timeoutID = void 0;
      }
      if (!noLeading && debounceMode && !timeoutID) {
        exec();
      }
      clearExistingTimeout();
      if (debounceMode === void 0 && elapsed > delay2) {
        if (noLeading) {
          lastExec = Date.now();
          if (!noTrailing) {
            timeoutID = setTimeout(debounceMode ? clear : exec, delay2);
          }
        } else {
          exec();
        }
      } else if (noTrailing !== true) {
        timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay2 - elapsed : delay2);
      }
    }
    wrapper.cancel = cancel;
    return wrapper;
  }
  function debounce$1(delay2, callback, options) {
    var _ref4 = {}, _ref$atBegin = _ref4.atBegin, atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;
    return throttle$1(delay2, callback, {
      debounceMode: atBegin !== false
    });
  }
  const genCheckboxStyle = (token2) => {
    const {
      checkboxCls,
      checkboxSize,
      lineWidth
    } = token2;
    const wrapperCls = `${checkboxCls}-wrapper`;
    return [
{
[`${checkboxCls}-group`]: {
          ...resetComponent(token2),
          display: "inline-flex",
          flexWrap: "wrap",
          columnGap: token2.marginXS,
[`> ${token2.antCls}-row`]: {
            flex: 1
          }
        },
[wrapperCls]: {
          ...resetComponent(token2),
          display: "inline-flex",
          alignItems: "baseline",
          cursor: "pointer",
"&:after": {
            display: "inline-block",
            width: 0,
            overflow: "hidden",
            content: "'\\a0'"
          },
[`& + ${wrapperCls}`]: {
            marginInlineStart: 0
          },
          [`&${wrapperCls}-in-form-item`]: {
            'input[type="checkbox"]': {
              width: 14,
height: 14
}
          }
        },
[checkboxCls]: {
          ...resetComponent(token2),
          position: "relative",
          whiteSpace: "nowrap",
          lineHeight: 1,
          cursor: "pointer",

alignSelf: "center",
boxSizing: "border-box",
          display: "block",
          width: checkboxSize,
          height: checkboxSize,
          direction: "ltr",
          backgroundColor: token2.colorBgContainer,
          border: `${unit$1(lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: token2.borderRadiusSM,
          borderCollapse: "separate",
          transition: `all ${token2.motionDurationSlow}`,
          ...genNoMotionStyle(),
"&:after": {
            boxSizing: "border-box",
            position: "absolute",
            top: `calc(${checkboxSize} / 2 - ${lineWidth})`,
            insetInlineStart: `calc(${checkboxSize} / 4 - ${lineWidth})`,
            display: "table",
            width: token2.calc(checkboxSize).div(14).mul(5).equal(),
            height: token2.calc(checkboxSize).div(14).mul(8).equal(),
            border: `${unit$1(token2.lineWidthBold)} solid ${token2.colorWhite}`,
            borderTop: 0,
            borderInlineStart: 0,
            transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
            opacity: 0,
            content: '""',
            transition: `all ${token2.motionDurationFast} ${token2.motionEaseInBack}, opacity ${token2.motionDurationFast}`,
            ...genNoMotionStyle()
          },
[`${checkboxCls}-input`]: {
            position: "absolute",


inset: `calc(-1 * (${lineWidth}))`,
            zIndex: 1,
            cursor: "pointer",
            opacity: 0,
            margin: 0
          },
[`&:has(${checkboxCls}-input:focus-visible)`]: genFocusOutline(token2),
"& + span": {
            paddingInlineStart: token2.paddingXS,
            paddingInlineEnd: token2.paddingXS
          }
        }
      },
{
[`
        ${wrapperCls}:not(${wrapperCls}-disabled),
        ${checkboxCls}:not(${checkboxCls}-disabled)
      `]: {
          [`&:hover ${checkboxCls}`]: {
            borderColor: token2.colorPrimary
          }
        },
        [`${wrapperCls}:not(${wrapperCls}-disabled)`]: {
          [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled)`]: {
            backgroundColor: token2.colorPrimaryHover,
            borderColor: "transparent"
          }
        }
      },
{
[`${checkboxCls}-checked`]: {
          backgroundColor: token2.colorPrimary,
          borderColor: token2.colorPrimary,
          "&:after": {
            opacity: 1,
            transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
            transition: `all ${token2.motionDurationMid} ${token2.motionEaseOutBack} ${token2.motionDurationFast}`,
            ...genNoMotionStyle()
          },
[`&:not(${checkboxCls}-disabled):hover`]: {
            backgroundColor: token2.colorPrimaryHover,
            borderColor: "transparent"
          }
        }
      },
{
        [checkboxCls]: {
          "&-indeterminate": {
            backgroundColor: token2.colorBgContainer,
            borderColor: token2.colorBorder,
            "&:after": {
              top: "50%",
              insetInlineStart: "50%",
              width: token2.calc(token2.fontSizeLG).div(2).equal(),
              height: token2.calc(token2.fontSizeLG).div(2).equal(),
              backgroundColor: token2.colorPrimary,
              border: 0,
              transform: "translate(-50%, -50%) scale(1)",
              opacity: 1,
              content: '""'
            },
"&:hover": {
              backgroundColor: token2.colorBgContainer,
              borderColor: token2.colorPrimary
            }
          }
        }
      },
{
[`${wrapperCls}-disabled`]: {
          cursor: "not-allowed"
        },
[`${checkboxCls}-disabled`]: {
[`&, ${checkboxCls}-input`]: {
            cursor: "not-allowed",

pointerEvents: "none"
          },
background: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          "&:after": {
            borderColor: token2.colorTextDisabled
          },
          "& + span": {
            color: token2.colorTextDisabled
          },
          [`&${checkboxCls}-indeterminate::after`]: {
            background: token2.colorTextDisabled
          }
        }
      }
    ];
  };
  function getStyle(prefixCls, token2) {
    const checkboxToken = merge$1(token2, {
      checkboxCls: `.${prefixCls}`,
      checkboxSize: token2.controlInteractiveSize
    });
    return genCheckboxStyle(checkboxToken);
  }
  const useStyle$k = genStyleHooks("Checkbox", (token2, {
    prefixCls
  }) => [getStyle(prefixCls, token2)]);
  const GroupContext$1 = React.createContext(null);
  const InternalCheckbox = (props, ref2) => {
    const {
      prefixCls: customizePrefixCls,
      children,
      indeterminate = false,
      onMouseEnter,
      onMouseLeave,
      skipGroup = false,
      disabled,
rootClassName,
      className,
      style: style2,
      classNames,
      styles,
name,
value,
checked,
      defaultChecked,
      onChange,
      ...restProps
    } = props;
    const {
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("checkbox");
    const checkboxGroup = reactExports.useContext(GroupContext$1);
    const {
      isFormItemInput
    } = reactExports.useContext(FormItemInputContext);
    const contextDisabled = reactExports.useContext(DisabledContext);
    const mergedDisabled = (checkboxGroup?.disabled || disabled) ?? contextDisabled;
    const [innerChecked, setInnerChecked] = useControlledState(defaultChecked, checked);
    let mergedChecked = innerChecked;
    const onInternalChange = useEvent$1((event) => {
      setInnerChecked(event.target.checked);
      onChange?.(event);
      if (!skipGroup && checkboxGroup?.toggleOption) {
        checkboxGroup.toggleOption({
          label: children,
          value
        });
      }
    });
    if (checkboxGroup && !skipGroup) {
      mergedChecked = checkboxGroup.value.includes(value);
    }
    const checkboxRef = reactExports.useRef(null);
    const mergedRef = useComposeRef(ref2, checkboxRef);
    reactExports.useEffect(() => {
      if (skipGroup || !checkboxGroup) {
        return;
      }
      checkboxGroup.registerValue(value);
      return () => {
        checkboxGroup.cancelValue(value);
      };
    }, [value, skipGroup]);
    reactExports.useEffect(() => {
      if (checkboxRef.current?.input) {
        checkboxRef.current.input.indeterminate = indeterminate;
      }
    }, [indeterminate]);
    const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$k(prefixCls, rootCls);
    const checkboxProps = {
      ...restProps
    };
    const mergedProps = {
      ...props,
      indeterminate,
      disabled: mergedDisabled,
      checked: mergedChecked
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const classString = clsx(`${prefixCls}-wrapper`, {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-wrapper-checked`]: mergedChecked,
      [`${prefixCls}-wrapper-disabled`]: mergedDisabled,
      [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput
    }, contextClassName, className, mergedClassNames.root, rootClassName, cssVarCls, rootCls, hashId);
    const checkboxClass = clsx(mergedClassNames.icon, {
      [`${prefixCls}-indeterminate`]: indeterminate
    }, TARGET_CLS, hashId);
    const [onLabelClick, onInputClick] = useBubbleLock(checkboxProps.onClick);
    return reactExports.createElement(Wave, {
      component: "Checkbox",
      disabled: mergedDisabled
    }, reactExports.createElement("label", {
      className: classString,
      style: {
        ...mergedStyles.root,
        ...contextStyle,
        ...style2
      },
      onMouseEnter,
      onMouseLeave,
      onClick: onLabelClick
    }, reactExports.createElement(Checkbox$2, {
      ...checkboxProps,
      name: !skipGroup && checkboxGroup ? checkboxGroup.name : name,
      checked: mergedChecked,
      onClick: onInputClick,
      onChange: onInternalChange,
      prefixCls,
      className: checkboxClass,
      style: mergedStyles.icon,
      disabled: mergedDisabled,
      ref: mergedRef,
      value
    }), isNonNullable(children) && reactExports.createElement("span", {
      className: clsx(`${prefixCls}-label`, mergedClassNames.label),
      style: mergedStyles.label
    }, children)));
  };
  const Checkbox$1 = reactExports.forwardRef(InternalCheckbox);
  const CheckboxGroup = reactExports.forwardRef((props, ref2) => {
    const {
      defaultValue: defaultValue2,
      children,
      options = [],
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style: style2,
      onChange,
      role = "group",
      ...restProps
    } = props;
    const {
      getPrefixCls,
      direction
    } = reactExports.useContext(ConfigContext);
    const [value, setValue] = reactExports.useState(restProps.value || defaultValue2 || []);
    const [registeredValues, setRegisteredValues] = reactExports.useState([]);
    reactExports.useEffect(() => {
      if ("value" in restProps) {
        setValue(restProps.value || []);
      }
    }, [restProps.value]);
    const memoizedOptions = reactExports.useMemo(() => options.map((option) => {
      if (typeof option === "string" || typeof option === "number") {
        return {
          label: option,
          value: option
        };
      }
      return option;
    }), [options]);
    const cancelValue = (val) => {
      setRegisteredValues((prevValues) => prevValues.filter((v) => v !== val));
    };
    const registerValue = (val) => {
      setRegisteredValues((prevValues) => [].concat(_toConsumableArray(prevValues), [val]));
    };
    const toggleOption = (option) => {
      const optionIndex = value.indexOf(option.value);
      const newValue = _toConsumableArray(value);
      if (optionIndex === -1) {
        newValue.push(option.value);
      } else {
        newValue.splice(optionIndex, 1);
      }
      if (!("value" in restProps)) {
        setValue(newValue);
      }
      onChange?.(newValue.filter((val) => registeredValues.includes(val)).sort((a2, b) => {
        const indexA = memoizedOptions.findIndex((opt) => opt.value === a2);
        const indexB = memoizedOptions.findIndex((opt) => opt.value === b);
        return indexA - indexB;
      }));
    };
    const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
    const groupPrefixCls = `${prefixCls}-group`;
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$k(prefixCls, rootCls);
    const domProps = omit(restProps, ["value", "disabled"]);
    const childrenNode = options.length ? memoizedOptions.map((option) => reactExports.createElement(Checkbox$1, {
      prefixCls,
      key: option.value.toString(),
      disabled: "disabled" in option ? option.disabled : restProps.disabled,
      value: option.value,
      checked: value.includes(option.value),
      onChange: option.onChange,
      className: clsx(`${groupPrefixCls}-item`, option.className),
      style: option.style,
      title: option.title,
      id: option.id,
      required: option.required
    }, option.label)) : children;
    const memoizedContext = reactExports.useMemo(() => ({
      toggleOption,
      value,
      disabled: restProps.disabled,
      name: restProps.name,
registerValue,
      cancelValue
    }), [toggleOption, value, restProps.disabled, restProps.name, registerValue, cancelValue]);
    const classString = clsx(groupPrefixCls, {
      [`${groupPrefixCls}-rtl`]: direction === "rtl"
    }, className, rootClassName, cssVarCls, rootCls, hashId);
    return reactExports.createElement("div", {
      className: classString,
      style: style2,
      role,
      ...domProps,
      ref: ref2
    }, reactExports.createElement(GroupContext$1.Provider, {
      value: memoizedContext
    }, childrenNode));
  });
  const Checkbox = Checkbox$1;
  Checkbox.Group = CheckboxGroup;
  Checkbox.__ANT_CHECKBOX = true;
  const genSizeDividerStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: {
        "&-horizontal": {
          [`&${componentCls}`]: {
            "&-sm": {
              marginBlock: token2.marginXS
            },
            "&-md": {
              marginBlock: token2.margin
            }
          }
        }
      }
    };
  };
  const genSharedDividerStyle = (token2) => {
    const {
      componentCls,
      sizePaddingEdgeHorizontal,
      colorSplit,
      lineWidth,
      textPaddingInline,
      orientationMargin,
      verticalMarginInline
    } = token2;
    const railCls = `${componentCls}-rail`;
    return {
      [componentCls]: {
        ...resetComponent(token2),
        borderBlockStart: `${unit$1(lineWidth)} solid ${colorSplit}`,
        [railCls]: {
          borderBlockStart: `${unit$1(lineWidth)} solid ${colorSplit}`
        },
"&-vertical": {
          position: "relative",
          top: "-0.06em",
          display: "inline-block",
          height: "0.9em",
          marginInline: verticalMarginInline,
          marginBlock: 0,
          verticalAlign: "middle",
          borderTop: 0,
          borderInlineStart: `${unit$1(lineWidth)} solid ${colorSplit}`
        },
        "&-horizontal": {
          display: "flex",
          clear: "both",
          width: "100%",
          minWidth: "100%",
margin: `${unit$1(token2.marginLG)} 0`
        },
        [`&-horizontal${componentCls}-with-text`]: {
          display: "flex",
          alignItems: "center",
          margin: `${unit$1(token2.dividerHorizontalWithTextGutterMargin)} 0`,
          color: token2.colorTextHeading,
          fontWeight: 500,
          fontSize: token2.fontSizeLG,
          whiteSpace: "nowrap",
          textAlign: "center",
          borderBlockStart: `0 ${colorSplit}`,
          [`${railCls}-start, ${railCls}-end`]: {
            width: "50%",
borderBlockStartColor: "inherit",
            borderBlockEnd: 0,
            content: "''"
          }
        },
        [`&-horizontal${componentCls}-with-text-start`]: {
          [`${railCls}-start`]: {
            width: `calc(${orientationMargin} * 100%)`
          },
          [`${railCls}-end`]: {
            width: `calc(100% - ${orientationMargin} * 100%)`
          }
        },
        [`&-horizontal${componentCls}-with-text-end`]: {
          [`${railCls}-start`]: {
            width: `calc(100% - ${orientationMargin} * 100%)`
          },
          [`${railCls}-end`]: {
            width: `calc(${orientationMargin} * 100%)`
          }
        },
        [`${componentCls}-inner-text`]: {
          display: "inline-block",
          paddingBlock: 0,
          paddingInline: textPaddingInline
        },
        "&-dashed": {
          background: "none",
          borderColor: colorSplit,
          borderStyle: "dashed",
          borderWidth: `${unit$1(lineWidth)} 0 0`,
          [railCls]: {
            borderBlockStart: `${unit$1(lineWidth)} dashed ${colorSplit}`
          }
        },
        [`&-horizontal${componentCls}-with-text${componentCls}-dashed`]: {
          [`${railCls}-start, ${railCls}-end`]: {
            borderStyle: "dashed none none"
          }
        },
        [`&-vertical${componentCls}-dashed`]: {
          borderInlineStartWidth: lineWidth,
          borderInlineEnd: 0,
          borderBlockStart: 0,
          borderBlockEnd: 0
        },
        "&-dotted": {
          background: "none",
          borderColor: colorSplit,
          borderStyle: "dotted",
          borderWidth: `${unit$1(lineWidth)} 0 0`,
          [railCls]: {
            borderBlockStart: `${unit$1(lineWidth)} dotted ${colorSplit}`
          }
        },
        [`&-horizontal${componentCls}-with-text${componentCls}-dotted`]: {
          "&::before, &::after": {
            borderStyle: "dotted none none"
          }
        },
        [`&-vertical${componentCls}-dotted`]: {
          borderInlineStartWidth: lineWidth,
          borderInlineEnd: 0,
          borderBlockStart: 0,
          borderBlockEnd: 0
        },
        [`&-plain${componentCls}-with-text`]: {
          color: token2.colorText,
          fontWeight: "normal",
          fontSize: token2.fontSize
        },
        [`&-horizontal${componentCls}-with-text-start${componentCls}-no-default-orientation-margin-start`]: {
          [`${railCls}-start`]: {
            width: 0
          },
          [`${railCls}-end`]: {
            width: "100%"
          },
          [`${componentCls}-inner-text`]: {
            paddingInlineStart: sizePaddingEdgeHorizontal
          }
        },
        [`&-horizontal${componentCls}-with-text-end${componentCls}-no-default-orientation-margin-end`]: {
          [`${railCls}-start`]: {
            width: "100%"
          },
          [`${railCls}-end`]: {
            width: 0
          },
          [`${componentCls}-inner-text`]: {
            paddingInlineEnd: sizePaddingEdgeHorizontal
          }
        }
      }
    };
  };
  const prepareComponentToken$c = (token2) => ({
    textPaddingInline: "1em",
    orientationMargin: 0.05,
    verticalMarginInline: token2.marginXS
  });
  const useStyle$j = genStyleHooks("Divider", (token2) => {
    const dividerToken = merge$1(token2, {
      dividerHorizontalWithTextGutterMargin: token2.margin,
      sizePaddingEdgeHorizontal: 0
    });
    return [genSharedDividerStyle(dividerToken), genSizeDividerStyle(dividerToken)];
  }, prepareComponentToken$c, {
    unitless: {
      orientationMargin: true
    }
  });
  const titlePlacementList = ["left", "right", "center", "start", "end"];
  const sizeClassNameMap = {
    small: "sm",
    middle: "md"
  };
  const Divider = (props) => {
    const {
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("divider");
    const {
      prefixCls: customizePrefixCls,
      type: type4,
      orientation,
      vertical,
      titlePlacement,
      orientationMargin,
      className,
      rootClassName,
      children,
      dashed,
      variant = "solid",
      plain,
      style: style2,
      size: customSize,
      classNames,
      styles,
      ...restProps
    } = props;
    const prefixCls = getPrefixCls("divider", customizePrefixCls);
    const railCls = `${prefixCls}-rail`;
    const [hashId, cssVarCls] = useStyle$j(prefixCls);
    const sizeFullName = useSize(customSize);
    const sizeCls = sizeClassNameMap[sizeFullName];
    const hasChildren = !!children;
    const validTitlePlacement = titlePlacementList.includes(orientation || "");
    const mergedTitlePlacement = reactExports.useMemo(() => {
      const placement = titlePlacement ?? (validTitlePlacement ? orientation : "center");
      if (placement === "left") {
        return direction === "rtl" ? "end" : "start";
      }
      if (placement === "right") {
        return direction === "rtl" ? "start" : "end";
      }
      return placement;
    }, [direction, orientation, titlePlacement, validTitlePlacement]);
    const hasMarginStart = mergedTitlePlacement === "start" && orientationMargin != null;
    const hasMarginEnd = mergedTitlePlacement === "end" && orientationMargin != null;
    const [mergedOrientation, mergedVertical] = useOrientation(orientation, vertical, type4);
    const mergedProps = {
      ...props,
      orientation: mergedOrientation,
      titlePlacement: mergedTitlePlacement,
      size: sizeFullName
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const classString = clsx(prefixCls, contextClassName, hashId, cssVarCls, `${prefixCls}-${mergedOrientation}`, {
      [`${prefixCls}-with-text`]: hasChildren,
      [`${prefixCls}-with-text-${mergedTitlePlacement}`]: hasChildren,
      [`${prefixCls}-dashed`]: !!dashed,
      [`${prefixCls}-${variant}`]: variant !== "solid",
      [`${prefixCls}-plain`]: !!plain,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-no-default-orientation-margin-start`]: hasMarginStart,
      [`${prefixCls}-no-default-orientation-margin-end`]: hasMarginEnd,
      [`${prefixCls}-${sizeCls}`]: !!sizeCls,
      [railCls]: !children,
      [mergedClassNames.rail]: mergedClassNames.rail && !children
    }, className, rootClassName, mergedClassNames.root);
    const memoizedPlacementMargin = reactExports.useMemo(() => {
      if (typeof orientationMargin === "number") {
        return orientationMargin;
      }
      if (/^\d+$/.test(orientationMargin)) {
        return Number(orientationMargin);
      }
      return orientationMargin;
    }, [orientationMargin]);
    const innerStyle = {
      marginInlineStart: hasMarginStart ? memoizedPlacementMargin : void 0,
      marginInlineEnd: hasMarginEnd ? memoizedPlacementMargin : void 0
    };
    return reactExports.createElement("div", {
      className: classString,
      style: {
        ...contextStyle,
        ...mergedStyles.root,
        ...children ? {} : mergedStyles.rail,
        ...style2
      },
      ...restProps,
      role: "separator"
    }, children && !mergedVertical && reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("div", {
      className: clsx(railCls, `${railCls}-start`, mergedClassNames.rail),
      style: mergedStyles.rail
    }), reactExports.createElement("span", {
      className: clsx(`${prefixCls}-inner-text`, mergedClassNames.content),
      style: {
        ...innerStyle,
        ...mergedStyles.content
      }
    }, children), reactExports.createElement("div", {
      className: clsx(railCls, `${railCls}-end`, mergedClassNames.rail),
      style: mergedStyles.rail
    })));
  };
  const calcThumbStyle = (targetElement, vertical) => {
    if (!targetElement) return null;
    const style2 = {
      left: targetElement.offsetLeft,
      right: targetElement.parentElement.clientWidth - targetElement.clientWidth - targetElement.offsetLeft,
      width: targetElement.clientWidth,
      top: targetElement.offsetTop,
      bottom: targetElement.parentElement.clientHeight - targetElement.clientHeight - targetElement.offsetTop,
      height: targetElement.clientHeight
    };
    if (vertical) {
      return {
        left: 0,
        right: 0,
        width: 0,
        top: style2.top,
        bottom: style2.bottom,
        height: style2.height
      };
    }
    return {
      left: style2.left,
      right: style2.right,
      width: style2.width,
      top: 0,
      bottom: 0,
      height: 0
    };
  };
  const toPX = (value) => value !== void 0 ? `${value}px` : void 0;
  function MotionThumb(props) {
    const {
      prefixCls,
      containerRef,
      value,
      getValueIndex,
      motionName,
      onMotionStart,
      onMotionEnd,
      direction,
      vertical = false
    } = props;
    const thumbRef = reactExports.useRef(null);
    const [prevValue, setPrevValue] = reactExports.useState(value);
    const findValueElement = (val) => {
      const index = getValueIndex(val);
      const ele = containerRef.current?.querySelectorAll(`.${prefixCls}-item`)[index];
      return ele?.offsetParent && ele;
    };
    const [prevStyle, setPrevStyle] = reactExports.useState(null);
    const [nextStyle, setNextStyle] = reactExports.useState(null);
    useLayoutEffect(() => {
      if (prevValue !== value) {
        const prev2 = findValueElement(prevValue);
        const next2 = findValueElement(value);
        const calcPrevStyle = calcThumbStyle(prev2, vertical);
        const calcNextStyle = calcThumbStyle(next2, vertical);
        setPrevValue(value);
        setPrevStyle(calcPrevStyle);
        setNextStyle(calcNextStyle);
        if (prev2 && next2) {
          onMotionStart();
        } else {
          onMotionEnd();
        }
      }
    }, [value]);
    const thumbStart = reactExports.useMemo(() => {
      if (vertical) {
        return toPX(prevStyle?.top ?? 0);
      }
      if (direction === "rtl") {
        return toPX(-prevStyle?.right);
      }
      return toPX(prevStyle?.left);
    }, [vertical, direction, prevStyle]);
    const thumbActive = reactExports.useMemo(() => {
      if (vertical) {
        return toPX(nextStyle?.top ?? 0);
      }
      if (direction === "rtl") {
        return toPX(-nextStyle?.right);
      }
      return toPX(nextStyle?.left);
    }, [vertical, direction, nextStyle]);
    const onAppearStart = () => {
      if (vertical) {
        return {
          transform: "translateY(var(--thumb-start-top))",
          height: "var(--thumb-start-height)"
        };
      }
      return {
        transform: "translateX(var(--thumb-start-left))",
        width: "var(--thumb-start-width)"
      };
    };
    const onAppearActive = () => {
      if (vertical) {
        return {
          transform: "translateY(var(--thumb-active-top))",
          height: "var(--thumb-active-height)"
        };
      }
      return {
        transform: "translateX(var(--thumb-active-left))",
        width: "var(--thumb-active-width)"
      };
    };
    const onVisibleChanged = () => {
      setPrevStyle(null);
      setNextStyle(null);
      onMotionEnd();
    };
    if (!prevStyle || !nextStyle) {
      return null;
    }
    return reactExports.createElement(CSSMotion, {
      visible: true,
      motionName,
      motionAppear: true,
      onAppearStart,
      onAppearActive,
      onVisibleChanged
    }, ({
      className: motionClassName,
      style: motionStyle
    }, ref2) => {
      const mergedStyle = {
        ...motionStyle,
        "--thumb-start-left": thumbStart,
        "--thumb-start-width": toPX(prevStyle?.width),
        "--thumb-active-left": thumbActive,
        "--thumb-active-width": toPX(nextStyle?.width),
        "--thumb-start-top": thumbStart,
        "--thumb-start-height": toPX(prevStyle?.height),
        "--thumb-active-top": thumbActive,
        "--thumb-active-height": toPX(nextStyle?.height)
      };
      const motionProps = {
        ref: composeRef(thumbRef, ref2),
        style: mergedStyle,
        className: clsx(`${prefixCls}-thumb`, motionClassName)
      };
      return reactExports.createElement("div", motionProps);
    });
  }
  function getValidTitle(option) {
    if (typeof option.title !== "undefined") {
      return option.title;
    }
    if (typeof option.label !== "object") {
      return option.label?.toString();
    }
  }
  function normalizeOptions(options) {
    return options.map((option) => {
      if (typeof option === "object" && option !== null) {
        const validTitle = getValidTitle(option);
        return {
          ...option,
          title: validTitle
        };
      }
      return {
        label: option?.toString(),
        title: option?.toString(),
        value: option
      };
    });
  }
  const InternalSegmentedOption = ({
    prefixCls,
    className,
    style: style2,
    styles,
    classNames: segmentedClassNames,
    data: data2,
    disabled,
    checked,
    label,
    title,
    value,
    name,
    onChange,
    onFocus,
    onBlur,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    itemRender = (node2) => node2
  }) => {
    const handleChange = (event) => {
      if (disabled) {
        return;
      }
      onChange(event, value);
    };
    const itemContent = reactExports.createElement("label", {
      className: clsx(className, {
        [`${prefixCls}-item-disabled`]: disabled
      }),
      style: style2,
      onMouseDown
    }, reactExports.createElement("input", {
      name,
      className: `${prefixCls}-item-input`,
      type: "radio",
      disabled,
      checked,
      onChange: handleChange,
      onFocus,
      onBlur,
      onKeyDown,
      onKeyUp
    }), reactExports.createElement("div", {
      className: clsx(`${prefixCls}-item-label`, segmentedClassNames?.label),
      title,
      style: styles?.label
    }, label));
    return itemRender(itemContent, {
      item: data2
    });
  };
  const Segmented$1 = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls = "rc-segmented",
      direction,
      vertical,
      options = [],
      disabled,
      defaultValue: defaultValue2,
      value,
      name,
      onChange,
      className = "",
      style: style2,
      styles,
      classNames: segmentedClassNames,
      motionName = "thumb-motion",
      itemRender,
      ...restProps
    } = props;
    const containerRef = reactExports.useRef(null);
    const mergedRef = reactExports.useMemo(() => composeRef(containerRef, ref2), [containerRef, ref2]);
    const segmentedOptions = reactExports.useMemo(() => {
      return normalizeOptions(options);
    }, [options]);
    const [rawValue, setRawValue] = useControlledState(defaultValue2 ?? segmentedOptions[0]?.value, value);
    const [thumbShow, setThumbShow] = reactExports.useState(false);
    const handleChange = (event, val) => {
      setRawValue(val);
      onChange?.(val);
    };
    const divProps = omit(restProps, ["children"]);
    const [isKeyboard, setIsKeyboard] = reactExports.useState(false);
    const [isFocused, setIsFocused] = reactExports.useState(false);
    const handleFocus = () => {
      setIsFocused(true);
    };
    const handleBlur = () => {
      setIsFocused(false);
    };
    const handleMouseDown = () => {
      setIsKeyboard(false);
    };
    const handleKeyUp = (event) => {
      if (event.key === "Tab") {
        setIsKeyboard(true);
      }
    };
    const onOffset = (offset2) => {
      const currentIndex = segmentedOptions.findIndex((option) => option.value === rawValue);
      const total = segmentedOptions.length;
      const nextIndex = (currentIndex + offset2 + total) % total;
      const nextOption = segmentedOptions[nextIndex];
      if (nextOption) {
        setRawValue(nextOption.value);
        onChange?.(nextOption.value);
      }
    };
    const handleKeyDown = (event) => {
      switch (event.key) {
        case "ArrowLeft":
        case "ArrowUp":
          onOffset(-1);
          break;
        case "ArrowRight":
        case "ArrowDown":
          onOffset(1);
          break;
      }
    };
    const renderOption = (segmentedOption) => {
      const {
        value: optionValue,
        disabled: optionDisabled
      } = segmentedOption;
      return reactExports.createElement(InternalSegmentedOption, _extends$15({}, segmentedOption, {
        name,
        data: segmentedOption,
        itemRender,
        key: optionValue,
        prefixCls,
        className: clsx(segmentedOption.className, `${prefixCls}-item`, segmentedClassNames?.item, {
          [`${prefixCls}-item-selected`]: optionValue === rawValue && !thumbShow,
          [`${prefixCls}-item-focused`]: isFocused && isKeyboard && optionValue === rawValue
        }),
        style: styles?.item,
        classNames: segmentedClassNames,
        styles,
        checked: optionValue === rawValue,
        onChange: handleChange,
        onFocus: handleFocus,
        onBlur: handleBlur,
        onKeyDown: handleKeyDown,
        onKeyUp: handleKeyUp,
        onMouseDown: handleMouseDown,
        disabled: !!disabled || !!optionDisabled
      }));
    };
    return reactExports.createElement("div", _extends$15({
      role: "radiogroup",
      "aria-label": "segmented control",
      tabIndex: disabled ? void 0 : 0,
      "aria-orientation": vertical ? "vertical" : "horizontal",
      style: style2
    }, divProps, {
      className: clsx(prefixCls, {
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-disabled`]: disabled,
        [`${prefixCls}-vertical`]: vertical
      }, className),
      ref: mergedRef
    }), reactExports.createElement("div", {
      className: `${prefixCls}-group`
    }, reactExports.createElement(MotionThumb, {
      vertical,
      prefixCls,
      value: rawValue,
      containerRef,
      motionName: `${prefixCls}-${motionName}`,
      direction,
      getValueIndex: (val) => segmentedOptions.findIndex((n2) => n2.value === val),
      onMotionStart: () => {
        setThumbShow(true);
      },
      onMotionEnd: () => {
        setThumbShow(false);
      }
    }), segmentedOptions.map(renderOption)));
  });
  const TypedSegmented = Segmented$1;
  function getItemDisabledStyle(cls, token2) {
    return {
      [`${cls}, ${cls}:hover, ${cls}:focus`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed"
      }
    };
  }
  const getItemSelectedStyle = (token2) => {
    return {
      background: token2.itemSelectedBg,
      boxShadow: token2.boxShadowTertiary
    };
  };
  const segmentedTextEllipsisCss = {
    overflow: "hidden",
...textEllipsis
  };
  const genSegmentedStyle = (token2) => {
    const {
      componentCls,
      motionDurationSlow,
      motionEaseInOut,
      motionDurationMid
    } = token2;
    const labelHeight = token2.calc(token2.controlHeight).sub(token2.calc(token2.trackPadding).mul(2)).equal();
    const labelHeightLG = token2.calc(token2.controlHeightLG).sub(token2.calc(token2.trackPadding).mul(2)).equal();
    const labelHeightSM = token2.calc(token2.controlHeightSM).sub(token2.calc(token2.trackPadding).mul(2)).equal();
    return {
      [componentCls]: {
        ...resetComponent(token2),
        display: "inline-block",
        padding: token2.trackPadding,
        color: token2.itemColor,
        background: token2.trackBg,
        borderRadius: token2.borderRadius,
        transition: `all ${motionDurationMid}`,
        ...genFocusStyle(token2),
        [`${componentCls}-group`]: {
          position: "relative",
          display: "flex",
          alignItems: "stretch",
          justifyItems: "flex-start",
          flexDirection: "row",
          width: "100%"
        },
[`&${componentCls}-rtl`]: {
          direction: "rtl"
        },
        [`&${componentCls}-vertical`]: {
          [`${componentCls}-group`]: {
            flexDirection: "column"
          },
          [`${componentCls}-thumb`]: {
            width: "100%",
            height: 0,
            padding: `0 ${unit$1(token2.paddingXXS)}`
          }
        },
[`&${componentCls}-block`]: {
          display: "flex"
        },
        [`&${componentCls}-block ${componentCls}-item`]: {
          flex: 1,
          minWidth: 0
        },
[`${componentCls}-item`]: {
          position: "relative",
          textAlign: "center",
          cursor: "pointer",
          transition: `color ${motionDurationMid}`,
          borderRadius: token2.borderRadiusSM,

transform: "translateZ(0)",
          "&-selected": {
            ...getItemSelectedStyle(token2),
            color: token2.itemSelectedColor
          },
          "&-focused": genFocusOutline(token2),
          "&::after": {
            content: '""',
            position: "absolute",
            zIndex: -1,
            width: "100%",
            height: "100%",
            top: 0,
            insetInlineStart: 0,
            borderRadius: "inherit",
            opacity: 0,

pointerEvents: "none",
            transition: ["opacity", "background-color"].map((prop) => `${prop} ${motionDurationMid}`).join(", ")
          },
          [`&:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)`]: {
            "&:hover, &:active": {
              color: token2.itemHoverColor
            },
            "&:hover::after": {
              opacity: 1,
              backgroundColor: token2.itemHoverBg
            },
            "&:active::after": {
              opacity: 1,
              backgroundColor: token2.itemActiveBg
            }
          },
          "&-label": {
            minHeight: labelHeight,
            lineHeight: unit$1(labelHeight),
            padding: `0 ${unit$1(token2.segmentedPaddingHorizontal)}`,
            ...segmentedTextEllipsisCss
          },
"&-icon + *": {
            marginInlineStart: token2.calc(token2.marginSM).div(2).equal()
          },
          "&-input": {
            position: "absolute",
            insetBlockStart: 0,
            insetInlineStart: 0,
            width: 0,
            height: 0,
            opacity: 0,
            pointerEvents: "none"
          }
        },
[`${componentCls}-thumb`]: {
          ...getItemSelectedStyle(token2),
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: 0,
          height: "100%",
          padding: `${unit$1(token2.paddingXXS)} 0`,
          borderRadius: token2.borderRadiusSM,
          [`& ~ ${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)::after`]: {
            backgroundColor: "transparent"
          }
        },
[`&${componentCls}-lg`]: {
          borderRadius: token2.borderRadiusLG,
          [`${componentCls}-item-label`]: {
            minHeight: labelHeightLG,
            lineHeight: unit$1(labelHeightLG),
            padding: `0 ${unit$1(token2.segmentedPaddingHorizontal)}`,
            fontSize: token2.fontSizeLG
          },
          [`${componentCls}-item, ${componentCls}-thumb`]: {
            borderRadius: token2.borderRadius
          }
        },
        [`&${componentCls}-sm`]: {
          borderRadius: token2.borderRadiusSM,
          [`${componentCls}-item-label`]: {
            minHeight: labelHeightSM,
            lineHeight: unit$1(labelHeightSM),
            padding: `0 ${unit$1(token2.segmentedPaddingHorizontalSM)}`
          },
          [`${componentCls}-item, ${componentCls}-thumb`]: {
            borderRadius: token2.borderRadiusXS
          }
        },
...getItemDisabledStyle(`&-disabled ${componentCls}-item`, token2),
        ...getItemDisabledStyle(`${componentCls}-item-disabled`, token2),
[`${componentCls}-thumb-motion-appear-active`]: {
          willChange: "transform, width",
          transition: [`transform`, `width`].map((prop) => `${prop} ${motionDurationSlow} ${motionEaseInOut}`).join(", ")
        },
        [`&${componentCls}-shape-round`]: {
          borderRadius: 9999,
          [`${componentCls}-item, ${componentCls}-thumb`]: {
            borderRadius: 9999
          }
        }
      }
    };
  };
  const prepareComponentToken$b = (token2) => {
    const {
      colorTextLabel,
      colorText,
      colorFillSecondary,
      colorBgElevated,
      colorFill,
      lineWidthBold,
      colorBgLayout
    } = token2;
    return {
      trackPadding: lineWidthBold,
      trackBg: colorBgLayout,
      itemColor: colorTextLabel,
      itemHoverColor: colorText,
      itemHoverBg: colorFillSecondary,
      itemSelectedBg: colorBgElevated,
      itemActiveBg: colorFill,
      itemSelectedColor: colorText
    };
  };
  const useStyle$i = genStyleHooks("Segmented", (token2) => {
    const {
      lineWidth,
      calc
    } = token2;
    const segmentedToken = merge$1(token2, {
      segmentedPaddingHorizontal: calc(token2.controlPaddingHorizontal).sub(lineWidth).equal(),
      segmentedPaddingHorizontalSM: calc(token2.controlPaddingHorizontalSM).sub(lineWidth).equal()
    });
    return genSegmentedStyle(segmentedToken);
  }, prepareComponentToken$b);
  function isSegmentedLabeledOptionWithIcon(option) {
    return typeof option === "object" && !!option?.icon;
  }
  const InternalSegmented = reactExports.forwardRef((props, ref2) => {
    const defaultName = useId();
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      block,
      options = [],
      size: customSize = "middle",
      style: style2,
      vertical,
      orientation,
      shape = "default",
      name = defaultName,
      styles,
      classNames,
      ...restProps
    } = props;
    const {
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("segmented");
    const mergedProps = {
      ...props,
      options,
      size: customSize,
      shape
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const prefixCls = getPrefixCls("segmented", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$i(prefixCls);
    const mergedSize = useSize(customSize);
    const extendedOptions = reactExports.useMemo(() => options.map((option) => {
      if (isSegmentedLabeledOptionWithIcon(option)) {
        const {
          icon,
          label,
          ...restOption
        } = option;
        return {
          ...restOption,
          label: reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("span", {
            className: clsx(`${prefixCls}-item-icon`, mergedClassNames.icon),
            style: mergedStyles.icon
          }, icon), label && reactExports.createElement("span", null, label))
        };
      }
      return option;
    }), [options, prefixCls, mergedClassNames.icon, mergedStyles.icon]);
    const [, mergedVertical] = useOrientation(orientation, vertical);
    const cls = clsx(className, rootClassName, contextClassName, mergedClassNames.root, {
      [`${prefixCls}-block`]: block,
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-lg`]: mergedSize === "large",
      [`${prefixCls}-vertical`]: mergedVertical,
      [`${prefixCls}-shape-${shape}`]: shape === "round"
    }, hashId, cssVarCls);
    const mergedStyle = {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    };
    const itemRender = (node2, {
      item
    }) => {
      if (!item.tooltip) {
        return node2;
      }
      const tooltipProps = typeof item.tooltip === "object" ? item.tooltip : {
        title: item.tooltip
      };
      return reactExports.createElement(Tooltip, {
        ...tooltipProps
      }, node2);
    };
    return reactExports.createElement(TypedSegmented, {
      ...restProps,
      name,
      className: cls,
      style: mergedStyle,
      classNames: mergedClassNames,
      styles: mergedStyles,
      itemRender,
      options: extendedOptions,
      ref: ref2,
      prefixCls,
      direction,
      vertical: mergedVertical
    });
  });
  const Segmented = InternalSegmented;
  const PanelPickerContext = React.createContext({});
  const PanelPresetsContext = React.createContext({});
  const ColorClear = ({
    prefixCls,
    value,
    onChange,
    className,
    style: style2
  }) => {
    const onClick = () => {
      if (onChange && value && !value.cleared) {
        const hsba = value.toHsb();
        hsba.a = 0;
        const genColor = generateColor(hsba);
        genColor.cleared = true;
        onChange(genColor);
      }
    };
    return React.createElement("div", {
      className: clsx(`${prefixCls}-clear`, className),
      style: style2,
      onClick
    });
  };
  const FORMAT_HEX = "hex";
  const FORMAT_RGB = "rgb";
  const FORMAT_HSB = "hsb";
  var MinusOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M872 474H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h720c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z" } }] }, "name": "minus", "theme": "outlined" };
  function _extends$h() {
    _extends$h = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$h.apply(this, arguments);
  }
  const MinusOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends$h({}, props, {
    ref: ref2,
    icon: MinusOutlined$1
  }));
  const RefIcon$8 = reactExports.forwardRef(MinusOutlined);
  var UpOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M890.5 755.3L537.9 269.2c-12.8-17.6-39-17.6-51.7 0L133.5 755.3A8 8 0 00140 768h75c5.1 0 9.9-2.5 12.9-6.6L512 369.8l284.1 391.6c3 4.1 7.8 6.6 12.9 6.6h75c6.5 0 10.3-7.4 6.5-12.7z" } }] }, "name": "up", "theme": "outlined" };
  function _extends$g() {
    _extends$g = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$g.apply(this, arguments);
  }
  const UpOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends$g({}, props, {
    ref: ref2,
    icon: UpOutlined$1
  }));
  const RefIcon$7 = reactExports.forwardRef(UpOutlined);
  function supportBigInt() {
    return typeof BigInt === "function";
  }
  function isEmpty(value) {
    return !value && value !== 0 && !Number.isNaN(value) || !String(value).trim();
  }
  function trimNumber(numStr) {
    var str = numStr.trim();
    var negative = str.startsWith("-");
    if (negative) {
      str = str.slice(1);
    }
    str = str.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, "");
    if (str.startsWith(".")) {
      str = "0".concat(str);
    }
    var trimStr = str || "0";
    var splitNumber = trimStr.split(".");
    var integerStr = splitNumber[0] || "0";
    var decimalStr = splitNumber[1] || "0";
    if (integerStr === "0" && decimalStr === "0") {
      negative = false;
    }
    var negativeStr = negative ? "-" : "";
    return {
      negative,
      negativeStr,
      trimStr,
      integerStr,
      decimalStr,
      fullStr: "".concat(negativeStr).concat(trimStr)
    };
  }
  function isE(number4) {
    var str = String(number4);
    return !Number.isNaN(Number(str)) && str.includes("e");
  }
  function getNumberPrecision(number4) {
    var numStr = String(number4);
    if (isE(number4)) {
      var precision = Number(numStr.slice(numStr.indexOf("e-") + 2));
      var decimalMatch = numStr.match(/\.(\d+)/);
      if (decimalMatch !== null && decimalMatch !== void 0 && decimalMatch[1]) {
        precision += decimalMatch[1].length;
      }
      return precision;
    }
    return numStr.includes(".") && validateNumber(numStr) ? numStr.length - numStr.indexOf(".") - 1 : 0;
  }
  function num2str(number4) {
    var numStr = String(number4);
    if (isE(number4)) {
      if (number4 > Number.MAX_SAFE_INTEGER) {
        return String(supportBigInt() ? BigInt(number4).toString() : Number.MAX_SAFE_INTEGER);
      }
      if (number4 < Number.MIN_SAFE_INTEGER) {
        return String(supportBigInt() ? BigInt(number4).toString() : Number.MIN_SAFE_INTEGER);
      }
      numStr = number4.toFixed(getNumberPrecision(numStr));
    }
    return trimNumber(numStr).fullStr;
  }
  function validateNumber(num) {
    if (typeof num === "number") {
      return !Number.isNaN(num);
    }
    if (!num) {
      return false;
    }
    return (
/^\s*-?\d+(\.\d+)?\s*$/.test(num) ||
/^\s*-?\d+\.\s*$/.test(num) ||
/^\s*-?\.\d+\s*$/.test(num)
    );
  }
  var BigIntDecimal = (function() {
    function BigIntDecimal2(value) {
      _classCallCheck(this, BigIntDecimal2);
      _defineProperty$1(this, "origin", "");
      _defineProperty$1(this, "negative", void 0);
      _defineProperty$1(this, "integer", void 0);
      _defineProperty$1(this, "decimal", void 0);
      _defineProperty$1(this, "decimalLen", void 0);
      _defineProperty$1(this, "empty", void 0);
      _defineProperty$1(this, "nan", void 0);
      if (isEmpty(value)) {
        this.empty = true;
        return;
      }
      this.origin = String(value);
      if (value === "-" || Number.isNaN(value)) {
        this.nan = true;
        return;
      }
      var mergedValue = value;
      if (isE(mergedValue)) {
        mergedValue = Number(mergedValue);
      }
      mergedValue = typeof mergedValue === "string" ? mergedValue : num2str(mergedValue);
      if (validateNumber(mergedValue)) {
        var trimRet = trimNumber(mergedValue);
        this.negative = trimRet.negative;
        var numbers = trimRet.trimStr.split(".");
        this.integer = BigInt(numbers[0]);
        var decimalStr = numbers[1] || "0";
        this.decimal = BigInt(decimalStr);
        this.decimalLen = decimalStr.length;
      } else {
        this.nan = true;
      }
    }
    _createClass(BigIntDecimal2, [{
      key: "getMark",
      value: function getMark2() {
        return this.negative ? "-" : "";
      }
    }, {
      key: "getIntegerStr",
      value: function getIntegerStr() {
        return this.integer.toString();
      }
}, {
      key: "getDecimalStr",
      value: function getDecimalStr() {
        return this.decimal.toString().padStart(this.decimalLen, "0");
      }
}, {
      key: "alignDecimal",
      value: function alignDecimal(decimalLength) {
        var str = "".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr().padEnd(decimalLength, "0"));
        return BigInt(str);
      }
    }, {
      key: "negate",
      value: function negate() {
        var clone2 = new BigIntDecimal2(this.toString());
        clone2.negative = !clone2.negative;
        return clone2;
      }
    }, {
      key: "cal",
      value: function cal(offset2, calculator, calDecimalLen) {
        var maxDecimalLength = Math.max(this.getDecimalStr().length, offset2.getDecimalStr().length);
        var myAlignedDecimal = this.alignDecimal(maxDecimalLength);
        var offsetAlignedDecimal = offset2.alignDecimal(maxDecimalLength);
        var valueStr = calculator(myAlignedDecimal, offsetAlignedDecimal).toString();
        var nextDecimalLength = calDecimalLen(maxDecimalLength);
        var _trimNumber = trimNumber(valueStr), negativeStr = _trimNumber.negativeStr, trimStr = _trimNumber.trimStr;
        var hydrateValueStr = "".concat(negativeStr).concat(trimStr.padStart(nextDecimalLength + 1, "0"));
        return new BigIntDecimal2("".concat(hydrateValueStr.slice(0, -nextDecimalLength), ".").concat(hydrateValueStr.slice(-nextDecimalLength)));
      }
    }, {
      key: "add",
      value: function add2(value) {
        if (this.isInvalidate()) {
          return new BigIntDecimal2(value);
        }
        var offset2 = new BigIntDecimal2(value);
        if (offset2.isInvalidate()) {
          return this;
        }
        return this.cal(offset2, function(num1, num2) {
          return num1 + num2;
        }, function(len) {
          return len;
        });
      }
    }, {
      key: "multi",
      value: function multi(value) {
        var target = new BigIntDecimal2(value);
        if (this.isInvalidate() || target.isInvalidate()) {
          return new BigIntDecimal2(NaN);
        }
        return this.cal(target, function(num1, num2) {
          return num1 * num2;
        }, function(len) {
          return len * 2;
        });
      }
    }, {
      key: "isEmpty",
      value: function isEmpty2() {
        return this.empty;
      }
    }, {
      key: "isNaN",
      value: function isNaN2() {
        return this.nan;
      }
    }, {
      key: "isInvalidate",
      value: function isInvalidate() {
        return this.isEmpty() || this.isNaN();
      }
    }, {
      key: "equals",
      value: function equals(target) {
        return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());
      }
    }, {
      key: "lessEquals",
      value: function lessEquals(target) {
        return this.add(target.negate().toString()).toNumber() <= 0;
      }
    }, {
      key: "toNumber",
      value: function toNumber2() {
        if (this.isNaN()) {
          return NaN;
        }
        return Number(this.toString());
      }
    }, {
      key: "toString",
      value: function toString2() {
        var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        if (!safe) {
          return this.origin;
        }
        if (this.isInvalidate()) {
          return "";
        }
        return trimNumber("".concat(this.getMark()).concat(this.getIntegerStr(), ".").concat(this.getDecimalStr())).fullStr;
      }
    }]);
    return BigIntDecimal2;
  })();
  var NumberDecimal = (function() {
    function NumberDecimal2(value) {
      _classCallCheck(this, NumberDecimal2);
      _defineProperty$1(this, "origin", "");
      _defineProperty$1(this, "number", void 0);
      _defineProperty$1(this, "empty", void 0);
      if (isEmpty(value)) {
        this.empty = true;
        return;
      }
      this.origin = String(value);
      this.number = Number(value);
    }
    _createClass(NumberDecimal2, [{
      key: "negate",
      value: function negate() {
        return new NumberDecimal2(-this.toNumber());
      }
    }, {
      key: "add",
      value: function add2(value) {
        if (this.isInvalidate()) {
          return new NumberDecimal2(value);
        }
        var target = Number(value);
        if (Number.isNaN(target)) {
          return this;
        }
        var number4 = this.number + target;
        if (number4 > Number.MAX_SAFE_INTEGER) {
          return new NumberDecimal2(Number.MAX_SAFE_INTEGER);
        }
        if (number4 < Number.MIN_SAFE_INTEGER) {
          return new NumberDecimal2(Number.MIN_SAFE_INTEGER);
        }
        var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
        return new NumberDecimal2(number4.toFixed(maxPrecision));
      }
    }, {
      key: "multi",
      value: function multi(value) {
        var target = Number(value);
        if (this.isInvalidate() || Number.isNaN(target)) {
          return new NumberDecimal2(NaN);
        }
        var number4 = this.number * target;
        if (number4 > Number.MAX_SAFE_INTEGER) {
          return new NumberDecimal2(Number.MAX_SAFE_INTEGER);
        }
        if (number4 < Number.MIN_SAFE_INTEGER) {
          return new NumberDecimal2(Number.MIN_SAFE_INTEGER);
        }
        var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
        return new NumberDecimal2(number4.toFixed(maxPrecision));
      }
    }, {
      key: "isEmpty",
      value: function isEmpty2() {
        return this.empty;
      }
    }, {
      key: "isNaN",
      value: function isNaN2() {
        return Number.isNaN(this.number);
      }
    }, {
      key: "isInvalidate",
      value: function isInvalidate() {
        return this.isEmpty() || this.isNaN();
      }
    }, {
      key: "equals",
      value: function equals(target) {
        return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());
      }
    }, {
      key: "lessEquals",
      value: function lessEquals(target) {
        return this.add(target.negate().toString()).toNumber() <= 0;
      }
    }, {
      key: "toNumber",
      value: function toNumber2() {
        return this.number;
      }
    }, {
      key: "toString",
      value: function toString2() {
        var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        if (!safe) {
          return this.origin;
        }
        if (this.isInvalidate()) {
          return "";
        }
        return num2str(this.number);
      }
    }]);
    return NumberDecimal2;
  })();
  function getMiniDecimal(value) {
    if (supportBigInt()) {
      return new BigIntDecimal(value);
    }
    return new NumberDecimal(value);
  }
  function toFixed(numStr, separatorStr, precision) {
    var cutOnly = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (numStr === "") {
      return "";
    }
    var _trimNumber = trimNumber(numStr), negativeStr = _trimNumber.negativeStr, integerStr = _trimNumber.integerStr, decimalStr = _trimNumber.decimalStr;
    var precisionDecimalStr = "".concat(separatorStr).concat(decimalStr);
    var numberWithoutDecimal = "".concat(negativeStr).concat(integerStr);
    if (precision >= 0) {
      var advancedNum = Number(decimalStr[precision]);
      if (advancedNum >= 5 && !cutOnly) {
        var advancedDecimal = getMiniDecimal(numStr).add("".concat(negativeStr, "0.").concat("0".repeat(precision)).concat(10 - advancedNum));
        return toFixed(advancedDecimal.toString(), separatorStr, precision, cutOnly);
      }
      if (precision === 0) {
        return numberWithoutDecimal;
      }
      return "".concat(numberWithoutDecimal).concat(separatorStr).concat(decimalStr.padEnd(precision, "0").slice(0, precision));
    }
    if (precisionDecimalStr === ".0") {
      return numberWithoutDecimal;
    }
    return "".concat(numberWithoutDecimal).concat(precisionDecimalStr);
  }
  function proxyObject(obj, extendProps) {
    if (typeof Proxy !== "undefined" && obj) {
      return new Proxy(obj, {
        get(target, prop) {
          if (extendProps[prop]) {
            return extendProps[prop];
          }
          const originProp = target[prop];
          return typeof originProp === "function" ? originProp.bind(target) : originProp;
        }
      });
    }
    return obj;
  }
  function useCursor(input, focused) {
    const selectionRef = reactExports.useRef(null);
    function recordCursor() {
      try {
        const {
          selectionStart: start,
          selectionEnd: end,
          value
        } = input;
        const beforeTxt = value.substring(0, start);
        const afterTxt = value.substring(end);
        selectionRef.current = {
          start,
          end,
          value,
          beforeTxt,
          afterTxt
        };
      } catch (e) {
      }
    }
    function restoreCursor() {
      if (input && selectionRef.current && focused) {
        try {
          const {
            value
          } = input;
          const {
            beforeTxt,
            afterTxt,
            start
          } = selectionRef.current;
          let startPos = value.length;
          if (value.startsWith(beforeTxt)) {
            startPos = beforeTxt.length;
          } else if (value.endsWith(afterTxt)) {
            startPos = value.length - selectionRef.current.afterTxt.length;
          } else {
            const beforeLastChar = beforeTxt[start - 1];
            const newIndex = value.indexOf(beforeLastChar, start - 1);
            if (newIndex !== -1) {
              startPos = newIndex + 1;
            }
          }
          input.setSelectionRange(startPos, startPos);
        } catch (e) {
          warningOnce(false, `Something warning of cursor restore. Please fire issue about this: ${e.message}`);
        }
      }
    }
    return [recordCursor, restoreCursor];
  }
  const STEP_INTERVAL = 200;
  const STEP_DELAY = 600;
  function StepHandler({
    prefixCls,
    action: action2,
    children,
    disabled,
    className,
    style: style2,
    onStep
  }) {
    const isUpAction = action2 === "up";
    const stepTimeoutRef = reactExports.useRef();
    const frameIds = reactExports.useRef([]);
    const onStopStep = () => {
      clearTimeout(stepTimeoutRef.current);
    };
    const onStepMouseDown = (e) => {
      e.preventDefault();
      onStopStep();
      onStep(isUpAction, "handler");
      function loopStep() {
        onStep(isUpAction, "handler");
        stepTimeoutRef.current = setTimeout(loopStep, STEP_INTERVAL);
      }
      stepTimeoutRef.current = setTimeout(loopStep, STEP_DELAY);
    };
    reactExports.useEffect(() => () => {
      onStopStep();
      frameIds.current.forEach((id2) => {
        wrapperRaf.cancel(id2);
      });
    }, []);
    const actionClassName = `${prefixCls}-action`;
    const mergedClassName = clsx(actionClassName, `${actionClassName}-${action2}`, {
      [`${actionClassName}-${action2}-disabled`]: disabled
    }, className);
    const safeOnStopStep = () => frameIds.current.push(wrapperRaf(onStopStep));
    return reactExports.createElement("span", {
      unselectable: "on",
      role: "button",
      onMouseUp: safeOnStopStep,
      onMouseLeave: safeOnStopStep,
      onMouseDown: (e) => {
        onStepMouseDown(e);
      },
      "aria-label": isUpAction ? "Increase Value" : "Decrease Value",
      "aria-disabled": disabled,
      className: mergedClassName,
      style: style2
    }, children || reactExports.createElement("span", {
      unselectable: "on",
      className: `${prefixCls}-action-${action2}-inner`
    }));
  }
  function getDecupleSteps(step) {
    const stepStr = typeof step === "number" ? num2str(step) : trimNumber(step).fullStr;
    const hasPoint = stepStr.includes(".");
    if (!hasPoint) {
      return step + "0";
    }
    return trimNumber(stepStr.replace(/(\d)\.(\d)/g, "$1$2.")).fullStr;
  }
  const useFrame = (() => {
    const idRef = reactExports.useRef(0);
    const cleanUp = () => {
      wrapperRaf.cancel(idRef.current);
    };
    reactExports.useEffect(() => cleanUp, []);
    return (callback) => {
      cleanUp();
      idRef.current = wrapperRaf(() => {
        callback();
      });
    };
  });
  function _extends$f() {
    _extends$f = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$f.apply(this, arguments);
  }
  const getDecimalValue = (stringMode, decimalValue) => {
    if (stringMode || decimalValue.isEmpty()) {
      return decimalValue.toString();
    }
    return decimalValue.toNumber();
  };
  const getDecimalIfValidate = (value) => {
    const decimal = getMiniDecimal(value);
    return decimal.isInvalidate() ? null : decimal;
  };
  const InputNumber$1 = reactExports.forwardRef((props, ref2) => {
    const {
      mode = "input",
      prefixCls = "rc-input-number",
      className,
      style: style2,
      classNames,
      styles,
      min,
      max,
      step = 1,
      defaultValue: defaultValue2,
      value,
      disabled,
      readOnly,
      upHandler,
      downHandler,
      keyboard,
      changeOnWheel = false,
      controls = true,
      prefix: prefix2,
      suffix,
      stringMode,
      parser,
      formatter,
      precision,
      decimalSeparator,
      onChange,
      onInput,
      onPressEnter,
      onStep,
onMouseDown,
      onClick,
      onMouseUp,
      onMouseLeave,
      onMouseMove,
      onMouseEnter,
      onMouseOut,
      changeOnBlur = true,
      ...restProps
    } = props;
    const [focus, setFocus] = reactExports.useState(false);
    const userTypingRef = reactExports.useRef(false);
    const compositionRef = reactExports.useRef(false);
    const shiftKeyRef = reactExports.useRef(false);
    const rootRef = reactExports.useRef(null);
    const inputRef = reactExports.useRef(null);
    reactExports.useImperativeHandle(ref2, () => proxyObject(inputRef.current, {
      focus: (option) => {
        triggerFocus(inputRef.current, option);
      },
      blur: () => {
        inputRef.current?.blur();
      },
      nativeElement: rootRef.current
    }));
    const [decimalValue, setDecimalValue] = reactExports.useState(() => getMiniDecimal(value ?? defaultValue2));
    function setUncontrolledDecimalValue(newDecimal) {
      if (value === void 0) {
        setDecimalValue(newDecimal);
      }
    }
    const getPrecision = reactExports.useCallback((numStr, userTyping) => {
      if (userTyping) {
        return void 0;
      }
      if (precision >= 0) {
        return precision;
      }
      return Math.max(getNumberPrecision(numStr), getNumberPrecision(step));
    }, [precision, step]);
    const mergedParser = reactExports.useCallback((num) => {
      const numStr = String(num);
      if (parser) {
        return parser(numStr);
      }
      let parsedStr = numStr;
      if (decimalSeparator) {
        parsedStr = parsedStr.replace(decimalSeparator, ".");
      }
      return parsedStr.replace(/[^\w.-]+/g, "");
    }, [parser, decimalSeparator]);
    const inputValueRef = reactExports.useRef("");
    const mergedFormatter = reactExports.useCallback((number4, userTyping) => {
      if (formatter) {
        return formatter(number4, {
          userTyping,
          input: String(inputValueRef.current)
        });
      }
      let str = typeof number4 === "number" ? num2str(number4) : number4;
      if (!userTyping) {
        const mergedPrecision = getPrecision(str, userTyping);
        if (validateNumber(str) && (decimalSeparator || mergedPrecision >= 0)) {
          const separatorStr = decimalSeparator || ".";
          str = toFixed(str, separatorStr, mergedPrecision);
        }
      }
      return str;
    }, [formatter, getPrecision, decimalSeparator]);
    const [inputValue, setInternalInputValue] = reactExports.useState(() => {
      const initValue = defaultValue2 ?? value;
      if (decimalValue.isInvalidate() && ["string", "number"].includes(typeof initValue)) {
        return Number.isNaN(initValue) ? "" : initValue;
      }
      return mergedFormatter(decimalValue.toString(), false);
    });
    inputValueRef.current = inputValue;
    function setInputValue(newValue, userTyping) {
      setInternalInputValue(mergedFormatter(


newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping),
        userTyping
      ));
    }
    const maxDecimal = reactExports.useMemo(() => getDecimalIfValidate(max), [max, precision]);
    const minDecimal = reactExports.useMemo(() => getDecimalIfValidate(min), [min, precision]);
    const upDisabled = reactExports.useMemo(() => {
      if (!maxDecimal || !decimalValue || decimalValue.isInvalidate()) {
        return false;
      }
      return maxDecimal.lessEquals(decimalValue);
    }, [maxDecimal, decimalValue]);
    const downDisabled = reactExports.useMemo(() => {
      if (!minDecimal || !decimalValue || decimalValue.isInvalidate()) {
        return false;
      }
      return decimalValue.lessEquals(minDecimal);
    }, [minDecimal, decimalValue]);
    const [recordCursor, restoreCursor] = useCursor(inputRef.current, focus);
    const getRangeValue = (target) => {
      if (maxDecimal && !target.lessEquals(maxDecimal)) {
        return maxDecimal;
      }
      if (minDecimal && !minDecimal.lessEquals(target)) {
        return minDecimal;
      }
      return null;
    };
    const isInRange = (target) => !getRangeValue(target);
    const triggerValueUpdate = (newValue, userTyping) => {
      let updateValue = newValue;
      let isRangeValidate = isInRange(updateValue) || updateValue.isEmpty();
      if (!updateValue.isEmpty() && !userTyping) {
        updateValue = getRangeValue(updateValue) || updateValue;
        isRangeValidate = true;
      }
      if (!readOnly && !disabled && isRangeValidate) {
        const numStr = updateValue.toString();
        const mergedPrecision = getPrecision(numStr, userTyping);
        if (mergedPrecision >= 0) {
          updateValue = getMiniDecimal(toFixed(numStr, ".", mergedPrecision));
          if (!isInRange(updateValue)) {
            updateValue = getMiniDecimal(toFixed(numStr, ".", mergedPrecision, true));
          }
        }
        if (!updateValue.equals(decimalValue)) {
          setUncontrolledDecimalValue(updateValue);
          onChange?.(updateValue.isEmpty() ? null : getDecimalValue(stringMode, updateValue));
          if (value === void 0) {
            setInputValue(updateValue, userTyping);
          }
        }
        return updateValue;
      }
      return decimalValue;
    };
    const onNextPromise = useFrame();
    const collectInputValue = (inputStr) => {
      recordCursor();
      inputValueRef.current = inputStr;
      setInternalInputValue(inputStr);
      if (!compositionRef.current) {
        const finalValue = mergedParser(inputStr);
        const finalDecimal = getMiniDecimal(finalValue);
        if (!finalDecimal.isNaN()) {
          triggerValueUpdate(finalDecimal, true);
        }
      }
      onInput?.(inputStr);
      onNextPromise(() => {
        let nextInputStr = inputStr;
        if (!parser) {
          nextInputStr = inputStr.replace(/。/g, ".");
        }
        if (nextInputStr !== inputStr) {
          collectInputValue(nextInputStr);
        }
      });
    };
    const onCompositionStart = () => {
      compositionRef.current = true;
    };
    const onCompositionEnd = () => {
      compositionRef.current = false;
      collectInputValue(inputRef.current.value);
    };
    const onInternalInput = (e) => {
      collectInputValue(e.target.value);
    };
    const onInternalStep = useEvent$1((up, emitter2) => {
      if (up && upDisabled || !up && downDisabled) {
        return;
      }
      userTypingRef.current = false;
      let stepDecimal = getMiniDecimal(shiftKeyRef.current ? getDecupleSteps(step) : step);
      if (!up) {
        stepDecimal = stepDecimal.negate();
      }
      const target = (decimalValue || getMiniDecimal(0)).add(stepDecimal.toString());
      const updatedValue = triggerValueUpdate(target, false);
      onStep?.(getDecimalValue(stringMode, updatedValue), {
        offset: shiftKeyRef.current ? getDecupleSteps(step) : step,
        type: up ? "up" : "down",
        emitter: emitter2
      });
      inputRef.current?.focus();
    });
    const flushInputValue = (userTyping) => {
      const parsedValue = getMiniDecimal(mergedParser(inputValue));
      let formatValue;
      if (!parsedValue.isNaN()) {
        formatValue = triggerValueUpdate(parsedValue, userTyping);
      } else {
        formatValue = triggerValueUpdate(decimalValue, userTyping);
      }
      if (value !== void 0) {
        setInputValue(decimalValue, false);
      } else if (!formatValue.isNaN()) {
        setInputValue(formatValue, false);
      }
    };
    const onBeforeInput = () => {
      userTypingRef.current = true;
    };
    const onKeyDown = (event) => {
      const {
        key,
        shiftKey
      } = event;
      userTypingRef.current = true;
      shiftKeyRef.current = shiftKey;
      if (key === "Enter") {
        if (!compositionRef.current) {
          userTypingRef.current = false;
        }
        flushInputValue(false);
        onPressEnter?.(event);
      }
      if (keyboard === false) {
        return;
      }
      if (!compositionRef.current && ["Up", "ArrowUp", "Down", "ArrowDown"].includes(key)) {
        onInternalStep(key === "Up" || key === "ArrowUp", "keyboard");
        event.preventDefault();
      }
    };
    const onKeyUp = () => {
      userTypingRef.current = false;
      shiftKeyRef.current = false;
    };
    reactExports.useEffect(() => {
      if (changeOnWheel && focus) {
        const onWheel = (event) => {
          onInternalStep(event.deltaY < 0, "wheel");
          event.preventDefault();
        };
        const input = inputRef.current;
        if (input) {
          input.addEventListener("wheel", onWheel, {
            passive: false
          });
          return () => input.removeEventListener("wheel", onWheel);
        }
      }
    });
    const onBlur = () => {
      if (changeOnBlur) {
        flushInputValue(false);
      }
      setFocus(false);
      userTypingRef.current = false;
    };
    const onInternalMouseDown = (event) => {
      if (inputRef.current && event.target !== inputRef.current) {
        inputRef.current.focus();
        event.preventDefault();
      }
      onMouseDown?.(event);
    };
    useLayoutUpdateEffect(() => {
      if (!decimalValue.isInvalidate()) {
        setInputValue(decimalValue, false);
      }
    }, [precision, formatter]);
    useLayoutUpdateEffect(() => {
      const newValue = getMiniDecimal(value);
      setDecimalValue(newValue);
      const currentParsedValue = getMiniDecimal(mergedParser(inputValue));
      if (!newValue.equals(currentParsedValue) || !userTypingRef.current || formatter) {
        setInputValue(newValue, userTypingRef.current);
      }
    }, [value]);
    useLayoutUpdateEffect(() => {
      if (formatter) {
        restoreCursor();
      }
    }, [inputValue]);
    const sharedHandlerProps = {
      prefixCls,
      onStep: onInternalStep,
      className: classNames?.action,
      style: styles?.action
    };
    const upNode = reactExports.createElement(StepHandler, _extends$f({}, sharedHandlerProps, {
      action: "up",
      disabled: upDisabled
    }), upHandler);
    const downNode = reactExports.createElement(StepHandler, _extends$f({}, sharedHandlerProps, {
      action: "down",
      disabled: downDisabled
    }), downHandler);
    return reactExports.createElement("div", {
      ref: rootRef,
      className: clsx(prefixCls, `${prefixCls}-mode-${mode}`, className, classNames?.root, {
        [`${prefixCls}-focused`]: focus,
        [`${prefixCls}-disabled`]: disabled,
        [`${prefixCls}-readonly`]: readOnly,
        [`${prefixCls}-not-a-number`]: decimalValue.isNaN(),
        [`${prefixCls}-out-of-range`]: !decimalValue.isInvalidate() && !isInRange(decimalValue)
      }),
      style: {
        ...styles?.root,
        ...style2
      },
      onMouseDown: onInternalMouseDown,
      onMouseUp,
      onMouseLeave,
      onMouseMove,
      onMouseEnter,
      onMouseOut,
      onClick,
      onFocus: () => {
        setFocus(true);
      },
      onBlur,
      onKeyDown,
      onKeyUp,
      onCompositionStart,
      onCompositionEnd,
      onBeforeInput
    }, mode === "spinner" && controls && downNode, prefix2 !== void 0 && reactExports.createElement("div", {
      className: clsx(`${prefixCls}-prefix`, classNames?.prefix),
      style: styles?.prefix
    }, prefix2), reactExports.createElement("input", _extends$f({
      autoComplete: "off",
      role: "spinbutton",
      "aria-valuemin": min,
      "aria-valuemax": max,
      "aria-valuenow": decimalValue.isInvalidate() ? null : decimalValue.toString(),
      step,
      ref: inputRef,
      className: clsx(`${prefixCls}-input`, classNames?.input),
      style: styles?.input,
      value: inputValue,
      onChange: onInternalInput,
      disabled,
      readOnly
    }, restProps)), suffix !== void 0 && reactExports.createElement("div", {
      className: clsx(`${prefixCls}-suffix`, classNames?.suffix),
      style: styles?.suffix
    }, suffix), mode === "spinner" && controls && upNode, mode === "input" && controls && reactExports.createElement("div", {
      className: clsx(`${prefixCls}-actions`, classNames?.actions),
      style: styles?.actions
    }, upNode, downNode));
  });
  const genSpaceAddonStyle = (token2) => {
    const {
      componentCls,
      borderRadius,
      paddingSM,
      colorBorder,
      paddingXS,
      fontSizeLG,
      fontSizeSM,
      borderRadiusLG,
      borderRadiusSM,
      colorBgContainerDisabled,
      lineWidth,
      antCls
    } = token2;
    const [varName, varRef] = genCssVar(antCls, "space");
    return {
      [componentCls]: [


{
          display: "inline-flex",
          alignItems: "center",
          gap: 0,
          paddingInline: paddingSM,
          margin: 0,
          borderWidth: lineWidth,
          borderStyle: "solid",
          borderRadius,
          "&:hover": {
            zIndex: 0
          },
          [`&${componentCls}-disabled`]: {
            color: token2.colorTextDisabled
          },
          "&-large": {
            fontSize: fontSizeLG,
            borderRadius: borderRadiusLG
          },
          "&-small": {
            paddingInline: paddingXS,
            borderRadius: borderRadiusSM,
            fontSize: fontSizeSM
          },
          "&-compact-last-item": {
            borderEndStartRadius: 0,
            borderStartStartRadius: 0
          },
          "&-compact-first-item": {
            borderEndEndRadius: 0,
            borderStartEndRadius: 0
          },
          "&-compact-item:not(:first-child):not(:last-child)": {
            borderRadius: 0
          },
          "&-compact-item:not(:last-child)": {
            borderInlineEndWidth: 0
          },
          "&-compact-item:not(:first-child)": {
            borderInlineStartWidth: 0
          }
        },


{
          [varName("addon-border-color")]: colorBorder,
          [varName("addon-background")]: colorBgContainerDisabled,
[varName("addon-border-color-outlined")]: colorBorder,
          [varName("addon-background-filled")]: colorBgContainerDisabled,
          borderColor: varRef("addon-border-color"),
          background: varRef("addon-background"),
"&-variant-outlined": {
            [varName("addon-border-color")]: varRef("addon-border-color-outlined")
          },
"&-variant-filled": {
            [varName("addon-border-color")]: "transparent",
            [varName("addon-background")]: varRef("addon-background-filled"),
[`&${componentCls}-disabled`]: {
              [varName("addon-border-color")]: colorBorder,
              [varName("addon-background")]: colorBgContainerDisabled
            }
          },
"&-variant-borderless": {
            border: "none",
            background: "transparent"
          },
"&-variant-underlined": {
            border: "none",
            background: "transparent"
          }
        },


{
          "&-status-error": {
            [varName("addon-border-color-outlined")]: token2.colorError,
            [varName("addon-background-filled")]: token2.colorErrorBg,
            color: token2.colorError
          },
          "&-status-warning": {
            [varName("addon-border-color-outlined")]: token2.colorWarning,
            [varName("addon-background-filled")]: token2.colorWarningBg,
            color: token2.colorWarning
          }
        }
      ]
    };
  };
  const useStyle$h = genStyleHooks(["Space", "Addon"], (token2) => [genSpaceAddonStyle(token2), genCompactItemStyle(token2, {
    focus: false
  })]);
  const SpaceAddon = React.forwardRef((props, ref2) => {
    const {
      className,
      children,
      style: style2,
      prefixCls: customizePrefixCls,
      variant = "outlined",
      disabled,
      status,
      ...restProps
    } = props;
    const {
      getPrefixCls,
      direction: directionConfig
    } = React.useContext(ConfigContext);
    const prefixCls = getPrefixCls("space-addon", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$h(prefixCls);
    const {
      compactItemClassnames,
      compactSize
    } = useCompactItemContext(prefixCls, directionConfig);
    const statusCls = getStatusClassNames(prefixCls, status);
    const classes2 = clsx(prefixCls, hashId, compactItemClassnames, cssVarCls, `${prefixCls}-variant-${variant}`, statusCls, {
      [`${prefixCls}-${compactSize}`]: compactSize,
      [`${prefixCls}-disabled`]: disabled
    }, className);
    return React.createElement("div", {
      ref: ref2,
      className: classes2,
      style: style2,
      ...restProps
    }, children);
  });
  const prepareComponentToken$a = (token2) => {
    const handleVisible = token2.handleVisible ?? "auto";
    const handleWidth = token2.controlHeightSM - token2.lineWidth * 2;
    return {
      ...initComponentToken(token2),
      controlWidth: 90,
      handleWidth,
      handleFontSize: token2.fontSize / 2,
      handleVisible,
      handleActiveBg: token2.colorFillAlter,
      handleBg: token2.colorBgContainer,
      filledHandleBg: new FastColor(token2.colorFillSecondary).onBackground(token2.colorBgContainer).toHexString(),
      handleHoverColor: token2.colorPrimary,
      handleBorderColor: token2.colorBorder,
      handleOpacity: handleVisible === true ? 1 : 0,
      handleVisibleWidth: handleVisible === true ? handleWidth : 0
    };
  };
  const genInputNumberStyles = (token2) => {
    const {
      componentCls,
      lineWidth,
      lineType,
      borderRadius,
      inputFontSizeSM,
      inputFontSizeLG,
      colorError,
      paddingInlineSM,
      paddingBlockSM,
      paddingBlockLG,
      paddingInlineLG,
      colorIcon,
      motionDurationMid,
      handleHoverColor,
      handleOpacity,
      paddingInline,
      paddingBlock,
      handleBg,
      handleActiveBg,
      inputAffixPadding,
      borderRadiusSM,
      controlWidth,
      handleBorderColor,
      filledHandleBg,
      lineHeightLG,
      antCls
    } = token2;
    const borderStyle = `${unit$1(lineWidth)} ${lineType} ${handleBorderColor}`;
    const [varName, varRef] = genCssVar(antCls, "input-number");
    return [


{
        [componentCls]: {
          ...resetComponent(token2),
          ...genBasicInputStyle(token2),
          [varName("input-padding-block")]: unit$1(paddingBlock),
          [varName("input-padding-inline")]: unit$1(paddingInline),
          display: "inline-flex",
          width: controlWidth,
          margin: 0,
          paddingBlock: 0,
          borderRadius,
...genOutlinedStyle(token2, {
            [`${componentCls}-actions`]: {
              background: handleBg,
              [`${componentCls}-action-down`]: {
                borderBlockStart: borderStyle
              }
            }
          }),
          ...genFilledStyle(token2, {
            [`${componentCls}-actions`]: {
              background: filledHandleBg,
              [`${componentCls}-action-down`]: {
                borderBlockStart: borderStyle
              }
            },
            "&:focus-within": {
              [`${componentCls}-actions`]: {
                background: handleBg
              }
            }
          }),
          ...genUnderlinedStyle(token2, {
            [`${componentCls}-actions`]: {
              background: handleBg,
              [`${componentCls}-action-down`]: {
                borderBlockStart: borderStyle
              }
            }
          }),
          ...genBorderlessStyle(token2),
"&-rtl": {
            direction: "rtl",
            [`${componentCls}-input`]: {
              direction: "rtl"
            }
          },
[`&${componentCls}-out-of-range`]: {
            [`${componentCls}-input`]: {
              color: colorError
            }
          },
[`${componentCls}-input`]: {
            ...resetComponent(token2),
            width: "100%",
            paddingBlock: varRef("input-padding-block"),
            textAlign: "start",
            backgroundColor: "transparent",
            border: 0,
            borderRadius,
            outline: 0,
            transition: `all ${motionDurationMid} linear`,
            appearance: "textfield",
            fontSize: "inherit",
            lineHeight: "inherit",
            ...genPlaceholderStyle(token2.colorTextPlaceholder),
            '&[type="number"]::-webkit-inner-spin-button, &[type="number"]::-webkit-outer-spin-button': {
              margin: 0,
              appearance: "none"
            }
          },
          [`&:hover ${componentCls}-handler-wrap, &-focused ${componentCls}-handler-wrap`]: {
            width: token2.handleWidth,
            opacity: 1
          },
[`&-disabled ${componentCls}-input`]: {
            cursor: "not-allowed",
            color: token2.colorTextDisabled
          }
        }
      },


{
        [componentCls]: {
[`
          ${componentCls}-action-up-disabled,
          ${componentCls}-action-down-disabled
        `]: {
            cursor: "not-allowed"
          },
          [`${componentCls}-action`]: {
            ...resetIcon(),
            userSelect: "none",
            overflow: "hidden",
            fontWeight: "bold",
            lineHeight: 0,
            textAlign: "center",
            cursor: "pointer",
            transition: `all ${motionDurationMid} linear`,
            "&:active": {
              background: handleActiveBg
            },
"&:hover": {
              color: handleHoverColor
            }
          },
"&-mode-input": {
            overflow: "hidden",
            [`${componentCls}-actions`]: {
              position: "absolute",
              insetBlockStart: 0,
              insetInlineEnd: 0,
              width: token2.handleVisibleWidth,
              opacity: handleOpacity,
              height: "100%",
              borderRadius: 0,
              display: "flex",
              flexDirection: "column",
              alignItems: "stretch",
              transition: `all ${motionDurationMid}`,
              overflow: "hidden",


[`${componentCls}-action`]: {
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                flex: "auto",
                height: "40%",
                marginInlineEnd: 0,
                fontSize: token2.handleFontSize
              }
            },
            [`&:hover ${componentCls}-actions, &-focused ${componentCls}-actions`]: {
              width: token2.handleWidth,
              opacity: 1
            },
            [`${componentCls}-action`]: {
              color: colorIcon,
              height: "50%",
              borderInlineStart: borderStyle,
"&:hover": {
                height: `60%`
              }
            },
            [`&${componentCls}-disabled, &${componentCls}-readonly`]: {
              [`${componentCls}-actions`]: {
                display: "none"
              }
            }
          },
[`&${componentCls}-mode-spinner`]: {
            padding: 0,
            width: "auto",
            [`${componentCls}-action`]: {
              flex: "none",
              paddingInline: varRef("input-padding-inline"),
              "&-up": {
                borderInlineStart: borderStyle
              },
              "&-down": {
                borderInlineEnd: borderStyle
              }
            },
            [`${componentCls}-input`]: {
              textAlign: "center",
              paddingInline: varRef("input-padding-inline")
            }
          }
        }
      },


{
        [componentCls]: {
          "&-lg": {
            [varName("input-padding-block")]: unit$1(paddingBlockLG),
            [varName("input-padding-inline")]: unit$1(paddingInlineLG),
            paddingBlock: 0,
            fontSize: inputFontSizeLG,
            lineHeight: lineHeightLG
          },
          "&-sm": {
            [varName("input-padding-block")]: unit$1(paddingBlockSM),
            [varName("input-padding-inline")]: unit$1(paddingInlineSM),
            paddingBlock: 0,
            fontSize: inputFontSizeSM,
            borderRadius: borderRadiusSM
          }
        }
      },


{
        [componentCls]: {
          [`${componentCls}-prefix, ${componentCls}-suffix`]: {
            display: "flex",
            flex: "none",
            alignItems: "center",
            alignSelf: "center",
            pointerEvents: "none"
          },
          [`${componentCls}-prefix`]: {
            marginInlineEnd: inputAffixPadding
          },
          [`${componentCls}-suffix`]: {
            height: "100%",
            marginInlineStart: inputAffixPadding,
            transition: `margin ${motionDurationMid}`
          },
          [`&:hover:not(${componentCls}-without-controls)`]: {
            [`${componentCls}-suffix`]: {
              marginInlineEnd: token2.handleWidth
            }
          }
        }
      }
    ];
  };
  const genCompatibleStyles = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    return {
      [`${componentCls}-addon`]: {
        [`&:has(${antCls}-select)`]: {
          border: 0,
          padding: 0
        }
      }
    };
  };
  const useStyle$g = genStyleHooks("InputNumber", (token2) => {
    const inputNumberToken = merge$1(token2, initInputToken(token2));
    return [
      genInputNumberStyles(inputNumberToken),
      genCompatibleStyles(inputNumberToken),


genCompactItemStyle(inputNumberToken)
    ];
  }, prepareComponentToken$a, {
    unitless: {
      handleOpacity: true
    },
    resetFont: false
  });
  const InternalInputNumber = reactExports.forwardRef((props, ref2) => {
    const inputRef = reactExports.useRef(null);
    reactExports.useImperativeHandle(ref2, () => inputRef.current);
    const {
      rootClassName,
      size: customizeSize,
      disabled: customDisabled,
      prefixCls,
      addonBefore: _addonBefore,
      addonAfter: _addonAfter,
      prefix: prefix2,
      suffix,
      bordered,
      readOnly,
      status,
      controls = true,
      variant: customVariant,
      className,
      style: style2,
      classNames,
      styles,
      mode,
      ...others
    } = props;
    const {
      direction,
      className: contextClassName,
      style: contextStyle,
      styles: contextStyles,
      classNames: contextClassNames
    } = useComponentConfig("inputNumber");
    const disabled = reactExports.useContext(DisabledContext);
    const mergedDisabled = customDisabled ?? disabled;
    const mergedControls = reactExports.useMemo(() => {
      if (!controls || mergedDisabled || readOnly) {
        return false;
      }
      return controls;
    }, [controls, mergedDisabled, readOnly]);
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    let upIcon = mode === "spinner" ? reactExports.createElement(RefIcon$9, null) : reactExports.createElement(RefIcon$7, null);
    let downIcon = mode === "spinner" ? reactExports.createElement(RefIcon$8, null) : reactExports.createElement(RefIcon$e, null);
    const controlsTemp = typeof mergedControls === "boolean" ? mergedControls : void 0;
    if (typeof mergedControls === "object") {
      upIcon = mergedControls.upIcon || upIcon;
      downIcon = mergedControls.downIcon || downIcon;
    }
    const {
      hasFeedback,
      isFormItemInput,
      feedbackIcon
    } = reactExports.useContext(FormItemInputContext);
    const mergedSize = useSize((ctx) => customizeSize ?? compactSize ?? ctx);
    const [variant, enableVariantCls] = useVariant("inputNumber", customVariant, bordered);
    const suffixNode = hasFeedback && reactExports.createElement(reactExports.Fragment, null, feedbackIcon);
    const mergedProps = {
      ...props,
      size: mergedSize,
      disabled: mergedDisabled,
      controls: mergedControls
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    return reactExports.createElement(InputNumber$1, {
      ref: inputRef,
      mode,
      disabled: mergedDisabled,
      className: clsx(className, rootClassName, mergedClassNames.root, contextClassName, compactItemClassnames, getStatusClassNames(prefixCls, status, hasFeedback), {
        [`${prefixCls}-${variant}`]: enableVariantCls,
        [`${prefixCls}-lg`]: mergedSize === "large",
        [`${prefixCls}-sm`]: mergedSize === "small",
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-in-form-item`]: isFormItemInput,
        [`${prefixCls}-without-controls`]: !mergedControls
      }),
      style: {
        ...mergedStyles.root,
        ...contextStyle,
        ...style2
      },
      upHandler: upIcon,
      downHandler: downIcon,
      prefixCls,
      readOnly,
      controls: controlsTemp,
      prefix: prefix2,
      suffix: suffixNode || suffix,
      classNames: mergedClassNames,
      styles: mergedStyles,
      ...others
    });
  });
  const InputNumber = reactExports.forwardRef((props, ref2) => {
    const {
      addonBefore,
      addonAfter,
      prefixCls: customizePrefixCls,
      className,
      status: customStatus,
      rootClassName,
      ...rest
    } = props;
    const {
      getPrefixCls
    } = useComponentConfig("inputNumber");
    const prefixCls = getPrefixCls("input-number", customizePrefixCls);
    const {
      status: contextStatus
    } = reactExports.useContext(FormItemInputContext);
    const mergedStatus = getMergedStatus(contextStatus, customStatus);
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$g(prefixCls, rootCls);
    const hasLegacyAddon = addonBefore || addonAfter;
    const inputNumberNode = reactExports.createElement(InternalInputNumber, {
      ref: ref2,
      ...rest,
      prefixCls,
      status: mergedStatus,
      className: clsx(cssVarCls, rootCls, hashId, className),
      rootClassName: !hasLegacyAddon ? rootClassName : void 0
    });
    if (hasLegacyAddon) {
      const renderAddon = (node2) => {
        if (!node2) {
          return null;
        }
        return reactExports.createElement(SpaceAddon, {
          className: clsx(`${prefixCls}-addon`, cssVarCls, hashId),
          variant: props.variant,
          disabled: props.disabled,
          status: mergedStatus
        }, reactExports.createElement(ContextIsolator, {
          form: true
        }, node2));
      };
      const addonBeforeNode = renderAddon(addonBefore);
      const addonAfterNode = renderAddon(addonAfter);
      return reactExports.createElement(Compact$1, {
        rootClassName
      }, addonBeforeNode, inputNumberNode, addonAfterNode);
    }
    return inputNumberNode;
  });
  const TypedInputNumber = InputNumber;
  const PureInputNumber = (props) => reactExports.createElement(ConfigProvider, {
    theme: {
      components: {
        InputNumber: {
          handleVisible: true
        }
      }
    }
  }, reactExports.createElement(InputNumber, {
    ...props
  }));
  TypedInputNumber._InternalPanelDoNotUseOrYouWillBeFired = PureInputNumber;
  const ColorSteppers = ({
    prefixCls,
    min = 0,
    max = 100,
    value,
    onChange,
    className,
    formatter
  }) => {
    const colorSteppersPrefixCls = `${prefixCls}-steppers`;
    const [internalValue, setInternalValue] = reactExports.useState(0);
    const stepValue = !Number.isNaN(value) ? value : internalValue;
    return React.createElement(TypedInputNumber, {
      className: clsx(colorSteppersPrefixCls, className),
      min,
      max,
      value: stepValue,
      formatter,
      size: "small",
      onChange: (step) => {
        setInternalValue(step || 0);
        onChange?.(step);
      }
    });
  };
  const ColorAlphaInput = ({
    prefixCls,
    value,
    onChange
  }) => {
    const colorAlphaInputPrefixCls = `${prefixCls}-alpha-input`;
    const [internalValue, setInternalValue] = reactExports.useState(() => generateColor(value || "#000"));
    const alphaValue = value || internalValue;
    const handleAlphaChange = (step) => {
      const hsba = alphaValue.toHsb();
      hsba.a = (step || 0) / 100;
      const genColor = generateColor(hsba);
      setInternalValue(genColor);
      onChange?.(genColor);
    };
    return React.createElement(ColorSteppers, {
      value: getColorAlpha(alphaValue),
      prefixCls,
      formatter: (step) => `${step}%`,
      className: colorAlphaInputPrefixCls,
      onChange: handleAlphaChange
    });
  };
  function hasAddon(props) {
    return !!(props.addonBefore || props.addonAfter);
  }
  function hasPrefixSuffix$1(props) {
    return !!(props.prefix || props.suffix || props.allowClear);
  }
  function cloneEvent(event, target, value) {
    const currentTarget = target.cloneNode(true);
    const newEvent = Object.create(event, {
      target: {
        value: currentTarget
      },
      currentTarget: {
        value: currentTarget
      }
    });
    currentTarget.value = value;
    if (typeof target.selectionStart === "number" && typeof target.selectionEnd === "number") {
      currentTarget.selectionStart = target.selectionStart;
      currentTarget.selectionEnd = target.selectionEnd;
    }
    currentTarget.setSelectionRange = (...args) => {
      target.setSelectionRange(...args);
    };
    return newEvent;
  }
  function resolveOnChange(target, e, onChange, targetValue) {
    if (!onChange) {
      return;
    }
    let event = e;
    if (e.type === "click") {
      event = cloneEvent(e, target, "");
      onChange(event);
      return;
    }
    if (target.type !== "file" && targetValue !== void 0) {
      event = cloneEvent(e, target, targetValue);
      onChange(event);
      return;
    }
    onChange(event);
  }
  function _extends$e() {
    _extends$e = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$e.apply(this, arguments);
  }
  const BaseInput = React.forwardRef((props, ref2) => {
    const {
      inputElement: inputEl,
      children,
      prefixCls,
      prefix: prefix2,
      suffix,
      addonBefore,
      addonAfter,
      className,
      style: style2,
      disabled,
      readOnly,
      focused,
      triggerFocus: triggerFocus2,
      allowClear,
      value,
      handleReset,
      hidden,
      classes: classes2,
      classNames,
      dataAttrs,
      styles,
      components: components2,
      onClear
    } = props;
    const inputElement = children ?? inputEl;
    const AffixWrapperComponent = components2?.affixWrapper || "span";
    const GroupWrapperComponent = components2?.groupWrapper || "span";
    const WrapperComponent = components2?.wrapper || "span";
    const GroupAddonComponent = components2?.groupAddon || "span";
    const containerRef = reactExports.useRef(null);
    const onInputClick = (e) => {
      if (containerRef.current?.contains(e.target)) {
        triggerFocus2?.();
      }
    };
    const hasAffix = hasPrefixSuffix$1(props);
    let element = reactExports.cloneElement(inputElement, {
      value,
      className: clsx(inputElement.props?.className, !hasAffix && classNames?.variant) || null
    });
    const groupRef = reactExports.useRef(null);
    React.useImperativeHandle(ref2, () => ({
      nativeElement: groupRef.current || containerRef.current
    }));
    if (hasAffix) {
      let clearIcon = null;
      if (allowClear) {
        const needClear = !disabled && !readOnly && value;
        const clearIconCls = `${prefixCls}-clear-icon`;
        const iconNode = typeof allowClear === "object" && allowClear?.clearIcon ? allowClear.clearIcon : "✖";
        clearIcon = React.createElement("button", {
          type: "button",
          tabIndex: -1,
          onClick: (event) => {
            handleReset?.(event);
            onClear?.();
          },
          onMouseDown: (e) => e.preventDefault(),
          className: clsx(clearIconCls, {
            [`${clearIconCls}-hidden`]: !needClear,
            [`${clearIconCls}-has-suffix`]: !!suffix
          })
        }, iconNode);
      }
      const affixWrapperPrefixCls = `${prefixCls}-affix-wrapper`;
      const affixWrapperCls = clsx(affixWrapperPrefixCls, {
        [`${prefixCls}-disabled`]: disabled,
        [`${affixWrapperPrefixCls}-disabled`]: disabled,
[`${affixWrapperPrefixCls}-focused`]: focused,
[`${affixWrapperPrefixCls}-readonly`]: readOnly,
        [`${affixWrapperPrefixCls}-input-with-clear-btn`]: suffix && allowClear && value
      }, classes2?.affixWrapper, classNames?.affixWrapper, classNames?.variant);
      const suffixNode = (suffix || allowClear) && React.createElement("span", {
        className: clsx(`${prefixCls}-suffix`, classNames?.suffix),
        style: styles?.suffix
      }, clearIcon, suffix);
      element = React.createElement(AffixWrapperComponent, _extends$e({
        className: affixWrapperCls,
        style: styles?.affixWrapper,
        onClick: onInputClick
      }, dataAttrs?.affixWrapper, {
        ref: containerRef
      }), prefix2 && React.createElement("span", {
        className: clsx(`${prefixCls}-prefix`, classNames?.prefix),
        style: styles?.prefix
      }, prefix2), element, suffixNode);
    }
    if (hasAddon(props)) {
      const wrapperCls = `${prefixCls}-group`;
      const addonCls = `${wrapperCls}-addon`;
      const groupWrapperCls = `${wrapperCls}-wrapper`;
      const mergedWrapperClassName = clsx(`${prefixCls}-wrapper`, wrapperCls, classes2?.wrapper, classNames?.wrapper);
      const mergedGroupClassName = clsx(groupWrapperCls, {
        [`${groupWrapperCls}-disabled`]: disabled
      }, classes2?.group, classNames?.groupWrapper);
      element = React.createElement(GroupWrapperComponent, {
        className: mergedGroupClassName,
        ref: groupRef
      }, React.createElement(WrapperComponent, {
        className: mergedWrapperClassName
      }, addonBefore && React.createElement(GroupAddonComponent, {
        className: addonCls
      }, addonBefore), element, addonAfter && React.createElement(GroupAddonComponent, {
        className: addonCls
      }, addonAfter)));
    }
    return React.cloneElement(element, {
      className: clsx(element.props?.className, className) || null,
      style: {
        ...element.props?.style,
        ...style2
      },
      hidden
    });
  });
  function useCount(count, showCount) {
    return reactExports.useMemo(() => {
      let mergedConfig = {};
      if (showCount) {
        mergedConfig.show = typeof showCount === "object" && showCount.formatter ? showCount.formatter : !!showCount;
      }
      mergedConfig = {
        ...mergedConfig,
        ...count
      };
      const {
        show,
        ...rest
      } = mergedConfig;
      return {
        ...rest,
        show: !!show,
        showFormatter: typeof show === "function" ? show : void 0,
        strategy: rest.strategy || ((value) => value.length)
      };
    }, [count, showCount]);
  }
  function _extends$d() {
    _extends$d = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$d.apply(this, arguments);
  }
  const Input$2 = reactExports.forwardRef((props, ref2) => {
    const {
      autoComplete,
      onChange,
      onFocus,
      onBlur,
      onPressEnter,
      onKeyDown,
      onKeyUp,
      prefixCls = "rc-input",
      disabled,
      htmlSize,
      className,
      maxLength,
      suffix,
      showCount,
      count,
      type: type4 = "text",
      classes: classes2,
      classNames,
      styles,
      onCompositionStart,
      onCompositionEnd,
      ...rest
    } = props;
    const [focused, setFocused] = reactExports.useState(false);
    const compositionRef = reactExports.useRef(false);
    const keyLockRef = reactExports.useRef(false);
    const inputRef = reactExports.useRef(null);
    const holderRef = reactExports.useRef(null);
    const focus = (option) => {
      if (inputRef.current) {
        triggerFocus(inputRef.current, option);
      }
    };
    const [value, setValue] = useControlledState(props.defaultValue, props.value);
    const formatValue = value === void 0 || value === null ? "" : String(value);
    const [selection, setSelection] = reactExports.useState(null);
    const countConfig = useCount(count, showCount);
    const mergedMax = countConfig.max || maxLength;
    const valueLength = countConfig.strategy(formatValue);
    const isOutOfRange = !!mergedMax && valueLength > mergedMax;
    reactExports.useImperativeHandle(ref2, () => ({
      focus,
      blur: () => {
        inputRef.current?.blur();
      },
      setSelectionRange: (start, end, direction) => {
        inputRef.current?.setSelectionRange(start, end, direction);
      },
      select: () => {
        inputRef.current?.select();
      },
      input: inputRef.current,
      nativeElement: holderRef.current?.nativeElement || inputRef.current
    }));
    reactExports.useEffect(() => {
      if (keyLockRef.current) {
        keyLockRef.current = false;
      }
      setFocused((prev2) => prev2 && disabled ? false : prev2);
    }, [disabled]);
    const triggerChange = (e, currentValue, info) => {
      let cutValue = currentValue;
      if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
        cutValue = countConfig.exceedFormatter(currentValue, {
          max: countConfig.max
        });
        if (currentValue !== cutValue) {
          setSelection([inputRef.current?.selectionStart || 0, inputRef.current?.selectionEnd || 0]);
        }
      } else if (info.source === "compositionEnd") {
        return;
      }
      setValue(cutValue);
      if (inputRef.current) {
        resolveOnChange(inputRef.current, e, onChange, cutValue);
      }
    };
    reactExports.useEffect(() => {
      if (selection) {
        inputRef.current?.setSelectionRange(...selection);
      }
    }, [selection]);
    const onInternalChange = (e) => {
      triggerChange(e, e.target.value, {
        source: "change"
      });
    };
    const onInternalCompositionEnd = (e) => {
      compositionRef.current = false;
      triggerChange(e, e.currentTarget.value, {
        source: "compositionEnd"
      });
      onCompositionEnd?.(e);
    };
    const handleKeyDown = (e) => {
      if (onPressEnter && e.key === "Enter" && !keyLockRef.current && !e.nativeEvent.isComposing) {
        keyLockRef.current = true;
        onPressEnter(e);
      }
      onKeyDown?.(e);
    };
    const handleKeyUp = (e) => {
      if (e.key === "Enter") {
        keyLockRef.current = false;
      }
      onKeyUp?.(e);
    };
    const handleFocus = (e) => {
      setFocused(true);
      onFocus?.(e);
    };
    const handleBlur = (e) => {
      if (keyLockRef.current) {
        keyLockRef.current = false;
      }
      setFocused(false);
      onBlur?.(e);
    };
    const handleReset = (e) => {
      setValue("");
      focus();
      if (inputRef.current) {
        resolveOnChange(inputRef.current, e, onChange);
      }
    };
    const outOfRangeCls = isOutOfRange && `${prefixCls}-out-of-range`;
    const getInputElement = () => {
      const otherProps = omit(props, [
        "prefixCls",
        "onPressEnter",
        "addonBefore",
        "addonAfter",
        "prefix",
        "suffix",
        "allowClear",

"defaultValue",
        "showCount",
        "count",
        "classes",
        "htmlSize",
        "styles",
        "classNames",
        "onClear"
      ]);
      return React.createElement("input", _extends$d({
        autoComplete
      }, otherProps, {
        onChange: onInternalChange,
        onFocus: handleFocus,
        onBlur: handleBlur,
        onKeyDown: handleKeyDown,
        onKeyUp: handleKeyUp,
        className: clsx(prefixCls, {
          [`${prefixCls}-disabled`]: disabled
        }, classNames?.input),
        style: styles?.input,
        ref: inputRef,
        size: htmlSize,
        type: type4,
        onCompositionStart: (e) => {
          compositionRef.current = true;
          onCompositionStart?.(e);
        },
        onCompositionEnd: onInternalCompositionEnd
      }));
    };
    const getSuffix = () => {
      const hasMaxLength = Number(mergedMax) > 0;
      if (suffix || countConfig.show) {
        const dataCount = countConfig.showFormatter ? countConfig.showFormatter({
          value: formatValue,
          count: valueLength,
          maxLength: mergedMax
        }) : `${valueLength}${hasMaxLength ? ` / ${mergedMax}` : ""}`;
        return React.createElement(React.Fragment, null, countConfig.show && React.createElement("span", {
          className: clsx(`${prefixCls}-show-count-suffix`, {
            [`${prefixCls}-show-count-has-suffix`]: !!suffix
          }, classNames?.count),
          style: {
            ...styles?.count
          }
        }, dataCount), suffix);
      }
      return null;
    };
    return React.createElement(BaseInput, _extends$d({}, rest, {
      prefixCls,
      className: clsx(className, outOfRangeCls),
      handleReset,
      value: formatValue,
      focused,
      triggerFocus: focus,
      suffix: getSuffix(),
      disabled,
      classes: classes2,
      classNames,
      styles,
      ref: holderRef
    }), getInputElement());
  });
  const getAllowClear = (allowClear) => {
    let mergedAllowClear;
    if (typeof allowClear === "object" && allowClear?.clearIcon) {
      mergedAllowClear = allowClear;
    } else if (allowClear) {
      mergedAllowClear = {
        clearIcon: React.createElement(RefIcon$l, null)
      };
    }
    return mergedAllowClear;
  };
  function useRemovePasswordTimeout(inputRef, triggerOnMount) {
    const removePasswordTimeoutRef = reactExports.useRef([]);
    const removePasswordTimeout = () => {
      removePasswordTimeoutRef.current.push(setTimeout(() => {
        if (inputRef.current?.input && inputRef.current?.input.getAttribute("type") === "password" && inputRef.current?.input.hasAttribute("value")) {
          inputRef.current?.input.removeAttribute("value");
        }
      }));
    };
    reactExports.useEffect(() => {
      if (triggerOnMount) {
        removePasswordTimeout();
      }
      return () => removePasswordTimeoutRef.current.forEach((timer) => {
        if (timer) {
          clearTimeout(timer);
        }
      });
    }, []);
    return removePasswordTimeout;
  }
  function hasPrefixSuffix(props) {
    return !!(props.prefix || props.suffix || props.allowClear || props.showCount);
  }
  const Input$1 = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls: customizePrefixCls,
      bordered = true,
      status: customStatus,
      size: customSize,
      disabled: customDisabled,
      onBlur,
      onFocus,
      suffix,
      allowClear,
      addonAfter,
      addonBefore,
      className,
      style: style2,
      styles,
      rootClassName,
      onChange,
      classNames,
      variant: customVariant,
      ...rest
    } = props;
    const {
      getPrefixCls,
      direction,
      allowClear: contextAllowClear,
      autoComplete: contextAutoComplete,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("input");
    const prefixCls = getPrefixCls("input", customizePrefixCls);
    const inputRef = reactExports.useRef(null);
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useSharedStyle(prefixCls, rootClassName);
    useStyle$m(prefixCls, rootCls);
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const mergedSize = useSize((ctx) => customSize ?? compactSize ?? ctx);
    const disabled = React.useContext(DisabledContext);
    const mergedDisabled = customDisabled ?? disabled;
    const mergedProps = {
      ...props,
      size: mergedSize,
      disabled: mergedDisabled
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const {
      status: contextStatus,
      hasFeedback,
      feedbackIcon
    } = reactExports.useContext(FormItemInputContext);
    const mergedStatus = getMergedStatus(contextStatus, customStatus);
    const inputHasPrefixSuffix = hasPrefixSuffix(props) || !!hasFeedback;
    reactExports.useRef(inputHasPrefixSuffix);
    const removePasswordTimeout = useRemovePasswordTimeout(inputRef, true);
    const handleBlur = (e) => {
      removePasswordTimeout();
      onBlur?.(e);
    };
    const handleFocus = (e) => {
      removePasswordTimeout();
      onFocus?.(e);
    };
    const handleChange = (e) => {
      removePasswordTimeout();
      onChange?.(e);
    };
    const suffixNode = (hasFeedback || suffix) && React.createElement(React.Fragment, null, suffix, hasFeedback && feedbackIcon);
    const mergedAllowClear = getAllowClear(allowClear ?? contextAllowClear);
    const [variant, enableVariantCls] = useVariant("input", customVariant, bordered);
    return React.createElement(Input$2, {
      ref: composeRef(ref2, inputRef),
      prefixCls,
      autoComplete: contextAutoComplete,
      ...rest,
      disabled: mergedDisabled,
      onBlur: handleBlur,
      onFocus: handleFocus,
      style: {
        ...mergedStyles.root,
        ...contextStyle,
        ...style2
      },
      styles: mergedStyles,
      suffix: suffixNode,
      allowClear: mergedAllowClear,
      className: clsx(className, rootClassName, cssVarCls, rootCls, compactItemClassnames, contextClassName, mergedClassNames.root),
      onChange: handleChange,
      addonBefore: addonBefore && React.createElement(ContextIsolator, {
        form: true,
        space: true
      }, addonBefore),
      addonAfter: addonAfter && React.createElement(ContextIsolator, {
        form: true,
        space: true
      }, addonAfter),
      classNames: {
        ...mergedClassNames,
        input: clsx({
          [`${prefixCls}-sm`]: mergedSize === "small",
          [`${prefixCls}-lg`]: mergedSize === "large",
          [`${prefixCls}-rtl`]: direction === "rtl"
        }, mergedClassNames.input, hashId),
        variant: clsx({
          [`${prefixCls}-${variant}`]: enableVariantCls
        }, getStatusClassNames(prefixCls, mergedStatus)),
        affixWrapper: clsx({
          [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
          [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
          [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl"
        }, hashId),
        wrapper: clsx({
          [`${prefixCls}-group-rtl`]: direction === "rtl"
        }, hashId),
        groupWrapper: clsx({
          [`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
          [`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
          [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
          [`${prefixCls}-group-wrapper-${variant}`]: enableVariantCls
        }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
      }
    });
  });
  const hexReg = /(^#[\da-f]{6}$)|(^#[\da-f]{8}$)/i;
  const isHexString = (hex3) => hexReg.test(`#${hex3}`);
  const ColorHexInput = ({
    prefixCls,
    value,
    onChange
  }) => {
    const colorHexInputPrefixCls = `${prefixCls}-hex-input`;
    const [hexValue, setHexValue] = reactExports.useState(() => value ? toHexFormat(value.toHexString()) : void 0);
    reactExports.useEffect(() => {
      if (value) {
        setHexValue(toHexFormat(value.toHexString()));
      }
    }, [value]);
    const handleHexChange = (e) => {
      const originValue = e.target.value;
      setHexValue(toHexFormat(originValue));
      if (isHexString(toHexFormat(originValue, true))) {
        onChange?.(generateColor(originValue));
      }
    };
    return React.createElement(Input$1, {
      className: colorHexInputPrefixCls,
      value: hexValue,
      prefix: "#",
      onChange: handleHexChange,
      size: "small"
    });
  };
  const ColorHsbInput = ({
    prefixCls,
    value,
    onChange
  }) => {
    const colorHsbInputPrefixCls = `${prefixCls}-hsb-input`;
    const [internalValue, setInternalValue] = reactExports.useState(() => generateColor(value || "#000"));
    const hsbValue = value || internalValue;
    const handleHsbChange = (step, type4) => {
      const hsb = hsbValue.toHsb();
      hsb[type4] = type4 === "h" ? step : (step || 0) / 100;
      const genColor = generateColor(hsb);
      setInternalValue(genColor);
      onChange?.(genColor);
    };
    return React.createElement("div", {
      className: colorHsbInputPrefixCls
    }, React.createElement(ColorSteppers, {
      max: 360,
      min: 0,
      value: Number(hsbValue.toHsb().h),
      prefixCls,
      className: colorHsbInputPrefixCls,
      formatter: (step) => getRoundNumber(step || 0).toString(),
      onChange: (step) => handleHsbChange(Number(step), "h")
    }), React.createElement(ColorSteppers, {
      max: 100,
      min: 0,
      value: Number(hsbValue.toHsb().s) * 100,
      prefixCls,
      className: colorHsbInputPrefixCls,
      formatter: (step) => `${getRoundNumber(step || 0)}%`,
      onChange: (step) => handleHsbChange(Number(step), "s")
    }), React.createElement(ColorSteppers, {
      max: 100,
      min: 0,
      value: Number(hsbValue.toHsb().b) * 100,
      prefixCls,
      className: colorHsbInputPrefixCls,
      formatter: (step) => `${getRoundNumber(step || 0)}%`,
      onChange: (step) => handleHsbChange(Number(step), "b")
    }));
  };
  const ColorRgbInput = ({
    prefixCls,
    value,
    onChange
  }) => {
    const colorRgbInputPrefixCls = `${prefixCls}-rgb-input`;
    const [internalValue, setInternalValue] = reactExports.useState(() => generateColor(value || "#000"));
    const rgbValue = value || internalValue;
    const handleRgbChange = (step, type4) => {
      const rgb = rgbValue.toRgb();
      rgb[type4] = step || 0;
      const genColor = generateColor(rgb);
      setInternalValue(genColor);
      onChange?.(genColor);
    };
    return React.createElement("div", {
      className: colorRgbInputPrefixCls
    }, React.createElement(ColorSteppers, {
      max: 255,
      min: 0,
      value: Number(rgbValue.toRgb().r),
      prefixCls,
      className: colorRgbInputPrefixCls,
      onChange: (step) => handleRgbChange(Number(step), "r")
    }), React.createElement(ColorSteppers, {
      max: 255,
      min: 0,
      value: Number(rgbValue.toRgb().g),
      prefixCls,
      className: colorRgbInputPrefixCls,
      onChange: (step) => handleRgbChange(Number(step), "g")
    }), React.createElement(ColorSteppers, {
      max: 255,
      min: 0,
      value: Number(rgbValue.toRgb().b),
      prefixCls,
      className: colorRgbInputPrefixCls,
      onChange: (step) => handleRgbChange(Number(step), "b")
    }));
  };
  const selectOptions = [FORMAT_HEX, FORMAT_HSB, FORMAT_RGB].map((format2) => ({
    value: format2,
    label: format2.toUpperCase()
  }));
  const ColorInput = (props) => {
    const {
      prefixCls,
      format: format2,
      value,
      disabledAlpha,
      onFormatChange,
      onChange,
      disabledFormat
    } = props;
    const [colorFormat, setColorFormat] = useControlledState(FORMAT_HEX, format2);
    const colorInputPrefixCls = `${prefixCls}-input`;
    const triggerFormatChange = (newFormat) => {
      setColorFormat(newFormat);
      onFormatChange?.(newFormat);
    };
    const steppersNode = reactExports.useMemo(() => {
      const inputProps = {
        value,
        prefixCls,
        onChange
      };
      switch (colorFormat) {
        case FORMAT_HSB:
          return React.createElement(ColorHsbInput, {
            ...inputProps
          });
        case FORMAT_RGB:
          return React.createElement(ColorRgbInput, {
            ...inputProps
          });
default:
          return React.createElement(ColorHexInput, {
            ...inputProps
          });
      }
    }, [colorFormat, prefixCls, value, onChange]);
    return React.createElement("div", {
      className: `${colorInputPrefixCls}-container`
    }, !disabledFormat && React.createElement(Select, {
      value: colorFormat,
      variant: "borderless",
      getPopupContainer: (current) => current,
      popupMatchSelectWidth: 68,
      placement: "bottomRight",
      onChange: triggerFormatChange,
      className: `${prefixCls}-format-select`,
      size: "small",
      options: selectOptions
    }), React.createElement("div", {
      className: colorInputPrefixCls
    }, steppersNode), !disabledAlpha && React.createElement(ColorAlphaInput, {
      prefixCls,
      value,
      onChange
    }));
  };
  function getOffset(value, min, max) {
    return (value - min) / (max - min);
  }
  function getDirectionStyle(direction, value, min, max) {
    const offset2 = getOffset(value, min, max);
    const positionStyle = {};
    switch (direction) {
      case "rtl":
        positionStyle.right = `${offset2 * 100}%`;
        positionStyle.transform = "translateX(50%)";
        break;
      case "btt":
        positionStyle.bottom = `${offset2 * 100}%`;
        positionStyle.transform = "translateY(50%)";
        break;
      case "ttb":
        positionStyle.top = `${offset2 * 100}%`;
        positionStyle.transform = "translateY(-50%)";
        break;
      default:
        positionStyle.left = `${offset2 * 100}%`;
        positionStyle.transform = "translateX(-50%)";
        break;
    }
    return positionStyle;
  }
  function getIndex(value, index) {
    return Array.isArray(value) ? value[index] : value;
  }
  const SliderContext = reactExports.createContext({
    min: 0,
    max: 0,
    direction: "ltr",
    step: 1,
    includedStart: 0,
    includedEnd: 0,
    tabIndex: 0,
    keyboard: true,
    styles: {},
    classNames: {}
  });
  const UnstableContext = reactExports.createContext({});
  function _extends$c() {
    _extends$c = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$c.apply(this, arguments);
  }
  const Handle = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls,
      value,
      valueIndex,
      onStartMove,
      onDelete,
      style: style2,
      render: render4,
      dragging,
      draggingDelete,
      onOffsetChange,
      onChangeComplete,
      onFocus,
      onMouseEnter,
      ...restProps
    } = props;
    const {
      min,
      max,
      direction,
      disabled,
      keyboard,
      range: range3,
      tabIndex,
      ariaLabelForHandle,
      ariaLabelledByForHandle,
      ariaRequired,
      ariaValueTextFormatterForHandle,
      styles,
      classNames
    } = reactExports.useContext(SliderContext);
    const handlePrefixCls = `${prefixCls}-handle`;
    const onInternalStartMove = (e) => {
      if (!disabled) {
        onStartMove(e, valueIndex);
      }
    };
    const onInternalFocus = (e) => {
      onFocus?.(e, valueIndex);
    };
    const onInternalMouseEnter = (e) => {
      onMouseEnter(e, valueIndex);
    };
    const onKeyDown = (e) => {
      if (!disabled && keyboard) {
        let offset2 = null;
        switch (e.which || e.keyCode) {
          case KeyCode.LEFT:
            offset2 = direction === "ltr" || direction === "btt" ? -1 : 1;
            break;
          case KeyCode.RIGHT:
            offset2 = direction === "ltr" || direction === "btt" ? 1 : -1;
            break;
case KeyCode.UP:
            offset2 = direction !== "ttb" ? 1 : -1;
            break;
case KeyCode.DOWN:
            offset2 = direction !== "ttb" ? -1 : 1;
            break;
          case KeyCode.HOME:
            offset2 = "min";
            break;
          case KeyCode.END:
            offset2 = "max";
            break;
          case KeyCode.PAGE_UP:
            offset2 = 2;
            break;
          case KeyCode.PAGE_DOWN:
            offset2 = -2;
            break;
          case KeyCode.BACKSPACE:
          case KeyCode.DELETE:
            onDelete?.(valueIndex);
            break;
        }
        if (offset2 !== null) {
          e.preventDefault();
          onOffsetChange(offset2, valueIndex);
        }
      }
    };
    const handleKeyUp = (e) => {
      switch (e.which || e.keyCode) {
        case KeyCode.LEFT:
        case KeyCode.RIGHT:
        case KeyCode.UP:
        case KeyCode.DOWN:
        case KeyCode.HOME:
        case KeyCode.END:
        case KeyCode.PAGE_UP:
        case KeyCode.PAGE_DOWN:
          onChangeComplete?.();
          break;
      }
    };
    const positionStyle = getDirectionStyle(direction, value, min, max);
    let divProps = {};
    if (valueIndex !== null) {
      divProps = {
        tabIndex: disabled ? null : getIndex(tabIndex, valueIndex),
        role: "slider",
        "aria-valuemin": min,
        "aria-valuemax": max,
        "aria-valuenow": value,
        "aria-disabled": disabled,
        "aria-label": getIndex(ariaLabelForHandle, valueIndex),
        "aria-labelledby": getIndex(ariaLabelledByForHandle, valueIndex),
        "aria-required": getIndex(ariaRequired, valueIndex),
        "aria-valuetext": getIndex(ariaValueTextFormatterForHandle, valueIndex)?.(value),
        "aria-orientation": direction === "ltr" || direction === "rtl" ? "horizontal" : "vertical",
        onMouseDown: onInternalStartMove,
        onTouchStart: onInternalStartMove,
        onFocus: onInternalFocus,
        onMouseEnter: onInternalMouseEnter,
        onKeyDown,
        onKeyUp: handleKeyUp
      };
    }
    let handleNode = reactExports.createElement("div", _extends$c({
      ref: ref2,
      className: clsx(handlePrefixCls, {
        [`${handlePrefixCls}-${valueIndex + 1}`]: valueIndex !== null && range3,
        [`${handlePrefixCls}-dragging`]: dragging,
        [`${handlePrefixCls}-dragging-delete`]: draggingDelete
      }, classNames.handle),
      style: {
        ...positionStyle,
        ...style2,
        ...styles.handle
      }
    }, divProps, restProps));
    if (render4) {
      handleNode = render4(handleNode, {
        index: valueIndex,
        prefixCls,
        value,
        dragging,
        draggingDelete
      });
    }
    return handleNode;
  });
  function _extends$b() {
    _extends$b = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$b.apply(this, arguments);
  }
  const Handles = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls,
      style: style2,
      onStartMove,
      onOffsetChange,
      values,
      handleRender,
      activeHandleRender,
      draggingIndex,
      draggingDelete,
      onFocus,
      ...restProps
    } = props;
    const handlesRef = reactExports.useRef({});
    const [activeVisible, setActiveVisible] = reactExports.useState(false);
    const [activeIndex, setActiveIndex] = reactExports.useState(-1);
    const onActive = (index) => {
      setActiveIndex(index);
      setActiveVisible(true);
    };
    const onHandleFocus = (e, index) => {
      onActive(index);
      onFocus?.(e);
    };
    const onHandleMouseEnter = (e, index) => {
      onActive(index);
    };
    reactExports.useImperativeHandle(ref2, () => ({
      focus: (index) => {
        handlesRef.current[index]?.focus();
      },
      hideHelp: () => {
        reactDomExports.flushSync(() => {
          setActiveVisible(false);
        });
      }
    }));
    const handleProps = {
      prefixCls,
      onStartMove,
      onOffsetChange,
      render: handleRender,
      onFocus: onHandleFocus,
      onMouseEnter: onHandleMouseEnter,
      ...restProps
    };
    return reactExports.createElement(reactExports.Fragment, null, values.map((value, index) => {
      const dragging = draggingIndex === index;
      return reactExports.createElement(Handle, _extends$b({
        ref: (node2) => {
          if (!node2) {
            delete handlesRef.current[index];
          } else {
            handlesRef.current[index] = node2;
          }
        },
        dragging,
        draggingDelete: dragging && draggingDelete,
        style: getIndex(style2, index),
        key: index,
        value,
        valueIndex: index
      }, handleProps));
    }), activeHandleRender && activeVisible && reactExports.createElement(Handle, _extends$b({
      key: "a11y"
    }, handleProps, {
      value: values[activeIndex],
      valueIndex: null,
      dragging: draggingIndex !== -1,
      draggingDelete,
      render: activeHandleRender,
      style: {
        pointerEvents: "none"
      },
      tabIndex: null,
      "aria-hidden": true
    })));
  });
  const Mark = (props) => {
    const {
      prefixCls,
      style: style2,
      children,
      value,
      onClick
    } = props;
    const {
      min,
      max,
      direction,
      includedStart,
      includedEnd,
      included
    } = reactExports.useContext(SliderContext);
    const textCls = `${prefixCls}-text`;
    const positionStyle = getDirectionStyle(direction, value, min, max);
    return reactExports.createElement("span", {
      className: clsx(textCls, {
        [`${textCls}-active`]: included && includedStart <= value && value <= includedEnd
      }),
      style: {
        ...positionStyle,
        ...style2
      },
      onMouseDown: (e) => {
        e.stopPropagation();
      },
      onClick: () => {
        onClick(value);
      }
    }, children);
  };
  const Marks = (props) => {
    const {
      prefixCls,
      marks,
      onClick
    } = props;
    const markPrefixCls = `${prefixCls}-mark`;
    if (!marks.length) {
      return null;
    }
    return reactExports.createElement("div", {
      className: markPrefixCls
    }, marks.map(({
      value,
      style: style2,
      label
    }) => reactExports.createElement(Mark, {
      key: value,
      prefixCls: markPrefixCls,
      style: style2,
      value,
      onClick
    }, label)));
  };
  const Dot = (props) => {
    const {
      prefixCls,
      value,
      style: style2,
      activeStyle
    } = props;
    const {
      min,
      max,
      direction,
      included,
      includedStart,
      includedEnd
    } = reactExports.useContext(SliderContext);
    const dotClassName = `${prefixCls}-dot`;
    const active = included && includedStart <= value && value <= includedEnd;
    let mergedStyle = {
      ...getDirectionStyle(direction, value, min, max),
      ...typeof style2 === "function" ? style2(value) : style2
    };
    if (active) {
      mergedStyle = {
        ...mergedStyle,
        ...typeof activeStyle === "function" ? activeStyle(value) : activeStyle
      };
    }
    return reactExports.createElement("span", {
      className: clsx(dotClassName, {
        [`${dotClassName}-active`]: active
      }),
      style: mergedStyle
    });
  };
  const Steps = (props) => {
    const {
      prefixCls,
      marks,
      dots,
      style: style2,
      activeStyle
    } = props;
    const {
      min,
      max,
      step
    } = reactExports.useContext(SliderContext);
    const stepDots = reactExports.useMemo(() => {
      const dotSet = new Set();
      marks.forEach((mark) => {
        dotSet.add(mark.value);
      });
      if (dots && step !== null) {
        let current = min;
        while (current <= max) {
          dotSet.add(current);
          current += step;
        }
      }
      return Array.from(dotSet);
    }, [min, max, step, dots, marks]);
    return reactExports.createElement("div", {
      className: `${prefixCls}-step`
    }, stepDots.map((dotValue) => reactExports.createElement(Dot, {
      prefixCls,
      key: dotValue,
      value: dotValue,
      style: style2,
      activeStyle
    })));
  };
  const Track = (props) => {
    const {
      prefixCls,
      style: style2,
      start,
      end,
      index,
      onStartMove,
      replaceCls
    } = props;
    const {
      direction,
      min,
      max,
      disabled,
      range: range3,
      classNames
    } = reactExports.useContext(SliderContext);
    const trackPrefixCls = `${prefixCls}-track`;
    const offsetStart = getOffset(start, min, max);
    const offsetEnd = getOffset(end, min, max);
    const onInternalStartMove = (e) => {
      if (!disabled && onStartMove) {
        onStartMove(e, -1);
      }
    };
    const positionStyle = {};
    switch (direction) {
      case "rtl":
        positionStyle.right = `${offsetStart * 100}%`;
        positionStyle.width = `${offsetEnd * 100 - offsetStart * 100}%`;
        break;
      case "btt":
        positionStyle.bottom = `${offsetStart * 100}%`;
        positionStyle.height = `${offsetEnd * 100 - offsetStart * 100}%`;
        break;
      case "ttb":
        positionStyle.top = `${offsetStart * 100}%`;
        positionStyle.height = `${offsetEnd * 100 - offsetStart * 100}%`;
        break;
      default:
        positionStyle.left = `${offsetStart * 100}%`;
        positionStyle.width = `${offsetEnd * 100 - offsetStart * 100}%`;
    }
    const className = replaceCls || clsx(trackPrefixCls, {
      [`${trackPrefixCls}-${index + 1}`]: index !== null && range3,
      [`${prefixCls}-track-draggable`]: onStartMove
    }, classNames.track);
    return reactExports.createElement("div", {
      className,
      style: {
        ...positionStyle,
        ...style2
      },
      onMouseDown: onInternalStartMove,
      onTouchStart: onInternalStartMove
    });
  };
  const Tracks = (props) => {
    const {
      prefixCls,
      style: style2,
      values,
      startPoint,
      onStartMove
    } = props;
    const {
      included,
      range: range3,
      min,
      styles,
      classNames
    } = reactExports.useContext(SliderContext);
    const trackList = reactExports.useMemo(() => {
      if (!range3) {
        if (values.length === 0) {
          return [];
        }
        const startValue = startPoint ?? min;
        const endValue = values[0];
        return [{
          start: Math.min(startValue, endValue),
          end: Math.max(startValue, endValue)
        }];
      }
      const list2 = [];
      for (let i2 = 0; i2 < values.length - 1; i2 += 1) {
        list2.push({
          start: values[i2],
          end: values[i2 + 1]
        });
      }
      return list2;
    }, [values, range3, startPoint, min]);
    if (!included) {
      return null;
    }
    const tracksNode = trackList?.length && (classNames.tracks || styles.tracks) ? reactExports.createElement(Track, {
      index: null,
      prefixCls,
      start: trackList[0].start,
      end: trackList[trackList.length - 1].end,
      replaceCls: clsx(classNames.tracks, `${prefixCls}-tracks`),
      style: styles.tracks
    }) : null;
    return reactExports.createElement(reactExports.Fragment, null, tracksNode, trackList.map(({
      start,
      end
    }, index) => reactExports.createElement(Track, {
      index,
      prefixCls,
      style: {
        ...getIndex(style2, index),
        ...styles.track
      },
      start,
      end,
      key: index,
      onStartMove
    })));
  };
  const REMOVE_DIST = 130;
  function getPosition(e) {
    const obj = "targetTouches" in e ? e.targetTouches[0] : e;
    return {
      pageX: obj.pageX,
      pageY: obj.pageY
    };
  }
  function useDrag(containerRef, direction, rawValues, min, max, formatValue, triggerChange, finishChange, offsetValues, editable, minCount) {
    const [draggingValue, setDraggingValue] = reactExports.useState(null);
    const [draggingIndex, setDraggingIndex] = reactExports.useState(-1);
    const [draggingDelete, setDraggingDelete] = reactExports.useState(false);
    const [cacheValues, setCacheValues] = reactExports.useState(rawValues);
    const [originValues, setOriginValues] = reactExports.useState(rawValues);
    const mouseMoveEventRef = reactExports.useRef(null);
    const mouseUpEventRef = reactExports.useRef(null);
    const touchEventTargetRef = reactExports.useRef(null);
    const {
      onDragStart,
      onDragChange
    } = reactExports.useContext(UnstableContext);
    useLayoutEffect(() => {
      if (draggingIndex === -1) {
        setCacheValues(rawValues);
      }
    }, [rawValues, draggingIndex]);
    reactExports.useEffect(() => () => {
      document.removeEventListener("mousemove", mouseMoveEventRef.current);
      document.removeEventListener("mouseup", mouseUpEventRef.current);
      if (touchEventTargetRef.current) {
        touchEventTargetRef.current.removeEventListener("touchmove", mouseMoveEventRef.current);
        touchEventTargetRef.current.removeEventListener("touchend", mouseUpEventRef.current);
      }
    }, []);
    const flushValues = (nextValues, nextValue, deleteMark) => {
      if (nextValue !== void 0) {
        setDraggingValue(nextValue);
      }
      setCacheValues(nextValues);
      let changeValues = nextValues;
      if (deleteMark) {
        changeValues = nextValues.filter((_2, i2) => i2 !== draggingIndex);
      }
      triggerChange(changeValues);
      if (onDragChange) {
        onDragChange({
          rawValues: nextValues,
          deleteIndex: deleteMark ? draggingIndex : -1,
          draggingIndex,
          draggingValue: nextValue
        });
      }
    };
    const updateCacheValue = useEvent$1((valueIndex, offsetPercent, deleteMark) => {
      if (valueIndex === -1) {
        const startValue = originValues[0];
        const endValue = originValues[originValues.length - 1];
        const maxStartOffset = min - startValue;
        const maxEndOffset = max - endValue;
        let offset2 = offsetPercent * (max - min);
        offset2 = Math.max(offset2, maxStartOffset);
        offset2 = Math.min(offset2, maxEndOffset);
        const formatStartValue = formatValue(startValue + offset2);
        offset2 = formatStartValue - startValue;
        const cloneCacheValues = originValues.map((val) => val + offset2);
        flushValues(cloneCacheValues);
      } else {
        const offsetDist = (max - min) * offsetPercent;
        const cloneValues = [...cacheValues];
        cloneValues[valueIndex] = originValues[valueIndex];
        const next2 = offsetValues(cloneValues, offsetDist, valueIndex, "dist");
        flushValues(next2.values, next2.value, deleteMark);
      }
    });
    const onStartMove = (e, valueIndex, startValues) => {
      e.stopPropagation();
      const initialValues = startValues || rawValues;
      const originValue = initialValues[valueIndex];
      setDraggingIndex(valueIndex);
      setDraggingValue(originValue);
      setOriginValues(initialValues);
      setCacheValues(initialValues);
      setDraggingDelete(false);
      const {
        pageX: startX,
        pageY: startY
      } = getPosition(e);
      let deleteMark = false;
      if (onDragStart) {
        onDragStart({
          rawValues: initialValues,
          draggingIndex: valueIndex,
          draggingValue: originValue
        });
      }
      const onMouseMove = (event) => {
        event.preventDefault();
        const {
          pageX: moveX,
          pageY: moveY
        } = getPosition(event);
        const offsetX = moveX - startX;
        const offsetY = moveY - startY;
        const {
          width,
          height
        } = containerRef.current.getBoundingClientRect();
        let offSetPercent;
        let removeDist;
        switch (direction) {
          case "btt":
            offSetPercent = -offsetY / height;
            removeDist = offsetX;
            break;
          case "ttb":
            offSetPercent = offsetY / height;
            removeDist = offsetX;
            break;
          case "rtl":
            offSetPercent = -offsetX / width;
            removeDist = offsetY;
            break;
          default:
            offSetPercent = offsetX / width;
            removeDist = offsetY;
        }
        deleteMark = editable ? Math.abs(removeDist) > REMOVE_DIST && minCount < cacheValues.length : false;
        setDraggingDelete(deleteMark);
        updateCacheValue(valueIndex, offSetPercent, deleteMark);
      };
      const onMouseUp = (event) => {
        event.preventDefault();
        document.removeEventListener("mouseup", onMouseUp);
        document.removeEventListener("mousemove", onMouseMove);
        if (touchEventTargetRef.current) {
          touchEventTargetRef.current.removeEventListener("touchmove", mouseMoveEventRef.current);
          touchEventTargetRef.current.removeEventListener("touchend", mouseUpEventRef.current);
        }
        mouseMoveEventRef.current = null;
        mouseUpEventRef.current = null;
        touchEventTargetRef.current = null;
        finishChange(deleteMark);
        setDraggingIndex(-1);
        setDraggingDelete(false);
      };
      document.addEventListener("mouseup", onMouseUp);
      document.addEventListener("mousemove", onMouseMove);
      e.currentTarget.addEventListener("touchend", onMouseUp);
      e.currentTarget.addEventListener("touchmove", onMouseMove);
      mouseMoveEventRef.current = onMouseMove;
      mouseUpEventRef.current = onMouseUp;
      touchEventTargetRef.current = e.currentTarget;
    };
    const returnValues = reactExports.useMemo(() => {
      const sourceValues = [...rawValues].sort((a2, b) => a2 - b);
      const targetValues = [...cacheValues].sort((a2, b) => a2 - b);
      const counts = {};
      targetValues.forEach((val) => {
        counts[val] = (counts[val] || 0) + 1;
      });
      sourceValues.forEach((val) => {
        counts[val] = (counts[val] || 0) - 1;
      });
      const maxDiffCount = editable ? 1 : 0;
      const diffCount = Object.values(counts).reduce((prev2, next2) => prev2 + Math.abs(next2), 0);
      return diffCount <= maxDiffCount ? cacheValues : rawValues;
    }, [rawValues, cacheValues, editable]);
    return [draggingIndex, draggingValue, draggingDelete, returnValues, onStartMove];
  }
  function useOffset(min, max, step, markList, allowCross, pushable) {
    const formatRangeValue = reactExports.useCallback((val) => Math.max(min, Math.min(max, val)), [min, max]);
    const formatStepValue = reactExports.useCallback((val) => {
      if (step !== null) {
        const stepValue = min + Math.round((formatRangeValue(val) - min) / step) * step;
        const getDecimal = (num) => (String(num).split(".")[1] || "").length;
        const maxDecimal = Math.max(getDecimal(step), getDecimal(max), getDecimal(min));
        const fixedValue = Number(stepValue.toFixed(maxDecimal));
        return min <= fixedValue && fixedValue <= max ? fixedValue : null;
      }
      return null;
    }, [step, min, max, formatRangeValue]);
    const formatValue = reactExports.useCallback((val) => {
      const formatNextValue = formatRangeValue(val);
      const alignValues = markList.map((mark) => mark.value);
      if (step !== null) {
        alignValues.push(formatStepValue(val));
      }
      alignValues.push(min, max);
      let closeValue = alignValues[0];
      let closeDist = max - min;
      alignValues.forEach((alignValue) => {
        const dist2 = Math.abs(formatNextValue - alignValue);
        if (dist2 <= closeDist) {
          closeValue = alignValue;
          closeDist = dist2;
        }
      });
      return closeValue;
    }, [min, max, markList, step, formatRangeValue, formatStepValue]);
    const offsetValue = (values, offset2, valueIndex, mode = "unit") => {
      if (typeof offset2 === "number") {
        let nextValue;
        const originValue = values[valueIndex];
        const targetDistValue = originValue + offset2;
        let potentialValues = [];
        markList.forEach((mark) => {
          potentialValues.push(mark.value);
        });
        potentialValues.push(min, max);
        potentialValues.push(formatStepValue(originValue));
        const sign = offset2 > 0 ? 1 : -1;
        if (mode === "unit") {
          potentialValues.push(formatStepValue(originValue + sign * step));
        } else {
          potentialValues.push(formatStepValue(targetDistValue));
        }
        potentialValues = potentialValues.filter((val) => val !== null).filter((val) => offset2 < 0 ? val <= originValue : val >= originValue);
        if (mode === "unit") {
          potentialValues = potentialValues.filter((val) => val !== originValue);
        }
        const compareValue = mode === "unit" ? originValue : targetDistValue;
        nextValue = potentialValues[0];
        let valueDist = Math.abs(nextValue - compareValue);
        potentialValues.forEach((potentialValue) => {
          const dist2 = Math.abs(potentialValue - compareValue);
          if (dist2 < valueDist) {
            nextValue = potentialValue;
            valueDist = dist2;
          }
        });
        if (nextValue === void 0) {
          return offset2 < 0 ? min : max;
        }
        if (mode === "dist") {
          return nextValue;
        }
        if (Math.abs(offset2) > 1) {
          const cloneValues = [...values];
          cloneValues[valueIndex] = nextValue;
          return offsetValue(cloneValues, offset2 - sign, valueIndex, mode);
        }
        return nextValue;
      } else if (offset2 === "min") {
        return min;
      } else if (offset2 === "max") {
        return max;
      }
    };
    const offsetChangedValue = (values, offset2, valueIndex, mode = "unit") => {
      const originValue = values[valueIndex];
      const nextValue = offsetValue(values, offset2, valueIndex, mode);
      return {
        value: nextValue,
        changed: nextValue !== originValue
      };
    };
    const needPush = (dist2) => {
      return pushable === null && dist2 === 0 || typeof pushable === "number" && dist2 < pushable;
    };
    const offsetValues = (values, offset2, valueIndex, mode = "unit") => {
      const nextValues = values.map(formatValue);
      const originValue = nextValues[valueIndex];
      const nextValue = offsetValue(nextValues, offset2, valueIndex, mode);
      nextValues[valueIndex] = nextValue;
      if (allowCross === false) {
        const pushNum = pushable || 0;
        if (valueIndex > 0 && nextValues[valueIndex - 1] !== originValue) {
          nextValues[valueIndex] = Math.max(nextValues[valueIndex], nextValues[valueIndex - 1] + pushNum);
        }
        if (valueIndex < nextValues.length - 1 && nextValues[valueIndex + 1] !== originValue) {
          nextValues[valueIndex] = Math.min(nextValues[valueIndex], nextValues[valueIndex + 1] - pushNum);
        }
      } else if (typeof pushable === "number" || pushable === null) {
        for (let i2 = valueIndex + 1; i2 < nextValues.length; i2 += 1) {
          let changed = true;
          while (needPush(nextValues[i2] - nextValues[i2 - 1]) && changed) {
            ({
              value: nextValues[i2],
              changed
            } = offsetChangedValue(nextValues, 1, i2));
          }
        }
        for (let i2 = valueIndex; i2 > 0; i2 -= 1) {
          let changed = true;
          while (needPush(nextValues[i2] - nextValues[i2 - 1]) && changed) {
            ({
              value: nextValues[i2 - 1],
              changed
            } = offsetChangedValue(nextValues, -1, i2 - 1));
          }
        }
        for (let i2 = nextValues.length - 1; i2 > 0; i2 -= 1) {
          let changed = true;
          while (needPush(nextValues[i2] - nextValues[i2 - 1]) && changed) {
            ({
              value: nextValues[i2 - 1],
              changed
            } = offsetChangedValue(nextValues, -1, i2 - 1));
          }
        }
        for (let i2 = 0; i2 < nextValues.length - 1; i2 += 1) {
          let changed = true;
          while (needPush(nextValues[i2 + 1] - nextValues[i2]) && changed) {
            ({
              value: nextValues[i2 + 1],
              changed
            } = offsetChangedValue(nextValues, 1, i2 + 1));
          }
        }
      }
      return {
        value: nextValues[valueIndex],
        values: nextValues
      };
    };
    return [formatValue, offsetValues];
  }
  function useRange(range3) {
    return reactExports.useMemo(() => {
      if (range3 === true || !range3) {
        return [!!range3, false, false, 0];
      }
      const {
        editable,
        draggableTrack,
        minCount,
        maxCount
      } = range3;
      return [true, editable, !editable && draggableTrack, minCount || 0, maxCount];
    }, [range3]);
  }
  const Slider$1 = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls = "rc-slider",
      className,
      style: style2,
      classNames,
      styles,
      id: id2,
disabled = false,
      keyboard = true,
      autoFocus,
      onFocus,
      onBlur,
min = 0,
      max = 100,
      step = 1,
      value,
      defaultValue: defaultValue2,
      range: range3,
      count,
      onChange,
      onBeforeChange,
      onAfterChange,
      onChangeComplete,
allowCross = true,
      pushable = false,
reverse,
      vertical,
included = true,
      startPoint,
      trackStyle,
      handleStyle,
      railStyle,
      dotStyle,
      activeDotStyle,
marks,
      dots,
handleRender,
      activeHandleRender,
      track,
tabIndex = 0,
      ariaLabelForHandle,
      ariaLabelledByForHandle,
      ariaRequired,
      ariaValueTextFormatterForHandle
    } = props;
    const handlesRef = reactExports.useRef(null);
    const containerRef = reactExports.useRef(null);
    const direction = reactExports.useMemo(() => {
      if (vertical) {
        return reverse ? "ttb" : "btt";
      }
      return reverse ? "rtl" : "ltr";
    }, [reverse, vertical]);
    const [rangeEnabled, rangeEditable, rangeDraggableTrack, minCount, maxCount] = useRange(range3);
    const mergedMin = reactExports.useMemo(() => isFinite(min) ? min : 0, [min]);
    const mergedMax = reactExports.useMemo(() => isFinite(max) ? max : 100, [max]);
    const mergedStep = reactExports.useMemo(() => step !== null && step <= 0 ? 1 : step, [step]);
    const mergedPush = reactExports.useMemo(() => {
      if (typeof pushable === "boolean") {
        return pushable ? mergedStep : false;
      }
      return pushable >= 0 ? pushable : false;
    }, [pushable, mergedStep]);
    const markList = reactExports.useMemo(() => {
      return Object.keys(marks || {}).map((key) => {
        const mark = marks[key];
        const markObj = {
          value: Number(key)
        };
        if (mark && typeof mark === "object" && ! reactExports.isValidElement(mark) && ("label" in mark || "style" in mark)) {
          markObj.style = mark.style;
          markObj.label = mark.label;
        } else {
          markObj.label = mark;
        }
        return markObj;
      }).filter(({
        label
      }) => label || typeof label === "number").sort((a2, b) => a2.value - b.value);
    }, [marks]);
    const [formatValue, offsetValues] = useOffset(mergedMin, mergedMax, mergedStep, markList, allowCross, mergedPush);
    const [mergedValue, setValue] = useControlledState(defaultValue2, value);
    const rawValues = reactExports.useMemo(() => {
      const valueList = mergedValue === null || mergedValue === void 0 ? [] : Array.isArray(mergedValue) ? mergedValue : [mergedValue];
      const [val0 = mergedMin] = valueList;
      let returnValues = mergedValue === null ? [] : [val0];
      if (rangeEnabled) {
        returnValues = [...valueList];
        if (count || mergedValue === void 0) {
          const pointCount = count >= 0 ? count + 1 : 2;
          returnValues = returnValues.slice(0, pointCount);
          while (returnValues.length < pointCount) {
            returnValues.push(returnValues[returnValues.length - 1] ?? mergedMin);
          }
        }
        returnValues.sort((a2, b) => a2 - b);
      }
      returnValues.forEach((val, index) => {
        returnValues[index] = formatValue(val);
      });
      return returnValues;
    }, [mergedValue, rangeEnabled, mergedMin, count, formatValue]);
    const getTriggerValue = (triggerValues) => rangeEnabled ? triggerValues : triggerValues[0];
    const triggerChange = useEvent$1((nextValues) => {
      const cloneNextValues = [...nextValues].sort((a2, b) => a2 - b);
      if (onChange && !isEqual$1(cloneNextValues, rawValues, true)) {
        onChange(getTriggerValue(cloneNextValues));
      }
      setValue(cloneNextValues);
    });
    const finishChange = useEvent$1((draggingDelete2) => {
      if (draggingDelete2) {
        handlesRef.current.hideHelp();
      }
      const finishValue = getTriggerValue(rawValues);
      onAfterChange?.(finishValue);
      warningOnce(!onAfterChange, "[rc-slider] `onAfterChange` is deprecated. Please use `onChangeComplete` instead.");
      onChangeComplete?.(finishValue);
    });
    const onDelete = (index) => {
      if (disabled || !rangeEditable || rawValues.length <= minCount) {
        return;
      }
      const cloneNextValues = [...rawValues];
      cloneNextValues.splice(index, 1);
      onBeforeChange?.(getTriggerValue(cloneNextValues));
      triggerChange(cloneNextValues);
      const nextFocusIndex = Math.max(0, index - 1);
      handlesRef.current.hideHelp();
      handlesRef.current.focus(nextFocusIndex);
    };
    const [draggingIndex, draggingValue, draggingDelete, cacheValues, onStartDrag] = useDrag(containerRef, direction, rawValues, mergedMin, mergedMax, formatValue, triggerChange, finishChange, offsetValues, rangeEditable, minCount);
    const changeToCloseValue = (newValue, e) => {
      if (!disabled) {
        const cloneNextValues = [...rawValues];
        let valueIndex = 0;
        let valueBeforeIndex = 0;
        let valueDist = mergedMax - mergedMin;
        rawValues.forEach((val, index) => {
          const dist2 = Math.abs(newValue - val);
          if (dist2 <= valueDist) {
            valueDist = dist2;
            valueIndex = index;
          }
          if (val < newValue) {
            valueBeforeIndex = index;
          }
        });
        let focusIndex = valueIndex;
        if (rangeEditable && valueDist !== 0 && (!maxCount || rawValues.length < maxCount)) {
          cloneNextValues.splice(valueBeforeIndex + 1, 0, newValue);
          focusIndex = valueBeforeIndex + 1;
        } else {
          cloneNextValues[valueIndex] = newValue;
        }
        if (rangeEnabled && !rawValues.length && count === void 0) {
          cloneNextValues.push(newValue);
        }
        const nextValue = getTriggerValue(cloneNextValues);
        onBeforeChange?.(nextValue);
        triggerChange(cloneNextValues);
        if (e) {
          document.activeElement?.blur?.();
          handlesRef.current.focus(focusIndex);
          onStartDrag(e, focusIndex, cloneNextValues);
        } else {
          onAfterChange?.(nextValue);
          warningOnce(!onAfterChange, "[rc-slider] `onAfterChange` is deprecated. Please use `onChangeComplete` instead.");
          onChangeComplete?.(nextValue);
        }
      }
    };
    const onSliderMouseDown = (e) => {
      e.preventDefault();
      const {
        width,
        height,
        left,
        top,
        bottom,
        right
      } = containerRef.current.getBoundingClientRect();
      const {
        clientX,
        clientY
      } = e;
      let percent2;
      switch (direction) {
        case "btt":
          percent2 = (bottom - clientY) / height;
          break;
        case "ttb":
          percent2 = (clientY - top) / height;
          break;
        case "rtl":
          percent2 = (right - clientX) / width;
          break;
        default:
          percent2 = (clientX - left) / width;
      }
      const nextValue = mergedMin + percent2 * (mergedMax - mergedMin);
      changeToCloseValue(formatValue(nextValue), e);
    };
    const [keyboardValue, setKeyboardValue] = reactExports.useState(null);
    const onHandleOffsetChange = (offset2, valueIndex) => {
      if (!disabled) {
        const next2 = offsetValues(rawValues, offset2, valueIndex);
        onBeforeChange?.(getTriggerValue(rawValues));
        triggerChange(next2.values);
        setKeyboardValue(next2.value);
      }
    };
    reactExports.useEffect(() => {
      if (keyboardValue !== null) {
        const valueIndex = rawValues.indexOf(keyboardValue);
        if (valueIndex >= 0) {
          handlesRef.current.focus(valueIndex);
        }
      }
      setKeyboardValue(null);
    }, [keyboardValue]);
    const mergedDraggableTrack = reactExports.useMemo(() => {
      if (rangeDraggableTrack && mergedStep === null) {
        return false;
      }
      return rangeDraggableTrack;
    }, [rangeDraggableTrack, mergedStep]);
    const onStartMove = useEvent$1((e, valueIndex) => {
      onStartDrag(e, valueIndex);
      onBeforeChange?.(getTriggerValue(rawValues));
    });
    const dragging = draggingIndex !== -1;
    reactExports.useEffect(() => {
      if (!dragging) {
        const valueIndex = rawValues.lastIndexOf(draggingValue);
        handlesRef.current.focus(valueIndex);
      }
    }, [dragging]);
    const sortedCacheValues = reactExports.useMemo(() => [...cacheValues].sort((a2, b) => a2 - b), [cacheValues]);
    const [includedStart, includedEnd] = reactExports.useMemo(() => {
      if (!rangeEnabled) {
        return [mergedMin, sortedCacheValues[0]];
      }
      return [sortedCacheValues[0], sortedCacheValues[sortedCacheValues.length - 1]];
    }, [sortedCacheValues, rangeEnabled, mergedMin]);
    reactExports.useImperativeHandle(ref2, () => ({
      focus: () => {
        handlesRef.current.focus(0);
      },
      blur: () => {
        const {
          activeElement
        } = document;
        if (containerRef.current?.contains(activeElement)) {
          activeElement?.blur();
        }
      }
    }));
    reactExports.useEffect(() => {
      if (autoFocus) {
        handlesRef.current.focus(0);
      }
    }, []);
    const context = reactExports.useMemo(() => ({
      min: mergedMin,
      max: mergedMax,
      direction,
      disabled,
      keyboard,
      step: mergedStep,
      included,
      includedStart,
      includedEnd,
      range: rangeEnabled,
      tabIndex,
      ariaLabelForHandle,
      ariaLabelledByForHandle,
      ariaRequired,
      ariaValueTextFormatterForHandle,
      styles: styles || {},
      classNames: classNames || {}
    }), [mergedMin, mergedMax, direction, disabled, keyboard, mergedStep, included, includedStart, includedEnd, rangeEnabled, tabIndex, ariaLabelForHandle, ariaLabelledByForHandle, ariaRequired, ariaValueTextFormatterForHandle, styles, classNames]);
    return reactExports.createElement(SliderContext.Provider, {
      value: context
    }, reactExports.createElement("div", {
      ref: containerRef,
      className: clsx(prefixCls, className, {
        [`${prefixCls}-disabled`]: disabled,
        [`${prefixCls}-vertical`]: vertical,
        [`${prefixCls}-horizontal`]: !vertical,
        [`${prefixCls}-with-marks`]: markList.length
      }),
      style: style2,
      onMouseDown: onSliderMouseDown,
      id: id2
    }, reactExports.createElement("div", {
      className: clsx(`${prefixCls}-rail`, classNames?.rail),
      style: {
        ...railStyle,
        ...styles?.rail
      }
    }), track !== false && reactExports.createElement(Tracks, {
      prefixCls,
      style: trackStyle,
      values: rawValues,
      startPoint,
      onStartMove: mergedDraggableTrack ? onStartMove : void 0
    }), reactExports.createElement(Steps, {
      prefixCls,
      marks: markList,
      dots,
      style: dotStyle,
      activeStyle: activeDotStyle
    }), reactExports.createElement(Handles, {
      ref: handlesRef,
      prefixCls,
      style: handleStyle,
      values: cacheValues,
      draggingIndex,
      draggingDelete,
      onStartMove,
      onOffsetChange: onHandleOffsetChange,
      onFocus,
      onBlur,
      handleRender,
      activeHandleRender,
      onChangeComplete: finishChange,
      onDelete: rangeEditable ? onDelete : void 0
    }), reactExports.createElement(Marks, {
      prefixCls,
      marks: markList,
      onClick: changeToCloseValue
    })));
  });
  const SliderInternalContext = reactExports.createContext({});
  const SliderTooltip = reactExports.forwardRef((props, ref2) => {
    const {
      open: open2,
      draggingDelete,
      value
    } = props;
    const innerRef = reactExports.useRef(null);
    const mergedOpen = open2 && !draggingDelete;
    const rafRef = reactExports.useRef(null);
    function cancelKeepAlign() {
      wrapperRaf.cancel(rafRef.current);
      rafRef.current = null;
    }
    function keepAlign() {
      rafRef.current = wrapperRaf(() => {
        innerRef.current?.forceAlign();
        rafRef.current = null;
      });
    }
    reactExports.useEffect(() => {
      if (mergedOpen) {
        keepAlign();
      } else {
        cancelKeepAlign();
      }
      return cancelKeepAlign;
    }, [mergedOpen, props.title, value]);
    return reactExports.createElement(Tooltip, {
      ref: composeRef(innerRef, ref2),
      ...props,
      open: mergedOpen
    });
  });
  const genBaseStyle$2 = (token2) => {
    const {
      componentCls,
      antCls,
      controlSize,
      dotSize,
      marginFull,
      marginPart,
      colorFillContentHover,
      handleColorDisabled,
      calc,
      handleSize,
      handleSizeHover,
      handleActiveColor,
      handleActiveOutlineColor,
      handleLineWidth,
      handleLineWidthHover,
      motionDurationMid
    } = token2;
    return {
      [componentCls]: {
        ...resetComponent(token2),
        position: "relative",
        height: controlSize,
        margin: `${unit$1(marginPart)} ${unit$1(marginFull)}`,
        padding: 0,
        cursor: "pointer",
        touchAction: "none",
        "&-vertical": {
          margin: `${unit$1(marginFull)} ${unit$1(marginPart)}`
        },
        [`${componentCls}-rail`]: {
          position: "absolute",
          backgroundColor: token2.railBg,
          borderRadius: token2.borderRadiusXS,
          transition: `background-color ${motionDurationMid}`
        },
        [`${componentCls}-track,${componentCls}-tracks`]: {
          position: "absolute",
          transition: `background-color ${motionDurationMid}`
        },
        [`${componentCls}-track`]: {
          backgroundColor: token2.trackBg,
          borderRadius: token2.borderRadiusXS
        },
        [`${componentCls}-track-draggable`]: {
          boxSizing: "content-box",
          backgroundClip: "content-box",
          border: "solid rgba(0,0,0,0)"
        },
        "&:hover": {
          [`${componentCls}-rail`]: {
            backgroundColor: token2.railHoverBg
          },
          [`${componentCls}-track`]: {
            backgroundColor: token2.trackHoverBg
          },
          [`${componentCls}-dot`]: {
            borderColor: colorFillContentHover
          },
          [`${componentCls}-handle::after`]: {
            boxShadow: `0 0 0 ${unit$1(handleLineWidth)} ${token2.colorPrimaryBorderHover}`
          },
          [`${componentCls}-dot-active`]: {
            borderColor: token2.dotActiveBorderColor
          }
        },
        [`${componentCls}-handle`]: {
          position: "absolute",
          width: handleSize,
          height: handleSize,
          outline: "none",
          userSelect: "none",
"&-dragging-delete": {
            opacity: 0
          },
"&::before": {
            content: '""',
            position: "absolute",
            insetInlineStart: calc(handleLineWidth).mul(-1).equal(),
            insetBlockStart: calc(handleLineWidth).mul(-1).equal(),
            width: calc(handleSize).add(calc(handleLineWidth).mul(2)).equal(),
            height: calc(handleSize).add(calc(handleLineWidth).mul(2)).equal(),
            backgroundColor: "transparent"
          },
          "&::after": {
            content: '""',
            position: "absolute",
            insetBlockStart: 0,
            insetInlineStart: 0,
            width: handleSize,
            height: handleSize,
            backgroundColor: token2.colorBgElevated,
            boxShadow: `0 0 0 ${unit$1(handleLineWidth)} ${token2.handleColor}`,
            outline: `0px solid transparent`,
            borderRadius: "50%",
            cursor: "pointer",
            transition: ["inset-inline-start", "inset-block-start", "width", "height", "box-shadow", "outline"].map((prop) => `${prop} ${motionDurationMid}`).join(", ")
          },
          "&:hover, &:active, &:focus": {
            "&::before": {
              insetInlineStart: calc(handleSizeHover).sub(handleSize).div(2).add(handleLineWidthHover).mul(-1).equal(),
              insetBlockStart: calc(handleSizeHover).sub(handleSize).div(2).add(handleLineWidthHover).mul(-1).equal(),
              width: calc(handleSizeHover).add(calc(handleLineWidthHover).mul(2)).equal(),
              height: calc(handleSizeHover).add(calc(handleLineWidthHover).mul(2)).equal()
            },
            "&::after": {
              boxShadow: `0 0 0 ${unit$1(handleLineWidthHover)} ${handleActiveColor}`,
              outline: `6px solid ${handleActiveOutlineColor}`,
              width: handleSizeHover,
              height: handleSizeHover,
              insetInlineStart: token2.calc(handleSize).sub(handleSizeHover).div(2).equal(),
              insetBlockStart: token2.calc(handleSize).sub(handleSizeHover).div(2).equal()
            }
          }
        },
        [`&-lock ${componentCls}-handle`]: {
          "&::before, &::after": {
            transition: "none"
          }
        },
        [`${componentCls}-mark`]: {
          position: "absolute",
          fontSize: token2.fontSize
        },
        [`${componentCls}-mark-text`]: {
          position: "absolute",
          display: "inline-block",
          color: token2.colorTextDescription,
          textAlign: "center",
          wordBreak: "keep-all",
          cursor: "pointer",
          userSelect: "none",
          "&-active": {
            color: token2.colorText
          }
        },
        [`${componentCls}-step`]: {
          position: "absolute",
          background: "transparent",
          pointerEvents: "none"
        },
        [`${componentCls}-dot`]: {
          position: "absolute",
          width: dotSize,
          height: dotSize,
          backgroundColor: token2.colorBgElevated,
          border: `${unit$1(handleLineWidth)} solid ${token2.dotBorderColor}`,
          borderRadius: "50%",
          cursor: "pointer",
          transition: `border-color ${token2.motionDurationSlow}`,
          pointerEvents: "auto",
          "&-active": {
            borderColor: token2.dotActiveBorderColor
          }
        },
        [`&${componentCls}-disabled`]: {
          cursor: "not-allowed",
          [`${componentCls}-rail`]: {
            backgroundColor: `${token2.railBg} !important`
          },
          [`${componentCls}-track`]: {
            backgroundColor: `${token2.trackBgDisabled} !important`
          },
          [`
          ${componentCls}-dot
        `]: {
            backgroundColor: token2.colorBgElevated,
            borderColor: token2.trackBgDisabled,
            boxShadow: "none",
            cursor: "not-allowed"
          },
          [`${componentCls}-handle::after`]: {
            backgroundColor: token2.colorBgElevated,
            cursor: "not-allowed",
            width: handleSize,
            height: handleSize,
            boxShadow: `0 0 0 ${unit$1(handleLineWidth)} ${handleColorDisabled}`,
            insetInlineStart: 0,
            insetBlockStart: 0
          },
          [`
          ${componentCls}-mark-text,
          ${componentCls}-dot
        `]: {
            cursor: `not-allowed !important`
          }
        },
        [`&-tooltip ${antCls}-tooltip-container`]: {
          minWidth: "unset"
        }
      }
    };
  };
  const genDirectionStyle = (token2, horizontal) => {
    const {
      componentCls,
      railSize,
      handleSize,
      dotSize,
      marginFull,
      calc
    } = token2;
    const railPadding = horizontal ? "paddingBlock" : "paddingInline";
    const full = horizontal ? "width" : "height";
    const part = horizontal ? "height" : "width";
    const handlePos = horizontal ? "insetBlockStart" : "insetInlineStart";
    const markInset = horizontal ? "top" : "insetInlineStart";
    const handlePosSize = calc(railSize).mul(3).sub(handleSize).div(2).equal();
    const draggableBorderSize = calc(handleSize).sub(railSize).div(2).equal();
    const draggableBorder = horizontal ? {
      borderWidth: `${unit$1(draggableBorderSize)} 0`,
      transform: `translateY(${unit$1(calc(draggableBorderSize).mul(-1).equal())})`
    } : {
      borderWidth: `0 ${unit$1(draggableBorderSize)}`,
      transform: `translateX(${unit$1(token2.calc(draggableBorderSize).mul(-1).equal())})`
    };
    return {
      [railPadding]: railSize,
      [part]: calc(railSize).mul(3).equal(),
      [`${componentCls}-rail`]: {
        [full]: "100%",
        [part]: railSize
      },
      [`${componentCls}-track,${componentCls}-tracks`]: {
        [part]: railSize
      },
      [`${componentCls}-track-draggable`]: {
        ...draggableBorder
      },
      [`${componentCls}-handle`]: {
        [handlePos]: handlePosSize
      },
      [`${componentCls}-mark`]: {
insetInlineStart: 0,
        top: 0,
[markInset]: calc(railSize).mul(3).add(horizontal ? 0 : marginFull).equal(),
        [full]: "100%"
      },
      [`${componentCls}-step`]: {
insetInlineStart: 0,
        top: 0,
        [markInset]: railSize,
        [full]: "100%",
        [part]: railSize
      },
      [`${componentCls}-dot`]: {
        position: "absolute",
        [handlePos]: calc(railSize).sub(dotSize).div(2).equal()
      }
    };
  };
  const genHorizontalStyle = (token2) => {
    const {
      componentCls,
      marginPartWithMark
    } = token2;
    return {
      [`${componentCls}-horizontal`]: {
        ...genDirectionStyle(token2, true),
        [`&${componentCls}-with-marks`]: {
          marginBottom: marginPartWithMark
        }
      }
    };
  };
  const genVerticalStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-vertical`]: {
        ...genDirectionStyle(token2, false),
        height: "100%"
      }
    };
  };
  const prepareComponentToken$9 = (token2) => {
    const increaseHandleWidth = 1;
    const controlSize = token2.controlHeightLG / 4;
    const controlSizeHover = token2.controlHeightSM / 2;
    const handleLineWidth = token2.lineWidth + increaseHandleWidth;
    const handleLineWidthHover = token2.lineWidth + increaseHandleWidth * 1.5;
    const handleActiveColor = token2.colorPrimary;
    const handleActiveOutlineColor = new FastColor(handleActiveColor).setA(0.2).toRgbString();
    return {
      controlSize,
      railSize: 4,
      handleSize: controlSize,
      handleSizeHover: controlSizeHover,
      dotSize: 8,
      handleLineWidth,
      handleLineWidthHover,
      railBg: token2.colorFillTertiary,
      railHoverBg: token2.colorFillSecondary,
      trackBg: token2.colorPrimaryBorder,
      trackHoverBg: token2.colorPrimaryBorderHover,
      handleColor: token2.colorPrimaryBorder,
      handleActiveColor,
      handleActiveOutlineColor,
      handleColorDisabled: new FastColor(token2.colorTextDisabled).onBackground(token2.colorBgContainer).toHexString(),
      dotBorderColor: token2.colorBorderSecondary,
      dotActiveBorderColor: token2.colorPrimaryBorder,
      trackBgDisabled: token2.colorBgContainerDisabled
    };
  };
  const useStyle$f = genStyleHooks("Slider", (token2) => {
    const sliderToken = merge$1(token2, {
      marginPart: token2.calc(token2.controlHeight).sub(token2.controlSize).div(2).equal(),
      marginFull: token2.calc(token2.controlSize).div(2).equal(),
      marginPartWithMark: token2.calc(token2.controlHeightLG).sub(token2.controlSize).equal()
    });
    return [genBaseStyle$2(sliderToken), genHorizontalStyle(sliderToken), genVerticalStyle(sliderToken)];
  }, prepareComponentToken$9);
  function useRafLock() {
    const [state2, setState] = reactExports.useState(false);
    const rafRef = reactExports.useRef(null);
    const cleanup2 = () => {
      wrapperRaf.cancel(rafRef.current);
    };
    const setDelayState = (nextState) => {
      cleanup2();
      if (nextState) {
        setState(nextState);
      } else {
        rafRef.current = wrapperRaf(() => {
          setState(nextState);
        });
      }
    };
    reactExports.useEffect(() => cleanup2, []);
    return [state2, setDelayState];
  }
  function getTipFormatter(tipFormatter) {
    if (tipFormatter || tipFormatter === null) {
      return tipFormatter;
    }
    return (val) => typeof val === "number" ? val.toString() : "";
  }
  const Slider = React.forwardRef((props, ref2) => {
    const {
      prefixCls: customizePrefixCls,
      range: range3,
      className,
      rootClassName,
      style: style2,
      disabled,
tooltip = {},
      onChangeComplete,
      classNames,
      styles,
      vertical,
      orientation,
      ...restProps
    } = props;
    const [, mergedVertical] = useOrientation(orientation, vertical);
    const {
      getPrefixCls,
      direction: contextDirection,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles,
      getPopupContainer
    } = useComponentConfig("slider");
    const contextDisabled = React.useContext(DisabledContext);
    const mergedDisabled = disabled ?? contextDisabled;
    const mergedProps = {
      ...props,
      disabled: mergedDisabled,
      vertical: mergedVertical
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const {
      handleRender: contextHandleRender,
      direction: internalContextDirection
    } = React.useContext(SliderInternalContext);
    const mergedDirection = internalContextDirection || contextDirection;
    const isRTL = mergedDirection === "rtl";
    const [hoverOpen, setHoverOpen] = useRafLock();
    const [focusOpen, setFocusOpen] = useRafLock();
    const tooltipProps = {
      ...tooltip
    };
    const {
      open: tooltipOpen,
      placement: tooltipPlacement,
      getPopupContainer: getTooltipPopupContainer,
      prefixCls: customizeTooltipPrefixCls,
      formatter: tipFormatter
    } = tooltipProps;
    const lockOpen = tooltipOpen;
    const activeOpen = (hoverOpen || focusOpen) && lockOpen !== false;
    const mergedTipFormatter = getTipFormatter(tipFormatter);
    const [dragging, setDragging] = useRafLock();
    const onInternalChangeComplete = (nextValues) => {
      onChangeComplete?.(nextValues);
      setDragging(false);
    };
    const getTooltipPlacement = (placement, vert) => {
      if (placement) {
        return placement;
      }
      if (!vert) {
        return "top";
      }
      return isRTL ? "left" : "right";
    };
    const prefixCls = getPrefixCls("slider", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$f(prefixCls);
    const rootClassNames = clsx(className, contextClassName, mergedClassNames.root, rootClassName, {
      [`${prefixCls}-rtl`]: isRTL,
      [`${prefixCls}-lock`]: dragging
    }, hashId, cssVarCls);
    if (isRTL && !mergedVertical) {
      restProps.reverse = !restProps.reverse;
    }
    React.useEffect(() => {
      const onMouseUp = () => {
        wrapperRaf(() => {
          setFocusOpen(false);
        }, 1);
      };
      document.addEventListener("mouseup", onMouseUp);
      return () => {
        document.removeEventListener("mouseup", onMouseUp);
      };
    }, []);
    const useActiveTooltipHandle = range3 && !lockOpen;
    const handleRender = contextHandleRender || ((node2, info) => {
      const {
        index
      } = info;
      const nodeProps = node2.props;
      function proxyEvent(eventName, event, triggerRestPropsEvent) {
        if (triggerRestPropsEvent) {
          restProps[eventName]?.(event);
        }
        nodeProps[eventName]?.(event);
      }
      const passedProps = {
        ...nodeProps,
        onMouseEnter: (e) => {
          setHoverOpen(true);
          proxyEvent("onMouseEnter", e);
        },
        onMouseLeave: (e) => {
          setHoverOpen(false);
          proxyEvent("onMouseLeave", e);
        },
        onMouseDown: (e) => {
          setFocusOpen(true);
          setDragging(true);
          proxyEvent("onMouseDown", e);
        },
        onFocus: (e) => {
          setFocusOpen(true);
          restProps.onFocus?.(e);
          proxyEvent("onFocus", e, true);
        },
        onBlur: (e) => {
          setFocusOpen(false);
          restProps.onBlur?.(e);
          proxyEvent("onBlur", e, true);
        }
      };
      const cloneNode = React.cloneElement(node2, passedProps);
      const open2 = (!!lockOpen || activeOpen) && mergedTipFormatter !== null;
      if (!useActiveTooltipHandle) {
        return React.createElement(SliderTooltip, {
          ...tooltipProps,
          prefixCls: getPrefixCls("tooltip", customizeTooltipPrefixCls),
          title: mergedTipFormatter ? mergedTipFormatter(info.value) : "",
          value: info.value,
          open: open2,
          placement: getTooltipPlacement(tooltipPlacement, mergedVertical),
          key: index,
          classNames: {
            root: `${prefixCls}-tooltip`
          },
          getPopupContainer: getTooltipPopupContainer || getPopupContainer
        }, cloneNode);
      }
      return cloneNode;
    });
    const activeHandleRender = useActiveTooltipHandle ? (handle, info) => {
      const cloneNode = React.cloneElement(handle, {
        style: {
          ...handle.props.style,
          visibility: "hidden"
        }
      });
      return React.createElement(SliderTooltip, {
        ...tooltipProps,
        prefixCls: getPrefixCls("tooltip", customizeTooltipPrefixCls),
        title: mergedTipFormatter ? mergedTipFormatter(info.value) : "",
        open: mergedTipFormatter !== null && activeOpen,
        placement: getTooltipPlacement(tooltipPlacement, mergedVertical),
        key: "tooltip",
        classNames: {
          root: `${prefixCls}-tooltip`
        },
        getPopupContainer: getTooltipPopupContainer || getPopupContainer,
        draggingDelete: info.draggingDelete
      }, cloneNode);
    } : void 0;
    const rootStyle = {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    };
    return (

React.createElement(Slider$1, {
        ...restProps,
        classNames: mergedClassNames,
        styles: mergedStyles,
        step: restProps.step,
        range: range3,
        className: rootClassNames,
        style: rootStyle,
        disabled: mergedDisabled,
        vertical: mergedVertical,
        ref: ref2,
        prefixCls,
        handleRender,
        activeHandleRender,
        onChangeComplete: onInternalChangeComplete
      })
    );
  });
  const GradientColorSlider = (props) => {
    const {
      prefixCls,
      colors: colors2,
      type: type4,
      color: color2,
      range: range3 = false,
      className,
      activeIndex,
      onActive,
      onDragStart,
      onDragChange,
      onKeyDelete,
      ...restProps
    } = props;
    const sliderProps = {
      ...restProps,
      track: false
    };
    const linearCss = reactExports.useMemo(() => {
      const colorsStr = colors2.map((c2) => `${c2.color} ${c2.percent}%`).join(", ");
      return `linear-gradient(90deg, ${colorsStr})`;
    }, [colors2]);
    const pointColor = reactExports.useMemo(() => {
      if (!color2 || !type4) {
        return null;
      }
      if (type4 === "alpha") {
        return color2.toRgbString();
      }
      return `hsl(${color2.toHsb().h}, 100%, 50%)`;
    }, [color2, type4]);
    const onInternalDragStart = useEvent$1(onDragStart);
    const onInternalDragChange = useEvent$1(onDragChange);
    const unstableContext = reactExports.useMemo(() => ({
      onDragStart: onInternalDragStart,
      onDragChange: onInternalDragChange
    }), []);
    const handleRender = useEvent$1((ori, info) => {
      const {
        onFocus,
        style: style2,
        className: handleCls,
        onKeyDown
      } = ori.props;
      const mergedStyle = {
        ...style2
      };
      if (type4 === "gradient") {
        mergedStyle.background = getGradientPercentColor(colors2, info.value);
      }
      return reactExports.cloneElement(ori, {
        onFocus: (e) => {
          onActive?.(info.index);
          onFocus?.(e);
        },
        style: mergedStyle,
        className: clsx(handleCls, {
          [`${prefixCls}-slider-handle-active`]: activeIndex === info.index
        }),
        onKeyDown: (e) => {
          if ((e.key === "Delete" || e.key === "Backspace") && onKeyDelete) {
            onKeyDelete(info.index);
          }
          onKeyDown?.(e);
        }
      });
    });
    const sliderContext = reactExports.useMemo(() => ({
      direction: "ltr",
      handleRender
    }), []);
    return reactExports.createElement(SliderInternalContext.Provider, {
      value: sliderContext
    }, reactExports.createElement(UnstableContext.Provider, {
      value: unstableContext
    }, reactExports.createElement(Slider, {
      ...sliderProps,
      className: clsx(className, `${prefixCls}-slider`),
      tooltip: {
        open: false
      },
      range: {
        editable: range3,
        minCount: 2
      },
      styles: {
        rail: {
          background: linearCss
        },
        handle: pointColor ? {
          background: pointColor
        } : {}
      },
      classNames: {
        rail: `${prefixCls}-slider-rail`,
        handle: `${prefixCls}-slider-handle`
      }
    })));
  };
  const SingleColorSlider = (props) => {
    const {
      value,
      onChange,
      onChangeComplete
    } = props;
    const singleOnChange = (v) => onChange(v[0]);
    const singleOnChangeComplete = (v) => onChangeComplete(v[0]);
    return reactExports.createElement(GradientColorSlider, {
      ...props,
      value: [value],
      onChange: singleOnChange,
      onChangeComplete: singleOnChangeComplete
    });
  };
  function sortColors(colors2) {
    return _toConsumableArray(colors2).sort((a2, b) => a2.percent - b.percent);
  }
  const GradientColorBar = (props) => {
    const {
      prefixCls,
      mode,
      onChange,
      onChangeComplete,
      onActive,
      activeIndex,
      onGradientDragging,
      colors: colors2
    } = props;
    const isGradient = mode === "gradient";
    const colorList = reactExports.useMemo(() => colors2.map((info) => ({
      percent: info.percent,
      color: info.color.toRgbString()
    })), [colors2]);
    const values = reactExports.useMemo(() => colorList.map((info) => info.percent), [colorList]);
    const colorsRef = reactExports.useRef(colorList);
    const onDragStart = ({
      rawValues,
      draggingIndex,
      draggingValue
    }) => {
      if (rawValues.length > colorList.length) {
        const newPointColor = getGradientPercentColor(colorList, draggingValue);
        const nextColors = _toConsumableArray(colorList);
        nextColors.splice(draggingIndex, 0, {
          percent: draggingValue,
          color: newPointColor
        });
        colorsRef.current = nextColors;
      } else {
        colorsRef.current = colorList;
      }
      onGradientDragging(true);
      onChange(new AggregationColor(sortColors(colorsRef.current)), true);
    };
    const onDragChange = ({
      deleteIndex,
      draggingIndex,
      draggingValue
    }) => {
      let nextColors = _toConsumableArray(colorsRef.current);
      if (deleteIndex !== -1) {
        nextColors.splice(deleteIndex, 1);
      } else {
        nextColors[draggingIndex] = {
          ...nextColors[draggingIndex],
          percent: draggingValue
        };
        nextColors = sortColors(nextColors);
      }
      onChange(new AggregationColor(nextColors), true);
    };
    const onKeyDelete = (index) => {
      const nextColors = _toConsumableArray(colorList);
      nextColors.splice(index, 1);
      const nextColor = new AggregationColor(nextColors);
      onChange(nextColor);
      onChangeComplete(nextColor);
    };
    const onInternalChangeComplete = (nextValues) => {
      onChangeComplete(new AggregationColor(colorList));
      if (activeIndex >= nextValues.length) {
        onActive(nextValues.length - 1);
      }
      onGradientDragging(false);
    };
    if (!isGradient) {
      return null;
    }
    return reactExports.createElement(GradientColorSlider, {
      min: 0,
      max: 100,
      prefixCls,
      className: `${prefixCls}-gradient-slider`,
      colors: colorList,
      color: null,
      value: values,
      range: true,
      onChangeComplete: onInternalChangeComplete,
      disabled: false,
      type: "gradient",
activeIndex,
      onActive,
onDragStart,
      onDragChange,
      onKeyDelete
    });
  };
  const GradientColorBar$1 = reactExports.memo(GradientColorBar);
  const components = {
    slider: SingleColorSlider
  };
  const PanelPicker = () => {
    const panelPickerContext = reactExports.useContext(PanelPickerContext);
    const {
      mode,
      onModeChange,
      modeOptions,
      prefixCls,
      allowClear,
      value,
      disabledAlpha,
      onChange,
      onClear,
      onChangeComplete,
      activeIndex,
      gradientDragging,
      ...injectProps
    } = panelPickerContext;
    const colors2 = React.useMemo(() => {
      if (!value.cleared) {
        return value.getColors();
      }
      return [{
        percent: 0,
        color: new AggregationColor("")
      }, {
        percent: 100,
        color: new AggregationColor("")
      }];
    }, [value]);
    const isSingle = !value.isGradient();
    const [lockedColor, setLockedColor] = React.useState(value);
    useLayoutEffect(() => {
      if (!isSingle) {
        setLockedColor(colors2[activeIndex]?.color);
      }
    }, [isSingle, colors2, gradientDragging, activeIndex]);
    const activeColor = React.useMemo(() => {
      if (isSingle) {
        return value;
      }
      if (gradientDragging) {
        return lockedColor;
      }
      return colors2[activeIndex]?.color;
    }, [colors2, value, activeIndex, isSingle, lockedColor, gradientDragging]);
    const [pickerColor, setPickerColor] = React.useState(activeColor);
    const [forceSync, setForceSync] = useForceUpdate();
    const mergedPickerColor = pickerColor?.equals(activeColor) ? activeColor : pickerColor;
    useLayoutEffect(() => {
      setPickerColor(activeColor);
    }, [forceSync, activeColor?.toHexString()]);
    const fillColor = (nextColor, info) => {
      let submitColor = generateColor(nextColor);
      if (value.cleared) {
        const rgb = submitColor.toRgb();
        if (!rgb.r && !rgb.g && !rgb.b && info) {
          const {
            type: infoType,
            value: infoValue = 0
          } = info;
          submitColor = new AggregationColor({
            h: infoType === "hue" ? infoValue : 0,
            s: 1,
            b: 1,
            a: infoType === "alpha" ? infoValue / 100 : 1
          });
        } else {
          submitColor = genAlphaColor(submitColor);
        }
      }
      if (mode === "single") {
        return submitColor;
      }
      const nextColors = _toConsumableArray(colors2);
      nextColors[activeIndex] = {
        ...nextColors[activeIndex],
        color: submitColor
      };
      return new AggregationColor(nextColors);
    };
    const onPickerChange = (colorValue, fromPicker, info) => {
      const nextColor = fillColor(colorValue, info);
      setPickerColor(nextColor.isGradient() ? nextColor.getColors()[activeIndex].color : nextColor);
      onChange(nextColor, fromPicker);
    };
    const onInternalChangeComplete = (nextColor, info) => {
      onChangeComplete(fillColor(nextColor, info));
      setForceSync();
    };
    const onInputChange = (colorValue) => {
      onChange(fillColor(colorValue));
    };
    let operationNode = null;
    const showMode = modeOptions.length > 1;
    if (allowClear || showMode) {
      operationNode = React.createElement("div", {
        className: `${prefixCls}-operation`
      }, showMode && React.createElement(Segmented, {
        size: "small",
        options: modeOptions,
        value: mode,
        onChange: onModeChange
      }), React.createElement(ColorClear, {
        prefixCls,
        value,
        onChange: (clearColor) => {
          onChange(clearColor);
          onClear?.();
        },
        ...injectProps
      }));
    }
    return React.createElement(React.Fragment, null, operationNode, React.createElement(GradientColorBar$1, {
      ...panelPickerContext,
      colors: colors2
    }), React.createElement(ColorPicker$1, {
      prefixCls,
      value: mergedPickerColor?.toHsb(),
      disabledAlpha,
      onChange: (colorValue, info) => {
        onPickerChange(colorValue, true, info);
      },
      onChangeComplete: (colorValue, info) => {
        onInternalChangeComplete(colorValue, info);
      },
      components
    }), React.createElement(ColorInput, {
      value: activeColor,
      onChange: onInputChange,
      prefixCls,
      disabledAlpha,
      ...injectProps
    }));
  };
  const PanelPresets = () => {
    const {
      prefixCls,
      value,
      presets,
      onChange
    } = reactExports.useContext(PanelPresetsContext);
    return Array.isArray(presets) ? React.createElement(ColorPresets, {
      value,
      presets,
      prefixCls,
      onChange
    }) : null;
  };
  const ColorPickerPanel = (props) => {
    const {
      prefixCls,
      presets,
      panelRender,
      value,
      onChange,
      onClear,
      allowClear,
      disabledAlpha,
      mode,
      onModeChange,
      modeOptions,
      onChangeComplete,
      activeIndex,
      onActive,
      format: format2,
      onFormatChange,
      gradientDragging,
      onGradientDragging,
      disabledFormat
    } = props;
    const colorPickerPanelPrefixCls = `${prefixCls}-inner`;
    const panelContext = React.useMemo(() => ({
      prefixCls,
      value,
      onChange,
      onClear,
      allowClear,
      disabledAlpha,
      mode,
      onModeChange,
      modeOptions,
      onChangeComplete,
      activeIndex,
      onActive,
      format: format2,
      onFormatChange,
      gradientDragging,
      onGradientDragging,
      disabledFormat
    }), [prefixCls, value, onChange, onClear, allowClear, disabledAlpha, mode, onModeChange, modeOptions, onChangeComplete, activeIndex, onActive, format2, onFormatChange, gradientDragging, onGradientDragging, disabledFormat]);
    const presetContext = React.useMemo(() => ({
      prefixCls,
      value,
      presets,
      onChange
    }), [prefixCls, value, presets, onChange]);
    const innerPanel = React.createElement("div", {
      className: `${colorPickerPanelPrefixCls}-content`
    }, React.createElement(PanelPicker, null), Array.isArray(presets) && React.createElement(Divider, null), React.createElement(PanelPresets, null));
    return React.createElement(PanelPickerContext.Provider, {
      value: panelContext
    }, React.createElement(PanelPresetsContext.Provider, {
      value: presetContext
    }, React.createElement("div", {
      className: colorPickerPanelPrefixCls
    }, typeof panelRender === "function" ? panelRender(innerPanel, {
      components: {
        Picker: PanelPicker,
        Presets: PanelPresets
      }
    }) : innerPanel)));
  };
  const ColorTrigger = reactExports.forwardRef((props, ref2) => {
    const {
      color: color2,
      prefixCls,
      open: open2,
      disabled,
      format: format2,
      className,
      style: style2,
      classNames,
      styles,
      showText,
      activeIndex,
      ...rest
    } = props;
    const colorTriggerPrefixCls = `${prefixCls}-trigger`;
    const colorTextPrefixCls = `${colorTriggerPrefixCls}-text`;
    const colorTextCellPrefixCls = `${colorTextPrefixCls}-cell`;
    const [locale2] = useLocale("ColorPicker");
    const desc = React.useMemo(() => {
      if (!showText) {
        return "";
      }
      if (typeof showText === "function") {
        return showText(color2);
      }
      if (color2.cleared) {
        return locale2.transparent;
      }
      if (color2.isGradient()) {
        return color2.getColors().map((c2, index) => {
          const inactive = activeIndex !== -1 && activeIndex !== index;
          return React.createElement("span", {
            key: index,
            className: clsx(colorTextCellPrefixCls, inactive && `${colorTextCellPrefixCls}-inactive`)
          }, c2.color.toRgbString(), " ", c2.percent, "%");
        });
      }
      const hexString = color2.toHexString().toUpperCase();
      const alpha2 = getColorAlpha(color2);
      switch (format2) {
        case "rgb":
          return color2.toRgbString();
        case "hsb":
          return color2.toHsbString();
default:
          return alpha2 < 100 ? `${hexString.slice(0, 7)},${alpha2}%` : hexString;
      }
    }, [color2, format2, showText, activeIndex, locale2.transparent, colorTextCellPrefixCls]);
    const containerNode = reactExports.useMemo(() => color2.cleared ? React.createElement(ColorClear, {
      prefixCls,
      className: classNames.body,
      style: styles.body
    }) : React.createElement(ColorBlock, {
      prefixCls,
      color: color2.toCssString(),
      className: classNames.body,
      innerClassName: classNames.content,
      style: styles.body,
      innerStyle: styles.content
    }), [color2, prefixCls, classNames.body, classNames.content, styles.body, styles.content]);
    return React.createElement("div", {
      ref: ref2,
      className: clsx(colorTriggerPrefixCls, className, classNames.root, {
        [`${colorTriggerPrefixCls}-active`]: open2,
        [`${colorTriggerPrefixCls}-disabled`]: disabled
      }),
      style: {
        ...styles.root,
        ...style2
      },
      ...pickAttrs(rest)
    }, containerNode, showText && React.createElement("div", {
      className: clsx(colorTextPrefixCls, classNames.description),
      style: styles.description
    }, desc));
  });
  function useModeColor(defaultValue2, value, mode) {
    const [locale2] = useLocale("ColorPicker");
    const [mergedColor, setMergedColor] = useControlledState(defaultValue2, value);
    const [modeState, setModeState] = reactExports.useState("single");
    const [modeOptionList, modeSet] = reactExports.useMemo(() => {
      const list2 = (Array.isArray(mode) ? mode : [mode]).filter((m2) => m2);
      if (!list2.length) {
        list2.push("single");
      }
      const modes = new Set(list2);
      const optionList = [];
      const pushOption = (modeType, localeTxt) => {
        if (modes.has(modeType)) {
          optionList.push({
            label: localeTxt,
            value: modeType
          });
        }
      };
      pushOption("single", locale2.singleColor);
      pushOption("gradient", locale2.gradientColor);
      return [optionList, modes];
    }, [mode, locale2.singleColor, locale2.gradientColor]);
    const [cacheColor, setCacheColor] = reactExports.useState(null);
    const setColor = useEvent$1((nextColor) => {
      setCacheColor(nextColor);
      setMergedColor(nextColor);
    });
    const postColor = reactExports.useMemo(() => {
      const colorObj = generateColor(mergedColor || "");
      return colorObj.equals(cacheColor) ? cacheColor : colorObj;
    }, [mergedColor, cacheColor]);
    const postMode = reactExports.useMemo(() => {
      if (modeSet.has(modeState)) {
        return modeState;
      }
      return modeOptionList[0]?.value;
    }, [modeSet, modeState, modeOptionList]);
    reactExports.useEffect(() => {
      setModeState(postColor.isGradient() ? "gradient" : "single");
    }, [postColor]);
    return [postColor, setColor, postMode, setModeState, modeOptionList];
  }
  const getTransBg = (size, colorFill) => ({
    backgroundImage: `conic-gradient(${colorFill} 25%, transparent 25% 50%, ${colorFill} 50% 75%, transparent 75% 100%)`,
    backgroundSize: `${size} ${size}`
  });
  const genColorBlockStyle = (token2, size) => {
    const {
      componentCls,
      borderRadiusSM,
      colorPickerInsetShadow,
      lineWidth,
      colorFillSecondary
    } = token2;
    return {
      [`${componentCls}-color-block`]: {
        position: "relative",
        borderRadius: borderRadiusSM,
        width: size,
        height: size,
        boxShadow: colorPickerInsetShadow,
        flex: "none",
        ...getTransBg("50%", token2.colorFillSecondary),
        [`${componentCls}-color-block-inner`]: {
          width: "100%",
          height: "100%",
          boxShadow: `inset 0 0 0 ${unit$1(lineWidth)} ${colorFillSecondary}`,
          borderRadius: "inherit"
        }
      }
    };
  };
  const genInputStyle = (token2) => {
    const {
      componentCls,
      antCls,
      fontSizeSM,
      lineHeightSM,
      colorPickerAlphaInputWidth,
      marginXXS,
      paddingXXS,
      controlHeightSM,
      marginXS,
      fontSizeIcon,
      paddingXS,
      colorTextPlaceholder,
      colorPickerInputNumberHandleWidth,
      lineWidth
    } = token2;
    return {
      [`${componentCls}-input-container`]: {
        display: "flex",
        [`${componentCls}-steppers${antCls}-input-number`]: {
          fontSize: fontSizeSM,
          lineHeight: lineHeightSM,
          padding: 0,
          [`${antCls}-input-number-input`]: {
            paddingInlineStart: paddingXXS,
            paddingInlineEnd: 0
          },
          [`${antCls}-input-number-handler-wrap`]: {
            width: colorPickerInputNumberHandleWidth
          }
        },
        [`${componentCls}-steppers${componentCls}-alpha-input`]: {
          flex: `0 0 ${unit$1(colorPickerAlphaInputWidth)}`,
          marginInlineStart: marginXXS
        },
        [`${componentCls}-format-select${antCls}-select`]: {
          marginInlineEnd: marginXS,
          width: "auto",
          "&-single": {
            [`${antCls}-select-selector`]: {
              padding: 0,
              border: 0
            },
            [`${antCls}-select-arrow`]: {
              insetInlineEnd: 0
            },
            [`${antCls}-select-selection-item`]: {
              paddingInlineEnd: token2.calc(fontSizeIcon).add(marginXXS).equal(),
              fontSize: fontSizeSM,
              lineHeight: unit$1(controlHeightSM)
            },
            [`${antCls}-select-item-option-content`]: {
              fontSize: fontSizeSM,
              lineHeight: lineHeightSM
            },
            [`${antCls}-select-dropdown`]: {
              [`${antCls}-select-item`]: {
                minHeight: "auto"
              }
            }
          }
        },
        [`${componentCls}-input`]: {
          gap: marginXXS,
          alignItems: "center",
          flex: 1,
          width: 0,
          [`${componentCls}-hsb-input,${componentCls}-rgb-input`]: {
            height: controlHeightSM,
            display: "flex",
            gap: marginXXS,
            alignItems: "center"
          },
          [`${componentCls}-steppers`]: {
            flex: 1
          },
          [`${componentCls}-hex-input${antCls}-input-affix-wrapper`]: {
            flex: 1,
            padding: `0 ${unit$1(paddingXS)}`,
            [`${antCls}-input`]: {
              fontSize: fontSizeSM,
              textTransform: "uppercase",
              lineHeight: unit$1(token2.calc(controlHeightSM).sub(token2.calc(lineWidth).mul(2)).equal())
            },
            [`${antCls}-input-prefix`]: {
              color: colorTextPlaceholder
            }
          }
        }
      }
    };
  };
  const genPickerStyle = (token2) => {
    const {
      componentCls,
      controlHeightLG,
      borderRadiusSM,
      colorPickerInsetShadow,
      marginSM,
      colorBgElevated,
      colorFillSecondary,
      lineWidthBold,
      colorPickerHandlerSize
    } = token2;
    return {
      userSelect: "none",
      [`${componentCls}-select`]: {
        [`${componentCls}-palette`]: {
          minHeight: token2.calc(controlHeightLG).mul(4).equal(),
          overflow: "hidden",
          borderRadius: borderRadiusSM
        },
        [`${componentCls}-saturation`]: {
          position: "absolute",
          borderRadius: "inherit",
          boxShadow: colorPickerInsetShadow,
          inset: 0
        },
        marginBottom: marginSM
      },
[`${componentCls}-handler`]: {
        width: colorPickerHandlerSize,
        height: colorPickerHandlerSize,
        border: `${unit$1(lineWidthBold)} solid ${colorBgElevated}`,
        position: "relative",
        borderRadius: "50%",
        cursor: "pointer",
        boxShadow: `${colorPickerInsetShadow}, 0 0 0 1px ${colorFillSecondary}`
      }
    };
  };
  const genPresetsStyle = (token2) => {
    const {
      componentCls,
      antCls,
      colorTextQuaternary,
      paddingXXS,
      colorPickerPresetColorSize,
      fontSizeSM,
      colorText,
      lineHeightSM,
      lineWidth,
      borderRadius,
      colorFill,
      colorWhite,
      marginXXS,
      paddingXS,
      fontHeightSM
    } = token2;
    return {
      [`${componentCls}-presets`]: {
        [`${antCls}-collapse-item > ${antCls}-collapse-header`]: {
          padding: 0,
          [`${antCls}-collapse-expand-icon`]: {
            height: fontHeightSM,
            color: colorTextQuaternary,
            paddingInlineEnd: paddingXXS
          }
        },
        [`${antCls}-collapse`]: {
          display: "flex",
          flexDirection: "column",
          gap: marginXXS
        },
        [`${antCls}-collapse-item > ${antCls}-collapse-panel > ${antCls}-collapse-body`]: {
          padding: `${unit$1(paddingXS)} 0`
        },
        "&-label": {
          fontSize: fontSizeSM,
          color: colorText,
          lineHeight: lineHeightSM
        },
        "&-items": {
          display: "flex",
          flexWrap: "wrap",
          gap: token2.calc(marginXXS).mul(1.5).equal(),
          [`${componentCls}-presets-color`]: {
            position: "relative",
            cursor: "pointer",
            width: colorPickerPresetColorSize,
            height: colorPickerPresetColorSize,
            "&::before": {
              content: '""',
              pointerEvents: "none",
              width: token2.calc(colorPickerPresetColorSize).add(token2.calc(lineWidth).mul(4)).equal(),
              height: token2.calc(colorPickerPresetColorSize).add(token2.calc(lineWidth).mul(4)).equal(),
              position: "absolute",
              top: token2.calc(lineWidth).mul(-2).equal(),
              insetInlineStart: token2.calc(lineWidth).mul(-2).equal(),
              borderRadius,
              border: `${unit$1(lineWidth)} solid transparent`,
              transition: `border-color ${token2.motionDurationMid} ${token2.motionEaseInBack}`
            },
            "&:hover::before": {
              borderColor: colorFill
            },
            "&::after": {
              boxSizing: "border-box",
              position: "absolute",
              top: "50%",
              insetInlineStart: "21.5%",
              display: "table",
              width: token2.calc(colorPickerPresetColorSize).div(13).mul(5).equal(),
              height: token2.calc(colorPickerPresetColorSize).div(13).mul(8).equal(),
              border: `${unit$1(token2.lineWidthBold)} solid ${token2.colorWhite}`,
              borderTop: 0,
              borderInlineStart: 0,
              transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
              opacity: 0,
              content: '""',
              transition: `all ${token2.motionDurationFast} ${token2.motionEaseInBack}, opacity ${token2.motionDurationFast}`
            },
            [`&${componentCls}-presets-color-checked`]: {
              "&::after": {
                opacity: 1,
                borderColor: colorWhite,
                transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
                transition: `transform ${token2.motionDurationMid} ${token2.motionEaseOutBack} ${token2.motionDurationFast}`
              },
              [`&${componentCls}-presets-color-bright`]: {
                "&::after": {
                  borderColor: "rgba(0, 0, 0, 0.45)"
                }
              }
            }
          }
        },
        "&-empty": {
          fontSize: fontSizeSM,
          color: colorTextQuaternary
        }
      }
    };
  };
  const genSliderStyle = (token2) => {
    const {
      componentCls,
      colorPickerInsetShadow,
      colorBgElevated,
      colorFillSecondary,
      lineWidthBold,
      colorPickerHandlerSizeSM,
      colorPickerSliderHeight,
      marginSM,
      marginXS
    } = token2;
    const handleInnerSize = token2.calc(colorPickerHandlerSizeSM).sub(token2.calc(lineWidthBold).mul(2).equal()).equal();
    const handleHoverSize = token2.calc(colorPickerHandlerSizeSM).add(token2.calc(lineWidthBold).mul(2).equal()).equal();
    const activeHandleStyle = {
      "&:after": {
        transform: "scale(1)",
        boxShadow: `${colorPickerInsetShadow}, 0 0 0 1px ${token2.colorPrimaryActive}`
      }
    };
    return {
[`${componentCls}-slider`]: [getTransBg(unit$1(colorPickerSliderHeight), token2.colorFillSecondary), {
        margin: 0,
        padding: 0,
        height: colorPickerSliderHeight,
        borderRadius: token2.calc(colorPickerSliderHeight).div(2).equal(),
        "&-rail": {
          height: colorPickerSliderHeight,
          borderRadius: token2.calc(colorPickerSliderHeight).div(2).equal(),
          boxShadow: colorPickerInsetShadow
        },
        [`& ${componentCls}-slider-handle`]: {
          width: handleInnerSize,
          height: handleInnerSize,
          top: 0,
          borderRadius: "100%",
          "&:before": {
            display: "block",
            position: "absolute",
            background: "transparent",
            left: {
              _skip_check_: true,
              value: "50%"
            },
            top: "50%",
            transform: "translate(-50%, -50%)",
            width: handleHoverSize,
            height: handleHoverSize,
            borderRadius: "100%"
          },
          "&:after": {
            width: colorPickerHandlerSizeSM,
            height: colorPickerHandlerSizeSM,
            border: `${unit$1(lineWidthBold)} solid ${colorBgElevated}`,
            boxShadow: `${colorPickerInsetShadow}, 0 0 0 1px ${colorFillSecondary}`,
            outline: "none",
            insetInlineStart: token2.calc(lineWidthBold).mul(-1).equal(),
            top: token2.calc(lineWidthBold).mul(-1).equal(),
            background: "transparent",
            transition: "none"
          },
          "&:focus": activeHandleStyle
        }
      }],
[`${componentCls}-slider-container`]: {
        display: "flex",
        gap: marginSM,
        marginBottom: marginSM,
[`${componentCls}-slider-group`]: {
          flex: 1,
          flexDirection: "column",
          justifyContent: "space-between",
          display: "flex",
          "&-disabled-alpha": {
            justifyContent: "center"
          }
        }
      },
      [`${componentCls}-gradient-slider`]: {
        marginBottom: marginXS,
        [`& ${componentCls}-slider-handle`]: {
          "&:after": {
            transform: "scale(0.8)"
          },
          "&-active, &:focus": activeHandleStyle
        }
      }
    };
  };
  const genActiveStyle = (token2, borderColor, outlineColor) => ({
    borderInlineEndWidth: token2.lineWidth,
    borderColor,
    boxShadow: `0 0 0 ${unit$1(token2.controlOutlineWidth)} ${outlineColor}`,
    outline: 0
  });
  const genRtlStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      "&-rtl": {
        [`${componentCls}-presets-color`]: {
          "&::after": {
            direction: "ltr"
          }
        },
        [`${componentCls}-clear`]: {
          "&::after": {
            direction: "ltr"
          }
        }
      }
    };
  };
  const genClearStyle = (token2, size, extraStyle) => {
    const {
      componentCls,
      borderRadiusSM,
      lineWidth,
      colorSplit,
      colorBorder,
      red6
    } = token2;
    return {
      [`${componentCls}-clear`]: {
        width: size,
        height: size,
        borderRadius: borderRadiusSM,
        border: `${unit$1(lineWidth)} solid ${colorSplit}`,
        position: "relative",
        overflow: "hidden",
        cursor: "inherit",
        transition: `all ${token2.motionDurationFast}`,
        ...extraStyle,
        "&::after": {
          content: '""',
          position: "absolute",
          insetInlineEnd: token2.calc(lineWidth).mul(-1).equal(),
          top: token2.calc(lineWidth).mul(-1).equal(),
          display: "block",
          width: 40,
height: 2,
transformOrigin: `calc(100% - 1px) 1px`,
          transform: "rotate(-45deg)",
          backgroundColor: red6
        },
        "&:hover": {
          borderColor: colorBorder
        }
      }
    };
  };
  const genStatusStyle = (token2) => {
    const {
      componentCls,
      colorError,
      colorWarning,
      colorErrorHover,
      colorWarningHover,
      colorErrorOutline,
      colorWarningOutline
    } = token2;
    return {
      [`&${componentCls}-status-error`]: {
        borderColor: colorError,
        "&:hover": {
          borderColor: colorErrorHover
        },
        [`&${componentCls}-trigger-active`]: {
          ...genActiveStyle(token2, colorError, colorErrorOutline)
        }
      },
      [`&${componentCls}-status-warning`]: {
        borderColor: colorWarning,
        "&:hover": {
          borderColor: colorWarningHover
        },
        [`&${componentCls}-trigger-active`]: {
          ...genActiveStyle(token2, colorWarning, colorWarningOutline)
        }
      }
    };
  };
  const genSizeStyle$1 = (token2) => {
    const {
      componentCls,
      controlHeightLG,
      controlHeightSM,
      controlHeight,
      controlHeightXS,
      borderRadius,
      borderRadiusSM,
      borderRadiusXS,
      borderRadiusLG,
      fontSizeLG
    } = token2;
    return {
      [`&${componentCls}-lg`]: {
        minWidth: controlHeightLG,
        minHeight: controlHeightLG,
        borderRadius: borderRadiusLG,
        [`${componentCls}-color-block, ${componentCls}-clear`]: {
          width: controlHeight,
          height: controlHeight,
          borderRadius
        },
        [`${componentCls}-trigger-text`]: {
          fontSize: fontSizeLG
        }
      },
      [`&${componentCls}-sm`]: {
        minWidth: controlHeightSM,
        minHeight: controlHeightSM,
        borderRadius: borderRadiusSM,
        [`${componentCls}-color-block, ${componentCls}-clear`]: {
          width: controlHeightXS,
          height: controlHeightXS,
          borderRadius: borderRadiusXS
        },
        [`${componentCls}-trigger-text`]: {
          lineHeight: unit$1(controlHeightXS)
        }
      }
    };
  };
  const genColorPickerStyle = (token2) => {
    const {
      antCls,
      componentCls,
      colorPickerWidth,
      colorPrimary,
      motionDurationMid,
      colorBgElevated,
      colorTextDisabled,
      colorText,
      colorBgContainerDisabled,
      borderRadius,
      marginXS,
      marginSM,
      controlHeight,
      controlHeightSM,
      colorBgTextActive,
      colorPickerPresetColorSize,
      colorPickerPreviewSize,
      lineWidth,
      colorBorder,
      paddingXXS,
      fontSize,
      colorPrimaryHover,
      controlOutline
    } = token2;
    return [{
      [componentCls]: {
        [`${componentCls}-inner`]: {
          "&-content": {
            display: "flex",
            flexDirection: "column",
            width: colorPickerWidth,
            [`& > ${antCls}-divider`]: {
              margin: `${unit$1(marginSM)} 0 ${unit$1(marginXS)}`
            }
          },
          [`${componentCls}-panel`]: {
            ...genPickerStyle(token2)
          },
          ...genSliderStyle(token2),
          ...genColorBlockStyle(token2, colorPickerPreviewSize),
          ...genInputStyle(token2),
          ...genPresetsStyle(token2),
          ...genClearStyle(token2, colorPickerPresetColorSize, {
            marginInlineStart: "auto"
          }),
[`${componentCls}-operation`]: {
            display: "flex",
            justifyContent: "space-between",
            marginBottom: marginXS
          }
        },
        "&-trigger": {
          minWidth: controlHeight,
          minHeight: controlHeight,
          borderRadius,
          border: `${unit$1(lineWidth)} solid ${colorBorder}`,
          cursor: "pointer",
          display: "inline-flex",
          alignItems: "flex-start",
          justifyContent: "center",
          transition: `all ${motionDurationMid}`,
          background: colorBgElevated,
          padding: token2.calc(paddingXXS).sub(lineWidth).equal(),
          [`${componentCls}-trigger-text`]: {
            marginInlineStart: marginXS,
            marginInlineEnd: token2.calc(marginXS).sub(token2.calc(paddingXXS).sub(lineWidth)).equal(),
            fontSize,
            color: colorText,
            alignSelf: "center",
            "&-cell": {
              "&:not(:last-child):after": {
                content: '", "'
              },
              "&-inactive": {
                color: colorTextDisabled
              }
            }
          },
          "&:hover": {
            borderColor: colorPrimaryHover
          },
          [`&${componentCls}-trigger-active`]: {
            ...genActiveStyle(token2, colorPrimary, controlOutline)
          },
          "&-disabled": {
            color: colorTextDisabled,
            background: colorBgContainerDisabled,
            cursor: "not-allowed",
            "&:hover": {
              borderColor: colorBgTextActive
            },
            [`${componentCls}-trigger-text`]: {
              color: colorTextDisabled
            }
          },
          ...genClearStyle(token2, controlHeightSM),
          ...genColorBlockStyle(token2, controlHeightSM),
          ...genStatusStyle(token2),
          ...genSizeStyle$1(token2)
        },
        ...genRtlStyle(token2)
      }
    }, genCompactItemStyle(token2, {
      focusElCls: `${componentCls}-trigger-active`
    })];
  };
  const useStyle$e = genStyleHooks("ColorPicker", (token2) => {
    const {
      colorTextQuaternary,
      marginSM
    } = token2;
    const colorPickerSliderHeight = 8;
    const colorPickerToken = merge$1(token2, {
      colorPickerWidth: 234,
      colorPickerHandlerSize: 16,
      colorPickerHandlerSizeSM: 12,
      colorPickerAlphaInputWidth: 44,
      colorPickerInputNumberHandleWidth: 16,
      colorPickerPresetColorSize: 24,
      colorPickerInsetShadow: `inset 0 0 1px 0 ${colorTextQuaternary}`,
      colorPickerSliderHeight,
      colorPickerPreviewSize: token2.calc(colorPickerSliderHeight).mul(2).add(marginSM).equal()
    });
    return genColorPickerStyle(colorPickerToken);
  });
  const ColorPicker = (props) => {
    const {
      mode,
      value,
      defaultValue: defaultValue2,
      format: format2,
      defaultFormat,
      allowClear = false,
      presets,
      children,
      trigger: trigger2 = "click",
      open: open2,
      disabled,
      placement = "bottomLeft",
      arrow,
      panelRender,
      showText,
      style: style2,
      className,
      size: customizeSize,
      rootClassName,
      prefixCls: customizePrefixCls,
      styles,
      classNames,
      disabledAlpha = false,
      onFormatChange,
      onChange,
      onClear,
      onOpenChange,
      onChangeComplete,
      getPopupContainer,
      autoAdjustOverflow: autoAdjustOverflow2 = true,
      destroyTooltipOnHide,
      destroyOnHidden,
      disabledFormat,
      ...rest
    } = props;
    const {
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles,
      arrow: contextArrow
    } = useComponentConfig("colorPicker");
    const contextDisabled = reactExports.useContext(DisabledContext);
    const mergedDisabled = disabled ?? contextDisabled;
    const prefixCls = getPrefixCls("color-picker", customizePrefixCls);
    const mergedArrow = useMergedArrow(arrow, contextArrow);
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const mergedSize = useSize((ctx) => customizeSize ?? compactSize ?? ctx);
    const mergedProps = {
      ...props,
      trigger: trigger2,
      allowClear,
      autoAdjustOverflow: autoAdjustOverflow2,
      disabledAlpha,
      arrow: mergedArrow,
      placement,
      disabled: mergedDisabled,
      size: mergedSize
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    }, {
      popup: {
        _default: "root"
      }
    });
    const [internalPopupOpen, setPopupOpen] = useControlledState(false, open2);
    const popupOpen = !mergedDisabled && internalPopupOpen;
    const [formatValue, setFormatValue] = useControlledState(defaultFormat, format2);
    const triggerFormatChange = (newFormat) => {
      setFormatValue(newFormat);
      if (formatValue !== newFormat) {
        onFormatChange?.(newFormat);
      }
    };
    const triggerOpenChange = (visible) => {
      if (!visible || !mergedDisabled) {
        setPopupOpen(visible);
        onOpenChange?.(visible);
      }
    };
    const [mergedColor, setColor, modeState, setModeState, modeOptions] = useModeColor(defaultValue2, value, mode);
    const isAlphaColor = reactExports.useMemo(() => getColorAlpha(mergedColor) < 100, [mergedColor]);
    const [cachedGradientColor, setCachedGradientColor] = React.useState(null);
    const onInternalChangeComplete = (color2) => {
      if (onChangeComplete) {
        let changeColor = generateColor(color2);
        if (disabledAlpha && isAlphaColor) {
          changeColor = genAlphaColor(color2);
        }
        onChangeComplete(changeColor);
      }
    };
    const onInternalChange = (data2, changeFromPickerDrag) => {
      let color2 = generateColor(data2);
      if (disabledAlpha && isAlphaColor) {
        color2 = genAlphaColor(color2);
      }
      setColor(color2);
      setCachedGradientColor(null);
      if (onChange) {
        onChange(color2, color2.toCssString());
      }
      if (!changeFromPickerDrag) {
        onInternalChangeComplete(color2);
      }
    };
    const [activeIndex, setActiveIndex] = React.useState(0);
    const [gradientDragging, setGradientDragging] = React.useState(false);
    const onInternalModeChange = (newMode) => {
      setModeState(newMode);
      if (newMode === "single" && mergedColor.isGradient()) {
        setActiveIndex(0);
        onInternalChange(new AggregationColor(mergedColor.getColors()[0].color));
        setCachedGradientColor(mergedColor);
      } else if (newMode === "gradient" && !mergedColor.isGradient()) {
        const baseColor = isAlphaColor ? genAlphaColor(mergedColor) : mergedColor;
        onInternalChange(new AggregationColor(cachedGradientColor || [{
          percent: 0,
          color: baseColor
        }, {
          percent: 100,
          color: baseColor
        }]));
      }
    };
    const {
      status: contextStatus
    } = React.useContext(FormItemInputContext);
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$e(prefixCls, rootCls);
    const rtlCls = {
      [`${prefixCls}-rtl`]: direction
    };
    const mergedRootCls = clsx(rootClassName, cssVarCls, rootCls, rtlCls);
    const mergedCls = clsx(getStatusClassNames(prefixCls, contextStatus), {
      [`${prefixCls}-sm`]: mergedSize === "small",
      [`${prefixCls}-lg`]: mergedSize === "large"
    }, compactItemClassnames, contextClassName, mergedRootCls, className, hashId);
    const mergedPopupCls = clsx(prefixCls, mergedRootCls, mergedClassNames.popup?.root);
    const popoverProps = {
      open: popupOpen,
      trigger: trigger2,
      placement,
      arrow: mergedArrow,
      rootClassName,
      getPopupContainer,
      autoAdjustOverflow: autoAdjustOverflow2,
      destroyOnHidden: destroyOnHidden ?? !!destroyTooltipOnHide
    };
    const mergedStyle = {
      ...contextStyle,
      ...style2
    };
    return React.createElement(Popover, {
      classNames: {
        root: mergedPopupCls
      },
      styles: {
        root: mergedStyles.popup?.root,
        container: styles?.popupOverlayInner
      },
      onOpenChange: triggerOpenChange,
      content: React.createElement(ContextIsolator, {
        form: true
      }, React.createElement(ColorPickerPanel, {
        mode: modeState,
        onModeChange: onInternalModeChange,
        modeOptions,
        prefixCls,
        value: mergedColor,
        allowClear,
        disabled: mergedDisabled,
        disabledAlpha,
        presets,
        panelRender,
        format: formatValue,
        onFormatChange: triggerFormatChange,
        onChange: onInternalChange,
        onChangeComplete: onInternalChangeComplete,
        onClear,
        activeIndex,
        onActive: setActiveIndex,
        gradientDragging,
        onGradientDragging: setGradientDragging,
        disabledFormat
      })),
      ...popoverProps
    }, children || React.createElement(ColorTrigger, {
      activeIndex: popupOpen ? activeIndex : -1,
      open: popupOpen,
      className: mergedCls,
      style: mergedStyle,
      classNames: mergedClassNames,
      styles: mergedStyles,
      prefixCls,
      disabled: mergedDisabled,
      showText,
      format: formatValue,
      ...rest,
      color: mergedColor
    }));
  };
  const PurePanel$4 = genPurePanel(
    ColorPicker,
    void 0,
    (props) => ({
      ...props,
      placement: "bottom",
      autoAdjustOverflow: false
    }),
    "color-picker",
(prefixCls) => prefixCls
  );
  ColorPicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$4;
  function isPresetSize(size) {
    return ["small", "middle", "large"].includes(size);
  }
  function isValidGapNumber(size) {
    if (!size) {
      return false;
    }
    return typeof size === "number" && !Number.isNaN(size);
  }
  const SpaceContext = React.createContext({
    latestIndex: 0
  });
  const SpaceContextProvider = SpaceContext.Provider;
  const Item = (props) => {
    const {
      className,
      prefix: prefix2,
      index,
      children,
      separator,
      style: style2,
      classNames,
      styles
    } = props;
    const {
      latestIndex
    } = reactExports.useContext(SpaceContext);
    if (!isNonNullable(children)) {
      return null;
    }
    return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("div", {
      className,
      style: style2
    }, children), index < latestIndex && separator && reactExports.createElement("span", {
      className: clsx(`${prefix2}-item-separator`, classNames?.separator),
      style: styles?.separator
    }, separator));
  };
  const genSpaceStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    return {
      [componentCls]: {
        display: "inline-flex",
        "&-rtl": {
          direction: "rtl"
        },
        "&-vertical": {
          flexDirection: "column"
        },
        "&-align": {
          flexDirection: "column",
          "&-center": {
            alignItems: "center"
          },
          "&-start": {
            alignItems: "flex-start"
          },
          "&-end": {
            alignItems: "flex-end"
          },
          "&-baseline": {
            alignItems: "baseline"
          }
        },
        [`${componentCls}-item:empty`]: {
          display: "none"
        },
[`${componentCls}-item > ${antCls}-badge-not-a-wrapper:only-child`]: {
          display: "block"
        }
      }
    };
  };
  const genSpaceGapStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: {
        "&-gap-row-small": {
          rowGap: token2.spaceGapSmallSize
        },
        "&-gap-row-middle": {
          rowGap: token2.spaceGapMiddleSize
        },
        "&-gap-row-large": {
          rowGap: token2.spaceGapLargeSize
        },
        "&-gap-col-small": {
          columnGap: token2.spaceGapSmallSize
        },
        "&-gap-col-middle": {
          columnGap: token2.spaceGapMiddleSize
        },
        "&-gap-col-large": {
          columnGap: token2.spaceGapLargeSize
        }
      }
    };
  };
  const useStyle$d = genStyleHooks("Space", (token2) => {
    const spaceToken = merge$1(token2, {
      spaceGapSmallSize: token2.paddingXS,
      spaceGapMiddleSize: token2.padding,
      spaceGapLargeSize: token2.paddingLG
    });
    return [genSpaceStyle(spaceToken), genSpaceGapStyle(spaceToken)];
  }, () => ({}), {

resetStyle: false
  });
  const InternalSpace = reactExports.forwardRef((props, ref2) => {
    const {
      getPrefixCls,
      direction: directionConfig,
      size: contextSize,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("space");
    const {
      size = contextSize ?? "small",
      align,
      className,
      rootClassName,
      children,
      direction,
      orientation,
      prefixCls: customizePrefixCls,
      split,
      separator,
      style: style2,
      vertical,
      wrap: wrap2 = false,
      classNames,
      styles,
      ...restProps
    } = props;
    const [horizontalSize, verticalSize] = Array.isArray(size) ? size : [size, size];
    const isPresetVerticalSize = isPresetSize(verticalSize);
    const isPresetHorizontalSize = isPresetSize(horizontalSize);
    const isValidVerticalSize = isValidGapNumber(verticalSize);
    const isValidHorizontalSize = isValidGapNumber(horizontalSize);
    const childNodes = toArray$4(children, {
      keepEmpty: true
    });
    const [mergedOrientation, mergedVertical] = useOrientation(orientation, vertical, direction);
    const mergedAlign = align === void 0 && !mergedVertical ? "center" : align;
    const mergedSeparator = separator ?? split;
    const prefixCls = getPrefixCls("space", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$d(prefixCls);
    const mergedProps = {
      ...props,
      size,
      orientation: mergedOrientation,
      align: mergedAlign
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const rootClassNames = clsx(prefixCls, contextClassName, hashId, `${prefixCls}-${mergedOrientation}`, {
      [`${prefixCls}-rtl`]: directionConfig === "rtl",
      [`${prefixCls}-align-${mergedAlign}`]: mergedAlign,
      [`${prefixCls}-gap-row-${verticalSize}`]: isPresetVerticalSize,
      [`${prefixCls}-gap-col-${horizontalSize}`]: isPresetHorizontalSize
    }, className, rootClassName, cssVarCls, mergedClassNames.root);
    const itemClassName = clsx(`${prefixCls}-item`, mergedClassNames.item);
    const renderedItems = childNodes.map((child, i2) => {
      const key = child?.key || `${itemClassName}-${i2}`;
      return reactExports.createElement(Item, {
        prefix: prefixCls,
        classNames: mergedClassNames,
        styles: mergedStyles,
        className: itemClassName,
        key,
        index: i2,
        separator: mergedSeparator,
        style: mergedStyles.item
      }, child);
    });
    const memoizedSpaceContext = reactExports.useMemo(() => {
      const calcLatestIndex = childNodes.reduce((latest, child, i2) => isNonNullable(child) ? i2 : latest, 0);
      return {
        latestIndex: calcLatestIndex
      };
    }, [childNodes]);
    if (childNodes.length === 0) {
      return null;
    }
    const gapStyle = {};
    if (wrap2) {
      gapStyle.flexWrap = "wrap";
    }
    if (!isPresetHorizontalSize && isValidHorizontalSize) {
      gapStyle.columnGap = horizontalSize;
    }
    if (!isPresetVerticalSize && isValidVerticalSize) {
      gapStyle.rowGap = verticalSize;
    }
    return reactExports.createElement("div", {
      ref: ref2,
      className: rootClassNames,
      style: {
        ...gapStyle,
        ...mergedStyles.root,
        ...contextStyle,
        ...style2
      },
      ...restProps
    }, reactExports.createElement(SpaceContextProvider, {
      value: memoizedSpaceContext
    }, renderedItems));
  });
  const Space = InternalSpace;
  Space.Compact = Compact$1;
  Space.Addon = SpaceAddon;
  const DropdownButton = (props) => {
    const {
      getPopupContainer: getContextPopupContainer,
      getPrefixCls,
      direction
    } = reactExports.useContext(ConfigContext);
    const {
      prefixCls: customizePrefixCls,
      type: type4 = "default",
      danger,
      disabled,
      loading,
      onClick,
      htmlType,
      children,
      className,
      menu,
      arrow,
      autoFocus,
      trigger: trigger2,
      align,
      open: open2,
      onOpenChange,
      placement,
      getPopupContainer,
      href,
      icon = reactExports.createElement(RefIcon$a, null),
      title,
      buttonsRender = (buttons) => buttons,
      mouseEnterDelay,
      mouseLeaveDelay,
      overlayClassName,
      overlayStyle,
      destroyOnHidden,
      destroyPopupOnHide,
      dropdownRender,
      popupRender,
      ...restProps
    } = props;
    const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
    const buttonPrefixCls = `${prefixCls}-button`;
    const mergedPopupRender = popupRender || dropdownRender;
    const dropdownProps = {
      menu,
      arrow,
      autoFocus,
      align,
      disabled,
      trigger: disabled ? [] : trigger2,
      onOpenChange,
      getPopupContainer: getPopupContainer || getContextPopupContainer,
      mouseEnterDelay,
      mouseLeaveDelay,
      classNames: {
        root: overlayClassName
      },
      styles: {
        root: overlayStyle
      },
      destroyOnHidden,
      popupRender: mergedPopupRender
    };
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const classes2 = clsx(buttonPrefixCls, compactItemClassnames, className);
    if ("destroyPopupOnHide" in props) {
      dropdownProps.destroyPopupOnHide = destroyPopupOnHide;
    }
    if ("open" in props) {
      dropdownProps.open = open2;
    }
    if ("placement" in props) {
      dropdownProps.placement = placement;
    } else {
      dropdownProps.placement = direction === "rtl" ? "bottomLeft" : "bottomRight";
    }
    const leftButton = reactExports.createElement(Button$1, {
      type: type4,
      danger,
      disabled,
      loading,
      onClick,
      htmlType,
      href,
      title
    }, children);
    const rightButton = reactExports.createElement(Button$1, {
      type: type4,
      danger,
      icon
    });
    const [leftButtonToRender, rightButtonToRender] = buttonsRender([leftButton, rightButton]);
    return reactExports.createElement(Space.Compact, {
      className: classes2,
      size: compactSize,
      block: true,
      ...restProps
    }, leftButtonToRender, reactExports.createElement(Dropdown$1, {
      ...dropdownProps
    }, rightButtonToRender));
  };
  DropdownButton.__ANT_BUTTON = true;
  const Dropdown = Dropdown$1;
  Dropdown.Button = DropdownButton;
  const flexWrapValues = ["wrap", "nowrap", "wrap-reverse"];
  const justifyContentValues = ["flex-start", "flex-end", "start", "end", "center", "space-between", "space-around", "space-evenly", "stretch", "normal", "left", "right"];
  const alignItemsValues = ["center", "start", "end", "flex-start", "flex-end", "self-start", "self-end", "baseline", "normal", "stretch"];
  const genClsWrap = (prefixCls, props) => {
    const wrap2 = props.wrap === true ? "wrap" : props.wrap;
    return {
      [`${prefixCls}-wrap-${wrap2}`]: wrap2 && flexWrapValues.includes(wrap2)
    };
  };
  const genClsAlign = (prefixCls, props) => {
    const alignCls = {};
    alignItemsValues.forEach((cssKey) => {
      alignCls[`${prefixCls}-align-${cssKey}`] = props.align === cssKey;
    });
    alignCls[`${prefixCls}-align-stretch`] = !props.align && !!props.vertical;
    return alignCls;
  };
  const genClsJustify = (prefixCls, props) => {
    const justifyCls = {};
    justifyContentValues.forEach((cssKey) => {
      justifyCls[`${prefixCls}-justify-${cssKey}`] = props.justify === cssKey;
    });
    return justifyCls;
  };
  const createFlexClassNames = (prefixCls, props) => {
    return clsx({
      ...genClsWrap(prefixCls, props),
      ...genClsAlign(prefixCls, props),
      ...genClsJustify(prefixCls, props)
    });
  };
  const genFlexStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: {
        display: "flex",
        margin: 0,
        padding: 0,
        "&-vertical": {
          flexDirection: "column"
        },
        "&-rtl": {
          direction: "rtl"
        },
        "&:empty": {
          display: "none"
        }
      }
    };
  };
  const genFlexGapStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: {
        "&-gap-small": {
          gap: token2.flexGapSM
        },
        "&-gap-middle": {
          gap: token2.flexGap
        },
        "&-gap-large": {
          gap: token2.flexGapLG
        }
      }
    };
  };
  const genFlexWrapStyle = (token2) => {
    const {
      componentCls
    } = token2;
    const wrapStyle = {};
    flexWrapValues.forEach((value) => {
      wrapStyle[`${componentCls}-wrap-${value}`] = {
        flexWrap: value
      };
    });
    return wrapStyle;
  };
  const genAlignItemsStyle = (token2) => {
    const {
      componentCls
    } = token2;
    const alignStyle = {};
    alignItemsValues.forEach((value) => {
      alignStyle[`${componentCls}-align-${value}`] = {
        alignItems: value
      };
    });
    return alignStyle;
  };
  const genJustifyContentStyle = (token2) => {
    const {
      componentCls
    } = token2;
    const justifyStyle = {};
    justifyContentValues.forEach((value) => {
      justifyStyle[`${componentCls}-justify-${value}`] = {
        justifyContent: value
      };
    });
    return justifyStyle;
  };
  const prepareComponentToken$8 = () => ({});
  const useStyle$c = genStyleHooks("Flex", (token2) => {
    const {
      paddingXS,
      padding,
      paddingLG
    } = token2;
    const flexToken = merge$1(token2, {
      flexGapSM: paddingXS,
      flexGap: padding,
      flexGapLG: paddingLG
    });
    return [genFlexStyle(flexToken), genFlexGapStyle(flexToken), genFlexWrapStyle(flexToken), genAlignItemsStyle(flexToken), genJustifyContentStyle(flexToken)];
  }, prepareComponentToken$8, {

resetStyle: false
  });
  const Flex = React.forwardRef((props, ref2) => {
    const {
      prefixCls: customizePrefixCls,
      rootClassName,
      className,
      style: style2,
      flex,
      gap,
      vertical,
      orientation,
      component: Component = "div",
      children,
      ...othersProps
    } = props;
    const {
      flex: ctxFlex,
      direction: ctxDirection,
      getPrefixCls
    } = React.useContext(ConfigContext);
    const prefixCls = getPrefixCls("flex", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$c(prefixCls);
    const [, mergedVertical] = useOrientation(orientation, vertical ?? ctxFlex?.vertical);
    const mergedCls = clsx(className, rootClassName, ctxFlex?.className, prefixCls, hashId, cssVarCls, createFlexClassNames(prefixCls, {
      ...props,
      vertical: mergedVertical
    }), {
      [`${prefixCls}-rtl`]: ctxDirection === "rtl",
      [`${prefixCls}-gap-${gap}`]: isPresetSize(gap),
      [`${prefixCls}-vertical`]: mergedVertical
    });
    const mergedStyle = {
      ...ctxFlex?.style,
      ...style2
    };
    if (isNonNullable(flex)) {
      mergedStyle.flex = flex;
    }
    if (isNonNullable(gap) && !isPresetSize(gap)) {
      mergedStyle.gap = gap;
    }
    return React.createElement(Component, {
      ref: ref2,
      className: mergedCls,
      style: mergedStyle,
      ...omit(othersProps, ["justify", "wrap", "align"])
    }, children);
  });
  const GroupContext = React.createContext(null);
  var FileTextOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494zM504 618H320c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h184c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM312 490v48c0 4.4 3.6 8 8 8h384c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H320c-4.4 0-8 3.6-8 8z" } }] }, "name": "file-text", "theme": "outlined" };
  function _extends$a() {
    _extends$a = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$a.apply(this, arguments);
  }
  const FileTextOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends$a({}, props, {
    ref: ref2,
    icon: FileTextOutlined$1
  }));
  const RefIcon$6 = reactExports.forwardRef(FileTextOutlined);
  const convertToTooltipProps = (tooltip, context) => {
    if (!isNonNullable(tooltip)) {
      return null;
    }
    if (typeof tooltip === "object" && ! reactExports.isValidElement(tooltip)) {
      return {
        ...context,
        ...tooltip
      };
    }
    return {
      ...context,
      title: tooltip
    };
  };
  const genFloatButtonStyle = (token2) => {
    const {
      componentCls,
      floatButtonSize,
      iconCls,
      antCls,
      floatButtonIconSize
    } = token2;
    const [varName, varRef] = genCssVar(antCls, "float-btn");
    const badgeCls = `${componentCls}-badge`;
    const R = Math.SQRT2;
    const offsetR = (R - 1) / R;
    const offsetSquare = token2.calc(token2.borderRadius).mul(offsetR).equal();
    const offsetCircle = token2.calc(token2.controlHeight).div(2).mul(offsetR).equal();
    return {
      [componentCls]: [


{
          [varName("size")]: unit$1(floatButtonSize)
        },


{
          flexDirection: "column",
          margin: 0,
          padding: `${unit$1(token2.paddingXXS)} 0`,
          width: varRef("size"),
          minHeight: varRef("size"),
          height: "auto",
          wordBreak: "break-word",
          whiteSpace: "normal",
          gap: token2.calc(token2.paddingXXS).div(2).equal(),
          "&-rtl": {
            direction: "rtl"
          },

[`&${componentCls}-individual`]: {
            position: "fixed",
            zIndex: token2.zIndexPopupBase,
            insetInlineEnd: token2.floatButtonInsetInlineEnd,
            bottom: token2.floatButtonInsetBlockEnd,
            boxShadow: token2.boxShadowSecondary
          },
[`&${componentCls}-pure`]: {
            position: "relative",
            inset: "auto"
          },
"&:empty": {
            display: "none"
          },
[`${componentCls}-icon`]: {
            lineHeight: 1
          },
[`&${componentCls}-icon-only`]: {
            [iconCls]: {
              fontSize: floatButtonIconSize
            }
          },
[`${componentCls}-content`]: {
            fontSize: token2.fontSizeSM
          },
[badgeCls]: {
            position: "absolute",
            top: 0,
            insetInlineEnd: 0,
            [`&:not(${badgeCls}-dot)`]: {
              transform: "translate(50%, -50%)"
            }
          },
[`&-rtl ${badgeCls}:not(${badgeCls}-dot)`]: {
            transform: "translate(-50%, -50%)"
          },
"&-square": {
            [`${badgeCls}-dot`]: {
              marginTop: offsetSquare,
              marginInlineEnd: offsetSquare
            }
          },
"&-circle": {
            [badgeCls]: {
              marginTop: offsetCircle,
              marginInlineEnd: offsetCircle
            }
          }
        }
      ]
    };
  };
  const genGroupStyle = (token2) => {
    const {
      componentCls,
      antCls,
      floatButtonSize,
      padding
    } = token2;
    const groupCls = `${componentCls}-group`;
    const listCls = `${groupCls}-list`;
    const [varName, varRef] = genCssVar(antCls, "float-btn");
    return {
      [groupCls]: [


{
          [varName("list-transform-start")]: `translate(0,${unit$1(floatButtonSize)})`,
          [varName("list-trigger-offset")]: `calc(${unit$1(floatButtonSize)} + ${unit$1(padding)})`
        },


{
          ...resetComponent(token2),
          position: "fixed",
          zIndex: token2.zIndexPopupBase,
          insetInlineEnd: token2.floatButtonInsetInlineEnd,
          bottom: token2.floatButtonInsetBlockEnd,
          gap: padding,
          "&-rtl": {
            direction: "rtl"
          },
[`&${componentCls}-pure`]: {
            position: "relative",
            inset: "auto"
          },
[componentCls]: {
            position: "relative",
            inset: "auto"
          }
        },


{

[`&:not(${groupCls}-individual) ${listCls}`]: {
            boxShadow: token2.boxShadowSecondary
          },
          [`&${groupCls}-individual ${listCls}`]: {
            gap: padding
          },
[`&-menu-mode ${listCls}`]: {
            position: "absolute"
          },
[listCls]: {
            borderRadius: token2.borderRadiusLG,
            "&-motion": {
              transition: `all ${token2.motionDurationSlow}`,
              "&-enter, &-appear": {
                opacity: 0,
                transform: varRef("list-transform-start"),
                "&-active": {
                  opacity: 1,
                  transform: `translate(0, 0)`
                }
              },
              "&-leave": {
                "&-active": {
                  opacity: 0,
                  transform: varRef("list-transform-start")
                }
              }
            }
          },
"&-top": {
            [listCls]: {
              bottom: varRef("list-trigger-offset")
            }
          },
          "&-bottom": {
            [listCls]: {
              [varName("list-transform-start")]: `translate(0, calc(${unit$1(floatButtonSize)} * -1))`,
              top: varRef("list-trigger-offset")
            }
          },
          "&-left": {
            [listCls]: {
              [varName("list-transform-start")]: `translate(${unit$1(floatButtonSize)}, 0)`,
              right: varRef("list-trigger-offset")
            }
          },
          "&-right": {
            [listCls]: {
              [varName("list-transform-start")]: `translate(calc(${unit$1(floatButtonSize)} * -1), 0)`,
              left: varRef("list-trigger-offset")
            }
          }
        }
      ]
    };
  };
  const prepareComponentToken$7 = () => ({});
  const useStyle$b = genStyleHooks("FloatButton", (token2) => {
    const {
      controlHeightLG,
      marginXXL,
      marginLG,
      fontSizeIcon,
      calc
    } = token2;
    const floatButtonToken = merge$1(token2, {
      floatButtonIconSize: calc(fontSizeIcon).mul(1.5).equal(),
      floatButtonSize: controlHeightLG,
      floatButtonInsetBlockEnd: marginXXL,
      floatButtonInsetInlineEnd: marginLG
    });
    return [genFloatButtonStyle(floatButtonToken), genGroupStyle(floatButtonToken), initFadeMotion(token2)];
  }, prepareComponentToken$7, {
order: -998
  });
  const floatButtonPrefixCls = "float-btn";
  const InternalFloatButton = React.forwardRef((props, ref2) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style: style2,
      type: type4 = "default",
      shape = "circle",
      icon,
      description,
      content,
      tooltip,
      badge = {},
      classNames,
      styles,
      ...restProps
    } = props;
    const {
      getPrefixCls,
      direction
    } = React.useContext(ConfigContext);
    const groupContext = React.useContext(GroupContext);
    const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
    const rootCls = useCSSVarCls(prefixCls);
    const {
      shape: contextShape,
      individual: contextIndividual,
      classNames: contextClassNames,
      styles: contextStyles
    } = groupContext || {};
    const mergedShape = contextShape || shape;
    const mergedIndividual = contextIndividual ?? true;
    const mergedContent = content ?? description;
    const mergedProps = {
      ...props,
      type: type4,
      shape: mergedShape
    };
    const [hashId, cssVarCls] = useStyle$b(prefixCls, rootCls);
    const floatButtonClassNames = React.useMemo(() => ({
      icon: `${prefixCls}-icon`,
      content: `${prefixCls}-content`
    }), [prefixCls]);
    const [mergedClassNames, mergedStyles] = useMergeSemantic([floatButtonClassNames, contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const mergedIcon = !mergedContent && !icon ? React.createElement(RefIcon$6, null) : icon;
    const [zIndex] = useZIndex("FloatButton", style2?.zIndex);
    const mergedStyle = {
      ...style2,
      zIndex
    };
    const badgeProps = omit(badge, ["title", "children", "status", "text"]);
    const badgeNode = "badge" in props && React.createElement(Badge, {
      ...badgeProps,
      className: clsx(badgeProps.className, `${prefixCls}-badge`, {
        [`${prefixCls}-badge-dot`]: badgeProps.dot
      })
    });
    const tooltipProps = convertToTooltipProps(tooltip);
    let node2 = React.createElement(Button$1, {
      ...restProps,
      ref: ref2,
className: clsx(hashId, cssVarCls, rootCls, prefixCls, className, rootClassName, `${prefixCls}-${type4}`, `${prefixCls}-${mergedShape}`, {
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-individual`]: mergedIndividual,
        [`${prefixCls}-icon-only`]: !mergedContent
      }),
      classNames: mergedClassNames,
      styles: mergedStyles,
      style: mergedStyle,
      shape: mergedShape,
type: type4,
      size: "large",
      icon: mergedIcon,
      _skipSemantic: true
    }, mergedContent, badgeNode);
    if (tooltipProps) {
      node2 = React.createElement(Tooltip, {
        ...tooltipProps
      }, node2);
    }
    return node2;
  });
  const FloatButton = InternalFloatButton;
  const defaultIcon = React.createElement(RefIcon$c, null);
  const BackTop = React.forwardRef((props, ref2) => {
    const {
      backTopIcon: contextIcon
    } = useComponentConfig("floatButton");
    const {
      prefixCls: customizePrefixCls,
      className,
      type: type4 = "default",
      shape = "circle",
      visibilityHeight = 400,
      icon,
      target,
      onClick,
      duration: duration2 = 450,
      ...restProps
    } = props;
    const mergedIcon = icon ?? contextIcon ?? defaultIcon;
    const [visible, setVisible] = reactExports.useState(visibilityHeight === 0);
    const internalRef = React.useRef(null);
    React.useImperativeHandle(ref2, () => ({
      nativeElement: internalRef.current
    }));
    const getDefaultTarget = () => internalRef.current?.ownerDocument || window;
    const handleScroll = throttleByAnimationFrame((e) => {
      const scrollTop = getScroll$1(e.target);
      setVisible(scrollTop >= visibilityHeight);
    });
    reactExports.useEffect(() => {
      const getTarget = target || getDefaultTarget;
      const container = getTarget();
      handleScroll({
        target: container
      });
      container?.addEventListener("scroll", handleScroll);
      return () => {
        handleScroll.cancel();
        container?.removeEventListener("scroll", handleScroll);
      };
    }, [target]);
    const scrollToTop = (e) => {
      scrollTo(0, {
        getContainer: target || getDefaultTarget,
        duration: duration2
      });
      onClick?.(e);
    };
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
    const rootPrefixCls = getPrefixCls();
    const groupShape = reactExports.useContext(GroupContext)?.shape;
    const mergedShape = groupShape || shape;
    const contentProps = {
      prefixCls,
      icon: mergedIcon,
      type: type4,
      shape: mergedShape,
      ...restProps
    };
    return React.createElement(CSSMotion, {
      visible,
      motionName: `${rootPrefixCls}-fade`
    }, ({
      className: motionClassName
    }, setRef2) => React.createElement(FloatButton, {
      ref: composeRef(internalRef, setRef2),
      ...contentProps,
      onClick: scrollToTop,
      className: clsx(className, motionClassName)
    }));
  });
  const FloatButtonGroup = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      style: style2,
      classNames,
      styles,
      rootClassName,
      shape = "circle",
      type: type4 = "default",
      placement,
      icon = React.createElement(RefIcon$6, null),
      closeIcon,
      trigger: trigger2,
      children,
      onOpenChange,
      open: customOpen,
      onClick: onTriggerButtonClick,
      ...floatButtonProps
    } = props;
    const {
      direction,
      getPrefixCls,
      closeIcon: contextCloseIcon,
      classNames: contextClassNames,
      styles: contextStyles,
      className: contextClassName,
      style: contextStyle
    } = useComponentConfig("floatButtonGroup");
    const mergedCloseIcon = closeIcon ?? contextCloseIcon ?? React.createElement(RefIcon$k, null);
    const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$b(prefixCls, rootCls);
    const groupPrefixCls = `${prefixCls}-group`;
    const isMenuMode = trigger2 && ["click", "hover"].includes(trigger2);
    const [zIndex] = useZIndex("FloatButton", style2?.zIndex);
    const floatButtonGroupRef = React.useRef(null);
    const mergedPlacement = ["top", "left", "right", "bottom"].includes(placement) ? placement : "top";
    const [open2, setOpen] = useControlledState(false, customOpen);
    const hoverTrigger = trigger2 === "hover";
    const clickTrigger = trigger2 === "click";
    const triggerOpen = useEvent$1((nextOpen) => {
      if (open2 !== nextOpen) {
        setOpen(nextOpen);
        onOpenChange?.(nextOpen);
      }
    });
    const onMouseEnter = () => {
      if (hoverTrigger) {
        triggerOpen(true);
      }
    };
    const onMouseLeave = () => {
      if (hoverTrigger) {
        triggerOpen(false);
      }
    };
    const onInternalTriggerButtonClick = (e) => {
      if (clickTrigger) {
        triggerOpen(!open2);
      }
      onTriggerButtonClick?.(e);
    };
    React.useEffect(() => {
      if (clickTrigger) {
        const onDocClick = (e) => {
          if (floatButtonGroupRef.current?.contains(e.target)) {
            return;
          }
          triggerOpen(false);
        };
        document.addEventListener("click", onDocClick, {
          capture: true
        });
        return () => document.removeEventListener("click", onDocClick, {
          capture: true
        });
      }
    }, [clickTrigger]);
    const individual = shape === "circle";
    const mergedProps = {
      ...props,
      shape,
      type: type4,
      placement: mergedPlacement
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const listContext = React.useMemo(() => ({
      shape,
      individual,
      classNames: {
        root: mergedClassNames.item,
        icon: mergedClassNames.itemIcon,
        content: mergedClassNames.itemContent
      },
      styles: {
        root: mergedStyles.item,
        icon: mergedStyles.itemIcon,
        content: mergedStyles.itemContent
      }
    }), [shape, individual, mergedClassNames, mergedStyles]);
    const triggerContext = React.useMemo(() => ({
      ...listContext,
      individual: true,
      classNames: {
        root: mergedClassNames.trigger,
        icon: mergedClassNames.triggerIcon,
        content: mergedClassNames.triggerContent
      },
      styles: {
        root: mergedStyles.trigger,
        icon: mergedStyles.triggerIcon,
        content: mergedStyles.triggerContent
      }
    }), [listContext, mergedClassNames, mergedStyles]);
    let listNode;
    const listCls = `${groupPrefixCls}-list`;
    const renderList = (motionClassName) => {
      const vertical = mergedPlacement === "top" || mergedPlacement === "bottom";
      const sharedProps = {
        className: clsx(listCls, mergedClassNames.list, motionClassName),
        style: mergedStyles.list
      };
      if (individual) {
        listNode = React.createElement(Flex, {
          vertical,
          ...sharedProps
        }, children);
      } else {
        listNode = React.createElement(Space.Compact, {
          vertical,
          ...sharedProps
        }, children);
      }
      return listNode;
    };
    return React.createElement(GroupContext.Provider, {
      value: listContext
    }, React.createElement("div", {
      className: clsx(groupPrefixCls, hashId, cssVarCls, rootCls, contextClassName, mergedClassNames.root, className, rootClassName, {
        [`${groupPrefixCls}-rtl`]: direction === "rtl",
        [`${groupPrefixCls}-individual`]: individual,
        [`${groupPrefixCls}-${mergedPlacement}`]: isMenuMode,
        [`${groupPrefixCls}-menu-mode`]: isMenuMode
      }),
      style: {
        ...contextStyle,
        zIndex,
        ...mergedStyles.root,
        ...style2
      },
ref: floatButtonGroupRef,
onMouseEnter,
      onMouseLeave
    }, isMenuMode ? React.createElement(CSSMotion, {
      visible: open2,
      motionName: `${listCls}-motion`
    }, ({
      className: motionClassName
    }) => renderList(motionClassName)) : renderList(), isMenuMode && React.createElement(GroupContext.Provider, {
      value: triggerContext
    }, React.createElement(FloatButton, {
      type: type4,
      icon: open2 ? mergedCloseIcon : icon,
      "aria-label": props["aria-label"],
      className: `${groupPrefixCls}-trigger`,
      onClick: onInternalTriggerButtonClick,
      ...floatButtonProps
    }))));
  };
  const PureFloatButton = ({
    backTop,
    ...props
  }) => backTop ? reactExports.createElement(BackTop, {
    ...props,
    visibilityHeight: 0
  }) : reactExports.createElement(FloatButton, {
    ...props
  });
  const PurePanel$3 = ({
    className,
    items,
    classNames: cls,
    styles,
    prefixCls: customizePrefixCls,
    ...restProps
  }) => {
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
    const pureCls = `${prefixCls}-pure`;
    if (items) {
      return reactExports.createElement(FloatButtonGroup, {
        className: clsx(className, pureCls),
        classNames: cls,
        styles,
        ...restProps
      }, items.map((item, index) => reactExports.createElement(PureFloatButton, {
        key: index,
        ...item
      })));
    }
    return reactExports.createElement(PureFloatButton, {
      className: clsx(className, pureCls),
      classNames: cls,
      styles,
      ...restProps
    });
  };
  FloatButton.BackTop = BackTop;
  FloatButton.Group = FloatButtonGroup;
  FloatButton._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$3;
  const Group = (props) => {
    const {
      getPrefixCls,
      direction
    } = reactExports.useContext(ConfigContext);
    const {
      prefixCls: customizePrefixCls,
      className
    } = props;
    const prefixCls = getPrefixCls("input-group", customizePrefixCls);
    const inputPrefixCls = getPrefixCls("input");
    const [hashId, cssVarCls] = useStyle$m(inputPrefixCls);
    const cls = clsx(prefixCls, cssVarCls, {
      [`${prefixCls}-lg`]: props.size === "large",
      [`${prefixCls}-sm`]: props.size === "small",
      [`${prefixCls}-compact`]: props.compact,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, hashId, className);
    const formItemContext = reactExports.useContext(FormItemInputContext);
    const groupFormItemContext = reactExports.useMemo(() => ({
      ...formItemContext,
      isFormItemInput: false
    }), [formItemContext]);
    return reactExports.createElement(FormItemInputContext.Provider, {
      value: groupFormItemContext
    }, reactExports.createElement(Space.Compact, {
      className: cls,
      style: props.style,
      onMouseEnter: props.onMouseEnter,
      onMouseLeave: props.onMouseLeave,
      onFocus: props.onFocus,
      onBlur: props.onBlur
    }, props.children));
  };
  const genOTPStyle = (token2) => {
    const {
      componentCls,
      paddingXS
    } = token2;
    return {
      [componentCls]: {
        display: "inline-flex",
        alignItems: "center",
        flexWrap: "nowrap",
        columnGap: paddingXS,
        [`${componentCls}-input-wrapper`]: {
          position: "relative",
          [`${componentCls}-mask-icon`]: {
            position: "absolute",
            zIndex: "1",
            top: "50%",
            right: "50%",
            transform: "translate(50%, -50%)",
            pointerEvents: "none"
          },
          [`${componentCls}-mask-input`]: {
            color: "transparent",
            caretColor: token2.colorText
          },
          [`${componentCls}-mask-input[type=number]::-webkit-inner-spin-button`]: {
            "-webkit-appearance": "none",
            margin: 0
          },
          [`${componentCls}-mask-input[type=number]`]: {
            "-moz-appearance": "textfield"
          }
        },
        "&-rtl": {
          direction: "rtl"
        },
        [`${componentCls}-input`]: {
          textAlign: "center",
          paddingInline: token2.paddingXXS
        },
[`&${componentCls}-sm ${componentCls}-input`]: {
          paddingInline: token2.calc(token2.paddingXXS).div(2).equal()
        },
        [`&${componentCls}-lg ${componentCls}-input`]: {
          paddingInline: token2.paddingXS
        }
      }
    };
  };
  const useStyle$a = genStyleHooks(["Input", "OTP"], (token2) => {
    const inputToken = merge$1(token2, initInputToken(token2));
    return genOTPStyle(inputToken);
  }, initComponentToken);
  const OTPInput = reactExports.forwardRef((props, ref2) => {
    const {
      className,
      value,
      onChange,
      onActiveChange,
      index,
      mask: mask2,
      onFocus,
      ...restProps
    } = props;
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const prefixCls = getPrefixCls("otp");
    const maskValue = typeof mask2 === "string" ? mask2 : value;
    const inputRef = reactExports.useRef(null);
    reactExports.useImperativeHandle(ref2, () => inputRef.current);
    const onInternalChange = (e) => {
      onChange(index, e.target.value);
    };
    const syncSelection = () => {
      wrapperRaf(() => {
        const inputEle = inputRef.current?.input;
        if (document.activeElement === inputEle && inputEle) {
          inputEle.select();
        }
      });
    };
    const onInternalFocus = (e) => {
      onFocus?.(e);
      syncSelection();
    };
    const onInternalKeyDown = (event) => {
      const {
        key,
        ctrlKey,
        metaKey
      } = event;
      if (key === "ArrowLeft") {
        onActiveChange(index - 1);
      } else if (key === "ArrowRight") {
        onActiveChange(index + 1);
      } else if (key === "z" && (ctrlKey || metaKey)) {
        event.preventDefault();
      } else if (key === "Backspace" && !value) {
        onActiveChange(index - 1);
      }
      syncSelection();
    };
    return reactExports.createElement("span", {
      className: `${prefixCls}-input-wrapper`,
      role: "presentation"
    }, mask2 && value !== "" && value !== void 0 && reactExports.createElement("span", {
      className: `${prefixCls}-mask-icon`,
      "aria-hidden": "true"
    }, maskValue), reactExports.createElement(Input$1, {
      "aria-label": `OTP Input ${index + 1}`,
      type: mask2 === true ? "password" : "text",
      ...restProps,
      ref: inputRef,
      value,
      onInput: onInternalChange,
      onFocus: onInternalFocus,
      onKeyDown: onInternalKeyDown,
      onMouseDown: syncSelection,
      onMouseUp: syncSelection,
      className: clsx(className, {
        [`${prefixCls}-mask-input`]: mask2
      })
    }));
  });
  function strToArr(str) {
    return (str || "").split("");
  }
  const Separator = (props) => {
    const {
      index,
      prefixCls,
      separator,
      className: semanticClassName,
      style: semanticStyle
    } = props;
    const separatorNode = typeof separator === "function" ? separator(index) : separator;
    if (!separatorNode) {
      return null;
    }
    return reactExports.createElement("span", {
      className: clsx(`${prefixCls}-separator`, semanticClassName),
      style: semanticStyle
    }, separatorNode);
  };
  const OTP = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls: customizePrefixCls,
      length: length2 = 6,
      size: customSize,
      defaultValue: defaultValue2,
      value,
      onChange,
      formatter,
      separator,
      variant,
      disabled,
      status: customStatus,
      autoFocus,
      mask: mask2,
      type: type4,
      autoComplete,
      onInput,
      onFocus,
      inputMode,
      classNames,
      styles,
      className,
      style: style2,
      ...restProps
    } = props;
    const {
      classNames: contextClassNames,
      styles: contextStyles,
      getPrefixCls,
      direction,
      style: contextStyle,
      className: contextClassName
    } = useComponentConfig("otp");
    const prefixCls = getPrefixCls("otp", customizePrefixCls);
    const mergedProps = {
      ...props,
      length: length2
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const domAttrs = pickAttrs(restProps, {
      aria: true,
      data: true,
      attr: true
    });
    const [hashId, cssVarCls] = useStyle$a(prefixCls);
    const mergedSize = useSize((ctx) => customSize ?? ctx);
    const formContext = reactExports.useContext(FormItemInputContext);
    const mergedStatus = getMergedStatus(formContext.status, customStatus);
    const proxyFormContext = reactExports.useMemo(() => ({
      ...formContext,
      status: mergedStatus,
      hasFeedback: false,
      feedbackIcon: null
    }), [formContext, mergedStatus]);
    const containerRef = reactExports.useRef(null);
    const refs = reactExports.useRef({});
    reactExports.useImperativeHandle(ref2, () => ({
      focus: () => {
        refs.current[0]?.focus();
      },
      blur: () => {
        for (let i2 = 0; i2 < length2; i2 += 1) {
          refs.current[i2]?.blur();
        }
      },
      nativeElement: containerRef.current
    }));
    const internalFormatter = (txt) => formatter ? formatter(txt) : txt;
    const [valueCells, setValueCells] = reactExports.useState(() => strToArr(internalFormatter(defaultValue2 || "")));
    reactExports.useEffect(() => {
      if (value !== void 0) {
        setValueCells(strToArr(value));
      }
    }, [value]);
    const triggerValueCellsChange = useEvent$1((nextValueCells) => {
      setValueCells(nextValueCells);
      if (onInput) {
        onInput(nextValueCells);
      }
      if (onChange && nextValueCells.length === length2 && nextValueCells.every((c2) => c2) && nextValueCells.some((c2, index) => valueCells[index] !== c2)) {
        onChange(nextValueCells.join(""));
      }
    });
    const patchValue = useEvent$1((index, txt) => {
      let nextCells = _toConsumableArray(valueCells);
      for (let i2 = 0; i2 < index; i2 += 1) {
        if (!nextCells[i2]) {
          nextCells[i2] = "";
        }
      }
      if (txt.length <= 1) {
        nextCells[index] = txt;
      } else {
        nextCells = nextCells.slice(0, index).concat(strToArr(txt));
      }
      nextCells = nextCells.slice(0, length2);
      for (let i2 = nextCells.length - 1; i2 >= 0; i2 -= 1) {
        if (nextCells[i2]) {
          break;
        }
        nextCells.pop();
      }
      const formattedValue = internalFormatter(nextCells.map((c2) => c2 || " ").join(""));
      nextCells = strToArr(formattedValue).map((c2, i2) => {
        if (c2 === " " && !nextCells[i2]) {
          return nextCells[i2];
        }
        return c2;
      });
      return nextCells;
    });
    const onInputChange = (index, txt) => {
      const nextCells = patchValue(index, txt);
      const nextIndex = Math.min(index + txt.length, length2 - 1);
      if (nextIndex !== index && nextCells[index] !== void 0) {
        refs.current[nextIndex]?.focus();
      }
      triggerValueCellsChange(nextCells);
    };
    const onInputActiveChange = (nextIndex) => {
      refs.current[nextIndex]?.focus();
    };
    const onInputFocus = (event, index) => {
      for (let i2 = 0; i2 < index; i2 += 1) {
        if (!refs.current[i2]?.input?.value) {
          refs.current[i2]?.focus();
          break;
        }
      }
      onFocus?.(event);
    };
    const inputSharedProps = {
      variant,
      disabled,
      status: mergedStatus,
      mask: mask2,
      type: type4,
      inputMode,
      autoComplete
    };
    return reactExports.createElement("div", {
      ...domAttrs,
      ref: containerRef,
      className: clsx(className, prefixCls, {
        [`${prefixCls}-sm`]: mergedSize === "small",
        [`${prefixCls}-lg`]: mergedSize === "large",
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, cssVarCls, hashId, contextClassName, mergedClassNames.root),
      style: {
        ...mergedStyles.root,
        ...contextStyle,
        ...style2
      },
      role: "group"
    }, reactExports.createElement(FormItemInputContext.Provider, {
      value: proxyFormContext
    }, Array.from({
      length: length2
    }).map((_2, index) => {
      const key = `otp-${index}`;
      const singleValue = valueCells[index] || "";
      return reactExports.createElement(reactExports.Fragment, {
        key
      }, reactExports.createElement(OTPInput, {
        ref: (inputEle) => {
          refs.current[index] = inputEle;
        },
        index,
        size: mergedSize,
        htmlSize: 1,
        className: clsx(mergedClassNames.input, `${prefixCls}-input`),
        style: mergedStyles.input,
        onChange: onInputChange,
        value: singleValue,
        onActiveChange: onInputActiveChange,
        autoFocus: index === 0 && autoFocus,
        onFocus: (event) => onInputFocus(event, index),
        ...inputSharedProps
      }), index < length2 - 1 && reactExports.createElement(Separator, {
        separator,
        index,
        prefixCls,
        className: clsx(mergedClassNames.separator),
        style: mergedStyles.separator
      }));
    })));
  });
  var EyeInvisibleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { "tag": "path", "attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, "name": "eye-invisible", "theme": "outlined" };
  function _extends$9() {
    _extends$9 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$9.apply(this, arguments);
  }
  const EyeInvisibleOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends$9({}, props, {
    ref: ref2,
    icon: EyeInvisibleOutlined$1
  }));
  const RefIcon$5 = reactExports.forwardRef(EyeInvisibleOutlined);
  var EyeOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
  function _extends$8() {
    _extends$8 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$8.apply(this, arguments);
  }
  const EyeOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends$8({}, props, {
    ref: ref2,
    icon: EyeOutlined$1
  }));
  const RefIcon$4 = reactExports.forwardRef(EyeOutlined);
  const defaultIconRender = (visible) => visible ? reactExports.createElement(RefIcon$4, null) : reactExports.createElement(RefIcon$5, null);
  const actionMap = {
    click: "onClick",
    hover: "onMouseOver"
  };
  const Password = reactExports.forwardRef((props, ref2) => {
    const {
      disabled: customDisabled,
      action: action2 = "click",
      visibilityToggle = true,
      iconRender = defaultIconRender,
      suffix
    } = props;
    const disabled = reactExports.useContext(DisabledContext);
    const mergedDisabled = customDisabled ?? disabled;
    const visibilityControlled = typeof visibilityToggle === "object" && visibilityToggle.visible !== void 0;
    const [visible, setVisible] = reactExports.useState(() => visibilityControlled ? visibilityToggle.visible : false);
    const inputRef = reactExports.useRef(null);
    reactExports.useEffect(() => {
      if (visibilityControlled) {
        setVisible(visibilityToggle.visible);
      }
    }, [visibilityControlled, visibilityToggle]);
    const removePasswordTimeout = useRemovePasswordTimeout(inputRef);
    const onVisibleChange = () => {
      if (mergedDisabled) {
        return;
      }
      if (visible) {
        removePasswordTimeout();
      }
      const nextVisible = !visible;
      setVisible(nextVisible);
      if (typeof visibilityToggle === "object") {
        visibilityToggle.onVisibleChange?.(nextVisible);
      }
    };
    const getIcon = (prefixCls2) => {
      const iconTrigger = actionMap[action2] || "";
      const icon = iconRender(visible);
      const iconProps = {
        [iconTrigger]: onVisibleChange,
        className: `${prefixCls2}-icon`,
        key: "passwordIcon",
        onMouseDown: (e) => {
          e.preventDefault();
        },
        onMouseUp: (e) => {
          e.preventDefault();
        }
      };
      return reactExports.cloneElement( reactExports.isValidElement(icon) ? icon : reactExports.createElement("span", null, icon), iconProps);
    };
    const {
      className,
      prefixCls: customizePrefixCls,
      inputPrefixCls: customizeInputPrefixCls,
      size,
      ...restProps
    } = props;
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
    const prefixCls = getPrefixCls("input-password", customizePrefixCls);
    const suffixIcon = visibilityToggle && getIcon(prefixCls);
    const inputClassName = clsx(prefixCls, className, {
      [`${prefixCls}-${size}`]: !!size
    });
    const omittedProps = {
      ...omit(restProps, ["suffix", "iconRender", "visibilityToggle"]),
      type: visible ? "text" : "password",
      className: inputClassName,
      prefixCls: inputPrefixCls,
      suffix: reactExports.createElement(reactExports.Fragment, null, suffixIcon, suffix)
    };
    if (size) {
      omittedProps.size = size;
    }
    return reactExports.createElement(Input$1, {
      ref: composeRef(ref2, inputRef),
      ...omittedProps
    });
  });
  const genSearchStyle = (token2) => {
    const {
      componentCls
    } = token2;
    const btnCls = `${componentCls}-btn`;
    return {
      [componentCls]: {
        width: "100%",
[btnCls]: {
          "&-filled": {
            background: token2.colorFillTertiary,
            "&:not(:disabled)": {
              "&:hover": {
                background: token2.colorFillSecondary
              },
              "&:active": {
                background: token2.colorFill
              }
            }
          }
        }
      }
    };
  };
  const useStyle$9 = genStyleHooks(["Input", "Search"], genSearchStyle);
  const Search$2 = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls: customizePrefixCls,
      inputPrefixCls: customizeInputPrefixCls,
      className,
      size: customizeSize,
      style: style2,
      enterButton = false,
      addonAfter,
      loading,
      disabled,
      onSearch: customOnSearch,
      onChange: customOnChange,
      onCompositionStart,
      onCompositionEnd,
      variant,
      onPressEnter: customOnPressEnter,
      classNames,
      styles,
      hidden,
      ...restProps
    } = props;
    const {
      direction,
      getPrefixCls,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("inputSearch");
    const mergedProps = {
      ...props,
      enterButton
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    }, {
      button: {
        _default: "root"
      }
    });
    const composedRef = reactExports.useRef(false);
    const prefixCls = getPrefixCls("input-search", customizePrefixCls);
    const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
    const [hashId, cssVarCls] = useStyle$9(prefixCls);
    const {
      compactSize
    } = useCompactItemContext(prefixCls, direction);
    const size = useSize((ctx) => customizeSize ?? compactSize ?? ctx);
    const inputRef = reactExports.useRef(null);
    const onChange = (e) => {
      if (e?.target && e.type === "click" && customOnSearch) {
        customOnSearch(e.target.value, e, {
          source: "clear"
        });
      }
      customOnChange?.(e);
    };
    const onMouseDown = (e) => {
      if (document.activeElement === inputRef.current?.input) {
        e.preventDefault();
      }
    };
    const onSearch = (e) => {
      if (customOnSearch) {
        customOnSearch(inputRef.current?.input?.value, e, {
          source: "input"
        });
      }
    };
    const onPressEnter = (e) => {
      if (composedRef.current || loading) {
        return;
      }
      customOnPressEnter?.(e);
      onSearch(e);
    };
    const searchIcon = typeof enterButton === "boolean" ? reactExports.createElement(RefIcon$d, null) : null;
    const btnPrefixCls = `${prefixCls}-btn`;
    const btnClassName = clsx(btnPrefixCls, {
      [`${btnPrefixCls}-${variant}`]: variant
    });
    let button;
    const enterButtonAsElement = enterButton || {};
    const isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
    if (isAntdButton || enterButtonAsElement.type === "button") {
      button = cloneElement(enterButtonAsElement, {
        onMouseDown,
        onClick: (e) => {
          enterButtonAsElement?.props?.onClick?.(e);
          onSearch(e);
        },
        key: "enterButton",
        ...isAntdButton ? {
          className: btnClassName,
          size
        } : {}
      });
    } else {
      button = reactExports.createElement(Button$1, {
        classNames: mergedClassNames.button,
        styles: mergedStyles.button,
        className: btnClassName,
        color: enterButton ? "primary" : "default",
        size,
        disabled,
        key: "enterButton",
        onMouseDown,
        onClick: onSearch,
        loading,
        icon: searchIcon,
        variant: variant === "borderless" || variant === "filled" || variant === "underlined" ? "text" : enterButton ? "solid" : void 0
      }, enterButton);
    }
    if (addonAfter) {
      button = [button, cloneElement(addonAfter, {
        key: "addonAfter"
      })];
    }
    const mergedClassName = clsx(prefixCls, cssVarCls, {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-${size}`]: !!size,
      [`${prefixCls}-with-button`]: !!enterButton
    }, className, hashId, mergedClassNames.root);
    const handleOnCompositionStart = (e) => {
      composedRef.current = true;
      onCompositionStart?.(e);
    };
    const handleOnCompositionEnd = (e) => {
      composedRef.current = false;
      onCompositionEnd?.(e);
    };
    const rootProps = pickAttrs(restProps, {
      data: true
    });
    const inputProps = omit({
      ...restProps,
      classNames: omit(mergedClassNames, ["button", "root"]),
      styles: omit(mergedStyles, ["button", "root"]),
      prefixCls: inputPrefixCls,
      type: "search",
      size,
      variant,
      onPressEnter,
      onCompositionStart: handleOnCompositionStart,
      onCompositionEnd: handleOnCompositionEnd,
      onChange,
      disabled
    }, Object.keys(rootProps));
    return reactExports.createElement(Compact$1, {
      className: mergedClassName,
      style: {
        ...style2,
        ...mergedStyles.root
      },
      ...rootProps,
      hidden
    }, reactExports.createElement(Input$1, {
      ref: composeRef(inputRef, ref2),
      ...inputProps
    }), button);
  });
  const HIDDEN_TEXTAREA_STYLE = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`;
  const SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"];
  const computedStyleCache = {};
  let hiddenTextarea;
  function calculateNodeStyling(node2, useCache2 = false) {
    const nodeRef = node2.getAttribute("id") || node2.getAttribute("data-reactid") || node2.getAttribute("name");
    if (useCache2 && computedStyleCache[nodeRef]) {
      return computedStyleCache[nodeRef];
    }
    const style2 = window.getComputedStyle(node2);
    const boxSizing = style2.getPropertyValue("box-sizing") || style2.getPropertyValue("-moz-box-sizing") || style2.getPropertyValue("-webkit-box-sizing");
    const paddingSize = parseFloat(style2.getPropertyValue("padding-bottom")) + parseFloat(style2.getPropertyValue("padding-top"));
    const borderSize = parseFloat(style2.getPropertyValue("border-bottom-width")) + parseFloat(style2.getPropertyValue("border-top-width"));
    const sizingStyle = SIZING_STYLE.map((name) => `${name}:${style2.getPropertyValue(name)}`).join(";");
    const nodeInfo = {
      sizingStyle,
      paddingSize,
      borderSize,
      boxSizing
    };
    if (useCache2 && nodeRef) {
      computedStyleCache[nodeRef] = nodeInfo;
    }
    return nodeInfo;
  }
  function calculateAutoSizeStyle(uiTextNode, useCache2 = false, minRows = null, maxRows = null) {
    if (!hiddenTextarea) {
      hiddenTextarea = document.createElement("textarea");
      hiddenTextarea.setAttribute("tab-index", "-1");
      hiddenTextarea.setAttribute("aria-hidden", "true");
      hiddenTextarea.setAttribute("name", "hiddenTextarea");
      document.body.appendChild(hiddenTextarea);
    }
    if (uiTextNode.getAttribute("wrap")) {
      hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
    } else {
      hiddenTextarea.removeAttribute("wrap");
    }
    const {
      paddingSize,
      borderSize,
      boxSizing,
      sizingStyle
    } = calculateNodeStyling(uiTextNode, useCache2);
    hiddenTextarea.setAttribute("style", `${sizingStyle};${HIDDEN_TEXTAREA_STYLE}`);
    hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
    let minHeight = void 0;
    let maxHeight = void 0;
    let overflowY;
    let height = hiddenTextarea.scrollHeight;
    if (boxSizing === "border-box") {
      height += borderSize;
    } else if (boxSizing === "content-box") {
      height -= paddingSize;
    }
    if (minRows !== null || maxRows !== null) {
      hiddenTextarea.value = " ";
      const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
      if (minRows !== null) {
        minHeight = singleRowHeight * minRows;
        if (boxSizing === "border-box") {
          minHeight = minHeight + paddingSize + borderSize;
        }
        height = Math.max(minHeight, height);
      }
      if (maxRows !== null) {
        maxHeight = singleRowHeight * maxRows;
        if (boxSizing === "border-box") {
          maxHeight = maxHeight + paddingSize + borderSize;
        }
        overflowY = height > maxHeight ? "" : "hidden";
        height = Math.min(maxHeight, height);
      }
    }
    const style2 = {
      height,
      overflowY,
      resize: "none"
    };
    if (minHeight) {
      style2.minHeight = minHeight;
    }
    if (maxHeight) {
      style2.maxHeight = maxHeight;
    }
    return style2;
  }
  function _extends$7() {
    _extends$7 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$7.apply(this, arguments);
  }
  const RESIZE_START = 0;
  const RESIZE_MEASURING = 1;
  const RESIZE_STABLE = 2;
  const ResizableTextArea = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls,
      defaultValue: defaultValue2,
      value,
      autoSize,
      onResize: onResize2,
      className,
      style: style2,
      disabled,
      onChange,
onInternalAutoSize,
      ...restProps
    } = props;
    const [internalValue, setMergedValue] = useControlledState(defaultValue2, value);
    const mergedValue = internalValue ?? "";
    const onInternalChange = (event) => {
      setMergedValue(event.target.value);
      onChange?.(event);
    };
    const textareaRef = reactExports.useRef();
    reactExports.useImperativeHandle(ref2, () => ({
      textArea: textareaRef.current
    }));
    const [minRows, maxRows] = reactExports.useMemo(() => {
      if (autoSize && typeof autoSize === "object") {
        return [autoSize.minRows, autoSize.maxRows];
      }
      return [];
    }, [autoSize]);
    const needAutoSize = !!autoSize;
    const [resizeState, setResizeState] = reactExports.useState(RESIZE_STABLE);
    const [autoSizeStyle, setAutoSizeStyle] = reactExports.useState();
    const startResize = () => {
      setResizeState(RESIZE_START);
    };
    useLayoutEffect(() => {
      if (needAutoSize) {
        startResize();
      }
    }, [value, minRows, maxRows, needAutoSize]);
    useLayoutEffect(() => {
      if (resizeState === RESIZE_START) {
        setResizeState(RESIZE_MEASURING);
      } else if (resizeState === RESIZE_MEASURING) {
        const textareaStyles = calculateAutoSizeStyle(textareaRef.current, false, minRows, maxRows);
        setResizeState(RESIZE_STABLE);
        setAutoSizeStyle(textareaStyles);
      } else ;
    }, [resizeState]);
    const resizeRafRef = reactExports.useRef();
    const cleanRaf = () => {
      wrapperRaf.cancel(resizeRafRef.current);
    };
    const onInternalResize = (size) => {
      if (resizeState === RESIZE_STABLE) {
        onResize2?.(size);
        if (autoSize) {
          cleanRaf();
          resizeRafRef.current = wrapperRaf(() => {
            startResize();
          });
        }
      }
    };
    reactExports.useEffect(() => cleanRaf, []);
    const mergedAutoSizeStyle = needAutoSize ? autoSizeStyle : null;
    const mergedStyle = {
      ...style2,
      ...mergedAutoSizeStyle
    };
    if (resizeState === RESIZE_START || resizeState === RESIZE_MEASURING) {
      mergedStyle.overflowY = "hidden";
      mergedStyle.overflowX = "hidden";
    }
    return reactExports.createElement(RefResizeObserver, {
      onResize: onInternalResize,
      disabled: !(autoSize || onResize2)
    }, reactExports.createElement("textarea", _extends$7({}, restProps, {
      ref: textareaRef,
      style: mergedStyle,
      className: clsx(prefixCls, className, {
        [`${prefixCls}-disabled`]: disabled
      }),
      disabled,
      value: mergedValue,
      onChange: onInternalChange
    })));
  });
  function _extends$6() {
    _extends$6 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$6.apply(this, arguments);
  }
  const TextArea$1 = React.forwardRef(({
    defaultValue: defaultValue2,
    value: customValue,
    onFocus,
    onBlur,
    onChange,
    allowClear,
    maxLength,
    onCompositionStart,
    onCompositionEnd,
    suffix,
    prefixCls = "rc-textarea",
    showCount,
    count,
    className,
    style: style2,
    disabled,
    hidden,
    classNames,
    styles,
    onResize: onResize2,
    onClear,
    onPressEnter,
    readOnly,
    autoSize,
    onKeyDown,
    ...rest
  }, ref2) => {
    const [value, setValue] = useControlledState(defaultValue2, customValue);
    const formatValue = value === void 0 || value === null ? "" : String(value);
    const [focused, setFocused] = React.useState(false);
    const compositionRef = React.useRef(false);
    const [textareaResized, setTextareaResized] = React.useState(null);
    const holderRef = reactExports.useRef(null);
    const resizableTextAreaRef = reactExports.useRef(null);
    const getTextArea = () => resizableTextAreaRef.current?.textArea;
    const focus = () => {
      getTextArea().focus();
    };
    reactExports.useImperativeHandle(ref2, () => ({
      resizableTextArea: resizableTextAreaRef.current,
      focus,
      blur: () => {
        getTextArea().blur();
      },
      nativeElement: holderRef.current?.nativeElement || getTextArea()
    }));
    reactExports.useEffect(() => {
      setFocused((prev2) => !disabled && prev2);
    }, [disabled]);
    const [selection, setSelection] = React.useState(null);
    React.useEffect(() => {
      if (selection) {
        getTextArea().setSelectionRange(...selection);
      }
    }, [selection]);
    const countConfig = useCount(count, showCount);
    const mergedMax = countConfig.max ?? maxLength;
    const hasMaxLength = Number(mergedMax) > 0;
    const valueLength = countConfig.strategy(formatValue);
    const isOutOfRange = !!mergedMax && valueLength > mergedMax;
    const triggerChange = (e, currentValue) => {
      let cutValue = currentValue;
      if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
        cutValue = countConfig.exceedFormatter(currentValue, {
          max: countConfig.max
        });
        if (currentValue !== cutValue) {
          setSelection([getTextArea().selectionStart || 0, getTextArea().selectionEnd || 0]);
        }
      }
      setValue(cutValue);
      resolveOnChange(e.currentTarget, e, onChange, cutValue);
    };
    const onInternalCompositionStart = (e) => {
      compositionRef.current = true;
      onCompositionStart?.(e);
    };
    const onInternalCompositionEnd = (e) => {
      compositionRef.current = false;
      triggerChange(e, e.currentTarget.value);
      onCompositionEnd?.(e);
    };
    const onInternalChange = (e) => {
      triggerChange(e, e.target.value);
    };
    const handleKeyDown = (e) => {
      if (e.key === "Enter" && onPressEnter && !e.nativeEvent.isComposing) {
        onPressEnter(e);
      }
      onKeyDown?.(e);
    };
    const handleFocus = (e) => {
      setFocused(true);
      onFocus?.(e);
    };
    const handleBlur = (e) => {
      setFocused(false);
      onBlur?.(e);
    };
    const handleReset = (e) => {
      setValue("");
      focus();
      resolveOnChange(getTextArea(), e, onChange);
    };
    let suffixNode = suffix;
    let dataCount;
    if (countConfig.show) {
      if (countConfig.showFormatter) {
        dataCount = countConfig.showFormatter({
          value: formatValue,
          count: valueLength,
          maxLength: mergedMax
        });
      } else {
        dataCount = `${valueLength}${hasMaxLength ? ` / ${mergedMax}` : ""}`;
      }
      suffixNode = React.createElement(React.Fragment, null, suffixNode, React.createElement("span", {
        className: clsx(`${prefixCls}-data-count`, classNames?.count),
        style: styles?.count
      }, dataCount));
    }
    const handleResize = (size) => {
      onResize2?.(size);
      if (getTextArea()?.style.height) {
        setTextareaResized(true);
      }
    };
    const isPureTextArea = !autoSize && !showCount && !allowClear;
    return React.createElement(BaseInput, {
      ref: holderRef,
      value: formatValue,
      allowClear,
      handleReset,
      suffix: suffixNode,
      prefixCls,
      classNames: {
        ...classNames,
        affixWrapper: clsx(classNames?.affixWrapper, {
          [`${prefixCls}-show-count`]: showCount,
          [`${prefixCls}-textarea-allow-clear`]: allowClear
        })
      },
      disabled,
      focused,
      className: clsx(className, isOutOfRange && `${prefixCls}-out-of-range`),
      style: {
        ...style2,
        ...textareaResized && !isPureTextArea ? {
          height: "auto"
        } : {}
      },
      dataAttrs: {
        affixWrapper: {
          "data-count": typeof dataCount === "string" ? dataCount : void 0
        }
      },
      hidden,
      readOnly,
      onClear
    }, React.createElement(ResizableTextArea, _extends$6({}, rest, {
      autoSize,
      maxLength,
      onKeyDown: handleKeyDown,
      onChange: onInternalChange,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onCompositionStart: onInternalCompositionStart,
      onCompositionEnd: onInternalCompositionEnd,
      className: clsx(classNames?.textarea),
      style: {
        resize: style2?.resize,
        ...styles?.textarea
      },
      disabled,
      prefixCls,
      onResize: handleResize,
      ref: resizableTextAreaRef,
      readOnly
    })));
  });
  const genTextAreaStyle = (token2) => {
    const {
      componentCls,
      paddingLG
    } = token2;
    const textareaPrefixCls = `${componentCls}-textarea`;
    return {
[`textarea${componentCls}`]: {
        maxWidth: "100%",
height: "auto",
        minHeight: token2.controlHeight,
        lineHeight: token2.lineHeight,
        verticalAlign: "bottom",
        transition: `all ${token2.motionDurationSlow}`,
        resize: "vertical",
        [`&${componentCls}-mouse-active`]: {
          transition: `all ${token2.motionDurationSlow}, height 0s, width 0s`
        }
      },
[`${componentCls}-textarea-affix-wrapper-resize-dirty`]: {
        width: "auto"
      },
      [textareaPrefixCls]: {
        position: "relative",
        "&-show-count": {
          [`${componentCls}-data-count`]: {
            position: "absolute",
            bottom: token2.calc(token2.fontSize).mul(token2.lineHeight).mul(-1).equal(),
            insetInlineEnd: 0,
            color: token2.colorTextDescription,
            whiteSpace: "nowrap",
            pointerEvents: "none"
          }
        },
        [`
        &-allow-clear > ${componentCls},
        &-affix-wrapper${textareaPrefixCls}-has-feedback ${componentCls}
      `]: {
          paddingInlineEnd: paddingLG
        },
        [`&-affix-wrapper${componentCls}-affix-wrapper`]: {
          padding: 0,
          [`> textarea${componentCls}`]: {
            fontSize: "inherit",
            border: "none",
            outline: "none",
            background: "transparent",
            minHeight: token2.calc(token2.controlHeight).sub(token2.calc(token2.lineWidth).mul(2)).equal(),
            "&:focus": {
              boxShadow: "none !important"
            }
          },
          [`${componentCls}-suffix`]: {
            margin: 0,
            "> *:not(:last-child)": {
              marginInline: 0
            },
[`${componentCls}-clear-icon`]: {
              position: "absolute",
              insetInlineEnd: token2.paddingInline,
              insetBlockStart: token2.paddingXS
            },
[`${textareaPrefixCls}-suffix`]: {
              position: "absolute",
              top: 0,
              insetInlineEnd: token2.paddingInline,
              bottom: 0,
              zIndex: 1,
              display: "inline-flex",
              alignItems: "center",
              margin: "auto",
              pointerEvents: "none"
            }
          }
        },
        [`&-affix-wrapper${componentCls}-affix-wrapper-rtl`]: {
          [`${componentCls}-suffix`]: {
            [`${componentCls}-data-count`]: {
              direction: "ltr",
              insetInlineStart: 0
            }
          }
        },
        [`&-affix-wrapper${componentCls}-affix-wrapper-sm`]: {
          [`${componentCls}-suffix`]: {
            [`${componentCls}-clear-icon`]: {
              insetInlineEnd: token2.paddingInlineSM
            }
          }
        }
      }
    };
  };
  const useStyle$8 = genStyleHooks(["Input", "TextArea"], (token2) => {
    const inputToken = merge$1(token2, initInputToken(token2));
    return genTextAreaStyle(inputToken);
  }, initComponentToken, {
    resetFont: false
  });
  const TextArea = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls: customizePrefixCls,
      bordered = true,
      size: customizeSize,
      disabled: customDisabled,
      status: customStatus,
      allowClear,
      classNames,
      rootClassName,
      className,
      style: style2,
      styles,
      variant: customVariant,
      showCount,
      onMouseDown,
      onResize: onResize2,
      ...rest
    } = props;
    const {
      getPrefixCls,
      direction,
      allowClear: contextAllowClear,
      autoComplete: contextAutoComplete,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("textArea");
    const disabled = reactExports.useContext(DisabledContext);
    const mergedDisabled = customDisabled ?? disabled;
    const {
      status: contextStatus,
      hasFeedback,
      feedbackIcon
    } = reactExports.useContext(FormItemInputContext);
    const mergedStatus = getMergedStatus(contextStatus, customStatus);
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props
    });
    const innerRef = reactExports.useRef(null);
    reactExports.useImperativeHandle(ref2, () => ({
      resizableTextArea: innerRef.current?.resizableTextArea,
      focus: (option) => {
        triggerFocus(innerRef.current?.resizableTextArea?.textArea, option);
      },
      blur: () => innerRef.current?.blur(),
      nativeElement: innerRef.current?.nativeElement || null
    }));
    const prefixCls = getPrefixCls("input", customizePrefixCls);
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useSharedStyle(prefixCls, rootClassName);
    useStyle$8(prefixCls, rootCls);
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const mergedSize = useSize((ctx) => customizeSize ?? compactSize ?? ctx);
    const [variant, enableVariantCls] = useVariant("textArea", customVariant, bordered);
    const mergedAllowClear = getAllowClear(allowClear ?? contextAllowClear);
    const [isMouseDown, setIsMouseDown] = reactExports.useState(false);
    const [resizeDirty, setResizeDirty] = reactExports.useState(false);
    const onInternalMouseDown = (e) => {
      setIsMouseDown(true);
      onMouseDown?.(e);
      const onMouseUp = () => {
        setIsMouseDown(false);
        document.removeEventListener("mouseup", onMouseUp);
      };
      document.addEventListener("mouseup", onMouseUp);
    };
    const onInternalResize = (size) => {
      onResize2?.(size);
      if (isMouseDown && typeof getComputedStyle === "function") {
        const ele = innerRef.current?.nativeElement?.querySelector("textarea");
        if (ele && getComputedStyle(ele).resize === "both") {
          setResizeDirty(true);
        }
      }
    };
    return reactExports.createElement(TextArea$1, {
      autoComplete: contextAutoComplete,
      ...rest,
      style: {
        ...mergedStyles.root,
        ...contextStyle,
        ...style2
      },
      styles: mergedStyles,
      disabled: mergedDisabled,
      allowClear: mergedAllowClear,
      className: clsx(
        cssVarCls,
        rootCls,
        className,
        rootClassName,
        compactItemClassnames,
        contextClassName,
        mergedClassNames.root,
{
          [`${prefixCls}-textarea-affix-wrapper-resize-dirty`]: resizeDirty
        }
      ),
      classNames: {
        ...mergedClassNames,
        textarea: clsx({
          [`${prefixCls}-sm`]: mergedSize === "small",
          [`${prefixCls}-lg`]: mergedSize === "large"
        }, hashId, mergedClassNames.textarea, isMouseDown && `${prefixCls}-mouse-active`),
        variant: clsx({
          [`${prefixCls}-${variant}`]: enableVariantCls
        }, getStatusClassNames(prefixCls, mergedStatus)),
        affixWrapper: clsx(`${prefixCls}-textarea-affix-wrapper`, {
          [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
          [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
          [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
          [`${prefixCls}-textarea-show-count`]: showCount || props.count?.show
        }, hashId)
      },
      prefixCls,
      suffix: hasFeedback && reactExports.createElement("span", {
        className: `${prefixCls}-textarea-suffix`
      }, feedbackIcon),
      showCount,
      ref: innerRef,
      onResize: onInternalResize,
      onMouseDown: onInternalMouseDown
    });
  });
  const Input = Input$1;
  Input.Group = Group;
  Input.Search = Search$2;
  Input.TextArea = TextArea;
  Input.Password = Password;
  Input.OTP = OTP;
  var DoubleLeftOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, "name": "double-left", "theme": "outlined" };
  function _extends$5() {
    _extends$5 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$5.apply(this, arguments);
  }
  const DoubleLeftOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends$5({}, props, {
    ref: ref2,
    icon: DoubleLeftOutlined$1
  }));
  const RefIcon$3 = reactExports.forwardRef(DoubleLeftOutlined);
  var DoubleRightOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, "name": "double-right", "theme": "outlined" };
  function _extends$4() {
    _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$4.apply(this, arguments);
  }
  const DoubleRightOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends$4({}, props, {
    ref: ref2,
    icon: DoubleRightOutlined$1
  }));
  const RefIcon$2 = reactExports.forwardRef(DoubleRightOutlined);
  const locale = {
items_per_page: "条/页",
    jump_to: "跳至",
    jump_to_confirm: "确定",
    page: "页",
prev_page: "上一页",
    next_page: "下一页",
    prev_5: "向前 5 页",
    next_5: "向后 5 页",
    prev_3: "向前 3 页",
    next_3: "向后 3 页",
    page_size: "页码"
  };
  const defaultPageSizeOptions = [10, 20, 50, 100];
  const Options = (props) => {
    const {
      pageSizeOptions = defaultPageSizeOptions,
      locale: locale2,
      changeSize,
      pageSize,
      goButton,
      quickGo,
      rootPrefixCls,
      disabled,
      buildOptionText,
      showSizeChanger,
      sizeChangerRender
    } = props;
    const [goInputText, setGoInputText] = React.useState("");
    const getValidValue = React.useMemo(() => {
      return !goInputText || Number.isNaN(goInputText) ? void 0 : Number(goInputText);
    }, [goInputText]);
    const mergeBuildOptionText = typeof buildOptionText === "function" ? buildOptionText : (value) => `${value} ${locale2.items_per_page}`;
    const handleChange = (e) => {
      const value = e.target.value;
      if (/^\d*$/.test(value)) {
        setGoInputText(value);
      }
    };
    const handleBlur = (e) => {
      if (goButton || goInputText === "") {
        return;
      }
      setGoInputText("");
      if (e.relatedTarget && (e.relatedTarget.className.includes(`${rootPrefixCls}-item-link`) || e.relatedTarget.className.includes(`${rootPrefixCls}-item`))) {
        return;
      }
      quickGo?.(getValidValue);
    };
    const go = (e) => {
      if (goInputText === "") {
        return;
      }
      if (e.keyCode === KeyCode.ENTER || e.type === "click") {
        setGoInputText("");
        quickGo?.(getValidValue);
      }
    };
    const getPageSizeOptions = () => {
      if (pageSizeOptions.some((option) => option.toString() === pageSize.toString())) {
        return pageSizeOptions;
      }
      return pageSizeOptions.concat([pageSize]).sort((a2, b) => {
        const numberA = Number.isNaN(Number(a2)) ? 0 : Number(a2);
        const numberB = Number.isNaN(Number(b)) ? 0 : Number(b);
        return numberA - numberB;
      });
    };
    const prefixCls = `${rootPrefixCls}-options`;
    if (!showSizeChanger && !quickGo) {
      return null;
    }
    let changeSelect = null;
    let goInput = null;
    let gotoButton = null;
    if (showSizeChanger && sizeChangerRender) {
      changeSelect = sizeChangerRender({
        disabled,
        size: pageSize,
        onSizeChange: (nextValue) => {
          changeSize?.(Number(nextValue));
        },
        "aria-label": locale2.page_size,
        className: `${prefixCls}-size-changer`,
        options: getPageSizeOptions().map((opt) => ({
          label: mergeBuildOptionText(opt),
          value: opt
        }))
      });
    }
    if (quickGo) {
      if (goButton) {
        gotoButton = typeof goButton === "boolean" ? React.createElement("button", {
          type: "button",
          onClick: go,
          onKeyUp: go,
          disabled,
          className: `${prefixCls}-quick-jumper-button`
        }, locale2.jump_to_confirm) : React.createElement("span", {
          onClick: go,
          onKeyUp: go
        }, goButton);
      }
      goInput = React.createElement("div", {
        className: `${prefixCls}-quick-jumper`
      }, locale2.jump_to, React.createElement("input", {
        disabled,
        type: "text",
        value: goInputText,
        onChange: handleChange,
        onKeyUp: go,
        onBlur: handleBlur,
        "aria-label": locale2.page
      }), locale2.page, gotoButton);
    }
    return React.createElement("li", {
      className: prefixCls
    }, changeSelect, goInput);
  };
  const Pager = (props) => {
    const {
      rootPrefixCls,
      page,
      active,
      className,
      style: style2,
      showTitle,
      onClick,
      onKeyPress,
      itemRender
    } = props;
    const prefixCls = `${rootPrefixCls}-item`;
    const cls = clsx(prefixCls, `${prefixCls}-${page}`, {
      [`${prefixCls}-active`]: active,
      [`${prefixCls}-disabled`]: !page
    }, className);
    const handleClick = () => {
      onClick(page);
    };
    const handleKeyPress = (e) => {
      onKeyPress(e, onClick, page);
    };
    const pager = itemRender(page, "page", React.createElement("a", {
      rel: "nofollow"
    }, page));
    return pager ? React.createElement("li", {
      title: showTitle ? String(page) : null,
      className: cls,
      style: style2,
      onClick: handleClick,
      onKeyDown: handleKeyPress,
      tabIndex: 0
    }, pager) : null;
  };
  function _extends$3() {
    _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$3.apply(this, arguments);
  }
  const defaultItemRender = (_2, __, element) => element;
  function noop$2() {
  }
  function isInteger(v) {
    const value = Number(v);
    return typeof value === "number" && !Number.isNaN(value) && isFinite(value) && Math.floor(value) === value;
  }
  function calculatePage(p2, pageSize, total) {
    const _pageSize = typeof p2 === "undefined" ? pageSize : p2;
    return Math.floor((total - 1) / _pageSize) + 1;
  }
  const Pagination$1 = (props) => {
    const {
prefixCls = "rc-pagination",
      selectPrefixCls = "rc-select",
      className,
      classNames: paginationClassNames,
      styles,
current: currentProp,
      defaultCurrent = 1,
      total = 0,
      pageSize: pageSizeProp,
      defaultPageSize = 10,
      onChange = noop$2,
hideOnSinglePage,
      align,
      showPrevNextJumpers = true,
      showQuickJumper,
      showLessItems,
      showTitle = true,
      onShowSizeChange = noop$2,
      locale: locale$12 = locale,
      style: style2,
      totalBoundaryShowSizeChanger = 50,
      disabled,
      simple,
      showTotal,
      showSizeChanger = total > totalBoundaryShowSizeChanger,
      sizeChangerRender,
      pageSizeOptions,
itemRender = defaultItemRender,
      jumpPrevIcon,
      jumpNextIcon,
      prevIcon,
      nextIcon
    } = props;
    const paginationRef = React.useRef(null);
    const [pageSize, setPageSize] = useControlledState(defaultPageSize, pageSizeProp);
    const [internalCurrent, setCurrent] = useControlledState(defaultCurrent, currentProp);
    const current = Math.max(1, Math.min(internalCurrent, calculatePage(void 0, pageSize, total)));
    const [internalInputVal, setInternalInputVal] = React.useState(current);
    reactExports.useEffect(() => {
      setInternalInputVal(current);
    }, [current]);
    const jumpPrevPage = Math.max(1, current - (showLessItems ? 3 : 5));
    const jumpNextPage = Math.min(calculatePage(void 0, pageSize, total), current + (showLessItems ? 3 : 5));
    function getItemIcon(icon, label) {
      let iconNode = icon || React.createElement("button", {
        type: "button",
        "aria-label": label,
        className: `${prefixCls}-item-link`
      });
      if (typeof icon === "function") {
        iconNode = React.createElement(icon, props);
      }
      return iconNode;
    }
    function getValidValue(e) {
      const inputValue = e.target.value;
      const allPages2 = calculatePage(void 0, pageSize, total);
      let value;
      if (inputValue === "") {
        value = inputValue;
      } else if (Number.isNaN(Number(inputValue))) {
        value = internalInputVal;
      } else if (inputValue >= allPages2) {
        value = allPages2;
      } else {
        value = Number(inputValue);
      }
      return value;
    }
    function isValid(page) {
      return isInteger(page) && page !== current && isInteger(total) && total > 0;
    }
    const shouldDisplayQuickJumper = total > pageSize ? showQuickJumper : false;
    function handleKeyDown(event) {
      if (event.keyCode === KeyCode.UP || event.keyCode === KeyCode.DOWN) {
        event.preventDefault();
      }
    }
    function handleKeyUp(event) {
      const value = getValidValue(event);
      if (value !== internalInputVal) {
        setInternalInputVal(value);
      }
      switch (event.keyCode) {
        case KeyCode.ENTER:
          handleChange(value);
          break;
        case KeyCode.UP:
          handleChange(value - 1);
          break;
        case KeyCode.DOWN:
          handleChange(value + 1);
          break;
      }
    }
    function handleBlur(event) {
      handleChange(getValidValue(event));
    }
    function changePageSize(size) {
      const newCurrent = calculatePage(size, pageSize, total);
      const nextCurrent = current > newCurrent && newCurrent !== 0 ? newCurrent : current;
      setPageSize(size);
      setInternalInputVal(nextCurrent);
      onShowSizeChange?.(current, size);
      setCurrent(nextCurrent);
      onChange?.(nextCurrent, size);
    }
    function handleChange(page) {
      if (isValid(page) && !disabled) {
        const currentPage = calculatePage(void 0, pageSize, total);
        let newPage = page;
        if (page > currentPage) {
          newPage = currentPage;
        } else if (page < 1) {
          newPage = 1;
        }
        if (newPage !== internalInputVal) {
          setInternalInputVal(newPage);
        }
        setCurrent(newPage);
        onChange?.(newPage, pageSize);
        return newPage;
      }
      return current;
    }
    const hasPrev = current > 1;
    const hasNext = current < calculatePage(void 0, pageSize, total);
    function prevHandle() {
      if (hasPrev) handleChange(current - 1);
    }
    function nextHandle() {
      if (hasNext) handleChange(current + 1);
    }
    function jumpPrevHandle() {
      handleChange(jumpPrevPage);
    }
    function jumpNextHandle() {
      handleChange(jumpNextPage);
    }
    function runIfEnter(event, callback, ...restParams) {
      if (event.key === "Enter" || event.charCode === KeyCode.ENTER || event.keyCode === KeyCode.ENTER) {
        callback(...restParams);
      }
    }
    function runIfEnterPrev(event) {
      runIfEnter(event, prevHandle);
    }
    function runIfEnterNext(event) {
      runIfEnter(event, nextHandle);
    }
    function runIfEnterJumpPrev(event) {
      runIfEnter(event, jumpPrevHandle);
    }
    function runIfEnterJumpNext(event) {
      runIfEnter(event, jumpNextHandle);
    }
    function renderPrev(prevPage2) {
      const prevButton = itemRender(prevPage2, "prev", getItemIcon(prevIcon, "prev page"));
      return React.isValidElement(prevButton) ? React.cloneElement(prevButton, {
        disabled: !hasPrev
      }) : prevButton;
    }
    function renderNext(nextPage2) {
      const nextButton = itemRender(nextPage2, "next", getItemIcon(nextIcon, "next page"));
      return React.isValidElement(nextButton) ? React.cloneElement(nextButton, {
        disabled: !hasNext
      }) : nextButton;
    }
    function handleGoTO(event) {
      if (event.type === "click" || event.keyCode === KeyCode.ENTER) {
        handleChange(internalInputVal);
      }
    }
    let jumpPrev = null;
    const dataOrAriaAttributeProps = pickAttrs(props, {
      aria: true,
      data: true
    });
    const totalText = showTotal && React.createElement("li", {
      className: `${prefixCls}-total-text`
    }, showTotal(total, [total === 0 ? 0 : (current - 1) * pageSize + 1, current * pageSize > total ? total : current * pageSize]));
    let jumpNext = null;
    const allPages = calculatePage(void 0, pageSize, total);
    if (hideOnSinglePage && total <= pageSize) {
      return null;
    }
    const pagerList = [];
    const pagerProps = {
      rootPrefixCls: prefixCls,
      onClick: handleChange,
      onKeyPress: runIfEnter,
      showTitle,
      itemRender,
      page: -1,
      className: paginationClassNames?.item,
      style: styles?.item
    };
    const prevPage = current - 1 > 0 ? current - 1 : 0;
    const nextPage = current + 1 < allPages ? current + 1 : allPages;
    const goButton = showQuickJumper && showQuickJumper.goButton;
    const isReadOnly = typeof simple === "object" ? simple.readOnly : !simple;
    let gotoButton = goButton;
    let simplePager = null;
    if (simple) {
      if (goButton) {
        if (typeof goButton === "boolean") {
          gotoButton = React.createElement("button", {
            type: "button",
            onClick: handleGoTO,
            onKeyUp: handleGoTO
          }, locale$12.jump_to_confirm);
        } else {
          gotoButton = React.createElement("span", {
            onClick: handleGoTO,
            onKeyUp: handleGoTO
          }, goButton);
        }
        gotoButton = React.createElement("li", {
          title: showTitle ? `${locale$12.jump_to}${current}/${allPages}` : null,
          className: `${prefixCls}-simple-pager`
        }, gotoButton);
      }
      simplePager = React.createElement("li", {
        title: showTitle ? `${current}/${allPages}` : null,
        className: clsx(`${prefixCls}-simple-pager`, paginationClassNames?.item),
        style: styles?.item
      }, isReadOnly ? internalInputVal : React.createElement("input", {
        type: "text",
        "aria-label": locale$12.jump_to,
        value: internalInputVal,
        disabled,
        onKeyDown: handleKeyDown,
        onKeyUp: handleKeyUp,
        onChange: handleKeyUp,
        onBlur: handleBlur,
        size: 3
      }), React.createElement("span", {
        className: `${prefixCls}-slash`
      }, "/"), allPages);
    }
    const pageBufferSize = showLessItems ? 1 : 2;
    if (allPages <= 3 + pageBufferSize * 2) {
      if (!allPages) {
        pagerList.push( React.createElement(Pager, _extends$3({}, pagerProps, {
          key: "noPager",
          page: 1,
          className: `${prefixCls}-item-disabled`
        })));
      }
      for (let i2 = 1; i2 <= allPages; i2 += 1) {
        pagerList.push( React.createElement(Pager, _extends$3({}, pagerProps, {
          key: i2,
          page: i2,
          active: current === i2
        })));
      }
    } else {
      const prevItemTitle = showLessItems ? locale$12.prev_3 : locale$12.prev_5;
      const nextItemTitle = showLessItems ? locale$12.next_3 : locale$12.next_5;
      const jumpPrevContent = itemRender(jumpPrevPage, "jump-prev", getItemIcon(jumpPrevIcon, "prev page"));
      const jumpNextContent = itemRender(jumpNextPage, "jump-next", getItemIcon(jumpNextIcon, "next page"));
      if (showPrevNextJumpers) {
        jumpPrev = jumpPrevContent ? React.createElement("li", {
          title: showTitle ? prevItemTitle : null,
          key: "prev",
          onClick: jumpPrevHandle,
          tabIndex: 0,
          onKeyDown: runIfEnterJumpPrev,
          className: clsx(`${prefixCls}-jump-prev`, {
            [`${prefixCls}-jump-prev-custom-icon`]: !!jumpPrevIcon
          })
        }, jumpPrevContent) : null;
        jumpNext = jumpNextContent ? React.createElement("li", {
          title: showTitle ? nextItemTitle : null,
          key: "next",
          onClick: jumpNextHandle,
          tabIndex: 0,
          onKeyDown: runIfEnterJumpNext,
          className: clsx(`${prefixCls}-jump-next`, {
            [`${prefixCls}-jump-next-custom-icon`]: !!jumpNextIcon
          })
        }, jumpNextContent) : null;
      }
      let left = Math.max(1, current - pageBufferSize);
      let right = Math.min(current + pageBufferSize, allPages);
      if (current - 1 <= pageBufferSize) {
        right = 1 + pageBufferSize * 2;
      }
      if (allPages - current <= pageBufferSize) {
        left = allPages - pageBufferSize * 2;
      }
      for (let i2 = left; i2 <= right; i2 += 1) {
        pagerList.push( React.createElement(Pager, _extends$3({}, pagerProps, {
          key: i2,
          page: i2,
          active: current === i2
        })));
      }
      if (current - 1 >= pageBufferSize * 2 && current !== 1 + 2) {
        pagerList[0] = React.cloneElement(pagerList[0], {
          className: clsx(`${prefixCls}-item-after-jump-prev`, pagerList[0].props.className)
        });
        pagerList.unshift(jumpPrev);
      }
      if (allPages - current >= pageBufferSize * 2 && current !== allPages - 2) {
        const lastOne = pagerList[pagerList.length - 1];
        pagerList[pagerList.length - 1] = React.cloneElement(lastOne, {
          className: clsx(`${prefixCls}-item-before-jump-next`, lastOne.props.className)
        });
        pagerList.push(jumpNext);
      }
      if (left !== 1) {
        pagerList.unshift( React.createElement(Pager, _extends$3({}, pagerProps, {
          key: 1,
          page: 1
        })));
      }
      if (right !== allPages) {
        pagerList.push( React.createElement(Pager, _extends$3({}, pagerProps, {
          key: allPages,
          page: allPages
        })));
      }
    }
    let prev2 = renderPrev(prevPage);
    if (prev2) {
      const prevDisabled = !hasPrev || !allPages;
      prev2 = React.createElement("li", {
        title: showTitle ? locale$12.prev_page : null,
        onClick: prevHandle,
        tabIndex: prevDisabled ? null : 0,
        onKeyDown: runIfEnterPrev,
        className: clsx(`${prefixCls}-prev`, paginationClassNames?.item, {
          [`${prefixCls}-disabled`]: prevDisabled
        }),
        style: styles?.item,
        "aria-disabled": prevDisabled
      }, prev2);
    }
    let next2 = renderNext(nextPage);
    if (next2) {
      let nextDisabled, nextTabIndex;
      if (simple) {
        nextDisabled = !hasNext;
        nextTabIndex = hasPrev ? 0 : null;
      } else {
        nextDisabled = !hasNext || !allPages;
        nextTabIndex = nextDisabled ? null : 0;
      }
      next2 = React.createElement("li", {
        title: showTitle ? locale$12.next_page : null,
        onClick: nextHandle,
        tabIndex: nextTabIndex,
        onKeyDown: runIfEnterNext,
        className: clsx(`${prefixCls}-next`, paginationClassNames?.item, {
          [`${prefixCls}-disabled`]: nextDisabled
        }),
        style: styles?.item,
        "aria-disabled": nextDisabled
      }, next2);
    }
    const cls = clsx(prefixCls, className, {
      [`${prefixCls}-start`]: align === "start",
      [`${prefixCls}-center`]: align === "center",
      [`${prefixCls}-end`]: align === "end",
      [`${prefixCls}-simple`]: simple,
      [`${prefixCls}-disabled`]: disabled
    });
    return React.createElement("ul", _extends$3({
      className: cls,
      style: style2,
      ref: paginationRef
    }, dataOrAriaAttributeProps), totalText, prev2, simple ? simplePager : pagerList, next2, React.createElement(Options, {
      locale: locale$12,
      rootPrefixCls: prefixCls,
      disabled,
      selectPrefixCls,
      changeSize: changePageSize,
      pageSize,
      pageSizeOptions,
      quickGo: shouldDisplayQuickJumper ? handleChange : null,
      goButton: gotoButton,
      showSizeChanger,
      sizeChangerRender
    }));
  };
  const genPaginationDisabledStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-disabled`]: {
        "&, &:hover": {
          cursor: "not-allowed",
          [`${componentCls}-item-link`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed"
          }
        },
        "&:focus-visible": {
          cursor: "not-allowed",
          [`${componentCls}-item-link`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed"
          }
        }
      },
      [`&${componentCls}-disabled`]: {
        cursor: "not-allowed",
        [`${componentCls}-item`]: {
          cursor: "not-allowed",
          backgroundColor: "transparent",
          "&:hover, &:active": {
            backgroundColor: "transparent"
          },
          a: {
            color: token2.colorTextDisabled,
            backgroundColor: "transparent",
            border: "none",
            cursor: "not-allowed"
          },
          "&-active": {
            borderColor: token2.colorBorder,
            backgroundColor: token2.itemActiveBgDisabled,
            "&:hover, &:active": {
              backgroundColor: token2.itemActiveBgDisabled
            },
            a: {
              color: token2.itemActiveColorDisabled
            }
          }
        },
        [`${componentCls}-item-link`]: {
          color: token2.colorTextDisabled,
          cursor: "not-allowed",
          "&:hover, &:active": {
            backgroundColor: "transparent"
          },
          [`${componentCls}-simple&`]: {
            backgroundColor: "transparent",
            "&:hover, &:active": {
              backgroundColor: "transparent"
            }
          }
        },
        [`${componentCls}-simple-pager`]: {
          color: token2.colorTextDisabled
        },
        [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
          [`${componentCls}-item-link-icon`]: {
            opacity: 0
          },
          [`${componentCls}-item-ellipsis`]: {
            opacity: 1
          }
        }
      }
    };
  };
  const genPaginationSmallStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`&${componentCls}-small ${componentCls}-options`]: {
        marginInlineStart: token2.paginationMiniOptionsMarginInlineStart,
        "&-quick-jumper": {
          input: {
            ...genInputSmallStyle(token2),
            width: token2.paginationMiniQuickJumperInputWidth
          }
        }
      }
    };
  };
  const genPaginationLargeStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`&${componentCls}-large ${componentCls}-options`]: {
        "&-quick-jumper": {
          input: {
            ...genInputLargeStyle(token2)
          }
        }
      }
    };
  };
  const genPaginationSimpleStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    const [, varRef] = genCssVar(antCls, "pagination");
    return {
      [`&${componentCls}-simple`]: {
        [`${componentCls}-prev, ${componentCls}-next`]: {
          height: varRef(`item-size-actual`),
          lineHeight: varRef(`item-size-actual`),
          verticalAlign: "top",
          [`${componentCls}-item-link`]: {
            height: varRef(`item-size-actual`),
            backgroundColor: "transparent",
            border: 0,
            "&:hover": {
              backgroundColor: token2.colorBgTextHover
            },
            "&:active": {
              backgroundColor: token2.colorBgTextActive
            },
            "&::after": {
              height: varRef(`item-size-actual`),
              lineHeight: varRef(`item-size-actual`)
            }
          }
        },
        [`${componentCls}-simple-pager`]: {
          display: "inline-flex",
          alignItems: "center",
          height: varRef(`item-size-actual`),
          marginInlineEnd: varRef(`item-spacing-actual`),
          input: {
            boxSizing: "border-box",
            height: "100%",
            width: token2.quickJumperInputWidth,
            padding: `0 ${unit$1(token2.paginationItemPaddingInline)}`,
            textAlign: "center",
            backgroundColor: token2.itemInputBg,
            border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
            borderRadius: token2.borderRadius,
            outline: "none",
            transition: `border-color ${token2.motionDurationMid}`,
            color: "inherit",
            "&:hover": {
              borderColor: token2.colorPrimary
            },
            "&:focus": {
              borderColor: token2.colorPrimaryHover,
              boxShadow: `${unit$1(token2.inputOutlineOffset)} 0 ${unit$1(token2.controlOutlineWidth)} ${token2.controlOutline}`
            },
            "&[disabled]": {
              color: token2.colorTextDisabled,
              backgroundColor: token2.colorBgContainerDisabled,
              borderColor: token2.colorBorder,
              cursor: "not-allowed"
            }
          }
        },
        [`&${componentCls}-disabled`]: {
          [`${componentCls}-prev, ${componentCls}-next`]: {
            [`${componentCls}-item-link`]: {
              "&:hover, &:active": {
                backgroundColor: "transparent"
              }
            }
          }
        },
        [`&${componentCls}-small`]: {
          [`${componentCls}-simple-pager`]: {
            input: {
              width: token2.paginationMiniQuickJumperInputWidth
            }
          }
        }
      }
    };
  };
  const genPaginationJumpStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    const [, varRef] = genCssVar(antCls, "pagination");
    return {
      [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
        outline: 0,
        [`${componentCls}-item-container`]: {
          position: "relative",
          [`${componentCls}-item-link-icon`]: {
            color: token2.colorPrimary,
            fontSize: token2.fontSizeSM,
            opacity: 0,
            transition: `all ${token2.motionDurationMid}`,
            "&-svg": {
              top: 0,
              insetInlineEnd: 0,
              bottom: 0,
              insetInlineStart: 0,
              margin: "auto"
            }
          },
          [`${componentCls}-item-ellipsis`]: {
            position: "absolute",
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            display: "block",
            margin: "auto",
            color: token2.colorTextDisabled,
            letterSpacing: token2.paginationEllipsisLetterSpacing,
            textAlign: "center",
            textIndent: token2.paginationEllipsisTextIndent,
            opacity: 1,
            transition: `all ${token2.motionDurationMid}`
          }
        },
        "&:hover": {
          [`${componentCls}-item-link-icon`]: {
            opacity: 1
          },
          [`${componentCls}-item-ellipsis`]: {
            opacity: 0
          }
        }
      },
      [`
    ${componentCls}-prev,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
        marginInlineEnd: varRef(`item-spacing-actual`)
      },
      [`
    ${componentCls}-prev,
    ${componentCls}-next,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
        display: "inline-block",
        minWidth: varRef(`item-size-actual`),
        height: varRef(`item-size-actual`),
        color: token2.colorText,
        fontFamily: token2.fontFamily,
        lineHeight: varRef(`item-size-actual`),
        textAlign: "center",
        verticalAlign: "middle",
        listStyle: "none",
        borderRadius: token2.borderRadius,
        cursor: "pointer",
        transition: `all ${token2.motionDurationMid}`
      },
      [`${componentCls}-prev, ${componentCls}-next`]: {
        outline: 0,
        button: {
          color: token2.colorText,
          cursor: "pointer",
          userSelect: "none"
        },
        [`${componentCls}-item-link`]: {
          display: "block",
          width: "100%",
          height: "100%",
          padding: 0,
          fontSize: token2.fontSizeSM,
          textAlign: "center",
          backgroundColor: "transparent",
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`,
          borderRadius: token2.borderRadius,
          outline: "none",
          transition: `all ${token2.motionDurationMid}`
        },
        [`&:hover ${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgTextHover
        },
        [`&:active ${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgTextActive
        },
        [`&${componentCls}-disabled:hover`]: {
          [`${componentCls}-item-link`]: {
            backgroundColor: "transparent"
          }
        }
      },
      [`${componentCls}-slash`]: {
        marginInlineEnd: token2.paginationSlashMarginInlineEnd,
        marginInlineStart: token2.paginationSlashMarginInlineStart
      },
      [`${componentCls}-options`]: {
        display: "inline-block",
        marginInlineStart: token2.margin,
        verticalAlign: "middle",
        "&-size-changer": {
          width: "auto"
        },
        "&-quick-jumper": {
          display: "inline-block",
          height: varRef(`item-size-actual`),
          marginInlineStart: token2.marginXS,
          lineHeight: varRef(`item-size-actual`),
          verticalAlign: "baseline",
          input: {
            ...genBasicInputStyle(token2),
            ...genBaseOutlinedStyle(token2, {
              borderColor: token2.colorBorder,
              hoverBorderColor: token2.colorPrimaryHover,
              activeBorderColor: token2.colorPrimary,
              activeShadow: token2.activeShadow
            }),
            "&[disabled]": {
              ...genDisabledStyle(token2)
            },
            width: token2.quickJumperInputWidth,
            height: varRef(`item-size-actual`),
            boxSizing: "border-box",
            margin: 0,
            marginInlineStart: varRef(`item-spacing-actual`),
            marginInlineEnd: varRef(`item-spacing-actual`)
          }
        }
      }
    };
  };
  const genPaginationItemStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    const [, varRef] = genCssVar(antCls, "pagination");
    return {
      [`${componentCls}-item`]: {
        display: "inline-block",
        minWidth: varRef(`item-size-actual`),
        height: varRef(`item-size-actual`),
        marginInlineEnd: varRef(`item-spacing-actual`),
        fontFamily: token2.fontFamily,
        lineHeight: unit$1(token2.calc(varRef("item-size-actual")).sub(2).equal()),
        textAlign: "center",
        verticalAlign: "middle",
        listStyle: "none",
        backgroundColor: token2.itemBg,
        border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`,
        borderRadius: token2.borderRadius,
        outline: 0,
        cursor: "pointer",
        userSelect: "none",
        a: {
          display: "block",
          padding: `0 ${unit$1(token2.paginationItemPaddingInline)}`,
          color: token2.colorText,
          "&:hover": {
            textDecoration: "none"
          }
        },
        [`&:not(${componentCls}-item-active)`]: {
          "&:hover": {
            transition: `all ${token2.motionDurationMid}`,
            backgroundColor: token2.colorBgTextHover
          },
          "&:active": {
            backgroundColor: token2.colorBgTextActive
          }
        },
        "&-active": {
          fontWeight: token2.fontWeightStrong,
          backgroundColor: token2.itemActiveBg,
          borderColor: token2.colorPrimary,
          a: {
            color: token2.itemActiveColor
          },
          "&:hover": {
            borderColor: token2.colorPrimaryHover
          },
          "&:hover a": {
            color: token2.itemActiveColorHover
          }
        }
      }
    };
  };
  const genPaginationStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    const [varName, varRef] = genCssVar(antCls, "pagination");
    return {
      [componentCls]: {
        [varName(`item-size-actual`)]: unit$1(token2.itemSize),
        [varName(`item-spacing-actual`)]: unit$1(token2.marginXS),
        "&-small": {
          [varName(`item-size-actual`)]: unit$1(token2.itemSizeSM),
          [varName(`item-spacing-actual`)]: unit$1(token2.marginXXS)
        },
        "&-large": {
          [varName(`item-size-actual`)]: unit$1(token2.itemSizeLG),
          [varName(`item-spacing-actual`)]: unit$1(token2.marginSM)
        },
        ...resetComponent(token2),
        display: "flex",
        alignItems: "center",
        "&-start": {
          justifyContent: "start"
        },
        "&-center": {
          justifyContent: "center"
        },
        "&-end": {
          justifyContent: "end"
        },
        "ul, ol": {
          margin: 0,
          padding: 0,
          listStyle: "none"
        },
        "&::after": {
          display: "block",
          clear: "both",
          height: 0,
          overflow: "hidden",
          visibility: "hidden",
          content: '""'
        },
        [`${componentCls}-total-text`]: {
          display: "inline-block",
          height: varRef(`item-size-actual`),
          marginInlineEnd: varRef(`item-spacing-actual`),
          lineHeight: unit$1(token2.calc(varRef(`item-size-actual`)).sub(2).equal()),
          verticalAlign: "middle"
        },
...genPaginationItemStyle(token2),
...genPaginationJumpStyle(token2),
...genPaginationSimpleStyle(token2),
...genPaginationSmallStyle(token2),
        ...genPaginationLargeStyle(token2),
...genPaginationDisabledStyle(token2),
[`@media only screen and (max-width: ${token2.screenLG}px)`]: {
          [`${componentCls}-item`]: {
            "&-after-jump-prev, &-before-jump-next": {
              display: "none"
            }
          }
        },
        [`@media only screen and (max-width: ${token2.screenSM}px)`]: {
          [`${componentCls}-options`]: {
            display: "none"
          }
        }
      },
[`&${token2.componentCls}-rtl`]: {
        direction: "rtl"
      }
    };
  };
  const genPaginationFocusStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}:not(${componentCls}-disabled)`]: {
        [`${componentCls}-item`]: {
          ...genFocusStyle(token2)
        },
        [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
          "&:focus-visible": {
            [`${componentCls}-item-link-icon`]: {
              opacity: 1
            },
            [`${componentCls}-item-ellipsis`]: {
              opacity: 0
            },
            ...genFocusOutline(token2)
          }
        },
        [`${componentCls}-prev, ${componentCls}-next`]: {
          [`&:focus-visible ${componentCls}-item-link`]: genFocusOutline(token2)
        }
      }
    };
  };
  const prepareComponentToken$6 = (token2) => ({
    itemBg: token2.colorBgContainer,
    itemSize: token2.controlHeight,
    itemSizeSM: token2.controlHeightSM,
    itemSizeLG: token2.controlHeightLG,
    itemActiveBg: token2.colorBgContainer,
    itemActiveColor: token2.colorPrimary,
    itemActiveColorHover: token2.colorPrimaryHover,
    itemLinkBg: token2.colorBgContainer,
    itemActiveColorDisabled: token2.colorTextDisabled,
    itemActiveBgDisabled: token2.controlItemBgActiveDisabled,
    itemInputBg: token2.colorBgContainer,
    miniOptionsSizeChangerTop: 0,
    ...initComponentToken(token2)
  });
  const prepareToken$1 = (token2) => merge$1(token2, {
    inputOutlineOffset: 0,
    quickJumperInputWidth: token2.calc(token2.controlHeightLG).mul(1.25).equal(),
    paginationMiniOptionsMarginInlineStart: token2.calc(token2.marginXXS).div(2).equal(),
    paginationMiniQuickJumperInputWidth: token2.calc(token2.controlHeightLG).mul(1.1).equal(),
    paginationItemPaddingInline: token2.calc(token2.marginXXS).mul(1.5).equal(),
    paginationEllipsisLetterSpacing: token2.calc(token2.marginXXS).div(2).equal(),
    paginationSlashMarginInlineStart: token2.marginSM,
    paginationSlashMarginInlineEnd: token2.marginSM,
    paginationEllipsisTextIndent: "0.13em"
}, initInputToken(token2));
  const useStyle$7 = genStyleHooks("Pagination", (token2) => {
    const paginationToken = prepareToken$1(token2);
    return [genPaginationStyle(paginationToken), genPaginationFocusStyle(paginationToken)];
  }, prepareComponentToken$6);
  const genBorderedStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}${componentCls}-bordered${componentCls}-disabled`]: {
        "&, &:hover": {
          [`${componentCls}-item-link`]: {
            borderColor: token2.colorBorder
          }
        },
        "&:focus-visible": {
          [`${componentCls}-item-link`]: {
            borderColor: token2.colorBorder
          }
        },
        [`${componentCls}-item, ${componentCls}-item-link`]: {
          backgroundColor: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          [`&:hover:not(${componentCls}-item-active)`]: {
            backgroundColor: token2.colorBgContainerDisabled,
            borderColor: token2.colorBorder,
            a: {
              color: token2.colorTextDisabled
            }
          },
          [`&${componentCls}-item-active`]: {
            backgroundColor: token2.itemActiveBgDisabled
          }
        },
        [`${componentCls}-prev, ${componentCls}-next`]: {
          "&:hover button": {
            backgroundColor: token2.colorBgContainerDisabled,
            borderColor: token2.colorBorder,
            color: token2.colorTextDisabled
          },
          [`${componentCls}-item-link`]: {
            backgroundColor: token2.colorBgContainerDisabled,
            borderColor: token2.colorBorder
          }
        }
      },
      [`${componentCls}${componentCls}-bordered`]: {
        [`${componentCls}-prev, ${componentCls}-next`]: {
          "&:hover button": {
            borderColor: token2.colorPrimaryHover,
            backgroundColor: token2.itemBg
          },
          [`${componentCls}-item-link`]: {
            backgroundColor: token2.itemLinkBg,
            borderColor: token2.colorBorder
          },
          [`&:hover ${componentCls}-item-link`]: {
            borderColor: token2.colorPrimary,
            backgroundColor: token2.itemBg,
            color: token2.colorPrimary
          },
          [`&${componentCls}-disabled`]: {
            [`${componentCls}-item-link`]: {
              borderColor: token2.colorBorder,
              color: token2.colorTextDisabled
            }
          }
        },
        [`${componentCls}-item`]: {
          backgroundColor: token2.itemBg,
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
          [`&:hover:not(${componentCls}-item-active)`]: {
            borderColor: token2.colorPrimary,
            backgroundColor: token2.itemBg,
            a: {
              color: token2.colorPrimary
            }
          },
          "&-active": {
            borderColor: token2.colorPrimary
          }
        }
      }
    };
  };
  const BorderedStyle = genSubStyleComponent(["Pagination", "bordered"], (token2) => {
    const paginationToken = prepareToken$1(token2);
    return genBorderedStyle(paginationToken);
  }, prepareComponentToken$6);
  function useShowSizeChanger(showSizeChanger) {
    return reactExports.useMemo(() => {
      if (typeof showSizeChanger === "boolean") {
        return [showSizeChanger, {}];
      }
      if (showSizeChanger && typeof showSizeChanger === "object") {
        return [true, showSizeChanger];
      }
      return [void 0, void 0];
    }, [showSizeChanger]);
  }
  const Pagination = (props) => {
    const {
      align,
      prefixCls: customizePrefixCls,
      selectPrefixCls: customizeSelectPrefixCls,
      className,
      rootClassName,
      style: style2,
      size: customizeSize,
      locale: customLocale,
      responsive,
      showSizeChanger,
      selectComponentClass,
      pageSizeOptions,
      styles,
      classNames,
      ...restProps
    } = props;
    const {
      xs
    } = useBreakpoint(responsive);
    const [, token2] = useToken$1();
    const {
      getPrefixCls,
      direction,
      showSizeChanger: contextShowSizeChangerConfig,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles,
      totalBoundaryShowSizeChanger: contextTotalBoundaryShowSizeChanger
    } = useComponentConfig("pagination");
    const prefixCls = getPrefixCls("pagination", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$7(prefixCls);
    const mergedSize = useSize(customizeSize);
    const isSmall = mergedSize === "small" || !!(xs && !mergedSize && responsive);
    const mergedProps = {
      ...props,
      size: mergedSize
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const [contextLocale] = useLocale("Pagination", locale$4);
    const locale2 = {
      ...contextLocale,
      ...customLocale
    };
    const [propShowSizeChanger, propSizeChangerSelectProps] = useShowSizeChanger(showSizeChanger);
    const [contextShowSizeChanger, contextSizeChangerSelectProps] = useShowSizeChanger(contextShowSizeChangerConfig);
    const mergedShowSizeChanger = propShowSizeChanger ?? contextShowSizeChanger;
    const mergedShowSizeChangerSelectProps = propSizeChangerSelectProps ?? contextSizeChangerSelectProps;
    const SizeChanger = selectComponentClass || Select;
    const mergedPageSizeOptions = reactExports.useMemo(() => {
      return pageSizeOptions ? pageSizeOptions.map(Number) : void 0;
    }, [pageSizeOptions]);
    const sizeChangerRender = (info) => {
      const {
        disabled,
        size: pageSize,
        onSizeChange,
        "aria-label": ariaLabel,
        className: sizeChangerClassName,
        options
      } = info;
      const {
        className: propSizeChangerClassName,
        onChange: propSizeChangerOnChange
      } = mergedShowSizeChangerSelectProps || {};
      const selectedValue = options.find((option) => String(option.value) === String(pageSize))?.value;
      return reactExports.createElement(SizeChanger, {
        disabled,
        showSearch: true,
        popupMatchSelectWidth: false,
        getPopupContainer: (triggerNode) => triggerNode.parentNode,
        "aria-label": ariaLabel,
        options,
        ...mergedShowSizeChangerSelectProps,
        value: selectedValue,
        onChange: (nextSize, option) => {
          onSizeChange?.(nextSize);
          propSizeChangerOnChange?.(nextSize, option);
        },
        size: mergedSize,
        className: clsx(sizeChangerClassName, propSizeChangerClassName)
      });
    };
    const iconsProps = reactExports.useMemo(() => {
      const ellipsis = reactExports.createElement("span", {
        className: `${prefixCls}-item-ellipsis`
      }, "•••");
      const prevIcon = reactExports.createElement("button", {
        className: `${prefixCls}-item-link`,
        type: "button",
        tabIndex: -1
      }, direction === "rtl" ? reactExports.createElement(RefIcon$g, null) : reactExports.createElement(RefIcon$b, null));
      const nextIcon = reactExports.createElement("button", {
        className: `${prefixCls}-item-link`,
        type: "button",
        tabIndex: -1
      }, direction === "rtl" ? reactExports.createElement(RefIcon$b, null) : reactExports.createElement(RefIcon$g, null));
      const jumpPrevIcon = (

reactExports.createElement("a", {
          className: `${prefixCls}-item-link`
        }, reactExports.createElement("div", {
          className: `${prefixCls}-item-container`
        }, direction === "rtl" ? reactExports.createElement(RefIcon$2, {
          className: `${prefixCls}-item-link-icon`
        }) : reactExports.createElement(RefIcon$3, {
          className: `${prefixCls}-item-link-icon`
        }), ellipsis))
      );
      const jumpNextIcon = (

reactExports.createElement("a", {
          className: `${prefixCls}-item-link`
        }, reactExports.createElement("div", {
          className: `${prefixCls}-item-container`
        }, direction === "rtl" ? reactExports.createElement(RefIcon$3, {
          className: `${prefixCls}-item-link-icon`
        }) : reactExports.createElement(RefIcon$2, {
          className: `${prefixCls}-item-link-icon`
        }), ellipsis))
      );
      return {
        prevIcon,
        nextIcon,
        jumpPrevIcon,
        jumpNextIcon
      };
    }, [direction, prefixCls]);
    const selectPrefixCls = getPrefixCls("select", customizeSelectPrefixCls);
    const extendedClassName = clsx({
      [`${prefixCls}-${align}`]: !!align,
      [`${prefixCls}-${mergedSize}`]: mergedSize,
[`${prefixCls}-mini`]: isSmall,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-bordered`]: token2.wireframe
    }, contextClassName, className, rootClassName, mergedClassNames.root, hashId, cssVarCls);
    const mergedStyle = {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    };
    return reactExports.createElement(reactExports.Fragment, null, token2.wireframe && reactExports.createElement(BorderedStyle, {
      prefixCls
    }), reactExports.createElement(Pagination$1, {
      ...iconsProps,
      ...restProps,
      styles: mergedStyles,
      classNames: mergedClassNames,
      style: mergedStyle,
      prefixCls,
      selectPrefixCls,
      className: extendedClassName,
      locale: locale2,
      pageSizeOptions: mergedPageSizeOptions,
      showSizeChanger: mergedShowSizeChanger,
      totalBoundaryShowSizeChanger: restProps.totalBoundaryShowSizeChanger ?? contextTotalBoundaryShowSizeChanger,
      sizeChangerRender
    }));
  };
  const viewSize = 100;
  const borderWidth = viewSize / 5;
  const radius = viewSize / 2 - borderWidth / 2;
  const circumference = radius * 2 * Math.PI;
  const position = 50;
  const CustomCircle = (props) => {
    const {
      dotClassName,
      style: style2,
      hasCircleCls
    } = props;
    return reactExports.createElement("circle", {
      className: clsx(`${dotClassName}-circle`, {
        [`${dotClassName}-circle-bg`]: hasCircleCls
      }),
      r: radius,
      cx: position,
      cy: position,
      strokeWidth: borderWidth,
      style: style2
    });
  };
  const Progress = ({
    percent: percent2,
    prefixCls
  }) => {
    const dotClassName = `${prefixCls}-dot`;
    const holderClassName = `${dotClassName}-holder`;
    const hideClassName = `${holderClassName}-hidden`;
    const [render4, setRender] = reactExports.useState(false);
    useLayoutEffect(() => {
      if (percent2 !== 0) {
        setRender(true);
      }
    }, [percent2 !== 0]);
    const safePtg = Math.max(Math.min(percent2, 100), 0);
    if (!render4) {
      return null;
    }
    const circleStyle = {
      strokeDashoffset: `${circumference / 4}`,
      strokeDasharray: `${circumference * safePtg / 100} ${circumference * (100 - safePtg) / 100}`
    };
    return reactExports.createElement("span", {
      className: clsx(holderClassName, `${dotClassName}-progress`, safePtg <= 0 && hideClassName)
    }, reactExports.createElement("svg", {
      viewBox: `0 0 ${viewSize} ${viewSize}`,
      role: "progressbar",
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      "aria-valuenow": safePtg
    }, reactExports.createElement(CustomCircle, {
      dotClassName,
      hasCircleCls: true
    }), reactExports.createElement(CustomCircle, {
      dotClassName,
      style: circleStyle
    })));
  };
  function Looper(props) {
    const {
      prefixCls,
      percent: percent2 = 0,
      className,
      style: style2
    } = props;
    const dotClassName = `${prefixCls}-dot`;
    const holderClassName = `${dotClassName}-holder`;
    const hideClassName = `${holderClassName}-hidden`;
    return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("span", {
      className: clsx(holderClassName, className, percent2 > 0 && hideClassName),
      style: style2
    }, reactExports.createElement("span", {
      className: clsx(dotClassName, `${prefixCls}-dot-spin`)
    }, [1, 2, 3, 4].map((i2) => reactExports.createElement("i", {
      className: `${prefixCls}-dot-item`,
      key: i2
    })))), reactExports.createElement(Progress, {
      prefixCls,
      percent: percent2
    }));
  }
  function Indicator(props) {
    const {
      prefixCls,
      indicator,
      percent: percent2,
      className,
      style: style2
    } = props;
    const dotClassName = `${prefixCls}-dot`;
    if (indicator && reactExports.isValidElement(indicator)) {
      return cloneElement(indicator, (currentProps) => ({
        className: clsx(currentProps.className, dotClassName, className),
        style: {
          ...currentProps.style,
          ...style2
        },
        percent: percent2
      }));
    }
    return reactExports.createElement(Looper, {
      prefixCls,
      percent: percent2,
      className,
      style: style2
    });
  }
  const antSpinMove = new Keyframe("antSpinMove", {
    to: {
      opacity: 1
    }
  });
  const antRotate = new Keyframe("antRotate", {
    to: {
      transform: "rotate(405deg)"
    }
  });
  const genSpinStyle = (token2) => {
    const {
      componentCls
    } = token2;
    const sectionCls = `${componentCls}-section`;
    return {
      [componentCls]: {
        ...resetComponent(token2),
        position: "relative",
        "&-rtl": {
          direction: "rtl"
        },
[`&${sectionCls}, ${sectionCls}`]: {
          display: "flex",
          alignItems: "center",
          flexDirection: "column",
          gap: token2.paddingSM,
          color: token2.colorPrimary
        },
        [`&${sectionCls}`]: {
          display: "inline-flex"
        },
        [sectionCls]: {
          position: "absolute",
          top: "50%",
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translate(-50%, -50%)",
          zIndex: 1
        },
        [`${componentCls}-description`]: {
          fontSize: token2.fontSize,
          lineHeight: 1
        },
[`${componentCls}-container`]: {
          position: "relative",
          transition: `opacity ${token2.motionDurationSlow}`,
          "&::after": {
            position: "absolute",
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            zIndex: 10,
            width: "100%",
            height: "100%",
            background: token2.colorBgContainer,
            opacity: 0,
            transition: `all ${token2.motionDurationSlow}`,
            content: '""',
            pointerEvents: "none"
          }
        },
"&-spinning": {
          [`${componentCls}-description`]: {
            textShadow: `0 0px 5px ${token2.colorBgContainer}`
          },
          [`${componentCls}-container`]: {
            clear: "both",
            opacity: 0.5,
            userSelect: "none",
            pointerEvents: "none",
            "&::after": {
              opacity: 0.4,
              pointerEvents: "auto"
            }
          }
        },
"&-fullscreen": {
          position: "fixed",
          inset: 0,
          backgroundColor: token2.colorBgMask,
          zIndex: token2.zIndexPopupBase,
          opacity: 0,
          pointerEvents: "none",
          transition: `all ${token2.motionDurationMid}`,
          [`&${componentCls}-spinning`]: {
            opacity: 1,
            pointerEvents: "auto"
          },
          [sectionCls]: {
            color: token2.colorWhite,
            [`${componentCls}-description`]: {
              color: token2.colorTextLightSolid
            }
          }
        }
      }
    };
  };
  const genIndicatorStyle = (token2) => {
    const {
      componentCls,
      antCls,
      motionDurationSlow
    } = token2;
    const [varName, varRef] = genCssVar(antCls, "spin");
    return {
      [componentCls]: {
        [varName("dot-holder-size")]: token2.dotSize,
        [varName("dot-item-size")]: `calc((${varRef("dot-holder-size")} - ${token2.marginXXS} / 2) / 2)`,
        [`${componentCls}-dot`]: {
"&-holder": {
            width: "1em",
            height: "1em",
            fontSize: varRef("dot-holder-size"),
            display: "inline-block",
            transition: ["transform", "opacity"].map((prop) => `${prop} ${motionDurationSlow} ease`).join(", "),
            transformOrigin: "50% 50%",
            lineHeight: 1,
            "&-hidden": {
              transform: "scale(0.3)",
              opacity: 0
            }
          },
position: "relative",
          display: "inline-block",
          fontSize: varRef("dot-holder-size"),
          width: "1em",
          height: "1em",
          "&-spin": {
            transform: "rotate(45deg)",
            animationName: antRotate,
            animationDuration: "1.2s",
            animationIterationCount: "infinite",
            animationTimingFunction: "linear"
          },
"&-item": {
            position: "absolute",
            display: "block",
            width: varRef("dot-item-size"),
            height: varRef("dot-item-size"),
            background: "currentColor",
            borderRadius: "100%",
            transform: "scale(0.75)",
            transformOrigin: "50% 50%",
            opacity: 0.3,
            animationName: antSpinMove,
            animationDuration: "1s",
            animationIterationCount: "infinite",
            animationTimingFunction: "linear",
            animationDirection: "alternate",
            "&:nth-child(1)": {
              top: 0,
              insetInlineStart: 0,
              animationDelay: "0s"
            },
            "&:nth-child(2)": {
              top: 0,
              insetInlineEnd: 0,
              animationDelay: "0.4s"
            },
            "&:nth-child(3)": {
              insetInlineEnd: 0,
              bottom: 0,
              animationDelay: "0.8s"
            },
            "&:nth-child(4)": {
              bottom: 0,
              insetInlineStart: 0,
              animationDelay: "1.2s"
            }
          },
"&-progress": {
            position: "absolute",
            left: "50%",
            top: 0,
            transform: "translateX(-50%)"
          },
          "&-circle": {
            strokeLinecap: "round",
            transition: ["stroke-dashoffset", "stroke-dasharray", "stroke", "stroke-width", "opacity"].map((item) => `${item} ${motionDurationSlow} ease`).join(","),
            fillOpacity: 0,
            stroke: "currentcolor"
          },
          "&-circle-bg": {
            stroke: token2.colorFillSecondary
          }
        }
      }
    };
  };
  const genSizeStyle = (token2) => {
    const {
      componentCls
    } = token2;
    const [varName] = genCssVar(token2.antCls, "spin");
    return {
      [componentCls]: {
        "&-sm": {
          [varName("dot-holder-size")]: token2.dotSizeSM
        },
        "&-lg": {
          [varName("dot-holder-size")]: token2.dotSizeLG
        }
      }
    };
  };
  const prepareComponentToken$5 = (token2) => {
    const {
      controlHeightLG,
      controlHeight
    } = token2;
    return {
      contentHeight: 400,
      dotSize: controlHeightLG / 2,
      dotSizeSM: controlHeightLG * 0.35,
      dotSizeLG: controlHeight
    };
  };
  const useStyle$6 = genStyleHooks("Spin", (token2) => {
    const spinToken = merge$1(token2, {
      spinDotDefault: token2.colorTextDescription
    });
    return [genSpinStyle(spinToken), genIndicatorStyle(spinToken), genSizeStyle(spinToken)];
  }, prepareComponentToken$5);
  const AUTO_INTERVAL = 200;
  const STEP_BUCKETS = [[30, 0.05], [70, 0.03], [96, 0.01]];
  function usePercent(spinning, percent2) {
    const [mockPercent, setMockPercent] = reactExports.useState(0);
    const mockIntervalRef = reactExports.useRef(null);
    const isAuto = percent2 === "auto";
    reactExports.useEffect(() => {
      if (isAuto && spinning) {
        setMockPercent(0);
        mockIntervalRef.current = setInterval(() => {
          setMockPercent((prev2) => {
            const restPTG = 100 - prev2;
            for (let i2 = 0; i2 < STEP_BUCKETS.length; i2 += 1) {
              const [limit2, stepPtg] = STEP_BUCKETS[i2];
              if (prev2 <= limit2) {
                return prev2 + restPTG * stepPtg;
              }
            }
            return prev2;
          });
        }, AUTO_INTERVAL);
      }
      return () => {
        if (mockIntervalRef.current) {
          clearInterval(mockIntervalRef.current);
          mockIntervalRef.current = null;
        }
      };
    }, [isAuto, spinning]);
    return isAuto ? mockPercent : percent2;
  }
  let defaultIndicator;
  function shouldDelay(spinning, delay2) {
    return !!spinning && !!delay2 && !Number.isNaN(Number(delay2));
  }
  const Spin = (props) => {
    const {
      prefixCls: customizePrefixCls,
      spinning: customSpinning = true,
      delay: delay2 = 0,
      className,
      rootClassName,
      size = "default",
      tip,
      description,
      wrapperClassName,
      style: style2,
      children,
      fullscreen = false,
      indicator,
      percent: percent2,
      classNames,
      styles,
      ...restProps
    } = props;
    const {
      getPrefixCls,
      direction,
      indicator: contextIndicator,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("spin");
    const prefixCls = getPrefixCls("spin", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$6(prefixCls);
    const [spinning, setSpinning] = reactExports.useState(() => customSpinning && !shouldDelay(customSpinning, delay2));
    const mergedPercent = usePercent(spinning, percent2);
    reactExports.useEffect(() => {
      if (customSpinning) {
        const showSpinning = debounce$1(delay2, () => {
          setSpinning(true);
        });
        showSpinning();
        return () => {
          showSpinning?.cancel?.();
        };
      }
      setSpinning(false);
    }, [delay2, customSpinning]);
    const mergedDescription = description ?? tip;
    const mergedProps = {
      ...props,
      size,
      spinning,
      tip: mergedDescription,
      description: mergedDescription,
      fullscreen,
      children,
      percent: mergedPercent
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const mergedIndicator = indicator ?? contextIndicator ?? defaultIndicator;
    const hasChildren = typeof children !== "undefined";
    const isNested = hasChildren || fullscreen;
    const indicatorNode = reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Indicator, {
      className: clsx(mergedClassNames.indicator),
      style: mergedStyles.indicator,
      prefixCls,
      indicator: mergedIndicator,
      percent: mergedPercent
    }), mergedDescription && reactExports.createElement("div", {
      className: clsx(`${prefixCls}-description`, mergedClassNames.tip, mergedClassNames.description),
      style: {
        ...mergedStyles.tip,
        ...mergedStyles.description
      }
    }, mergedDescription));
    return reactExports.createElement("div", {
      className: clsx(prefixCls, {
        [`${prefixCls}-sm`]: size === "small",
        [`${prefixCls}-lg`]: size === "large",
        [`${prefixCls}-spinning`]: spinning,
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-fullscreen`]: fullscreen
      }, rootClassName, mergedClassNames.root, fullscreen && mergedClassNames.mask, isNested ? wrapperClassName : [`${prefixCls}-section`, mergedClassNames.section], contextClassName, className, hashId, cssVarCls),
      style: {
        ...mergedStyles.root,
        ...!isNested ? mergedStyles.section : {},
        ...fullscreen ? mergedStyles.mask : {},
        ...contextStyle,
        ...style2
      },
      "aria-live": "polite",
      "aria-busy": spinning,
      ...restProps
    }, spinning && (isNested ? reactExports.createElement("div", {
      className: clsx(`${prefixCls}-section`, mergedClassNames.section),
      style: mergedStyles.section
    }, indicatorNode) : indicatorNode), hasChildren && reactExports.createElement("div", {
      className: clsx(`${prefixCls}-container`, mergedClassNames.container),
      style: mergedStyles.container
    }, children));
  };
  Spin.setDefaultIndicator = (indicator) => {
    defaultIndicator = indicator;
  };
  let message = null;
  let act$1 = (callback) => callback();
  let taskQueue$1 = [];
  let defaultGlobalConfig$1 = {};
  function getGlobalContext$1() {
    const {
      getContainer: getContainer2,
      duration: duration2,
      rtl,
      maxCount,
      top
    } = defaultGlobalConfig$1;
    const mergedContainer = getContainer2?.() || document.body;
    return {
      getContainer: () => mergedContainer,
      duration: duration2,
      rtl,
      maxCount,
      top
    };
  }
  const GlobalHolder$1 = React.forwardRef((props, ref2) => {
    const {
      messageConfig: messageConfig2,
      sync
    } = props;
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const prefixCls = defaultGlobalConfig$1.prefixCls || getPrefixCls("message");
    const appConfig = reactExports.useContext(AppConfigContext);
    const [api, holder] = useInternalMessage({
      ...messageConfig2,
      prefixCls,
      ...appConfig.message
    });
    React.useImperativeHandle(ref2, () => {
      const instance = {
        ...api
      };
      Object.keys(instance).forEach((method4) => {
        instance[method4] = (...args) => {
          sync();
          return api[method4].apply(api, args);
        };
      });
      return {
        instance,
        sync
      };
    });
    return holder;
  });
  const GlobalHolderWrapper$1 = React.forwardRef((_2, ref2) => {
    const [messageConfig2, setMessageConfig] = React.useState(getGlobalContext$1);
    const sync = () => {
      setMessageConfig(getGlobalContext$1);
    };
    React.useEffect(sync, []);
    const global2 = globalConfig();
    const rootPrefixCls = global2.getRootPrefixCls();
    const rootIconPrefixCls = global2.getIconPrefixCls();
    const theme2 = global2.getTheme();
    const dom = React.createElement(GlobalHolder$1, {
      ref: ref2,
      sync,
      messageConfig: messageConfig2
    });
    return React.createElement(ConfigProvider, {
      prefixCls: rootPrefixCls,
      iconPrefixCls: rootIconPrefixCls,
      theme: theme2
    }, global2.holderRender ? global2.holderRender(dom) : dom);
  });
  const flushMessageQueue = () => {
    if (!message) {
      const holderFragment = document.createDocumentFragment();
      const newMessage = {
        fragment: holderFragment
      };
      message = newMessage;
      act$1(() => {
        render( React.createElement(GlobalHolderWrapper$1, {
          ref: (node2) => {
            const {
              instance,
              sync
            } = node2 || {};
            Promise.resolve().then(() => {
              if (!newMessage.instance && instance) {
                newMessage.instance = instance;
                newMessage.sync = sync;
                flushMessageQueue();
              }
            });
          }
        }), holderFragment);
      });
      return;
    }
    if (!message.instance) {
      return;
    }
    taskQueue$1.forEach((task) => {
      const {
        type: type4,
        skipped
      } = task;
      if (!skipped) {
        switch (type4) {
          case "open": {
            act$1(() => {
              const closeFn = message.instance.open({
                ...defaultGlobalConfig$1,
                ...task.config
              });
              closeFn?.then(task.resolve);
              task.setCloseFn(closeFn);
            });
            break;
          }
          case "destroy":
            act$1(() => {
              message?.instance.destroy(task.key);
            });
            break;
default: {
            act$1(() => {
              var _message$instance;
              const closeFn = (_message$instance = message.instance)[type4].apply(_message$instance, _toConsumableArray(task.args));
              closeFn?.then(task.resolve);
              task.setCloseFn(closeFn);
            });
          }
        }
      }
    });
    taskQueue$1 = [];
  };
  function setMessageGlobalConfig(config) {
    defaultGlobalConfig$1 = {
      ...defaultGlobalConfig$1,
      ...config
    };
    act$1(() => {
      message?.sync?.();
    });
  }
  function open$1(config) {
    const result = wrapPromiseFn((resolve) => {
      let closeFn;
      const task = {
        type: "open",
        config,
        resolve,
        setCloseFn: (fn) => {
          closeFn = fn;
        }
      };
      taskQueue$1.push(task);
      return () => {
        if (closeFn) {
          act$1(() => {
            closeFn();
          });
        } else {
          task.skipped = true;
        }
      };
    });
    flushMessageQueue();
    return result;
  }
  function typeOpen(type4, args) {
    const result = wrapPromiseFn((resolve) => {
      let closeFn;
      const task = {
        type: type4,
        args,
        resolve,
        setCloseFn: (fn) => {
          closeFn = fn;
        }
      };
      taskQueue$1.push(task);
      return () => {
        if (closeFn) {
          act$1(() => {
            closeFn();
          });
        } else {
          task.skipped = true;
        }
      };
    });
    flushMessageQueue();
    return result;
  }
  const destroy$1 = (key) => {
    taskQueue$1.push({
      type: "destroy",
      key
    });
    flushMessageQueue();
  };
  const methods$1 = ["success", "info", "warning", "error", "loading"];
  const baseStaticMethods$1 = {
    open: open$1,
    destroy: destroy$1,
    config: setMessageGlobalConfig,
    useMessage,
    _InternalPanelDoNotUseOrYouWillBeFired: PurePanel$a
  };
  const staticMethods$1 = baseStaticMethods$1;
  methods$1.forEach((type4) => {
    staticMethods$1[type4] = (...args) => typeOpen(type4, args);
  });
  const PurePanel$1 = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      closeIcon,
      closable,
      type: type4,
      title,
      children,
      footer,
      classNames,
      styles,
      ...restProps
    } = props;
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const {
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("modal");
    const rootPrefixCls = getPrefixCls();
    const prefixCls = customizePrefixCls || getPrefixCls("modal");
    const rootCls = useCSSVarCls(rootPrefixCls);
    const [hashId, cssVarCls] = useStyle$y(prefixCls, rootCls);
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props
    });
    const confirmPrefixCls = `${prefixCls}-confirm`;
    let additionalProps = {};
    if (type4) {
      additionalProps = {
        closable: closable ?? false,
        title: "",
        footer: "",
        children: reactExports.createElement(ConfirmContent, {
          ...props,
          prefixCls,
          confirmPrefixCls,
          rootPrefixCls,
          content: children
        })
      };
    } else {
      additionalProps = {
        closable: closable ?? true,
        title,
        footer: footer !== null && reactExports.createElement(Footer, {
          ...props
        }),
        children
      };
    }
    return reactExports.createElement(Panel, {
      prefixCls,
      className: clsx(hashId, `${prefixCls}-pure-panel`, type4 && confirmPrefixCls, type4 && `${confirmPrefixCls}-${type4}`, className, contextClassName, cssVarCls, rootCls, mergedClassNames.root),
      style: {
        ...contextStyle,
        ...mergedStyles.root
      },
      ...restProps,
      closeIcon: renderCloseIcon(prefixCls, closeIcon),
      closable,
      classNames: mergedClassNames,
      styles: mergedStyles,
      ...additionalProps
    });
  };
  const PurePanel$2 = withPureRenderTheme(PurePanel$1);
  function modalWarn(props) {
    return confirm(withWarn(props));
  }
  const Modal = Modal$1;
  Modal.useModal = useModal;
  Modal.info = function infoFn(props) {
    return confirm(withInfo(props));
  };
  Modal.success = function successFn(props) {
    return confirm(withSuccess(props));
  };
  Modal.error = function errorFn(props) {
    return confirm(withError(props));
  };
  Modal.warning = modalWarn;
  Modal.warn = modalWarn;
  Modal.confirm = function confirmFn(props) {
    return confirm(withConfirm(props));
  };
  Modal.destroyAll = function destroyAllFn() {
    while (destroyFns.length) {
      const close = destroyFns.pop();
      if (close) {
        close();
      }
    }
  };
  Modal.config = modalGlobalConfig;
  Modal._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$2;
  let notification = null;
  let act = (callback) => callback();
  let taskQueue = [];
  let defaultGlobalConfig = {};
  function getGlobalContext() {
    const {
      getContainer: getContainer2,
      rtl,
      maxCount,
      top,
      bottom,
      showProgress,
      pauseOnHover
    } = defaultGlobalConfig;
    const mergedContainer = getContainer2?.() || document.body;
    return {
      getContainer: () => mergedContainer,
      rtl,
      maxCount,
      top,
      bottom,
      showProgress,
      pauseOnHover
    };
  }
  const GlobalHolder = React.forwardRef((props, ref2) => {
    const {
      notificationConfig,
      sync
    } = props;
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const prefixCls = defaultGlobalConfig.prefixCls || getPrefixCls("notification");
    const appConfig = reactExports.useContext(AppConfigContext);
    const [api, holder] = useInternalNotification({
      ...notificationConfig,
      prefixCls,
      ...appConfig.notification
    });
    React.useEffect(sync, []);
    React.useImperativeHandle(ref2, () => {
      const instance = {
        ...api
      };
      Object.keys(instance).forEach((method4) => {
        instance[method4] = (...args) => {
          sync();
          return api[method4].apply(api, args);
        };
      });
      return {
        instance,
        sync
      };
    });
    return holder;
  });
  const GlobalHolderWrapper = React.forwardRef((_2, ref2) => {
    const [notificationConfig, setNotificationConfig] = React.useState(getGlobalContext);
    const sync = () => {
      setNotificationConfig(getGlobalContext);
    };
    React.useEffect(sync, []);
    const global2 = globalConfig();
    const rootPrefixCls = global2.getRootPrefixCls();
    const rootIconPrefixCls = global2.getIconPrefixCls();
    const theme2 = global2.getTheme();
    const dom = React.createElement(GlobalHolder, {
      ref: ref2,
      sync,
      notificationConfig
    });
    return React.createElement(ConfigProvider, {
      prefixCls: rootPrefixCls,
      iconPrefixCls: rootIconPrefixCls,
      theme: theme2
    }, global2.holderRender ? global2.holderRender(dom) : dom);
  });
  const flushNotificationQueue = () => {
    if (!notification) {
      const holderFragment = document.createDocumentFragment();
      const newNotification = {
        fragment: holderFragment
      };
      notification = newNotification;
      act(() => {
        render( React.createElement(GlobalHolderWrapper, {
          ref: (node2) => {
            const {
              instance,
              sync
            } = node2 || {};
            Promise.resolve().then(() => {
              if (!newNotification.instance && instance) {
                newNotification.instance = instance;
                newNotification.sync = sync;
                flushNotificationQueue();
              }
            });
          }
        }), holderFragment);
      });
      return;
    }
    if (!notification.instance) {
      return;
    }
    taskQueue.forEach((task) => {
      switch (task.type) {
        case "open": {
          act(() => {
            notification.instance.open({
              ...defaultGlobalConfig,
              ...task.config
            });
          });
          break;
        }
        case "destroy":
          act(() => {
            notification?.instance?.destroy(task.key);
          });
          break;
      }
    });
    taskQueue = [];
  };
  function setNotificationGlobalConfig(config) {
    defaultGlobalConfig = {
      ...defaultGlobalConfig,
      ...config
    };
    act(() => {
      notification?.sync?.();
    });
  }
  function open(config) {
    taskQueue.push({
      type: "open",
      config
    });
    flushNotificationQueue();
  }
  const destroy = (key) => {
    taskQueue.push({
      type: "destroy",
      key
    });
    flushNotificationQueue();
  };
  const methods = ["success", "info", "warning", "error"];
  const baseStaticMethods = {
    open,
    destroy,
    config: setNotificationGlobalConfig,
    useNotification,
    _InternalPanelDoNotUseOrYouWillBeFired: PurePanel$9
  };
  const staticMethods = baseStaticMethods;
  methods.forEach((type4) => {
    staticMethods[type4] = (config) => open({
      ...config,
      type: type4
    });
  });
  const genBaseStyle$1 = (token2) => {
    const {
      componentCls,
      iconCls,
      antCls,
      zIndexPopup,
      colorText,
      colorWarning,
      marginXXS,
      marginXS,
      fontSize,
      fontWeightStrong,
      colorTextHeading
    } = token2;
    return {
      [componentCls]: {
        zIndex: zIndexPopup,
        [`&${antCls}-popover`]: {
          fontSize
        },
        [`${componentCls}-message`]: {
          marginBottom: marginXS,
          display: "flex",
          flexWrap: "nowrap",
          alignItems: "start",
          [`> ${componentCls}-message-icon ${iconCls}`]: {
            color: colorWarning,
            fontSize,
            lineHeight: 1,
            marginInlineEnd: marginXS
          },
          [`${componentCls}-title`]: {
            fontWeight: fontWeightStrong,
            color: colorTextHeading,
            "&:only-child": {
              fontWeight: "normal"
            }
          },
          [`${componentCls}-description`]: {
            marginTop: marginXXS,
            color: colorText
          }
        },
        [`${componentCls}-buttons`]: {
          textAlign: "end",
          whiteSpace: "nowrap",
          button: {
            marginInlineStart: marginXS
          }
        }
      }
    };
  };
  const prepareComponentToken$4 = (token2) => {
    const {
      zIndexPopupBase
    } = token2;
    return {
      zIndexPopup: zIndexPopupBase + 60
    };
  };
  const useStyle$5 = genStyleHooks("Popconfirm", genBaseStyle$1, prepareComponentToken$4, {
    resetStyle: false
  });
  const Overlay = (props) => {
    const {
      prefixCls,
      okButtonProps,
      cancelButtonProps,
      title,
      description,
      cancelText,
      okText,
      okType = "primary",
      icon = reactExports.createElement(RefIcon$j, null),
      showCancel = true,
      close,
      onConfirm,
      onCancel,
      onPopupClick,
      classNames,
      styles
    } = props;
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const [contextLocale] = useLocale("Popconfirm", localeValues.Popconfirm);
    const titleNode = getRenderPropValue(title);
    const descriptionNode = getRenderPropValue(description);
    return reactExports.createElement("div", {
      className: `${prefixCls}-inner-content`,
      onClick: onPopupClick
    }, reactExports.createElement("div", {
      className: `${prefixCls}-message`
    }, icon && reactExports.createElement("span", {
      className: `${prefixCls}-message-icon`
    }, icon), reactExports.createElement("div", {
      className: `${prefixCls}-message-text`
    }, titleNode && reactExports.createElement("div", {
      className: clsx(`${prefixCls}-title`, classNames?.title),
      style: styles?.title
    }, titleNode), descriptionNode && reactExports.createElement("div", {
      className: clsx(`${prefixCls}-description`, classNames?.content),
      style: styles?.content
    }, descriptionNode))), reactExports.createElement("div", {
      className: `${prefixCls}-buttons`
    }, showCancel && reactExports.createElement(Button$1, {
      onClick: onCancel,
      size: "small",
      ...cancelButtonProps
    }, cancelText || contextLocale?.cancelText), reactExports.createElement(ActionButton$1, {
      buttonProps: {
        size: "small",
        ...convertLegacyProps(okType),
        ...okButtonProps
      },
      actionFn: onConfirm,
      close,
      prefixCls: getPrefixCls("btn"),
      quitOnNullishReturnValue: true,
      emitEvent: true
    }, okText || contextLocale?.okText)));
  };
  const PurePanel = (props) => {
    const {
      prefixCls: customizePrefixCls,
      placement,
      className,
      style: style2,
      ...restProps
    } = props;
    const {
      getPrefixCls
    } = reactExports.useContext(ConfigContext);
    const prefixCls = getPrefixCls("popconfirm", customizePrefixCls);
    useStyle$5(prefixCls);
    return reactExports.createElement(PurePanel$6, {
      placement,
      className: clsx(prefixCls, className),
      style: style2,
      content: reactExports.createElement(Overlay, {
        prefixCls,
        ...restProps
      })
    });
  };
  const InternalPopconfirm = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls: customizePrefixCls,
      placement = "top",
      trigger: trigger2,
      okType = "primary",
      icon = reactExports.createElement(RefIcon$j, null),
      children,
      overlayClassName,
      onOpenChange,
      overlayStyle,
      styles,
      arrow: popconfirmArrow,
      classNames,
      ...restProps
    } = props;
    const {
      getPrefixCls,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles,
      arrow: contextArrow,
      trigger: contextTrigger
    } = useComponentConfig("popconfirm");
    const [open2, setOpen] = useControlledState(props.defaultOpen ?? false, props.open);
    const mergedArrow = useMergedArrow(popconfirmArrow, contextArrow);
    const mergedTrigger = trigger2 || contextTrigger || "click";
    const settingOpen = (value) => {
      setOpen(value);
      onOpenChange?.(value);
    };
    const close = () => {
      settingOpen(false);
    };
    const onConfirm = (e) => props.onConfirm?.call(void 0, e);
    const onCancel = (e) => {
      settingOpen(false);
      props.onCancel?.call(void 0, e);
    };
    const onInternalOpenChange = (value) => {
      const {
        disabled = false
      } = props;
      if (disabled) {
        return;
      }
      settingOpen(value);
    };
    const prefixCls = getPrefixCls("popconfirm", customizePrefixCls);
    const mergedProps = {
      ...props,
      placement,
      trigger: mergedTrigger,
      okType,
      overlayStyle,
      styles,
      classNames
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const rootClassNames = clsx(prefixCls, contextClassName, overlayClassName, mergedClassNames.root);
    useStyle$5(prefixCls);
    return reactExports.createElement(Popover, {
      arrow: mergedArrow,
      ...omit(restProps, ["title"]),
      trigger: mergedTrigger,
      placement,
      onOpenChange: onInternalOpenChange,
      open: open2,
      ref: ref2,
      classNames: {
        root: rootClassNames,
        container: mergedClassNames.container,
        arrow: mergedClassNames.arrow
      },
      styles: {
        root: {
          ...contextStyle,
          ...mergedStyles.root,
          ...overlayStyle
        },
        container: mergedStyles.container,
        arrow: mergedStyles.arrow
      },
      content: reactExports.createElement(Overlay, {
        okType,
        icon,
        ...props,
        prefixCls,
        close,
        onConfirm,
        onCancel,
        classNames: mergedClassNames,
        styles: mergedStyles
      }),
      "data-popover-inject": true
    }, children);
  });
  const Popconfirm = InternalPopconfirm;
  Popconfirm._InternalPanelDoNotUseOrYouWillBeFired = PurePanel;
  function _createForOfIteratorHelper(r2, e) {
    var t2 = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
    if (!t2) {
      if (Array.isArray(r2) || (t2 = _unsupportedIterableToArray(r2)) || e) {
        t2 && (r2 = t2);
        var _n = 0, F = function F2() {
        };
        return {
          s: F,
          n: function n2() {
            return _n >= r2.length ? {
              done: true
            } : {
              done: false,
              value: r2[_n++]
            };
          },
          e: function e2(r3) {
            throw r3;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o2, a2 = true, u2 = false;
    return {
      s: function s2() {
        t2 = t2.call(r2);
      },
      n: function n2() {
        var r3 = t2.next();
        return a2 = r3.done, r3;
      },
      e: function e2(r3) {
        u2 = true, o2 = r3;
      },
      f: function f2() {
        try {
          a2 || null == t2["return"] || t2["return"]();
        } finally {
          if (u2) throw o2;
        }
      }
    };
  }
  var _class, _class2;
  function appendBits(val, len, bb) {
    if (len < 0 || len > 31 || val >>> len != 0) {
      throw new RangeError("Value out of range");
    }
    for (var i2 = len - 1; i2 >= 0; i2--) {
      bb.push(val >>> i2 & 1);
    }
  }
  function getBit(x, i2) {
    return (x >>> i2 & 1) != 0;
  }
  function assert(cond) {
    if (!cond) {
      throw new Error("Assertion error");
    }
  }
  var Mode = (function() {
    function Mode2(modeBits, numBitsCharCount) {
      _classCallCheck(this, Mode2);
      _defineProperty$1(this, "modeBits", void 0);
      _defineProperty$1(this, "numBitsCharCount", void 0);
      this.modeBits = modeBits;
      this.numBitsCharCount = numBitsCharCount;
    }
    _createClass(Mode2, [{
      key: "numCharCountBits",
      value: function numCharCountBits(ver) {
        return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
      }
    }]);
    return Mode2;
  })();
  _class = Mode;
  _defineProperty$1(Mode, "NUMERIC", new _class(1, [10, 12, 14]));
  _defineProperty$1(Mode, "ALPHANUMERIC", new _class(2, [9, 11, 13]));
  _defineProperty$1(Mode, "BYTE", new _class(4, [8, 16, 16]));
  _defineProperty$1(Mode, "KANJI", new _class(8, [8, 10, 12]));
  _defineProperty$1(Mode, "ECI", new _class(7, [0, 0, 0]));
  var Ecc = _createClass(function Ecc2(ordinal, formatBits) {
    _classCallCheck(this, Ecc2);
    _defineProperty$1(this, "ordinal", void 0);
    _defineProperty$1(this, "formatBits", void 0);
    this.ordinal = ordinal;
    this.formatBits = formatBits;
  });
  _class2 = Ecc;
  _defineProperty$1(Ecc, "LOW", new _class2(0, 1));
  _defineProperty$1(Ecc, "MEDIUM", new _class2(1, 0));
  _defineProperty$1(Ecc, "QUARTILE", new _class2(2, 3));
  _defineProperty$1(Ecc, "HIGH", new _class2(3, 2));
  var QrSegment = (function() {
    function QrSegment2(mode, numChars, bitData) {
      _classCallCheck(this, QrSegment2);
      _defineProperty$1(this, "mode", void 0);
      _defineProperty$1(this, "numChars", void 0);
      _defineProperty$1(this, "bitData", void 0);
      this.mode = mode;
      this.numChars = numChars;
      this.bitData = bitData;
      if (numChars < 0) {
        throw new RangeError("Invalid argument");
      }
      this.bitData = bitData.slice();
    }
    _createClass(QrSegment2, [{
      key: "getData",
      value: function getData() {
        return this.bitData.slice();
      }

}], [{
      key: "makeBytes",
      value: (



function makeBytes(data2) {
          var bb = [];
          var _iterator = _createForOfIteratorHelper(data2), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var b = _step.value;
              appendBits(b, 8, bb);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return new QrSegment2(Mode.BYTE, data2.length, bb);
        }
      )
}, {
      key: "makeNumeric",
      value: function makeNumeric(digits) {
        if (!QrSegment2.isNumeric(digits)) {
          throw new RangeError("String contains non-numeric characters");
        }
        var bb = [];
        for (var i2 = 0; i2 < digits.length; ) {
          var n2 = Math.min(digits.length - i2, 3);
          appendBits(parseInt(digits.substring(i2, i2 + n2), 10), n2 * 3 + 1, bb);
          i2 += n2;
        }
        return new QrSegment2(Mode.NUMERIC, digits.length, bb);
      }


}, {
      key: "makeAlphanumeric",
      value: function makeAlphanumeric(text) {
        if (!QrSegment2.isAlphanumeric(text)) {
          throw new RangeError("String contains unencodable characters in alphanumeric mode");
        }
        var bb = [];
        var i2;
        for (i2 = 0; i2 + 2 <= text.length; i2 += 2) {
          var temp = QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i2)) * 45;
          temp += QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i2 + 1));
          appendBits(temp, 11, bb);
        }
        if (i2 < text.length) {
          appendBits(QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i2)), 6, bb);
        }
        return new QrSegment2(Mode.ALPHANUMERIC, text.length, bb);
      }

}, {
      key: "makeSegments",
      value: function makeSegments(text) {
        if (text == "") {
          return [];
        } else if (QrSegment2.isNumeric(text)) {
          return [QrSegment2.makeNumeric(text)];
        } else if (QrSegment2.isAlphanumeric(text)) {
          return [QrSegment2.makeAlphanumeric(text)];
        } else {
          return [QrSegment2.makeBytes(QrSegment2.toUtf8ByteArray(text))];
        }
      }

}, {
      key: "makeEci",
      value: function makeEci(assignVal) {
        var bb = [];
        if (assignVal < 0) {
          throw new RangeError("ECI assignment value out of range");
        } else if (assignVal < 1 << 7) {
          appendBits(assignVal, 8, bb);
        } else if (assignVal < 1 << 14) {
          appendBits(2, 2, bb);
          appendBits(assignVal, 14, bb);
        } else if (assignVal < 1e6) {
          appendBits(6, 3, bb);
          appendBits(assignVal, 21, bb);
        } else {
          throw new RangeError("ECI assignment value out of range");
        }
        return new QrSegment2(Mode.ECI, 0, bb);
      }

}, {
      key: "isNumeric",
      value: function isNumeric(text) {
        return QrSegment2.NUMERIC_REGEX.test(text);
      }


}, {
      key: "isAlphanumeric",
      value: function isAlphanumeric(text) {
        return QrSegment2.ALPHANUMERIC_REGEX.test(text);
      }
    }, {
      key: "getTotalBits",
      value: function getTotalBits(segs, version2) {
        var result = 0;
        var _iterator2 = _createForOfIteratorHelper(segs), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var seg = _step2.value;
            var ccbits = seg.mode.numCharCountBits(version2);
            if (seg.numChars >= 1 << ccbits) {
              return Infinity;
            }
            result += 4 + ccbits + seg.bitData.length;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return result;
      }
}, {
      key: "toUtf8ByteArray",
      value: function toUtf8ByteArray(input) {
        var str = encodeURI(input);
        var result = [];
        for (var i2 = 0; i2 < str.length; i2++) {
          if (str.charAt(i2) != "%") {
            result.push(str.charCodeAt(i2));
          } else {
            result.push(parseInt(str.substring(i2 + 1, i2 + 3), 16));
            i2 += 2;
          }
        }
        return result;
      }

}]);
    return QrSegment2;
  })();
  _defineProperty$1(QrSegment, "NUMERIC_REGEX", /^[0-9]*$/);
  _defineProperty$1(QrSegment, "ALPHANUMERIC_REGEX", /^[A-Z0-9 $%*+.\/:-]*$/);
  _defineProperty$1(QrSegment, "ALPHANUMERIC_CHARSET", "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:");
  var QrCode = (function() {
    function QrCode2(version2, errorCorrectionLevel, dataCodewords, oriMsk) {
      _classCallCheck(this, QrCode2);
      _defineProperty$1(this, "size", void 0);
      _defineProperty$1(this, "mask", void 0);
      _defineProperty$1(this, "modules", []);
      _defineProperty$1(this, "isFunction", []);
      _defineProperty$1(this, "version", void 0);
      _defineProperty$1(this, "errorCorrectionLevel", void 0);
      var msk = oriMsk;
      this.version = version2;
      this.errorCorrectionLevel = errorCorrectionLevel;
      if (version2 < QrCode2.MIN_VERSION || version2 > QrCode2.MAX_VERSION) {
        throw new RangeError("Version value out of range");
      }
      if (msk < -1 || msk > 7) {
        throw new RangeError("Mask value out of range");
      }
      this.size = version2 * 4 + 17;
      var row = [];
      for (var i2 = 0; i2 < this.size; i2++) {
        row.push(false);
      }
      for (var _i = 0; _i < this.size; _i++) {
        this.modules.push(row.slice());
        this.isFunction.push(row.slice());
      }
      this.drawFunctionPatterns();
      var allCodewords = this.addEccAndInterleave(dataCodewords);
      this.drawCodewords(allCodewords);
      if (msk == -1) {
        var minPenalty = 1e9;
        for (var _i2 = 0; _i2 < 8; _i2++) {
          this.applyMask(_i2);
          this.drawFormatBits(_i2);
          var penalty = this.getPenaltyScore();
          if (penalty < minPenalty) {
            msk = _i2;
            minPenalty = penalty;
          }
          this.applyMask(_i2);
        }
      }
      assert(0 <= msk && msk <= 7);
      this.mask = msk;
      this.applyMask(msk);
      this.drawFormatBits(msk);
      this.isFunction = [];
    }
    _createClass(QrCode2, [{
      key: "getModule",
      value: function getModule(x, y) {
        return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];
      }
}, {
      key: "getModules",
      value: function getModules() {
        return this.modules;
      }

}, {
      key: "drawFunctionPatterns",
      value: function drawFunctionPatterns() {
        for (var i2 = 0; i2 < this.size; i2++) {
          this.setFunctionModule(6, i2, i2 % 2 == 0);
          this.setFunctionModule(i2, 6, i2 % 2 == 0);
        }
        this.drawFinderPattern(3, 3);
        this.drawFinderPattern(this.size - 4, 3);
        this.drawFinderPattern(3, this.size - 4);
        var alignPatPos = this.getAlignmentPatternPositions();
        var numAlign = alignPatPos.length;
        for (var _i3 = 0; _i3 < numAlign; _i3++) {
          for (var j = 0; j < numAlign; j++) {
            if (!(_i3 == 0 && j == 0 || _i3 == 0 && j == numAlign - 1 || _i3 == numAlign - 1 && j == 0)) {
              this.drawAlignmentPattern(alignPatPos[_i3], alignPatPos[j]);
            }
          }
        }
        this.drawFormatBits(0);
        this.drawVersion();
      }

}, {
      key: "drawFormatBits",
      value: function drawFormatBits(mask2) {
        var data2 = this.errorCorrectionLevel.formatBits << 3 | mask2;
        var rem = data2;
        for (var i2 = 0; i2 < 10; i2++) {
          rem = rem << 1 ^ (rem >>> 9) * 1335;
        }
        var bits = (data2 << 10 | rem) ^ 21522;
        assert(bits >>> 15 == 0);
        for (var _i4 = 0; _i4 <= 5; _i4++) {
          this.setFunctionModule(8, _i4, getBit(bits, _i4));
        }
        this.setFunctionModule(8, 7, getBit(bits, 6));
        this.setFunctionModule(8, 8, getBit(bits, 7));
        this.setFunctionModule(7, 8, getBit(bits, 8));
        for (var _i5 = 9; _i5 < 15; _i5++) {
          this.setFunctionModule(14 - _i5, 8, getBit(bits, _i5));
        }
        for (var _i6 = 0; _i6 < 8; _i6++) {
          this.setFunctionModule(this.size - 1 - _i6, 8, getBit(bits, _i6));
        }
        for (var _i7 = 8; _i7 < 15; _i7++) {
          this.setFunctionModule(8, this.size - 15 + _i7, getBit(bits, _i7));
        }
        this.setFunctionModule(8, this.size - 8, true);
      }

}, {
      key: "drawVersion",
      value: function drawVersion() {
        if (this.version < 7) {
          return;
        }
        var rem = this.version;
        for (var i2 = 0; i2 < 12; i2++) {
          rem = rem << 1 ^ (rem >>> 11) * 7973;
        }
        var bits = this.version << 12 | rem;
        assert(bits >>> 18 == 0);
        for (var _i8 = 0; _i8 < 18; _i8++) {
          var color2 = getBit(bits, _i8);
          var a2 = this.size - 11 + _i8 % 3;
          var b = Math.floor(_i8 / 3);
          this.setFunctionModule(a2, b, color2);
          this.setFunctionModule(b, a2, color2);
        }
      }

}, {
      key: "drawFinderPattern",
      value: function drawFinderPattern(x, y) {
        for (var dy = -4; dy <= 4; dy++) {
          for (var dx = -4; dx <= 4; dx++) {
            var dist2 = Math.max(Math.abs(dx), Math.abs(dy));
            var xx = x + dx;
            var yy = y + dy;
            if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size) {
              this.setFunctionModule(xx, yy, dist2 != 2 && dist2 != 4);
            }
          }
        }
      }

}, {
      key: "drawAlignmentPattern",
      value: function drawAlignmentPattern(x, y) {
        for (var dy = -2; dy <= 2; dy++) {
          for (var dx = -2; dx <= 2; dx++) this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
        }
      }

}, {
      key: "setFunctionModule",
      value: function setFunctionModule(x, y, isDark) {
        this.modules[y][x] = isDark;
        this.isFunction[y][x] = true;
      }


}, {
      key: "addEccAndInterleave",
      value: function addEccAndInterleave(data2) {
        var ver = this.version;
        var ecl = this.errorCorrectionLevel;
        if (data2.length != QrCode2.getNumDataCodewords(ver, ecl)) {
          throw new RangeError("Invalid argument");
        }
        var numBlocks = QrCode2.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
        var blockEccLen = QrCode2.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
        var rawCodewords = Math.floor(QrCode2.getNumRawDataModules(ver) / 8);
        var numShortBlocks = numBlocks - rawCodewords % numBlocks;
        var shortBlockLen = Math.floor(rawCodewords / numBlocks);
        var blocks = [];
        var rsDiv = QrCode2.reedSolomonComputeDivisor(blockEccLen);
        for (var i2 = 0, k = 0; i2 < numBlocks; i2++) {
          var dat = data2.slice(k, k + shortBlockLen - blockEccLen + (i2 < numShortBlocks ? 0 : 1));
          k += dat.length;
          var ecc = QrCode2.reedSolomonComputeRemainder(dat, rsDiv);
          if (i2 < numShortBlocks) {
            dat.push(0);
          }
          blocks.push(dat.concat(ecc));
        }
        var result = [];
        var _loop = function _loop2(_i92) {
          blocks.forEach(function(block, j) {
            if (_i92 != shortBlockLen - blockEccLen || j >= numShortBlocks) {
              result.push(block[_i92]);
            }
          });
        };
        for (var _i9 = 0; _i9 < blocks[0].length; _i9++) {
          _loop(_i9);
        }
        assert(result.length == rawCodewords);
        return result;
      }

}, {
      key: "drawCodewords",
      value: function drawCodewords(data2) {
        if (data2.length != Math.floor(QrCode2.getNumRawDataModules(this.version) / 8)) {
          throw new RangeError("Invalid argument");
        }
        var i2 = 0;
        for (var right = this.size - 1; right >= 1; right -= 2) {
          if (right == 6) {
            right = 5;
          }
          for (var vert = 0; vert < this.size; vert++) {
            for (var j = 0; j < 2; j++) {
              var x = right - j;
              var upward = (right + 1 & 2) == 0;
              var y = upward ? this.size - 1 - vert : vert;
              if (!this.isFunction[y][x] && i2 < data2.length * 8) {
                this.modules[y][x] = getBit(data2[i2 >>> 3], 7 - (i2 & 7));
                i2++;
              }
            }
          }
        }
        assert(i2 == data2.length * 8);
      }




}, {
      key: "applyMask",
      value: function applyMask(mask2) {
        if (mask2 < 0 || mask2 > 7) {
          throw new RangeError("Mask value out of range");
        }
        for (var y = 0; y < this.size; y++) {
          for (var x = 0; x < this.size; x++) {
            var invert = void 0;
            switch (mask2) {
              case 0:
                invert = (x + y) % 2 == 0;
                break;
              case 1:
                invert = y % 2 == 0;
                break;
              case 2:
                invert = x % 3 == 0;
                break;
              case 3:
                invert = (x + y) % 3 == 0;
                break;
              case 4:
                invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;
                break;
              case 5:
                invert = x * y % 2 + x * y % 3 == 0;
                break;
              case 6:
                invert = (x * y % 2 + x * y % 3) % 2 == 0;
                break;
              case 7:
                invert = ((x + y) % 2 + x * y % 3) % 2 == 0;
                break;
              default:
                throw new Error("Unreachable");
            }
            if (!this.isFunction[y][x] && invert) {
              this.modules[y][x] = !this.modules[y][x];
            }
          }
        }
      }

}, {
      key: "getPenaltyScore",
      value: function getPenaltyScore() {
        var result = 0;
        for (var y = 0; y < this.size; y++) {
          var runColor = false;
          var runX = 0;
          var runHistory = [0, 0, 0, 0, 0, 0, 0];
          for (var x = 0; x < this.size; x++) {
            if (this.modules[y][x] == runColor) {
              runX++;
              if (runX == 5) {
                result += QrCode2.PENALTY_N1;
              } else if (runX > 5) {
                result++;
              }
            } else {
              this.finderPenaltyAddHistory(runX, runHistory);
              if (!runColor) {
                result += this.finderPenaltyCountPatterns(runHistory) * QrCode2.PENALTY_N3;
              }
              runColor = this.modules[y][x];
              runX = 1;
            }
          }
          result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * QrCode2.PENALTY_N3;
        }
        for (var _x = 0; _x < this.size; _x++) {
          var _runColor = false;
          var runY = 0;
          var _runHistory = [0, 0, 0, 0, 0, 0, 0];
          for (var _y = 0; _y < this.size; _y++) {
            if (this.modules[_y][_x] == _runColor) {
              runY++;
              if (runY == 5) {
                result += QrCode2.PENALTY_N1;
              } else if (runY > 5) {
                result++;
              }
            } else {
              this.finderPenaltyAddHistory(runY, _runHistory);
              if (!_runColor) {
                result += this.finderPenaltyCountPatterns(_runHistory) * QrCode2.PENALTY_N3;
              }
              _runColor = this.modules[_y][_x];
              runY = 1;
            }
          }
          result += this.finderPenaltyTerminateAndCount(_runColor, runY, _runHistory) * QrCode2.PENALTY_N3;
        }
        for (var _y2 = 0; _y2 < this.size - 1; _y2++) {
          for (var _x2 = 0; _x2 < this.size - 1; _x2++) {
            var color2 = this.modules[_y2][_x2];
            if (color2 == this.modules[_y2][_x2 + 1] && color2 == this.modules[_y2 + 1][_x2] && color2 == this.modules[_y2 + 1][_x2 + 1]) {
              result += QrCode2.PENALTY_N2;
            }
          }
        }
        var dark = 0;
        var _iterator3 = _createForOfIteratorHelper(this.modules), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var row = _step3.value;
            dark = row.reduce(function(sum, color3) {
              return sum + (color3 ? 1 : 0);
            }, dark);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        var total = this.size * this.size;
        var k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
        assert(0 <= k && k <= 9);
        result += k * QrCode2.PENALTY_N4;
        assert(0 <= result && result <= 2568888);
        return result;
      }



}, {
      key: "getAlignmentPatternPositions",
      value: function getAlignmentPatternPositions() {
        if (this.version == 1) {
          return [];
        } else {
          var numAlign = Math.floor(this.version / 7) + 2;
          var step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
          var result = [6];
          for (var pos = this.size - 7; result.length < numAlign; pos -= step) {
            result.splice(1, 0, pos);
          }
          return result;
        }
      }


}, {
      key: "finderPenaltyCountPatterns",
      value: (

function finderPenaltyCountPatterns(runHistory) {
          var n2 = runHistory[1];
          assert(n2 <= this.size * 3);
          var core = n2 > 0 && runHistory[2] == n2 && runHistory[3] == n2 * 3 && runHistory[4] == n2 && runHistory[5] == n2;
          return (core && runHistory[0] >= n2 * 4 && runHistory[6] >= n2 ? 1 : 0) + (core && runHistory[6] >= n2 * 4 && runHistory[0] >= n2 ? 1 : 0);
        }
      )
}, {
      key: "finderPenaltyTerminateAndCount",
      value: function finderPenaltyTerminateAndCount(currentRunColor, oriCurrentRunLength, runHistory) {
        var currentRunLength = oriCurrentRunLength;
        if (currentRunColor) {
          this.finderPenaltyAddHistory(currentRunLength, runHistory);
          currentRunLength = 0;
        }
        currentRunLength += this.size;
        this.finderPenaltyAddHistory(currentRunLength, runHistory);
        return this.finderPenaltyCountPatterns(runHistory);
      }
}, {
      key: "finderPenaltyAddHistory",
      value: function finderPenaltyAddHistory(oriCurrentRunLength, runHistory) {
        var currentRunLength = oriCurrentRunLength;
        if (runHistory[0] == 0) {
          currentRunLength += this.size;
        }
        runHistory.pop();
        runHistory.unshift(currentRunLength);
      }

}], [{
      key: "encodeText",
      value: (





function encodeText(text, ecl) {
          var segs = QrSegment.makeSegments(text);
          return QrCode2.encodeSegments(segs, ecl);
        }
      )



}, {
      key: "encodeBinary",
      value: function encodeBinary(data2, ecl) {
        var seg = QrSegment.makeBytes(data2);
        return QrCode2.encodeSegments([seg], ecl);
      }









}, {
      key: "encodeSegments",
      value: function encodeSegments(segs, oriEcl) {
        var minVersion = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        var maxVersion = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 40;
        var mask2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1;
        var boostEcl = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
        if (!(QrCode2.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode2.MAX_VERSION) || mask2 < -1 || mask2 > 7) {
          throw new RangeError("Invalid value");
        }
        var version2;
        var dataUsedBits;
        for (version2 = minVersion; ; version2++) {
          var _dataCapacityBits = QrCode2.getNumDataCodewords(version2, oriEcl) * 8;
          var usedBits = QrSegment.getTotalBits(segs, version2);
          if (usedBits <= _dataCapacityBits) {
            dataUsedBits = usedBits;
            break;
          }
          if (version2 >= maxVersion) {
            throw new RangeError("Data too long");
          }
        }
        var ecl = oriEcl;
        for (var _i10 = 0, _arr = [Ecc.MEDIUM, Ecc.QUARTILE, Ecc.HIGH]; _i10 < _arr.length; _i10++) {
          var newEcl = _arr[_i10];
          if (boostEcl && dataUsedBits <= QrCode2.getNumDataCodewords(version2, newEcl) * 8) {
            ecl = newEcl;
          }
        }
        var bb = [];
        var _iterator4 = _createForOfIteratorHelper(segs), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var seg = _step4.value;
            appendBits(seg.mode.modeBits, 4, bb);
            appendBits(seg.numChars, seg.mode.numCharCountBits(version2), bb);
            var _iterator5 = _createForOfIteratorHelper(seg.getData()), _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                var b = _step5.value;
                bb.push(b);
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        assert(bb.length == dataUsedBits);
        var dataCapacityBits = QrCode2.getNumDataCodewords(version2, ecl) * 8;
        assert(bb.length <= dataCapacityBits);
        appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
        appendBits(0, (8 - bb.length % 8) % 8, bb);
        assert(bb.length % 8 == 0);
        for (var padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17) {
          appendBits(padByte, 8, bb);
        }
        var dataCodewords = [];
        while (dataCodewords.length * 8 < bb.length) {
          dataCodewords.push(0);
        }
        bb.forEach(function(b2, i2) {
          dataCodewords[i2 >>> 3] |= b2 << 7 - (i2 & 7);
        });
        return new QrCode2(version2, ecl, dataCodewords, mask2);
      }
    }, {
      key: "getNumRawDataModules",
      value: function getNumRawDataModules(ver) {
        if (ver < QrCode2.MIN_VERSION || ver > QrCode2.MAX_VERSION) {
          throw new RangeError("Version number out of range");
        }
        var result = (16 * ver + 128) * ver + 64;
        if (ver >= 2) {
          var numAlign = Math.floor(ver / 7) + 2;
          result -= (25 * numAlign - 10) * numAlign - 55;
          if (ver >= 7) {
            result -= 36;
          }
        }
        assert(208 <= result && result <= 29648);
        return result;
      }


}, {
      key: "getNumDataCodewords",
      value: function getNumDataCodewords(ver, ecl) {
        return Math.floor(QrCode2.getNumRawDataModules(ver) / 8) - QrCode2.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * QrCode2.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
      }

}, {
      key: "reedSolomonComputeDivisor",
      value: function reedSolomonComputeDivisor(degree) {
        if (degree < 1 || degree > 255) {
          throw new RangeError("Degree out of range");
        }
        var result = [];
        for (var i2 = 0; i2 < degree - 1; i2++) {
          result.push(0);
        }
        result.push(1);
        var root2 = 1;
        for (var _i11 = 0; _i11 < degree; _i11++) {
          for (var j = 0; j < result.length; j++) {
            result[j] = QrCode2.reedSolomonMultiply(result[j], root2);
            if (j + 1 < result.length) {
              result[j] ^= result[j + 1];
            }
          }
          root2 = QrCode2.reedSolomonMultiply(root2, 2);
        }
        return result;
      }
}, {
      key: "reedSolomonComputeRemainder",
      value: function reedSolomonComputeRemainder(data2, divisor) {
        var result = divisor.map(function() {
          return 0;
        });
        var _iterator6 = _createForOfIteratorHelper(data2), _step6;
        try {
          var _loop2 = function _loop22() {
            var b = _step6.value;
            var factor = b ^ result.shift();
            result.push(0);
            divisor.forEach(function(coef, i2) {
              result[i2] ^= QrCode2.reedSolomonMultiply(coef, factor);
            });
          };
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
            _loop2();
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
        return result;
      }

}, {
      key: "reedSolomonMultiply",
      value: function reedSolomonMultiply(x, y) {
        if (x >>> 8 != 0 || y >>> 8 != 0) {
          throw new RangeError("Byte out of range");
        }
        var z = 0;
        for (var i2 = 7; i2 >= 0; i2--) {
          z = z << 1 ^ (z >>> 7) * 285;
          z ^= (y >>> i2 & 1) * x;
        }
        assert(z >>> 8 == 0);
        return z;
      }
    }]);
    return QrCode2;
  })();
  _defineProperty$1(QrCode, "MIN_VERSION", 1);
  _defineProperty$1(QrCode, "MAX_VERSION", 40);
  _defineProperty$1(QrCode, "PENALTY_N1", 3);
  _defineProperty$1(QrCode, "PENALTY_N2", 3);
  _defineProperty$1(QrCode, "PENALTY_N3", 40);
  _defineProperty$1(QrCode, "PENALTY_N4", 10);
  _defineProperty$1(QrCode, "ECC_CODEWORDS_PER_BLOCK", [

[-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
[-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
[-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
[-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
]);
  _defineProperty$1(QrCode, "NUM_ERROR_CORRECTION_BLOCKS", [

[-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
[-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
[-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
[-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
]);
  var ERROR_LEVEL_MAP = {
    L: Ecc.LOW,
    M: Ecc.MEDIUM,
    Q: Ecc.QUARTILE,
    H: Ecc.HIGH
  };
  var DEFAULT_SIZE = 128;
  var DEFAULT_LEVEL = "L";
  var DEFAULT_BACKGROUND_COLOR = "#FFFFFF";
  var DEFAULT_FRONT_COLOR = "#000000";
  var DEFAULT_NEED_MARGIN = false;
  var DEFAULT_MINVERSION = 1;
  var SPEC_MARGIN_SIZE = 4;
  var DEFAULT_MARGIN_SIZE = 0;
  var DEFAULT_IMG_SCALE = 0.1;
  var generatePath = function generatePath2(modules) {
    var margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var ops = [];
    modules.forEach(function(row, y) {
      var start = null;
      row.forEach(function(cell, x) {
        if (!cell && start !== null) {
          ops.push("M".concat(start + margin, " ").concat(y + margin, "h").concat(x - start, "v1H").concat(start + margin, "z"));
          start = null;
          return;
        }
        if (x === row.length - 1) {
          if (!cell) {
            return;
          }
          if (start === null) {
            ops.push("M".concat(x + margin, ",").concat(y + margin, " h1v1H").concat(x + margin, "z"));
          } else {
            ops.push("M".concat(start + margin, ",").concat(y + margin, " h").concat(x + 1 - start, "v1H").concat(start + margin, "z"));
          }
          return;
        }
        if (cell && start === null) {
          start = x;
        }
      });
    });
    return ops.join("");
  };
  var excavateModules = function excavateModules2(modules, excavation) {
    return modules.slice().map(function(row, y) {
      if (y < excavation.y || y >= excavation.y + excavation.h) {
        return row;
      }
      return row.map(function(cell, x) {
        if (x < excavation.x || x >= excavation.x + excavation.w) {
          return cell;
        }
        return false;
      });
    });
  };
  var getImageSettings = function getImageSettings2(cells, size, margin, imageSettings) {
    if (imageSettings == null) {
      return null;
    }
    var numCells = cells.length + margin * 2;
    var defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
    var scale2 = numCells / size;
    var w = (imageSettings.width || defaultSize) * scale2;
    var h2 = (imageSettings.height || defaultSize) * scale2;
    var x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale2;
    var y = imageSettings.y == null ? cells.length / 2 - h2 / 2 : imageSettings.y * scale2;
    var opacity = imageSettings.opacity == null ? 1 : imageSettings.opacity;
    var excavation = null;
    if (imageSettings.excavate) {
      var floorX = Math.floor(x);
      var floorY = Math.floor(y);
      var ceilW = Math.ceil(w + x - floorX);
      var ceilH = Math.ceil(h2 + y - floorY);
      excavation = {
        x: floorX,
        y: floorY,
        w: ceilW,
        h: ceilH
      };
    }
    var crossOrigin = imageSettings.crossOrigin;
    return {
      x,
      y,
      h: h2,
      w,
      excavation,
      opacity,
      crossOrigin
    };
  };
  var getMarginSize = function getMarginSize2(needMargin, marginSize) {
    if (marginSize != null) {
      return Math.max(Math.floor(marginSize), 0);
    }
    return needMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;
  };
  var isSupportPath2d = (function() {
    try {
      new Path2D().addPath(new Path2D());
    } catch (_unused) {
      return false;
    }
    return true;
  })();
  var useQRCode = function useQRCode2(opt) {
    var value = opt.value, level = opt.level, minVersion = opt.minVersion, includeMargin = opt.includeMargin, marginSize = opt.marginSize, imageSettings = opt.imageSettings, size = opt.size, boostLevel = opt.boostLevel;
    var memoizedQrcode = React.useMemo(function() {
      var values = Array.isArray(value) ? value : [value];
      var segments = values.reduce(function(acc, val) {
        acc.push.apply(acc, _toConsumableArray(QrSegment.makeSegments(val)));
        return acc;
      }, []);
      return QrCode.encodeSegments(segments, ERROR_LEVEL_MAP[level], minVersion, void 0, void 0, boostLevel);
    }, [value, level, minVersion, boostLevel]);
    return React.useMemo(function() {
      var cs = memoizedQrcode.getModules();
      var mg = getMarginSize(includeMargin, marginSize);
      var ncs = cs.length + mg * 2;
      var cis = getImageSettings(cs, size, mg, imageSettings);
      return {
        cells: cs,
        margin: mg,
        numCells: ncs,
        calculatedImageSettings: cis,
        qrcode: memoizedQrcode
      };
    }, [memoizedQrcode, size, imageSettings, includeMargin, marginSize]);
  };
  var _excluded$1 = ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "minVersion", "marginSize", "style", "imageSettings", "boostLevel"];
  var QRCodeCanvas = React.forwardRef(function(props, ref2) {
    var value = props.value, _props$size = props.size, size = _props$size === void 0 ? DEFAULT_SIZE : _props$size, _props$level = props.level, level = _props$level === void 0 ? DEFAULT_LEVEL : _props$level, _props$bgColor = props.bgColor, bgColor = _props$bgColor === void 0 ? DEFAULT_BACKGROUND_COLOR : _props$bgColor, _props$fgColor = props.fgColor, fgColor = _props$fgColor === void 0 ? DEFAULT_FRONT_COLOR : _props$fgColor, _props$includeMargin = props.includeMargin, includeMargin = _props$includeMargin === void 0 ? DEFAULT_NEED_MARGIN : _props$includeMargin, _props$minVersion = props.minVersion, minVersion = _props$minVersion === void 0 ? DEFAULT_MINVERSION : _props$minVersion, marginSize = props.marginSize, style2 = props.style, imageSettings = props.imageSettings, boostLevel = props.boostLevel, otherProps = _objectWithoutProperties(props, _excluded$1);
    var imgSrc = imageSettings === null || imageSettings === void 0 ? void 0 : imageSettings.src;
    var _canvas = React.useRef(null);
    var _image = React.useRef(null);
    var setCanvasRef = React.useCallback(function(node2) {
      _canvas.current = node2;
      if (typeof ref2 === "function") {
        ref2(node2);
      } else if (ref2) {
        ref2.current = node2;
      }
    }, [ref2]);
    var _React$useState = React.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), setIsImageLoaded = _React$useState2[1];
    var _useQRCode = useQRCode({
      value,
      level,
      minVersion,
      includeMargin,
      marginSize,
      imageSettings,
      size,
      boostLevel
    }), margin = _useQRCode.margin, cells = _useQRCode.cells, numCells = _useQRCode.numCells, calculatedImageSettings = _useQRCode.calculatedImageSettings;
    React.useEffect(function() {
      if (_canvas.current) {
        var canvas = _canvas.current;
        var ctx = canvas.getContext("2d");
        if (!ctx) {
          return;
        }
        var cellsToDraw = cells;
        var image = _image.current;
        var haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;
        if (haveImageToRender) {
          if (calculatedImageSettings.excavation != null) {
            cellsToDraw = excavateModules(cells, calculatedImageSettings.excavation);
          }
        }
        var pixelRatio = window.devicePixelRatio || 1;
        canvas.height = canvas.width = size * pixelRatio;
        var scale2 = size / numCells * pixelRatio;
        ctx.scale(scale2, scale2);
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, numCells, numCells);
        ctx.fillStyle = fgColor;
        if (isSupportPath2d) {
          ctx.fill(new Path2D(generatePath(cellsToDraw, margin)));
        } else {
          cells.forEach(function(row, rdx) {
            row.forEach(function(cell, cdx) {
              if (cell) {
                ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
              }
            });
          });
        }
        if (calculatedImageSettings) {
          ctx.globalAlpha = calculatedImageSettings.opacity;
        }
        if (haveImageToRender) {
          ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);
        }
      }
    });
    React.useEffect(function() {
      setIsImageLoaded(false);
    }, [imgSrc]);
    var canvasStyle = _objectSpread2({
      height: size,
      width: size
    }, style2);
    var img = null;
    if (imgSrc != null) {
      img = React.createElement("img", {
        alt: "QR-Code",
        src: imgSrc,
        key: imgSrc,
        style: {
          display: "none"
        },
        onLoad: function onLoad() {
          setIsImageLoaded(true);
        },
        ref: _image,
        crossOrigin: calculatedImageSettings === null || calculatedImageSettings === void 0 ? void 0 : calculatedImageSettings.crossOrigin
      });
    }
    return React.createElement(React.Fragment, null, React.createElement("canvas", _extends$15({
      style: canvasStyle,
      height: size,
      width: size,
      ref: setCanvasRef,
      role: "img"
    }, otherProps)), img);
  });
  var _excluded = ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "minVersion", "title", "marginSize", "imageSettings", "boostLevel"];
  var QRCodeSVG = React.forwardRef(function(props, ref2) {
    var value = props.value, _props$size = props.size, size = _props$size === void 0 ? DEFAULT_SIZE : _props$size, _props$level = props.level, level = _props$level === void 0 ? DEFAULT_LEVEL : _props$level, _props$bgColor = props.bgColor, bgColor = _props$bgColor === void 0 ? DEFAULT_BACKGROUND_COLOR : _props$bgColor, _props$fgColor = props.fgColor, fgColor = _props$fgColor === void 0 ? DEFAULT_FRONT_COLOR : _props$fgColor, _props$includeMargin = props.includeMargin, includeMargin = _props$includeMargin === void 0 ? DEFAULT_NEED_MARGIN : _props$includeMargin, _props$minVersion = props.minVersion, minVersion = _props$minVersion === void 0 ? DEFAULT_MINVERSION : _props$minVersion, title = props.title, marginSize = props.marginSize, imageSettings = props.imageSettings, boostLevel = props.boostLevel, otherProps = _objectWithoutProperties(props, _excluded);
    var _useQRCode = useQRCode({
      value,
      level,
      minVersion,
      includeMargin,
      marginSize,
      imageSettings,
      size,
      boostLevel
    }), margin = _useQRCode.margin, cells = _useQRCode.cells, numCells = _useQRCode.numCells, calculatedImageSettings = _useQRCode.calculatedImageSettings;
    var cellsToDraw = cells;
    var image = null;
    if (imageSettings != null && calculatedImageSettings != null) {
      if (calculatedImageSettings.excavation != null) {
        cellsToDraw = excavateModules(cells, calculatedImageSettings.excavation);
      }
      image = React.createElement("image", {
        href: imageSettings.src,
        height: calculatedImageSettings.h,
        width: calculatedImageSettings.w,
        x: calculatedImageSettings.x + margin,
        y: calculatedImageSettings.y + margin,
        preserveAspectRatio: "none",
        opacity: calculatedImageSettings.opacity,
        crossOrigin: calculatedImageSettings.crossOrigin
      });
    }
    var fgPath = generatePath(cellsToDraw, margin);
    return React.createElement("svg", _extends$15({
      height: size,
      width: size,
      viewBox: "0 0 ".concat(numCells, " ").concat(numCells),
      ref: ref2,
      role: "img"
    }, otherProps), !!title && React.createElement("title", null, title), React.createElement("path", {
      fill: bgColor,
      d: "M0,0 h".concat(numCells, "v").concat(numCells, "H0z"),
      shapeRendering: "crispEdges"
    }), React.createElement("path", {
      fill: fgColor,
      d: fgPath,
      shapeRendering: "crispEdges"
    }), image);
  });
  var ReloadOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.1 209.3l-56.4 44.1C775.8 155.1 656.2 92 521.9 92 290 92 102.3 279.5 102 511.5 101.7 743.7 289.8 932 521.9 932c181.3 0 335.8-115 394.6-276.1 1.5-4.2-.7-8.9-4.9-10.3l-56.7-19.5a8 8 0 00-10.1 4.8c-1.8 5-3.8 10-5.9 14.9-17.3 41-42.1 77.8-73.7 109.4A344.77 344.77 0 01655.9 829c-42.3 17.9-87.4 27-133.8 27-46.5 0-91.5-9.1-133.8-27A341.5 341.5 0 01279 755.2a342.16 342.16 0 01-73.7-109.4c-17.9-42.4-27-87.4-27-133.9s9.1-91.5 27-133.9c17.3-41 42.1-77.8 73.7-109.4 31.6-31.6 68.4-56.4 109.3-73.8 42.3-17.9 87.4-27 133.8-27 46.5 0 91.5 9.1 133.8 27a341.5 341.5 0 01109.3 73.8c9.9 9.9 19.2 20.4 27.8 31.4l-60.2 47a8 8 0 003 14.1l175.6 43c5 1.2 9.9-2.6 9.9-7.7l.8-180.9c-.1-6.6-7.8-10.3-13-6.2z" } }] }, "name": "reload", "theme": "outlined" };
  function _extends$2() {
    _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$2.apply(this, arguments);
  }
  const ReloadOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends$2({}, props, {
    ref: ref2,
    icon: ReloadOutlined$1
  }));
  const RefIcon$1 = reactExports.forwardRef(ReloadOutlined);
  const defaultSpin = React.createElement(Spin, null);
  function QRcodeStatus({
    prefixCls,
    locale: locale2,
    onRefresh,
    statusRender,
    status
  }) {
    const defaultExpiredNode = React.createElement(React.Fragment, null, React.createElement("p", {
      className: `${prefixCls}-expired`
    }, locale2?.expired), onRefresh && React.createElement(Button$1, {
      type: "link",
      icon: React.createElement(RefIcon$1, null),
      onClick: onRefresh
    }, locale2?.refresh));
    const defaultScannedNode = React.createElement("p", {
      className: `${prefixCls}-scanned`
    }, locale2?.scanned);
    const defaultNodes = {
      expired: defaultExpiredNode,
      loading: defaultSpin,
      scanned: defaultScannedNode
    };
    const defaultStatusRender = (info) => defaultNodes[info.status];
    const mergedStatusRender = statusRender ?? defaultStatusRender;
    return mergedStatusRender({
      status,
      locale: locale2,
      onRefresh
    });
  }
  const genQRCodeStyle = (token2) => {
    const {
      componentCls,
      lineWidth,
      lineType,
      colorSplit
    } = token2;
    return {
      [componentCls]: {
        ...resetComponent(token2),
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        padding: token2.paddingSM,
        backgroundColor: token2.colorWhite,
        borderRadius: token2.borderRadiusLG,
        border: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
        position: "relative",
        overflow: "hidden",
        [`& > ${componentCls}-cover`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          zIndex: 10,
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          width: "100%",
          height: "100%",
          color: token2.colorText,
          lineHeight: token2.lineHeight,
          background: token2.QRCodeCoverBackgroundColor,
          textAlign: "center",
          [`& > ${componentCls}-expired, & > ${componentCls}-scanned`]: {
            color: token2.QRCodeTextColor
          }
        },
        "> canvas": {
          alignSelf: "stretch",
          flex: "auto",
          minWidth: 0
        },
        "&-icon": {
          marginBlockEnd: token2.marginXS,
          fontSize: token2.controlHeight
        }
      },
      [`${componentCls}-borderless`]: {
        borderColor: "transparent",
        padding: 0,
        borderRadius: 0
      }
    };
  };
  const prepareComponentToken$3 = (token2) => ({
    QRCodeCoverBackgroundColor: new FastColor(token2.colorBgContainer).setA(0.96).toRgbString()
  });
  const useStyle$4 = genStyleHooks("QRCode", (token2) => {
    const mergedToken = merge$1(token2, {
      QRCodeTextColor: token2.colorText
    });
    return genQRCodeStyle(mergedToken);
  }, prepareComponentToken$3);
  const QRCode = (props) => {
    const [, token2] = useToken$1();
    const {
      value,
      type: type4 = "canvas",
      icon = "",
      size = 160,
      iconSize,
      color: color2 = token2.colorText,
      errorLevel = "M",
      status = "active",
      bordered = true,
      onRefresh,
      style: style2,
      className,
      rootClassName,
      prefixCls: customizePrefixCls,
      bgColor = "transparent",
      marginSize,
      statusRender,
      classNames,
      styles,
      boostLevel,
      ...rest
    } = props;
    const {
      getPrefixCls,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("qrcode");
    const mergedProps = {
      ...props,
      bgColor,
      type: type4,
      size,
      status,
      bordered,
      errorLevel
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const prefixCls = getPrefixCls("qrcode", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$4(prefixCls);
    const imageSettings = {
      src: icon,
      x: void 0,
      y: void 0,
      height: typeof iconSize === "number" ? iconSize : iconSize?.height ?? 40,
      width: typeof iconSize === "number" ? iconSize : iconSize?.width ?? 40,
      excavate: true,
      crossOrigin: "anonymous"
    };
    const a11yProps = pickAttrs(rest, true);
    const restProps = omit(rest, Object.keys(a11yProps));
    const qrCodeProps = {
      value,
      size,
      level: errorLevel,
      bgColor,
      fgColor: color2,
      style: {
        width: style2?.width,
        height: style2?.height
      },
      imageSettings: icon ? imageSettings : void 0,
      marginSize,
      boostLevel,
      ...a11yProps
    };
    const [locale2] = useLocale("QRCode");
    if (!value) {
      return null;
    }
    const rootClassNames = clsx(prefixCls, className, rootClassName, hashId, cssVarCls, contextClassName, mergedClassNames.root, {
      [`${prefixCls}-borderless`]: !bordered
    });
    const rootStyle = {
      backgroundColor: bgColor,
      ...mergedStyles.root,
      ...contextStyle,
      ...style2,
      width: style2?.width ?? size,
      height: style2?.height ?? size
    };
    return React.createElement("div", {
      ...restProps,
      className: rootClassNames,
      style: rootStyle
    }, status !== "active" && React.createElement("div", {
      className: clsx(`${prefixCls}-cover`, mergedClassNames.cover),
      style: mergedStyles.cover
    }, React.createElement(QRcodeStatus, {
      prefixCls,
      locale: locale2,
      status,
      onRefresh,
      statusRender
    })), type4 === "canvas" ? React.createElement(QRCodeCanvas, {
      ...qrCodeProps
    }) : React.createElement(QRCodeSVG, {
      ...qrCodeProps
    }));
  };
  function _extends$1() {
    _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$1.apply(this, arguments);
  }
  const Switch$1 = reactExports.forwardRef(({
    prefixCls = "rc-switch",
    className,
    checked,
    defaultChecked,
    disabled,
    loadingIcon,
    checkedChildren,
    unCheckedChildren,
    onClick,
    onChange,
    onKeyDown,
    styles,
    classNames: switchClassNames,
    ...restProps
  }, ref2) => {
    const [innerChecked, setInnerChecked] = useControlledState(defaultChecked ?? false, checked);
    function triggerChange(newChecked, event) {
      let mergedChecked = innerChecked;
      if (!disabled) {
        mergedChecked = newChecked;
        setInnerChecked(mergedChecked);
        onChange?.(mergedChecked, event);
      }
      return mergedChecked;
    }
    function onInternalKeyDown(e) {
      if (e.which === KeyCode.LEFT) {
        triggerChange(false, e);
      } else if (e.which === KeyCode.RIGHT) {
        triggerChange(true, e);
      }
      onKeyDown?.(e);
    }
    function onInternalClick(e) {
      const ret = triggerChange(!innerChecked, e);
      onClick?.(ret, e);
    }
    const switchClassName = clsx(prefixCls, className, {
      [`${prefixCls}-checked`]: innerChecked,
      [`${prefixCls}-disabled`]: disabled
    });
    return reactExports.createElement("button", _extends$1({}, restProps, {
      type: "button",
      role: "switch",
      "aria-checked": innerChecked,
      disabled,
      className: switchClassName,
      ref: ref2,
      onKeyDown: onInternalKeyDown,
      onClick: onInternalClick
    }), loadingIcon, reactExports.createElement("span", {
      className: `${prefixCls}-inner`
    }, reactExports.createElement("span", {
      className: clsx(`${prefixCls}-inner-checked`, switchClassNames?.content),
      style: styles?.content
    }, checkedChildren), reactExports.createElement("span", {
      className: clsx(`${prefixCls}-inner-unchecked`, switchClassNames?.content),
      style: styles?.content
    }, unCheckedChildren)));
  });
  Switch$1.displayName = "Switch";
  const genSwitchSmallStyle = (token2) => {
    const {
      componentCls,
      trackHeightSM,
      trackPadding,
      trackMinWidthSM,
      innerMinMarginSM,
      innerMaxMarginSM,
      handleSizeSM,
      calc
    } = token2;
    const switchInnerCls = `${componentCls}-inner`;
    const trackPaddingCalc = unit$1(calc(handleSizeSM).add(calc(trackPadding).mul(2)).equal());
    const innerMaxMarginCalc = unit$1(calc(innerMaxMarginSM).mul(2).equal());
    return {
      [componentCls]: {
        [`&${componentCls}-small`]: {
          minWidth: trackMinWidthSM,
          height: trackHeightSM,
          lineHeight: unit$1(trackHeightSM),
          [`${componentCls}-inner`]: {
            paddingInlineStart: innerMaxMarginSM,
            paddingInlineEnd: innerMinMarginSM,
            [`${switchInnerCls}-checked, ${switchInnerCls}-unchecked`]: {
              minHeight: trackHeightSM
            },
            [`${switchInnerCls}-checked`]: {
              marginInlineStart: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`,
              marginInlineEnd: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`
            },
            [`${switchInnerCls}-unchecked`]: {
              marginTop: calc(trackHeightSM).mul(-1).equal(),
              marginInlineStart: 0,
              marginInlineEnd: 0
            }
          },
          [`${componentCls}-handle`]: {
            width: handleSizeSM,
            height: handleSizeSM
          },
          [`${componentCls}-loading-icon`]: {
            top: calc(calc(handleSizeSM).sub(token2.switchLoadingIconSize)).div(2).equal(),
            fontSize: token2.switchLoadingIconSize
          },
          [`&${componentCls}-checked`]: {
            [`${componentCls}-inner`]: {
              paddingInlineStart: innerMinMarginSM,
              paddingInlineEnd: innerMaxMarginSM,
              [`${switchInnerCls}-checked`]: {
                marginInlineStart: 0,
                marginInlineEnd: 0
              },
              [`${switchInnerCls}-unchecked`]: {
                marginInlineStart: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`,
                marginInlineEnd: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`
              }
            },
            [`${componentCls}-handle`]: {
              insetInlineStart: `calc(100% - ${unit$1(calc(handleSizeSM).add(trackPadding).equal())})`
            }
          },
          [`&:not(${componentCls}-disabled):active`]: {
            [`&:not(${componentCls}-checked) ${switchInnerCls}`]: {
              [`${switchInnerCls}-unchecked`]: {
                marginInlineStart: calc(token2.marginXXS).div(2).equal(),
                marginInlineEnd: calc(token2.marginXXS).mul(-1).div(2).equal()
              }
            },
            [`&${componentCls}-checked ${switchInnerCls}`]: {
              [`${switchInnerCls}-checked`]: {
                marginInlineStart: calc(token2.marginXXS).mul(-1).div(2).equal(),
                marginInlineEnd: calc(token2.marginXXS).div(2).equal()
              }
            }
          }
        }
      }
    };
  };
  const genSwitchLoadingStyle = (token2) => {
    const {
      componentCls,
      handleSize,
      calc
    } = token2;
    return {
      [componentCls]: {
        [`${componentCls}-loading-icon${token2.iconCls}`]: {
          position: "relative",
          top: calc(calc(handleSize).sub(token2.fontSize)).div(2).equal(),
          color: token2.switchLoadingIconColor,
          verticalAlign: "top"
        },
        [`&${componentCls}-checked ${componentCls}-loading-icon`]: {
          color: token2.switchColor
        }
      }
    };
  };
  const genSwitchHandleStyle = (token2) => {
    const {
      componentCls,
      trackPadding,
      handleBg,
      handleShadow,
      handleSize,
      calc
    } = token2;
    const switchHandleCls = `${componentCls}-handle`;
    return {
      [componentCls]: {
        [switchHandleCls]: {
          position: "absolute",
          top: trackPadding,
          insetInlineStart: trackPadding,
          width: handleSize,
          height: handleSize,
          transition: `all ${token2.switchDuration} ease-in-out`,
          ...genNoMotionStyle(),
          "&::before": {
            position: "absolute",
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            backgroundColor: handleBg,
            borderRadius: calc(handleSize).div(2).equal(),
            boxShadow: handleShadow,
            transition: `all ${token2.switchDuration} ease-in-out`,
            content: '""',
            ...genNoMotionStyle()
          }
        },
        [`&${componentCls}-checked ${switchHandleCls}`]: {
          insetInlineStart: `calc(100% - ${unit$1(calc(handleSize).add(trackPadding).equal())})`
        },
        [`&:not(${componentCls}-disabled):active`]: {
          [`${switchHandleCls}::before`]: {
            insetInlineEnd: token2.switchHandleActiveInset,
            insetInlineStart: 0
          },
          [`&${componentCls}-checked ${switchHandleCls}::before`]: {
            insetInlineEnd: 0,
            insetInlineStart: token2.switchHandleActiveInset
          }
        }
      }
    };
  };
  const genSwitchInnerStyle = (token2) => {
    const {
      componentCls,
      trackHeight,
      trackPadding,
      innerMinMargin,
      innerMaxMargin,
      handleSize,
      switchDuration,
      calc
    } = token2;
    const switchInnerCls = `${componentCls}-inner`;
    const trackPaddingCalc = unit$1(calc(handleSize).add(calc(trackPadding).mul(2)).equal());
    const innerMaxMarginCalc = unit$1(calc(innerMaxMargin).mul(2).equal());
    return {
      [componentCls]: {
        [switchInnerCls]: {
          display: "block",
          overflow: "hidden",
          borderRadius: 100,
          height: "100%",
          paddingInlineStart: innerMaxMargin,
          paddingInlineEnd: innerMinMargin,
          transition: [`padding-inline-start`, `padding-inline-end`].map((prop) => `${prop} ${switchDuration} ease-in-out`).join(", "),
          ...genNoMotionStyle(),
          [`${switchInnerCls}-checked, ${switchInnerCls}-unchecked`]: {
            display: "block",
            color: token2.colorTextLightSolid,
            fontSize: token2.fontSizeSM,
            pointerEvents: "none",
            minHeight: trackHeight,
            transition: [`margin-inline-start`, `margin-inline-end`].map((prop) => `${prop} ${switchDuration} ease-in-out`).join(", "),
            ...genNoMotionStyle()
          },
          [`${switchInnerCls}-checked`]: {
            marginInlineStart: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`,
            marginInlineEnd: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`
          },
          [`${switchInnerCls}-unchecked`]: {
            marginTop: calc(trackHeight).mul(-1).equal(),
            marginInlineStart: 0,
            marginInlineEnd: 0
          }
        },
        [`&${componentCls}-checked ${switchInnerCls}`]: {
          paddingInlineStart: innerMinMargin,
          paddingInlineEnd: innerMaxMargin,
          [`${switchInnerCls}-checked`]: {
            marginInlineStart: 0,
            marginInlineEnd: 0
          },
          [`${switchInnerCls}-unchecked`]: {
            marginInlineStart: `calc(100% - ${trackPaddingCalc} + ${innerMaxMarginCalc})`,
            marginInlineEnd: `calc(-100% + ${trackPaddingCalc} - ${innerMaxMarginCalc})`
          }
        },
        [`&:not(${componentCls}-disabled):active`]: {
          [`&:not(${componentCls}-checked) ${switchInnerCls}`]: {
            [`${switchInnerCls}-unchecked`]: {
              marginInlineStart: calc(trackPadding).mul(2).equal(),
              marginInlineEnd: calc(trackPadding).mul(-1).mul(2).equal()
            }
          },
          [`&${componentCls}-checked ${switchInnerCls}`]: {
            [`${switchInnerCls}-checked`]: {
              marginInlineStart: calc(trackPadding).mul(-1).mul(2).equal(),
              marginInlineEnd: calc(trackPadding).mul(2).equal()
            }
          }
        }
      }
    };
  };
  const genSwitchStyle = (token2) => {
    const {
      componentCls,
      trackHeight,
      trackMinWidth
    } = token2;
    return {
      [componentCls]: {
        ...resetComponent(token2),
        position: "relative",
        display: "inline-block",
        boxSizing: "border-box",
        minWidth: trackMinWidth,
        height: trackHeight,
        lineHeight: unit$1(trackHeight),
        verticalAlign: "middle",
        background: token2.colorTextQuaternary,
        border: "0",
        borderRadius: 100,
        cursor: "pointer",
        transition: `all ${token2.motionDurationMid}`,
        userSelect: "none",
        ...genNoMotionStyle(),
        [`&:hover:not(${componentCls}-disabled)`]: {
          background: token2.colorTextTertiary
        },
        ...genFocusStyle(token2),
        [`&${componentCls}-checked`]: {
          background: token2.switchColor,
          [`&:hover:not(${componentCls}-disabled)`]: {
            background: token2.colorPrimaryHover
          }
        },
        [`&${componentCls}-loading, &${componentCls}-disabled`]: {
          cursor: "not-allowed",
          opacity: token2.switchDisabledOpacity,
          "*": {
            boxShadow: "none",
            cursor: "not-allowed"
          }
        },
[`&${componentCls}-rtl`]: {
          direction: "rtl"
        }
      }
    };
  };
  const prepareComponentToken$2 = (token2) => {
    const {
      fontSize,
      lineHeight,
      controlHeight,
      colorWhite
    } = token2;
    const height = fontSize * lineHeight;
    const heightSM = controlHeight / 2;
    const padding = 2;
    const handleSize = height - padding * 2;
    const handleSizeSM = heightSM - padding * 2;
    return {
      trackHeight: height,
      trackHeightSM: heightSM,
      trackMinWidth: handleSize * 2 + padding * 4,
      trackMinWidthSM: handleSizeSM * 2 + padding * 2,
      trackPadding: padding,
handleBg: colorWhite,
      handleSize,
      handleSizeSM,
      handleShadow: `0 2px 4px 0 ${new FastColor("#00230b").setA(0.2).toRgbString()}`,
      innerMinMargin: handleSize / 2,
      innerMaxMargin: handleSize + padding + padding * 2,
      innerMinMarginSM: handleSizeSM / 2,
      innerMaxMarginSM: handleSizeSM + padding + padding * 2
    };
  };
  const useStyle$3 = genStyleHooks("Switch", (token2) => {
    const switchToken = merge$1(token2, {
      switchDuration: token2.motionDurationMid,
      switchColor: token2.colorPrimary,
      switchDisabledOpacity: token2.opacityLoading,
      switchLoadingIconSize: token2.calc(token2.fontSizeIcon).mul(0.75).equal(),
      switchLoadingIconColor: `rgba(0, 0, 0, ${token2.opacityLoading})`,
      switchHandleActiveInset: "-30%"
    });
    return [
      genSwitchStyle(switchToken),
genSwitchInnerStyle(switchToken),
genSwitchHandleStyle(switchToken),
genSwitchLoadingStyle(switchToken),
genSwitchSmallStyle(switchToken)
    ];
  }, prepareComponentToken$2);
  const InternalSwitch = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls: customizePrefixCls,
      size: customizeSize,
      disabled: customDisabled,
      loading,
      className,
      rootClassName,
      style: style2,
      checked: checkedProp,
      value,
      defaultChecked: defaultCheckedProp,
      defaultValue: defaultValue2,
      onChange,
      styles,
      classNames,
      ...restProps
    } = props;
    const [checked, setChecked] = useControlledState(defaultCheckedProp ?? defaultValue2 ?? false, checkedProp ?? value);
    const {
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("switch");
    const disabled = reactExports.useContext(DisabledContext);
    const mergedDisabled = (customDisabled ?? disabled) || loading;
    const prefixCls = getPrefixCls("switch", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$3(prefixCls);
    const mergedSize = useSize(customizeSize);
    const mergedProps = {
      ...props,
      size: mergedSize,
      disabled: mergedDisabled
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const loadingIcon = reactExports.createElement("div", {
      className: clsx(`${prefixCls}-handle`, mergedClassNames.indicator),
      style: mergedStyles.indicator
    }, loading && reactExports.createElement(RefIcon$h, {
      className: `${prefixCls}-loading-icon`
    }));
    const classes2 = clsx(contextClassName, {
      [`${prefixCls}-small`]: mergedSize === "small",
      [`${prefixCls}-loading`]: loading,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, rootClassName, mergedClassNames.root, hashId, cssVarCls);
    const mergedStyle = {
      ...mergedStyles.root,
      ...contextStyle,
      ...style2
    };
    const changeHandler = (...args) => {
      setChecked(args[0]);
      onChange?.(...args);
    };
    return reactExports.createElement(Wave, {
      component: "Switch",
      disabled: mergedDisabled
    }, reactExports.createElement(Switch$1, {
      ...restProps,
      classNames: mergedClassNames,
      styles: mergedStyles,
      checked,
      onChange: changeHandler,
      prefixCls,
      className: classes2,
      style: mergedStyle,
      disabled: mergedDisabled,
      ref: ref2,
      loadingIcon
    }));
  });
  const Switch = InternalSwitch;
  Switch.__ANT_SWITCH = true;
  const genBaseStyle = (token2) => {
    const {
      paddingXXS,
      lineWidth,
      tagPaddingHorizontal,
      componentCls,
      calc
    } = token2;
    const paddingInline = calc(tagPaddingHorizontal).sub(lineWidth).equal();
    const iconMarginInline = calc(paddingXXS).sub(lineWidth).equal();
    return {
[componentCls]: {
        ...resetComponent(token2),
        display: "inline-block",
        height: "auto",
        paddingInline,
        fontSize: token2.tagFontSize,
        lineHeight: token2.tagLineHeight,
        whiteSpace: "nowrap",
        backgroundColor: token2.defaultBg,
        border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
        borderRadius: token2.borderRadiusSM,
        opacity: 1,
        transition: `all ${token2.motionDurationMid}`,
        textAlign: "start",
        position: "relative",
[`&${componentCls}-rtl`]: {
          direction: "rtl"
        },
        "&, a, a:hover": {
          color: token2.defaultColor
        },
        [`${componentCls}-close-icon`]: {
          marginInlineStart: iconMarginInline,
          fontSize: token2.tagIconSize,
          color: token2.colorIcon,
          cursor: "pointer",
          transition: `all ${token2.motionDurationMid}`,
          "&:hover": {
            color: token2.colorTextHeading
          }
        },
        "&-checkable": {
          backgroundColor: "transparent",
          borderColor: "transparent",
          cursor: "pointer",
          [`&:not(${componentCls}-checkable-checked):hover`]: {
            color: token2.colorPrimary,
            backgroundColor: token2.colorFillSecondary
          },
          "&:active, &-checked": {
            color: token2.colorTextLightSolid
          },
          "&-checked": {
            backgroundColor: token2.colorPrimary,
            "&:hover": {
              backgroundColor: token2.colorPrimaryHover
            }
          },
          "&:active": {
            backgroundColor: token2.colorPrimaryActive
          },
          "&-disabled": {
            cursor: "not-allowed",
            [`&:not(${componentCls}-checkable-checked)`]: {
              color: token2.colorTextDisabled,
              "&:hover": {
                backgroundColor: "transparent"
              }
            },
            [`&${componentCls}-checkable-checked`]: {
              color: token2.colorTextDisabled,
              backgroundColor: token2.colorBgContainerDisabled
            },
            "&:hover, &:active": {
              backgroundColor: token2.colorBgContainerDisabled,
              color: token2.colorTextDisabled
            },
            [`&:not(${componentCls}-checkable-checked):hover`]: {
              color: token2.colorTextDisabled
            }
          },
          "&-group": {
            display: "flex",
            flexWrap: "wrap",
            gap: token2.paddingXS
          }
        },
        "&-hidden": {
          display: "none"
        },
[`> ${token2.iconCls} + span, > span + ${token2.iconCls}`]: {
          marginInlineStart: paddingInline
        }
      },
      [`&${token2.componentCls}-solid`]: {
        borderColor: "transparent",
        color: token2.colorTextLightSolid,
        backgroundColor: token2.colorBgSolid,
        [`&${componentCls}-default`]: {
          color: token2.solidTextColor
        }
      },
      [`${componentCls}-filled`]: {
        borderColor: "transparent",
        backgroundColor: token2.tagBorderlessBg
      },
      [`&${componentCls}-disabled`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed",
        backgroundColor: token2.colorBgContainerDisabled,
        a: {
          cursor: "not-allowed",
          pointerEvents: "none",
          color: token2.colorTextDisabled,
          "&:hover": {
            color: token2.colorTextDisabled
          }
        },
        "a&": {
          "&:hover, &:active": {
            color: token2.colorTextDisabled
          }
        },
        [`&${componentCls}-outlined`]: {
          borderColor: token2.colorBorderDisabled
        },
        [`&${componentCls}-solid, &${componentCls}-filled`]: {
          color: token2.colorTextDisabled,
          [`${componentCls}-close-icon`]: {
            color: token2.colorTextDisabled
          }
        },
        [`${componentCls}-close-icon`]: {
          cursor: "not-allowed",
          color: token2.colorTextDisabled,
          "&:hover": {
            color: token2.colorTextDisabled
          }
        }
      }
    };
  };
  const prepareToken = (token2) => {
    const {
      lineWidth,
      fontSizeIcon,
      calc
    } = token2;
    const tagFontSize = token2.fontSizeSM;
    const tagToken = merge$1(token2, {
      tagFontSize,
      tagLineHeight: unit$1(calc(token2.lineHeightSM).mul(tagFontSize).equal()),
      tagIconSize: calc(fontSizeIcon).sub(calc(lineWidth).mul(2)).equal(),
tagPaddingHorizontal: 8,
tagBorderlessBg: token2.defaultBg
    });
    return tagToken;
  };
  const prepareComponentToken$1 = (token2) => {
    const solidTextColor = isBright(new AggregationColor(token2.colorBgSolid), "#fff") ? "#000" : "#fff";
    return {
      defaultBg: new FastColor(token2.colorFillTertiary).onBackground(token2.colorBgContainer).toHexString(),
      defaultColor: token2.colorText,
      solidTextColor
    };
  };
  const useStyle$2 = genStyleHooks("Tag", (token2) => {
    const tagToken = prepareToken(token2);
    return genBaseStyle(tagToken);
  }, prepareComponentToken$1);
  const CheckableTag = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls: customizePrefixCls,
      style: style2,
      className,
      checked,
      children,
      icon,
      onChange,
      onClick,
      disabled: customDisabled,
      ...restProps
    } = props;
    const {
      getPrefixCls,
      tag
    } = reactExports.useContext(ConfigContext);
    const disabled = reactExports.useContext(DisabledContext);
    const mergedDisabled = customDisabled ?? disabled;
    const handleClick = (e) => {
      if (mergedDisabled) {
        return;
      }
      onChange?.(!checked);
      onClick?.(e);
    };
    const prefixCls = getPrefixCls("tag", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$2(prefixCls);
    const cls = clsx(prefixCls, `${prefixCls}-checkable`, {
      [`${prefixCls}-checkable-checked`]: checked,
      [`${prefixCls}-checkable-disabled`]: mergedDisabled
    }, tag?.className, className, hashId, cssVarCls);
    return reactExports.createElement("span", {
      ...restProps,
      ref: ref2,
      style: {
        ...style2,
        ...tag?.style
      },
      className: cls,
      onClick: handleClick
    }, icon, reactExports.createElement("span", null, children));
  });
  const CheckableTagGroup = React.forwardRef((props, ref2) => {
    const {
      id: id2,
      prefixCls: customizePrefixCls,
      rootClassName,
      className,
      style: style2,
      classNames,
      styles,
      disabled,
      options,
      value,
      defaultValue: defaultValue2,
      onChange,
      multiple,
      ...restProps
    } = props;
    const {
      getPrefixCls,
      direction,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("tag");
    const prefixCls = getPrefixCls("tag", customizePrefixCls);
    const groupPrefixCls = `${prefixCls}-checkable-group`;
    const rootCls = useCSSVarCls(prefixCls);
    const [hashId, cssVarCls] = useStyle$2(prefixCls, rootCls);
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props
    });
    const parsedOptions = reactExports.useMemo(() => {
      if (!Array.isArray(options)) {
        return [];
      }
      return options.map((option) => {
        if (option && typeof option === "object") {
          return option;
        }
        return {
          value: option,
          label: option
        };
      });
    }, [options]);
    const [mergedValue, setMergedValue] = useControlledState(defaultValue2, value);
    const handleChange = (checked, option) => {
      let newValue = null;
      if (multiple) {
        const valueList = mergedValue || [];
        newValue = checked ? [].concat(_toConsumableArray(valueList), [option.value]) : valueList.filter((item) => item !== option.value);
      } else {
        newValue = checked ? option.value : null;
      }
      setMergedValue(newValue);
      onChange?.(newValue);
    };
    const divRef = React.useRef(null);
    reactExports.useImperativeHandle(ref2, () => ({
      nativeElement: divRef.current
    }));
    const ariaProps = pickAttrs(restProps, {
      aria: true,
      data: true
    });
    return React.createElement("div", {
      ...ariaProps,
      className: clsx(groupPrefixCls, contextClassName, rootClassName, {
        [`${groupPrefixCls}-disabled`]: disabled,
        [`${groupPrefixCls}-rtl`]: direction === "rtl"
      }, hashId, cssVarCls, className, mergedClassNames.root),
      style: {
        ...contextStyle,
        ...mergedStyles.root,
        ...style2
      },
      id: id2,
      ref: divRef
    }, parsedOptions.map((option) => React.createElement(CheckableTag, {
      key: option.value,
      className: clsx(`${groupPrefixCls}-item`, mergedClassNames.item),
      style: mergedStyles.item,
      checked: multiple ? (mergedValue || []).includes(option.value) : mergedValue === option.value,
      onChange: (checked) => handleChange(checked, option),
      disabled
    }, option.label)));
  });
  function useColor(props, contextVariant) {
    const {
      color: color2,
      variant,
      bordered
    } = props;
    return reactExports.useMemo(() => {
      const isInverseColor = color2?.endsWith("-inverse");
      let nextVariant;
      if (variant) {
        nextVariant = variant;
      } else if (isInverseColor) {
        nextVariant = "solid";
      } else if (bordered === false) {
        nextVariant = "filled";
      } else {
        nextVariant = contextVariant || "filled";
      }
      const nextColor = isInverseColor ? color2?.replace("-inverse", "") : color2;
      const nextIsPreset = isPresetColor(color2);
      const nextIsStatus = isPresetStatusColor(color2);
      const tagStyle = {};
      if (!nextIsPreset && !nextIsStatus && nextColor) {
        if (nextVariant === "solid") {
          tagStyle.backgroundColor = color2;
        } else {
          const hsl = new FastColor(nextColor).toHsl();
          hsl.l = 0.95;
          tagStyle.backgroundColor = new FastColor(hsl).toHexString();
          tagStyle.color = color2;
          if (nextVariant === "outlined") {
            tagStyle.borderColor = color2;
          }
        }
      }
      return [nextVariant, nextColor, nextIsPreset, nextIsStatus, tagStyle];
    }, [color2, variant, bordered, contextVariant]);
  }
  const genPresetStyle = (token2) => genPresetColor$1(token2, (colorKey, {
    textColor,
    lightBorderColor,
    lightColor,
    darkColor
  }) => ({
    [`${token2.componentCls}${token2.componentCls}-${colorKey}:not(${token2.componentCls}-disabled)`]: {
      [`&${token2.componentCls}-outlined`]: {
        backgroundColor: lightColor,
        borderColor: lightBorderColor,
        color: textColor
      },
      [`&${token2.componentCls}-solid`]: {
        backgroundColor: darkColor,
        borderColor: darkColor,
        color: token2.colorTextLightSolid
      },
      [`&${token2.componentCls}-filled`]: {
        backgroundColor: lightColor,
        color: textColor
      }
    }
  }));
  const PresetCmp = genSubStyleComponent(["Tag", "preset"], (token2) => {
    const tagToken = prepareToken(token2);
    return genPresetStyle(tagToken);
  }, prepareComponentToken$1);
  function capitalize(str) {
    if (typeof str !== "string") {
      return str;
    }
    const ret = str.charAt(0).toUpperCase() + str.slice(1);
    return ret;
  }
  const genTagStatusStyle = (token2, status, cssVariableType) => {
    const capitalizedCssVariableType = capitalize(cssVariableType);
    return {
      [`${token2.componentCls}${token2.componentCls}-${status}:not(${token2.componentCls}-disabled)`]: {
        [`&${token2.componentCls}-outlined`]: {
          backgroundColor: token2[`color${capitalizedCssVariableType}Bg`],
          borderColor: token2[`color${capitalizedCssVariableType}Border`],
          color: token2[`color${cssVariableType}`]
        },
        [`&${token2.componentCls}-solid`]: {
          backgroundColor: token2[`color${cssVariableType}`],
          borderColor: token2[`color${cssVariableType}`]
        },
        [`&${token2.componentCls}-filled`]: {
          backgroundColor: token2[`color${capitalizedCssVariableType}Bg`],
          color: token2[`color${cssVariableType}`]
        }
      }
    };
  };
  const StatusCmp = genSubStyleComponent(["Tag", "status"], (token2) => {
    const tagToken = prepareToken(token2);
    return [genTagStatusStyle(tagToken, "success", "Success"), genTagStatusStyle(tagToken, "processing", "Info"), genTagStatusStyle(tagToken, "error", "Error"), genTagStatusStyle(tagToken, "warning", "Warning")];
  }, prepareComponentToken$1);
  const InternalTag = reactExports.forwardRef((props, ref2) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style: style2,
      children,
      icon,
      color: color2,
      variant: _variant,
      onClose,
      bordered,
      disabled: customDisabled,
      href,
      target,
      styles,
      classNames,
      ...restProps
    } = props;
    const {
      getPrefixCls,
      direction,
      className: contextClassName,
      variant: contextVariant,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles
    } = useComponentConfig("tag");
    const [mergedVariant, mergedColor, isPreset, isStatus, customTagStyle] = useColor(props, contextVariant);
    const isInternalColor = isPreset || isStatus;
    const disabled = reactExports.useContext(DisabledContext);
    const mergedDisabled = customDisabled ?? disabled;
    const {
      tag: tagContext
    } = reactExports.useContext(ConfigContext);
    const [visible, setVisible] = reactExports.useState(true);
    const domProps = omit(restProps, ["closeIcon", "closable"]);
    const mergedProps = {
      ...props,
      color: mergedColor,
      variant: mergedVariant,
      disabled: mergedDisabled,
      href,
      target,
      icon
    };
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const tagStyle = reactExports.useMemo(() => {
      let nextTagStyle = {
        ...mergedStyles.root,
        ...contextStyle,
        ...style2
      };
      if (!mergedDisabled) {
        nextTagStyle = {
          ...customTagStyle,
          ...nextTagStyle
        };
      }
      return nextTagStyle;
    }, [mergedStyles.root, contextStyle, style2, customTagStyle, mergedDisabled]);
    const prefixCls = getPrefixCls("tag", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$2(prefixCls);
    const tagClassName = clsx(prefixCls, contextClassName, mergedClassNames.root, `${prefixCls}-${mergedVariant}`, {
      [`${prefixCls}-${mergedColor}`]: isInternalColor,
      [`${prefixCls}-hidden`]: !visible,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-disabled`]: mergedDisabled
    }, className, rootClassName, hashId, cssVarCls);
    const handleCloseClick = (e) => {
      if (mergedDisabled) {
        return;
      }
      e.stopPropagation();
      onClose?.(e);
      if (e.defaultPrevented) {
        return;
      }
      setVisible(false);
    };
    const [, mergedCloseIcon] = useClosable(pickClosable(props), pickClosable(tagContext), {
      closable: false,
      closeIconRender: (iconNode2) => {
        const replacement = reactExports.createElement("span", {
          className: `${prefixCls}-close-icon`,
          onClick: handleCloseClick
        }, iconNode2);
        return replaceElement(iconNode2, replacement, (originProps) => ({
          onClick: (e) => {
            originProps?.onClick?.(e);
            handleCloseClick(e);
          },
          className: clsx(originProps?.className, `${prefixCls}-close-icon`)
        }));
      }
    });
    const isNeedWave = typeof restProps.onClick === "function" || children && children.type === "a";
    const iconNode = cloneElement(icon, {
      className: clsx( reactExports.isValidElement(icon) ? icon.props?.className : void 0, mergedClassNames.icon),
      style: mergedStyles.icon
    });
    const child = iconNode ? reactExports.createElement(reactExports.Fragment, null, iconNode, children && reactExports.createElement("span", {
      className: mergedClassNames.content,
      style: mergedStyles.content
    }, children)) : children;
    const TagWrapper = href ? "a" : "span";
    const tagNode = reactExports.createElement(TagWrapper, {
      ...domProps,
ref: ref2,
      className: tagClassName,
      style: tagStyle,
      href: mergedDisabled ? void 0 : href,
      target,
      onClick: mergedDisabled ? void 0 : domProps.onClick,
      ...href && mergedDisabled ? {
        "aria-disabled": true
      } : {}
    }, child, mergedCloseIcon, isPreset && reactExports.createElement(PresetCmp, {
      key: "preset",
      prefixCls
    }), isStatus && reactExports.createElement(StatusCmp, {
      key: "status",
      prefixCls
    }));
    return isNeedWave ? reactExports.createElement(Wave, {
      component: "Tag"
    }, tagNode) : tagNode;
  });
  const Tag = InternalTag;
  Tag.CheckableTag = CheckableTag;
  Tag.CheckableTagGroup = CheckableTagGroup;
  const getDesignToken = (config) => {
    const theme2 = config?.algorithm ? createTheme(config.algorithm) : defaultTheme;
    const mergedToken = {
      ...seedToken,
      ...config?.token
    };
    return getComputedToken$1(mergedToken, {
      override: config?.token
    }, theme2, formatToken);
  };
  function genSizeMapToken(token2) {
    const {
      sizeUnit,
      sizeStep
    } = token2;
    const compactSizeStep = sizeStep - 2;
    return {
      sizeXXL: sizeUnit * (compactSizeStep + 10),
      sizeXL: sizeUnit * (compactSizeStep + 6),
      sizeLG: sizeUnit * (compactSizeStep + 2),
      sizeMD: sizeUnit * (compactSizeStep + 2),
      sizeMS: sizeUnit * (compactSizeStep + 1),
      size: sizeUnit * compactSizeStep,
      sizeSM: sizeUnit * compactSizeStep,
      sizeXS: sizeUnit * (compactSizeStep - 1),
      sizeXXS: sizeUnit * (compactSizeStep - 1)
    };
  }
  const derivative$1 = (token2, mapToken) => {
    const mergedMapToken = mapToken ?? derivative$2(token2);
    const fontSize = mergedMapToken.fontSizeSM;
    const controlHeight = mergedMapToken.controlHeight - 4;
    return {
      ...mergedMapToken,
      ...genSizeMapToken(mapToken ?? token2),
...genFontMapToken(fontSize),
controlHeight,
      ...genControlHeight({
        ...mergedMapToken,
        controlHeight
      })
    };
  };
  const getAlphaColor = (baseColor, alpha2) => new FastColor(baseColor).setA(alpha2).toRgbString();
  const getSolidColor = (baseColor, brightness) => {
    const instance = new FastColor(baseColor);
    return instance.lighten(brightness).toHexString();
  };
  const generateColorPalettes = (baseColor) => {
    const colors2 = generate$1(baseColor, {
      theme: "dark"
    });
    return {
      1: colors2[0],
      2: colors2[1],
      3: colors2[2],
      4: colors2[3],
      5: colors2[6],
      6: colors2[5],
      7: colors2[4],
      8: colors2[6],
      9: colors2[5],
      10: colors2[4]
    };
  };
  const generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
    const colorBgBase = bgBaseColor || "#000";
    const colorTextBase = textBaseColor || "#fff";
    return {
      colorBgBase,
      colorTextBase,
      colorText: getAlphaColor(colorTextBase, 0.85),
      colorTextSecondary: getAlphaColor(colorTextBase, 0.65),
      colorTextTertiary: getAlphaColor(colorTextBase, 0.45),
      colorTextQuaternary: getAlphaColor(colorTextBase, 0.25),
      colorFill: getAlphaColor(colorTextBase, 0.18),
      colorFillSecondary: getAlphaColor(colorTextBase, 0.12),
      colorFillTertiary: getAlphaColor(colorTextBase, 0.08),
      colorFillQuaternary: getAlphaColor(colorTextBase, 0.04),
      colorBgSolid: getAlphaColor(colorTextBase, 0.95),
      colorBgSolidHover: getAlphaColor(colorTextBase, 1),
      colorBgSolidActive: getAlphaColor(colorTextBase, 0.9),
      colorBgElevated: getSolidColor(colorBgBase, 12),
      colorBgContainer: getSolidColor(colorBgBase, 8),
      colorBgLayout: getSolidColor(colorBgBase, 0),
      colorBgSpotlight: getSolidColor(colorBgBase, 26),
      colorBgBlur: getAlphaColor(colorTextBase, 0.04),
      colorBorder: getSolidColor(colorBgBase, 26),
      colorBorderDisabled: getSolidColor(colorBgBase, 26),
      colorBorderSecondary: getSolidColor(colorBgBase, 19)
    };
  };
  const derivative = (token2, mapToken) => {
    const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
      const colors2 = generate$1(token2[colorKey], {
        theme: "dark"
      });
      return Array.from({
        length: 10
      }, () => 1).reduce((prev2, _2, i2) => {
        prev2[`${colorKey}-${i2 + 1}`] = colors2[i2];
        prev2[`${colorKey}${i2 + 1}`] = colors2[i2];
        return prev2;
      }, {});
    }).reduce((prev2, cur) => {
      prev2 = {
        ...prev2,
        ...cur
      };
      return prev2;
    }, {});
    const mergedMapToken = mapToken ?? derivative$2(token2);
    const colorMapToken = genColorMapToken(token2, {
      generateColorPalettes,
      generateNeutralColorPalettes
    });
    const presetColorHoverActiveTokens = PresetColors.reduce((prev2, colorKey) => {
      const colorBase = token2[colorKey];
      if (colorBase) {
        const colorPalette = generateColorPalettes(colorBase);
        prev2[`${colorKey}Hover`] = colorPalette[7];
        prev2[`${colorKey}Active`] = colorPalette[5];
      }
      return prev2;
    }, {});
    return {
      ...mergedMapToken,
...colorPalettes,
...colorMapToken,
      ...presetColorHoverActiveTokens,

colorPrimaryBg: colorMapToken.colorPrimaryBorder,
      colorPrimaryBgHover: colorMapToken.colorPrimaryBorderHover
    };
  };
  function useToken() {
    const [theme2, token2, hashId, cssVar2] = useToken$1();
    return {
      theme: theme2,
      token: token2,
      hashId,
      cssVar: cssVar2
    };
  }
  const theme = {
defaultSeed: defaultConfig.token,
    useToken,
    defaultAlgorithm: derivative$2,
    darkAlgorithm: derivative,
    compactAlgorithm: derivative$1,
    getDesignToken,
defaultConfig,
_internalContext: DesignTokenContext
  };
  const groupKeysMap = (keys2) => {
    const map = new Map();
    keys2.forEach((key, index) => {
      map.set(key, index);
    });
    return map;
  };
  const groupDisabledKeysMap = (dataSource) => {
    const map = new Map();
    dataSource.forEach(({
      disabled,
      key
    }, index) => {
      if (disabled) {
        map.set(key, index);
      }
    });
    return map;
  };
  function getArrowIcon(type4, direction) {
    const isRight = type4 === "right";
    if (direction !== "rtl") {
      return isRight ? React.createElement(RefIcon$g, null) : React.createElement(RefIcon$b, null);
    }
    return isRight ? React.createElement(RefIcon$b, null) : React.createElement(RefIcon$g, null);
  }
  const Action$1 = ({
    type: type4,
    actions,
    moveToLeft,
    moveToRight,
    leftActive,
    rightActive,
    direction,
    disabled
  }) => {
    const isRight = type4 === "right";
    const button = isRight ? actions[0] : actions[1];
    const moveHandler = isRight ? moveToRight : moveToLeft;
    const active = isRight ? rightActive : leftActive;
    const icon = getArrowIcon(type4, direction);
    if ( React.isValidElement(button)) {
      const element = button;
      const onClick = (event) => {
        element?.props?.onClick?.(event);
        moveHandler?.(event);
      };
      return React.cloneElement(element, {
        disabled: disabled || !active,
        onClick
      });
    }
    return React.createElement(Button$1, {
      type: "primary",
      size: "small",
      disabled: disabled || !active,
      onClick: (event) => moveHandler?.(event),
      icon
    }, button);
  };
  const Actions = (props) => {
    const {
      className,
      style: style2,
      oneWay,
      actions,
      ...restProps
    } = props;
    return React.createElement("div", {
      className,
      style: style2
    }, React.createElement(Action$1, {
      type: "right",
      actions,
      ...restProps
    }), !oneWay && React.createElement(Action$1, {
      type: "left",
      actions,
      ...restProps
    }), actions.slice(oneWay ? 1 : 2));
  };
  const useData = (dataSource, rowKey, targetKeys) => {
    const mergedDataSource = reactExports.useMemo(() => (dataSource || []).map((record) => {
      if (rowKey) {
        return {
          ...record,
          key: rowKey(record)
        };
      }
      return record;
    }), [dataSource, rowKey]);
    const [leftDataSource, rightDataSource] = reactExports.useMemo(() => {
      const leftData = [];
      const rightData = Array.from({
        length: targetKeys?.length ?? 0
      });
      const targetKeysMap = groupKeysMap(targetKeys || []);
      mergedDataSource.forEach((record) => {
        if (targetKeysMap.has(record.key)) {
          const idx = targetKeysMap.get(record.key);
          rightData[idx] = record;
        } else {
          leftData.push(record);
        }
      });
      return [leftData, rightData];
    }, [mergedDataSource, targetKeys]);
    return [mergedDataSource, leftDataSource.filter(Boolean), rightDataSource.filter(Boolean)];
  };
  const EMPTY_KEYS = [];
  function filterKeys(keys2, dataKeys) {
    const filteredKeys = keys2.filter((key) => dataKeys.has(key));
    return keys2.length === filteredKeys.length ? keys2 : filteredKeys;
  }
  function flattenKeys(keys2) {
    return Array.from(keys2).join(";");
  }
  function useSelection(leftDataSource, rightDataSource, selectedKeys) {
    const [leftKeys, rightKeys] = reactExports.useMemo(() => [new Set(leftDataSource.map((src) => src?.key)), new Set(rightDataSource.map((src) => src?.key))], [leftDataSource, rightDataSource]);
    const [mergedSelectedKeys, setMergedSelectedKeys] = useControlledState(EMPTY_KEYS, selectedKeys);
    const sourceSelectedKeys = reactExports.useMemo(() => filterKeys(mergedSelectedKeys, leftKeys), [mergedSelectedKeys, leftKeys]);
    const targetSelectedKeys = reactExports.useMemo(() => filterKeys(mergedSelectedKeys, rightKeys), [mergedSelectedKeys, rightKeys]);
    reactExports.useEffect(() => {
      setMergedSelectedKeys([].concat(_toConsumableArray(filterKeys(mergedSelectedKeys, leftKeys)), _toConsumableArray(filterKeys(mergedSelectedKeys, rightKeys))));
    }, [flattenKeys(leftKeys), flattenKeys(rightKeys)]);
    const setSourceSelectedKeys = useEvent$1((nextSrcKeys) => {
      setMergedSelectedKeys([].concat(_toConsumableArray(nextSrcKeys), _toConsumableArray(targetSelectedKeys)));
    });
    const setTargetSelectedKeys = useEvent$1((nextTargetKeys) => {
      setMergedSelectedKeys([].concat(_toConsumableArray(sourceSelectedKeys), _toConsumableArray(nextTargetKeys)));
    });
    return [
sourceSelectedKeys,
      targetSelectedKeys,
setSourceSelectedKeys,
      setTargetSelectedKeys
    ];
  }
  const Search$1 = (props) => {
    const {
      placeholder = "",
      value,
      prefixCls,
      disabled,
      onChange,
      handleClear
    } = props;
    const handleChange = reactExports.useCallback((e) => {
      onChange?.(e);
      if (e.target.value === "") {
        handleClear?.();
      }
    }, [onChange]);
    return reactExports.createElement(Input$1, {
      placeholder,
      className: prefixCls,
      value,
      onChange: handleChange,
      disabled,
      allowClear: true,
      prefix: reactExports.createElement(RefIcon$d, null)
    });
  };
  var DeleteOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z" } }] }, "name": "delete", "theme": "outlined" };
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  const DeleteOutlined = (props, ref2) => reactExports.createElement(Icon$1, _extends({}, props, {
    ref: ref2,
    icon: DeleteOutlined$1
  }));
  const RefIcon = reactExports.forwardRef(DeleteOutlined);
  const ListItem = (props) => {
    const {
      prefixCls,
      classNames,
      styles,
      renderedText,
      renderedEl,
      item,
      checked,
      disabled,
      onClick,
      onRemove,
      showRemove
    } = props;
    const mergedDisabled = disabled || item?.disabled;
    const classes2 = clsx(`${prefixCls}-content-item`, classNames.item, {
      [`${prefixCls}-content-item-disabled`]: mergedDisabled,
      [`${prefixCls}-content-item-checked`]: checked && !mergedDisabled
    });
    let title;
    if (typeof renderedText === "string" || typeof renderedText === "number") {
      title = String(renderedText);
    }
    const [contextLocale] = useLocale("Transfer", localeValues.Transfer);
    const liProps = {
      className: classes2,
      style: styles.item,
      title
    };
    const labelNode = reactExports.createElement("span", {
      className: clsx(`${prefixCls}-content-item-text`, classNames.itemContent),
      style: styles.itemContent
    }, renderedEl);
    if (showRemove) {
      return reactExports.createElement("li", {
        ...liProps
      }, labelNode, reactExports.createElement("button", {
        type: "button",
        disabled: mergedDisabled,
        className: `${prefixCls}-content-item-remove`,
        "aria-label": contextLocale?.remove,
        onClick: () => onRemove?.(item)
      }, reactExports.createElement(RefIcon, null)));
    }
    liProps.onClick = mergedDisabled ? void 0 : (event) => onClick(item, event);
    return reactExports.createElement("li", {
      ...liProps
    }, reactExports.createElement(Checkbox, {
      className: clsx(`${prefixCls}-checkbox`, classNames.itemIcon),
      style: styles.itemIcon,
      checked,
      disabled: mergedDisabled
    }), labelNode);
  };
  const ListItem$1 = reactExports.memo(ListItem);
  const OmitProps = ["handleFilter", "handleClear", "checkedKeys"];
  const parsePagination = (pagination) => {
    const defaultPagination = {
      simple: true,
      showSizeChanger: false,
      showLessItems: false
    };
    return {
      ...defaultPagination,
      ...pagination
    };
  };
  const TransferListBody = (props, ref2) => {
    const {
      prefixCls,
      classNames,
      styles,
      filteredRenderItems,
      selectedKeys,
      disabled: globalDisabled,
      showRemove,
      pagination,
      onScroll,
      onItemSelect,
      onItemRemove
    } = props;
    const [current, setCurrent] = reactExports.useState(1);
    const mergedPagination = reactExports.useMemo(() => {
      if (!pagination) {
        return null;
      }
      const convertPagination = typeof pagination === "object" ? pagination : {};
      return parsePagination(convertPagination);
    }, [pagination]);
    const [pageSize, setPageSize] = useControlledState(10, mergedPagination?.pageSize);
    reactExports.useEffect(() => {
      if (mergedPagination) {
        const maxPageCount = Math.ceil(filteredRenderItems.length / pageSize);
        setCurrent(Math.min(current, maxPageCount));
      }
    }, [filteredRenderItems, mergedPagination, pageSize]);
    const onInternalClick = (item, e) => {
      onItemSelect(item.key, !selectedKeys.includes(item.key), e);
    };
    const onRemove = (item) => {
      onItemRemove?.([item.key]);
    };
    const onPageChange = (cur) => {
      setCurrent(cur);
    };
    const onSizeChange = (cur, size) => {
      setCurrent(cur);
      setPageSize(size);
    };
    const memoizedItems = reactExports.useMemo(() => {
      const displayItems = mergedPagination ? filteredRenderItems.slice((current - 1) * pageSize, current * pageSize) : filteredRenderItems;
      return displayItems;
    }, [current, filteredRenderItems, mergedPagination, pageSize]);
    reactExports.useImperativeHandle(ref2, () => ({
      items: memoizedItems
    }));
    const paginationNode = mergedPagination ? reactExports.createElement(Pagination, {
      size: "small",
      disabled: globalDisabled,
      simple: mergedPagination.simple,
      pageSize,
      showLessItems: mergedPagination.showLessItems,
      showSizeChanger: mergedPagination.showSizeChanger,
      className: `${prefixCls}-pagination`,
      total: filteredRenderItems.length,
      current,
      onChange: onPageChange,
      onShowSizeChange: onSizeChange
    }) : null;
    return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("ul", {
      className: clsx(`${prefixCls}-content`, classNames.list, {
        [`${prefixCls}-content-show-remove`]: showRemove
      }),
      style: styles.list,
      onScroll
    }, (memoizedItems || []).map(({
      renderedEl,
      renderedText,
      item
    }) => reactExports.createElement(ListItem$1, {
      key: item.key,
      prefixCls,
      classNames,
      styles,
      item,
      renderedText,
      renderedEl,
      showRemove,
      onClick: onInternalClick,
      onRemove,
      checked: selectedKeys.includes(item.key),
      disabled: globalDisabled
    }))), paginationNode);
  };
  const DefaultListBody = reactExports.forwardRef(TransferListBody);
  const defaultRender = () => null;
  function isRenderResultPlainObject(result) {
    return !!(result && ! React.isValidElement(result) && Object.prototype.toString.call(result) === "[object Object]");
  }
  function getEnabledItemKeys(items) {
    return items.filter((data2) => !data2.disabled).map((data2) => data2.key);
  }
  const isValidIcon = (icon) => icon !== void 0;
  const getShowSearchOption = (showSearch) => {
    if (showSearch && typeof showSearch === "object") {
      return {
        ...showSearch,
        defaultValue: showSearch.defaultValue || ""
      };
    }
    return {
      defaultValue: "",
      placeholder: ""
    };
  };
  const TransferSection = (props) => {
    const {
      prefixCls,
      style: style2,
      classNames,
      styles,
      dataSource = [],
      titleText = "",
      checkedKeys,
      disabled,
      showSearch = false,
      searchPlaceholder,
      notFoundContent,
      selectAll,
      deselectAll,
      selectCurrent,
      selectInvert,
      removeAll,
      removeCurrent,
      showSelectAll = true,
      showRemove,
      pagination,
      direction,
      itemsUnit,
      itemUnit,
      selectAllLabel,
      selectionsIcon,
      footer,
      renderList,
      onItemSelectAll,
      onItemRemove,
      handleFilter,
      handleClear,
      filterOption,
      render: render4 = defaultRender
    } = props;
    const sectionPrefixCls = `${prefixCls}-section`;
    const listPrefixCls = `${prefixCls}-list`;
    const searchOptions = getShowSearchOption(showSearch);
    const [filterValue, setFilterValue] = reactExports.useState(searchOptions.defaultValue);
    const listBodyRef = reactExports.useRef({});
    const internalHandleFilter = (e) => {
      setFilterValue(e.target.value);
      handleFilter(e);
    };
    const internalHandleClear = () => {
      setFilterValue("");
      handleClear();
    };
    const matchFilter = (text, item) => {
      if (typeof filterOption === "function") {
        return filterOption(filterValue, item, direction);
      }
      return text.includes(filterValue);
    };
    const customRenderListBody = (listProps) => {
      let bodyContent = renderList ? renderList({
        ...listProps,
        onItemSelect: (key, check) => listProps.onItemSelect(key, check)
      }) : null;
      const customize = !!bodyContent;
      if (!customize) {
        bodyContent = React.createElement(DefaultListBody, {
          ref: listBodyRef,
          ...listProps,
          prefixCls: listPrefixCls
        });
      }
      return {
        customize,
        bodyContent
      };
    };
    const renderItem = (item) => {
      const renderResult = render4(item);
      const isRenderResultPlain = isRenderResultPlainObject(renderResult);
      return {
        item,
        renderedEl: isRenderResultPlain ? renderResult.label : renderResult,
        renderedText: isRenderResultPlain ? renderResult.value : renderResult
      };
    };
    const notFoundContentEle = reactExports.useMemo(() => Array.isArray(notFoundContent) ? notFoundContent[direction === "left" ? 0 : 1] : notFoundContent, [notFoundContent, direction]);
    const [filteredItems, filteredRenderItems] = reactExports.useMemo(() => {
      const filterItems = [];
      const filterRenderItems = [];
      dataSource.forEach((item) => {
        const renderedItem = renderItem(item);
        if (filterValue && !matchFilter(renderedItem.renderedText, item)) {
          return;
        }
        filterItems.push(item);
        filterRenderItems.push(renderedItem);
      });
      return [filterItems, filterRenderItems];
    }, [dataSource, filterValue]);
    const checkedActiveItems = reactExports.useMemo(() => {
      return filteredItems.filter((item) => checkedKeys.includes(item.key) && !item.disabled);
    }, [checkedKeys, filteredItems]);
    const checkStatus = reactExports.useMemo(() => {
      if (checkedActiveItems.length === 0) {
        return "none";
      }
      const checkedKeysMap = groupKeysMap(checkedKeys);
      if (filteredItems.every((item) => checkedKeysMap.has(item.key) || !!item.disabled)) {
        return "all";
      }
      return "part";
    }, [checkedActiveItems.length, checkedKeys, filteredItems]);
    const renderListBody = () => {
      const search = showSearch ? React.createElement("div", {
        className: `${listPrefixCls}-body-search-wrapper`
      }, React.createElement(Search$1, {
        prefixCls: `${listPrefixCls}-search`,
        onChange: internalHandleFilter,
        handleClear: internalHandleClear,
        placeholder: searchOptions.placeholder || searchPlaceholder,
        value: filterValue,
        disabled
      })) : null;
      const {
        customize,
        bodyContent
      } = customRenderListBody({
        ...omit(props, OmitProps),
        filteredItems,
        filteredRenderItems,
        selectedKeys: checkedKeys,
        classNames,
        styles
      });
      let bodyNode;
      if (customize) {
        bodyNode = React.createElement("div", {
          className: `${listPrefixCls}-body-customize-wrapper`
        }, bodyContent);
      } else {
        bodyNode = filteredItems.length ? bodyContent : React.createElement("div", {
          className: `${listPrefixCls}-body-not-found`
        }, notFoundContentEle);
      }
      return React.createElement("div", {
        className: clsx(`${listPrefixCls}-body`, {
          [`${listPrefixCls}-body-with-search`]: showSearch
        }, classNames.body),
        style: styles.body
      }, search, bodyNode);
    };
    const checkBox = React.createElement(Checkbox, {
      disabled: dataSource.filter((d2) => !d2.disabled).length === 0 || disabled,
      checked: checkStatus === "all",
      indeterminate: checkStatus === "part",
      className: `${listPrefixCls}-checkbox`,
      onChange: () => {
        onItemSelectAll?.(filteredItems.filter((item) => !item.disabled).map(({
          key
        }) => key), checkStatus !== "all");
      }
    });
    const getSelectAllLabel = (selectedCount, totalCount) => {
      if (selectAllLabel) {
        return typeof selectAllLabel === "function" ? selectAllLabel({
          selectedCount,
          totalCount
        }) : selectAllLabel;
      }
      const unit2 = totalCount > 1 ? itemsUnit : itemUnit;
      return React.createElement(React.Fragment, null, (selectedCount > 0 ? `${selectedCount}/` : "") + totalCount, " ", unit2);
    };
    const footerDom = footer && (footer.length < 2 ? footer(props) : footer(props, {
      direction
    }));
    const listFooter = footerDom ? React.createElement("div", {
      className: clsx(`${listPrefixCls}-footer`, classNames.footer),
      style: styles.footer
    }, footerDom) : null;
    const checkAllCheckbox = !showRemove && !pagination && checkBox;
    let items;
    if (showRemove) {
      items = [
pagination ? {
          key: "removeCurrent",
          label: removeCurrent,
          onClick() {
            const pageKeys = getEnabledItemKeys((listBodyRef.current?.items || []).map((entity) => entity.item));
            onItemRemove?.(pageKeys);
          }
        } : null,
{
          key: "removeAll",
          label: removeAll,
          onClick() {
            onItemRemove?.(getEnabledItemKeys(filteredItems));
          }
        }
      ].filter(Boolean);
    } else {
      items = [{
        key: "selectAll",
        label: checkStatus === "all" ? deselectAll : selectAll,
        onClick() {
          const keys2 = getEnabledItemKeys(filteredItems);
          onItemSelectAll?.(keys2, keys2.length !== checkedKeys.length);
        }
      }, pagination ? {
        key: "selectCurrent",
        label: selectCurrent,
        onClick() {
          const pageItems = listBodyRef.current?.items || [];
          onItemSelectAll?.(getEnabledItemKeys(pageItems.map((entity) => entity.item)), true);
        }
      } : null, {
        key: "selectInvert",
        label: selectInvert,
        onClick() {
          const availablePageItemKeys = getEnabledItemKeys((listBodyRef.current?.items || []).map((entity) => entity.item));
          const checkedKeySet = new Set(checkedKeys);
          const newCheckedKeysSet = new Set(checkedKeySet);
          availablePageItemKeys.forEach((key) => {
            if (checkedKeySet.has(key)) {
              newCheckedKeysSet.delete(key);
            } else {
              newCheckedKeysSet.add(key);
            }
          });
          onItemSelectAll?.(Array.from(newCheckedKeysSet), "replace");
        }
      }];
    }
    const dropdown = React.createElement(Dropdown, {
      className: `${listPrefixCls}-header-dropdown`,
      menu: {
        items
      },
      disabled
    }, isValidIcon(selectionsIcon) ? selectionsIcon : React.createElement(RefIcon$e, null));
    return React.createElement("div", {
      className: clsx(sectionPrefixCls, classNames.section, {
        [`${sectionPrefixCls}-with-pagination`]: !!pagination,
        [`${sectionPrefixCls}-with-footer`]: !!footerDom
      }),
      style: {
        ...style2,
        ...styles.section
      }
    }, React.createElement("div", {
      className: clsx(`${listPrefixCls}-header`, classNames.header),
      style: styles.header
    }, showSelectAll ? React.createElement(React.Fragment, null, checkAllCheckbox, dropdown) : null, React.createElement("span", {
      className: `${listPrefixCls}-header-selected`
    }, getSelectAllLabel(checkedActiveItems.length, filteredItems.length)), React.createElement("span", {
      className: clsx(`${listPrefixCls}-header-title`, classNames.title),
      style: styles.title
    }, titleText)), renderListBody(), listFooter);
  };
  const genTransferCustomizeStyle = (token2) => {
    const {
      antCls,
      componentCls,
      listHeight,
      controlHeightLG
    } = token2;
    const tableCls = `${antCls}-table`;
    const inputCls = `${antCls}-input`;
    return {
      [`${componentCls}-customize-list`]: {
        [`${componentCls}-section`]: {
          flex: "1 1 50%",
          width: "auto",
          height: "auto",
          minHeight: listHeight,
          minWidth: 0
        },
[`${tableCls}-wrapper`]: {
          [`${tableCls}-small`]: {
            border: 0,
            borderRadius: 0,
            [`${tableCls}-selection-column`]: {
              width: controlHeightLG,
              minWidth: controlHeightLG
            }
          },
          [`${tableCls}-pagination${tableCls}-pagination`]: {
            margin: 0,
            padding: token2.paddingXS
          }
        },
        [`${inputCls}[disabled]`]: {
          backgroundColor: "transparent"
        }
      }
    };
  };
  const genTransferStatusColor = (token2, color2) => {
    const {
      componentCls,
      colorBorder
    } = token2;
    return {
      [`${componentCls}-section`]: {
        borderColor: color2,
        [`${componentCls}-list-search:not([disabled])`]: {
          borderColor: colorBorder
        }
      }
    };
  };
  const genTransferStatusStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-status-error`]: {
        ...genTransferStatusColor(token2, token2.colorError)
      },
      [`${componentCls}-status-warning`]: {
        ...genTransferStatusColor(token2, token2.colorWarning)
      }
    };
  };
  const genTransferListStyle = (token2) => {
    const {
      componentCls,
      colorBorder,
      colorSplit,
      lineWidth,
      itemHeight,
      headerHeight,
      transferHeaderVerticalPadding,
      itemPaddingBlock,
      controlItemBgActive,
      colorTextDisabled,
      colorTextSecondary,
      listHeight,
      listWidth,
      listWidthLG,
      fontSizeIcon,
      marginXS,
      paddingSM,
      lineType,
      antCls,
      iconCls,
      motionDurationSlow,
      controlItemBgHover,
      borderRadiusLG,
      colorBgContainer,
      colorText,
      controlItemBgActiveHover
    } = token2;
    const contentBorderRadius = unit$1(token2.calc(borderRadiusLG).sub(lineWidth).equal());
    return {
      display: "flex",
      flexDirection: "column",
      width: listWidth,
      height: listHeight,
      border: `${unit$1(lineWidth)} ${lineType} ${colorBorder}`,
      borderRadius: token2.borderRadiusLG,
      "&-with-pagination": {
        width: listWidthLG,
        height: "auto"
      },
      [`${componentCls}-list`]: {
        "&-search": {
          [`${iconCls}-search`]: {
            color: colorTextDisabled
          }
        },
        "&-header": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          height: headerHeight,
padding: `${unit$1(token2.calc(transferHeaderVerticalPadding).sub(lineWidth).equal())} ${unit$1(paddingSM)} ${unit$1(transferHeaderVerticalPadding)}`,
          color: colorText,
          background: colorBgContainer,
          borderBottom: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
          borderRadius: `${unit$1(borderRadiusLG)} ${unit$1(borderRadiusLG)} 0 0`,
          "> *:not(:last-child)": {
            marginInlineEnd: 4
},
          "> *": {
            flex: "none"
          },
          "&-title": {
            ...textEllipsis,
            flex: "0 1 auto",
            textAlign: "end",
            marginInlineStart: "auto"
          },
          "&-dropdown": {
            ...resetIcon(),
            fontSize: fontSizeIcon,
            transform: "translateY(10%)",
            cursor: "pointer",
            "&[disabled]": {
              cursor: "not-allowed"
            }
          }
        },
        "&-body": {
          display: "flex",
          flex: "auto",
          flexDirection: "column",
          fontSize: token2.fontSize,
minHeight: 0,
          "&-search-wrapper": {
            position: "relative",
            flex: "none",
            padding: paddingSM
          }
        },
        "&-content": {
          flex: "auto",
          margin: 0,
          padding: 0,
          overflow: "auto",
          listStyle: "none",
          borderRadius: `0 0 ${contentBorderRadius} ${contentBorderRadius}`,
          "&-item": {
            display: "flex",
            alignItems: "center",
            minHeight: itemHeight,
            padding: `${unit$1(itemPaddingBlock)} ${unit$1(paddingSM)}`,
            transition: `all ${motionDurationSlow}`,
            "> *:not(:last-child)": {
              marginInlineEnd: marginXS
            },
            "> *": {
              flex: "none"
            },
            "&-text": {
              ...textEllipsis,
              flex: "auto"
            },
            "&-remove": {
              ...operationUnit(token2),
              color: colorBorder,
              "&:hover, &:focus": {
                color: colorTextSecondary
              }
            },
            [`&:not(${componentCls}-list-content-item-disabled)`]: {
              "&:hover": {
                backgroundColor: controlItemBgHover,
                cursor: "pointer"
              },
              [`&${componentCls}-list-content-item-checked:hover`]: {
                backgroundColor: controlItemBgActiveHover
              }
            },
            "&-checked": {
              backgroundColor: controlItemBgActive
            },
            "&-disabled": {
              color: colorTextDisabled,
              cursor: "not-allowed"
            }
          },
[`&-show-remove ${componentCls}-list-content-item:not(${componentCls}-list-content-item-disabled):hover`]: {
            background: "transparent",
            cursor: "default"
          }
        },
        "&-pagination": {
          padding: token2.paddingXS,
          textAlign: "end",
          borderTop: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
          [`${antCls}-pagination-options`]: {
            paddingInlineEnd: token2.paddingXS
          }
        },
        "&-body-not-found": {
          flex: "none",
          width: "100%",
          margin: "auto 0",
          color: colorTextDisabled,
          textAlign: "center"
        },
        "&-footer": {
          borderTop: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`
        },
"&-checkbox": {
          lineHeight: 1
        }
      }
    };
  };
  const genTransferStyle = (token2) => {
    const {
      antCls,
      iconCls,
      componentCls,
      marginXS,
      marginXXS,
      fontSizeIcon,
      colorBgContainerDisabled
    } = token2;
    return {
      [componentCls]: {
        ...resetComponent(token2),
        position: "relative",
        display: "flex",
        alignItems: "stretch",
        [`${componentCls}-disabled`]: {
          [`${componentCls}-section`]: {
            background: colorBgContainerDisabled
          }
        },
        [`${componentCls}-section`]: genTransferListStyle(token2),
        [`${componentCls}-actions`]: {
          display: "flex",
          flex: "none",
          flexDirection: "column",
          alignSelf: "center",
          margin: `0 ${unit$1(marginXS)}`,
          verticalAlign: "middle",
          gap: marginXXS,
          [`${antCls}-btn ${iconCls}`]: {
            fontSize: fontSizeIcon
          }
        }
      }
    };
  };
  const genTransferRTLStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-rtl`]: {
        direction: "rtl"
      }
    };
  };
  const prepareComponentToken = (token2) => {
    const {
      fontSize,
      lineHeight,
      controlHeight,
      controlHeightLG,
      lineWidth
    } = token2;
    const fontHeight = Math.round(fontSize * lineHeight);
    return {
      listWidth: 180,
      listHeight: 200,
      listWidthLG: 250,
      headerHeight: controlHeightLG,
      itemHeight: controlHeight,
      itemPaddingBlock: (controlHeight - fontHeight) / 2,
      transferHeaderVerticalPadding: Math.ceil((controlHeightLG - lineWidth - fontHeight) / 2)
    };
  };
  const useStyle$1 = genStyleHooks("Transfer", (token2) => {
    const transferToken = merge$1(token2);
    return [genTransferStyle(transferToken), genTransferCustomizeStyle(transferToken), genTransferStatusStyle(transferToken), genTransferRTLStyle(transferToken)];
  }, prepareComponentToken);
  const Transfer = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      classNames,
      styles,
      style: style2,
      listStyle,
      operationStyle,
      operations,
      actions,
      dataSource,
      targetKeys = [],
      selectedKeys,
      selectAllLabels = [],
      locale: locale2 = {},
      titles,
      disabled,
      showSearch = false,
      showSelectAll,
      oneWay,
      pagination,
      status: customStatus,
      selectionsIcon,
      filterOption,
      render: render4,
      footer,
      children,
      rowKey,
      onScroll,
      onChange,
      onSearch,
      onSelectChange
    } = props;
    const {
      getPrefixCls,
      renderEmpty,
      direction: dir,
      className: contextClassName,
      style: contextStyle,
      classNames: contextClassNames,
      styles: contextStyles,
      selectionsIcon: contextSelectionsIcon
    } = useComponentConfig("transfer");
    const contextDisabled = reactExports.useContext(DisabledContext);
    const mergedDisabled = disabled ?? contextDisabled;
    const mergedProps = {
      ...props,
      disabled: mergedDisabled
    };
    const prefixCls = getPrefixCls("transfer", customizePrefixCls);
    const [hashId, cssVarCls] = useStyle$1(prefixCls);
    const mergedActions = actions || operations || [];
    const isRtl = dir === "rtl";
    const [mergedDataSource, leftDataSource, rightDataSource] = useData(dataSource, rowKey, targetKeys);
    const [
sourceSelectedKeys,
      targetSelectedKeys,
setSourceSelectedKeys,
      setTargetSelectedKeys
    ] = useSelection(leftDataSource, rightDataSource, selectedKeys);
    const [leftMultipleSelect, updateLeftPrevSelectedIndex] = useMultipleSelect((item) => item.key);
    const [rightMultipleSelect, updateRightPrevSelectedIndex] = useMultipleSelect((item) => item.key);
    const setStateKeys = reactExports.useCallback((direction, keys2) => {
      if (direction === "left") {
        const nextKeys = typeof keys2 === "function" ? keys2(sourceSelectedKeys || []) : keys2;
        setSourceSelectedKeys(nextKeys);
      } else {
        const nextKeys = typeof keys2 === "function" ? keys2(targetSelectedKeys || []) : keys2;
        setTargetSelectedKeys(nextKeys);
      }
    }, [sourceSelectedKeys, targetSelectedKeys]);
    const setPrevSelectedIndex = (direction, value) => {
      const isLeftDirection = direction === "left";
      const updatePrevSelectedIndex = isLeftDirection ? updateLeftPrevSelectedIndex : updateRightPrevSelectedIndex;
      updatePrevSelectedIndex(value);
    };
    const handleSelectChange = reactExports.useCallback((direction, holder) => {
      if (direction === "left") {
        onSelectChange?.(holder, targetSelectedKeys);
      } else {
        onSelectChange?.(sourceSelectedKeys, holder);
      }
    }, [sourceSelectedKeys, targetSelectedKeys]);
    const getTitles = (transferLocale) => titles ?? transferLocale.titles ?? [];
    const handleLeftScroll = (e) => {
      onScroll?.("left", e);
    };
    const handleRightScroll = (e) => {
      onScroll?.("right", e);
    };
    const moveTo = (direction) => {
      const moveKeys = direction === "right" ? sourceSelectedKeys : targetSelectedKeys;
      const dataSourceDisabledKeysMap = groupDisabledKeysMap(mergedDataSource);
      const newMoveKeys = moveKeys.filter((key) => !dataSourceDisabledKeysMap.has(key));
      const newMoveKeysMap = groupKeysMap(newMoveKeys);
      const newTargetKeys = direction === "right" ? newMoveKeys.concat(targetKeys) : targetKeys.filter((targetKey) => !newMoveKeysMap.has(targetKey));
      const oppositeDirection = direction === "right" ? "left" : "right";
      setStateKeys(oppositeDirection, []);
      handleSelectChange(oppositeDirection, []);
      onChange?.(newTargetKeys, direction, newMoveKeys);
    };
    const moveToLeft = () => {
      moveTo("left");
      setPrevSelectedIndex("left", null);
    };
    const moveToRight = () => {
      moveTo("right");
      setPrevSelectedIndex("right", null);
    };
    const onItemSelectAll = (direction, keys2, checkAll) => {
      setStateKeys(direction, (prevKeys) => {
        let mergedCheckedKeys = [];
        if (checkAll === "replace") {
          mergedCheckedKeys = keys2;
        } else if (checkAll) {
          mergedCheckedKeys = Array.from(new Set([].concat(_toConsumableArray(prevKeys), _toConsumableArray(keys2))));
        } else {
          const selectedKeysMap = groupKeysMap(keys2);
          mergedCheckedKeys = prevKeys.filter((key) => !selectedKeysMap.has(key));
        }
        handleSelectChange(direction, mergedCheckedKeys);
        return mergedCheckedKeys;
      });
      setPrevSelectedIndex(direction, null);
    };
    const onLeftItemSelectAll = (keys2, checkAll) => onItemSelectAll("left", keys2, checkAll);
    const onRightItemSelectAll = (keys2, checkAll) => onItemSelectAll("right", keys2, checkAll);
    const leftFilter = (e) => onSearch?.("left", e.target.value);
    const rightFilter = (e) => onSearch?.("right", e.target.value);
    const handleLeftClear = () => onSearch?.("left", "");
    const handleRightClear = () => onSearch?.("right", "");
    const handleSingleSelect = (direction, holder, selectedKey, checked, currentSelectedIndex) => {
      const isSelected = holder.has(selectedKey);
      if (isSelected) {
        holder.delete(selectedKey);
        setPrevSelectedIndex(direction, null);
      }
      if (checked) {
        holder.add(selectedKey);
        setPrevSelectedIndex(direction, currentSelectedIndex);
      }
    };
    const handleMultipleSelect = (direction, data2, holder, currentSelectedIndex) => {
      const isLeftDirection = direction === "left";
      const multipleSelect = isLeftDirection ? leftMultipleSelect : rightMultipleSelect;
      multipleSelect(currentSelectedIndex, data2, holder);
    };
    const onItemSelect = (direction, selectedKey, checked, multiple) => {
      const isLeftDirection = direction === "left";
      const holder = isLeftDirection ? sourceSelectedKeys : targetSelectedKeys;
      const holderSet = new Set(holder);
      const data2 = (isLeftDirection ? leftDataSource : rightDataSource).filter((item) => !item.disabled);
      const currentSelectedIndex = data2.findIndex((item) => item.key === selectedKey);
      if (multiple && holder.length > 0) {
        handleMultipleSelect(direction, data2, holderSet, currentSelectedIndex);
      } else {
        handleSingleSelect(direction, holderSet, selectedKey, checked, currentSelectedIndex);
      }
      const holderArr = Array.from(holderSet);
      handleSelectChange(direction, holderArr);
      if (!props.selectedKeys) {
        setStateKeys(direction, holderArr);
      }
    };
    const onLeftItemSelect = (selectedKey, checked, e) => {
      onItemSelect("left", selectedKey, checked, e?.shiftKey);
    };
    const onRightItemSelect = (selectedKey, checked, e) => onItemSelect("right", selectedKey, checked, e?.shiftKey);
    const onRightItemRemove = (keys2) => {
      setStateKeys("right", []);
      onChange?.(targetKeys.filter((key) => !keys2.includes(key)), "left", _toConsumableArray(keys2));
    };
    const handleListStyle = (direction) => {
      if (typeof listStyle === "function") {
        return listStyle({
          direction
        });
      }
      return listStyle || {};
    };
    const formItemContext = reactExports.useContext(FormItemInputContext);
    const {
      hasFeedback,
      status
    } = formItemContext;
    const getLocale = (transferLocale) => ({
      ...transferLocale,
      notFoundContent: renderEmpty?.("Transfer") || React.createElement(DefaultRenderEmpty, {
        componentName: "Transfer"
      }),
      ...locale2
    });
    const mergedStatus = getMergedStatus(status, customStatus);
    const mergedPagination = !children && pagination;
    const leftActive = rightDataSource.filter((d2) => targetSelectedKeys.includes(d2.key) && !d2.disabled).length > 0;
    const rightActive = leftDataSource.filter((d2) => sourceSelectedKeys.includes(d2.key) && !d2.disabled).length > 0;
    const [mergedClassNames, mergedStyles] = useMergeSemantic([contextClassNames, classNames], [contextStyles, styles], {
      props: mergedProps
    });
    const cls = clsx(prefixCls, {
      [`${prefixCls}-disabled`]: mergedDisabled,
      [`${prefixCls}-customize-list`]: !!children,
      [`${prefixCls}-rtl`]: isRtl
    }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), contextClassName, className, rootClassName, hashId, cssVarCls, mergedClassNames.root);
    const [contextLocale] = useLocale("Transfer", localeValues.Transfer);
    const listLocale = getLocale(contextLocale);
    const [leftTitle, rightTitle] = getTitles(listLocale);
    const mergedSelectionsIcon = selectionsIcon ?? contextSelectionsIcon;
    return React.createElement("div", {
      className: cls,
      style: {
        ...contextStyle,
        ...mergedStyles.root,
        ...style2
      }
    }, React.createElement(TransferSection, {
      prefixCls,
      style: handleListStyle("left"),
      classNames: mergedClassNames,
      styles: mergedStyles,
      titleText: leftTitle,
      dataSource: leftDataSource,
      filterOption,
      checkedKeys: sourceSelectedKeys,
      handleFilter: leftFilter,
      handleClear: handleLeftClear,
      onItemSelect: onLeftItemSelect,
      onItemSelectAll: onLeftItemSelectAll,
      render: render4,
      showSearch,
      renderList: children,
      footer,
      onScroll: handleLeftScroll,
      disabled: mergedDisabled,
      direction: isRtl ? "right" : "left",
      showSelectAll,
      selectAllLabel: selectAllLabels[0],
      pagination: mergedPagination,
      selectionsIcon: mergedSelectionsIcon,
      ...listLocale
    }), React.createElement(Actions, {
      className: clsx(`${prefixCls}-actions`, mergedClassNames.actions),
      rightActive,
      moveToRight,
      leftActive,
      actions: mergedActions,
      moveToLeft,
      style: {
        ...operationStyle,
        ...mergedStyles.actions
      },
      disabled: mergedDisabled,
      direction: dir,
      oneWay
    }), React.createElement(TransferSection, {
      prefixCls,
      style: handleListStyle("right"),
      classNames: mergedClassNames,
      styles: mergedStyles,
      titleText: rightTitle,
      dataSource: rightDataSource,
      filterOption,
      checkedKeys: targetSelectedKeys,
      handleFilter: rightFilter,
      handleClear: handleRightClear,
      onItemSelect: onRightItemSelect,
      onItemSelectAll: onRightItemSelectAll,
      onItemRemove: onRightItemRemove,
      render: render4,
      showSearch,
      renderList: children,
      footer,
      onScroll: handleRightScroll,
      disabled: mergedDisabled,
      direction: isRtl ? "left" : "right",
      showSelectAll,
      selectAllLabel: selectAllLabels[1],
      showRemove: oneWay,
      pagination: mergedPagination,
      selectionsIcon: mergedSelectionsIcon,
      ...listLocale
    }));
  };
  Transfer.List = TransferSection;
  Transfer.Search = Search$1;
  Transfer.Operation = Actions;
  const { proxyStateMap: proxyStateMap$2 } = unstable_getInternalStates();
  const isProxy$2 = (x) => proxyStateMap$2.has(x);
  const trappersForGet = new Set();
  unstable_replaceInternalFunction("createHandler", (createHandler2) => (...args) => {
    const handler = createHandler2(...args);
    const origGet = handler.get || ((target, p2, receiver) => Reflect.get(target, p2, receiver));
    handler.get = (target, p2, receiver) => {
      for (const trapper of trappersForGet) {
        trapper(target, p2, receiver);
      }
      return origGet(target, p2, receiver);
    };
    return handler;
  });
  const callbackStack = [];
  const registerCallback = (callback) => {
    if (callbackStack.length) {
      callbackStack[callbackStack.length - 1].add(callback);
    } else {
      callback();
    }
  };
  function watch(fn) {
    const subscriptions = new Map();
    const touchedKeys = new Map();
    const isChanged2 = (p2, prev2) => Array.from(prev2).some(([key, prevValue]) => {
      const value = p2[key];
      const prevOfValue = touchedKeys.get(value);
      if (prevOfValue) {
        return isChanged2(value, prevOfValue);
      }
      if (!Object.is(value, prevValue[0])) {
        return true;
      }
      const version2 = getVersion(value);
      const prevVersion = prevValue[1];
      if (typeof version2 === "number" && typeof prevVersion === "number") {
        return version2 !== prevVersion;
      }
      return false;
    });
    const callback = () => {
      if (Array.from(touchedKeys).some(([p2, prev2]) => isChanged2(p2, prev2))) {
        runFn();
      }
    };
    const subscribeProxies = () => {
      for (const [p2, unsub] of subscriptions) {
        if (!touchedKeys.has(p2)) {
          unsub();
          subscriptions.delete(p2);
        }
      }
      for (const p2 of touchedKeys.keys()) {
        if (!subscriptions.has(p2)) {
          const unsub = subscribe$3(p2, () => registerCallback(callback), true);
          subscriptions.set(p2, unsub);
        }
      }
    };
    const runFn = () => {
      touchedKeys.clear();
      const trapper = (target, p2, receiver) => {
        if (!isProxy$2(receiver)) {
          return;
        }
        let prev2 = touchedKeys.get(receiver);
        if (!prev2) {
          prev2 = new Map();
          touchedKeys.set(receiver, prev2);
        }
        const v = Reflect.get(target, p2, receiver);
        prev2.set(p2, [v, getVersion(v)]);
      };
      trappersForGet.add(trapper);
      try {
        fn();
      } finally {
        trappersForGet.delete(trapper);
        subscribeProxies();
      }
    };
    runFn();
    const unwatch = () => {
      for (const unsub of subscriptions.values()) {
        unsub();
      }
      subscriptions.clear();
      touchedKeys.clear();
    };
    return unwatch;
  }
  function effect(fn, cleanup2) {
    const unwatch = watch(fn);
    return () => {
      unwatch();
    };
  }
  function minmax(value, min, max) {
    if (value < min) {
      return min;
    } else if (value > max) {
      return max;
    } else {
      return value;
    }
  }
  function unwrapRef(ref2) {
    return ref2.value;
  }
  var Dispatcher = class _Dispatcher {
    static fromConcurrency(concurrency, label = "") {
      if (!isFinite(concurrency)) throw new Error("concurrency must be finite");
      if (!(concurrency > 0)) throw new Error("concurrency must be greater than 0");
      const executors = new Array(concurrency).fill(0).map(
        (_2, index) => [label, `executors(${concurrency})`, index].map((x) => x && x.toString().trim()).filter(Boolean).join(".")
      );
      return new _Dispatcher(executors);
    }
    executorRefs;
    idleState;
    constructor(executors) {
      if (!executors.length) throw new Error("executors can not be empty");
      this.executorRefs = executors.map((x) => ({ value: x }));
      this.idleState = new WeakMap();
      this.executorRefs.forEach((x) => this.idleState.set(x, true));
    }
    aborted = false;
    abort() {
      this.aborted = true;
      this.pendingResolves = [];
    }
    pendingResolves = [];
    replenish = (executor) => {
      if (this.aborted) return;
      if (!this.pendingResolves.length) return;
      this.pendingResolves.shift()?.();
    };
    async getExecutorRef() {
      const find = () => this.executorRefs.find((x) => this.idleState.get(x));
      let executorRef = find();
      while (!executorRef) {
        const { promise, resolve } = Promise.withResolvers();
        this.pendingResolves.push(resolve);
        await promise;
        executorRef = find();
      }
      this.idleState.set(executorRef, false);
      return executorRef;
    }
    async dispatch(action2) {
      const executorRef = await this.getExecutorRef();
      const executor = unwrapRef(executorRef);
      try {
        return await action2(executor);
      } finally {
        this.idleState.set(executorRef, true);
        setTimeout(() => this.replenish(executorRef));
      }
    }
  };
  async function pmap(arr, fn, concurrency) {
    if (!arr.length) return [];
    concurrency = Math.min(concurrency, arr.length);
    const dispatcher = Dispatcher.fromConcurrency(concurrency, "pmap");
    try {
      return await Promise.all(
        arr.map((item, index) => dispatcher.dispatch(() => fn(item, index, arr)))
      );
    } catch (e) {
      dispatcher.abort();
      throw e;
    }
  }
  function pLimit(concurrency) {
    const dispatcher = Dispatcher.fromConcurrency(concurrency, "pLimit");
    return function limit2(fn, ...args) {
      return dispatcher.dispatch(() => fn(...args));
    };
  }
  var limitFunction = createLimitedVersionOfFn;
  function createLimitedVersionOfFn(fn, concurrency) {
    const dispatcher = Dispatcher.fromConcurrency(concurrency, "createLimitedVersionOfFn");
    return function limitedVersionOfFn(...args) {
      return dispatcher.dispatch(() => fn(...args));
    };
  }
  function subscribeKey(proxyObject2, key, callback, notifyInSync) {
    let prevValue = proxyObject2[key];
    return subscribe$3(
      proxyObject2,
      () => {
        const nextValue = proxyObject2[key];
        if (!Object.is(prevValue, nextValue)) {
          callback(prevValue = nextValue);
        }
      },
      notifyInSync
    );
  }
  const { proxyStateMap: proxyStateMap$1, snapCache: snapCache$1 } = unstable_getInternalStates();
  const isProxy$1 = (x) => proxyStateMap$1.has(x);
  function proxyMap(entries) {
    const initialData = [];
    let initialIndex = 0;
    const indexMap = new Map();
    const snapMapCache = new WeakMap();
    const registerSnapMap = () => {
      const cache2 = snapCache$1.get(vObject);
      const latestSnap = cache2 == null ? void 0 : cache2[1];
      if (latestSnap && !snapMapCache.has(latestSnap)) {
        const clonedMap = new Map(indexMap);
        snapMapCache.set(latestSnap, clonedMap);
      }
    };
    const getMapForThis = (x) => snapMapCache.get(x) || indexMap;
    if (entries) {
      if (typeof entries[Symbol.iterator] !== "function") {
        throw new TypeError(
          "proxyMap:\n	initial state must be iterable\n		tip: structure should be [[key, value]]"
        );
      }
      for (const [key, value] of entries) {
        indexMap.set(key, initialIndex);
        initialData[initialIndex++] = value;
      }
    }
    const vObject = {
      data: initialData,
      index: initialIndex,
      epoch: 0,
      get size() {
        if (!isProxy$1(this)) {
          registerSnapMap();
        }
        const map = getMapForThis(this);
        return map.size;
      },
      get(key) {
        const map = getMapForThis(this);
        const index = map.get(key);
        if (index === void 0) {
          this.epoch;
          return void 0;
        }
        return this.data[index];
      },
      has(key) {
        const map = getMapForThis(this);
        this.epoch;
        return map.has(key);
      },
      set(key, value) {
        if (!isProxy$1(this)) {
          throw new Error("Cannot perform mutations on a snapshot");
        }
        const index = indexMap.get(key);
        if (index === void 0) {
          indexMap.set(key, this.index);
          this.data[this.index++] = value;
        } else {
          this.data[index] = value;
        }
        this.epoch++;
        return this;
      },
      delete(key) {
        if (!isProxy$1(this)) {
          throw new Error("Cannot perform mutations on a snapshot");
        }
        const index = indexMap.get(key);
        if (index === void 0) {
          return false;
        }
        delete this.data[index];
        indexMap.delete(key);
        this.epoch++;
        return true;
      },
      clear() {
        if (!isProxy$1(this)) {
          throw new Error("Cannot perform mutations on a snapshot");
        }
        this.data.length = 0;
        this.index = 0;
        this.epoch++;
        indexMap.clear();
      },
      forEach(cb) {
        this.epoch;
        const map = getMapForThis(this);
        map.forEach((index, key) => {
          cb(this.data[index], key, this);
        });
      },
      *entries() {
        this.epoch;
        const map = getMapForThis(this);
        for (const [key, index] of map) {
          yield [key, this.data[index]];
        }
      },
      *keys() {
        this.epoch;
        const map = getMapForThis(this);
        for (const key of map.keys()) {
          yield key;
        }
      },
      *values() {
        this.epoch;
        const map = getMapForThis(this);
        for (const index of map.values()) {
          yield this.data[index];
        }
      },
      [Symbol.iterator]() {
        return this.entries();
      },
      get [Symbol.toStringTag]() {
        return "Map";
      },
      toJSON() {
        return new Map(this.entries());
      }
    };
    const proxiedObject = proxy(vObject);
    Object.defineProperties(proxiedObject, {
      size: { enumerable: false },
      index: { enumerable: false },
      epoch: { enumerable: false },
      data: { enumerable: false },
      toJSON: { enumerable: false }
    });
    Object.seal(proxiedObject);
    return proxiedObject;
  }
  const { proxyStateMap, snapCache } = unstable_getInternalStates();
  const maybeProxify = (x) => typeof x === "object" ? proxy({ x }).x : x;
  const isProxy = (x) => proxyStateMap.has(x);
  function proxySet(initialValues) {
    const initialData = [];
    const indexMap = new Map();
    let initialIndex = 0;
    const snapMapCache = new WeakMap();
    const registerSnapMap = () => {
      const cache2 = snapCache.get(vObject);
      const latestSnap = cache2 == null ? void 0 : cache2[1];
      if (latestSnap && !snapMapCache.has(latestSnap)) {
        const clonedMap = new Map(indexMap);
        snapMapCache.set(latestSnap, clonedMap);
      }
    };
    const getMapForThis = (x) => snapMapCache.get(x) || indexMap;
    if (initialValues) {
      if (typeof initialValues[Symbol.iterator] !== "function") {
        throw new TypeError("not iterable");
      }
      for (const value of initialValues) {
        if (!indexMap.has(value)) {
          const v = maybeProxify(value);
          indexMap.set(v, initialIndex);
          initialData[initialIndex++] = v;
        }
      }
    }
    const isIterable = (o2) => typeof o2 === "object" && o2 !== null && Symbol.iterator in o2;
    const hasForEach = (o2) => typeof o2.forEach === "function";
    const asIterable = (other) => {
      if (isIterable(other)) return other;
      if (hasForEach(other)) {
        const acc = [];
        other.forEach((v) => acc.push(v));
        return acc;
      }
      throw new TypeError("Expected an iterable");
    };
    function intersectionImpl(other) {
      this.epoch;
      const otherSet = proxySet(asIterable(other));
      const result = proxySet();
      for (const value of this.values()) {
        if (otherSet.has(value)) {
          result.add(value);
        }
      }
      return proxySet(result);
    }
    function unionImpl(other) {
      this.epoch;
      const otherSet = proxySet(asIterable(other));
      const result = proxySet();
      for (const v of this.values()) result.add(v);
      for (const v of otherSet.values()) result.add(v);
      return proxySet(result);
    }
    function differenceImpl(other) {
      this.epoch;
      const otherSet = proxySet(asIterable(other));
      const result = proxySet();
      for (const v of this.values()) if (!otherSet.has(v)) result.add(v);
      return proxySet(result);
    }
    function symmetricDifferenceImpl(other) {
      this.epoch;
      const otherSet = proxySet(asIterable(other));
      const result = proxySet();
      for (const v of this.values()) if (!otherSet.has(v)) result.add(v);
      for (const v of otherSet.values()) if (!this.has(v)) result.add(v);
      return proxySet(result);
    }
    const vObject = {
      data: initialData,
      index: initialIndex,
      epoch: 0,
      get size() {
        if (!isProxy(this)) {
          registerSnapMap();
        }
        return indexMap.size;
      },
      has(value) {
        const map = getMapForThis(this);
        const v = maybeProxify(value);
        this.epoch;
        return map.has(v);
      },
      add(value) {
        if (!isProxy(this)) {
          throw new Error("Cannot perform mutations on a snapshot");
        }
        const v = maybeProxify(value);
        if (!indexMap.has(v)) {
          indexMap.set(v, this.index);
          this.data[this.index++] = v;
          this.epoch++;
        }
        return this;
      },
      delete(value) {
        if (!isProxy(this)) {
          throw new Error("Cannot perform mutations on a snapshot");
        }
        const v = maybeProxify(value);
        const index = indexMap.get(v);
        if (index === void 0) {
          return false;
        }
        delete this.data[index];
        indexMap.delete(v);
        this.epoch++;
        return true;
      },
      clear() {
        if (!isProxy(this)) {
          throw new Error("Cannot perform mutations on a snapshot");
        }
        this.data.length = 0;
        this.index = 0;
        this.epoch++;
        indexMap.clear();
      },
      forEach(cb) {
        this.epoch;
        const map = getMapForThis(this);
        map.forEach((index) => {
          cb(this.data[index], this.data[index], this);
        });
      },
      *values() {
        this.epoch;
        const map = getMapForThis(this);
        for (const index of map.values()) {
          yield this.data[index];
        }
      },
      keys() {
        this.epoch;
        return this.values();
      },
      *entries() {
        this.epoch;
        const map = getMapForThis(this);
        for (const index of map.values()) {
          const value = this.data[index];
          yield [value, value];
        }
      },
      toJSON() {
        return new Set(this.values());
      },
      [Symbol.iterator]() {
        return this.values();
      },
      get [Symbol.toStringTag]() {
        return "Set";
      },
      intersection: intersectionImpl,
      union: unionImpl,
      difference: differenceImpl,
      symmetricDifference: symmetricDifferenceImpl,
      isSubsetOf(other) {
        this.epoch;
        for (const v of this.values()) if (!other.has(v)) return false;
        return true;
      },
      isSupersetOf(other) {
        this.epoch;
        const it = asIterable(other);
        for (const v of it) if (!this.has(v)) return false;
        return true;
      },
      isDisjointFrom(other) {
        this.epoch;
        for (const v of this.values()) if (other.has(v)) return false;
        return true;
      }
    };
    const proxiedObject = proxy(vObject);
    Object.defineProperties(proxiedObject, {
      size: { enumerable: false },
      data: { enumerable: false },
      index: { enumerable: false },
      epoch: { enumerable: false },
      toJSON: { enumerable: false }
    });
    Object.seal(proxiedObject);
    return proxiedObject;
  }
  const RUNNING_IN_USERSCRIPTS = typeof GM_info !== "undefined" && GM_info.scriptHandler === "Userscripts";
  function openNewTab(url2, active = true) {
    if (url2.startsWith("/")) url2 = location.origin + url2;
    if (RUNNING_IN_USERSCRIPTS) {
      GM.openInTab(url2, !active);
      return;
    }
    GM.openInTab(url2, {
      active,
      insert: true,
      setParent: true
    });
  }
  function reciveGmValueUpdatesFromOtherTab({
    storageKey: storageKey2,
    onUpdate,
    setPersist
  }) {
    if (typeof GM_addValueChangeListener === "undefined") return;
    const limit2 = pLimit(1);
    GM_addValueChangeListener(storageKey2, (name, oldValue, newValue, remote) => {
      if (!remote) return;
      if (!newValue) return;
      limit2(async () => {
        setPersist(false);
        try {
          onUpdate(newValue);
        } finally {
          await Promise.resolve().then(() => {
            setPersist(true);
          });
        }
      });
    });
  }
  function valtioFactory(computeValue) {
    const state2 = proxy({
      value: computeValue()
    });
    function use() {
      return useSnapshot(state2).value;
    }
    function get2() {
      return state2.value;
    }
    function update() {
      return state2.value = computeValue();
    }
    const updateThrottled = throttle$2(update, 100, {
      edges: ["leading", "trailing"]
    });
    return {
      state: state2,
      use,
      get: get2,
      update,
      updateThrottled
    };
  }
  function subscribeOnKeys(state2, keys2, callback) {
    let prevVal = pick(snapshot(state2), keys2);
    subscribe$3(state2, () => {
      const snap = snapshot(state2);
      const val = pick(snap, keys2);
      if (!isEqual$2(prevVal, val)) {
        callback(snap);
      }
      prevVal = val;
    });
  }
  function proxyWithLocalStorage(initialVaue, storageKey2) {
    if (!storageKey2.startsWith(APP_NAME)) storageKey2 = `${APP_NAMESPACE}:${storageKey2}`;
    const allowedKeys = Object.keys(initialVaue);
    const [loadErr, savedValue] = attempt(() => {
      const str = localStorage.getItem(storageKey2);
      if (!str) return;
      const obj = JSON.parse(str);
      return pick(obj, allowedKeys);
    });
    if (loadErr) {
      appWarn("failed to load from localStorage key=", storageKey2, "error=", loadErr);
    }
    const p2 = proxy({
      ...initialVaue,
      ...savedValue
    });
    setTimeout(() => {
      subscribe$3(p2, () => {
        const val = snapshot(p2);
        localStorage.setItem(storageKey2, JSON.stringify(val));
      });
    });
    return p2;
  }
  async function proxyWithGmStorage(initialVaue, storageKey2) {
    async function load2() {
      const allowedKeys = Object.keys(initialVaue);
      return pick(await GM.getValue(storageKey2) || {}, allowedKeys);
    }
    const p2 = proxy({
      ...initialVaue,
      ...await load2()
    });
    setTimeout(() => {
      const limit2 = pLimit(1);
      subscribe$3(p2, () => limit2(async () => {
        const existing = await load2();
        const newValue = toMerged(existing, snapshot(p2));
        GM.setValue(storageKey2, newValue);
      }));
    });
    return p2;
  }
  async function proxySetWithGmStorage(storageKey2) {
    const load2 = async () => await GM.getValue(storageKey2) || [];
    const p2 = proxySet(await load2());
    const replaceAllWith = (newVal) => {
      const newSet = new Set(newVal);
      for (const x of [...p2, ...newSet]) {
        if (!newSet.has(x)) p2.delete(x);
        else p2.add(x);
      }
    };
    setTimeout(setupSubscribe);
    let persist = true;
    function setupSubscribe() {
      subscribe$3(p2, () => {
        if (!persist) return;
        GM.setValue(storageKey2, Array.from(snapshot(p2)));
      });
      reciveGmValueUpdatesFromOtherTab({
        storageKey: storageKey2,
        setPersist: (val) => persist = val,
        onUpdate: replaceAllWith
      });
    }
    return {
      set: p2,
      replaceAllWith
    };
  }
  async function proxyMapWithGmStorage(storageKey2, beforeSave) {
    const load2 = async () => await GM.getValue(storageKey2) || [];
    const p2 = proxyMap(await load2());
    const replaceAllWith = (newVal) => {
      const newMap = new Map(newVal);
      for (const [k, v] of [...p2, ...newMap]) {
        if (!newMap.has(k)) p2.delete(k);
        else p2.set(k, v);
      }
    };
    setTimeout(setupSubscribe);
    let persist = true;
    function setupSubscribe() {
      subscribe$3(p2, () => {
        if (!persist) return;
        let val = Array.from(snapshot(p2));
        GM.setValue(storageKey2, val);
      });
      reciveGmValueUpdatesFromOtherTab({
        storageKey: storageKey2,
        setPersist: (val) => persist = val,
        onUpdate: replaceAllWith
      });
    }
    return {
      map: p2,
      replaceAllWith
    };
  }
  const defaultHeader = () => document.querySelector(".bili-header__bar");
  const $usingEvolevdHeader = valtioFactory(calcUsingCustomHeader);
  function calcUsingCustomHeader() {
    const el = defaultHeader();
    return Boolean(el && window.getComputedStyle(el).display === "none");
  }
  const $headerHeight = valtioFactory(function calcHeaderHeight() {
    if (!calcUsingCustomHeader()) return 64;
    const fixed = document.body.classList.contains("fixed-navbar");
    if (!fixed) return 0;
    const heightDef = document.documentElement.style.getPropertyValue("--navbar-height");
    if (!heightDef) return 50;
    const height = Number(heightDef.replace("px", ""));
    if (Number.isNaN(height)) return 50;
    return height;
  });
  const $headerWidth = valtioFactory(function calcHeaderWidth() {
    const paddingDef = document.documentElement.style.getPropertyValue("--navbar-bounds-padding");
    if (!paddingDef) return;
    if (!/^\d+%$/.test(paddingDef)) return;
    const percent2 = minmax(Number(paddingDef.replace("%", "")), 2, 10);
    return 100 - percent2 * 2;
  });
  function useBackToTopRight() {
    const width = $headerWidth.use();
    const {
      pureRecommend,
      grid: {
        useCustomGrid
      }
    } = useSettingsSnapshot();
    if (!pureRecommend || !useCustomGrid) return;
    if (!width) return;
    const rest = (1 - width / 100) / 2 * window.innerWidth +
10;
    const backToTopWidth = 40;
    if (rest > backToTopWidth +
24 +
5) {
      return;
    }
    if (rest < backToTopWidth) {
      return 0;
    }
    const right = Math.floor((rest - backToTopWidth) / 2);
    return right;
  }
  const $evolvedThemeColor = valtioFactory(function calcEvolvedThemeColor() {
    return window.getComputedStyle(document.documentElement).getPropertyValue("--theme-color");
  });
  const evolvedThemeColorStorageKey = `${APP_NAMESPACE}:evolved-theme-color-hex`;
  effect(() => {
    const hex3 = $evolvedThemeColor.get();
    if (!hex3) return;
    localStorage.setItem(evolvedThemeColorStorageKey, hex3);
  });
  function getEvolvedThemeColorFallback() {
    return localStorage.getItem(evolvedThemeColorStorageKey) || BiliBrandColor.Pink;
  }
  function action() {
    $usingEvolevdHeader.updateThrottled();
    $headerHeight.updateThrottled();
    $headerWidth.updateThrottled();
    $evolvedThemeColor.updateThrottled();
  }
  const ob$1 = new MutationObserver(() => action());
  ob$1.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ["style"]
  });
  ob$1.observe(document.body, {
    attributes: true,
    attributeFilter: ["class"]
  });
  document.body.addEventListener("click", (e) => {
    const el = e.target;
    const isClickOnButton = (el2) => !!el2?.matches(".be-button.ok");
    if (!isClickOnButton(el) && !isClickOnButton(el.parentElement)) return;
    if (!el.closest(".be-popup.picker.open")) return;
    setTimeout($evolvedThemeColor.updateThrottled, 1e3);
  }, {
    capture: true,
    passive: true
  });
  const messageConfig = {
maxCount: 5,
    top: $headerHeight.get() - 4
  };
  staticMethods$1.config(messageConfig);
  function AntdStaticFunctionsSetup() {
    const h2 = $headerHeight.use();
    return jsx$1(App, { message: {
      ...messageConfig,
      top: h2 - 4
    }, children: jsx$1(SetupInner, {}) });
  }
  let antStatic;
  let antMessage = staticMethods$1;
  let antNotification = staticMethods;
  let antModal = Modal;
  function SetupInner() {
    antStatic = App.useApp();
    antMessage = antStatic.message;
    antNotification = antStatic.notification;
    antModal = antStatic.modal;
    return null;
  }
  function defineAntMenus(arr) {
    return arr.filter(Boolean).filter((x) => {
      if (x.test === void 0) return true;
      if (typeof x.test === "boolean") return x.test;
      return x.test();
    }).map((x) => omit$1(x, ["test"]));
  }
  const cuidaShuffleOutline = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M17.793 3.693a1 1 0 0 1 1.414 0l2.5 2.5a1 1 0 0 1 0 1.414l-2.5 2.5a1 1 0 1 1-1.414-1.414L19.586 6.9l-1.793-1.793a1 1 0 0 1 0-1.414m0 10.15a1 1 0 0 1 1.414 0l2.5 2.5a1 1 0 0 1 0 1.414l-2.5 2.5a1 1 0 1 1-1.414-1.414l1.793-1.793l-1.793-1.793a1 1 0 0 1 0-1.414", clipRule: "evenodd" }),
jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M19.054 5.913c.352.023.657.043.946.043a1 1 0 1 1 0 2c-.346 0-.776-.028-1.184-.054a37 37 0 0 0-.606-.037c-.614-.03-1.118-.02-1.482.065c-1.456.341-3.07 1.481-4.394 4.117c1.304 2.555 2.9 3.529 4.394 3.879c.364.085.868.094 1.482.064c.186-.009.393-.022.606-.036A19 19 0 0 1 20 15.899a1 1 0 1 1 0 2c-.289 0-.594.02-.946.044c-.227.015-.473.032-.747.045c-.63.03-1.377.04-2.035-.115c-1.812-.424-3.549-1.493-4.972-3.634c-.553 1.02-1.177 1.822-1.927 2.427c-.978.788-2.12 1.106-3.213 1.24c-.882.108-1.81.102-2.64.096L3 18a1 1 0 1 1 0-2l.582.002c.824.005 1.593.01 2.335-.08c.892-.11 1.624-.348 2.201-.813c.687-.554 1.323-1.447 1.962-2.95l.046-.109l-.046-.109c-.651-1.53-1.303-2.495-2.015-3.103c-.56-.477-1.277-.726-2.161-.845c-.763-.102-1.562-.099-2.42-.095L3 7.899a1 1 0 1 1 0-2l.445-.001c.853-.004 1.813-.01 2.724.113c1.094.146 2.234.486 3.194 1.305c.75.64 1.375 1.481 1.93 2.52c1.408-2.187 3.136-3.421 4.979-3.853c.658-.154 1.405-.145 2.035-.115c.274.013.52.03.747.045", clipRule: "evenodd" })
  ] });
  const ForwardRef$1k = reactExports.forwardRef(cuidaShuffleOutline);
  function defineSvgComponent(render4) {
    return (props) => {
      return render4({
        xmlns: "http://www.w3.org/2000/svg",
        xmlnsXlink: "http://www.w3.org/1999/xlink",
        width: "1em",
        height: "1em",
        ...props
      });
    };
  }
  const IconFreshSpaceDynamicFeed = defineSvgComponent((props) => {
    return jsx$1("svg", { viewBox: "0 0 1024 1024", fill: "currentColor", ...props, children: jsx$1("path", { d: "M550 470q10-36 34-62.5t56.5-41Q673 352 709 352q35 0 67.5 14t57 40.5Q858 433 869 470q1 4-1 7t-9 3H560q-4 0-8-2t-2-8zm-64-11q-7 27 3.5 46t28.5 29q18 10 36 10h310q19 0 37.5-10.5t28-30Q939 484 931 456q-14-51-46.5-88.5T807 309q-45-21-98-21-57 0-103 23.5t-77 62Q498 412 486 459zm-17 15q-35-10-61.5-34t-41-56.5Q352 351 352 315q0-35 14-67.5t40.5-57Q433 166 470 155q3-1 6.5 1t3.5 9v299q0 4-2 8t-9 2zm-11 64q28 7 47-3t29-28.5q10-18.5 10-36.5V160q0-19-10.5-37.5t-30.5-28Q483 85 455 93q-50 14-88 46.5T308.5 217Q288 262 288 315q0 57 23 103t62 77q39 31 85 43zm16 16q-10 36-34 62.5t-57 41Q350 672 314 672q-35 0-67.5-14T190 617.5Q166 591 155 554q-1-3 1-6.5t9-3.5h298q5 0 9 2t2 8zm63 11q7-27-3-46t-28-29q-18-10-36-10H160q-19 0-37.5 10.5t-28 30Q85 540 93 569q14 50 46.5 87.5T217 715q45 21 97 21 57 0 103.5-23.5t77.5-62q31-38.5 42-85.5zm17-15q36 10 62.5 34t41 57q14.5 33 14.5 69 0 35-14 67t-40.5 56.5Q591 858 554 869q-3 1-6.5-1t-3.5-9V560q0-4 2-8t8-2zm11-63q-27-7-46 3t-29 28q-10 18-10 36v310q0 19 10.5 37.5t30 28Q540 939 568 931q51-14 88.5-46.5T715 807q21-45 21-97 0-57-23.5-103.5t-62-77.5Q612 498 565 487z" }) });
  });
  const svgSpinnersBarsRotateFade = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { children: [
jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", opacity: 0.14 }),
jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", opacity: 0.29, transform: "rotate(30 12 12)" }),
jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", opacity: 0.43, transform: "rotate(60 12 12)" }),
jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", opacity: 0.57, transform: "rotate(90 12 12)" }),
jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", opacity: 0.71, transform: "rotate(120 12 12)" }),
jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", opacity: 0.86, transform: "rotate(150 12 12)" }),
jsx$1("rect", { width: 2, height: 5, x: 11, y: 1, fill: "currentColor", transform: "rotate(180 12 12)" }),
jsx$1("animateTransform", { attributeName: "transform", calcMode: "discrete", dur: "0.75s", repeatCount: "indefinite", type: "rotate", values: "0 12 12;30 12 12;60 12 12;90 12 12;120 12 12;150 12 12;180 12 12;210 12 12;240 12 12;270 12 12;300 12 12;330 12 12;360 12 12" })
    ] })
  ] });
  const ForwardRef$1j = reactExports.forwardRef(svgSpinnersBarsRotateFade);
  const phThumbsUpDuotone = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 256 256", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "currentColor", children: [
jsx$1("path", { d: "M80 104v104H32a8 8 0 0 1-8-8v-88a8 8 0 0 1 8-8Z", opacity: 0.2 }),
jsx$1("path", { d: "M234 80.12A24 24 0 0 0 216 72h-56V56a40 40 0 0 0-40-40a8 8 0 0 0-7.16 4.42L75.06 96H32a16 16 0 0 0-16 16v88a16 16 0 0 0 16 16h172a24 24 0 0 0 23.82-21l12-96A24 24 0 0 0 234 80.12M32 112h40v88H32Zm191.94-15l-12 96a8 8 0 0 1-7.94 7H88v-94.11l36.71-73.43A24 24 0 0 1 144 56v24a8 8 0 0 0 8 8h64a8 8 0 0 1 7.94 9" })
    ] })
  ] });
  const ForwardRef$1i = reactExports.forwardRef(phThumbsUpDuotone);
  const phThumbsDownDuotone = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 256 256", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "currentColor", children: [
jsx$1("path", { d: "M80 48v104H32a8 8 0 0 1-8-8V56a8 8 0 0 1 8-8Z", opacity: 0.2 }),
jsx$1("path", { d: "m239.82 157l-12-96A24 24 0 0 0 204 40H32a16 16 0 0 0-16 16v88a16 16 0 0 0 16 16h43.06l37.78 75.58A8 8 0 0 0 120 240a40 40 0 0 0 40-40v-16h56a24 24 0 0 0 23.82-27M72 144H32V56h40Zm150 21.29a7.88 7.88 0 0 1-6 2.71h-64a8 8 0 0 0-8 8v24a24 24 0 0 1-19.29 23.54L88 150.11V56h116a8 8 0 0 1 7.94 7l12 96a7.87 7.87 0 0 1-1.94 6.29" })
    ] })
  ] });
  const ForwardRef$1h = reactExports.forwardRef(phThumbsDownDuotone);
  const iconParkOutlineConfig = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "m24 4l-6 6h-8v8l-6 6l6 6v8h8l6 6l6-6h8v-8l6-6l-6-6v-8h-8z" }),
jsx$1("path", { d: "M24 30a6 6 0 1 0 0-12a6 6 0 0 0 0 12Z" })
    ] })
  ] });
  const ForwardRef$1g = reactExports.forwardRef(iconParkOutlineConfig);
  const iconParkOutlinePlayTwo = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("rect", { width: 36, height: 36, x: 6, y: 6, strokeLinecap: "round", rx: 3 }),
jsx$1("path", { d: "M18.5 24v-7.794l6.75 3.897L32 24l-6.75 3.897l-6.75 3.897z" })
    ] })
  ] });
  const ForwardRef$1f = reactExports.forwardRef(iconParkOutlinePlayTwo);
  const materialSymbolsLightOpenInNew = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M5.616 20q-.691 0-1.153-.462T4 18.384V5.616q0-.691.463-1.153T5.616 4h5.615v1H5.616q-.231 0-.424.192T5 5.616v12.769q0 .23.192.423t.423.192h12.77q.23 0 .423-.192t.192-.423v-5.616h1v5.616q0 .69-.462 1.152T18.384 20zm4.123-5.03l-.708-.709L18.292 5H14V4h6v6h-1V5.708z" })
  ] });
  const ForwardRef$1e = reactExports.forwardRef(materialSymbolsLightOpenInNew);
  const mdiSortClockDescending = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M18 7h-3l4-4l4 4h-3v14h-2zM8 5c-3.86 0-7 3.13-7 7s3.13 7 7 7c3.86 0 7-3.13 7-7s-3.13-7-7-7m2.19 9.53L7 12.69V9h1.5v2.82l2.44 1.41z" })
  ] });
  const ForwardRef$1d = reactExports.forwardRef(mdiSortClockDescending);
  const mdiSortClockAscending = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M20 17h3l-4 4l-4-4h3V3h2zM8 5c-3.86 0-7 3.13-7 7s3.13 7 7 7c3.86 0 7-3.13 7-7s-3.13-7-7-7m2.19 9.53L7 12.69V9h1.5v2.82l2.44 1.41z" })
  ] });
  const ForwardRef$1c = reactExports.forwardRef(mdiSortClockAscending);
  const tablerSortAscending = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 6h7m-7 6h7m-7 6h9m2-9l3-3l3 3m-3-3v12" })
  ] });
  const ForwardRef$1b = reactExports.forwardRef(tablerSortAscending);
  const tablerSortDescending = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 6h9m-9 6h7m-7 6h7m4-3l3 3l3-3m-3-9v12" })
  ] });
  const ForwardRef$1a = reactExports.forwardRef(tablerSortDescending);
  const iconParkOutlineInfo = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", children: [
jsx$1("path", { stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, d: "M24 44a19.94 19.94 0 0 0 14.142-5.858A19.94 19.94 0 0 0 44 24a19.94 19.94 0 0 0-5.858-14.142A19.94 19.94 0 0 0 24 4A19.94 19.94 0 0 0 9.858 9.858A19.94 19.94 0 0 0 4 24a19.94 19.94 0 0 0 5.858 14.142A19.94 19.94 0 0 0 24 44Z" }),
jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M24 11a2.5 2.5 0 1 1 0 5a2.5 2.5 0 0 1 0-5", clipRule: "evenodd" }),
jsx$1("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "M24.5 34V20h-2M21 34h7" })
    ] })
  ] });
  const ForwardRef$19 = reactExports.forwardRef(iconParkOutlineInfo);
  const mdiShuffleDisabled = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M16 4.5V7H5v2h11v2.5L19.5 8M16 12.5V15H5v2h11v2.5l3.5-3.5" })
  ] });
  const ForwardRef$18 = reactExports.forwardRef(mdiShuffleDisabled);
  const iconParkOutlineTime = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4S4 12.954 4 24s8.954 20 20 20Z" }),
jsx$1("path", { strokeLinecap: "round", d: "M24.008 12v12.01l8.479 8.48" })
    ] })
  ] });
  const ForwardRef$17 = reactExports.forwardRef(iconParkOutlineTime);
  const iconParkOutlineIphone = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeWidth: 4, children: [
jsx$1("rect", { width: 26, height: 40, x: 11, y: 4, rx: 3 }),
jsx$1("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M22 10h4m-6 28h8" })
    ] })
  ] });
  const ForwardRef$16 = reactExports.forwardRef(iconParkOutlineIphone);
  const iconParkOutlineComputer = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeWidth: 4, children: [
jsx$1("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M19 32h10v9H19z" }),
jsx$1("rect", { width: 38, height: 24, x: 5, y: 8, rx: 2 }),
jsx$1("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M22 27h4M14 41h20" })
    ] })
  ] });
  const ForwardRef$15 = reactExports.forwardRef(iconParkOutlineComputer);
  const iconParkOutlineConcern = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", children: [
jsx$1("path", { strokeLinecap: "round", strokeWidth: 4, d: "M10.858 9.858A19.94 19.94 0 0 0 5 24a19.94 19.94 0 0 0 5.858 14.142m28.284 0A19.94 19.94 0 0 0 45 24a19.94 19.94 0 0 0-5.858-14.142M34.9 33.9A13.96 13.96 0 0 0 39 24a13.96 13.96 0 0 0-4.1-9.9m-19.8 0A13.96 13.96 0 0 0 11 24a13.96 13.96 0 0 0 4.1 9.9" }),
jsx$1("path", { strokeLinejoin: "round", strokeWidth: 3.5, d: "M28.182 20C30.29 20 32 21.612 32 23.6c0 2.588-2.546 4.8-3.818 6Q26.908 30.8 25 32q-1.909-1.2-3.182-2.4C20.545 28.4 18 26.188 18 23.6c0-1.988 1.71-3.6 3.818-3.6c1.328 0 2.498.64 3.182 1.61c.684-.97 1.854-1.61 3.182-1.61Z" })
    ] })
  ] });
  const ForwardRef$14 = reactExports.forwardRef(iconParkOutlineConcern);
  const carbonStar = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 32 32", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "m16 6.52l2.76 5.58l.46 1l1 .15l6.16.89l-4.38 4.3l-.75.73l.18 1l1.05 6.13l-5.51-2.89L16 23l-.93.49l-5.51 2.85l1-6.13l.18-1l-.74-.77l-4.42-4.35l6.16-.89l1-.15l.46-1zM16 2l-4.55 9.22l-10.17 1.47l7.36 7.18L6.9 30l9.1-4.78L25.1 30l-1.74-10.13l7.36-7.17l-10.17-1.48Z" })
  ] });
  const ForwardRef$13 = reactExports.forwardRef(carbonStar);
  const carbonStarFilled = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 32 32", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "m16 2l-4.55 9.22l-10.17 1.47l7.36 7.18L6.9 30l9.1-4.78L25.1 30l-1.74-10.13l7.36-7.17l-10.17-1.48Z" })
  ] });
  const ForwardRef$12 = reactExports.forwardRef(carbonStarFilled);
  const iconParkOutlineFire = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, d: "M24 44c8.235 0 15-6.526 15-14.902c0-2.056-.105-4.26-1.245-7.686s-1.369-3.868-2.574-5.984c-.515 4.317-3.27 6.117-3.97 6.655c0-.56-1.666-6.747-4.193-10.45C24.537 8 21.163 5.617 19.185 4c0 3.07-.863 7.634-2.1 9.96c-1.236 2.325-1.468 2.41-3.013 4.14s-2.253 2.265-3.545 4.365S9 27.362 9 29.418C9 37.794 15.765 44 24 44Z" })
  ] });
  const ForwardRef$11 = reactExports.forwardRef(iconParkOutlineFire);
  const lineMdUploadingLoop = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsx$1("path", { strokeDasharray: 32, d: "M12 3c4.97 0 9 4.03 9 9c0 4.97 -4.03 9 -9 9", children: jsx$1("animate", { fill: "freeze", attributeName: "stroke-dashoffset", dur: "0.6s", values: "32;0" }) }),
jsxs("path", { strokeDasharray: "2 4", strokeDashoffset: 6, d: "M12 21c-4.97 0 -9 -4.03 -9 -9c0 -4.97 4.03 -9 9 -9", opacity: 0, children: [
jsx$1("set", { fill: "freeze", attributeName: "opacity", begin: "0.45s", to: 1 }),
jsx$1("animateTransform", { fill: "freeze", attributeName: "transform", begin: "0.45s", dur: "0.6s", type: "rotate", values: "-180 12 12;0 12 12" }),
jsx$1("animate", { attributeName: "stroke-dashoffset", begin: "0.85s", dur: "0.6s", repeatCount: "indefinite", to: 0 })
      ] }),
jsx$1("path", { strokeDasharray: 10, strokeDashoffset: 10, d: "M12 16v-7.5", children: jsx$1("animate", { fill: "freeze", attributeName: "stroke-dashoffset", begin: "0.85s", dur: "0.2s", to: 0 }) }),
jsx$1("path", { strokeDasharray: 8, strokeDashoffset: 8, d: "M12 8.5l3.5 3.5M12 8.5l-3.5 3.5", children: jsx$1("animate", { fill: "freeze", attributeName: "stroke-dashoffset", begin: "1.05s", dur: "0.2s", to: 0 }) })
    ] })
  ] });
  const ForwardRef$10 = reactExports.forwardRef(lineMdUploadingLoop);
  const iconParkOutlinePeopleDelete = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M19 20a7 7 0 1 0 0-14a7 7 0 0 0 0 14Z" }),
jsx$1("path", { strokeLinecap: "round", d: "m33 31l8 8m-8 0l8-8m-14-3h-8.2c-4.48 0-6.72 0-8.432.872a8 8 0 0 0-3.496 3.496C6 34.08 6 36.32 6 40.8V42h21" })
    ] })
  ] });
  const ForwardRef$$ = reactExports.forwardRef(iconParkOutlinePeopleDelete);
  const iconParkOutlineReturn = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "m13 8l-7 6l7 7" }),
jsx$1("path", { d: "M6 14h22.994c6.883 0 12.728 5.62 12.996 12.5c.284 7.27-5.723 13.5-12.996 13.5H11.998" })
    ] })
  ] });
  const ForwardRef$_ = reactExports.forwardRef(iconParkOutlineReturn);
  const iconParkOutlineCopy = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { strokeLinecap: "round", d: "M13 12.432v-4.62A2.813 2.813 0 0 1 15.813 5h24.374A2.813 2.813 0 0 1 43 7.813v24.375A2.813 2.813 0 0 1 40.188 35h-4.672" }),
jsx$1("path", { d: "M32.188 13H7.811A2.813 2.813 0 0 0 5 15.813v24.374A2.813 2.813 0 0 0 7.813 43h24.375A2.813 2.813 0 0 0 35 40.188V15.811A2.813 2.813 0 0 0 32.188 13Z" })
    ] })
  ] });
  const ForwardRef$Z = reactExports.forwardRef(iconParkOutlineCopy);
  const materialSymbolsDeleteOutlineRounded = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M7 21q-.825 0-1.412-.587T5 19V6q-.425 0-.712-.288T4 5t.288-.712T5 4h4q0-.425.288-.712T10 3h4q.425 0 .713.288T15 4h4q.425 0 .713.288T20 5t-.288.713T19 6v13q0 .825-.587 1.413T17 21zM17 6H7v13h10zm-6.287 10.713Q11 16.425 11 16V9q0-.425-.288-.712T10 8t-.712.288T9 9v7q0 .425.288.713T10 17t.713-.288m4 0Q15 16.426 15 16V9q0-.425-.288-.712T14 8t-.712.288T13 9v7q0 .425.288.713T14 17t.713-.288M7 6v13z" })
  ] });
  const ForwardRef$Y = reactExports.forwardRef(materialSymbolsDeleteOutlineRounded);
  const iconParkOutlineTransferData = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "m10 8l-6 6l6 6m28 8l6 6l-6 6M4 14h40M4 34h40" })
  ] });
  const ForwardRef$X = reactExports.forwardRef(iconParkOutlineTransferData);
  const iconParkOutlineWrite = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M5.325 43.5h8.485l31.113-31.113l-8.486-8.485L5.325 35.015z" }),
jsx$1("path", { strokeLinecap: "round", d: "m27.952 12.387l8.485 8.485" })
    ] })
  ] });
  const ForwardRef$W = reactExports.forwardRef(iconParkOutlineWrite);
  const materialSymbolsBarChart = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M16 20v-7h4v7zm-6 0V4h4v16zm-6 0V9h4v11z" })
  ] });
  const ForwardRef$V = reactExports.forwardRef(materialSymbolsBarChart);
  const LayoutGroupContext = reactExports.createContext({});
  function useConstant(init) {
    const ref2 = reactExports.useRef(null);
    if (ref2.current === null) {
      ref2.current = init();
    }
    return ref2.current;
  }
  const isBrowser$3 = typeof window !== "undefined";
  const useIsomorphicLayoutEffect$1 = isBrowser$3 ? reactExports.useLayoutEffect : reactExports.useEffect;
  const PresenceContext = reactExports.createContext(null);
  function addUniqueItem(arr, item) {
    if (arr.indexOf(item) === -1)
      arr.push(item);
  }
  function removeItem(arr, item) {
    const index = arr.indexOf(item);
    if (index > -1)
      arr.splice(index, 1);
  }
  const clamp = (min, max, v) => {
    if (v > max)
      return max;
    if (v < min)
      return min;
    return v;
  };
  let invariant = () => {
  };
  const MotionGlobalConfig = {};
  const isNumericalString = (v) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v);
  function isObject(value) {
    return typeof value === "object" && value !== null;
  }
  const isZeroValueString = (v) => /^0[^.\s]+$/u.test(v);
function memo(callback) {
    let result;
    return () => {
      if (result === void 0)
        result = callback();
      return result;
    };
  }
  const noop$1 = (any3) => any3;
  const combineFunctions = (a2, b) => (v) => b(a2(v));
  const pipe = (...transformers) => transformers.reduce(combineFunctions);
  const progress = (from2, to, value) => {
    const toFromDifference = to - from2;
    return toFromDifference === 0 ? 1 : (value - from2) / toFromDifference;
  };
  class SubscriptionManager {
    constructor() {
      this.subscriptions = [];
    }
    add(handler) {
      addUniqueItem(this.subscriptions, handler);
      return () => removeItem(this.subscriptions, handler);
    }
    notify(a2, b, c2) {
      const numSubscriptions = this.subscriptions.length;
      if (!numSubscriptions)
        return;
      if (numSubscriptions === 1) {
        this.subscriptions[0](a2, b, c2);
      } else {
        for (let i2 = 0; i2 < numSubscriptions; i2++) {
          const handler = this.subscriptions[i2];
          handler && handler(a2, b, c2);
        }
      }
    }
    getSize() {
      return this.subscriptions.length;
    }
    clear() {
      this.subscriptions.length = 0;
    }
  }
  const secondsToMilliseconds = (seconds) => seconds * 1e3;
  const millisecondsToSeconds = (milliseconds) => milliseconds / 1e3;
  function velocityPerSecond(velocity, frameDuration) {
    return frameDuration ? velocity * (1e3 / frameDuration) : 0;
  }
  const wrap = (min, max, v) => {
    const rangeSize = max - min;
    return ((v - min) % rangeSize + rangeSize) % rangeSize + min;
  };
  const calcBezier = (t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2;
  const subdivisionPrecision = 1e-7;
  const subdivisionMaxIterations = 12;
  function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
    let currentX;
    let currentT;
    let i2 = 0;
    do {
      currentT = lowerBound + (upperBound - lowerBound) / 2;
      currentX = calcBezier(currentT, mX1, mX2) - x;
      if (currentX > 0) {
        upperBound = currentT;
      } else {
        lowerBound = currentT;
      }
    } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
    return currentT;
  }
  function cubicBezier(mX1, mY1, mX2, mY2) {
    if (mX1 === mY1 && mX2 === mY2)
      return noop$1;
    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
    return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
  }
  const mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;
  const reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);
  const backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
  const backIn = reverseEasing(backOut);
  const backInOut = mirrorEasing(backIn);
  const anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));
  const circIn = (p2) => 1 - Math.sin(Math.acos(p2));
  const circOut = reverseEasing(circIn);
  const circInOut = mirrorEasing(circIn);
  const easeIn = cubicBezier(0.42, 0, 1, 1);
  const easeOut = cubicBezier(0, 0, 0.58, 1);
  const easeInOut = cubicBezier(0.42, 0, 0.58, 1);
  const isEasingArray = (ease2) => {
    return Array.isArray(ease2) && typeof ease2[0] !== "number";
  };
  function getEasingForSegment(easing, i2) {
    return isEasingArray(easing) ? easing[wrap(0, easing.length, i2)] : easing;
  }
  const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
  const easingLookup = {
    linear: noop$1,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate
  };
  const isValidEasing = (easing) => {
    return typeof easing === "string";
  };
  const easingDefinitionToFunction = (definition) => {
    if (isBezierDefinition(definition)) {
      invariant(definition.length === 4);
      const [x1, y1, x2, y2] = definition;
      return cubicBezier(x1, y1, x2, y2);
    } else if (isValidEasing(definition)) {
      return easingLookup[definition];
    }
    return definition;
  };
  const stepsOrder = [
    "setup",
"read",
"resolveKeyframes",
"preUpdate",
"update",
"preRender",
"render",
"postRender"
];
  function createRenderStep(runNextFrame, stepName) {
    let thisFrame = new Set();
    let nextFrame = new Set();
    let isProcessing = false;
    let flushNextFrame = false;
    const toKeepAlive = new WeakSet();
    let latestFrameData = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    };
    function triggerCallback(callback) {
      if (toKeepAlive.has(callback)) {
        step.schedule(callback);
        runNextFrame();
      }
      callback(latestFrameData);
    }
    const step = {
schedule: (callback, keepAlive = false, immediate = false) => {
        const addToCurrentFrame = immediate && isProcessing;
        const queue = addToCurrentFrame ? thisFrame : nextFrame;
        if (keepAlive)
          toKeepAlive.add(callback);
        if (!queue.has(callback))
          queue.add(callback);
        return callback;
      },
cancel: (callback) => {
        nextFrame.delete(callback);
        toKeepAlive.delete(callback);
      },
process: (frameData2) => {
        latestFrameData = frameData2;
        if (isProcessing) {
          flushNextFrame = true;
          return;
        }
        isProcessing = true;
        [thisFrame, nextFrame] = [nextFrame, thisFrame];
        thisFrame.forEach(triggerCallback);
        thisFrame.clear();
        isProcessing = false;
        if (flushNextFrame) {
          flushNextFrame = false;
          step.process(frameData2);
        }
      }
    };
    return step;
  }
  const maxElapsed = 40;
  function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
    let runNextFrame = false;
    let useDefaultElapsed = true;
    const state2 = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    };
    const flagRunNextFrame = () => runNextFrame = true;
    const steps = stepsOrder.reduce((acc, key) => {
      acc[key] = createRenderStep(flagRunNextFrame);
      return acc;
    }, {});
    const { setup, read, resolveKeyframes, preUpdate, update, preRender, render: render4, postRender } = steps;
    const processBatch = () => {
      const timestamp = MotionGlobalConfig.useManualTiming ? state2.timestamp : performance.now();
      runNextFrame = false;
      if (!MotionGlobalConfig.useManualTiming) {
        state2.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state2.timestamp, maxElapsed), 1);
      }
      state2.timestamp = timestamp;
      state2.isProcessing = true;
      setup.process(state2);
      read.process(state2);
      resolveKeyframes.process(state2);
      preUpdate.process(state2);
      update.process(state2);
      preRender.process(state2);
      render4.process(state2);
      postRender.process(state2);
      state2.isProcessing = false;
      if (runNextFrame && allowKeepAlive) {
        useDefaultElapsed = false;
        scheduleNextBatch(processBatch);
      }
    };
    const wake = () => {
      runNextFrame = true;
      useDefaultElapsed = true;
      if (!state2.isProcessing) {
        scheduleNextBatch(processBatch);
      }
    };
    const schedule = stepsOrder.reduce((acc, key) => {
      const step = steps[key];
      acc[key] = (process2, keepAlive = false, immediate = false) => {
        if (!runNextFrame)
          wake();
        return step.schedule(process2, keepAlive, immediate);
      };
      return acc;
    }, {});
    const cancel = (process2) => {
      for (let i2 = 0; i2 < stepsOrder.length; i2++) {
        steps[stepsOrder[i2]].cancel(process2);
      }
    };
    return { schedule, cancel, state: state2, steps };
  }
  const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop$1, true);
  let now;
  function clearTime() {
    now = void 0;
  }
  const time = {
    now: () => {
      if (now === void 0) {
        time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
      }
      return now;
    },
    set: (newTime) => {
      now = newTime;
      queueMicrotask(clearTime);
    }
  };
  const checkStringStartsWith = (token2) => (key) => typeof key === "string" && key.startsWith(token2);
  const isCSSVariableName = checkStringStartsWith("--");
  const startsAsVariableToken = checkStringStartsWith("var(--");
  const isCSSVariableToken = (value) => {
    const startsWithToken = startsAsVariableToken(value);
    if (!startsWithToken)
      return false;
    return singleCssVariableRegex.test(value.split("/*")[0].trim());
  };
  const singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
  function containsCSSVariable(value) {
    if (typeof value !== "string")
      return false;
    return value.split("/*")[0].includes("var(--");
  }
  const number3 = {
    test: (v) => typeof v === "number",
    parse: parseFloat,
    transform: (v) => v
  };
  const alpha = {
    ...number3,
    transform: (v) => clamp(0, 1, v)
  };
  const scale = {
    ...number3,
    default: 1
  };
  const sanitize = (v) => Math.round(v * 1e5) / 1e5;
  const floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
  function isNullish(v) {
    return v == null;
  }
  const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
  const isColorString = (type4, testProp) => (v) => {
    return Boolean(typeof v === "string" && singleColorRegex.test(v) && v.startsWith(type4) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp));
  };
  const splitColor = (aName, bName, cName) => (v) => {
    if (typeof v !== "string")
      return v;
    const [a2, b, c2, alpha2] = v.match(floatRegex);
    return {
      [aName]: parseFloat(a2),
      [bName]: parseFloat(b),
      [cName]: parseFloat(c2),
      alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
    };
  };
  const clampRgbUnit = (v) => clamp(0, 255, v);
  const rgbUnit = {
    ...number3,
    transform: (v) => Math.round(clampRgbUnit(v))
  };
  const rgba = {
    test: isColorString("rgb", "red"),
    parse: splitColor("red", "green", "blue"),
    transform: ({ red: red2, green: green2, blue: blue2, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red2) + ", " + rgbUnit.transform(green2) + ", " + rgbUnit.transform(blue2) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
  };
  function parseHex(v) {
    let r2 = "";
    let g2 = "";
    let b = "";
    let a2 = "";
    if (v.length > 5) {
      r2 = v.substring(1, 3);
      g2 = v.substring(3, 5);
      b = v.substring(5, 7);
      a2 = v.substring(7, 9);
    } else {
      r2 = v.substring(1, 2);
      g2 = v.substring(2, 3);
      b = v.substring(3, 4);
      a2 = v.substring(4, 5);
      r2 += r2;
      g2 += g2;
      b += b;
      a2 += a2;
    }
    return {
      red: parseInt(r2, 16),
      green: parseInt(g2, 16),
      blue: parseInt(b, 16),
      alpha: a2 ? parseInt(a2, 16) / 255 : 1
    };
  }
  const hex2 = {
    test: isColorString("#"),
    parse: parseHex,
    transform: rgba.transform
  };
  const createUnitType = (unit2) => ({
    test: (v) => typeof v === "string" && v.endsWith(unit2) && v.split(" ").length === 1,
    parse: parseFloat,
    transform: (v) => `${v}${unit2}`
  });
  const degrees = createUnitType("deg");
  const percent = createUnitType("%");
  const px = createUnitType("px");
  const vh = createUnitType("vh");
  const vw = createUnitType("vw");
  const progressPercentage = (() => ({
    ...percent,
    parse: (v) => percent.parse(v) / 100,
    transform: (v) => percent.transform(v * 100)
  }))();
  const hsla = {
    test: isColorString("hsl", "hue"),
    parse: splitColor("hue", "saturation", "lightness"),
    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
      return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
    }
  };
  const color = {
    test: (v) => rgba.test(v) || hex2.test(v) || hsla.test(v),
    parse: (v) => {
      if (rgba.test(v)) {
        return rgba.parse(v);
      } else if (hsla.test(v)) {
        return hsla.parse(v);
      } else {
        return hex2.parse(v);
      }
    },
    transform: (v) => {
      return typeof v === "string" ? v : v.hasOwnProperty("red") ? rgba.transform(v) : hsla.transform(v);
    },
    getAnimatableNone: (v) => {
      const parsed2 = color.parse(v);
      parsed2.alpha = 0;
      return color.transform(parsed2);
    }
  };
  const colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
  function test(v) {
    return isNaN(v) && typeof v === "string" && (v.match(floatRegex)?.length || 0) + (v.match(colorRegex)?.length || 0) > 0;
  }
  const NUMBER_TOKEN = "number";
  const COLOR_TOKEN = "color";
  const VAR_TOKEN = "var";
  const VAR_FUNCTION_TOKEN = "var(";
  const SPLIT_TOKEN = "${}";
  const complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
  function analyseComplexValue(value) {
    const originalValue = value.toString();
    const values = [];
    const indexes = {
      color: [],
      number: [],
      var: []
    };
    const types2 = [];
    let i2 = 0;
    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
      if (color.test(parsedValue)) {
        indexes.color.push(i2);
        types2.push(COLOR_TOKEN);
        values.push(color.parse(parsedValue));
      } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
        indexes.var.push(i2);
        types2.push(VAR_TOKEN);
        values.push(parsedValue);
      } else {
        indexes.number.push(i2);
        types2.push(NUMBER_TOKEN);
        values.push(parseFloat(parsedValue));
      }
      ++i2;
      return SPLIT_TOKEN;
    });
    const split = tokenised.split(SPLIT_TOKEN);
    return { values, split, indexes, types: types2 };
  }
  function parseComplexValue(v) {
    return analyseComplexValue(v).values;
  }
  function createTransformer(source) {
    const { split, types: types2 } = analyseComplexValue(source);
    const numSections = split.length;
    return (v) => {
      let output = "";
      for (let i2 = 0; i2 < numSections; i2++) {
        output += split[i2];
        if (v[i2] !== void 0) {
          const type4 = types2[i2];
          if (type4 === NUMBER_TOKEN) {
            output += sanitize(v[i2]);
          } else if (type4 === COLOR_TOKEN) {
            output += color.transform(v[i2]);
          } else {
            output += v[i2];
          }
        }
      }
      return output;
    };
  }
  const convertNumbersToZero = (v) => typeof v === "number" ? 0 : color.test(v) ? color.getAnimatableNone(v) : v;
  function getAnimatableNone$1(v) {
    const parsed2 = parseComplexValue(v);
    const transformer = createTransformer(v);
    return transformer(parsed2.map(convertNumbersToZero));
  }
  const complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone: getAnimatableNone$1
  };
  function hueToRgb(p2, q, t2) {
    if (t2 < 0)
      t2 += 1;
    if (t2 > 1)
      t2 -= 1;
    if (t2 < 1 / 6)
      return p2 + (q - p2) * 6 * t2;
    if (t2 < 1 / 2)
      return q;
    if (t2 < 2 / 3)
      return p2 + (q - p2) * (2 / 3 - t2) * 6;
    return p2;
  }
  function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
    hue /= 360;
    saturation /= 100;
    lightness /= 100;
    let red2 = 0;
    let green2 = 0;
    let blue2 = 0;
    if (!saturation) {
      red2 = green2 = blue2 = lightness;
    } else {
      const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
      const p2 = 2 * lightness - q;
      red2 = hueToRgb(p2, q, hue + 1 / 3);
      green2 = hueToRgb(p2, q, hue);
      blue2 = hueToRgb(p2, q, hue - 1 / 3);
    }
    return {
      red: Math.round(red2 * 255),
      green: Math.round(green2 * 255),
      blue: Math.round(blue2 * 255),
      alpha: alpha2
    };
  }
  function mixImmediate(a2, b) {
    return (p2) => p2 > 0 ? b : a2;
  }
  const mixNumber$1 = (from2, to, progress2) => {
    return from2 + (to - from2) * progress2;
  };
  const mixLinearColor = (from2, to, v) => {
    const fromExpo = from2 * from2;
    const expo = v * (to * to - fromExpo) + fromExpo;
    return expo < 0 ? 0 : Math.sqrt(expo);
  };
  const colorTypes = [hex2, rgba, hsla];
  const getColorType = (v) => colorTypes.find((type4) => type4.test(v));
  function asRGBA(color2) {
    const type4 = getColorType(color2);
    if (!Boolean(type4))
      return false;
    let model = type4.parse(color2);
    if (type4 === hsla) {
      model = hslaToRgba(model);
    }
    return model;
  }
  const mixColor = (from2, to) => {
    const fromRGBA = asRGBA(from2);
    const toRGBA = asRGBA(to);
    if (!fromRGBA || !toRGBA) {
      return mixImmediate(from2, to);
    }
    const blended = { ...fromRGBA };
    return (v) => {
      blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
      blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
      blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
      blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);
      return rgba.transform(blended);
    };
  };
  const invisibleValues = new Set(["none", "hidden"]);
  function mixVisibility(origin, target) {
    if (invisibleValues.has(origin)) {
      return (p2) => p2 <= 0 ? origin : target;
    } else {
      return (p2) => p2 >= 1 ? target : origin;
    }
  }
  function mixNumber(a2, b) {
    return (p2) => mixNumber$1(a2, b, p2);
  }
  function getMixer(a2) {
    if (typeof a2 === "number") {
      return mixNumber;
    } else if (typeof a2 === "string") {
      return isCSSVariableToken(a2) ? mixImmediate : color.test(a2) ? mixColor : mixComplex;
    } else if (Array.isArray(a2)) {
      return mixArray;
    } else if (typeof a2 === "object") {
      return color.test(a2) ? mixColor : mixObject;
    }
    return mixImmediate;
  }
  function mixArray(a2, b) {
    const output = [...a2];
    const numValues = output.length;
    const blendValue = a2.map((v, i2) => getMixer(v)(v, b[i2]));
    return (p2) => {
      for (let i2 = 0; i2 < numValues; i2++) {
        output[i2] = blendValue[i2](p2);
      }
      return output;
    };
  }
  function mixObject(a2, b) {
    const output = { ...a2, ...b };
    const blendValue = {};
    for (const key in output) {
      if (a2[key] !== void 0 && b[key] !== void 0) {
        blendValue[key] = getMixer(a2[key])(a2[key], b[key]);
      }
    }
    return (v) => {
      for (const key in blendValue) {
        output[key] = blendValue[key](v);
      }
      return output;
    };
  }
  function matchOrder(origin, target) {
    const orderedOrigin = [];
    const pointers = { color: 0, var: 0, number: 0 };
    for (let i2 = 0; i2 < target.values.length; i2++) {
      const type4 = target.types[i2];
      const originIndex = origin.indexes[type4][pointers[type4]];
      const originValue = origin.values[originIndex] ?? 0;
      orderedOrigin[i2] = originValue;
      pointers[type4]++;
    }
    return orderedOrigin;
  }
  const mixComplex = (origin, target) => {
    const template = complex.createTransformer(target);
    const originStats = analyseComplexValue(origin);
    const targetStats = analyseComplexValue(target);
    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
    if (canInterpolate) {
      if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
        return mixVisibility(origin, target);
      }
      return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
    } else {
      return mixImmediate(origin, target);
    }
  };
  function mix(from2, to, p2) {
    if (typeof from2 === "number" && typeof to === "number" && typeof p2 === "number") {
      return mixNumber$1(from2, to, p2);
    }
    const mixer = getMixer(from2);
    return mixer(from2, to);
  }
  const frameloopDriver = (update) => {
    const passTimestamp = ({ timestamp }) => update(timestamp);
    return {
      start: (keepAlive = true) => frame.update(passTimestamp, keepAlive),
      stop: () => cancelFrame(passTimestamp),
now: () => frameData.isProcessing ? frameData.timestamp : time.now()
    };
  };
  const generateLinearEasing = (easing, duration2, resolution = 10) => {
    let points = "";
    const numPoints = Math.max(Math.round(duration2 / resolution), 2);
    for (let i2 = 0; i2 < numPoints; i2++) {
      points += Math.round(easing(i2 / (numPoints - 1)) * 1e4) / 1e4 + ", ";
    }
    return `linear(${points.substring(0, points.length - 2)})`;
  };
  const maxGeneratorDuration = 2e4;
  function calcGeneratorDuration(generator) {
    let duration2 = 0;
    const timeStep = 50;
    let state2 = generator.next(duration2);
    while (!state2.done && duration2 < maxGeneratorDuration) {
      duration2 += timeStep;
      state2 = generator.next(duration2);
    }
    return duration2 >= maxGeneratorDuration ? Infinity : duration2;
  }
  function createGeneratorEasing(options, scale2 = 100, createGenerator) {
    const generator = createGenerator({ ...options, keyframes: [0, scale2] });
    const duration2 = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
    return {
      type: "keyframes",
      ease: (progress2) => {
        return generator.next(duration2 * progress2).value / scale2;
      },
      duration: millisecondsToSeconds(duration2)
    };
  }
  const velocitySampleDuration = 5;
  function calcGeneratorVelocity(resolveValue, t2, current) {
    const prevT = Math.max(t2 - velocitySampleDuration, 0);
    return velocityPerSecond(current - resolveValue(prevT), t2 - prevT);
  }
  const springDefaults = {
stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
duration: 800,
bounce: 0.3,
    visualDuration: 0.3,

restSpeed: {
      granular: 0.01,
      default: 2
    },
    restDelta: {
      granular: 5e-3,
      default: 0.5
    },
minDuration: 0.01,
maxDuration: 10,
minDamping: 0.05,
    maxDamping: 1
  };
  const safeMin = 1e-3;
  function findSpring({ duration: duration2 = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
    let envelope;
    let derivative2;
    let dampingRatio = 1 - bounce;
    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
    duration2 = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration2));
    if (dampingRatio < 1) {
      envelope = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration2;
        const a2 = exponentialDecay - velocity;
        const b = calcAngularFreq(undampedFreq2, dampingRatio);
        const c2 = Math.exp(-delta);
        return safeMin - a2 / b * c2;
      };
      derivative2 = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration2;
        const d2 = delta * velocity + velocity;
        const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration2;
        const f2 = Math.exp(-delta);
        const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
        const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
        return factor * ((d2 - e) * f2) / g2;
      };
    } else {
      envelope = (undampedFreq2) => {
        const a2 = Math.exp(-undampedFreq2 * duration2);
        const b = (undampedFreq2 - velocity) * duration2 + 1;
        return -safeMin + a2 * b;
      };
      derivative2 = (undampedFreq2) => {
        const a2 = Math.exp(-undampedFreq2 * duration2);
        const b = (velocity - undampedFreq2) * (duration2 * duration2);
        return a2 * b;
      };
    }
    const initialGuess = 5 / duration2;
    const undampedFreq = approximateRoot(envelope, derivative2, initialGuess);
    duration2 = secondsToMilliseconds(duration2);
    if (isNaN(undampedFreq)) {
      return {
        stiffness: springDefaults.stiffness,
        damping: springDefaults.damping,
        duration: duration2
      };
    } else {
      const stiffness = Math.pow(undampedFreq, 2) * mass;
      return {
        stiffness,
        damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
        duration: duration2
      };
    }
  }
  const rootIterations = 12;
  function approximateRoot(envelope, derivative2, initialGuess) {
    let result = initialGuess;
    for (let i2 = 1; i2 < rootIterations; i2++) {
      result = result - envelope(result) / derivative2(result);
    }
    return result;
  }
  function calcAngularFreq(undampedFreq, dampingRatio) {
    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
  }
  const durationKeys = ["duration", "bounce"];
  const physicsKeys = ["stiffness", "damping", "mass"];
  function isSpringType(options, keys2) {
    return keys2.some((key) => options[key] !== void 0);
  }
  function getSpringOptions(options) {
    let springOptions = {
      velocity: springDefaults.velocity,
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      mass: springDefaults.mass,
      isResolvedFromDuration: false,
      ...options
    };
    if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
      springOptions.velocity = 0;
      if (options.visualDuration) {
        const visualDuration = options.visualDuration;
        const root2 = 2 * Math.PI / (visualDuration * 1.2);
        const stiffness = root2 * root2;
        const damping = 2 * clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
        springOptions = {
          ...springOptions,
          mass: springDefaults.mass,
          stiffness,
          damping
        };
      } else {
        const derived = findSpring({ ...options, velocity: 0 });
        springOptions = {
          ...springOptions,
          ...derived,
          mass: springDefaults.mass
        };
        springOptions.isResolvedFromDuration = true;
      }
    }
    return springOptions;
  }
  function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
    const options = typeof optionsOrVisualDuration !== "object" ? {
      visualDuration: optionsOrVisualDuration,
      keyframes: [0, 1],
      bounce
    } : optionsOrVisualDuration;
    let { restSpeed, restDelta } = options;
    const origin = options.keyframes[0];
    const target = options.keyframes[options.keyframes.length - 1];
    const state2 = { done: false, value: origin };
    const { stiffness, damping, mass, duration: duration2, velocity, isResolvedFromDuration } = getSpringOptions({
      ...options,
      velocity: - millisecondsToSeconds(options.velocity || 0)
    });
    const initialVelocity = velocity || 0;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const initialDelta = target - origin;
    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
    const isGranularScale = Math.abs(initialDelta) < 5;
    restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
    restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
    let resolveSpring;
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        const freqForT = Math.min(dampedAngularFreq * t2, 300);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
    const generator = {
      calculatedDuration: isResolvedFromDuration ? duration2 || null : null,
      next: (t2) => {
        const current = resolveSpring(t2);
        if (!isResolvedFromDuration) {
          let currentVelocity = t2 === 0 ? initialVelocity : 0;
          if (dampingRatio < 1) {
            currentVelocity = t2 === 0 ? secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t2, current);
          }
          const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
          const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
          state2.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
        } else {
          state2.done = t2 >= duration2;
        }
        state2.value = state2.done ? target : current;
        return state2;
      },
      toString: () => {
        const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
        const easing = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
        return calculatedDuration + "ms " + easing;
      },
      toTransition: () => {
      }
    };
    return generator;
  }
  spring.applyToOptions = (options) => {
    const generatorOptions = createGeneratorEasing(options, 100, spring);
    options.ease = generatorOptions.ease;
    options.duration = secondsToMilliseconds(generatorOptions.duration);
    options.type = "keyframes";
    return options;
  };
  function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed }) {
    const origin = keyframes2[0];
    const state2 = {
      done: false,
      value: origin
    };
    const isOutOfBounds = (v) => min !== void 0 && v < min || max !== void 0 && v > max;
    const nearestBoundary = (v) => {
      if (min === void 0)
        return max;
      if (max === void 0)
        return min;
      return Math.abs(min - v) < Math.abs(max - v) ? min : max;
    };
    let amplitude = power * velocity;
    const ideal = origin + amplitude;
    const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
    if (target !== ideal)
      amplitude = target - origin;
    const calcDelta = (t2) => -amplitude * Math.exp(-t2 / timeConstant);
    const calcLatest = (t2) => target + calcDelta(t2);
    const applyFriction = (t2) => {
      const delta = calcDelta(t2);
      const latest = calcLatest(t2);
      state2.done = Math.abs(delta) <= restDelta;
      state2.value = state2.done ? target : latest;
    };
    let timeReachedBoundary;
    let spring$1;
    const checkCatchBoundary = (t2) => {
      if (!isOutOfBounds(state2.value))
        return;
      timeReachedBoundary = t2;
      spring$1 = spring({
        keyframes: [state2.value, nearestBoundary(state2.value)],
        velocity: calcGeneratorVelocity(calcLatest, t2, state2.value),
damping: bounceDamping,
        stiffness: bounceStiffness,
        restDelta,
        restSpeed
      });
    };
    checkCatchBoundary(0);
    return {
      calculatedDuration: null,
      next: (t2) => {
        let hasUpdatedFrame = false;
        if (!spring$1 && timeReachedBoundary === void 0) {
          hasUpdatedFrame = true;
          applyFriction(t2);
          checkCatchBoundary(t2);
        }
        if (timeReachedBoundary !== void 0 && t2 >= timeReachedBoundary) {
          return spring$1.next(t2 - timeReachedBoundary);
        } else {
          !hasUpdatedFrame && applyFriction(t2);
          return state2;
        }
      }
    };
  }
  function createMixers(output, ease2, customMixer) {
    const mixers = [];
    const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;
    const numMixers = output.length - 1;
    for (let i2 = 0; i2 < numMixers; i2++) {
      let mixer = mixerFactory(output[i2], output[i2 + 1]);
      if (ease2) {
        const easingFunction = Array.isArray(ease2) ? ease2[i2] || noop$1 : ease2;
        mixer = pipe(easingFunction, mixer);
      }
      mixers.push(mixer);
    }
    return mixers;
  }
  function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
    const inputLength = input.length;
    invariant(inputLength === output.length);
    if (inputLength === 1)
      return () => output[0];
    if (inputLength === 2 && output[0] === output[1])
      return () => output[1];
    const isZeroDeltaRange = input[0] === input[1];
    if (input[0] > input[inputLength - 1]) {
      input = [...input].reverse();
      output = [...output].reverse();
    }
    const mixers = createMixers(output, ease2, mixer);
    const numMixers = mixers.length;
    const interpolator = (v) => {
      if (isZeroDeltaRange && v < input[0])
        return output[0];
      let i2 = 0;
      if (numMixers > 1) {
        for (; i2 < input.length - 2; i2++) {
          if (v < input[i2 + 1])
            break;
        }
      }
      const progressInRange = progress(input[i2], input[i2 + 1], v);
      return mixers[i2](progressInRange);
    };
    return isClamp ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;
  }
  function fillOffset(offset2, remaining) {
    const min = offset2[offset2.length - 1];
    for (let i2 = 1; i2 <= remaining; i2++) {
      const offsetProgress = progress(0, remaining, i2);
      offset2.push(mixNumber$1(min, 1, offsetProgress));
    }
  }
  function defaultOffset(arr) {
    const offset2 = [0];
    fillOffset(offset2, arr.length - 1);
    return offset2;
  }
  function convertOffsetToTimes(offset2, duration2) {
    return offset2.map((o2) => o2 * duration2);
  }
  function defaultEasing(values, easing) {
    return values.map(() => easing || easeInOut).splice(0, values.length - 1);
  }
  function keyframes({ duration: duration2 = 300, keyframes: keyframeValues, times: times2, ease: ease2 = "easeInOut" }) {
    const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
    const state2 = {
      done: false,
      value: keyframeValues[0]
    };
    const absoluteTimes = convertOffsetToTimes(

times2 && times2.length === keyframeValues.length ? times2 : defaultOffset(keyframeValues),
      duration2
    );
    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
      ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
    });
    return {
      calculatedDuration: duration2,
      next: (t2) => {
        state2.value = mapTimeToKeyframe(t2);
        state2.done = t2 >= duration2;
        return state2;
      }
    };
  }
  const isNotNull$1 = (value) => value !== null;
  function getFinalKeyframe$1(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe, speed = 1) {
    const resolvedKeyframes = keyframes2.filter(isNotNull$1);
    const useFirstKeyframe = speed < 0 || repeat && repeatType !== "loop" && repeat % 2 === 1;
    const index = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;
    return !index || finalKeyframe === void 0 ? resolvedKeyframes[index] : finalKeyframe;
  }
  const transitionTypeMap = {
    decay: inertia,
    inertia,
    tween: keyframes,
    keyframes,
    spring
  };
  function replaceTransitionType(transition) {
    if (typeof transition.type === "string") {
      transition.type = transitionTypeMap[transition.type];
    }
  }
  class WithPromise {
    constructor() {
      this.updateFinished();
    }
    get finished() {
      return this._finished;
    }
    updateFinished() {
      this._finished = new Promise((resolve) => {
        this.resolve = resolve;
      });
    }
    notifyFinished() {
      this.resolve();
    }
then(onResolve, onReject) {
      return this.finished.then(onResolve, onReject);
    }
  }
  const percentToProgress = (percent2) => percent2 / 100;
  class JSAnimation extends WithPromise {
    constructor(options) {
      super();
      this.state = "idle";
      this.startTime = null;
      this.isStopped = false;
      this.currentTime = 0;
      this.holdTime = null;
      this.playbackSpeed = 1;
      this.stop = () => {
        const { motionValue: motionValue2 } = this.options;
        if (motionValue2 && motionValue2.updatedAt !== time.now()) {
          this.tick(time.now());
        }
        this.isStopped = true;
        if (this.state === "idle")
          return;
        this.teardown();
        this.options.onStop?.();
      };
      this.options = options;
      this.initAnimation();
      this.play();
      if (options.autoplay === false)
        this.pause();
    }
    initAnimation() {
      const { options } = this;
      replaceTransitionType(options);
      const { type: type4 = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = options;
      let { keyframes: keyframes$1 } = options;
      const generatorFactory = type4 || keyframes;
      if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
        this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
        keyframes$1 = [0, 100];
      }
      const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
      if (repeatType === "mirror") {
        this.mirroredGenerator = generatorFactory({
          ...options,
          keyframes: [...keyframes$1].reverse(),
          velocity: -velocity
        });
      }
      if (generator.calculatedDuration === null) {
        generator.calculatedDuration = calcGeneratorDuration(generator);
      }
      const { calculatedDuration } = generator;
      this.calculatedDuration = calculatedDuration;
      this.resolvedDuration = calculatedDuration + repeatDelay;
      this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;
      this.generator = generator;
    }
    updateTime(timestamp) {
      const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;
      if (this.holdTime !== null) {
        this.currentTime = this.holdTime;
      } else {
        this.currentTime = animationTime;
      }
    }
    tick(timestamp, sample = false) {
      const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration } = this;
      if (this.startTime === null)
        return generator.next(0);
      const { delay: delay2 = 0, keyframes: keyframes2, repeat, repeatType, repeatDelay, type: type4, onUpdate, finalKeyframe } = this.options;
      if (this.speed > 0) {
        this.startTime = Math.min(this.startTime, timestamp);
      } else if (this.speed < 0) {
        this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
      }
      if (sample) {
        this.currentTime = timestamp;
      } else {
        this.updateTime(timestamp);
      }
      const timeWithoutDelay = this.currentTime - delay2 * (this.playbackSpeed >= 0 ? 1 : -1);
      const isInDelayPhase = this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
      this.currentTime = Math.max(timeWithoutDelay, 0);
      if (this.state === "finished" && this.holdTime === null) {
        this.currentTime = totalDuration;
      }
      let elapsed = this.currentTime;
      let frameGenerator = generator;
      if (repeat) {
        const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
        let currentIteration = Math.floor(progress2);
        let iterationProgress = progress2 % 1;
        if (!iterationProgress && progress2 >= 1) {
          iterationProgress = 1;
        }
        iterationProgress === 1 && currentIteration--;
        currentIteration = Math.min(currentIteration, repeat + 1);
        const isOddIteration = Boolean(currentIteration % 2);
        if (isOddIteration) {
          if (repeatType === "reverse") {
            iterationProgress = 1 - iterationProgress;
            if (repeatDelay) {
              iterationProgress -= repeatDelay / resolvedDuration;
            }
          } else if (repeatType === "mirror") {
            frameGenerator = mirroredGenerator;
          }
        }
        elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
      }
      const state2 = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);
      if (mixKeyframes) {
        state2.value = mixKeyframes(state2.value);
      }
      let { done } = state2;
      if (!isInDelayPhase && calculatedDuration !== null) {
        done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
      }
      const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
      if (isAnimationFinished && type4 !== inertia) {
        state2.value = getFinalKeyframe$1(keyframes2, this.options, finalKeyframe, this.speed);
      }
      if (onUpdate) {
        onUpdate(state2.value);
      }
      if (isAnimationFinished) {
        this.finish();
      }
      return state2;
    }
then(resolve, reject) {
      return this.finished.then(resolve, reject);
    }
    get duration() {
      return millisecondsToSeconds(this.calculatedDuration);
    }
    get iterationDuration() {
      const { delay: delay2 = 0 } = this.options || {};
      return this.duration + millisecondsToSeconds(delay2);
    }
    get time() {
      return millisecondsToSeconds(this.currentTime);
    }
    set time(newTime) {
      newTime = secondsToMilliseconds(newTime);
      this.currentTime = newTime;
      if (this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0) {
        this.holdTime = newTime;
      } else if (this.driver) {
        this.startTime = this.driver.now() - newTime / this.playbackSpeed;
      }
      this.driver?.start(false);
    }
    get speed() {
      return this.playbackSpeed;
    }
    set speed(newSpeed) {
      this.updateTime(time.now());
      const hasChanged = this.playbackSpeed !== newSpeed;
      this.playbackSpeed = newSpeed;
      if (hasChanged) {
        this.time = millisecondsToSeconds(this.currentTime);
      }
    }
    play() {
      if (this.isStopped)
        return;
      const { driver = frameloopDriver, startTime } = this.options;
      if (!this.driver) {
        this.driver = driver((timestamp) => this.tick(timestamp));
      }
      this.options.onPlay?.();
      const now2 = this.driver.now();
      if (this.state === "finished") {
        this.updateFinished();
        this.startTime = now2;
      } else if (this.holdTime !== null) {
        this.startTime = now2 - this.holdTime;
      } else if (!this.startTime) {
        this.startTime = startTime ?? now2;
      }
      if (this.state === "finished" && this.speed < 0) {
        this.startTime += this.calculatedDuration;
      }
      this.holdTime = null;
      this.state = "running";
      this.driver.start();
    }
    pause() {
      this.state = "paused";
      this.updateTime(time.now());
      this.holdTime = this.currentTime;
    }
    complete() {
      if (this.state !== "running") {
        this.play();
      }
      this.state = "finished";
      this.holdTime = null;
    }
    finish() {
      this.notifyFinished();
      this.teardown();
      this.state = "finished";
      this.options.onComplete?.();
    }
    cancel() {
      this.holdTime = null;
      this.startTime = 0;
      this.tick(0);
      this.teardown();
      this.options.onCancel?.();
    }
    teardown() {
      this.state = "idle";
      this.stopDriver();
      this.startTime = this.holdTime = null;
    }
    stopDriver() {
      if (!this.driver)
        return;
      this.driver.stop();
      this.driver = void 0;
    }
    sample(sampleTime) {
      this.startTime = 0;
      return this.tick(sampleTime, true);
    }
    attachTimeline(timeline) {
      if (this.options.allowFlatten) {
        this.options.type = "keyframes";
        this.options.ease = "linear";
        this.initAnimation();
      }
      this.driver?.stop();
      return timeline.observe(this);
    }
  }
  function fillWildcards(keyframes2) {
    for (let i2 = 1; i2 < keyframes2.length; i2++) {
      keyframes2[i2] ?? (keyframes2[i2] = keyframes2[i2 - 1]);
    }
  }
  const radToDeg = (rad) => rad * 180 / Math.PI;
  const rotate = (v) => {
    const angle = radToDeg(Math.atan2(v[1], v[0]));
    return rebaseAngle(angle);
  };
  const matrix2dParsers = {
    x: 4,
    y: 5,
    translateX: 4,
    translateY: 5,
    scaleX: 0,
    scaleY: 3,
    scale: (v) => (Math.abs(v[0]) + Math.abs(v[3])) / 2,
    rotate,
    rotateZ: rotate,
    skewX: (v) => radToDeg(Math.atan(v[1])),
    skewY: (v) => radToDeg(Math.atan(v[2])),
    skew: (v) => (Math.abs(v[1]) + Math.abs(v[2])) / 2
  };
  const rebaseAngle = (angle) => {
    angle = angle % 360;
    if (angle < 0)
      angle += 360;
    return angle;
  };
  const rotateZ = rotate;
  const scaleX = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  const scaleY = (v) => Math.sqrt(v[4] * v[4] + v[5] * v[5]);
  const matrix3dParsers = {
    x: 12,
    y: 13,
    z: 14,
    translateX: 12,
    translateY: 13,
    translateZ: 14,
    scaleX,
    scaleY,
    scale: (v) => (scaleX(v) + scaleY(v)) / 2,
    rotateX: (v) => rebaseAngle(radToDeg(Math.atan2(v[6], v[5]))),
    rotateY: (v) => rebaseAngle(radToDeg(Math.atan2(-v[2], v[0]))),
    rotateZ,
    rotate: rotateZ,
    skewX: (v) => radToDeg(Math.atan(v[4])),
    skewY: (v) => radToDeg(Math.atan(v[1])),
    skew: (v) => (Math.abs(v[1]) + Math.abs(v[4])) / 2
  };
  function defaultTransformValue(name) {
    return name.includes("scale") ? 1 : 0;
  }
  function parseValueFromTransform(transform, name) {
    if (!transform || transform === "none") {
      return defaultTransformValue(name);
    }
    const matrix3dMatch = transform.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
    let parsers;
    let match2;
    if (matrix3dMatch) {
      parsers = matrix3dParsers;
      match2 = matrix3dMatch;
    } else {
      const matrix2dMatch = transform.match(/^matrix\(([-\d.e\s,]+)\)$/u);
      parsers = matrix2dParsers;
      match2 = matrix2dMatch;
    }
    if (!match2) {
      return defaultTransformValue(name);
    }
    const valueParser = parsers[name];
    const values = match2[1].split(",").map(convertTransformToNumber);
    return typeof valueParser === "function" ? valueParser(values) : values[valueParser];
  }
  const readTransformValue = (instance, name) => {
    const { transform = "none" } = getComputedStyle(instance);
    return parseValueFromTransform(transform, name);
  };
  function convertTransformToNumber(value) {
    return parseFloat(value.trim());
  }
  const transformPropOrder = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY"
  ];
  const transformProps = (() => new Set(transformPropOrder))();
  const isNumOrPxType = (v) => v === number3 || v === px;
  const transformKeys = new Set(["x", "y", "z"]);
  const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
  function removeNonTranslationalTransform(visualElement) {
    const removedTransforms = [];
    nonTranslationalTransformKeys.forEach((key) => {
      const value = visualElement.getValue(key);
      if (value !== void 0) {
        removedTransforms.push([key, value.get()]);
        value.set(key.startsWith("scale") ? 1 : 0);
      }
    });
    return removedTransforms;
  }
  const positionalValues = {
width: ({ x }, { paddingLeft = "0", paddingRight = "0" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
    height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
    top: (_bbox, { top }) => parseFloat(top),
    left: (_bbox, { left }) => parseFloat(left),
    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),
    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),
x: (_bbox, { transform }) => parseValueFromTransform(transform, "x"),
    y: (_bbox, { transform }) => parseValueFromTransform(transform, "y")
  };
  positionalValues.translateX = positionalValues.x;
  positionalValues.translateY = positionalValues.y;
  const toResolve = new Set();
  let isScheduled = false;
  let anyNeedsMeasurement = false;
  let isForced = false;
  function measureAllKeyframes() {
    if (anyNeedsMeasurement) {
      const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
      const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
      const transformsToRestore = new Map();
      elementsToMeasure.forEach((element) => {
        const removedTransforms = removeNonTranslationalTransform(element);
        if (!removedTransforms.length)
          return;
        transformsToRestore.set(element, removedTransforms);
        element.render();
      });
      resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
      elementsToMeasure.forEach((element) => {
        element.render();
        const restore = transformsToRestore.get(element);
        if (restore) {
          restore.forEach(([key, value]) => {
            element.getValue(key)?.set(value);
          });
        }
      });
      resolversToMeasure.forEach((resolver) => resolver.measureEndState());
      resolversToMeasure.forEach((resolver) => {
        if (resolver.suspendedScrollY !== void 0) {
          window.scrollTo(0, resolver.suspendedScrollY);
        }
      });
    }
    anyNeedsMeasurement = false;
    isScheduled = false;
    toResolve.forEach((resolver) => resolver.complete(isForced));
    toResolve.clear();
  }
  function readAllKeyframes() {
    toResolve.forEach((resolver) => {
      resolver.readKeyframes();
      if (resolver.needsMeasurement) {
        anyNeedsMeasurement = true;
      }
    });
  }
  function flushKeyframeResolvers() {
    isForced = true;
    readAllKeyframes();
    measureAllKeyframes();
    isForced = false;
  }
  class KeyframeResolver {
    constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = false) {
      this.state = "pending";
      this.isAsync = false;
      this.needsMeasurement = false;
      this.unresolvedKeyframes = [...unresolvedKeyframes];
      this.onComplete = onComplete;
      this.name = name;
      this.motionValue = motionValue2;
      this.element = element;
      this.isAsync = isAsync;
    }
    scheduleResolve() {
      this.state = "scheduled";
      if (this.isAsync) {
        toResolve.add(this);
        if (!isScheduled) {
          isScheduled = true;
          frame.read(readAllKeyframes);
          frame.resolveKeyframes(measureAllKeyframes);
        }
      } else {
        this.readKeyframes();
        this.complete();
      }
    }
    readKeyframes() {
      const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
      if (unresolvedKeyframes[0] === null) {
        const currentValue = motionValue2?.get();
        const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
        if (currentValue !== void 0) {
          unresolvedKeyframes[0] = currentValue;
        } else if (element && name) {
          const valueAsRead = element.readValue(name, finalKeyframe);
          if (valueAsRead !== void 0 && valueAsRead !== null) {
            unresolvedKeyframes[0] = valueAsRead;
          }
        }
        if (unresolvedKeyframes[0] === void 0) {
          unresolvedKeyframes[0] = finalKeyframe;
        }
        if (motionValue2 && currentValue === void 0) {
          motionValue2.set(unresolvedKeyframes[0]);
        }
      }
      fillWildcards(unresolvedKeyframes);
    }
    setFinalKeyframe() {
    }
    measureInitialState() {
    }
    renderEndStyles() {
    }
    measureEndState() {
    }
    complete(isForcedComplete = false) {
      this.state = "complete";
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);
      toResolve.delete(this);
    }
    cancel() {
      if (this.state === "scheduled") {
        toResolve.delete(this);
        this.state = "pending";
      }
    }
    resume() {
      if (this.state === "pending")
        this.scheduleResolve();
    }
  }
  const isCSSVar = (name) => name.startsWith("--");
  function setStyle(element, name, value) {
    isCSSVar(name) ? element.style.setProperty(name, value) : element.style[name] = value;
  }
  const supportsFlags = {};
  function memoSupports(callback, supportsFlag) {
    const memoized = memo(callback);
    return () => supportsFlags[supportsFlag] ?? memoized();
  }
  const supportsScrollTimeline = memoSupports(() => window.ScrollTimeline !== void 0, "scrollTimeline");
  const supportsLinearEasing = memoSupports(() => {
    try {
      document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
    } catch (e) {
      return false;
    }
    return true;
  }, "linearEasing");
  const cubicBezierAsString = ([a2, b, c2, d2]) => `cubic-bezier(${a2}, ${b}, ${c2}, ${d2})`;
  const supportedWaapiEasing = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
    circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
    backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
    backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
  };
  function mapEasingToNativeEasing(easing, duration2) {
    if (!easing) {
      return void 0;
    } else if (typeof easing === "function") {
      return supportsLinearEasing() ? generateLinearEasing(easing, duration2) : "ease-out";
    } else if (isBezierDefinition(easing)) {
      return cubicBezierAsString(easing);
    } else if (Array.isArray(easing)) {
      return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration2) || supportedWaapiEasing.easeOut);
    } else {
      return supportedWaapiEasing[easing];
    }
  }
  function startWaapiAnimation(element, valueName, keyframes2, { delay: delay2 = 0, duration: duration2 = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeOut", times: times2 } = {}, pseudoElement = void 0) {
    const keyframeOptions = {
      [valueName]: keyframes2
    };
    if (times2)
      keyframeOptions.offset = times2;
    const easing = mapEasingToNativeEasing(ease2, duration2);
    if (Array.isArray(easing))
      keyframeOptions.easing = easing;
    const options = {
      delay: delay2,
      duration: duration2,
      easing: !Array.isArray(easing) ? easing : "linear",
      fill: "both",
      iterations: repeat + 1,
      direction: repeatType === "reverse" ? "alternate" : "normal"
    };
    if (pseudoElement)
      options.pseudoElement = pseudoElement;
    const animation = element.animate(keyframeOptions, options);
    return animation;
  }
  function isGenerator(type4) {
    return typeof type4 === "function" && "applyToOptions" in type4;
  }
  function applyGeneratorOptions({ type: type4, ...options }) {
    if (isGenerator(type4) && supportsLinearEasing()) {
      return type4.applyToOptions(options);
    } else {
      options.duration ?? (options.duration = 300);
      options.ease ?? (options.ease = "easeOut");
    }
    return options;
  }
  class NativeAnimation extends WithPromise {
    constructor(options) {
      super();
      this.finishedTime = null;
      this.isStopped = false;
      this.manualStartTime = null;
      if (!options)
        return;
      const { element, name, keyframes: keyframes2, pseudoElement, allowFlatten = false, finalKeyframe, onComplete } = options;
      this.isPseudoElement = Boolean(pseudoElement);
      this.allowFlatten = allowFlatten;
      this.options = options;
      invariant(typeof options.type !== "string");
      const transition = applyGeneratorOptions(options);
      this.animation = startWaapiAnimation(element, name, keyframes2, transition, pseudoElement);
      if (transition.autoplay === false) {
        this.animation.pause();
      }
      this.animation.onfinish = () => {
        this.finishedTime = this.time;
        if (!pseudoElement) {
          const keyframe = getFinalKeyframe$1(keyframes2, this.options, finalKeyframe, this.speed);
          if (this.updateMotionValue) {
            this.updateMotionValue(keyframe);
          } else {
            setStyle(element, name, keyframe);
          }
          this.animation.cancel();
        }
        onComplete?.();
        this.notifyFinished();
      };
    }
    play() {
      if (this.isStopped)
        return;
      this.manualStartTime = null;
      this.animation.play();
      if (this.state === "finished") {
        this.updateFinished();
      }
    }
    pause() {
      this.animation.pause();
    }
    complete() {
      this.animation.finish?.();
    }
    cancel() {
      try {
        this.animation.cancel();
      } catch (e) {
      }
    }
    stop() {
      if (this.isStopped)
        return;
      this.isStopped = true;
      const { state: state2 } = this;
      if (state2 === "idle" || state2 === "finished") {
        return;
      }
      if (this.updateMotionValue) {
        this.updateMotionValue();
      } else {
        this.commitStyles();
      }
      if (!this.isPseudoElement)
        this.cancel();
    }
commitStyles() {
      const element = this.options?.element;
      if (!this.isPseudoElement && element?.isConnected) {
        this.animation.commitStyles?.();
      }
    }
    get duration() {
      const duration2 = this.animation.effect?.getComputedTiming?.().duration || 0;
      return millisecondsToSeconds(Number(duration2));
    }
    get iterationDuration() {
      const { delay: delay2 = 0 } = this.options || {};
      return this.duration + millisecondsToSeconds(delay2);
    }
    get time() {
      return millisecondsToSeconds(Number(this.animation.currentTime) || 0);
    }
    set time(newTime) {
      this.manualStartTime = null;
      this.finishedTime = null;
      this.animation.currentTime = secondsToMilliseconds(newTime);
    }
get speed() {
      return this.animation.playbackRate;
    }
    set speed(newSpeed) {
      if (newSpeed < 0)
        this.finishedTime = null;
      this.animation.playbackRate = newSpeed;
    }
    get state() {
      return this.finishedTime !== null ? "finished" : this.animation.playState;
    }
    get startTime() {
      return this.manualStartTime ?? Number(this.animation.startTime);
    }
    set startTime(newStartTime) {
      this.manualStartTime = this.animation.startTime = newStartTime;
    }
attachTimeline({ timeline, observe: observe2 }) {
      if (this.allowFlatten) {
        this.animation.effect?.updateTiming({ easing: "linear" });
      }
      this.animation.onfinish = null;
      if (timeline && supportsScrollTimeline()) {
        this.animation.timeline = timeline;
        return noop$1;
      } else {
        return observe2(this);
      }
    }
  }
  const unsupportedEasingFunctions = {
    anticipate,
    backInOut,
    circInOut
  };
  function isUnsupportedEase(key) {
    return key in unsupportedEasingFunctions;
  }
  function replaceStringEasing(transition) {
    if (typeof transition.ease === "string" && isUnsupportedEase(transition.ease)) {
      transition.ease = unsupportedEasingFunctions[transition.ease];
    }
  }
  const sampleDelta = 10;
  class NativeAnimationExtended extends NativeAnimation {
    constructor(options) {
      replaceStringEasing(options);
      replaceTransitionType(options);
      super(options);
      if (options.startTime !== void 0) {
        this.startTime = options.startTime;
      }
      this.options = options;
    }
updateMotionValue(value) {
      const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options;
      if (!motionValue2)
        return;
      if (value !== void 0) {
        motionValue2.set(value);
        return;
      }
      const sampleAnimation = new JSAnimation({
        ...options,
        autoplay: false
      });
      const sampleTime = Math.max(sampleDelta, time.now() - this.startTime);
      const delta = clamp(0, sampleDelta, sampleTime - sampleDelta);
      motionValue2.setWithVelocity(sampleAnimation.sample(Math.max(0, sampleTime - delta)).value, sampleAnimation.sample(sampleTime).value, delta);
      sampleAnimation.stop();
    }
  }
  const isAnimatable = (value, name) => {
    if (name === "zIndex")
      return false;
    if (typeof value === "number" || Array.isArray(value))
      return true;
    if (typeof value === "string" &&
(complex.test(value) || value === "0") &&
!value.startsWith("url(")) {
      return true;
    }
    return false;
  };
  function hasKeyframesChanged(keyframes2) {
    const current = keyframes2[0];
    if (keyframes2.length === 1)
      return true;
    for (let i2 = 0; i2 < keyframes2.length; i2++) {
      if (keyframes2[i2] !== current)
        return true;
    }
  }
  function canAnimate(keyframes2, name, type4, velocity) {
    const originKeyframe = keyframes2[0];
    if (originKeyframe === null) {
      return false;
    }
    if (name === "display" || name === "visibility")
      return true;
    const targetKeyframe = keyframes2[keyframes2.length - 1];
    const isOriginAnimatable = isAnimatable(originKeyframe, name);
    const isTargetAnimatable = isAnimatable(targetKeyframe, name);
    if (!isOriginAnimatable || !isTargetAnimatable) {
      return false;
    }
    return hasKeyframesChanged(keyframes2) || (type4 === "spring" || isGenerator(type4)) && velocity;
  }
  function makeAnimationInstant(options) {
    options.duration = 0;
    options.type = "keyframes";
  }
  const acceleratedValues$1 = new Set([
    "opacity",
    "clipPath",
    "filter",
    "transform"

]);
  const supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
  function supportsBrowserAnimation(options) {
    const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type: type4 } = options;
    const subject = motionValue2?.owner?.current;
    if (!(subject instanceof HTMLElement)) {
      return false;
    }
    const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
    return supportsWaapi() && name && acceleratedValues$1.has(name) && (name !== "transform" || !transformTemplate) &&
!onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type4 !== "inertia";
  }
  const MAX_RESOLVE_DELAY = 40;
  class AsyncMotionValueAnimation extends WithPromise {
    constructor({ autoplay = true, delay: delay2 = 0, type: type4 = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", keyframes: keyframes2, name, motionValue: motionValue2, element, ...options }) {
      super();
      this.stop = () => {
        if (this._animation) {
          this._animation.stop();
          this.stopTimeline?.();
        }
        this.keyframeResolver?.cancel();
      };
      this.createdAt = time.now();
      const optionsWithDefaults = {
        autoplay,
        delay: delay2,
        type: type4,
        repeat,
        repeatDelay,
        repeatType,
        name,
        motionValue: motionValue2,
        element,
        ...options
      };
      const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;
      this.keyframeResolver = new KeyframeResolver$1(keyframes2, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue2, element);
      this.keyframeResolver?.scheduleResolve();
    }
    onKeyframesResolved(keyframes2, finalKeyframe, options, sync) {
      this.keyframeResolver = void 0;
      const { name, type: type4, velocity, delay: delay2, isHandoff, onUpdate } = options;
      this.resolvedAt = time.now();
      if (!canAnimate(keyframes2, name, type4, velocity)) {
        if (MotionGlobalConfig.instantAnimations || !delay2) {
          onUpdate?.(getFinalKeyframe$1(keyframes2, options, finalKeyframe));
        }
        keyframes2[0] = keyframes2[keyframes2.length - 1];
        makeAnimationInstant(options);
        options.repeat = 0;
      }
      const startTime = sync ? !this.resolvedAt ? this.createdAt : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : void 0;
      const resolvedOptions = {
        startTime,
        finalKeyframe,
        ...options,
        keyframes: keyframes2
      };
      const useWaapi = !isHandoff && supportsBrowserAnimation(resolvedOptions);
      const element = resolvedOptions.motionValue?.owner?.current;
      const animation = useWaapi ? new NativeAnimationExtended({
        ...resolvedOptions,
        element
      }) : new JSAnimation(resolvedOptions);
      animation.finished.then(() => {
        this.notifyFinished();
      }).catch(noop$1);
      if (this.pendingTimeline) {
        this.stopTimeline = animation.attachTimeline(this.pendingTimeline);
        this.pendingTimeline = void 0;
      }
      this._animation = animation;
    }
    get finished() {
      if (!this._animation) {
        return this._finished;
      } else {
        return this.animation.finished;
      }
    }
    then(onResolve, _onReject) {
      return this.finished.finally(onResolve).then(() => {
      });
    }
    get animation() {
      if (!this._animation) {
        this.keyframeResolver?.resume();
        flushKeyframeResolvers();
      }
      return this._animation;
    }
    get duration() {
      return this.animation.duration;
    }
    get iterationDuration() {
      return this.animation.iterationDuration;
    }
    get time() {
      return this.animation.time;
    }
    set time(newTime) {
      this.animation.time = newTime;
    }
    get speed() {
      return this.animation.speed;
    }
    get state() {
      return this.animation.state;
    }
    set speed(newSpeed) {
      this.animation.speed = newSpeed;
    }
    get startTime() {
      return this.animation.startTime;
    }
    attachTimeline(timeline) {
      if (this._animation) {
        this.stopTimeline = this.animation.attachTimeline(timeline);
      } else {
        this.pendingTimeline = timeline;
      }
      return () => this.stop();
    }
    play() {
      this.animation.play();
    }
    pause() {
      this.animation.pause();
    }
    complete() {
      this.animation.complete();
    }
    cancel() {
      if (this._animation) {
        this.animation.cancel();
      }
      this.keyframeResolver?.cancel();
    }
  }
  class GroupAnimation {
    constructor(animations2) {
      this.stop = () => this.runAll("stop");
      this.animations = animations2.filter(Boolean);
    }
    get finished() {
      return Promise.all(this.animations.map((animation) => animation.finished));
    }
getAll(propName) {
      return this.animations[0][propName];
    }
    setAll(propName, newValue) {
      for (let i2 = 0; i2 < this.animations.length; i2++) {
        this.animations[i2][propName] = newValue;
      }
    }
    attachTimeline(timeline) {
      const subscriptions = this.animations.map((animation) => animation.attachTimeline(timeline));
      return () => {
        subscriptions.forEach((cancel, i2) => {
          cancel && cancel();
          this.animations[i2].stop();
        });
      };
    }
    get time() {
      return this.getAll("time");
    }
    set time(time2) {
      this.setAll("time", time2);
    }
    get speed() {
      return this.getAll("speed");
    }
    set speed(speed) {
      this.setAll("speed", speed);
    }
    get state() {
      return this.getAll("state");
    }
    get startTime() {
      return this.getAll("startTime");
    }
    get duration() {
      return getMax(this.animations, "duration");
    }
    get iterationDuration() {
      return getMax(this.animations, "iterationDuration");
    }
    runAll(methodName) {
      this.animations.forEach((controls) => controls[methodName]());
    }
    play() {
      this.runAll("play");
    }
    pause() {
      this.runAll("pause");
    }
    cancel() {
      this.runAll("cancel");
    }
    complete() {
      this.runAll("complete");
    }
  }
  function getMax(animations2, propName) {
    let max = 0;
    for (let i2 = 0; i2 < animations2.length; i2++) {
      const value = animations2[i2][propName];
      if (value !== null && value > max) {
        max = value;
      }
    }
    return max;
  }
  class GroupAnimationWithThen extends GroupAnimation {
    then(onResolve, _onReject) {
      return this.finished.finally(onResolve).then(() => {
      });
    }
  }
  function calcChildStagger(children, child, delayChildren, staggerChildren = 0, staggerDirection = 1) {
    const index = Array.from(children).sort((a2, b) => a2.sortNodePosition(b)).indexOf(child);
    const numChildren = children.size;
    const maxStaggerDuration = (numChildren - 1) * staggerChildren;
    const delayIsFunction = typeof delayChildren === "function";
    return delayIsFunction ? delayChildren(index, numChildren) : staggerDirection === 1 ? index * staggerChildren : maxStaggerDuration - index * staggerChildren;
  }
  const splitCSSVariableRegex = (
/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
  );
  function parseCSSVariable(current) {
    const match2 = splitCSSVariableRegex.exec(current);
    if (!match2)
      return [,];
    const [, token1, token2, fallback] = match2;
    return [`--${token1 ?? token2}`, fallback];
  }
  function getVariableValue(current, element, depth = 1) {
    const [token2, fallback] = parseCSSVariable(current);
    if (!token2)
      return;
    const resolved = window.getComputedStyle(element).getPropertyValue(token2);
    if (resolved) {
      const trimmed = resolved.trim();
      return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
    }
    return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
  }
  const underDampedSpring = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
  };
  const criticallyDampedSpring = (target) => ({
    type: "spring",
    stiffness: 550,
    damping: target === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
  });
  const keyframesTransition = {
    type: "keyframes",
    duration: 0.8
  };
  const ease = {
    type: "keyframes",
    ease: [0.25, 0.1, 0.35, 1],
    duration: 0.3
  };
  const getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
    if (keyframes2.length > 2) {
      return keyframesTransition;
    } else if (transformProps.has(valueKey)) {
      return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
    }
    return ease;
  };
  const isNotNull = (value) => value !== null;
  function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
    const resolvedKeyframes = keyframes2.filter(isNotNull);
    const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
    return resolvedKeyframes[index];
  }
  function resolveTransition(transition, parentTransition) {
    if (transition?.inherit && parentTransition) {
      const { inherit: _2, ...rest } = transition;
      return { ...parentTransition, ...rest };
    }
    return transition;
  }
  function getValueTransition$1(transition, key) {
    const valueTransition = transition?.[key] ?? transition?.["default"] ?? transition;
    if (valueTransition !== transition) {
      return resolveTransition(valueTransition, transition);
    }
    return valueTransition;
  }
  function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from: from2, elapsed, ...transition }) {
    return !!Object.keys(transition).length;
  }
  const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
    const valueTransition = getValueTransition$1(transition, name) || {};
    const delay2 = valueTransition.delay || transition.delay || 0;
    let { elapsed = 0 } = transition;
    elapsed = elapsed - secondsToMilliseconds(delay2);
    const options = {
      keyframes: Array.isArray(target) ? target : [null, target],
      ease: "easeOut",
      velocity: value.getVelocity(),
      ...valueTransition,
      delay: -elapsed,
      onUpdate: (v) => {
        value.set(v);
        valueTransition.onUpdate && valueTransition.onUpdate(v);
      },
      onComplete: () => {
        onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      },
      name,
      motionValue: value,
      element: isHandoff ? void 0 : element
    };
    if (!isTransitionDefined(valueTransition)) {
      Object.assign(options, getDefaultTransition(name, options));
    }
    options.duration && (options.duration = secondsToMilliseconds(options.duration));
    options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));
    if (options.from !== void 0) {
      options.keyframes[0] = options.from;
    }
    let shouldSkip = false;
    if (options.type === false || options.duration === 0 && !options.repeatDelay) {
      makeAnimationInstant(options);
      if (options.delay === 0) {
        shouldSkip = true;
      }
    }
    if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations || element?.shouldSkipAnimations) {
      shouldSkip = true;
      makeAnimationInstant(options);
      options.delay = 0;
    }
    options.allowFlatten = !valueTransition.type && !valueTransition.ease;
    if (shouldSkip && !isHandoff && value.get() !== void 0) {
      const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
      if (finalKeyframe !== void 0) {
        frame.update(() => {
          options.onUpdate(finalKeyframe);
          options.onComplete();
        });
        return;
      }
    }
    return valueTransition.isSync ? new JSAnimation(options) : new AsyncMotionValueAnimation(options);
  };
  function getValueState(visualElement) {
    const state2 = [{}, {}];
    visualElement?.values.forEach((value, key) => {
      state2[0][key] = value.get();
      state2[1][key] = value.getVelocity();
    });
    return state2;
  }
  function resolveVariantFromProps(props, definition, custom, visualElement) {
    if (typeof definition === "function") {
      const [current, velocity] = getValueState(visualElement);
      definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
    }
    if (typeof definition === "string") {
      definition = props.variants && props.variants[definition];
    }
    if (typeof definition === "function") {
      const [current, velocity] = getValueState(visualElement);
      definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
    }
    return definition;
  }
  function resolveVariant(visualElement, definition, custom) {
    const props = visualElement.getProps();
    return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, visualElement);
  }
  const positionalKeys = new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    ...transformPropOrder
  ]);
  const MAX_VELOCITY_DELTA = 30;
  const isFloat = (value) => {
    return !isNaN(parseFloat(value));
  };
  class MotionValue {
constructor(init, options = {}) {
      this.canTrackVelocity = null;
      this.events = {};
      this.updateAndNotify = (v) => {
        const currentTime = time.now();
        if (this.updatedAt !== currentTime) {
          this.setPrevFrameValue();
        }
        this.prev = this.current;
        this.setCurrent(v);
        if (this.current !== this.prev) {
          this.events.change?.notify(this.current);
          if (this.dependents) {
            for (const dependent of this.dependents) {
              dependent.dirty();
            }
          }
        }
      };
      this.hasAnimated = false;
      this.setCurrent(init);
      this.owner = options.owner;
    }
    setCurrent(current) {
      this.current = current;
      this.updatedAt = time.now();
      if (this.canTrackVelocity === null && current !== void 0) {
        this.canTrackVelocity = isFloat(this.current);
      }
    }
    setPrevFrameValue(prevFrameValue = this.current) {
      this.prevFrameValue = prevFrameValue;
      this.prevUpdatedAt = this.updatedAt;
    }
onChange(subscription) {
      return this.on("change", subscription);
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      const unsubscribe = this.events[eventName].add(callback);
      if (eventName === "change") {
        return () => {
          unsubscribe();
          frame.read(() => {
            if (!this.events.change.getSize()) {
              this.stop();
            }
          });
        };
      }
      return unsubscribe;
    }
    clearListeners() {
      for (const eventManagers in this.events) {
        this.events[eventManagers].clear();
      }
    }
attach(passiveEffect, stopPassiveEffect) {
      this.passiveEffect = passiveEffect;
      this.stopPassiveEffect = stopPassiveEffect;
    }
set(v) {
      if (!this.passiveEffect) {
        this.updateAndNotify(v);
      } else {
        this.passiveEffect(v, this.updateAndNotify);
      }
    }
    setWithVelocity(prev2, current, delta) {
      this.set(current);
      this.prev = void 0;
      this.prevFrameValue = prev2;
      this.prevUpdatedAt = this.updatedAt - delta;
    }
jump(v, endAnimation = true) {
      this.updateAndNotify(v);
      this.prev = v;
      this.prevUpdatedAt = this.prevFrameValue = void 0;
      endAnimation && this.stop();
      if (this.stopPassiveEffect)
        this.stopPassiveEffect();
    }
    dirty() {
      this.events.change?.notify(this.current);
    }
    addDependent(dependent) {
      if (!this.dependents) {
        this.dependents = new Set();
      }
      this.dependents.add(dependent);
    }
    removeDependent(dependent) {
      if (this.dependents) {
        this.dependents.delete(dependent);
      }
    }
get() {
      return this.current;
    }
getPrevious() {
      return this.prev;
    }
getVelocity() {
      const currentTime = time.now();
      if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
        return 0;
      }
      const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
      return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
    }
start(startAnimation) {
      this.stop();
      return new Promise((resolve) => {
        this.hasAnimated = true;
        this.animation = startAnimation(resolve);
        if (this.events.animationStart) {
          this.events.animationStart.notify();
        }
      }).then(() => {
        if (this.events.animationComplete) {
          this.events.animationComplete.notify();
        }
        this.clearAnimation();
      });
    }
stop() {
      if (this.animation) {
        this.animation.stop();
        if (this.events.animationCancel) {
          this.events.animationCancel.notify();
        }
      }
      this.clearAnimation();
    }
isAnimating() {
      return !!this.animation;
    }
    clearAnimation() {
      delete this.animation;
    }
destroy() {
      this.dependents?.clear();
      this.events.destroy?.notify();
      this.clearListeners();
      this.stop();
      if (this.stopPassiveEffect) {
        this.stopPassiveEffect();
      }
    }
  }
  function motionValue(init, options) {
    return new MotionValue(init, options);
  }
  const isKeyframesTarget = (v) => {
    return Array.isArray(v);
  };
  function setMotionValue(visualElement, key, value) {
    if (visualElement.hasValue(key)) {
      visualElement.getValue(key).set(value);
    } else {
      visualElement.addValue(key, motionValue(value));
    }
  }
  function resolveFinalValueInKeyframes(v) {
    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
  }
  function setTarget(visualElement, definition) {
    const resolved = resolveVariant(visualElement, definition);
    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
    target = { ...target, ...transitionEnd };
    for (const key in target) {
      const value = resolveFinalValueInKeyframes(target[key]);
      setMotionValue(visualElement, key, value);
    }
  }
  const isMotionValue = (value) => Boolean(value && value.getVelocity);
  function isWillChangeMotionValue(value) {
    return Boolean(isMotionValue(value) && value.add);
  }
  function addValueToWillChange(visualElement, key) {
    const willChange = visualElement.getValue("willChange");
    if (isWillChangeMotionValue(willChange)) {
      return willChange.add(key);
    } else if (!willChange && MotionGlobalConfig.WillChange) {
      const newWillChange = new MotionGlobalConfig.WillChange("auto");
      visualElement.addValue("willChange", newWillChange);
      newWillChange.add(key);
    }
  }
  function camelToDash(str) {
    return str.replace(/([A-Z])/g, (match2) => `-${match2.toLowerCase()}`);
  }
  const optimizedAppearDataId = "framerAppearId";
  const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
  function getOptimisedAppearId(visualElement) {
    return visualElement.props[optimizedAppearDataAttribute];
  }
  function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
    needsAnimating[key] = false;
    return shouldBlock;
  }
  function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type: type4 } = {}) {
    let { transition, transitionEnd, ...target } = targetAndTransition;
    const defaultTransition2 = visualElement.getDefaultTransition();
    transition = transition ? resolveTransition(transition, defaultTransition2) : defaultTransition2;
    const reduceMotion = transition?.reduceMotion;
    if (transitionOverride)
      transition = transitionOverride;
    const animations2 = [];
    const animationTypeState = type4 && visualElement.animationState && visualElement.animationState.getState()[type4];
    for (const key in target) {
      const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);
      const valueTarget = target[key];
      if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
        continue;
      }
      const valueTransition = {
        delay: delay2,
        ...getValueTransition$1(transition || {}, key)
      };
      const currentValue = value.get();
      if (currentValue !== void 0 && !value.isAnimating && !Array.isArray(valueTarget) && valueTarget === currentValue && !valueTransition.velocity) {
        continue;
      }
      let isHandoff = false;
      if (window.MotionHandoffAnimation) {
        const appearId = getOptimisedAppearId(visualElement);
        if (appearId) {
          const startTime = window.MotionHandoffAnimation(appearId, key, frame);
          if (startTime !== null) {
            valueTransition.startTime = startTime;
            isHandoff = true;
          }
        }
      }
      addValueToWillChange(visualElement, key);
      const shouldReduceMotion = reduceMotion ?? visualElement.shouldReduceMotion;
      value.start(animateMotionValue(key, value, valueTarget, shouldReduceMotion && positionalKeys.has(key) ? { type: false } : valueTransition, visualElement, isHandoff));
      const animation = value.animation;
      if (animation) {
        animations2.push(animation);
      }
    }
    if (transitionEnd) {
      const applyTransitionEnd = () => frame.update(() => {
        transitionEnd && setTarget(visualElement, transitionEnd);
      });
      if (animations2.length) {
        Promise.all(animations2).then(applyTransitionEnd);
      } else {
        applyTransitionEnd();
      }
    }
    return animations2;
  }
  function animateVariant(visualElement, variant, options = {}) {
    const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? visualElement.presenceContext?.custom : void 0);
    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
    if (options.transitionOverride) {
      transition = options.transitionOverride;
    }
    const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
      const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
      return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);
    } : () => Promise.resolve();
    const { when } = transition;
    if (when) {
      const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
      return first().then(() => last());
    } else {
      return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
    }
  }
  function animateChildren(visualElement, variant, delay2 = 0, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
    const animations2 = [];
    for (const child of visualElement.variantChildren) {
      child.notify("AnimationStart", variant);
      animations2.push(animateVariant(child, variant, {
        ...options,
        delay: delay2 + (typeof delayChildren === "function" ? 0 : delayChildren) + calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection)
      }).then(() => child.notify("AnimationComplete", variant)));
    }
    return Promise.all(animations2);
  }
  function animateVisualElement(visualElement, definition, options = {}) {
    visualElement.notify("AnimationStart", definition);
    let animation;
    if (Array.isArray(definition)) {
      const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
      animation = Promise.all(animations2);
    } else if (typeof definition === "string") {
      animation = animateVariant(visualElement, definition, options);
    } else {
      const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
      animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
    }
    return animation.then(() => {
      visualElement.notify("AnimationComplete", definition);
    });
  }
  const auto = {
    test: (v) => v === "auto",
    parse: (v) => v
  };
  const testValueType = (v) => (type4) => type4.test(v);
  const dimensionValueTypes = [number3, px, percent, degrees, vw, vh, auto];
  const findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));
  function isNone(value) {
    if (typeof value === "number") {
      return value === 0;
    } else if (value !== null) {
      return value === "none" || value === "0" || isZeroValueString(value);
    } else {
      return true;
    }
  }
  const maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);
  function applyDefaultFilter(v) {
    const [name, value] = v.slice(0, -1).split("(");
    if (name === "drop-shadow")
      return v;
    const [number4] = value.match(floatRegex) || [];
    if (!number4)
      return v;
    const unit2 = value.replace(number4, "");
    let defaultValue2 = maxDefaults.has(name) ? 1 : 0;
    if (number4 !== value)
      defaultValue2 *= 100;
    return name + "(" + defaultValue2 + unit2 + ")";
  }
  const functionRegex = /\b([a-z-]*)\(.*?\)/gu;
  const filter = {
    ...complex,
    getAnimatableNone: (v) => {
      const functions = v.match(functionRegex);
      return functions ? functions.map(applyDefaultFilter).join(" ") : v;
    }
  };
  const mask = {
    ...complex,
    getAnimatableNone: (v) => {
      const parsed2 = complex.parse(v);
      const transformer = complex.createTransformer(v);
      return transformer(parsed2.map((v2) => typeof v2 === "number" ? 0 : typeof v2 === "object" ? { ...v2, alpha: 1 } : v2));
    }
  };
  const int = {
    ...number3,
    transform: Math.round
  };
  const transformValueTypes = {
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px,
    translateX: px,
    translateY: px,
    translateZ: px,
    x: px,
    y: px,
    z: px,
    perspective: px,
    transformPerspective: px,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px
  };
  const numberValueTypes = {
borderWidth: px,
    borderTopWidth: px,
    borderRightWidth: px,
    borderBottomWidth: px,
    borderLeftWidth: px,
    borderRadius: px,
    borderTopLeftRadius: px,
    borderTopRightRadius: px,
    borderBottomRightRadius: px,
    borderBottomLeftRadius: px,
width: px,
    maxWidth: px,
    height: px,
    maxHeight: px,
    top: px,
    right: px,
    bottom: px,
    left: px,
    inset: px,
    insetBlock: px,
    insetBlockStart: px,
    insetBlockEnd: px,
    insetInline: px,
    insetInlineStart: px,
    insetInlineEnd: px,
padding: px,
    paddingTop: px,
    paddingRight: px,
    paddingBottom: px,
    paddingLeft: px,
    paddingBlock: px,
    paddingBlockStart: px,
    paddingBlockEnd: px,
    paddingInline: px,
    paddingInlineStart: px,
    paddingInlineEnd: px,
    margin: px,
    marginTop: px,
    marginRight: px,
    marginBottom: px,
    marginLeft: px,
    marginBlock: px,
    marginBlockStart: px,
    marginBlockEnd: px,
    marginInline: px,
    marginInlineStart: px,
    marginInlineEnd: px,
fontSize: px,
backgroundPositionX: px,
    backgroundPositionY: px,
    ...transformValueTypes,
    zIndex: int,
fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int
  };
  const defaultValueTypes = {
    ...numberValueTypes,
color,
    backgroundColor: color,
    outlineColor: color,
    fill: color,
    stroke: color,
borderColor: color,
    borderTopColor: color,
    borderRightColor: color,
    borderBottomColor: color,
    borderLeftColor: color,
    filter,
    WebkitFilter: filter,
    mask,
    WebkitMask: mask
  };
  const getDefaultValueType = (key) => defaultValueTypes[key];
  const customTypes = new Set([filter, mask]);
  function getAnimatableNone(key, value) {
    let defaultValueType = getDefaultValueType(key);
    if (!customTypes.has(defaultValueType))
      defaultValueType = complex;
    return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
  }
  const invalidTemplates = new Set(["auto", "none", "0"]);
  function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
    let i2 = 0;
    let animatableTemplate = void 0;
    while (i2 < unresolvedKeyframes.length && !animatableTemplate) {
      const keyframe = unresolvedKeyframes[i2];
      if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
        animatableTemplate = unresolvedKeyframes[i2];
      }
      i2++;
    }
    if (animatableTemplate && name) {
      for (const noneIndex of noneKeyframeIndexes) {
        unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
      }
    }
  }
  class DOMKeyframesResolver extends KeyframeResolver {
    constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
      super(unresolvedKeyframes, onComplete, name, motionValue2, element, true);
    }
    readKeyframes() {
      const { unresolvedKeyframes, element, name } = this;
      if (!element || !element.current)
        return;
      super.readKeyframes();
      for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
        let keyframe = unresolvedKeyframes[i2];
        if (typeof keyframe === "string") {
          keyframe = keyframe.trim();
          if (isCSSVariableToken(keyframe)) {
            const resolved = getVariableValue(keyframe, element.current);
            if (resolved !== void 0) {
              unresolvedKeyframes[i2] = resolved;
            }
            if (i2 === unresolvedKeyframes.length - 1) {
              this.finalKeyframe = keyframe;
            }
          }
        }
      }
      this.resolveNoneKeyframes();
      if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
        return;
      }
      const [origin, target] = unresolvedKeyframes;
      const originType = findDimensionValueType(origin);
      const targetType = findDimensionValueType(target);
      const originHasVar = containsCSSVariable(origin);
      const targetHasVar = containsCSSVariable(target);
      if (originHasVar !== targetHasVar && positionalValues[name]) {
        this.needsMeasurement = true;
        return;
      }
      if (originType === targetType)
        return;
      if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
        for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
          const value = unresolvedKeyframes[i2];
          if (typeof value === "string") {
            unresolvedKeyframes[i2] = parseFloat(value);
          }
        }
      } else if (positionalValues[name]) {
        this.needsMeasurement = true;
      }
    }
    resolveNoneKeyframes() {
      const { unresolvedKeyframes, name } = this;
      const noneKeyframeIndexes = [];
      for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
        if (unresolvedKeyframes[i2] === null || isNone(unresolvedKeyframes[i2])) {
          noneKeyframeIndexes.push(i2);
        }
      }
      if (noneKeyframeIndexes.length) {
        makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
      }
    }
    measureInitialState() {
      const { element, unresolvedKeyframes, name } = this;
      if (!element || !element.current)
        return;
      if (name === "height") {
        this.suspendedScrollY = window.pageYOffset;
      }
      this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
      unresolvedKeyframes[0] = this.measuredOrigin;
      const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
      if (measureKeyframe !== void 0) {
        element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
      }
    }
    measureEndState() {
      const { element, name, unresolvedKeyframes } = this;
      if (!element || !element.current)
        return;
      const value = element.getValue(name);
      value && value.jump(this.measuredOrigin, false);
      const finalKeyframeIndex = unresolvedKeyframes.length - 1;
      const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
      unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
      if (finalKeyframe !== null && this.finalKeyframe === void 0) {
        this.finalKeyframe = finalKeyframe;
      }
      if (this.removedTransforms?.length) {
        this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
          element.getValue(unsetTransformName).set(unsetTransformValue);
        });
      }
      this.resolveNoneKeyframes();
    }
  }
  const acceleratedValues = new Set([
    "opacity",
    "clipPath",
    "filter",
    "transform"


]);
  function resolveElements(elementOrSelector, scope, selectorCache) {
    if (elementOrSelector == null) {
      return [];
    }
    if (elementOrSelector instanceof EventTarget) {
      return [elementOrSelector];
    } else if (typeof elementOrSelector === "string") {
      let root2 = document;
      if (scope) {
        root2 = scope.current;
      }
      const elements = selectorCache?.[elementOrSelector] ?? root2.querySelectorAll(elementOrSelector);
      return elements ? Array.from(elements) : [];
    }
    return Array.from(elementOrSelector).filter((element) => element != null);
  }
  const getValueAsType = (value, type4) => {
    return type4 && typeof value === "number" ? type4.transform(value) : value;
  };
  function isHTMLElement$1(element) {
    return isObject(element) && "offsetHeight" in element;
  }
  const { schedule: microtask } = createRenderBatcher(queueMicrotask, false);
  const isDragging = {
    x: false,
    y: false
  };
  function isDragActive() {
    return isDragging.x || isDragging.y;
  }
  function setDragLock(axis) {
    if (axis === "x" || axis === "y") {
      if (isDragging[axis]) {
        return null;
      } else {
        isDragging[axis] = true;
        return () => {
          isDragging[axis] = false;
        };
      }
    } else {
      if (isDragging.x || isDragging.y) {
        return null;
      } else {
        isDragging.x = isDragging.y = true;
        return () => {
          isDragging.x = isDragging.y = false;
        };
      }
    }
  }
  function setupGesture(elementOrSelector, options) {
    const elements = resolveElements(elementOrSelector);
    const gestureAbortController = new AbortController();
    const eventOptions = {
      passive: true,
      ...options,
      signal: gestureAbortController.signal
    };
    const cancel = () => gestureAbortController.abort();
    return [elements, eventOptions, cancel];
  }
  function isValidHover(event) {
    return !(event.pointerType === "touch" || isDragActive());
  }
  function hover(elementOrSelector, onHoverStart, options = {}) {
    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
    elements.forEach((element) => {
      let isPressed = false;
      let deferredHoverEnd = false;
      let hoverEndCallback;
      const removePointerLeave = () => {
        element.removeEventListener("pointerleave", onPointerLeave);
      };
      const endHover = (event) => {
        if (hoverEndCallback) {
          hoverEndCallback(event);
          hoverEndCallback = void 0;
        }
        removePointerLeave();
      };
      const onPointerUp = (event) => {
        isPressed = false;
        window.removeEventListener("pointerup", onPointerUp);
        window.removeEventListener("pointercancel", onPointerUp);
        if (deferredHoverEnd) {
          deferredHoverEnd = false;
          endHover(event);
        }
      };
      const onPointerDown = () => {
        isPressed = true;
        window.addEventListener("pointerup", onPointerUp, eventOptions);
        window.addEventListener("pointercancel", onPointerUp, eventOptions);
      };
      const onPointerLeave = (leaveEvent) => {
        if (leaveEvent.pointerType === "touch")
          return;
        if (isPressed) {
          deferredHoverEnd = true;
          return;
        }
        endHover(leaveEvent);
      };
      const onPointerEnter = (enterEvent) => {
        if (!isValidHover(enterEvent))
          return;
        deferredHoverEnd = false;
        const onHoverEnd = onHoverStart(element, enterEvent);
        if (typeof onHoverEnd !== "function")
          return;
        hoverEndCallback = onHoverEnd;
        element.addEventListener("pointerleave", onPointerLeave, eventOptions);
      };
      element.addEventListener("pointerenter", onPointerEnter, eventOptions);
      element.addEventListener("pointerdown", onPointerDown, eventOptions);
    });
    return cancel;
  }
  const isNodeOrChild = (parent, child) => {
    if (!child) {
      return false;
    } else if (parent === child) {
      return true;
    } else {
      return isNodeOrChild(parent, child.parentElement);
    }
  };
  const isPrimaryPointer = (event) => {
    if (event.pointerType === "mouse") {
      return typeof event.button !== "number" || event.button <= 0;
    } else {
      return event.isPrimary !== false;
    }
  };
  const keyboardAccessibleElements = new Set([
    "BUTTON",
    "INPUT",
    "SELECT",
    "TEXTAREA",
    "A"
  ]);
  function isElementKeyboardAccessible(element) {
    return keyboardAccessibleElements.has(element.tagName) || element.isContentEditable === true;
  }
  const textInputElements = new Set(["INPUT", "SELECT", "TEXTAREA"]);
  function isElementTextInput(element) {
    return textInputElements.has(element.tagName) || element.isContentEditable === true;
  }
  const isPressing = new WeakSet();
  function filterEvents(callback) {
    return (event) => {
      if (event.key !== "Enter")
        return;
      callback(event);
    };
  }
  function firePointerEvent(target, type4) {
    target.dispatchEvent(new PointerEvent("pointer" + type4, { isPrimary: true, bubbles: true }));
  }
  const enableKeyboardPress = (focusEvent, eventOptions) => {
    const element = focusEvent.currentTarget;
    if (!element)
      return;
    const handleKeydown = filterEvents(() => {
      if (isPressing.has(element))
        return;
      firePointerEvent(element, "down");
      const handleKeyup = filterEvents(() => {
        firePointerEvent(element, "up");
      });
      const handleBlur = () => firePointerEvent(element, "cancel");
      element.addEventListener("keyup", handleKeyup, eventOptions);
      element.addEventListener("blur", handleBlur, eventOptions);
    });
    element.addEventListener("keydown", handleKeydown, eventOptions);
    element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
  };
  function isValidPressEvent(event) {
    return isPrimaryPointer(event) && !isDragActive();
  }
  const claimedPointerDownEvents = new WeakSet();
  function press(targetOrSelector, onPressStart, options = {}) {
    const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);
    const startPress = (startEvent) => {
      const target = startEvent.currentTarget;
      if (!isValidPressEvent(startEvent))
        return;
      if (claimedPointerDownEvents.has(startEvent))
        return;
      isPressing.add(target);
      if (options.stopPropagation) {
        claimedPointerDownEvents.add(startEvent);
      }
      const onPressEnd = onPressStart(target, startEvent);
      const onPointerEnd = (endEvent, success) => {
        window.removeEventListener("pointerup", onPointerUp);
        window.removeEventListener("pointercancel", onPointerCancel);
        if (isPressing.has(target)) {
          isPressing.delete(target);
        }
        if (!isValidPressEvent(endEvent)) {
          return;
        }
        if (typeof onPressEnd === "function") {
          onPressEnd(endEvent, { success });
        }
      };
      const onPointerUp = (upEvent) => {
        onPointerEnd(upEvent, target === window || target === document || options.useGlobalTarget || isNodeOrChild(target, upEvent.target));
      };
      const onPointerCancel = (cancelEvent) => {
        onPointerEnd(cancelEvent, false);
      };
      window.addEventListener("pointerup", onPointerUp, eventOptions);
      window.addEventListener("pointercancel", onPointerCancel, eventOptions);
    };
    targets.forEach((target) => {
      const pointerDownTarget = options.useGlobalTarget ? window : target;
      pointerDownTarget.addEventListener("pointerdown", startPress, eventOptions);
      if (isHTMLElement$1(target)) {
        target.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions));
        if (!isElementKeyboardAccessible(target) && !target.hasAttribute("tabindex")) {
          target.tabIndex = 0;
        }
      }
    });
    return cancelEvents;
  }
  function isSVGElement$1(element) {
    return isObject(element) && "ownerSVGElement" in element;
  }
  const resizeHandlers = new WeakMap();
  let observer;
  const getSize = (borderBoxAxis, svgAxis, htmlAxis) => (target, borderBoxSize) => {
    if (borderBoxSize && borderBoxSize[0]) {
      return borderBoxSize[0][borderBoxAxis + "Size"];
    } else if (isSVGElement$1(target) && "getBBox" in target) {
      return target.getBBox()[svgAxis];
    } else {
      return target[htmlAxis];
    }
  };
  const getWidth = getSize("inline", "width", "offsetWidth");
  const getHeight = getSize("block", "height", "offsetHeight");
  function notifyTarget({ target, borderBoxSize }) {
    resizeHandlers.get(target)?.forEach((handler) => {
      handler(target, {
        get width() {
          return getWidth(target, borderBoxSize);
        },
        get height() {
          return getHeight(target, borderBoxSize);
        }
      });
    });
  }
  function notifyAll(entries) {
    entries.forEach(notifyTarget);
  }
  function createResizeObserver() {
    if (typeof ResizeObserver === "undefined")
      return;
    observer = new ResizeObserver(notifyAll);
  }
  function resizeElement(target, handler) {
    if (!observer)
      createResizeObserver();
    const elements = resolveElements(target);
    elements.forEach((element) => {
      let elementHandlers = resizeHandlers.get(element);
      if (!elementHandlers) {
        elementHandlers = new Set();
        resizeHandlers.set(element, elementHandlers);
      }
      elementHandlers.add(handler);
      observer?.observe(element);
    });
    return () => {
      elements.forEach((element) => {
        const elementHandlers = resizeHandlers.get(element);
        elementHandlers?.delete(handler);
        if (!elementHandlers?.size) {
          observer?.unobserve(element);
        }
      });
    };
  }
  const windowCallbacks = new Set();
  let windowResizeHandler;
  function createWindowResizeHandler() {
    windowResizeHandler = () => {
      const info = {
        get width() {
          return window.innerWidth;
        },
        get height() {
          return window.innerHeight;
        }
      };
      windowCallbacks.forEach((callback) => callback(info));
    };
    window.addEventListener("resize", windowResizeHandler);
  }
  function resizeWindow(callback) {
    windowCallbacks.add(callback);
    if (!windowResizeHandler)
      createWindowResizeHandler();
    return () => {
      windowCallbacks.delete(callback);
      if (!windowCallbacks.size && typeof windowResizeHandler === "function") {
        window.removeEventListener("resize", windowResizeHandler);
        windowResizeHandler = void 0;
      }
    };
  }
  function resize(a2, b) {
    return typeof a2 === "function" ? resizeWindow(a2) : resizeElement(a2, b);
  }
  function isSVGSVGElement(element) {
    return isSVGElement$1(element) && element.tagName === "svg";
  }
  const valueTypes = [...dimensionValueTypes, color, complex];
  const findValueType = (v) => valueTypes.find(testValueType(v));
  const createAxisDelta = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
  });
  const createDelta = () => ({
    x: createAxisDelta(),
    y: createAxisDelta()
  });
  const createAxis = () => ({ min: 0, max: 0 });
  const createBox = () => ({
    x: createAxis(),
    y: createAxis()
  });
  const visualElementStore = new WeakMap();
  function isAnimationControls(v) {
    return v !== null && typeof v === "object" && typeof v.start === "function";
  }
  function isVariantLabel(v) {
    return typeof v === "string" || Array.isArray(v);
  }
  const variantPriorityOrder = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit"
  ];
  const variantProps = ["initial", ...variantPriorityOrder];
  function isControllingVariants(props) {
    return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
  }
  function isVariantNode(props) {
    return Boolean(isControllingVariants(props) || props.variants);
  }
  function updateMotionValuesFromProps(element, next2, prev2) {
    for (const key in next2) {
      const nextValue = next2[key];
      const prevValue = prev2[key];
      if (isMotionValue(nextValue)) {
        element.addValue(key, nextValue);
      } else if (isMotionValue(prevValue)) {
        element.addValue(key, motionValue(nextValue, { owner: element }));
      } else if (prevValue !== nextValue) {
        if (element.hasValue(key)) {
          const existingValue = element.getValue(key);
          if (existingValue.liveStyle === true) {
            existingValue.jump(nextValue);
          } else if (!existingValue.hasAnimated) {
            existingValue.set(nextValue);
          }
        } else {
          const latestValue = element.getStaticValue(key);
          element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
        }
      }
    }
    for (const key in prev2) {
      if (next2[key] === void 0)
        element.removeValue(key);
    }
    return next2;
  }
  const prefersReducedMotion = { current: null };
  const hasReducedMotionListener = { current: false };
  const isBrowser$2 = typeof window !== "undefined";
  function initPrefersReducedMotion() {
    hasReducedMotionListener.current = true;
    if (!isBrowser$2)
      return;
    if (window.matchMedia) {
      const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
      const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
      motionMediaQuery.addEventListener("change", setReducedMotionPreferences);
      setReducedMotionPreferences();
    } else {
      prefersReducedMotion.current = false;
    }
  }
  const propEventHandlers = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete"
  ];
  let featureDefinitions = {};
  function setFeatureDefinitions(definitions) {
    featureDefinitions = definitions;
  }
  function getFeatureDefinitions() {
    return featureDefinitions;
  }
  class VisualElement {
scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
      return {};
    }
    constructor({ parent, props, presenceContext, reducedMotionConfig, skipAnimations, blockInitialAnimation, visualState }, options = {}) {
      this.current = null;
      this.children = new Set();
      this.isVariantNode = false;
      this.isControllingVariants = false;
      this.shouldReduceMotion = null;
      this.shouldSkipAnimations = false;
      this.values = new Map();
      this.KeyframeResolver = KeyframeResolver;
      this.features = {};
      this.valueSubscriptions = new Map();
      this.prevMotionValues = {};
      this.hasBeenMounted = false;
      this.events = {};
      this.propEventSubscriptions = {};
      this.notifyUpdate = () => this.notify("Update", this.latestValues);
      this.render = () => {
        if (!this.current)
          return;
        this.triggerBuild();
        this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
      };
      this.renderScheduledAt = 0;
      this.scheduleRender = () => {
        const now2 = time.now();
        if (this.renderScheduledAt < now2) {
          this.renderScheduledAt = now2;
          frame.render(this.render, false, true);
        }
      };
      const { latestValues, renderState } = visualState;
      this.latestValues = latestValues;
      this.baseTarget = { ...latestValues };
      this.initialValues = props.initial ? { ...latestValues } : {};
      this.renderState = renderState;
      this.parent = parent;
      this.props = props;
      this.presenceContext = presenceContext;
      this.depth = parent ? parent.depth + 1 : 0;
      this.reducedMotionConfig = reducedMotionConfig;
      this.skipAnimationsConfig = skipAnimations;
      this.options = options;
      this.blockInitialAnimation = Boolean(blockInitialAnimation);
      this.isControllingVariants = isControllingVariants(props);
      this.isVariantNode = isVariantNode(props);
      if (this.isVariantNode) {
        this.variantChildren = new Set();
      }
      this.manuallyAnimateOnMount = Boolean(parent && parent.current);
      const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
      for (const key in initialMotionValues) {
        const value = initialMotionValues[key];
        if (latestValues[key] !== void 0 && isMotionValue(value)) {
          value.set(latestValues[key]);
        }
      }
    }
    mount(instance) {
      if (this.hasBeenMounted) {
        for (const key in this.initialValues) {
          this.values.get(key)?.jump(this.initialValues[key]);
          this.latestValues[key] = this.initialValues[key];
        }
      }
      this.current = instance;
      visualElementStore.set(instance, this);
      if (this.projection && !this.projection.instance) {
        this.projection.mount(instance);
      }
      if (this.parent && this.isVariantNode && !this.isControllingVariants) {
        this.removeFromVariantTree = this.parent.addVariantChild(this);
      }
      this.values.forEach((value, key) => this.bindToMotionValue(key, value));
      if (this.reducedMotionConfig === "never") {
        this.shouldReduceMotion = false;
      } else if (this.reducedMotionConfig === "always") {
        this.shouldReduceMotion = true;
      } else {
        if (!hasReducedMotionListener.current) {
          initPrefersReducedMotion();
        }
        this.shouldReduceMotion = prefersReducedMotion.current;
      }
      this.shouldSkipAnimations = this.skipAnimationsConfig ?? false;
      this.parent?.addChild(this);
      this.update(this.props, this.presenceContext);
      this.hasBeenMounted = true;
    }
    unmount() {
      this.projection && this.projection.unmount();
      cancelFrame(this.notifyUpdate);
      cancelFrame(this.render);
      this.valueSubscriptions.forEach((remove) => remove());
      this.valueSubscriptions.clear();
      this.removeFromVariantTree && this.removeFromVariantTree();
      this.parent?.removeChild(this);
      for (const key in this.events) {
        this.events[key].clear();
      }
      for (const key in this.features) {
        const feature = this.features[key];
        if (feature) {
          feature.unmount();
          feature.isMounted = false;
        }
      }
      this.current = null;
    }
    addChild(child) {
      this.children.add(child);
      this.enteringChildren ?? (this.enteringChildren = new Set());
      this.enteringChildren.add(child);
    }
    removeChild(child) {
      this.children.delete(child);
      this.enteringChildren && this.enteringChildren.delete(child);
    }
    bindToMotionValue(key, value) {
      if (this.valueSubscriptions.has(key)) {
        this.valueSubscriptions.get(key)();
      }
      if (value.accelerate && acceleratedValues.has(key) && this.current instanceof HTMLElement) {
        const { factory, keyframes: keyframes2, times: times2, ease: ease2, duration: duration2 } = value.accelerate;
        const animation = new NativeAnimation({
          element: this.current,
          name: key,
          keyframes: keyframes2,
          times: times2,
          ease: ease2,
          duration: secondsToMilliseconds(duration2)
        });
        const cleanup2 = factory(animation);
        this.valueSubscriptions.set(key, () => {
          cleanup2();
          animation.cancel();
        });
        return;
      }
      const valueIsTransform = transformProps.has(key);
      if (valueIsTransform && this.onBindTransform) {
        this.onBindTransform();
      }
      const removeOnChange = value.on("change", (latestValue) => {
        this.latestValues[key] = latestValue;
        this.props.onUpdate && frame.preRender(this.notifyUpdate);
        if (valueIsTransform && this.projection) {
          this.projection.isTransformDirty = true;
        }
        this.scheduleRender();
      });
      let removeSyncCheck;
      if (typeof window !== "undefined" && window.MotionCheckAppearSync) {
        removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
      }
      this.valueSubscriptions.set(key, () => {
        removeOnChange();
        if (removeSyncCheck)
          removeSyncCheck();
        if (value.owner)
          value.stop();
      });
    }
    sortNodePosition(other) {
      if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
        return 0;
      }
      return this.sortInstanceNodePosition(this.current, other.current);
    }
    updateFeatures() {
      let key = "animation";
      for (key in featureDefinitions) {
        const featureDefinition = featureDefinitions[key];
        if (!featureDefinition)
          continue;
        const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
        if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
          this.features[key] = new FeatureConstructor(this);
        }
        if (this.features[key]) {
          const feature = this.features[key];
          if (feature.isMounted) {
            feature.update();
          } else {
            feature.mount();
            feature.isMounted = true;
          }
        }
      }
    }
    triggerBuild() {
      this.build(this.renderState, this.latestValues, this.props);
    }
measureViewportBox() {
      return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
    }
    getStaticValue(key) {
      return this.latestValues[key];
    }
    setStaticValue(key, value) {
      this.latestValues[key] = value;
    }
update(props, presenceContext) {
      if (props.transformTemplate || this.props.transformTemplate) {
        this.scheduleRender();
      }
      this.prevProps = this.props;
      this.props = props;
      this.prevPresenceContext = this.presenceContext;
      this.presenceContext = presenceContext;
      for (let i2 = 0; i2 < propEventHandlers.length; i2++) {
        const key = propEventHandlers[i2];
        if (this.propEventSubscriptions[key]) {
          this.propEventSubscriptions[key]();
          delete this.propEventSubscriptions[key];
        }
        const listenerName = "on" + key;
        const listener = props[listenerName];
        if (listener) {
          this.propEventSubscriptions[key] = this.on(key, listener);
        }
      }
      this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps || {}, this), this.prevMotionValues);
      if (this.handleChildMotionValue) {
        this.handleChildMotionValue();
      }
    }
    getProps() {
      return this.props;
    }
getVariant(name) {
      return this.props.variants ? this.props.variants[name] : void 0;
    }
getDefaultTransition() {
      return this.props.transition;
    }
    getTransformPagePoint() {
      return this.props.transformPagePoint;
    }
    getClosestVariantNode() {
      return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
    }
addVariantChild(child) {
      const closestVariantNode = this.getClosestVariantNode();
      if (closestVariantNode) {
        closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
        return () => closestVariantNode.variantChildren.delete(child);
      }
    }
addValue(key, value) {
      const existingValue = this.values.get(key);
      if (value !== existingValue) {
        if (existingValue)
          this.removeValue(key);
        this.bindToMotionValue(key, value);
        this.values.set(key, value);
        this.latestValues[key] = value.get();
      }
    }
removeValue(key) {
      this.values.delete(key);
      const unsubscribe = this.valueSubscriptions.get(key);
      if (unsubscribe) {
        unsubscribe();
        this.valueSubscriptions.delete(key);
      }
      delete this.latestValues[key];
      this.removeValueFromRenderState(key, this.renderState);
    }
hasValue(key) {
      return this.values.has(key);
    }
    getValue(key, defaultValue2) {
      if (this.props.values && this.props.values[key]) {
        return this.props.values[key];
      }
      let value = this.values.get(key);
      if (value === void 0 && defaultValue2 !== void 0) {
        value = motionValue(defaultValue2 === null ? void 0 : defaultValue2, { owner: this });
        this.addValue(key, value);
      }
      return value;
    }
readValue(key, target) {
      let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.getBaseTargetFromProps(this.props, key) ?? this.readValueFromInstance(this.current, key, this.options);
      if (value !== void 0 && value !== null) {
        if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
          value = parseFloat(value);
        } else if (!findValueType(value) && complex.test(target)) {
          value = getAnimatableNone(key, target);
        }
        this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
      }
      return isMotionValue(value) ? value.get() : value;
    }
setBaseTarget(key, value) {
      this.baseTarget[key] = value;
    }
getBaseTarget(key) {
      const { initial } = this.props;
      let valueFromInitial;
      if (typeof initial === "string" || typeof initial === "object") {
        const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);
        if (variant) {
          valueFromInitial = variant[key];
        }
      }
      if (initial && valueFromInitial !== void 0) {
        return valueFromInitial;
      }
      const target = this.getBaseTargetFromProps(this.props, key);
      if (target !== void 0 && !isMotionValue(target))
        return target;
      return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      return this.events[eventName].add(callback);
    }
    notify(eventName, ...args) {
      if (this.events[eventName]) {
        this.events[eventName].notify(...args);
      }
    }
    scheduleRenderMicrotask() {
      microtask.render(this.render);
    }
  }
  class DOMVisualElement extends VisualElement {
    constructor() {
      super(...arguments);
      this.KeyframeResolver = DOMKeyframesResolver;
    }
    sortInstanceNodePosition(a2, b) {
      return a2.compareDocumentPosition(b) & 2 ? 1 : -1;
    }
    getBaseTargetFromProps(props, key) {
      const style2 = props.style;
      return style2 ? style2[key] : void 0;
    }
    removeValueFromRenderState(key, { vars, style: style2 }) {
      delete vars[key];
      delete style2[key];
    }
    handleChildMotionValue() {
      if (this.childSubscription) {
        this.childSubscription();
        delete this.childSubscription;
      }
      const { children } = this.props;
      if (isMotionValue(children)) {
        this.childSubscription = children.on("change", (latest) => {
          if (this.current) {
            this.current.textContent = `${latest}`;
          }
        });
      }
    }
  }
  class Feature {
    constructor(node2) {
      this.isMounted = false;
      this.node = node2;
    }
    update() {
    }
  }
  function convertBoundingBoxToBox({ top, left, right, bottom }) {
    return {
      x: { min: left, max: right },
      y: { min: top, max: bottom }
    };
  }
  function convertBoxToBoundingBox({ x, y }) {
    return { top: y.min, right: x.max, bottom: y.max, left: x.min };
  }
  function transformBoxPoints(point, transformPoint2) {
    if (!transformPoint2)
      return point;
    const topLeft = transformPoint2({ x: point.left, y: point.top });
    const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
    return {
      top: topLeft.y,
      left: topLeft.x,
      bottom: bottomRight.y,
      right: bottomRight.x
    };
  }
  function isIdentityScale(scale2) {
    return scale2 === void 0 || scale2 === 1;
  }
  function hasScale({ scale: scale2, scaleX: scaleX2, scaleY: scaleY2 }) {
    return !isIdentityScale(scale2) || !isIdentityScale(scaleX2) || !isIdentityScale(scaleY2);
  }
  function hasTransform(values) {
    return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
  }
  function has2DTranslate(values) {
    return is2DTranslate(values.x) || is2DTranslate(values.y);
  }
  function is2DTranslate(value) {
    return value && value !== "0%";
  }
  function scalePoint(point, scale2, originPoint) {
    const distanceFromOrigin = point - originPoint;
    const scaled = scale2 * distanceFromOrigin;
    return originPoint + scaled;
  }
  function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
    if (boxScale !== void 0) {
      point = scalePoint(point, boxScale, originPoint);
    }
    return scalePoint(point, scale2, originPoint) + translate;
  }
  function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
    axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
    axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
  }
  function applyBoxDelta(box2, { x, y }) {
    applyAxisDelta(box2.x, x.translate, x.scale, x.originPoint);
    applyAxisDelta(box2.y, y.translate, y.scale, y.originPoint);
  }
  const TREE_SCALE_SNAP_MIN = 0.999999999999;
  const TREE_SCALE_SNAP_MAX = 1.0000000000001;
  function applyTreeDeltas(box2, treeScale, treePath, isSharedTransition = false) {
    const treeLength = treePath.length;
    if (!treeLength)
      return;
    treeScale.x = treeScale.y = 1;
    let node2;
    let delta;
    for (let i2 = 0; i2 < treeLength; i2++) {
      node2 = treePath[i2];
      delta = node2.projectionDelta;
      const { visualElement } = node2.options;
      if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
        continue;
      }
      if (isSharedTransition && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
        transformBox(box2, {
          x: -node2.scroll.offset.x,
          y: -node2.scroll.offset.y
        });
      }
      if (delta) {
        treeScale.x *= delta.x.scale;
        treeScale.y *= delta.y.scale;
        applyBoxDelta(box2, delta);
      }
      if (isSharedTransition && hasTransform(node2.latestValues)) {
        transformBox(box2, node2.latestValues);
      }
    }
    if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
      treeScale.x = 1;
    }
    if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
      treeScale.y = 1;
    }
  }
  function translateAxis(axis, distance2) {
    axis.min = axis.min + distance2;
    axis.max = axis.max + distance2;
  }
  function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
    const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
  }
  function transformBox(box2, transform) {
    transformAxis(box2.x, transform.x, transform.scaleX, transform.scale, transform.originX);
    transformAxis(box2.y, transform.y, transform.scaleY, transform.scale, transform.originY);
  }
  function measureViewportBox(instance, transformPoint2) {
    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
  }
  function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
    const viewportBox = measureViewportBox(element, transformPagePoint);
    const { scroll } = rootProjectionNode2;
    if (scroll) {
      translateAxis(viewportBox.x, scroll.offset.x);
      translateAxis(viewportBox.y, scroll.offset.y);
    }
    return viewportBox;
  }
  const translateAlias = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
  };
  const numTransforms = transformPropOrder.length;
  function buildTransform(latestValues, transform, transformTemplate) {
    let transformString = "";
    let transformIsDefault = true;
    for (let i2 = 0; i2 < numTransforms; i2++) {
      const key = transformPropOrder[i2];
      const value = latestValues[key];
      if (value === void 0)
        continue;
      let valueIsDefault = true;
      if (typeof value === "number") {
        valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
      } else {
        const parsed2 = parseFloat(value);
        valueIsDefault = key.startsWith("scale") ? parsed2 === 1 : parsed2 === 0;
      }
      if (!valueIsDefault || transformTemplate) {
        const valueAsType = getValueAsType(value, numberValueTypes[key]);
        if (!valueIsDefault) {
          transformIsDefault = false;
          const transformName = translateAlias[key] || key;
          transformString += `${transformName}(${valueAsType}) `;
        }
        if (transformTemplate) {
          transform[key] = valueAsType;
        }
      }
    }
    transformString = transformString.trim();
    if (transformTemplate) {
      transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
    } else if (transformIsDefault) {
      transformString = "none";
    }
    return transformString;
  }
  function buildHTMLStyles(state2, latestValues, transformTemplate) {
    const { style: style2, vars, transformOrigin } = state2;
    let hasTransform2 = false;
    let hasTransformOrigin = false;
    for (const key in latestValues) {
      const value = latestValues[key];
      if (transformProps.has(key)) {
        hasTransform2 = true;
        continue;
      } else if (isCSSVariableName(key)) {
        vars[key] = value;
        continue;
      } else {
        const valueAsType = getValueAsType(value, numberValueTypes[key]);
        if (key.startsWith("origin")) {
          hasTransformOrigin = true;
          transformOrigin[key] = valueAsType;
        } else {
          style2[key] = valueAsType;
        }
      }
    }
    if (!latestValues.transform) {
      if (hasTransform2 || transformTemplate) {
        style2.transform = buildTransform(latestValues, state2.transform, transformTemplate);
      } else if (style2.transform) {
        style2.transform = "none";
      }
    }
    if (hasTransformOrigin) {
      const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
      style2.transformOrigin = `${originX} ${originY} ${originZ}`;
    }
  }
  function renderHTML(element, { style: style2, vars }, styleProp, projection) {
    const elementStyle = element.style;
    let key;
    for (key in style2) {
      elementStyle[key] = style2[key];
    }
    projection?.applyProjectionStyles(elementStyle, styleProp);
    for (key in vars) {
      elementStyle.setProperty(key, vars[key]);
    }
  }
  function pixelsToPercent(pixels, axis) {
    if (axis.max === axis.min)
      return 0;
    return pixels / (axis.max - axis.min) * 100;
  }
  const correctBorderRadius = {
    correct: (latest, node2) => {
      if (!node2.target)
        return latest;
      if (typeof latest === "string") {
        if (px.test(latest)) {
          latest = parseFloat(latest);
        } else {
          return latest;
        }
      }
      const x = pixelsToPercent(latest, node2.target.x);
      const y = pixelsToPercent(latest, node2.target.y);
      return `${x}% ${y}%`;
    }
  };
  const correctBoxShadow = {
    correct: (latest, { treeScale, projectionDelta }) => {
      const original = latest;
      const shadow = complex.parse(latest);
      if (shadow.length > 5)
        return original;
      const template = complex.createTransformer(latest);
      const offset2 = typeof shadow[0] !== "number" ? 1 : 0;
      const xScale = projectionDelta.x.scale * treeScale.x;
      const yScale = projectionDelta.y.scale * treeScale.y;
      shadow[0 + offset2] /= xScale;
      shadow[1 + offset2] /= yScale;
      const averageScale = mixNumber$1(xScale, yScale, 0.5);
      if (typeof shadow[2 + offset2] === "number")
        shadow[2 + offset2] /= averageScale;
      if (typeof shadow[3 + offset2] === "number")
        shadow[3 + offset2] /= averageScale;
      return template(shadow);
    }
  };
  const scaleCorrectors = {
    borderRadius: {
      ...correctBorderRadius,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius"
      ]
    },
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow
  };
  function isForcedMotionValue(key, { layout: layout2, layoutId }) {
    return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
  }
  function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
    const style2 = props.style;
    const prevStyle = prevProps?.style;
    const newValues = {};
    if (!style2)
      return newValues;
    for (const key in style2) {
      if (isMotionValue(style2[key]) || prevStyle && isMotionValue(prevStyle[key]) || isForcedMotionValue(key, props) || visualElement?.getValue(key)?.liveStyle !== void 0) {
        newValues[key] = style2[key];
      }
    }
    return newValues;
  }
  function getComputedStyle$1(element) {
    return window.getComputedStyle(element);
  }
  class HTMLVisualElement extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "html";
      this.renderInstance = renderHTML;
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        return this.projection?.isProjecting ? defaultTransformValue(key) : readTransformValue(instance, key);
      } else {
        const computedStyle = getComputedStyle$1(instance);
        const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
        return typeof value === "string" ? value.trim() : value;
      }
    }
    measureInstanceViewportBox(instance, { transformPagePoint }) {
      return measureViewportBox(instance, transformPagePoint);
    }
    build(renderState, latestValues, props) {
      buildHTMLStyles(renderState, latestValues, props.transformTemplate);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
    }
  }
  function isObjectKey(key, object4) {
    return key in object4;
  }
  class ObjectVisualElement extends VisualElement {
    constructor() {
      super(...arguments);
      this.type = "object";
    }
    readValueFromInstance(instance, key) {
      if (isObjectKey(key, instance)) {
        const value = instance[key];
        if (typeof value === "string" || typeof value === "number") {
          return value;
        }
      }
      return void 0;
    }
    getBaseTargetFromProps() {
      return void 0;
    }
    removeValueFromRenderState(key, renderState) {
      delete renderState.output[key];
    }
    measureInstanceViewportBox() {
      return createBox();
    }
    build(renderState, latestValues) {
      Object.assign(renderState.output, latestValues);
    }
    renderInstance(instance, { output }) {
      Object.assign(instance, output);
    }
    sortInstanceNodePosition() {
      return 0;
    }
  }
  const dashKeys = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
  };
  const camelKeys = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
  };
  function buildSVGPath(attrs, length2, spacing = 1, offset2 = 0, useDashCase = true) {
    attrs.pathLength = 1;
    const keys2 = useDashCase ? dashKeys : camelKeys;
    attrs[keys2.offset] = `${-offset2}`;
    attrs[keys2.array] = `${length2} ${spacing}`;
  }
  const cssMotionPathProperties = [
    "offsetDistance",
    "offsetPath",
    "offsetRotate",
    "offsetAnchor"
  ];
  function buildSVGAttrs(state2, {
    attrX,
    attrY,
    attrScale,
    pathLength,
    pathSpacing = 1,
    pathOffset = 0,
...latest
  }, isSVGTag2, transformTemplate, styleProp) {
    buildHTMLStyles(state2, latest, transformTemplate);
    if (isSVGTag2) {
      if (state2.style.viewBox) {
        state2.attrs.viewBox = state2.style.viewBox;
      }
      return;
    }
    state2.attrs = state2.style;
    state2.style = {};
    const { attrs, style: style2 } = state2;
    if (attrs.transform) {
      style2.transform = attrs.transform;
      delete attrs.transform;
    }
    if (style2.transform || attrs.transformOrigin) {
      style2.transformOrigin = attrs.transformOrigin ?? "50% 50%";
      delete attrs.transformOrigin;
    }
    if (style2.transform) {
      style2.transformBox = styleProp?.transformBox ?? "fill-box";
      delete attrs.transformBox;
    }
    for (const key of cssMotionPathProperties) {
      if (attrs[key] !== void 0) {
        style2[key] = attrs[key];
        delete attrs[key];
      }
    }
    if (attrX !== void 0)
      attrs.x = attrX;
    if (attrY !== void 0)
      attrs.y = attrY;
    if (attrScale !== void 0)
      attrs.scale = attrScale;
    if (pathLength !== void 0) {
      buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
    }
  }
  const camelCaseAttributes = new Set([
    "baseFrequency",
    "diffuseConstant",
    "kernelMatrix",
    "kernelUnitLength",
    "keySplines",
    "keyTimes",
    "limitingConeAngle",
    "markerHeight",
    "markerWidth",
    "numOctaves",
    "targetX",
    "targetY",
    "surfaceScale",
    "specularConstant",
    "specularExponent",
    "stdDeviation",
    "tableValues",
    "viewBox",
    "gradientTransform",
    "pathLength",
    "startOffset",
    "textLength",
    "lengthAdjust"
  ]);
  const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
  function renderSVG(element, renderState, _styleProp, projection) {
    renderHTML(element, renderState, void 0, projection);
    for (const key in renderState.attrs) {
      element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
    }
  }
  function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
    for (const key in props) {
      if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
        const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
        newValues[targetKey] = props[key];
      }
    }
    return newValues;
  }
  class SVGVisualElement extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "svg";
      this.isSVGTag = false;
      this.measureInstanceViewportBox = createBox;
    }
    getBaseTargetFromProps(props, key) {
      return props[key];
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        const defaultType = getDefaultValueType(key);
        return defaultType ? defaultType.default || 0 : 0;
      }
      key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
      return instance.getAttribute(key);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps(props, prevProps, visualElement);
    }
    build(renderState, latestValues, props) {
      buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);
    }
    renderInstance(instance, renderState, styleProp, projection) {
      renderSVG(instance, renderState, styleProp, projection);
    }
    mount(instance) {
      this.isSVGTag = isSVGTag(instance.tagName);
      super.mount(instance);
    }
  }
  const numVariantProps = variantProps.length;
  function getVariantContext(visualElement) {
    if (!visualElement)
      return void 0;
    if (!visualElement.isControllingVariants) {
      const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
      if (visualElement.props.initial !== void 0) {
        context2.initial = visualElement.props.initial;
      }
      return context2;
    }
    const context = {};
    for (let i2 = 0; i2 < numVariantProps; i2++) {
      const name = variantProps[i2];
      const prop = visualElement.props[name];
      if (isVariantLabel(prop) || prop === false) {
        context[name] = prop;
      }
    }
    return context;
  }
  function shallowCompare(next2, prev2) {
    if (!Array.isArray(prev2))
      return false;
    const prevLength = prev2.length;
    if (prevLength !== next2.length)
      return false;
    for (let i2 = 0; i2 < prevLength; i2++) {
      if (prev2[i2] !== next2[i2])
        return false;
    }
    return true;
  }
  const reversePriorityOrder = [...variantPriorityOrder].reverse();
  const numAnimationTypes = variantPriorityOrder.length;
  function createAnimateFunction(visualElement) {
    return (animations2) => {
      return Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
    };
  }
  function createAnimationState(visualElement) {
    let animate = createAnimateFunction(visualElement);
    let state2 = createState();
    let isInitialRender = true;
    const buildResolvedTypeValues = (type4) => (acc, definition) => {
      const resolved = resolveVariant(visualElement, definition, type4 === "exit" ? visualElement.presenceContext?.custom : void 0);
      if (resolved) {
        const { transition, transitionEnd, ...target } = resolved;
        acc = { ...acc, ...target, ...transitionEnd };
      }
      return acc;
    };
    function setAnimateFunction(makeAnimator) {
      animate = makeAnimator(visualElement);
    }
    function animateChanges(changedActiveType) {
      const { props } = visualElement;
      const context = getVariantContext(visualElement.parent) || {};
      const animations2 = [];
      const removedKeys = new Set();
      let encounteredKeys = {};
      let removedVariantIndex = Infinity;
      for (let i2 = 0; i2 < numAnimationTypes; i2++) {
        const type4 = reversePriorityOrder[i2];
        const typeState = state2[type4];
        const prop = props[type4] !== void 0 ? props[type4] : context[type4];
        const propIsVariant = isVariantLabel(prop);
        const activeDelta = type4 === changedActiveType ? typeState.isActive : null;
        if (activeDelta === false)
          removedVariantIndex = i2;
        let isInherited = prop === context[type4] && prop !== props[type4] && propIsVariant;
        if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
          isInherited = false;
        }
        typeState.protectedKeys = { ...encounteredKeys };
        if (
!typeState.isActive && activeDelta === null ||
!prop && !typeState.prevProp ||
isAnimationControls(prop) || typeof prop === "boolean"
        ) {
          continue;
        }
        if (type4 === "exit" && typeState.isActive && activeDelta !== true) {
          if (typeState.prevResolvedValues) {
            encounteredKeys = {
              ...encounteredKeys,
              ...typeState.prevResolvedValues
            };
          }
          continue;
        }
        const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
        let shouldAnimateType = variantDidChange ||
type4 === changedActiveType && typeState.isActive && !isInherited && propIsVariant ||
i2 > removedVariantIndex && propIsVariant;
        let handledRemovedValues = false;
        const definitionList = Array.isArray(prop) ? prop : [prop];
        let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type4), {});
        if (activeDelta === false)
          resolvedValues = {};
        const { prevResolvedValues = {} } = typeState;
        const allKeys = {
          ...prevResolvedValues,
          ...resolvedValues
        };
        const markToAnimate = (key) => {
          shouldAnimateType = true;
          if (removedKeys.has(key)) {
            handledRemovedValues = true;
            removedKeys.delete(key);
          }
          typeState.needsAnimating[key] = true;
          const motionValue2 = visualElement.getValue(key);
          if (motionValue2)
            motionValue2.liveStyle = false;
        };
        for (const key in allKeys) {
          const next2 = resolvedValues[key];
          const prev2 = prevResolvedValues[key];
          if (encounteredKeys.hasOwnProperty(key))
            continue;
          let valueHasChanged = false;
          if (isKeyframesTarget(next2) && isKeyframesTarget(prev2)) {
            valueHasChanged = !shallowCompare(next2, prev2);
          } else {
            valueHasChanged = next2 !== prev2;
          }
          if (valueHasChanged) {
            if (next2 !== void 0 && next2 !== null) {
              markToAnimate(key);
            } else {
              removedKeys.add(key);
            }
          } else if (next2 !== void 0 && removedKeys.has(key)) {
            markToAnimate(key);
          } else {
            typeState.protectedKeys[key] = true;
          }
        }
        typeState.prevProp = prop;
        typeState.prevResolvedValues = resolvedValues;
        if (typeState.isActive) {
          encounteredKeys = { ...encounteredKeys, ...resolvedValues };
        }
        if (isInitialRender && visualElement.blockInitialAnimation) {
          shouldAnimateType = false;
        }
        const willAnimateViaParent = isInherited && variantDidChange;
        const needsAnimating = !willAnimateViaParent || handledRemovedValues;
        if (shouldAnimateType && needsAnimating) {
          animations2.push(...definitionList.map((animation) => {
            const options = { type: type4 };
            if (typeof animation === "string" && isInitialRender && !willAnimateViaParent && visualElement.manuallyAnimateOnMount && visualElement.parent) {
              const { parent } = visualElement;
              const parentVariant = resolveVariant(parent, animation);
              if (parent.enteringChildren && parentVariant) {
                const { delayChildren } = parentVariant.transition || {};
                options.delay = calcChildStagger(parent.enteringChildren, visualElement, delayChildren);
              }
            }
            return {
              animation,
              options
            };
          }));
        }
      }
      if (removedKeys.size) {
        const fallbackAnimation = {};
        if (typeof props.initial !== "boolean") {
          const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);
          if (initialTransition && initialTransition.transition) {
            fallbackAnimation.transition = initialTransition.transition;
          }
        }
        removedKeys.forEach((key) => {
          const fallbackTarget = visualElement.getBaseTarget(key);
          const motionValue2 = visualElement.getValue(key);
          if (motionValue2)
            motionValue2.liveStyle = true;
          fallbackAnimation[key] = fallbackTarget ?? null;
        });
        animations2.push({ animation: fallbackAnimation });
      }
      let shouldAnimate = Boolean(animations2.length);
      if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
        shouldAnimate = false;
      }
      isInitialRender = false;
      return shouldAnimate ? animate(animations2) : Promise.resolve();
    }
    function setActive(type4, isActive2) {
      if (state2[type4].isActive === isActive2)
        return Promise.resolve();
      visualElement.variantChildren?.forEach((child) => child.animationState?.setActive(type4, isActive2));
      state2[type4].isActive = isActive2;
      const animations2 = animateChanges(type4);
      for (const key in state2) {
        state2[key].protectedKeys = {};
      }
      return animations2;
    }
    return {
      animateChanges,
      setActive,
      setAnimateFunction,
      getState: () => state2,
      reset: () => {
        state2 = createState();
      }
    };
  }
  function checkVariantsDidChange(prev2, next2) {
    if (typeof next2 === "string") {
      return next2 !== prev2;
    } else if (Array.isArray(next2)) {
      return !shallowCompare(next2, prev2);
    }
    return false;
  }
  function createTypeState(isActive2 = false) {
    return {
      isActive: isActive2,
      protectedKeys: {},
      needsAnimating: {},
      prevResolvedValues: {}
    };
  }
  function createState() {
    return {
      animate: createTypeState(true),
      whileInView: createTypeState(),
      whileHover: createTypeState(),
      whileTap: createTypeState(),
      whileDrag: createTypeState(),
      whileFocus: createTypeState(),
      exit: createTypeState()
    };
  }
  function copyAxisInto(axis, originAxis) {
    axis.min = originAxis.min;
    axis.max = originAxis.max;
  }
  function copyBoxInto(box2, originBox) {
    copyAxisInto(box2.x, originBox.x);
    copyAxisInto(box2.y, originBox.y);
  }
  function copyAxisDeltaInto(delta, originDelta) {
    delta.translate = originDelta.translate;
    delta.scale = originDelta.scale;
    delta.originPoint = originDelta.originPoint;
    delta.origin = originDelta.origin;
  }
  const SCALE_PRECISION = 1e-4;
  const SCALE_MIN = 1 - SCALE_PRECISION;
  const SCALE_MAX = 1 + SCALE_PRECISION;
  const TRANSLATE_PRECISION = 0.01;
  const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
  const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
  function calcLength(axis) {
    return axis.max - axis.min;
  }
  function isNear(value, target, maxDistance) {
    return Math.abs(value - target) <= maxDistance;
  }
  function calcAxisDelta(delta, source, target, origin = 0.5) {
    delta.origin = origin;
    delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
    delta.scale = calcLength(target) / calcLength(source);
    delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
    if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
      delta.scale = 1;
    }
    if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
      delta.translate = 0;
    }
  }
  function calcBoxDelta(delta, source, target, origin) {
    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
  }
  function calcRelativeAxis(target, relative, parent) {
    target.min = parent.min + relative.min;
    target.max = target.min + calcLength(relative);
  }
  function calcRelativeBox(target, relative, parent) {
    calcRelativeAxis(target.x, relative.x, parent.x);
    calcRelativeAxis(target.y, relative.y, parent.y);
  }
  function calcRelativeAxisPosition(target, layout2, parent) {
    target.min = layout2.min - parent.min;
    target.max = target.min + calcLength(layout2);
  }
  function calcRelativePosition(target, layout2, parent) {
    calcRelativeAxisPosition(target.x, layout2.x, parent.x);
    calcRelativeAxisPosition(target.y, layout2.y, parent.y);
  }
  function removePointDelta(point, translate, scale2, originPoint, boxScale) {
    point -= translate;
    point = scalePoint(point, 1 / scale2, originPoint);
    if (boxScale !== void 0) {
      point = scalePoint(point, 1 / boxScale, originPoint);
    }
    return point;
  }
  function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
    if (percent.test(translate)) {
      translate = parseFloat(translate);
      const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);
      translate = relativeProgress - sourceAxis.min;
    }
    if (typeof translate !== "number")
      return;
    let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
    if (axis === originAxis)
      originPoint -= translate;
    axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
    axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
  }
  function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
  }
  const xKeys = ["x", "scaleX", "originX"];
  const yKeys = ["y", "scaleY", "originY"];
  function removeBoxTransforms(box2, transforms, originBox, sourceBox) {
    removeAxisTransforms(box2.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
    removeAxisTransforms(box2.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
  }
  function isAxisDeltaZero(delta) {
    return delta.translate === 0 && delta.scale === 1;
  }
  function isDeltaZero(delta) {
    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
  }
  function axisEquals(a2, b) {
    return a2.min === b.min && a2.max === b.max;
  }
  function boxEquals(a2, b) {
    return axisEquals(a2.x, b.x) && axisEquals(a2.y, b.y);
  }
  function axisEqualsRounded(a2, b) {
    return Math.round(a2.min) === Math.round(b.min) && Math.round(a2.max) === Math.round(b.max);
  }
  function boxEqualsRounded(a2, b) {
    return axisEqualsRounded(a2.x, b.x) && axisEqualsRounded(a2.y, b.y);
  }
  function aspectRatio(box2) {
    return calcLength(box2.x) / calcLength(box2.y);
  }
  function axisDeltaEquals(a2, b) {
    return a2.translate === b.translate && a2.scale === b.scale && a2.originPoint === b.originPoint;
  }
  function eachAxis(callback) {
    return [callback("x"), callback("y")];
  }
  function buildProjectionTransform(delta, treeScale, latestTransform) {
    let transform = "";
    const xTranslate = delta.x.translate / treeScale.x;
    const yTranslate = delta.y.translate / treeScale.y;
    const zTranslate = latestTransform?.z || 0;
    if (xTranslate || yTranslate || zTranslate) {
      transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
    }
    if (treeScale.x !== 1 || treeScale.y !== 1) {
      transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
    }
    if (latestTransform) {
      const { transformPerspective, rotate: rotate2, rotateX, rotateY, skewX, skewY } = latestTransform;
      if (transformPerspective)
        transform = `perspective(${transformPerspective}px) ${transform}`;
      if (rotate2)
        transform += `rotate(${rotate2}deg) `;
      if (rotateX)
        transform += `rotateX(${rotateX}deg) `;
      if (rotateY)
        transform += `rotateY(${rotateY}deg) `;
      if (skewX)
        transform += `skewX(${skewX}deg) `;
      if (skewY)
        transform += `skewY(${skewY}deg) `;
    }
    const elementScaleX = delta.x.scale * treeScale.x;
    const elementScaleY = delta.y.scale * treeScale.y;
    if (elementScaleX !== 1 || elementScaleY !== 1) {
      transform += `scale(${elementScaleX}, ${elementScaleY})`;
    }
    return transform || "none";
  }
  const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
  const numBorders = borders.length;
  const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
  const isPx = (value) => typeof value === "number" || px.test(value);
  function mixValues(target, follow2, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
    if (shouldCrossfadeOpacity) {
      target.opacity = mixNumber$1(0, lead.opacity ?? 1, easeCrossfadeIn(progress2));
      target.opacityExit = mixNumber$1(follow2.opacity ?? 1, 0, easeCrossfadeOut(progress2));
    } else if (isOnlyMember) {
      target.opacity = mixNumber$1(follow2.opacity ?? 1, lead.opacity ?? 1, progress2);
    }
    for (let i2 = 0; i2 < numBorders; i2++) {
      const borderLabel = `border${borders[i2]}Radius`;
      let followRadius = getRadius(follow2, borderLabel);
      let leadRadius = getRadius(lead, borderLabel);
      if (followRadius === void 0 && leadRadius === void 0)
        continue;
      followRadius || (followRadius = 0);
      leadRadius || (leadRadius = 0);
      const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
      if (canMix) {
        target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
        if (percent.test(leadRadius) || percent.test(followRadius)) {
          target[borderLabel] += "%";
        }
      } else {
        target[borderLabel] = leadRadius;
      }
    }
    if (follow2.rotate || lead.rotate) {
      target.rotate = mixNumber$1(follow2.rotate || 0, lead.rotate || 0, progress2);
    }
  }
  function getRadius(values, radiusName) {
    return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
  }
  const easeCrossfadeIn = compress(0, 0.5, circOut);
  const easeCrossfadeOut = compress(0.5, 0.95, noop$1);
  function compress(min, max, easing) {
    return (p2) => {
      if (p2 < min)
        return 0;
      if (p2 > max)
        return 1;
      return easing( progress(min, max, p2));
    };
  }
  function animateSingleValue(value, keyframes2, options) {
    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
    motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
    return motionValue$1.animation;
  }
  function addDomEvent(target, eventName, handler, options = { passive: true }) {
    target.addEventListener(eventName, handler, options);
    return () => target.removeEventListener(eventName, handler);
  }
  const compareByDepth = (a2, b) => a2.depth - b.depth;
  class FlatTree {
    constructor() {
      this.children = [];
      this.isDirty = false;
    }
    add(child) {
      addUniqueItem(this.children, child);
      this.isDirty = true;
    }
    remove(child) {
      removeItem(this.children, child);
      this.isDirty = true;
    }
    forEach(callback) {
      this.isDirty && this.children.sort(compareByDepth);
      this.isDirty = false;
      this.children.forEach(callback);
    }
  }
  function delay(callback, timeout) {
    const start = time.now();
    const checkElapsed = ({ timestamp }) => {
      const elapsed = timestamp - start;
      if (elapsed >= timeout) {
        cancelFrame(checkElapsed);
        callback(elapsed - timeout);
      }
    };
    frame.setup(checkElapsed, true);
    return () => cancelFrame(checkElapsed);
  }
  function resolveMotionValue(value) {
    return isMotionValue(value) ? value.get() : value;
  }
  class NodeStack {
    constructor() {
      this.members = [];
    }
    add(node2) {
      addUniqueItem(this.members, node2);
      for (let i2 = this.members.length - 1; i2 >= 0; i2--) {
        const m2 = this.members[i2];
        if (m2 === node2 || m2 === this.lead || m2 === this.prevLead)
          continue;
        const inst = m2.instance;
        if (inst && inst.isConnected === false && m2.isPresent !== false && !m2.snapshot) {
          removeItem(this.members, m2);
        }
      }
      node2.scheduleRender();
    }
    remove(node2) {
      removeItem(this.members, node2);
      if (node2 === this.prevLead) {
        this.prevLead = void 0;
      }
      if (node2 === this.lead) {
        const prevLead = this.members[this.members.length - 1];
        if (prevLead) {
          this.promote(prevLead);
        }
      }
    }
    relegate(node2) {
      const indexOfNode = this.members.findIndex((member) => node2 === member);
      if (indexOfNode === 0)
        return false;
      let prevLead;
      for (let i2 = indexOfNode; i2 >= 0; i2--) {
        const member = this.members[i2];
        const inst = member.instance;
        if (member.isPresent !== false && (!inst || inst.isConnected !== false)) {
          prevLead = member;
          break;
        }
      }
      if (prevLead) {
        this.promote(prevLead);
        return true;
      } else {
        return false;
      }
    }
    promote(node2, preserveFollowOpacity) {
      const prevLead = this.lead;
      if (node2 === prevLead)
        return;
      this.prevLead = prevLead;
      this.lead = node2;
      node2.show();
      if (prevLead) {
        prevLead.instance && prevLead.scheduleRender();
        node2.scheduleRender();
        const prevDep = prevLead.options.layoutDependency;
        const nextDep = node2.options.layoutDependency;
        const dependencyMatches = prevDep !== void 0 && nextDep !== void 0 && prevDep === nextDep;
        if (!dependencyMatches) {
          const prevInstance = prevLead.instance;
          const isStale = prevInstance && prevInstance.isConnected === false && !prevLead.snapshot;
          if (!isStale) {
            node2.resumeFrom = prevLead;
            if (preserveFollowOpacity) {
              node2.resumeFrom.preserveOpacity = true;
            }
            if (prevLead.snapshot) {
              node2.snapshot = prevLead.snapshot;
              node2.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
            }
            if (node2.root && node2.root.isUpdating) {
              node2.isLayoutDirty = true;
            }
          }
        }
        const { crossfade } = node2.options;
        if (crossfade === false) {
          prevLead.hide();
        }
      }
    }
    exitAnimationComplete() {
      this.members.forEach((node2) => {
        const { options, resumingFrom } = node2;
        options.onExitComplete && options.onExitComplete();
        if (resumingFrom) {
          resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
        }
      });
    }
    scheduleRender() {
      this.members.forEach((node2) => {
        node2.instance && node2.scheduleRender(false);
      });
    }
removeLeadSnapshot() {
      if (this.lead && this.lead.snapshot) {
        this.lead.snapshot = void 0;
      }
    }
  }
  const globalProjectionState = {
hasAnimatedSinceResize: true,
hasEverUpdated: false
  };
  const transformAxes = ["", "X", "Y", "Z"];
  const animationTarget = 1e3;
  let id$1 = 0;
  function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
    const { latestValues } = visualElement;
    if (latestValues[key]) {
      values[key] = latestValues[key];
      visualElement.setStaticValue(key, 0);
      if (sharedAnimationValues) {
        sharedAnimationValues[key] = 0;
      }
    }
  }
  function cancelTreeOptimisedTransformAnimations(projectionNode) {
    projectionNode.hasCheckedOptimisedAppear = true;
    if (projectionNode.root === projectionNode)
      return;
    const { visualElement } = projectionNode.options;
    if (!visualElement)
      return;
    const appearId = getOptimisedAppearId(visualElement);
    if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
      const { layout: layout2, layoutId } = projectionNode.options;
      window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
    }
    const { parent } = projectionNode;
    if (parent && !parent.hasCheckedOptimisedAppear) {
      cancelTreeOptimisedTransformAnimations(parent);
    }
  }
  function createProjectionNode$1({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
    return class ProjectionNode {
      constructor(latestValues = {}, parent = defaultParent?.()) {
        this.id = id$1++;
        this.animationId = 0;
        this.animationCommitId = 0;
        this.children = new Set();
        this.options = {};
        this.isTreeAnimating = false;
        this.isAnimationBlocked = false;
        this.isLayoutDirty = false;
        this.isProjectionDirty = false;
        this.isSharedProjectionDirty = false;
        this.isTransformDirty = false;
        this.updateManuallyBlocked = false;
        this.updateBlockedByResize = false;
        this.isUpdating = false;
        this.isSVG = false;
        this.needsReset = false;
        this.shouldResetTransform = false;
        this.hasCheckedOptimisedAppear = false;
        this.treeScale = { x: 1, y: 1 };
        this.eventHandlers = new Map();
        this.hasTreeAnimated = false;
        this.layoutVersion = 0;
        this.updateScheduled = false;
        this.scheduleUpdate = () => this.update();
        this.projectionUpdateScheduled = false;
        this.checkUpdateFailed = () => {
          if (this.isUpdating) {
            this.isUpdating = false;
            this.clearAllSnapshots();
          }
        };
        this.updateProjection = () => {
          this.projectionUpdateScheduled = false;
          this.nodes.forEach(propagateDirtyNodes);
          this.nodes.forEach(resolveTargetDelta);
          this.nodes.forEach(calcProjection);
          this.nodes.forEach(cleanDirtyNodes);
        };
        this.resolvedRelativeTargetAt = 0;
        this.linkedParentVersion = 0;
        this.hasProjected = false;
        this.isVisible = true;
        this.animationProgress = 0;
        this.sharedNodes = new Map();
        this.latestValues = latestValues;
        this.root = parent ? parent.root || parent : this;
        this.path = parent ? [...parent.path, parent] : [];
        this.parent = parent;
        this.depth = parent ? parent.depth + 1 : 0;
        for (let i2 = 0; i2 < this.path.length; i2++) {
          this.path[i2].shouldResetTransform = true;
        }
        if (this.root === this)
          this.nodes = new FlatTree();
      }
      addEventListener(name, handler) {
        if (!this.eventHandlers.has(name)) {
          this.eventHandlers.set(name, new SubscriptionManager());
        }
        return this.eventHandlers.get(name).add(handler);
      }
      notifyListeners(name, ...args) {
        const subscriptionManager = this.eventHandlers.get(name);
        subscriptionManager && subscriptionManager.notify(...args);
      }
      hasListeners(name) {
        return this.eventHandlers.has(name);
      }
mount(instance) {
        if (this.instance)
          return;
        this.isSVG = isSVGElement$1(instance) && !isSVGSVGElement(instance);
        this.instance = instance;
        const { layoutId, layout: layout2, visualElement } = this.options;
        if (visualElement && !visualElement.current) {
          visualElement.mount(instance);
        }
        this.root.nodes.add(this);
        this.parent && this.parent.children.add(this);
        if (this.root.hasTreeAnimated && (layout2 || layoutId)) {
          this.isLayoutDirty = true;
        }
        if (attachResizeListener) {
          let cancelDelay;
          let innerWidth = 0;
          const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
          frame.read(() => {
            innerWidth = window.innerWidth;
          });
          attachResizeListener(instance, () => {
            const newInnerWidth = window.innerWidth;
            if (newInnerWidth === innerWidth)
              return;
            innerWidth = newInnerWidth;
            this.root.updateBlockedByResize = true;
            cancelDelay && cancelDelay();
            cancelDelay = delay(resizeUnblockUpdate, 250);
            if (globalProjectionState.hasAnimatedSinceResize) {
              globalProjectionState.hasAnimatedSinceResize = false;
              this.nodes.forEach(finishAnimation);
            }
          });
        }
        if (layoutId) {
          this.root.registerSharedNode(layoutId, this);
        }
        if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
          this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
            if (this.isTreeAnimationBlocked()) {
              this.target = void 0;
              this.relativeTarget = void 0;
              return;
            }
            const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
            const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
            const hasTargetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout);
            const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
            if (this.options.layoutRoot || this.resumeFrom || hasOnlyRelativeTargetChanged || hasLayoutChanged && (hasTargetChanged || !this.currentAnimation)) {
              if (this.resumeFrom) {
                this.resumingFrom = this.resumeFrom;
                this.resumingFrom.resumingFrom = void 0;
              }
              const animationOptions = {
                ...getValueTransition$1(layoutTransition, "layout"),
                onPlay: onLayoutAnimationStart,
                onComplete: onLayoutAnimationComplete
              };
              if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
                animationOptions.delay = 0;
                animationOptions.type = false;
              }
              this.startAnimation(animationOptions);
              this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            } else {
              if (!hasLayoutChanged) {
                finishAnimation(this);
              }
              if (this.isLead() && this.options.onExitComplete) {
                this.options.onExitComplete();
              }
            }
            this.targetLayout = newLayout;
          });
        }
      }
      unmount() {
        this.options.layoutId && this.willUpdate();
        this.root.nodes.remove(this);
        const stack2 = this.getStack();
        stack2 && stack2.remove(this);
        this.parent && this.parent.children.delete(this);
        this.instance = void 0;
        this.eventHandlers.clear();
        cancelFrame(this.updateProjection);
      }
blockUpdate() {
        this.updateManuallyBlocked = true;
      }
      unblockUpdate() {
        this.updateManuallyBlocked = false;
      }
      isUpdateBlocked() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      }
      isTreeAnimationBlocked() {
        return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
      }
startUpdate() {
        if (this.isUpdateBlocked())
          return;
        this.isUpdating = true;
        this.nodes && this.nodes.forEach(resetSkewAndRotation);
        this.animationId++;
      }
      getTransformTemplate() {
        const { visualElement } = this.options;
        return visualElement && visualElement.getProps().transformTemplate;
      }
      willUpdate(shouldNotifyListeners = true) {
        this.root.hasTreeAnimated = true;
        if (this.root.isUpdateBlocked()) {
          this.options.onExitComplete && this.options.onExitComplete();
          return;
        }
        if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
          cancelTreeOptimisedTransformAnimations(this);
        }
        !this.root.isUpdating && this.root.startUpdate();
        if (this.isLayoutDirty)
          return;
        this.isLayoutDirty = true;
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node2 = this.path[i2];
          node2.shouldResetTransform = true;
          node2.updateScroll("snapshot");
          if (node2.options.layoutRoot) {
            node2.willUpdate(false);
          }
        }
        const { layoutId, layout: layout2 } = this.options;
        if (layoutId === void 0 && !layout2)
          return;
        const transformTemplate = this.getTransformTemplate();
        this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
        this.updateSnapshot();
        shouldNotifyListeners && this.notifyListeners("willUpdate");
      }
      update() {
        this.updateScheduled = false;
        const updateWasBlocked = this.isUpdateBlocked();
        if (updateWasBlocked) {
          this.unblockUpdate();
          this.clearAllSnapshots();
          this.nodes.forEach(clearMeasurements);
          return;
        }
        if (this.animationId <= this.animationCommitId) {
          this.nodes.forEach(clearIsLayoutDirty);
          return;
        }
        this.animationCommitId = this.animationId;
        if (!this.isUpdating) {
          this.nodes.forEach(clearIsLayoutDirty);
        } else {
          this.isUpdating = false;
          this.nodes.forEach(resetTransformStyle);
          this.nodes.forEach(updateLayout);
          this.nodes.forEach(notifyLayoutUpdate);
        }
        this.clearAllSnapshots();
        const now2 = time.now();
        frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp);
        frameData.timestamp = now2;
        frameData.isProcessing = true;
        frameSteps.update.process(frameData);
        frameSteps.preRender.process(frameData);
        frameSteps.render.process(frameData);
        frameData.isProcessing = false;
      }
      didUpdate() {
        if (!this.updateScheduled) {
          this.updateScheduled = true;
          microtask.read(this.scheduleUpdate);
        }
      }
      clearAllSnapshots() {
        this.nodes.forEach(clearSnapshot);
        this.sharedNodes.forEach(removeLeadSnapshots);
      }
      scheduleUpdateProjection() {
        if (!this.projectionUpdateScheduled) {
          this.projectionUpdateScheduled = true;
          frame.preRender(this.updateProjection, false, true);
        }
      }
      scheduleCheckAfterUnmount() {
        frame.postRender(() => {
          if (this.isLayoutDirty) {
            this.root.didUpdate();
          } else {
            this.root.checkUpdateFailed();
          }
        });
      }
updateSnapshot() {
        if (this.snapshot || !this.instance)
          return;
        this.snapshot = this.measure();
        if (this.snapshot && !calcLength(this.snapshot.measuredBox.x) && !calcLength(this.snapshot.measuredBox.y)) {
          this.snapshot = void 0;
        }
      }
      updateLayout() {
        if (!this.instance)
          return;
        this.updateScroll();
        if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
          return;
        }
        if (this.resumeFrom && !this.resumeFrom.instance) {
          for (let i2 = 0; i2 < this.path.length; i2++) {
            const node2 = this.path[i2];
            node2.updateScroll();
          }
        }
        const prevLayout = this.layout;
        this.layout = this.measure(false);
        this.layoutVersion++;
        this.layoutCorrected = createBox();
        this.isLayoutDirty = false;
        this.projectionDelta = void 0;
        this.notifyListeners("measure", this.layout.layoutBox);
        const { visualElement } = this.options;
        visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
      }
      updateScroll(phase = "measure") {
        let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
        if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
          needsMeasurement = false;
        }
        if (needsMeasurement && this.instance) {
          const isRoot = checkIsScrollRoot(this.instance);
          this.scroll = {
            animationId: this.root.animationId,
            phase,
            isRoot,
            offset: measureScroll(this.instance),
            wasRoot: this.scroll ? this.scroll.isRoot : isRoot
          };
        }
      }
      resetTransform() {
        if (!resetTransform)
          return;
        const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
        const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
        const transformTemplate = this.getTransformTemplate();
        const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
        const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
        if (isResetRequested && this.instance && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
          resetTransform(this.instance, transformTemplateValue);
          this.shouldResetTransform = false;
          this.scheduleRender();
        }
      }
      measure(removeTransform = true) {
        const pageBox = this.measurePageBox();
        let layoutBox = this.removeElementScroll(pageBox);
        if (removeTransform) {
          layoutBox = this.removeTransform(layoutBox);
        }
        roundBox(layoutBox);
        return {
          animationId: this.root.animationId,
          measuredBox: pageBox,
          layoutBox,
          latestValues: {},
          source: this.id
        };
      }
      measurePageBox() {
        const { visualElement } = this.options;
        if (!visualElement)
          return createBox();
        const box2 = visualElement.measureViewportBox();
        const wasInScrollRoot = this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot);
        if (!wasInScrollRoot) {
          const { scroll } = this.root;
          if (scroll) {
            translateAxis(box2.x, scroll.offset.x);
            translateAxis(box2.y, scroll.offset.y);
          }
        }
        return box2;
      }
      removeElementScroll(box2) {
        const boxWithoutScroll = createBox();
        copyBoxInto(boxWithoutScroll, box2);
        if (this.scroll?.wasRoot) {
          return boxWithoutScroll;
        }
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node2 = this.path[i2];
          const { scroll, options } = node2;
          if (node2 !== this.root && scroll && options.layoutScroll) {
            if (scroll.wasRoot) {
              copyBoxInto(boxWithoutScroll, box2);
            }
            translateAxis(boxWithoutScroll.x, scroll.offset.x);
            translateAxis(boxWithoutScroll.y, scroll.offset.y);
          }
        }
        return boxWithoutScroll;
      }
      applyTransform(box2, transformOnly = false) {
        const withTransforms = createBox();
        copyBoxInto(withTransforms, box2);
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node2 = this.path[i2];
          if (!transformOnly && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
            transformBox(withTransforms, {
              x: -node2.scroll.offset.x,
              y: -node2.scroll.offset.y
            });
          }
          if (!hasTransform(node2.latestValues))
            continue;
          transformBox(withTransforms, node2.latestValues);
        }
        if (hasTransform(this.latestValues)) {
          transformBox(withTransforms, this.latestValues);
        }
        return withTransforms;
      }
      removeTransform(box2) {
        const boxWithoutTransform = createBox();
        copyBoxInto(boxWithoutTransform, box2);
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node2 = this.path[i2];
          if (!node2.instance)
            continue;
          if (!hasTransform(node2.latestValues))
            continue;
          hasScale(node2.latestValues) && node2.updateSnapshot();
          const sourceBox = createBox();
          const nodeBox = node2.measurePageBox();
          copyBoxInto(sourceBox, nodeBox);
          removeBoxTransforms(boxWithoutTransform, node2.latestValues, node2.snapshot ? node2.snapshot.layoutBox : void 0, sourceBox);
        }
        if (hasTransform(this.latestValues)) {
          removeBoxTransforms(boxWithoutTransform, this.latestValues);
        }
        return boxWithoutTransform;
      }
      setTargetDelta(delta) {
        this.targetDelta = delta;
        this.root.scheduleUpdateProjection();
        this.isProjectionDirty = true;
      }
      setOptions(options) {
        this.options = {
          ...this.options,
          ...options,
          crossfade: options.crossfade !== void 0 ? options.crossfade : true
        };
      }
      clearMeasurements() {
        this.scroll = void 0;
        this.layout = void 0;
        this.snapshot = void 0;
        this.prevTransformTemplateValue = void 0;
        this.targetDelta = void 0;
        this.target = void 0;
        this.isLayoutDirty = false;
      }
      forceRelativeParentToResolveTarget() {
        if (!this.relativeParent)
          return;
        if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
          this.relativeParent.resolveTargetDelta(true);
        }
      }
      resolveTargetDelta(forceRecalculation = false) {
        const lead = this.getLead();
        this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
        this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
        this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
        if (canSkip)
          return;
        const { layout: layout2, layoutId } = this.options;
        if (!this.layout || !(layout2 || layoutId))
          return;
        this.resolvedRelativeTargetAt = frameData.timestamp;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && this.linkedParentVersion !== relativeParent.layoutVersion && !relativeParent.options.layoutRoot) {
          this.removeRelativeTarget();
        }
        if (!this.targetDelta && !this.relativeTarget) {
          if (relativeParent && relativeParent.layout) {
            this.createRelativeTarget(relativeParent, this.layout.layoutBox, relativeParent.layout.layoutBox);
          } else {
            this.removeRelativeTarget();
          }
        }
        if (!this.relativeTarget && !this.targetDelta)
          return;
        if (!this.target) {
          this.target = createBox();
          this.targetWithTransforms = createBox();
        }
        if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
          this.forceRelativeParentToResolveTarget();
          calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
        } else if (this.targetDelta) {
          if (Boolean(this.resumingFrom)) {
            this.target = this.applyTransform(this.layout.layoutBox);
          } else {
            copyBoxInto(this.target, this.layout.layoutBox);
          }
          applyBoxDelta(this.target, this.targetDelta);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        if (this.attemptToResolveRelativeTarget) {
          this.attemptToResolveRelativeTarget = false;
          if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
            this.createRelativeTarget(relativeParent, this.target, relativeParent.target);
          } else {
            this.relativeParent = this.relativeTarget = void 0;
          }
        }
      }
      getClosestProjectingParent() {
        if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
          return void 0;
        }
        if (this.parent.isProjecting()) {
          return this.parent;
        } else {
          return this.parent.getClosestProjectingParent();
        }
      }
      isProjecting() {
        return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
      }
      createRelativeTarget(relativeParent, layout2, parentLayout) {
        this.relativeParent = relativeParent;
        this.linkedParentVersion = relativeParent.layoutVersion;
        this.forceRelativeParentToResolveTarget();
        this.relativeTarget = createBox();
        this.relativeTargetOrigin = createBox();
        calcRelativePosition(this.relativeTargetOrigin, layout2, parentLayout);
        copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
      }
      removeRelativeTarget() {
        this.relativeParent = this.relativeTarget = void 0;
      }
      calcProjection() {
        const lead = this.getLead();
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        let canSkip = true;
        if (this.isProjectionDirty || this.parent?.isProjectionDirty) {
          canSkip = false;
        }
        if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
          canSkip = false;
        }
        if (this.resolvedRelativeTargetAt === frameData.timestamp) {
          canSkip = false;
        }
        if (canSkip)
          return;
        const { layout: layout2, layoutId } = this.options;
        this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
        if (!this.isTreeAnimating) {
          this.targetDelta = this.relativeTarget = void 0;
        }
        if (!this.layout || !(layout2 || layoutId))
          return;
        copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
        const prevTreeScaleX = this.treeScale.x;
        const prevTreeScaleY = this.treeScale.y;
        applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
        if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
          lead.target = lead.layout.layoutBox;
          lead.targetWithTransforms = createBox();
        }
        const { target } = lead;
        if (!target) {
          if (this.prevProjectionDelta) {
            this.createProjectionDeltas();
            this.scheduleRender();
          }
          return;
        }
        if (!this.projectionDelta || !this.prevProjectionDelta) {
          this.createProjectionDeltas();
        } else {
          copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
          copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
        }
        calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
        if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
          this.hasProjected = true;
          this.scheduleRender();
          this.notifyListeners("projectionUpdate", target);
        }
      }
      hide() {
        this.isVisible = false;
      }
      show() {
        this.isVisible = true;
      }
      scheduleRender(notifyAll2 = true) {
        this.options.visualElement?.scheduleRender();
        if (notifyAll2) {
          const stack2 = this.getStack();
          stack2 && stack2.scheduleRender();
        }
        if (this.resumingFrom && !this.resumingFrom.instance) {
          this.resumingFrom = void 0;
        }
      }
      createProjectionDeltas() {
        this.prevProjectionDelta = createDelta();
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
        const snapshot2 = this.snapshot;
        const snapshotLatestValues = snapshot2 ? snapshot2.latestValues : {};
        const mixedValues = { ...this.latestValues };
        const targetDelta = createDelta();
        if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
          this.relativeTarget = this.relativeTargetOrigin = void 0;
        }
        this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
        const relativeLayout = createBox();
        const snapshotSource = snapshot2 ? snapshot2.source : void 0;
        const layoutSource = this.layout ? this.layout.source : void 0;
        const isSharedLayoutAnimation = snapshotSource !== layoutSource;
        const stack2 = this.getStack();
        const isOnlyMember = !stack2 || stack2.members.length <= 1;
        const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
        this.animationProgress = 0;
        let prevRelativeTarget;
        this.mixTargetDelta = (latest) => {
          const progress2 = latest / 1e3;
          mixAxisDelta(targetDelta.x, delta.x, progress2);
          mixAxisDelta(targetDelta.y, delta.y, progress2);
          this.setTargetDelta(targetDelta);
          if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
            calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
            mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
            if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
              this.isProjectionDirty = false;
            }
            if (!prevRelativeTarget)
              prevRelativeTarget = createBox();
            copyBoxInto(prevRelativeTarget, this.relativeTarget);
          }
          if (isSharedLayoutAnimation) {
            this.animationValues = mixedValues;
            mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
          }
          this.root.scheduleUpdateProjection();
          this.scheduleRender();
          this.animationProgress = progress2;
        };
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
      }
      startAnimation(options) {
        this.notifyListeners("animationStart");
        this.currentAnimation?.stop();
        this.resumingFrom?.currentAnimation?.stop();
        if (this.pendingAnimation) {
          cancelFrame(this.pendingAnimation);
          this.pendingAnimation = void 0;
        }
        this.pendingAnimation = frame.update(() => {
          globalProjectionState.hasAnimatedSinceResize = true;
          this.motionValue || (this.motionValue = motionValue(0));
          this.motionValue.jump(0, false);
          this.currentAnimation = animateSingleValue(this.motionValue, [0, 1e3], {
            ...options,
            velocity: 0,
            isSync: true,
            onUpdate: (latest) => {
              this.mixTargetDelta(latest);
              options.onUpdate && options.onUpdate(latest);
            },
            onStop: () => {
            },
            onComplete: () => {
              options.onComplete && options.onComplete();
              this.completeAnimation();
            }
          });
          if (this.resumingFrom) {
            this.resumingFrom.currentAnimation = this.currentAnimation;
          }
          this.pendingAnimation = void 0;
        });
      }
      completeAnimation() {
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = void 0;
          this.resumingFrom.preserveOpacity = void 0;
        }
        const stack2 = this.getStack();
        stack2 && stack2.exitAnimationComplete();
        this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
        this.notifyListeners("animationComplete");
      }
      finishAnimation() {
        if (this.currentAnimation) {
          this.mixTargetDelta && this.mixTargetDelta(animationTarget);
          this.currentAnimation.stop();
        }
        this.completeAnimation();
      }
      applyTransformsToTarget() {
        const lead = this.getLead();
        let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
        if (!targetWithTransforms || !target || !layout2)
          return;
        if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
          target = this.target || createBox();
          const xLength = calcLength(this.layout.layoutBox.x);
          target.x.min = lead.target.x.min;
          target.x.max = target.x.min + xLength;
          const yLength = calcLength(this.layout.layoutBox.y);
          target.y.min = lead.target.y.min;
          target.y.max = target.y.min + yLength;
        }
        copyBoxInto(targetWithTransforms, target);
        transformBox(targetWithTransforms, latestValues);
        calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      }
      registerSharedNode(layoutId, node2) {
        if (!this.sharedNodes.has(layoutId)) {
          this.sharedNodes.set(layoutId, new NodeStack());
        }
        const stack2 = this.sharedNodes.get(layoutId);
        stack2.add(node2);
        const config = node2.options.initialPromotionConfig;
        node2.promote({
          transition: config ? config.transition : void 0,
          preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node2) : void 0
        });
      }
      isLead() {
        const stack2 = this.getStack();
        return stack2 ? stack2.lead === this : true;
      }
      getLead() {
        const { layoutId } = this.options;
        return layoutId ? this.getStack()?.lead || this : this;
      }
      getPrevLead() {
        const { layoutId } = this.options;
        return layoutId ? this.getStack()?.prevLead : void 0;
      }
      getStack() {
        const { layoutId } = this.options;
        if (layoutId)
          return this.root.sharedNodes.get(layoutId);
      }
      promote({ needsReset, transition, preserveFollowOpacity } = {}) {
        const stack2 = this.getStack();
        if (stack2)
          stack2.promote(this, preserveFollowOpacity);
        if (needsReset) {
          this.projectionDelta = void 0;
          this.needsReset = true;
        }
        if (transition)
          this.setOptions({ transition });
      }
      relegate() {
        const stack2 = this.getStack();
        if (stack2) {
          return stack2.relegate(this);
        } else {
          return false;
        }
      }
      resetSkewAndRotation() {
        const { visualElement } = this.options;
        if (!visualElement)
          return;
        let hasDistortingTransform = false;
        const { latestValues } = visualElement;
        if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
          hasDistortingTransform = true;
        }
        if (!hasDistortingTransform)
          return;
        const resetValues = {};
        if (latestValues.z) {
          resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
        }
        for (let i2 = 0; i2 < transformAxes.length; i2++) {
          resetDistortingTransform(`rotate${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
          resetDistortingTransform(`skew${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
        }
        visualElement.render();
        for (const key in resetValues) {
          visualElement.setStaticValue(key, resetValues[key]);
          if (this.animationValues) {
            this.animationValues[key] = resetValues[key];
          }
        }
        visualElement.scheduleRender();
      }
      applyProjectionStyles(targetStyle, styleProp) {
        if (!this.instance || this.isSVG)
          return;
        if (!this.isVisible) {
          targetStyle.visibility = "hidden";
          return;
        }
        const transformTemplate = this.getTransformTemplate();
        if (this.needsReset) {
          this.needsReset = false;
          targetStyle.visibility = "";
          targetStyle.opacity = "";
          targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "";
          targetStyle.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
          return;
        }
        const lead = this.getLead();
        if (!this.projectionDelta || !this.layout || !lead.target) {
          if (this.options.layoutId) {
            targetStyle.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
            targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "";
          }
          if (this.hasProjected && !hasTransform(this.latestValues)) {
            targetStyle.transform = transformTemplate ? transformTemplate({}, "") : "none";
            this.hasProjected = false;
          }
          return;
        }
        targetStyle.visibility = "";
        const valuesToRender = lead.animationValues || lead.latestValues;
        this.applyTransformsToTarget();
        let transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
        if (transformTemplate) {
          transform = transformTemplate(valuesToRender, transform);
        }
        targetStyle.transform = transform;
        const { x, y } = this.projectionDelta;
        targetStyle.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
        if (lead.animationValues) {
          targetStyle.opacity = lead === this ? valuesToRender.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
        } else {
          targetStyle.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
        }
        for (const key in scaleCorrectors) {
          if (valuesToRender[key] === void 0)
            continue;
          const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];
          const corrected = transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
          if (applyTo) {
            const num = applyTo.length;
            for (let i2 = 0; i2 < num; i2++) {
              targetStyle[applyTo[i2]] = corrected;
            }
          } else {
            if (isCSSVariable) {
              this.options.visualElement.renderState.vars[key] = corrected;
            } else {
              targetStyle[key] = corrected;
            }
          }
        }
        if (this.options.layoutId) {
          targetStyle.pointerEvents = lead === this ? resolveMotionValue(styleProp?.pointerEvents) || "" : "none";
        }
      }
      clearSnapshot() {
        this.resumeFrom = this.snapshot = void 0;
      }
resetTree() {
        this.root.nodes.forEach((node2) => node2.currentAnimation?.stop());
        this.root.nodes.forEach(clearMeasurements);
        this.root.sharedNodes.clear();
      }
    };
  }
  function updateLayout(node2) {
    node2.updateLayout();
  }
  function notifyLayoutUpdate(node2) {
    const snapshot2 = node2.resumeFrom?.snapshot || node2.snapshot;
    if (node2.isLead() && node2.layout && snapshot2 && node2.hasListeners("didUpdate")) {
      const { layoutBox: layout2, measuredBox: measuredLayout } = node2.layout;
      const { animationType } = node2.options;
      const isShared = snapshot2.source !== node2.layout.source;
      if (animationType === "size") {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot2.measuredBox[axis] : snapshot2.layoutBox[axis];
          const length2 = calcLength(axisSnapshot);
          axisSnapshot.min = layout2[axis].min;
          axisSnapshot.max = axisSnapshot.min + length2;
        });
      } else if (shouldAnimatePositionOnly(animationType, snapshot2.layoutBox, layout2)) {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot2.measuredBox[axis] : snapshot2.layoutBox[axis];
          const length2 = calcLength(layout2[axis]);
          axisSnapshot.max = axisSnapshot.min + length2;
          if (node2.relativeTarget && !node2.currentAnimation) {
            node2.isProjectionDirty = true;
            node2.relativeTarget[axis].max = node2.relativeTarget[axis].min + length2;
          }
        });
      }
      const layoutDelta = createDelta();
      calcBoxDelta(layoutDelta, layout2, snapshot2.layoutBox);
      const visualDelta = createDelta();
      if (isShared) {
        calcBoxDelta(visualDelta, node2.applyTransform(measuredLayout, true), snapshot2.measuredBox);
      } else {
        calcBoxDelta(visualDelta, layout2, snapshot2.layoutBox);
      }
      const hasLayoutChanged = !isDeltaZero(layoutDelta);
      let hasRelativeLayoutChanged = false;
      if (!node2.resumeFrom) {
        const relativeParent = node2.getClosestProjectingParent();
        if (relativeParent && !relativeParent.resumeFrom) {
          const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
          if (parentSnapshot && parentLayout) {
            const relativeSnapshot = createBox();
            calcRelativePosition(relativeSnapshot, snapshot2.layoutBox, parentSnapshot.layoutBox);
            const relativeLayout = createBox();
            calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
            if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
              hasRelativeLayoutChanged = true;
            }
            if (relativeParent.options.layoutRoot) {
              node2.relativeTarget = relativeLayout;
              node2.relativeTargetOrigin = relativeSnapshot;
              node2.relativeParent = relativeParent;
            }
          }
        }
      }
      node2.notifyListeners("didUpdate", {
        layout: layout2,
        snapshot: snapshot2,
        delta: visualDelta,
        layoutDelta,
        hasLayoutChanged,
        hasRelativeLayoutChanged
      });
    } else if (node2.isLead()) {
      const { onExitComplete } = node2.options;
      onExitComplete && onExitComplete();
    }
    node2.options.transition = void 0;
  }
  function propagateDirtyNodes(node2) {
    if (!node2.parent)
      return;
    if (!node2.isProjecting()) {
      node2.isProjectionDirty = node2.parent.isProjectionDirty;
    }
    node2.isSharedProjectionDirty || (node2.isSharedProjectionDirty = Boolean(node2.isProjectionDirty || node2.parent.isProjectionDirty || node2.parent.isSharedProjectionDirty));
    node2.isTransformDirty || (node2.isTransformDirty = node2.parent.isTransformDirty);
  }
  function cleanDirtyNodes(node2) {
    node2.isProjectionDirty = node2.isSharedProjectionDirty = node2.isTransformDirty = false;
  }
  function clearSnapshot(node2) {
    node2.clearSnapshot();
  }
  function clearMeasurements(node2) {
    node2.clearMeasurements();
  }
  function clearIsLayoutDirty(node2) {
    node2.isLayoutDirty = false;
  }
  function resetTransformStyle(node2) {
    const { visualElement } = node2.options;
    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
      visualElement.notify("BeforeLayoutMeasure");
    }
    node2.resetTransform();
  }
  function finishAnimation(node2) {
    node2.finishAnimation();
    node2.targetDelta = node2.relativeTarget = node2.target = void 0;
    node2.isProjectionDirty = true;
  }
  function resolveTargetDelta(node2) {
    node2.resolveTargetDelta();
  }
  function calcProjection(node2) {
    node2.calcProjection();
  }
  function resetSkewAndRotation(node2) {
    node2.resetSkewAndRotation();
  }
  function removeLeadSnapshots(stack2) {
    stack2.removeLeadSnapshot();
  }
  function mixAxisDelta(output, delta, p2) {
    output.translate = mixNumber$1(delta.translate, 0, p2);
    output.scale = mixNumber$1(delta.scale, 1, p2);
    output.origin = delta.origin;
    output.originPoint = delta.originPoint;
  }
  function mixAxis(output, from2, to, p2) {
    output.min = mixNumber$1(from2.min, to.min, p2);
    output.max = mixNumber$1(from2.max, to.max, p2);
  }
  function mixBox(output, from2, to, p2) {
    mixAxis(output.x, from2.x, to.x, p2);
    mixAxis(output.y, from2.y, to.y, p2);
  }
  function hasOpacityCrossfade(node2) {
    return node2.animationValues && node2.animationValues.opacityExit !== void 0;
  }
  const defaultLayoutTransition = {
    duration: 0.45,
    ease: [0.4, 0, 0.1, 1]
  };
  const userAgentContains = (string3) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string3);
  const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$1;
  function roundAxis(axis) {
    axis.min = roundPoint(axis.min);
    axis.max = roundPoint(axis.max);
  }
  function roundBox(box2) {
    roundAxis(box2.x);
    roundAxis(box2.y);
  }
  function shouldAnimatePositionOnly(animationType, snapshot2, layout2) {
    return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot2), aspectRatio(layout2), 0.2);
  }
  function checkNodeWasScrollRoot(node2) {
    return node2 !== node2.root && node2.scroll?.wasRoot;
  }
  const DocumentProjectionNode = createProjectionNode$1({
    attachResizeListener: (ref2, notify) => addDomEvent(ref2, "resize", notify),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body?.scrollLeft || 0,
      y: document.documentElement.scrollTop || document.body?.scrollTop || 0
    }),
    checkIsScrollRoot: () => true
  });
  const rootProjectionNode = {
    current: void 0
  };
  const HTMLProjectionNode = createProjectionNode$1({
    measureScroll: (instance) => ({
      x: instance.scrollLeft,
      y: instance.scrollTop
    }),
    defaultParent: () => {
      if (!rootProjectionNode.current) {
        const documentNode = new DocumentProjectionNode({});
        documentNode.mount(window);
        documentNode.setOptions({ layoutScroll: true });
        rootProjectionNode.current = documentNode;
      }
      return rootProjectionNode.current;
    },
    resetTransform: (instance, value) => {
      instance.style.transform = value !== void 0 ? value : "none";
    },
    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
  });
  const MotionConfigContext = reactExports.createContext({
    transformPagePoint: (p2) => p2,
    isStatic: false,
    reducedMotion: "never"
  });
  function setRef(ref2, value) {
    if (typeof ref2 === "function") {
      return ref2(value);
    } else if (ref2 !== null && ref2 !== void 0) {
      ref2.current = value;
    }
  }
  function composeRefs(...refs) {
    return (node2) => {
      let hasCleanup = false;
      const cleanups = refs.map((ref2) => {
        const cleanup2 = setRef(ref2, node2);
        if (!hasCleanup && typeof cleanup2 === "function") {
          hasCleanup = true;
        }
        return cleanup2;
      });
      if (hasCleanup) {
        return () => {
          for (let i2 = 0; i2 < cleanups.length; i2++) {
            const cleanup2 = cleanups[i2];
            if (typeof cleanup2 === "function") {
              cleanup2();
            } else {
              setRef(refs[i2], null);
            }
          }
        };
      }
    };
  }
  function useComposedRefs(...refs) {
    return reactExports.useCallback(composeRefs(...refs), refs);
  }
  class PopChildMeasure extends reactExports.Component {
    getSnapshotBeforeUpdate(prevProps) {
      const element = this.props.childRef.current;
      if (element && prevProps.isPresent && !this.props.isPresent && this.props.pop !== false) {
        const parent = element.offsetParent;
        const parentWidth = isHTMLElement$1(parent) ? parent.offsetWidth || 0 : 0;
        const parentHeight = isHTMLElement$1(parent) ? parent.offsetHeight || 0 : 0;
        const size = this.props.sizeRef.current;
        size.height = element.offsetHeight || 0;
        size.width = element.offsetWidth || 0;
        size.top = element.offsetTop;
        size.left = element.offsetLeft;
        size.right = parentWidth - size.width - size.left;
        size.bottom = parentHeight - size.height - size.top;
      }
      return null;
    }
componentDidUpdate() {
    }
    render() {
      return this.props.children;
    }
  }
  function PopChild({ children, isPresent, anchorX, anchorY, root: root2, pop }) {
    const id2 = reactExports.useId();
    const ref2 = reactExports.useRef(null);
    const size = reactExports.useRef({
      width: 0,
      height: 0,
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    });
    const { nonce } = reactExports.useContext(MotionConfigContext);
    const childRef = children.props?.ref ?? children?.ref;
    const composedRef = useComposedRefs(ref2, childRef);
    reactExports.useInsertionEffect(() => {
      const { width, height, top, left, right, bottom } = size.current;
      if (isPresent || pop === false || !ref2.current || !width || !height)
        return;
      const x = anchorX === "left" ? `left: ${left}` : `right: ${right}`;
      const y = anchorY === "bottom" ? `bottom: ${bottom}` : `top: ${top}`;
      ref2.current.dataset.motionPopId = id2;
      const style2 = document.createElement("style");
      if (nonce)
        style2.nonce = nonce;
      const parent = root2 ?? document.head;
      parent.appendChild(style2);
      if (style2.sheet) {
        style2.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            ${x}px !important;
            ${y}px !important;
          }
        `);
      }
      return () => {
        if (parent.contains(style2)) {
          parent.removeChild(style2);
        }
      };
    }, [isPresent]);
    return jsxRuntimeExports.jsx(PopChildMeasure, { isPresent, childRef: ref2, sizeRef: size, pop, children: pop === false ? children : reactExports.cloneElement(children, { ref: composedRef }) });
  }
  const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, anchorY, root: root2 }) => {
    const presenceChildren = useConstant(newChildrenMap);
    const id2 = reactExports.useId();
    let isReusedContext = true;
    let context = reactExports.useMemo(() => {
      isReusedContext = false;
      return {
        id: id2,
        initial,
        isPresent,
        custom,
        onExitComplete: (childId) => {
          presenceChildren.set(childId, true);
          for (const isComplete of presenceChildren.values()) {
            if (!isComplete)
              return;
          }
          onExitComplete && onExitComplete();
        },
        register: (childId) => {
          presenceChildren.set(childId, false);
          return () => presenceChildren.delete(childId);
        }
      };
    }, [isPresent, presenceChildren, onExitComplete]);
    if (presenceAffectsLayout && isReusedContext) {
      context = { ...context };
    }
    reactExports.useMemo(() => {
      presenceChildren.forEach((_2, key) => presenceChildren.set(key, false));
    }, [isPresent]);
    reactExports.useEffect(() => {
      !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
    }, [isPresent]);
    children = jsxRuntimeExports.jsx(PopChild, { pop: mode === "popLayout", isPresent, anchorX, anchorY, root: root2, children });
    return jsxRuntimeExports.jsx(PresenceContext.Provider, { value: context, children });
  };
  function newChildrenMap() {
    return new Map();
  }
  function usePresence(subscribe2 = true) {
    const context = reactExports.useContext(PresenceContext);
    if (context === null)
      return [true, null];
    const { isPresent, onExitComplete, register: register2 } = context;
    const id2 = reactExports.useId();
    reactExports.useEffect(() => {
      if (subscribe2) {
        return register2(id2);
      }
    }, [subscribe2]);
    const safeToRemove = reactExports.useCallback(() => subscribe2 && onExitComplete && onExitComplete(id2), [id2, onExitComplete, subscribe2]);
    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
  }
  const getChildKey = (child) => child.key || "";
  function onlyElements(children) {
    const filtered = [];
    reactExports.Children.forEach(children, (child) => {
      if (reactExports.isValidElement(child))
        filtered.push(child);
    });
    return filtered;
  }
  const AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", propagate = false, anchorX = "left", anchorY = "top", root: root2 }) => {
    const [isParentPresent, safeToRemove] = usePresence(propagate);
    const presentChildren = reactExports.useMemo(() => onlyElements(children), [children]);
    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
    const isInitialRender = reactExports.useRef(true);
    const pendingPresentChildren = reactExports.useRef(presentChildren);
    const exitComplete = useConstant(() => new Map());
    const exitingComponents = reactExports.useRef( new Set());
    const [diffedChildren, setDiffedChildren] = reactExports.useState(presentChildren);
    const [renderedChildren, setRenderedChildren] = reactExports.useState(presentChildren);
    useIsomorphicLayoutEffect$1(() => {
      isInitialRender.current = false;
      pendingPresentChildren.current = presentChildren;
      for (let i2 = 0; i2 < renderedChildren.length; i2++) {
        const key = getChildKey(renderedChildren[i2]);
        if (!presentKeys.includes(key)) {
          if (exitComplete.get(key) !== true) {
            exitComplete.set(key, false);
          }
        } else {
          exitComplete.delete(key);
          exitingComponents.current.delete(key);
        }
      }
    }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
    const exitingChildren = [];
    if (presentChildren !== diffedChildren) {
      let nextChildren = [...presentChildren];
      for (let i2 = 0; i2 < renderedChildren.length; i2++) {
        const child = renderedChildren[i2];
        const key = getChildKey(child);
        if (!presentKeys.includes(key)) {
          nextChildren.splice(i2, 0, child);
          exitingChildren.push(child);
        }
      }
      if (mode === "wait" && exitingChildren.length) {
        nextChildren = exitingChildren;
      }
      setRenderedChildren(onlyElements(nextChildren));
      setDiffedChildren(presentChildren);
      return null;
    }
    const { forceRender } = reactExports.useContext(LayoutGroupContext);
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: renderedChildren.map((child) => {
      const key = getChildKey(child);
      const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);
      const onExit = () => {
        if (exitingComponents.current.has(key)) {
          return;
        }
        exitingComponents.current.add(key);
        if (exitComplete.has(key)) {
          exitComplete.set(key, true);
        } else {
          return;
        }
        let isEveryExitComplete = true;
        exitComplete.forEach((isExitComplete) => {
          if (!isExitComplete)
            isEveryExitComplete = false;
        });
        if (isEveryExitComplete) {
          forceRender?.();
          setRenderedChildren(pendingPresentChildren.current);
          propagate && safeToRemove?.();
          onExitComplete && onExitComplete();
        }
      };
      return jsxRuntimeExports.jsx(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : false, custom, presenceAffectsLayout, mode, root: root2, onExitComplete: isPresent ? void 0 : onExit, anchorX, anchorY, children: child }, key);
    }) });
  };
  const LazyContext = reactExports.createContext({ strict: false });
  const featureProps = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag"
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
  };
  let isInitialized = false;
  function initFeatureDefinitions() {
    if (isInitialized)
      return;
    const initialFeatureDefinitions = {};
    for (const key in featureProps) {
      initialFeatureDefinitions[key] = {
        isEnabled: (props) => featureProps[key].some((name) => !!props[name])
      };
    }
    setFeatureDefinitions(initialFeatureDefinitions);
    isInitialized = true;
  }
  function getInitializedFeatureDefinitions() {
    initFeatureDefinitions();
    return getFeatureDefinitions();
  }
  function loadFeatures(features) {
    const featureDefinitions2 = getInitializedFeatureDefinitions();
    for (const key in features) {
      featureDefinitions2[key] = {
        ...featureDefinitions2[key],
        ...features[key]
      };
    }
    setFeatureDefinitions(featureDefinitions2);
  }
  const validMotionProps = new Set([
    "animate",
    "exit",
    "variants",
    "initial",
    "style",
    "values",
    "variants",
    "transition",
    "transformTemplate",
    "custom",
    "inherit",
    "onBeforeLayoutMeasure",
    "onAnimationStart",
    "onAnimationComplete",
    "onUpdate",
    "onDragStart",
    "onDrag",
    "onDragEnd",
    "onMeasureDragConstraints",
    "onDirectionLock",
    "onDragTransitionEnd",
    "_dragX",
    "_dragY",
    "onHoverStart",
    "onHoverEnd",
    "onViewportEnter",
    "onViewportLeave",
    "globalTapTarget",
    "propagate",
    "ignoreStrict",
    "viewport"
  ]);
  function isValidMotionProp(key) {
    return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
  }
  let shouldForward = (key) => !isValidMotionProp(key);
  function loadExternalIsValidProp(isValidProp) {
    if (typeof isValidProp !== "function")
      return;
    shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
  }
  try {
    loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
  } catch {
  }
  function filterProps(props, isDom, forwardMotionProps) {
    const filteredProps = {};
    for (const key in props) {
      if (key === "values" && typeof props.values === "object")
        continue;
      if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) ||
props["draggable"] && key.startsWith("onDrag")) {
        filteredProps[key] = props[key];
      }
    }
    return filteredProps;
  }
  const MotionContext = reactExports.createContext({});
  function getCurrentTreeVariants(props, context) {
    if (isControllingVariants(props)) {
      const { initial, animate } = props;
      return {
        initial: initial === false || isVariantLabel(initial) ? initial : void 0,
        animate: isVariantLabel(animate) ? animate : void 0
      };
    }
    return props.inherit !== false ? context : {};
  }
  function useCreateMotionContext(props) {
    const { initial, animate } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
    return reactExports.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
  }
  function variantLabelsAsDependency(prop) {
    return Array.isArray(prop) ? prop.join(" ") : prop;
  }
  const createHtmlRenderState = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
  });
  function copyRawValuesOnly(target, source, props) {
    for (const key in source) {
      if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
        target[key] = source[key];
      }
    }
  }
  function useInitialMotionValues({ transformTemplate }, visualState) {
    return reactExports.useMemo(() => {
      const state2 = createHtmlRenderState();
      buildHTMLStyles(state2, visualState, transformTemplate);
      return Object.assign({}, state2.vars, state2.style);
    }, [visualState]);
  }
  function useStyle(props, visualState) {
    const styleProp = props.style || {};
    const style2 = {};
    copyRawValuesOnly(style2, styleProp, props);
    Object.assign(style2, useInitialMotionValues(props, visualState));
    return style2;
  }
  function useHTMLProps(props, visualState) {
    const htmlProps = {};
    const style2 = useStyle(props, visualState);
    if (props.drag && props.dragListener !== false) {
      htmlProps.draggable = false;
      style2.userSelect = style2.WebkitUserSelect = style2.WebkitTouchCallout = "none";
      style2.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
    }
    if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
      htmlProps.tabIndex = 0;
    }
    htmlProps.style = style2;
    return htmlProps;
  }
  const createSvgRenderState = () => ({
    ...createHtmlRenderState(),
    attrs: {}
  });
  function useSVGProps(props, visualState, _isStatic, Component) {
    const visualProps = reactExports.useMemo(() => {
      const state2 = createSvgRenderState();
      buildSVGAttrs(state2, visualState, isSVGTag(Component), props.transformTemplate, props.style);
      return {
        ...state2.attrs,
        style: { ...state2.style }
      };
    }, [visualState]);
    if (props.style) {
      const rawStyles = {};
      copyRawValuesOnly(rawStyles, props.style, props);
      visualProps.style = { ...rawStyles, ...visualProps.style };
    }
    return visualProps;
  }
  const lowercaseSVGElements = [
    "animate",
    "circle",
    "defs",
    "desc",
    "ellipse",
    "g",
    "image",
    "line",
    "filter",
    "marker",
    "mask",
    "metadata",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "rect",
    "stop",
    "switch",
    "symbol",
    "svg",
    "text",
    "tspan",
    "use",
    "view"
  ];
  function isSVGComponent(Component) {
    if (
typeof Component !== "string" ||
Component.includes("-")
    ) {
      return false;
    } else if (
lowercaseSVGElements.indexOf(Component) > -1 ||
/[A-Z]/u.test(Component)
    ) {
      return true;
    }
    return false;
  }
  function useRender(Component, props, ref2, { latestValues }, isStatic, forwardMotionProps = false, isSVG) {
    const useVisualProps = isSVG ?? isSVGComponent(Component) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component);
    const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
    const elementProps = Component !== reactExports.Fragment ? { ...filteredProps, ...visualProps, ref: ref2 } : {};
    const { children } = props;
    const renderedChildren = reactExports.useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
    return reactExports.createElement(Component, {
      ...elementProps,
      children: renderedChildren
    });
  }
  function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState }, props, context, presenceContext) {
    const state2 = {
      latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
      renderState: createRenderState()
    };
    return state2;
  }
  function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
    const values = {};
    const motionValues = scrapeMotionValues(props, {});
    for (const key in motionValues) {
      values[key] = resolveMotionValue(motionValues[key]);
    }
    let { initial, animate } = props;
    const isControllingVariants$1 = isControllingVariants(props);
    const isVariantNode$1 = isVariantNode(props);
    if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
      if (initial === void 0)
        initial = context.initial;
      if (animate === void 0)
        animate = context.animate;
    }
    let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
    const variantToSet = isInitialAnimationBlocked ? animate : initial;
    if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
      const list2 = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
      for (let i2 = 0; i2 < list2.length; i2++) {
        const resolved = resolveVariantFromProps(props, list2[i2]);
        if (resolved) {
          const { transitionEnd, transition, ...target } = resolved;
          for (const key in target) {
            let valueTarget = target[key];
            if (Array.isArray(valueTarget)) {
              const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
              valueTarget = valueTarget[index];
            }
            if (valueTarget !== null) {
              values[key] = valueTarget;
            }
          }
          for (const key in transitionEnd) {
            values[key] = transitionEnd[key];
          }
        }
      }
    }
    return values;
  }
  const makeUseVisualState = (config) => (props, isStatic) => {
    const context = reactExports.useContext(MotionContext);
    const presenceContext = reactExports.useContext(PresenceContext);
    const make = () => makeState(config, props, context, presenceContext);
    return isStatic ? make() : useConstant(make);
  };
  const useHTMLVisualState = makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  });
  const useSVGVisualState = makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState
  });
  const motionComponentSymbol = Symbol.for("motionComponentSymbol");
  function useMotionRef(visualState, visualElement, externalRef) {
    const externalRefContainer = reactExports.useRef(externalRef);
    reactExports.useInsertionEffect(() => {
      externalRefContainer.current = externalRef;
    });
    const refCleanup = reactExports.useRef(null);
    return reactExports.useCallback((instance) => {
      if (instance) {
        visualState.onMount?.(instance);
      }
      if (visualElement) {
        instance ? visualElement.mount(instance) : visualElement.unmount();
      }
      const ref2 = externalRefContainer.current;
      if (typeof ref2 === "function") {
        if (instance) {
          const cleanup2 = ref2(instance);
          if (typeof cleanup2 === "function") {
            refCleanup.current = cleanup2;
          }
        } else if (refCleanup.current) {
          refCleanup.current();
          refCleanup.current = null;
        } else {
          ref2(instance);
        }
      } else if (ref2) {
        ref2.current = instance;
      }
    }, [visualElement]);
  }
  const SwitchLayoutGroupContext = reactExports.createContext({});
  function isRefObject(ref2) {
    return ref2 && typeof ref2 === "object" && Object.prototype.hasOwnProperty.call(ref2, "current");
  }
  function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor, isSVG) {
    const { visualElement: parent } = reactExports.useContext(MotionContext);
    const lazyContext = reactExports.useContext(LazyContext);
    const presenceContext = reactExports.useContext(PresenceContext);
    const motionConfig = reactExports.useContext(MotionConfigContext);
    const reducedMotionConfig = motionConfig.reducedMotion;
    const skipAnimations = motionConfig.skipAnimations;
    const visualElementRef = reactExports.useRef(null);
    const hasMountedOnce = reactExports.useRef(false);
    createVisualElement = createVisualElement || lazyContext.renderer;
    if (!visualElementRef.current && createVisualElement) {
      visualElementRef.current = createVisualElement(Component, {
        visualState,
        parent,
        props,
        presenceContext,
        blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
        reducedMotionConfig,
        skipAnimations,
        isSVG
      });
      if (hasMountedOnce.current && visualElementRef.current) {
        visualElementRef.current.manuallyAnimateOnMount = true;
      }
    }
    const visualElement = visualElementRef.current;
    const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
    if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
      createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
    }
    const isMounted = reactExports.useRef(false);
    reactExports.useInsertionEffect(() => {
      if (visualElement && isMounted.current) {
        visualElement.update(props, presenceContext);
      }
    });
    const optimisedAppearId = props[optimizedAppearDataAttribute];
    const wantsHandoff = reactExports.useRef(Boolean(optimisedAppearId) && !window.MotionHandoffIsComplete?.(optimisedAppearId) && window.MotionHasOptimisedAnimation?.(optimisedAppearId));
    useIsomorphicLayoutEffect$1(() => {
      hasMountedOnce.current = true;
      if (!visualElement)
        return;
      isMounted.current = true;
      window.MotionIsMounted = true;
      visualElement.updateFeatures();
      visualElement.scheduleRenderMicrotask();
      if (wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
    });
    reactExports.useEffect(() => {
      if (!visualElement)
        return;
      if (!wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
      if (wantsHandoff.current) {
        queueMicrotask(() => {
          window.MotionHandoffMarkAsComplete?.(optimisedAppearId);
        });
        wantsHandoff.current = false;
      }
      visualElement.enteringChildren = void 0;
    });
    return visualElement;
  }
  function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
    const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade } = props;
    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
    visualElement.projection.setOptions({
      layoutId,
      layout: layout2,
      alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
      visualElement,
animationType: typeof layout2 === "string" ? layout2 : "both",
      initialPromotionConfig,
      crossfade: layoutCrossfade,
      layoutScroll,
      layoutRoot
    });
  }
  function getClosestProjectingNode(visualElement) {
    if (!visualElement)
      return void 0;
    return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
  }
  function createMotionComponent(Component, { forwardMotionProps = false, type: type4 } = {}, preloadedFeatures, createVisualElement) {
    preloadedFeatures && loadFeatures(preloadedFeatures);
    const isSVG = type4 ? type4 === "svg" : isSVGComponent(Component);
    const useVisualState = isSVG ? useSVGVisualState : useHTMLVisualState;
    function MotionDOMComponent(props, externalRef) {
      let MeasureLayout2;
      const configAndProps = {
        ...reactExports.useContext(MotionConfigContext),
        ...props,
        layoutId: useLayoutId(props)
      };
      const { isStatic } = configAndProps;
      const context = useCreateMotionContext(props);
      const visualState = useVisualState(props, isStatic);
      if (!isStatic && isBrowser$3) {
        useStrictMode();
        const layoutProjection = getProjectionFunctionality(configAndProps);
        MeasureLayout2 = layoutProjection.MeasureLayout;
        context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode, isSVG);
      }
      return jsxRuntimeExports.jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? jsxRuntimeExports.jsx(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps, isSVG)] });
    }
    MotionDOMComponent.displayName = `motion.${typeof Component === "string" ? Component : `create(${Component.displayName ?? Component.name ?? ""})`}`;
    const ForwardRefMotionComponent = reactExports.forwardRef(MotionDOMComponent);
    ForwardRefMotionComponent[motionComponentSymbol] = Component;
    return ForwardRefMotionComponent;
  }
  function useLayoutId({ layoutId }) {
    const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
    return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
  }
  function useStrictMode(configAndProps, preloadedFeatures) {
    reactExports.useContext(LazyContext).strict;
  }
  function getProjectionFunctionality(props) {
    const featureDefinitions2 = getInitializedFeatureDefinitions();
    const { drag: drag2, layout: layout2 } = featureDefinitions2;
    if (!drag2 && !layout2)
      return {};
    const combined = { ...drag2, ...layout2 };
    return {
      MeasureLayout: drag2?.isEnabled(props) || layout2?.isEnabled(props) ? combined.MeasureLayout : void 0,
      ProjectionNode: combined.ProjectionNode
    };
  }
  function createMotionProxy(preloadedFeatures, createVisualElement) {
    if (typeof Proxy === "undefined") {
      return createMotionComponent;
    }
    const componentCache = new Map();
    const factory = (Component, options) => {
      return createMotionComponent(Component, options, preloadedFeatures, createVisualElement);
    };
    const deprecatedFactoryFunction = (Component, options) => {
      return factory(Component, options);
    };
    return new Proxy(deprecatedFactoryFunction, {
get: (_target, key) => {
        if (key === "create")
          return factory;
        if (!componentCache.has(key)) {
          componentCache.set(key, createMotionComponent(key, void 0, preloadedFeatures, createVisualElement));
        }
        return componentCache.get(key);
      }
    });
  }
  const createDomVisualElement = (Component, options) => {
    const isSVG = options.isSVG ?? isSVGComponent(Component);
    return isSVG ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
      allowProjection: Component !== reactExports.Fragment
    });
  };
  class AnimationFeature extends Feature {
constructor(node2) {
      super(node2);
      node2.animationState || (node2.animationState = createAnimationState(node2));
    }
    updateAnimationControlsSubscription() {
      const { animate } = this.node.getProps();
      if (isAnimationControls(animate)) {
        this.unmountControls = animate.subscribe(this.node);
      }
    }
mount() {
      this.updateAnimationControlsSubscription();
    }
    update() {
      const { animate } = this.node.getProps();
      const { animate: prevAnimate } = this.node.prevProps || {};
      if (animate !== prevAnimate) {
        this.updateAnimationControlsSubscription();
      }
    }
    unmount() {
      this.node.animationState.reset();
      this.unmountControls?.();
    }
  }
  let id = 0;
  class ExitAnimationFeature extends Feature {
    constructor() {
      super(...arguments);
      this.id = id++;
    }
    update() {
      if (!this.node.presenceContext)
        return;
      const { isPresent, onExitComplete } = this.node.presenceContext;
      const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
      if (!this.node.animationState || isPresent === prevIsPresent) {
        return;
      }
      const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
      if (onExitComplete && !isPresent) {
        exitAnimation.then(() => {
          onExitComplete(this.id);
        });
      }
    }
    mount() {
      const { register: register2, onExitComplete } = this.node.presenceContext || {};
      if (onExitComplete) {
        onExitComplete(this.id);
      }
      if (register2) {
        this.unmount = register2(this.id);
      }
    }
    unmount() {
    }
  }
  const animations = {
    animation: {
      Feature: AnimationFeature
    },
    exit: {
      Feature: ExitAnimationFeature
    }
  };
  function extractEventInfo(event) {
    return {
      point: {
        x: event.pageX,
        y: event.pageY
      }
    };
  }
  const addPointerInfo = (handler) => {
    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
  };
  function addPointerEvent(target, eventName, handler, options) {
    return addDomEvent(target, eventName, addPointerInfo(handler), options);
  }
  const getContextWindow = ({ current }) => {
    return current ? current.ownerDocument.defaultView : null;
  };
  const distance = (a2, b) => Math.abs(a2 - b);
  function distance2D(a2, b) {
    const xDelta = distance(a2.x, b.x);
    const yDelta = distance(a2.y, b.y);
    return Math.sqrt(xDelta ** 2 + yDelta ** 2);
  }
  const overflowStyles = new Set(["auto", "scroll"]);
  class PanSession {
    constructor(event, handlers2, { transformPagePoint, contextWindow = window, dragSnapToOrigin = false, distanceThreshold = 3, element } = {}) {
      this.startEvent = null;
      this.lastMoveEvent = null;
      this.lastMoveEventInfo = null;
      this.handlers = {};
      this.contextWindow = window;
      this.scrollPositions = new Map();
      this.removeScrollListeners = null;
      this.onElementScroll = (event2) => {
        this.handleScroll(event2.target);
      };
      this.onWindowScroll = () => {
        this.handleScroll(window);
      };
      this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo))
          return;
        const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
        const isPanStarted = this.startEvent !== null;
        const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
        if (!isPanStarted && !isDistancePastThreshold)
          return;
        const { point: point2 } = info2;
        const { timestamp: timestamp2 } = frameData;
        this.history.push({ ...point2, timestamp: timestamp2 });
        const { onStart, onMove } = this.handlers;
        if (!isPanStarted) {
          onStart && onStart(this.lastMoveEvent, info2);
          this.startEvent = this.lastMoveEvent;
        }
        onMove && onMove(this.lastMoveEvent, info2);
      };
      this.handlePointerMove = (event2, info2) => {
        this.lastMoveEvent = event2;
        this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
        frame.update(this.updatePoint, true);
      };
      this.handlePointerUp = (event2, info2) => {
        this.end();
        const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
        if (this.dragSnapToOrigin || !this.startEvent) {
          resumeAnimation && resumeAnimation();
        }
        if (!(this.lastMoveEvent && this.lastMoveEventInfo))
          return;
        const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
        if (this.startEvent && onEnd) {
          onEnd(event2, panInfo);
        }
        onSessionEnd && onSessionEnd(event2, panInfo);
      };
      if (!isPrimaryPointer(event))
        return;
      this.dragSnapToOrigin = dragSnapToOrigin;
      this.handlers = handlers2;
      this.transformPagePoint = transformPagePoint;
      this.distanceThreshold = distanceThreshold;
      this.contextWindow = contextWindow || window;
      const info = extractEventInfo(event);
      const initialInfo = transformPoint(info, this.transformPagePoint);
      const { point } = initialInfo;
      const { timestamp } = frameData;
      this.history = [{ ...point, timestamp }];
      const { onSessionStart } = handlers2;
      onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
      this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
      if (element) {
        this.startScrollTracking(element);
      }
    }
startScrollTracking(element) {
      let current = element.parentElement;
      while (current) {
        const style2 = getComputedStyle(current);
        if (overflowStyles.has(style2.overflowX) || overflowStyles.has(style2.overflowY)) {
          this.scrollPositions.set(current, {
            x: current.scrollLeft,
            y: current.scrollTop
          });
        }
        current = current.parentElement;
      }
      this.scrollPositions.set(window, {
        x: window.scrollX,
        y: window.scrollY
      });
      window.addEventListener("scroll", this.onElementScroll, {
        capture: true
      });
      window.addEventListener("scroll", this.onWindowScroll);
      this.removeScrollListeners = () => {
        window.removeEventListener("scroll", this.onElementScroll, {
          capture: true
        });
        window.removeEventListener("scroll", this.onWindowScroll);
      };
    }
handleScroll(target) {
      const initial = this.scrollPositions.get(target);
      if (!initial)
        return;
      const isWindow2 = target === window;
      const current = isWindow2 ? { x: window.scrollX, y: window.scrollY } : {
        x: target.scrollLeft,
        y: target.scrollTop
      };
      const delta = { x: current.x - initial.x, y: current.y - initial.y };
      if (delta.x === 0 && delta.y === 0)
        return;
      if (isWindow2) {
        if (this.lastMoveEventInfo) {
          this.lastMoveEventInfo.point.x += delta.x;
          this.lastMoveEventInfo.point.y += delta.y;
        }
      } else {
        if (this.history.length > 0) {
          this.history[0].x -= delta.x;
          this.history[0].y -= delta.y;
        }
      }
      this.scrollPositions.set(target, current);
      frame.update(this.updatePoint, true);
    }
    updateHandlers(handlers2) {
      this.handlers = handlers2;
    }
    end() {
      this.removeListeners && this.removeListeners();
      this.removeScrollListeners && this.removeScrollListeners();
      this.scrollPositions.clear();
      cancelFrame(this.updatePoint);
    }
  }
  function transformPoint(info, transformPagePoint) {
    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
  }
  function subtractPoint(a2, b) {
    return { x: a2.x - b.x, y: a2.y - b.y };
  }
  function getPanInfo({ point }, history2) {
    return {
      point,
      delta: subtractPoint(point, lastDevicePoint(history2)),
      offset: subtractPoint(point, startDevicePoint(history2)),
      velocity: getVelocity(history2, 0.1)
    };
  }
  function startDevicePoint(history2) {
    return history2[0];
  }
  function lastDevicePoint(history2) {
    return history2[history2.length - 1];
  }
  function getVelocity(history2, timeDelta) {
    if (history2.length < 2) {
      return { x: 0, y: 0 };
    }
    let i2 = history2.length - 1;
    let timestampedPoint = null;
    const lastPoint = lastDevicePoint(history2);
    while (i2 >= 0) {
      timestampedPoint = history2[i2];
      if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
        break;
      }
      i2--;
    }
    if (!timestampedPoint) {
      return { x: 0, y: 0 };
    }
    if (timestampedPoint === history2[0] && history2.length > 2 && lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta) * 2) {
      timestampedPoint = history2[1];
    }
    const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
    if (time2 === 0) {
      return { x: 0, y: 0 };
    }
    const currentVelocity = {
      x: (lastPoint.x - timestampedPoint.x) / time2,
      y: (lastPoint.y - timestampedPoint.y) / time2
    };
    if (currentVelocity.x === Infinity) {
      currentVelocity.x = 0;
    }
    if (currentVelocity.y === Infinity) {
      currentVelocity.y = 0;
    }
    return currentVelocity;
  }
  function applyConstraints(point, { min, max }, elastic) {
    if (min !== void 0 && point < min) {
      point = elastic ? mixNumber$1(min, point, elastic.min) : Math.max(point, min);
    } else if (max !== void 0 && point > max) {
      point = elastic ? mixNumber$1(max, point, elastic.max) : Math.min(point, max);
    }
    return point;
  }
  function calcRelativeAxisConstraints(axis, min, max) {
    return {
      min: min !== void 0 ? axis.min + min : void 0,
      max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
    };
  }
  function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
    return {
      x: calcRelativeAxisConstraints(layoutBox.x, left, right),
      y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
    };
  }
  function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
    let min = constraintsAxis.min - layoutAxis.min;
    let max = constraintsAxis.max - layoutAxis.max;
    if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
      [min, max] = [max, min];
    }
    return { min, max };
  }
  function calcViewportConstraints(layoutBox, constraintsBox) {
    return {
      x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
      y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
    };
  }
  function calcOrigin(source, target) {
    let origin = 0.5;
    const sourceLength = calcLength(source);
    const targetLength = calcLength(target);
    if (targetLength > sourceLength) {
      origin = progress(target.min, target.max - sourceLength, source.min);
    } else if (sourceLength > targetLength) {
      origin = progress(source.min, source.max - targetLength, target.min);
    }
    return clamp(0, 1, origin);
  }
  function rebaseAxisConstraints(layout2, constraints) {
    const relativeConstraints = {};
    if (constraints.min !== void 0) {
      relativeConstraints.min = constraints.min - layout2.min;
    }
    if (constraints.max !== void 0) {
      relativeConstraints.max = constraints.max - layout2.min;
    }
    return relativeConstraints;
  }
  const defaultElastic = 0.35;
  function resolveDragElastic(dragElastic = defaultElastic) {
    if (dragElastic === false) {
      dragElastic = 0;
    } else if (dragElastic === true) {
      dragElastic = defaultElastic;
    }
    return {
      x: resolveAxisElastic(dragElastic, "left", "right"),
      y: resolveAxisElastic(dragElastic, "top", "bottom")
    };
  }
  function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
    return {
      min: resolvePointElastic(dragElastic, minLabel),
      max: resolvePointElastic(dragElastic, maxLabel)
    };
  }
  function resolvePointElastic(dragElastic, label) {
    return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
  }
  const elementDragControls = new WeakMap();
  class VisualElementDragControls {
    constructor(visualElement) {
      this.openDragLock = null;
      this.isDragging = false;
      this.currentDirection = null;
      this.originPoint = { x: 0, y: 0 };
      this.constraints = false;
      this.hasMutatedConstraints = false;
      this.elastic = createBox();
      this.latestPointerEvent = null;
      this.latestPanInfo = null;
      this.visualElement = visualElement;
    }
    start(originEvent, { snapToCursor = false, distanceThreshold } = {}) {
      const { presenceContext } = this.visualElement;
      if (presenceContext && presenceContext.isPresent === false)
        return;
      const onSessionStart = (event) => {
        if (snapToCursor) {
          this.snapToCursor(extractEventInfo(event).point);
        }
        this.stopAnimation();
      };
      const onStart = (event, info) => {
        const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
        if (drag2 && !dragPropagation) {
          if (this.openDragLock)
            this.openDragLock();
          this.openDragLock = setDragLock(drag2);
          if (!this.openDragLock)
            return;
        }
        this.latestPointerEvent = event;
        this.latestPanInfo = info;
        this.isDragging = true;
        this.currentDirection = null;
        this.resolveConstraints();
        if (this.visualElement.projection) {
          this.visualElement.projection.isAnimationBlocked = true;
          this.visualElement.projection.target = void 0;
        }
        eachAxis((axis) => {
          let current = this.getAxisMotionValue(axis).get() || 0;
          if (percent.test(current)) {
            const { projection } = this.visualElement;
            if (projection && projection.layout) {
              const measuredAxis = projection.layout.layoutBox[axis];
              if (measuredAxis) {
                const length2 = calcLength(measuredAxis);
                current = length2 * (parseFloat(current) / 100);
              }
            }
          }
          this.originPoint[axis] = current;
        });
        if (onDragStart) {
          frame.update(() => onDragStart(event, info), false, true);
        }
        addValueToWillChange(this.visualElement, "transform");
        const { animationState } = this.visualElement;
        animationState && animationState.setActive("whileDrag", true);
      };
      const onMove = (event, info) => {
        this.latestPointerEvent = event;
        this.latestPanInfo = info;
        const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
        if (!dragPropagation && !this.openDragLock)
          return;
        const { offset: offset2 } = info;
        if (dragDirectionLock && this.currentDirection === null) {
          this.currentDirection = getCurrentDirection(offset2);
          if (this.currentDirection !== null) {
            onDirectionLock && onDirectionLock(this.currentDirection);
          }
          return;
        }
        this.updateAxis("x", info.point, offset2);
        this.updateAxis("y", info.point, offset2);
        this.visualElement.render();
        if (onDrag) {
          frame.update(() => onDrag(event, info), false, true);
        }
      };
      const onSessionEnd = (event, info) => {
        this.latestPointerEvent = event;
        this.latestPanInfo = info;
        this.stop(event, info);
        this.latestPointerEvent = null;
        this.latestPanInfo = null;
      };
      const resumeAnimation = () => {
        const { dragSnapToOrigin: snap } = this.getProps();
        if (snap || this.constraints) {
          this.startAnimation({ x: 0, y: 0 });
        }
      };
      const { dragSnapToOrigin } = this.getProps();
      this.panSession = new PanSession(originEvent, {
        onSessionStart,
        onStart,
        onMove,
        onSessionEnd,
        resumeAnimation
      }, {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin,
        distanceThreshold,
        contextWindow: getContextWindow(this.visualElement),
        element: this.visualElement.current
      });
    }
stop(event, panInfo) {
      const finalEvent = event || this.latestPointerEvent;
      const finalPanInfo = panInfo || this.latestPanInfo;
      const isDragging2 = this.isDragging;
      this.cancel();
      if (!isDragging2 || !finalPanInfo || !finalEvent)
        return;
      const { velocity } = finalPanInfo;
      this.startAnimation(velocity);
      const { onDragEnd } = this.getProps();
      if (onDragEnd) {
        frame.postRender(() => onDragEnd(finalEvent, finalPanInfo));
      }
    }
cancel() {
      this.isDragging = false;
      const { projection, animationState } = this.visualElement;
      if (projection) {
        projection.isAnimationBlocked = false;
      }
      this.endPanSession();
      const { dragPropagation } = this.getProps();
      if (!dragPropagation && this.openDragLock) {
        this.openDragLock();
        this.openDragLock = null;
      }
      animationState && animationState.setActive("whileDrag", false);
    }
endPanSession() {
      this.panSession && this.panSession.end();
      this.panSession = void 0;
    }
    updateAxis(axis, _point, offset2) {
      const { drag: drag2 } = this.getProps();
      if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      let next2 = this.originPoint[axis] + offset2[axis];
      if (this.constraints && this.constraints[axis]) {
        next2 = applyConstraints(next2, this.constraints[axis], this.elastic[axis]);
      }
      axisValue.set(next2);
    }
    resolveConstraints() {
      const { dragConstraints, dragElastic } = this.getProps();
      const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : this.visualElement.projection?.layout;
      const prevConstraints = this.constraints;
      if (dragConstraints && isRefObject(dragConstraints)) {
        if (!this.constraints) {
          this.constraints = this.resolveRefConstraints();
        }
      } else {
        if (dragConstraints && layout2) {
          this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
        } else {
          this.constraints = false;
        }
      }
      this.elastic = resolveDragElastic(dragElastic);
      if (prevConstraints !== this.constraints && !isRefObject(dragConstraints) && layout2 && this.constraints && !this.hasMutatedConstraints) {
        eachAxis((axis) => {
          if (this.constraints !== false && this.getAxisMotionValue(axis)) {
            this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
          }
        });
      }
    }
    resolveRefConstraints() {
      const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
      if (!constraints || !isRefObject(constraints))
        return false;
      const constraintsElement = constraints.current;
      const { projection } = this.visualElement;
      if (!projection || !projection.layout)
        return false;
      const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
      let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
      if (onMeasureDragConstraints) {
        const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
        this.hasMutatedConstraints = !!userConstraints;
        if (userConstraints) {
          measuredConstraints = convertBoundingBoxToBox(userConstraints);
        }
      }
      return measuredConstraints;
    }
    startAnimation(velocity) {
      const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
      const constraints = this.constraints || {};
      const momentumAnimations = eachAxis((axis) => {
        if (!shouldDrag(axis, drag2, this.currentDirection)) {
          return;
        }
        let transition = constraints && constraints[axis] || {};
        if (dragSnapToOrigin)
          transition = { min: 0, max: 0 };
        const bounceStiffness = dragElastic ? 200 : 1e6;
        const bounceDamping = dragElastic ? 40 : 1e7;
        const inertia2 = {
          type: "inertia",
          velocity: dragMomentum ? velocity[axis] : 0,
          bounceStiffness,
          bounceDamping,
          timeConstant: 750,
          restDelta: 1,
          restSpeed: 10,
          ...dragTransition,
          ...transition
        };
        return this.startAxisValueAnimation(axis, inertia2);
      });
      return Promise.all(momentumAnimations).then(onDragTransitionEnd);
    }
    startAxisValueAnimation(axis, transition) {
      const axisValue = this.getAxisMotionValue(axis);
      addValueToWillChange(this.visualElement, axis);
      return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
    }
    stopAnimation() {
      eachAxis((axis) => this.getAxisMotionValue(axis).stop());
    }
getAxisMotionValue(axis) {
      const dragKey = `_drag${axis.toUpperCase()}`;
      const props = this.visualElement.getProps();
      const externalMotionValue = props[dragKey];
      return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
    }
    snapToCursor(point) {
      eachAxis((axis) => {
        const { drag: drag2 } = this.getProps();
        if (!shouldDrag(axis, drag2, this.currentDirection))
          return;
        const { projection } = this.visualElement;
        const axisValue = this.getAxisMotionValue(axis);
        if (projection && projection.layout) {
          const { min, max } = projection.layout.layoutBox[axis];
          const current = axisValue.get() || 0;
          axisValue.set(point[axis] - mixNumber$1(min, max, 0.5) + current);
        }
      });
    }
scalePositionWithinConstraints() {
      if (!this.visualElement.current)
        return;
      const { drag: drag2, dragConstraints } = this.getProps();
      const { projection } = this.visualElement;
      if (!isRefObject(dragConstraints) || !projection || !this.constraints)
        return;
      this.stopAnimation();
      const boxProgress = { x: 0, y: 0 };
      eachAxis((axis) => {
        const axisValue = this.getAxisMotionValue(axis);
        if (axisValue && this.constraints !== false) {
          const latest = axisValue.get();
          boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
        }
      });
      const { transformTemplate } = this.visualElement.getProps();
      this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
      this.constraints = false;
      this.resolveConstraints();
      eachAxis((axis) => {
        if (!shouldDrag(axis, drag2, null))
          return;
        const axisValue = this.getAxisMotionValue(axis);
        const { min, max } = this.constraints[axis];
        axisValue.set(mixNumber$1(min, max, boxProgress[axis]));
      });
      this.visualElement.render();
    }
    addListeners() {
      if (!this.visualElement.current)
        return;
      elementDragControls.set(this.visualElement, this);
      const element = this.visualElement.current;
      const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
        const { drag: drag2, dragListener = true } = this.getProps();
        const target = event.target;
        const isClickingTextInputChild = target !== element && isElementTextInput(target);
        if (drag2 && dragListener && !isClickingTextInputChild) {
          this.start(event);
        }
      });
      let stopResizeObservers;
      const measureDragConstraints = () => {
        const { dragConstraints } = this.getProps();
        if (isRefObject(dragConstraints) && dragConstraints.current) {
          this.constraints = this.resolveRefConstraints();
          if (!stopResizeObservers) {
            stopResizeObservers = startResizeObservers(element, dragConstraints.current, () => this.scalePositionWithinConstraints());
          }
        }
      };
      const { projection } = this.visualElement;
      const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
      if (projection && !projection.layout) {
        projection.root && projection.root.updateScroll();
        projection.updateLayout();
      }
      frame.read(measureDragConstraints);
      const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
      const stopLayoutUpdateListener = projection.addEventListener("didUpdate", (({ delta, hasLayoutChanged }) => {
        if (this.isDragging && hasLayoutChanged) {
          eachAxis((axis) => {
            const motionValue2 = this.getAxisMotionValue(axis);
            if (!motionValue2)
              return;
            this.originPoint[axis] += delta[axis].translate;
            motionValue2.set(motionValue2.get() + delta[axis].translate);
          });
          this.visualElement.render();
        }
      }));
      return () => {
        stopResizeListener();
        stopPointerListener();
        stopMeasureLayoutListener();
        stopLayoutUpdateListener && stopLayoutUpdateListener();
        stopResizeObservers && stopResizeObservers();
      };
    }
    getProps() {
      const props = this.visualElement.getProps();
      const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
      return {
        ...props,
        drag: drag2,
        dragDirectionLock,
        dragPropagation,
        dragConstraints,
        dragElastic,
        dragMomentum
      };
    }
  }
  function skipFirstCall(callback) {
    let isFirst = true;
    return () => {
      if (isFirst) {
        isFirst = false;
        return;
      }
      callback();
    };
  }
  function startResizeObservers(element, constraintsElement, onResize2) {
    const stopElement = resize(element, skipFirstCall(onResize2));
    const stopContainer = resize(constraintsElement, skipFirstCall(onResize2));
    return () => {
      stopElement();
      stopContainer();
    };
  }
  function shouldDrag(direction, drag2, currentDirection) {
    return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
  }
  function getCurrentDirection(offset2, lockThreshold = 10) {
    let direction = null;
    if (Math.abs(offset2.y) > lockThreshold) {
      direction = "y";
    } else if (Math.abs(offset2.x) > lockThreshold) {
      direction = "x";
    }
    return direction;
  }
  class DragGesture extends Feature {
    constructor(node2) {
      super(node2);
      this.removeGroupControls = noop$1;
      this.removeListeners = noop$1;
      this.controls = new VisualElementDragControls(node2);
    }
    mount() {
      const { dragControls } = this.node.getProps();
      if (dragControls) {
        this.removeGroupControls = dragControls.subscribe(this.controls);
      }
      this.removeListeners = this.controls.addListeners() || noop$1;
    }
    update() {
      const { dragControls } = this.node.getProps();
      const { dragControls: prevDragControls } = this.node.prevProps || {};
      if (dragControls !== prevDragControls) {
        this.removeGroupControls();
        if (dragControls) {
          this.removeGroupControls = dragControls.subscribe(this.controls);
        }
      }
    }
    unmount() {
      this.removeGroupControls();
      this.removeListeners();
      if (!this.controls.isDragging) {
        this.controls.endPanSession();
      }
    }
  }
  const asyncHandler = (handler) => (event, info) => {
    if (handler) {
      frame.update(() => handler(event, info), false, true);
    }
  };
  class PanGesture extends Feature {
    constructor() {
      super(...arguments);
      this.removePointerDownListener = noop$1;
    }
    onPointerDown(pointerDownEvent) {
      this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
        transformPagePoint: this.node.getTransformPagePoint(),
        contextWindow: getContextWindow(this.node)
      });
    }
    createPanHandlers() {
      const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
      return {
        onSessionStart: asyncHandler(onPanSessionStart),
        onStart: asyncHandler(onPanStart),
        onMove: asyncHandler(onPan),
        onEnd: (event, info) => {
          delete this.session;
          if (onPanEnd) {
            frame.postRender(() => onPanEnd(event, info));
          }
        }
      };
    }
    mount() {
      this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
    }
    update() {
      this.session && this.session.updateHandlers(this.createPanHandlers());
    }
    unmount() {
      this.removePointerDownListener();
      this.session && this.session.end();
    }
  }
  let hasTakenAnySnapshot = false;
  class MeasureLayoutWithContext extends reactExports.Component {
componentDidMount() {
      const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
      const { projection } = visualElement;
      if (projection) {
        if (layoutGroup.group)
          layoutGroup.group.add(projection);
        if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
          switchLayoutGroup.register(projection);
        }
        if (hasTakenAnySnapshot) {
          projection.root.didUpdate();
        }
        projection.addEventListener("animationComplete", () => {
          this.safeToRemove();
        });
        projection.setOptions({
          ...projection.options,
          layoutDependency: this.props.layoutDependency,
          onExitComplete: () => this.safeToRemove()
        });
      }
      globalProjectionState.hasEverUpdated = true;
    }
    getSnapshotBeforeUpdate(prevProps) {
      const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
      const { projection } = visualElement;
      if (!projection)
        return null;
      projection.isPresent = isPresent;
      if (prevProps.layoutDependency !== layoutDependency) {
        projection.setOptions({
          ...projection.options,
          layoutDependency
        });
      }
      hasTakenAnySnapshot = true;
      if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 || prevProps.isPresent !== isPresent) {
        projection.willUpdate();
      } else {
        this.safeToRemove();
      }
      if (prevProps.isPresent !== isPresent) {
        if (isPresent) {
          projection.promote();
        } else if (!projection.relegate()) {
          frame.postRender(() => {
            const stack2 = projection.getStack();
            if (!stack2 || !stack2.members.length) {
              this.safeToRemove();
            }
          });
        }
      }
      return null;
    }
    componentDidUpdate() {
      const { projection } = this.props.visualElement;
      if (projection) {
        projection.root.didUpdate();
        microtask.postRender(() => {
          if (!projection.currentAnimation && projection.isLead()) {
            this.safeToRemove();
          }
        });
      }
    }
    componentWillUnmount() {
      const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
      const { projection } = visualElement;
      hasTakenAnySnapshot = true;
      if (projection) {
        projection.scheduleCheckAfterUnmount();
        if (layoutGroup && layoutGroup.group)
          layoutGroup.group.remove(projection);
        if (promoteContext && promoteContext.deregister)
          promoteContext.deregister(projection);
      }
    }
    safeToRemove() {
      const { safeToRemove } = this.props;
      safeToRemove && safeToRemove();
    }
    render() {
      return null;
    }
  }
  function MeasureLayout(props) {
    const [isPresent, safeToRemove] = usePresence();
    const layoutGroup = reactExports.useContext(LayoutGroupContext);
    return jsxRuntimeExports.jsx(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
  }
  const drag = {
    pan: {
      Feature: PanGesture
    },
    drag: {
      Feature: DragGesture,
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout
    }
  };
  function handleHoverEvent(node2, event, lifecycle) {
    const { props } = node2;
    if (node2.animationState && props.whileHover) {
      node2.animationState.setActive("whileHover", lifecycle === "Start");
    }
    const eventName = "onHover" + lifecycle;
    const callback = props[eventName];
    if (callback) {
      frame.postRender(() => callback(event, extractEventInfo(event)));
    }
  }
  class HoverGesture extends Feature {
    mount() {
      const { current } = this.node;
      if (!current)
        return;
      this.unmount = hover(current, (_element, startEvent) => {
        handleHoverEvent(this.node, startEvent, "Start");
        return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
      });
    }
    unmount() {
    }
  }
  class FocusGesture extends Feature {
    constructor() {
      super(...arguments);
      this.isActive = false;
    }
    onFocus() {
      let isFocusVisible = false;
      try {
        isFocusVisible = this.node.current.matches(":focus-visible");
      } catch (e) {
        isFocusVisible = true;
      }
      if (!isFocusVisible || !this.node.animationState)
        return;
      this.node.animationState.setActive("whileFocus", true);
      this.isActive = true;
    }
    onBlur() {
      if (!this.isActive || !this.node.animationState)
        return;
      this.node.animationState.setActive("whileFocus", false);
      this.isActive = false;
    }
    mount() {
      this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
    }
    unmount() {
    }
  }
  function handlePressEvent(node2, event, lifecycle) {
    const { props } = node2;
    if (node2.current instanceof HTMLButtonElement && node2.current.disabled) {
      return;
    }
    if (node2.animationState && props.whileTap) {
      node2.animationState.setActive("whileTap", lifecycle === "Start");
    }
    const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
    const callback = props[eventName];
    if (callback) {
      frame.postRender(() => callback(event, extractEventInfo(event)));
    }
  }
  class PressGesture extends Feature {
    mount() {
      const { current } = this.node;
      if (!current)
        return;
      const { globalTapTarget, propagate } = this.node.props;
      this.unmount = press(current, (_element, startEvent) => {
        handlePressEvent(this.node, startEvent, "Start");
        return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
      }, {
        useGlobalTarget: globalTapTarget,
        stopPropagation: propagate?.tap === false
      });
    }
    unmount() {
    }
  }
  const observerCallbacks = new WeakMap();
  const observers = new WeakMap();
  const fireObserverCallback = (entry) => {
    const callback = observerCallbacks.get(entry.target);
    callback && callback(entry);
  };
  const fireAllObserverCallbacks = (entries) => {
    entries.forEach(fireObserverCallback);
  };
  function initIntersectionObserver({ root: root2, ...options }) {
    const lookupRoot = root2 || document;
    if (!observers.has(lookupRoot)) {
      observers.set(lookupRoot, {});
    }
    const rootObservers = observers.get(lookupRoot);
    const key = JSON.stringify(options);
    if (!rootObservers[key]) {
      rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options });
    }
    return rootObservers[key];
  }
  function observeIntersection(element, options, callback) {
    const rootInteresectionObserver = initIntersectionObserver(options);
    observerCallbacks.set(element, callback);
    rootInteresectionObserver.observe(element);
    return () => {
      observerCallbacks.delete(element);
      rootInteresectionObserver.unobserve(element);
    };
  }
  const thresholdNames = {
    some: 0,
    all: 1
  };
  class InViewFeature extends Feature {
    constructor() {
      super(...arguments);
      this.hasEnteredView = false;
      this.isInView = false;
    }
    startObserver() {
      this.unmount();
      const { viewport = {} } = this.node.getProps();
      const { root: root2, margin: rootMargin, amount = "some", once: once2 } = viewport;
      const options = {
        root: root2 ? root2.current : void 0,
        rootMargin,
        threshold: typeof amount === "number" ? amount : thresholdNames[amount]
      };
      const onIntersectionUpdate = (entry) => {
        const { isIntersecting } = entry;
        if (this.isInView === isIntersecting)
          return;
        this.isInView = isIntersecting;
        if (once2 && !isIntersecting && this.hasEnteredView) {
          return;
        } else if (isIntersecting) {
          this.hasEnteredView = true;
        }
        if (this.node.animationState) {
          this.node.animationState.setActive("whileInView", isIntersecting);
        }
        const { onViewportEnter, onViewportLeave } = this.node.getProps();
        const callback = isIntersecting ? onViewportEnter : onViewportLeave;
        callback && callback(entry);
      };
      return observeIntersection(this.node.current, options, onIntersectionUpdate);
    }
    mount() {
      this.startObserver();
    }
    update() {
      if (typeof IntersectionObserver === "undefined")
        return;
      const { props, prevProps } = this.node;
      const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
      if (hasOptionsChanged) {
        this.startObserver();
      }
    }
    unmount() {
    }
  }
  function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
    return (name) => viewport[name] !== prevViewport[name];
  }
  const gestureAnimations = {
    inView: {
      Feature: InViewFeature
    },
    tap: {
      Feature: PressGesture
    },
    focus: {
      Feature: FocusGesture
    },
    hover: {
      Feature: HoverGesture
    }
  };
  const layout = {
    layout: {
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout
    }
  };
  const featureBundle = {
    ...animations,
    ...gestureAnimations,
    ...drag,
    ...layout
  };
  const motion = createMotionProxy(featureBundle, createDomVisualElement);
  function useUnmountEffect(callback) {
    return reactExports.useEffect(() => () => callback(), []);
  }
  function useReducedMotion() {
    !hasReducedMotionListener.current && initPrefersReducedMotion();
    const [shouldReduceMotion] = reactExports.useState(prefersReducedMotion.current);
    return shouldReduceMotion;
  }
  function useReducedMotionConfig() {
    const reducedMotionPreference = useReducedMotion();
    const { reducedMotion } = reactExports.useContext(MotionConfigContext);
    if (reducedMotion === "never") {
      return false;
    } else if (reducedMotion === "always") {
      return true;
    } else {
      return reducedMotionPreference;
    }
  }
  function isDOMKeyframes(keyframes2) {
    return typeof keyframes2 === "object" && !Array.isArray(keyframes2);
  }
  function resolveSubjects(subject, keyframes2, scope, selectorCache) {
    if (subject == null) {
      return [];
    }
    if (typeof subject === "string" && isDOMKeyframes(keyframes2)) {
      return resolveElements(subject, scope, selectorCache);
    } else if (subject instanceof NodeList) {
      return Array.from(subject);
    } else if (Array.isArray(subject)) {
      return subject.filter((s2) => s2 != null);
    } else {
      return [subject];
    }
  }
  function calculateRepeatDuration(duration2, repeat, _repeatDelay) {
    return duration2 * (repeat + 1);
  }
  function calcNextTime(current, next2, prev2, labels) {
    if (typeof next2 === "number") {
      return next2;
    } else if (next2.startsWith("-") || next2.startsWith("+")) {
      return Math.max(0, current + parseFloat(next2));
    } else if (next2 === "<") {
      return prev2;
    } else if (next2.startsWith("<")) {
      return Math.max(0, prev2 + parseFloat(next2.slice(1)));
    } else {
      return labels.get(next2) ?? current;
    }
  }
  function eraseKeyframes(sequence, startTime, endTime) {
    for (let i2 = 0; i2 < sequence.length; i2++) {
      const keyframe = sequence[i2];
      if (keyframe.at > startTime && keyframe.at < endTime) {
        removeItem(sequence, keyframe);
        i2--;
      }
    }
  }
  function addKeyframes(sequence, keyframes2, easing, offset2, startTime, endTime) {
    eraseKeyframes(sequence, startTime, endTime);
    for (let i2 = 0; i2 < keyframes2.length; i2++) {
      sequence.push({
        value: keyframes2[i2],
        at: mixNumber$1(startTime, endTime, offset2[i2]),
        easing: getEasingForSegment(easing, i2)
      });
    }
  }
  function normalizeTimes(times2, repeat) {
    for (let i2 = 0; i2 < times2.length; i2++) {
      times2[i2] = times2[i2] / (repeat + 1);
    }
  }
  function compareByTime(a2, b) {
    if (a2.at === b.at) {
      if (a2.value === null)
        return 1;
      if (b.value === null)
        return -1;
      return 0;
    } else {
      return a2.at - b.at;
    }
  }
  const defaultSegmentEasing = "easeInOut";
  function createAnimationsFromSequence(sequence, { defaultTransition: defaultTransition2 = {}, ...sequenceTransition } = {}, scope, generators) {
    const defaultDuration = defaultTransition2.duration || 0.3;
    const animationDefinitions = new Map();
    const sequences = new Map();
    const elementCache = {};
    const timeLabels = new Map();
    let prevTime = 0;
    let currentTime = 0;
    let totalDuration = 0;
    for (let i2 = 0; i2 < sequence.length; i2++) {
      const segment = sequence[i2];
      if (typeof segment === "string") {
        timeLabels.set(segment, currentTime);
        continue;
      } else if (!Array.isArray(segment)) {
        timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));
        continue;
      }
      let [subject, keyframes2, transition = {}] = segment;
      if (transition.at !== void 0) {
        currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);
      }
      let maxDuration = 0;
      const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {
        const valueKeyframesAsList = keyframesAsList(valueKeyframes);
        const { delay: delay2 = 0, times: times2 = defaultOffset(valueKeyframesAsList), type: type4 = defaultTransition2.type || "keyframes", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;
        let { ease: ease2 = defaultTransition2.ease || "easeOut", duration: duration2 } = valueTransition;
        const calculatedDelay = typeof delay2 === "function" ? delay2(elementIndex, numSubjects) : delay2;
        const numKeyframes = valueKeyframesAsList.length;
        const createGenerator = isGenerator(type4) ? type4 : generators?.[type4 || "keyframes"];
        if (numKeyframes <= 2 && createGenerator) {
          let absoluteDelta = 100;
          if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {
            const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];
            absoluteDelta = Math.abs(delta);
          }
          const springTransition = {
            ...defaultTransition2,
            ...remainingTransition
          };
          if (duration2 !== void 0) {
            springTransition.duration = secondsToMilliseconds(duration2);
          }
          const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);
          ease2 = springEasing.ease;
          duration2 = springEasing.duration;
        }
        duration2 ?? (duration2 = defaultDuration);
        const startTime = currentTime + calculatedDelay;
        if (times2.length === 1 && times2[0] === 0) {
          times2[1] = 1;
        }
        const remainder = times2.length - valueKeyframesAsList.length;
        remainder > 0 && fillOffset(times2, remainder);
        valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);
        if (repeat) {
          duration2 = calculateRepeatDuration(duration2, repeat);
          const originalKeyframes = [...valueKeyframesAsList];
          const originalTimes = [...times2];
          ease2 = Array.isArray(ease2) ? [...ease2] : [ease2];
          const originalEase = [...ease2];
          for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {
            valueKeyframesAsList.push(...originalKeyframes);
            for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {
              times2.push(originalTimes[keyframeIndex] + (repeatIndex + 1));
              ease2.push(keyframeIndex === 0 ? "linear" : getEasingForSegment(originalEase, keyframeIndex - 1));
            }
          }
          normalizeTimes(times2, repeat);
        }
        const targetTime = startTime + duration2;
        addKeyframes(valueSequence, valueKeyframesAsList, ease2, times2, startTime, targetTime);
        maxDuration = Math.max(calculatedDelay + duration2, maxDuration);
        totalDuration = Math.max(targetTime, totalDuration);
      };
      if (isMotionValue(subject)) {
        const subjectSequence = getSubjectSequence(subject, sequences);
        resolveValueSequence(keyframes2, transition, getValueSequence("default", subjectSequence));
      } else {
        const subjects = resolveSubjects(subject, keyframes2, scope, elementCache);
        const numSubjects = subjects.length;
        for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {
          keyframes2 = keyframes2;
          transition = transition;
          const thisSubject = subjects[subjectIndex];
          const subjectSequence = getSubjectSequence(thisSubject, sequences);
          for (const key in keyframes2) {
            resolveValueSequence(keyframes2[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);
          }
        }
      }
      prevTime = currentTime;
      currentTime += maxDuration;
    }
    sequences.forEach((valueSequences, element) => {
      for (const key in valueSequences) {
        const valueSequence = valueSequences[key];
        valueSequence.sort(compareByTime);
        const keyframes2 = [];
        const valueOffset = [];
        const valueEasing = [];
        for (let i2 = 0; i2 < valueSequence.length; i2++) {
          const { at, value, easing } = valueSequence[i2];
          keyframes2.push(value);
          valueOffset.push( progress(0, totalDuration, at));
          valueEasing.push(easing || "easeOut");
        }
        if (valueOffset[0] !== 0) {
          valueOffset.unshift(0);
          keyframes2.unshift(keyframes2[0]);
          valueEasing.unshift(defaultSegmentEasing);
        }
        if (valueOffset[valueOffset.length - 1] !== 1) {
          valueOffset.push(1);
          keyframes2.push(null);
        }
        if (!animationDefinitions.has(element)) {
          animationDefinitions.set(element, {
            keyframes: {},
            transition: {}
          });
        }
        const definition = animationDefinitions.get(element);
        definition.keyframes[key] = keyframes2;
        const { type: _type, ...remainingDefaultTransition } = defaultTransition2;
        definition.transition[key] = {
          ...remainingDefaultTransition,
          duration: totalDuration,
          ease: valueEasing,
          times: valueOffset,
          ...sequenceTransition
        };
      }
    });
    return animationDefinitions;
  }
  function getSubjectSequence(subject, sequences) {
    !sequences.has(subject) && sequences.set(subject, {});
    return sequences.get(subject);
  }
  function getValueSequence(name, sequences) {
    if (!sequences[name])
      sequences[name] = [];
    return sequences[name];
  }
  function keyframesAsList(keyframes2) {
    return Array.isArray(keyframes2) ? keyframes2 : [keyframes2];
  }
  function getValueTransition(transition, key) {
    return transition && transition[key] ? {
      ...transition,
      ...transition[key]
    } : { ...transition };
  }
  const isNumber$1 = (keyframe) => typeof keyframe === "number";
  const isNumberKeyframesArray = (keyframes2) => keyframes2.every(isNumber$1);
  function createDOMVisualElement(element) {
    const options = {
      presenceContext: null,
      props: {},
      visualState: {
        renderState: {
          transform: {},
          transformOrigin: {},
          style: {},
          vars: {},
          attrs: {}
        },
        latestValues: {}
      }
    };
    const node2 = isSVGElement$1(element) && !isSVGSVGElement(element) ? new SVGVisualElement(options) : new HTMLVisualElement(options);
    node2.mount(element);
    visualElementStore.set(element, node2);
  }
  function createObjectVisualElement(subject) {
    const options = {
      presenceContext: null,
      props: {},
      visualState: {
        renderState: {
          output: {}
        },
        latestValues: {}
      }
    };
    const node2 = new ObjectVisualElement(options);
    node2.mount(subject);
    visualElementStore.set(subject, node2);
  }
  function isSingleValue(subject, keyframes2) {
    return isMotionValue(subject) || typeof subject === "number" || typeof subject === "string" && !isDOMKeyframes(keyframes2);
  }
  function animateSubject(subject, keyframes2, options, scope) {
    const animations2 = [];
    if (isSingleValue(subject, keyframes2)) {
      animations2.push(animateSingleValue(subject, isDOMKeyframes(keyframes2) ? keyframes2.default || keyframes2 : keyframes2, options ? options.default || options : options));
    } else {
      if (subject == null) {
        return animations2;
      }
      const subjects = resolveSubjects(subject, keyframes2, scope);
      const numSubjects = subjects.length;
      for (let i2 = 0; i2 < numSubjects; i2++) {
        const thisSubject = subjects[i2];
        const createVisualElement = thisSubject instanceof Element ? createDOMVisualElement : createObjectVisualElement;
        if (!visualElementStore.has(thisSubject)) {
          createVisualElement(thisSubject);
        }
        const visualElement = visualElementStore.get(thisSubject);
        const transition = { ...options };
        if ("delay" in transition && typeof transition.delay === "function") {
          transition.delay = transition.delay(i2, numSubjects);
        }
        animations2.push(...animateTarget(visualElement, { ...keyframes2, transition }, {}));
      }
    }
    return animations2;
  }
  function animateSequence(sequence, options, scope) {
    const animations2 = [];
    const processedSequence = sequence.map((segment) => {
      if (Array.isArray(segment) && typeof segment[0] === "function") {
        const callback = segment[0];
        const mv = motionValue(0);
        mv.on("change", callback);
        if (segment.length === 1) {
          return [mv, [0, 1]];
        } else if (segment.length === 2) {
          return [mv, [0, 1], segment[1]];
        } else {
          return [mv, segment[1], segment[2]];
        }
      }
      return segment;
    });
    const animationDefinitions = createAnimationsFromSequence(processedSequence, options, scope, { spring });
    animationDefinitions.forEach(({ keyframes: keyframes2, transition }, subject) => {
      animations2.push(...animateSubject(subject, keyframes2, transition));
    });
    return animations2;
  }
  function isSequence(value) {
    return Array.isArray(value) && value.some(Array.isArray);
  }
  function createScopedAnimate(options = {}) {
    const { scope, reduceMotion } = options;
    function scopedAnimate(subjectOrSequence, optionsOrKeyframes, options2) {
      let animations2 = [];
      let animationOnComplete;
      if (isSequence(subjectOrSequence)) {
        animations2 = animateSequence(subjectOrSequence, reduceMotion !== void 0 ? { reduceMotion, ...optionsOrKeyframes } : optionsOrKeyframes, scope);
      } else {
        const { onComplete, ...rest } = options2 || {};
        if (typeof onComplete === "function") {
          animationOnComplete = onComplete;
        }
        animations2 = animateSubject(subjectOrSequence, optionsOrKeyframes, reduceMotion !== void 0 ? { reduceMotion, ...rest } : rest, scope);
      }
      const animation = new GroupAnimationWithThen(animations2);
      if (animationOnComplete) {
        animation.finished.then(animationOnComplete);
      }
      if (scope) {
        scope.animations.push(animation);
        animation.finished.then(() => {
          removeItem(scope.animations, animation);
        });
      }
      return animation;
    }
    return scopedAnimate;
  }
  createScopedAnimate();
  function useAnimate() {
    const scope = useConstant(() => ({
      current: null,
animations: []
    }));
    const reduceMotion = useReducedMotionConfig() ?? void 0;
    const animate = reactExports.useMemo(() => createScopedAnimate({ scope, reduceMotion }), [scope, reduceMotion]);
    useUnmountEffect(() => {
      scope.animations.forEach((animation) => animation.stop());
      scope.animations.length = 0;
    });
    return [scope, animate];
  }
  function IconAnimatedChecked({
    size = 18,
    useAnimation = false,
    color: color2 = "currentColor",
    ...restProps
  }) {
    return jsx$1("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: size, height: size, ...restProps, children: jsx$1(motion.path, { fill: "transparent", stroke: color2, strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M5 11L11 17L21 7", ...useAnimation && {
      initial: {
        pathLength: 0
      },
      animate: {
        pathLength: 1
      },
      transition: {
        duration: 0.2,
        ease: "easeInOut"
      }
    } }) });
  }
  const IconForLike = ForwardRef$1i;
  const IconForDislike = ForwardRef$1h;
  const IconForConfig = ForwardRef$1g;
  const IconForPlayer = ForwardRef$1f;
  const IconForOpenExternalLink = ForwardRef$1e;
  const IconForTimeAsc = ForwardRef$1d;
  const IconForTimeDesc = ForwardRef$1c;
  const IconForAsc = ForwardRef$1b;
  const IconForDesc = ForwardRef$1a;
  const IconForInfo = ForwardRef$19;
  const IconForDefaultOrder = ForwardRef$18;
  const IconForShuffle = ForwardRef$1k;
  const IconForTimestamp = ForwardRef$17;
  const IconForPhone = ForwardRef$16;
  const IconForPc = ForwardRef$15;
  const IconForFollowedOnly = ForwardRef$14;
  const IconForDynamicFeed = IconFreshSpaceDynamicFeed;
  const IconForFav = ForwardRef$13;
  const IconForFaved = ForwardRef$12;
  const IconForHot = ForwardRef$11;
  const IconForSpaceUpload = ForwardRef$10;
  const IconForBlacklist = ForwardRef$$;
  const IconForReset = ForwardRef$_;
  const IconForCopy = ForwardRef$Z;
  const IconForLoading = ForwardRef$1j;
  const IconForDelete = ForwardRef$Y;
  const IconForMove = ForwardRef$X;
  const IconForEdit = ForwardRef$W;
  const LIVE_GIF = `data:image/gif;base64,R0lGODlhGAAYAJECAP7+/v///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUDw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ4IDc5LjE2NDAzNiwgMjAxOS8wOC8xMy0wMTowNjo1NyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QTI2NTYzMDc2RTNDMTFFREJENEJEMzUxOTQzQjMxMkQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QTI2NTYzMDg2RTNDMTFFREJENEJEMzUxOTQzQjMxMkQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpBMjY1NjMwNTZFM0MxMUVEQkQ0QkQzNTE5NDNCMzEyRCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBMjY1NjMwNjZFM0MxMUVEQkQ0QkQzNTE5NDNCMzEyRCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769vLu6ubi3trW0s7KxsK+urayrqqmop6alpKOioaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhoWEg4KBgH9+fXx7enl4d3Z1dHNycXBvbm1sa2ppaGdmZWRjYmFgX15dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozo5ODc2NTQzMjEwLy4tLCsqKSgnJiUkIyIhIB8eHRwbGhkYFxYVFBMSERAPDg0MCwoJCAcGBQQDAgEAACH5BAkEAAIALAAAAAAYABgAAAI5lI+py+0Po2QhTFXrRdlu031gJgqhpI0pdJ4sacJv6j6trABeTOMcfFslgp7ar4fcDVcyX+kJjToKACH5BAkEAAIALAAAAAAYABgAAAI2lI+py+0Po5xUhFDRvdls3H0T522SaJkRikKs6qptAr+kYoOzJvc37dPBgKQco3YbdpbM5qQAACH5BAkEAAIALAAAAAAYABgAAAI3lI+py+0Po5y02hhykHqLzmkGiImfCZHkkh0qmrztOSuyt8bmzfC0Z9sJa7qZLwhEwS7MpnNSAAAh+QQJBAACACwAAAAAGAAYAAACPJSPqcvtD6OctJoQ7MFYC55dYQSKHcmZo3J+qdsmJRzO7DvbMs7HSN5b/YIqBvCkGyKJixds4/NIp1RHAQAh+QQJBAACACwAAAAAGAAYAAACOpSPqcvtD6OcLwSarMVHXy54YKhJIrmhn3K25eKmJ/vGa1bnKS3rN2IzzHC94q/jE754yNVyBI1KIQUAIfkECQQAAgAsAAAAABgAGAAAAjmUj6nL7Q+jnLSaEOzBePbLSVwmjGJYopCZfmnDxmoif6xSkzeN5ozfIuF6RBfPVhQeN66Z5gmNTgoAIfkECQQAAgAsAAAAABgAGAAAAjmUj6nL7Q+jnLRaETLSMnMfdJ4Bit8YlRgKqerauOibyCen2OGK1/Pf2wB3NOGNyPLteIfk5QmNTgoAIfkECQQAAgAsAAAAABgAGAAAAjeUj6nL7Q+jnCkEWu3FRm/uHdYUCiVUnk+qSewYvd/amrWKyF2t6DbcuwmBGZgv+OHxOMyms1kAACH5BAkEAAIALAAAAAAYABgAAAI5lI+py+0PowtBLkptwlUf7n1YaIBlF5kmpI6puz5t9tLxBLsCgCpzdxPZcjQfEajbFHVJkvMJtRQAACH5BAkEAAIALAAAAAAYABgAAAI1lI+py+0Po5wpBFrtxUZv7nGdJgqheJ5QSkasJb2bmsFmSyPyaCv73avNcC1fr1gsKZdMSAEAIfkECQQAAgAsAAAAABgAGAAAAjWUj6nL7Q+jnLRaEfI1Wd8ebKDYkR4WHqcyol7Llm4KJ+0tx69cI/i+8vGGQdUpl9sol0xIAQAh+QQJBAACACwAAAAAGAAYAAACNJSPqcvtD6OctNq7QsBCa+xtV9h8DJl5p5qaCtqJsZugNvuyN43sIlzTCXkHnJHISSqXiQIAIfkECQQAAgAsAAAAABgAGAAAAjKUj6nL7Q+jnLTai3MMPLDuLeDXkZwZKqNYsqebJqva0u86yy1e6/feQ9SGL43xiEwUAAAh+QQJBAACACwAAAAAGAAYAAACM5SPqcvtD6OctNp7Q8BCa+xtzDd6JamEp5iai2qgcEvCc2K7N5LXLi3qsXCy4pCDTCoXBQAh+QQJBAACACwAAAAAGAAYAAACNJSPqcvtD6OctNoYcrhC7+txIag1mVkuY/exp5qOayLHqVK/M5J/+9Ez/IQvF7DISSqXkAIAIfkEBQQAAgAsAAAAABgAGAAAAjKUj6nL7Q+jnFSEUNG92WzcfZ21jWJYRucJranyutwig2xSey+e5nQPnMGEMeHoiExCCgA7`;
  function IconForLive({
    active = false,
    ...props
  }) {
    if (active) {
      return jsx$1("img", { ...props, src: LIVE_GIF });
    } else {
      return jsx$1(ForwardRef$V, { ...props });
    }
  }
  const IconForWatchlater = defineSvgComponent((props) => {
    return jsxs("svg", { viewBox: "0 0 20 20", fill: "currentColor", ...props, children: [
jsx$1("path", { className: "circle", d: "M10 3.1248000000000005C6.20305 3.1248000000000005 3.1250083333333336 6.202841666666667 3.1250083333333336 9.999833333333335C3.1250083333333336 13.796750000000001 6.20305 16.874833333333335 10 16.874833333333335C11.898291666666667 16.874833333333335 13.615833333333333 16.106291666666667 14.860625 14.861916666666666C15.104708333333335 14.617916666666666 15.500416666666668 14.617958333333334 15.7445 14.862041666666668C15.9885 15.106166666666669 15.988416666666668 15.501916666666666 15.744333333333334 15.745958333333334C14.274750000000001 17.215041666666668 12.243041666666667 18.124833333333335 10 18.124833333333335C5.512691666666667 18.124833333333335 1.8750083333333334 14.487125 1.8750083333333334 9.999833333333335C1.8750083333333334 5.512483333333334 5.512691666666667 1.8748000000000002 10 1.8748000000000002C14.487291666666668 1.8748000000000002 18.125 5.512483333333334 18.125 9.999833333333335C18.125 10.304458333333333 18.108208333333334 10.605458333333333 18.075458333333337 10.901791666666668C18.0375 11.244916666666667 17.728625 11.492291666666667 17.385583333333333 11.454333333333334C17.0425 11.416416666666667 16.795083333333334 11.107541666666668 16.833000000000002 10.764458333333334C16.860750000000003 10.513625000000001 16.875 10.2585 16.875 9.999833333333335C16.875 6.202841666666667 13.796958333333333 3.1248000000000005 10 3.1248000000000005z", fill: "currentColor" }),
jsx$1("path", { d: "M15.391416666666666 9.141166666666667C15.635458333333334 8.897083333333335 16.031208333333332 8.897083333333335 16.275291666666668 9.141166666666667L17.5 10.365875L18.72475 9.141166666666667C18.968791666666668 8.897083333333335 19.364541666666668 8.897083333333335 19.608625 9.141166666666667C19.852666666666668 9.385291666666667 19.852666666666668 9.780958333333334 19.608625 10.025083333333333L18.08925 11.544416666666669C17.763833333333334 11.869833333333334 17.236208333333334 11.869833333333334 16.91075 11.544416666666669L15.391416666666666 10.025083333333333C15.147333333333334 9.780958333333334 15.147333333333334 9.385291666666667 15.391416666666666 9.141166666666667z", fill: "currentColor" }),
jsx$1("path", { d: "M12.499333333333334 9.278375C13.05475 9.599 13.05475 10.400666666666668 12.499333333333334 10.721291666666668L9.373916666666666 12.525791666666668C8.818541666666667 12.846416666666666 8.124274999999999 12.445583333333333 8.124274999999999 11.804291666666668L8.124274999999999 8.1954C8.124274999999999 7.554066666666667 8.818541666666667 7.153233333333334 9.373916666666666 7.473900000000001L12.499333333333334 9.278375z", fill: "currentColor" })
    ] });
  });
  const parsed = UAParser();
  const isMac = parsed.os.name?.toLowerCase() === "mac os";
  const parsedBrowserName = parsed.browser.name || "";
  const isBrand = (brand) => new RegExp(String.raw`\b${brand}\b`, "i").test(parsedBrowserName);
  const isSafari = isBrand("safari");
  isBrand("firefox");
  isBrand("edge");
  const materialSymbolsLightOpenInNewOff = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "m19.833 21.26l-1.298-1.298q-.096.019-.173.029q-.077.009-.173.009H5.616q-.691 0-1.153-.462T4 18.384V5.813q0-.096.01-.173t.029-.173l-1.299-1.3l.713-.713l17.092 17.092zM5.616 19h11.957l-5.933-5.933l-1.902 1.902l-.707-.708l1.902-1.902L5 6.427v11.958q0 .23.192.423t.423.192M7.813 5l-1-1h4.419v1zm5.948 5.948l-.708-.707L18.292 5H14V4h6v6h-1V5.708zm6.24 6.24l-1-1V12.77h1z" })
  ] });
  const ForwardRef$U = reactExports.forwardRef(materialSymbolsLightOpenInNewOff);
  const riFullscreenFill = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M16 3h6v6h-2V5h-4zM2 3h6v2H4v4H2zm18 16v-4h2v6h-6v-2zM4 19h4v2H2v-6h2z" })
  ] });
  const ForwardRef$T = reactExports.forwardRef(riFullscreenFill);
  const akarIconsMiniplayer = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsx$1("rect", { width: 20, height: 16, x: 2, y: 4, rx: 2 }),
jsx$1("rect", { width: 9, height: 7, x: 13, y: 13, rx: 2 })
    ] })
  ] });
  const ForwardRef$S = reactExports.forwardRef(akarIconsMiniplayer);
  const eosIconsBackgroundTasks = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M6 3h8.99v1.5H6zM2.99 6h1.5v1.5h-1.5zm0-3h1.5v1.5h-1.5zm0 6.01H4.5v1.5H2.99z" }),
jsx$1("path", { fill: "currentColor", d: "M4.5 12h-3V1.49h15V6H18V2a2 2 0 0 0-2-2H2a2 2 0 0 0-2 2v9.48a2 2 0 0 0 2 2h2.5Z" }),
jsx$1("path", { fill: "currentColor", d: "M22 7.5H8a2 2 0 0 0-2 2V19a2 2 0 0 0 2 2h5.53v1.53H12V24h6v-1.49h-1.5V21H22a2 2 0 0 0 2-2V9.5a2 2 0 0 0-2-2m.51 12h-15V9h15Z" })
  ] });
  const ForwardRef$R = reactExports.forwardRef(eosIconsBackgroundTasks);
  const STAT_NUMBER_FALLBACK = "0";
  function copyContent(content, msgDuration) {
    GM.setClipboard(content);
    antMessage.success(`已复制: ${content}`, msgDuration);
  }
  var EQueryKey = ((EQueryKey2) => {
    EQueryKey2["PlayerScreenMode"] = `${APP_SHORT_PREFIX}-player-screen-mode`;
    EQueryKey2["ForceAutoPlay"] = `${APP_SHORT_PREFIX}-force-auto-play`;
    return EQueryKey2;
  })(EQueryKey || {});
  var EPlayerScreenMode = ((EPlayerScreenMode2) => {
    EPlayerScreenMode2["Normal"] = "normal";
    EPlayerScreenMode2["Wide"] = "wide";
    EPlayerScreenMode2["WebFullscreen"] = "web";
    EPlayerScreenMode2["Fullscreen"] = "full";
    return EPlayerScreenMode2;
  })(EPlayerScreenMode || {});
  var EForceAutoPlay = ((EForceAutoPlay2) => {
    EForceAutoPlay2["ON"] = "on";
    EForceAutoPlay2["OFF"] = "off";
    return EForceAutoPlay2;
  })(EForceAutoPlay || {});
  var EVideoLinkOpenMode = ((EVideoLinkOpenMode2) => {
    EVideoLinkOpenMode2["Normal"] = "Normal";
    EVideoLinkOpenMode2["CurrentPage"] = "CurrentPage";
    EVideoLinkOpenMode2["NormalWebFullscreen"] = "NormalWebFullscreen";
    EVideoLinkOpenMode2["Popup"] = "Popup";
    EVideoLinkOpenMode2["Background"] = "Background";
    EVideoLinkOpenMode2["Iina"] = "Iina";
    return EVideoLinkOpenMode2;
  })(EVideoLinkOpenMode || {});
  const VideoLinkOpenModeKey = Object.entries(EVideoLinkOpenMode).reduce((record, [key, value]) => {
    return {
      ...record,
      [value]: `LinkOpenMode.${key}`
    };
  }, {});
  const VideoLinkOpenModeConfig = {
    [
      "Normal"
]: {
      icon: jsx$1(IconForOpenExternalLink, { className: "size-16px" }),
      label: "打开",
      desc: "默认在新标签页中打开"
    },
    [
      "CurrentPage"
]: {
      icon: jsx$1(ForwardRef$U, { className: "size-16px" }),
      label: "当前页中打开",
      desc: "不打开新标签页, 使用当前标签页打开, 适用于将网站作为应用安装场景"
    },
    [
      "NormalWebFullscreen"
]: {
      icon: jsx$1(ForwardRef$T, { className: "size-15px" }),
      label: "打开-网页全屏",
      desc: jsx$1(Fragment, { children: "默认在新标签页中打开, 打开后自动网页全屏" })
    },
    [
      "Popup"
]: {
      icon: jsx$1(ForwardRef$S, { className: "size-15px" }),
      label: "小窗打开",
      desc: jsxs(Fragment, { children: [
        "当",
        " ",
jsx$1("a", { href: "https://developer.chrome.com/docs/web-platform/document-picture-in-picture", target: "_blank", children: "「文档画中画」API" }),
        " ",
        "可用时, 会使用「文档画中画」的形式: 窗口置顶 + 播放页网页全屏.",
jsx$1("br", {}),
        "当该 API 不可用时, 会使用 popup window + 播放页网页全屏 的形式."
      ] })
    },
    [
      "Background"
]: {
      icon: jsx$1(ForwardRef$R, { className: "size-15px" }),
      label: "后台打开"
    },
    [
      "Iina"
]: {
      icon: jsx$1(IconForPlayer, { className: "size-15px" }),
      label: "在 IINA 中打开",
      enabled: isMac,
      desc: jsx$1(Fragment, { children: jsx$1("a", { href: "https://github.com/magicdawn/Bilibili-Gate/blob/main/notes/iina.md", target: "_blank", children: "macOS IINA 设置教程" }) })
    }
  };
  function createVideoCardEmitter() {
    return new Emittery();
  }
  const defaultVideoCardEmitter = createVideoCardEmitter();
  const displayAsListCss = {
    card: {
      name: "18iuzk9",
      styles: "grid-column:1/-1"
    },
    cardWrap: {
      name: "k9oiqw",
      styles: "display:flex;column-gap:20px"
    },
    cover: {
      name: "1t7agkb",
      styles: "width:clamp(250px, 20%, 400px);flex-shrink:0"
    }
  };
  const clsZWatchlaterProgressBar = "z-2";
  const clsZPreviewImageWrapper = "z-3";
  const clsZMultiSelectBg = "z-4";
  const clsZLeftMarks = "z-5";
  const clsZRightActions = "z-6";
  var EGridDisplayMode = ((EGridDisplayMode2) => {
    EGridDisplayMode2["NormalGrid"] = "grid";
    EGridDisplayMode2["List"] = "list";
    EGridDisplayMode2["TwoColumnGrid"] = "two-column-grid";
    EGridDisplayMode2["CenterEmptyGrid"] = "center-empty-grid";
    return EGridDisplayMode2;
  })(EGridDisplayMode || {});
  var ETwoColumnModeAlign = ((ETwoColumnModeAlign2) => {
    ETwoColumnModeAlign2["Center"] = "center";
    ETwoColumnModeAlign2["Left"] = "left";
    ETwoColumnModeAlign2["Right"] = "right";
    return ETwoColumnModeAlign2;
  })(ETwoColumnModeAlign || {});
  var ESidebarAlign = ((ESidebarAlign2) => {
    ESidebarAlign2["Left"] = "left";
    ESidebarAlign2["Right"] = "right";
    return ESidebarAlign2;
  })(ESidebarAlign || {});
  var WatchlaterItemsOrder = ((WatchlaterItemsOrder2) => {
    WatchlaterItemsOrder2["AddTimeDesc"] = "add-time-desc";
    WatchlaterItemsOrder2["AddTimeAsc"] = "add-time-asc";
    WatchlaterItemsOrder2["Shuffle"] = "shuffle";
    return WatchlaterItemsOrder2;
  })(WatchlaterItemsOrder || {});
  function getPaths(obj, parentPath = "", result = []) {
    if (parentPath) {
      result.push(parentPath);
    }
    for (const key in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;
      const value = obj[key];
      const currentPath = parentPath ? `${parentPath}.${key}` : key;
      result.push(currentPath);
      if (value && typeof value === "object" && !Array.isArray(value) &&
!(value instanceof Date) && !(value instanceof RegExp)) {
        getPaths(value, currentPath, result);
      }
    }
    return [...new Set(result)];
  }
  function getObjectPaths(obj, parentPath = "") {
    const result = [];
    if (parentPath) {
      result.push(parentPath);
    }
    for (const key in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;
      const value = obj[key];
      const currentPath = parentPath ? `${parentPath}.${key}` : key;
      if (value && typeof value === "object" && !Array.isArray(value) && !(value instanceof Date) && !(value instanceof RegExp) && Object.getPrototypeOf(value) === Object.prototype) {
        result.push(currentPath);
        result.push(...getObjectPaths(value, currentPath));
      }
    }
    return [...new Set(result)];
  }
  function getLeafPaths(obj) {
    const allPaths = getPaths(obj);
    const objPaths = getObjectPaths(obj);
    return allPaths.filter((p2) => !objPaths.includes(p2));
  }
  function t(e) {
    return [...new Set(e)];
  }
  function n(e, t2) {
    if (!e) throw Error(t2);
  }
  const r$1 = String.raw, i = (e, ...t2) => new RegExp(r$1(e, ...t2)), a = r$1`(\d+(\.\d+)?)?(xs|sm|md|lg|xl)`, o = `(solid|dashed|dotted|double|none|hidden)`;
  function s(e, t2) {
    return n(e.endsWith(`-`), "prefix must end with `-`"), t2.map((t3) => e + t3);
  }
  const c$1 = [[[...[`block`, `flex`, `grid`, `table`].flatMap((e) => [e, `inline-${e}`]), `inline`, `flow-root`, `contents`, `list-item`, `hidden`, ...s(`table-`, [`row`, `column`, `cell`, `caption`, `row-group`, `column-group`, `header-group`, `footer-group`])], `display`], [[`isolate`, `isolation-auto`], `isolation`], [[`static`, `fixed`, `absolute`, `relative`, `sticky`], `position`], [[`visible`, `invisible`, `collapse`], `visibility`], [s(`flex-`, [`row`, `row-reverse`, `col`, `col-reverse`]), `flex-direction`], [s(`flex-`, [`wrap`, `wrap-reverse`, `nowrap`]), `flex-wrap`], [s(`object-`, [`contain`, `cover`, `fill`, `none`, `scale-down`]), `object-fit`], [s(`object-`, [`bottom`, `center`, `left`, `left-bottom`, `left-top`, `right`, `right-bottom`, `right-top`, `top`]), `object-position`], [[`antialiased`, `subpixel-antialiased`], `font-smoothing`], [[`italic`, `not-italic`, `oblique`, `not-oblique`], `font-style`], [s(`font-`, [`mono`, `sans`, `serif`]), `font-family`], [/^(?:font|fw)-?(thin|extralight|light|normal|medium|semibold|bold|extrabold|black|\d+)$/, `font-weight`], [[`normal-nums`, `ordinal`, `slashed-zero`, `lining-nums`, `oldstyle-nums`, `proportional-nums`, `tabular-nums`, `diagonal-fractions`, `stacked-fractions`], `font-variant-numeric`], [i`^(text|text-size|font-size)-(\d+|${a}$)`, `font-size`], [/^(leading|line-height)-/, `line-height`], [s(`list-`, [`inside`, `outside`]), `list-style-position`], [s(`list-`, [`none`, `disc`, `decimal`]), `list-style-type`], [s(`text-`, [`left`, `center`, `right`, `justify`, `start`, `end`]), `text-align`], [[`underline`, `overline`, `line-through`, `no-underline`], `text-decoration-line`], [s(`decoration-`, [`solid`, `double`, `dotted`, `dashed`, `wavy`]), `text-decoration-style`], [/^decoration-(\d+|(auto|from-font)$)/, `text-decoration-thickness`], [[`truncate`, `text-ellipsis`, `text-clip`], `text-overflow`], [s(`text-`, [`wrap`, `nowrap`, `balance`, `pretty`]), `text-wrap`], [s(`bg-`, [`bottom`, `center`, `left`, `left-bottom`, `left-top`, `right`, `right-bottom`, `right-top`, `top`]), `background-position`], [/^bg(-no)?-repeat($|-)/, `background-repeat`], [s(`bg-`, [`auto`, `cover`, `contain`]), `background-size`], [[`bg-none`, /^bg-gradient-to-/], `background-image`], [/^(?:border-|b-)?(?:rounded|rd)(?:-(.+))?$/, `rounded`], [i`^b(?:order)?-${o}$`, `border-style`], [i`^b(?:order)?-([tblrxyse])-${o}$`, (e, t2) => `border-${t2?.[1]}-style`], [/^b(?:order)?($|-\d+)/, `border-width`], [/^b(?:order)?-([tblrxyse])($|-\d+)/, (e, t2) => `border-${t2?.[1]}-width`], [/^(?:border|b)-(?:color-)?(.+)$/, `border-color`], [/^(?:border|b)-([rltbse])-(?:color-)?(.+)$/, (e, t2) => `border-${t2?.[1]}-color`], [/^outline-\d+/, `outline-width`], [[`outline`, i`^outline-${o}$`], `outline-style`], [i`^divide-${o}$`, `divide-style`], [/^divide-(x|y)($|-\d+)/, (e, t2) => `divide-${t2?.[1]}-width`], [[`ring`, /^ring-\d+/], `ring-width`], [[/^ring-offset-\d+/], `ring-offset-width`], [[`shadow`, ...s(`shadow-`, [`inner`, `none`]), i`^shadow-${a}$`], `box-shadow`], [s(`border-`, [`collapse`, `separate`]), `border-collapse`], [s(`table-`, [`auto`, `fixed`]), `table-layout`], [s(`caption-`, [`top`, `bottom`]), `caption-side`], [s(`scroll-`, [`auto`, `smooth`]), `scroll-behavior`], [s(`snap-`, [`start`, `end`, `center`, `align-none`]), `scroll-snap-align`], [s(`snap-`, [`normal`, `always`]), `scroll-snap-stop`], [s(`snap-`, [`none`, `x`, `y`, `both`, `mandatory`, `proximity`]), `scroll-snap-type`], [/^stroke-\d+/, `stroke-width`], [[`sr-only`, `not-sr-only`], `Screen-Readers`], [/^(flex-)?grow($|-\d+$)/, `flex-grow`], [/^(flex-)?shrink($|-\d+$)/, `flex-shrink`], [/^(flex-)?basis-(.+)$/, `flex-basis`], [/^flex-(initial|auto|none|\d+)$/, `flex`], [/^col-start-/, `grid-column-start`], [/^col-end-/, `grid-column-end`], [[/^col-/, /^col-span-/], `grid-column`], [/^row-start-/, `grid-row-start`], [/^row-end-/, `grid-row-end`], [[/^row-/, /^row-span-/], `grid-row`], [`transition-none`, `transition-none`], [/^transition-delay-(.+)$/, `transition-delay`], [/^transition-ease(?:-(.+))?$/, `transition-timing-function`], [/^transition(-duration)?-\d+(m?s)?$/, `transition-duration`], [/^transition-(all$|\w+)/, `transition-property`], ...[`ring-inset`, `divide-x-reverse`, `divide-y-reverse`].map((e) => [e, e]), ...[`resize`, `blur`, `drop-shadow`, `grayscale`, `invert`, `sepia`, `backdrop-blur`, `backdrop-grayscale`, `backdrop-invert`, `backdrop-sepia`].map((e) => [i`^${e}($|-)`, e])], l = new Map(), u = new Map();
  for (let [e, t2] of c$1) {
    let n2 = [e].flat(), r2 = n2.filter((e2) => typeof e2 == `string`), i2 = n2.filter((e2) => typeof e2 == `object` && e2 instanceof RegExp);
    r2.forEach((e2) => {
      let n3 = typeof t2 == `string` ? t2 : t2(e2);
      l.set(e2, n3);
    }), i2.forEach((e2) => {
      u.set(e2, t2);
    });
  }
  function d$1(e) {
    if (l.has(e)) return l.get(e);
    for (let [t2, n2] of u.entries()) if (t2.test(e)) {
      let r2 = t2.exec(e);
      return typeof n2 == `string` ? n2 : n2(e, r2);
    }
  }
  function f(e) {
    return p.map((e2) => typeof e2 == `string` ? [e2, e2] : e2).find(([t2, n2]) => e.startsWith(`${t2}-`));
  }
  const p = [`break-after`, `break-before`, `break-inside`, `grid-flow`, `align`, `whitespace`, `mix-blend`, `bg-blend`, `ease`, `origin`, `cursor`, `touch`, `color`, [`text`, `color`], [`c`, `color`], [`bg`, `background-color`], [`decoration`, `text-decoration-color`], [`from`, `gradient-color-stops`], [`divide`, `divide-color`], [`outline`, `outline-color`], [`ring`, `ring-color`], [`ring-offset`, `ring-offset-color`], [`shadow`, `box-shadow-color`], [`accent`, `accent-color`], [`caret`, `caret-color`], `fill`, `stroke`], m = new Map(Object.entries({ flex: [`flex-grow`, `flex-shrink`, `flex-basis`], "transiton-none": [`transition-duration`, `transition-delay`, `transition-timing-function`, `transition-property`], m: [`mt`, `mb`, `ml`, `mr`, `mx`, `my`], mx: [`ml`, `mr`], my: [`mt`, `mb`], p: [`pt`, `pb`, `pl`, `pr`, `px`, `py`], px: [`pl`, `pr`], py: [`pt`, `pb`] }));
  function h(e) {
    return (e || ``).split(` `).map((e2) => e2.trim()).filter(Boolean);
  }
  function g(...n2) {
    let r2 = new Map();
    return h(clsx(...n2)).filter(Boolean).forEach((e) => _(e, r2)), t(Array.from(r2.values())).join(` `);
  }
  function _(e, t2) {
    let n2 = e, r2;
    function i2(e2) {
      [e2].flat().forEach((e3) => {
        m.has(e3) && [m.get(e3)].flat().filter((e4) => e4 !== void 0).forEach((e4) => {
          t2.delete(r2 ? r2 + e4 : e4);
        }), t2.set(r2 ? r2 + e3 : e3, n2);
      });
    }
    function a2() {
      let t3 = d$1(e);
      if (t3) return i2(t3), true;
    }
    function o2() {
      let t3 = f(e);
      if (!t3) return;
      let [n3, r3] = t3;
      return i2(r3), true;
    }
    function s2() {
      let t3 = e, n3 = /(\[[\w,()/-]+\])$/;
      n3.test(e) && (t3 = e.replace(n3, function(e2, t4) {
        return `*`.repeat(t4.length);
      })), t3 = t3.replaceAll(/--(?=\d)/g, `-*`);
      let r3 = t3.lastIndexOf(`-`);
      if (r3 !== -1) return i2(e.slice(0, r3)), true;
    }
    function c2() {
      return i2(e);
    }
    function l2() {
      let t3 = /^(?:(?:[\w-]+|\[\S+\]):)+/.exec(e);
      t3 && (r2 = t3[0].split(new RegExp("(?<=:)(?:\\b|$)")).filter(Boolean).sort().join(``), e = e.slice(r2.length));
    }
    function u2() {
      if (e.startsWith(`!`)) {
        e = `important:` + e.slice(1);
        return;
      }
      if (e.endsWith(`!`)) {
        e = `important:` + e.slice(0, -1);
        return;
      }
    }
    a2() || o2() || (u2(), l2(), a2() || o2() || s2() || c2());
  }
  function r(...r2) {
    let i2 = reactExports.useMemo(() => clsx(...r2), [...r2]);
    return reactExports.useMemo(() => g(i2), [i2]);
  }
  const kbdClassName = "inline-block cursor-pointer rounded bg-gate-primary-lv-3 px-6px text-white line-height-tight font-mono";
  function CustomKbd({
    className,
    ...restProps
  }) {
    return jsx$1("kbd", { ...restProps, className: r(kbdClassName, className) });
  }
  const antSpinIndicator = jsx$1(ForwardRef$1j, { className: "text-gate-primary [.ant-spin_.ant-spin-dot&]:size-25px" });
  const clsAntdButton = "flex items-center gap-x-1 [&.ant-btn:not(:disabled):focus-visible]:outline-0";
  function parseZ(className) {
    if (!/^z-\d+$/.test(className)) return void 0;
    return Number.parseInt(className.slice(2));
  }
  const clsZRecHeader = "z-1001";
  const clsZGateFloatEntry = "z-10004";
  const clsZBaseModal = "z-10005";
  const clsZAntdPopupBase = "z-11000";
  const clsZVideoCardLargePreview = "z-11200";
  const clsZVideoCardContextMenu = "z-11300";
  const clsZToast = "z-90000";
  const ToastClassNames = {
    default: clsx("fixed left-50% top-50% max-w-450px min-w-200px w-[max-content] translate-x--50% translate-y--50% whitespace-pre-wrap rounded-6px bg-gate-primary px-24px py-12px text-14px text-white", clsZToast),
    singleLine: "text-center"
  };
  function toast(msg, duration2 = 2e3, container = document.body) {
    const div = document.createElement("div");
    div.textContent = msg;
    const isSingleLine = !msg.includes("\n") && !msg.includes("<br");
    div.className = clsx(APP_CLS_ROOT, ToastClassNames.default, isSingleLine && ToastClassNames.singleLine);
    container.appendChild(div);
    setTimeout(() => div.remove(), duration2);
  }
  var ms$1;
  var hasRequiredMs;
  function requireMs() {
    if (hasRequiredMs) return ms$1;
    hasRequiredMs = 1;
    var s2 = 1e3;
    var m2 = s2 * 60;
    var h2 = m2 * 60;
    var d2 = h2 * 24;
    var w = d2 * 7;
    var y = d2 * 365.25;
    ms$1 = function(val, options) {
      options = options || {};
      var type4 = typeof val;
      if (type4 === "string" && val.length > 0) {
        return parse2(val);
      } else if (type4 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match2) {
        return;
      }
      var n2 = parseFloat(match2[1]);
      var type4 = (match2[2] || "ms").toLowerCase();
      switch (type4) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y;
        case "weeks":
        case "week":
        case "w":
          return n2 * w;
        case "days":
        case "day":
        case "d":
          return n2 * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return Math.round(ms2 / d2) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms2 / h2) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms2 / m2) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms2 / s2) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return plural(ms2, msAbs, d2, "day");
      }
      if (msAbs >= h2) {
        return plural(ms2, msAbs, h2, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms2, msAbs, m2, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms2, msAbs, s2, "second");
      }
      return ms2 + " ms";
    }
    function plural(ms2, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms2 / n2) + " " + name + (isPlural ? "s" : "");
    }
    return ms$1;
  }
  var msExports = requireMs();
  const ms = getDefaultExportFromCjs(msExports);
  var isAbsoluteURL;
  var hasRequiredIsAbsoluteURL;
  function requireIsAbsoluteURL() {
    if (hasRequiredIsAbsoluteURL) return isAbsoluteURL;
    hasRequiredIsAbsoluteURL = 1;
    isAbsoluteURL = function isAbsoluteURL2(url2) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
    };
    return isAbsoluteURL;
  }
  var combineURLs;
  var hasRequiredCombineURLs;
  function requireCombineURLs() {
    if (hasRequiredCombineURLs) return combineURLs;
    hasRequiredCombineURLs = 1;
    combineURLs = function combineURLs2(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
    return combineURLs;
  }
  var buildFullPath$1;
  var hasRequiredBuildFullPath;
  function requireBuildFullPath() {
    if (hasRequiredBuildFullPath) return buildFullPath$1;
    hasRequiredBuildFullPath = 1;
    var isAbsoluteURL2 = requireIsAbsoluteURL();
    var combineURLs2 = requireCombineURLs();
    buildFullPath$1 = function buildFullPath2(baseURL, requestedURL, allowAbsoluteUrls) {
      var isRelativeURL = !isAbsoluteURL2(requestedURL);
      if (baseURL && (isRelativeURL || allowAbsoluteUrls === false)) {
        return combineURLs2(baseURL, requestedURL);
      }
      return requestedURL;
    };
    return buildFullPath$1;
  }
  var buildFullPathExports = requireBuildFullPath();
  const buildFullPath = getDefaultExportFromCjs(buildFullPathExports);
  var bind;
  var hasRequiredBind;
  function requireBind() {
    if (hasRequiredBind) return bind;
    hasRequiredBind = 1;
    bind = function bind2(fn, thisArg) {
      return function wrap2() {
        return fn.apply(thisArg, arguments);
      };
    };
    return bind;
  }
  var utils$2;
  var hasRequiredUtils$1;
  function requireUtils$1() {
    if (hasRequiredUtils$1) return utils$2;
    hasRequiredUtils$1 = 1;
    var bind2 = requireBind();
    var toString2 = Object.prototype.toString;
    var kindOf = (function(cache2) {
      return function(thing) {
        var str = toString2.call(thing);
        return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
      };
    })( Object.create(null));
    function kindOfTest(type4) {
      type4 = type4.toLowerCase();
      return function isKindOf(thing) {
        return kindOf(thing) === type4;
      };
    }
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString2(val) {
      return typeof val === "string";
    }
    function isNumber2(val) {
      return typeof val === "number";
    }
    function isObject2(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject2(val) {
      if (kindOf(val) !== "object") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isEmptyObject(val) {
      return val && Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
    }
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    function isFunction2(val) {
      return toString2.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject2(val) && isFunction2(val.pipe);
    }
    function isFormData(thing) {
      var pattern4 = "[object FormData]";
      return thing && (typeof FormData === "function" && thing instanceof FormData || toString2.call(thing) === pattern4 || isFunction2(thing.toString) && thing.toString() === pattern4);
    }
    var isURLSearchParams = kindOfTest("URLSearchParams");
    function trim2(str) {
      return str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    }
    function isStandardBrowserEnv() {
      var product;
      if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
          fn.call(null, obj[i2], i2, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge2() {
      var result = {};
      function assignValue2(val, key) {
        if (isPlainObject2(result[key]) && isPlainObject2(val)) {
          result[key] = merge2(result[key], val);
        } else if (isPlainObject2(val)) {
          result[key] = merge2({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
        forEach(arguments[i2], assignValue2);
      }
      return result;
    }
    function extend(a2, b, thisArg) {
      forEach(b, function assignValue2(val, key) {
        if (thisArg && typeof val === "function") {
          a2[key] = bind2(val, thisArg);
        } else {
          a2[key] = val;
        }
      });
      return a2;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function inherits(constructor, superConstructor, props, descriptors) {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors);
      constructor.prototype.constructor = constructor;
      props && Object.assign(constructor.prototype, props);
    }
    function toFlatObject(sourceObj, destObj, filter2, propFilter) {
      var props;
      var i2;
      var prop;
      var merged = {};
      destObj = destObj || {};
      if (sourceObj == null) return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i2 = props.length;
        while (i2-- > 0) {
          prop = props[i2];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter2 !== false && Object.getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    }
    function endsWith(str, searchString, position2) {
      str = String(str);
      if (position2 === void 0 || position2 > str.length) {
        position2 = str.length;
      }
      position2 -= searchString.length;
      var lastIndex = str.indexOf(searchString, position2);
      return lastIndex !== -1 && lastIndex === position2;
    }
    function toArray2(thing) {
      if (!thing) return null;
      if (isArray(thing)) return thing;
      var i2 = thing.length;
      if (!isNumber2(i2)) return null;
      var arr = new Array(i2);
      while (i2-- > 0) {
        arr[i2] = thing[i2];
      }
      return arr;
    }
    var isTypedArray2 = (function(TypedArray) {
      return function(thing) {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
    function forEachEntry(obj, fn) {
      var generator = obj && obj[Symbol.iterator];
      var iterator2 = generator.call(obj);
      var result;
      while ((result = iterator2.next()) && !result.done) {
        var pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    }
    function matchAll(regExp, str) {
      var matches;
      var arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    }
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var hasOwnProperty = (function resolver(_hasOwnProperty) {
      return function(obj, prop) {
        return _hasOwnProperty.call(obj, prop);
      };
    })(Object.prototype.hasOwnProperty);
    utils$2 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString: isString2,
      isNumber: isNumber2,
      isObject: isObject2,
      isPlainObject: isPlainObject2,
      isEmptyObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction: isFunction2,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge: merge2,
      extend,
      trim: trim2,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray: toArray2,
      isTypedArray: isTypedArray2,
      isFileList,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty
    };
    return utils$2;
  }
  var AxiosError_1;
  var hasRequiredAxiosError;
  function requireAxiosError() {
    if (hasRequiredAxiosError) return AxiosError_1;
    hasRequiredAxiosError = 1;
    var utils2 = requireUtils$1();
    function AxiosError2(message2, code, config, request2, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message2;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request2 && (this.request = request2);
      response && (this.response = response);
    }
    utils2.inherits(AxiosError2, Error, {
      toJSON: function toJSON() {
        return {
message: this.message,
          name: this.name,
description: this.description,
          number: this.number,
fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype = AxiosError2.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
].forEach(function(code) {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError2, descriptors);
    Object.defineProperty(prototype, "isAxiosError", { value: true });
    AxiosError2.from = function(error, code, config, request2, response, customProps) {
      var axiosError = Object.create(prototype);
      utils2.toFlatObject(error, axiosError, function filter2(obj) {
        return obj !== Error.prototype;
      });
      AxiosError2.call(axiosError, error.message, code, config, request2, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    AxiosError_1 = AxiosError2;
    return AxiosError_1;
  }
  var settle$1;
  var hasRequiredSettle;
  function requireSettle() {
    if (hasRequiredSettle) return settle$1;
    hasRequiredSettle = 1;
    var AxiosError2 = requireAxiosError();
    settle$1 = function settle2(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError2(
          "Request failed with status code " + response.status,
          [AxiosError2.ERR_BAD_REQUEST, AxiosError2.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    };
    return settle$1;
  }
  var settleExports = requireSettle();
  const settle = getDefaultExportFromCjs(settleExports);
  var browser;
  var hasRequiredBrowser;
  function requireBrowser() {
    if (hasRequiredBrowser) return browser;
    hasRequiredBrowser = 1;
    browser = typeof self === "object" ? self.FormData : window.FormData;
    return browser;
  }
  var FormData$1;
  var hasRequiredFormData;
  function requireFormData() {
    if (hasRequiredFormData) return FormData$1;
    hasRequiredFormData = 1;
    FormData$1 = requireBrowser();
    return FormData$1;
  }
  var toFormData_1;
  var hasRequiredToFormData;
  function requireToFormData() {
    if (hasRequiredToFormData) return toFormData_1;
    hasRequiredToFormData = 1;
    var utils2 = requireUtils$1();
    var AxiosError2 = requireAxiosError();
    var envFormData = requireFormData();
    function isVisitable(thing) {
      return utils2.isPlainObject(thing) || utils2.isArray(thing);
    }
    function removeBrackets(key) {
      return utils2.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path) return key;
      return path.concat(key).map(function each(token2, i2) {
        token2 = removeBrackets(token2);
        return !dots && i2 ? "[" + token2 + "]" : token2;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils2.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils2.toFlatObject(utils2, {}, null, function filter2(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function isSpecCompliant(thing) {
      return thing && utils2.isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator];
    }
    function toFormData(obj, formData, options) {
      if (!utils2.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new (envFormData || FormData)();
      options = utils2.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils2.isUndefined(source[option]);
      });
      var metaTokens = options.metaTokens;
      var visitor = options.visitor || defaultVisitor;
      var dots = options.dots;
      var indexes = options.indexes;
      var _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      var useBlob = _Blob && isSpecCompliant(formData);
      if (!utils2.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null) return "";
        if (utils2.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils2.isBlob(value)) {
          throw new AxiosError2("Blob is not supported. Use a Buffer instead.");
        }
        if (utils2.isArrayBuffer(value) || utils2.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        var arr = value;
        if (value && !path && typeof value === "object") {
          if (utils2.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils2.isArray(value) && isFlatArray(value) || (utils2.isFileList(value) || utils2.endsWith(key, "[]") && (arr = utils2.toArray(value)))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils2.isUndefined(el) || el === null) && formData.append(
indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      var stack2 = [];
      var exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils2.isUndefined(value)) return;
        if (stack2.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack2.push(value);
        utils2.forEach(value, function each(el, key) {
          var result = !(utils2.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils2.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack2.pop();
      }
      if (!utils2.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    toFormData_1 = toFormData;
    return toFormData_1;
  }
  var AxiosURLSearchParams_1;
  var hasRequiredAxiosURLSearchParams;
  function requireAxiosURLSearchParams() {
    if (hasRequiredAxiosURLSearchParams) return AxiosURLSearchParams_1;
    hasRequiredAxiosURLSearchParams = 1;
    var toFormData = requireToFormData();
    function encode(str) {
      var charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'\(\)~]|%20|%00/g, function replacer(match2) {
        return charMap[match2];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append2(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      var _encode = encoder ? function(value) {
        return encoder.call(this, value, encode);
      } : encode;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    AxiosURLSearchParams_1 = AxiosURLSearchParams;
    return AxiosURLSearchParams_1;
  }
  var buildURL$1;
  var hasRequiredBuildURL;
  function requireBuildURL() {
    if (hasRequiredBuildURL) return buildURL$1;
    hasRequiredBuildURL = 1;
    var utils2 = requireUtils$1();
    var AxiosURLSearchParams = requireAxiosURLSearchParams();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    buildURL$1 = function buildURL2(url2, params, options) {
      if (!params) {
        return url2;
      }
      var hashmarkIndex = url2.indexOf("#");
      if (hashmarkIndex !== -1) {
        url2 = url2.slice(0, hashmarkIndex);
      }
      var _encode = options && options.encode || encode;
      var serializeFn = options && options.serialize;
      var serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils2.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url2;
    };
    return buildURL$1;
  }
  var buildURLExports = requireBuildURL();
  const buildURL = getDefaultExportFromCjs(buildURLExports);
  var parseHeaders$1;
  var hasRequiredParseHeaders;
  function requireParseHeaders() {
    if (hasRequiredParseHeaders) return parseHeaders$1;
    hasRequiredParseHeaders = 1;
    var utils2 = requireUtils$1();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    parseHeaders$1 = function parseHeaders2(headers) {
      var parsed2 = {};
      var key;
      var val;
      var i2;
      if (!headers) {
        return parsed2;
      }
      utils2.forEach(headers.split("\n"), function parser(line2) {
        i2 = line2.indexOf(":");
        key = utils2.trim(line2.slice(0, i2)).toLowerCase();
        val = utils2.trim(line2.slice(i2 + 1));
        if (key) {
          if (parsed2[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed2[key] = (parsed2[key] ? parsed2[key] : []).concat([val]);
          } else {
            parsed2[key] = parsed2[key] ? parsed2[key] + ", " + val : val;
          }
        }
      });
      return parsed2;
    };
    return parseHeaders$1;
  }
  var parseHeadersExports = requireParseHeaders();
  const parseHeaders = getDefaultExportFromCjs(parseHeadersExports);
  var utilsExports = requireUtils$1();
  const utils$1 = getDefaultExportFromCjs(utilsExports);
  function xhrAdapter(config) {
    return new Promise((resolve, reject) => {
      let requestData = config.data;
      const requestHeaders = config.headers ?? {};
      if (utils$1.isFormData(requestData)) {
        delete requestHeaders["Content-Type"];
      }
      if (config.auth) {
        const username = config.auth.username || "";
        const password = config.auth.password || "";
        requestHeaders.Authorization = "Basic " + Buffer.from(username + ":" + password).toString("base64");
      }
      const onerror = function handleError() {
        reject(new axios.AxiosError("Network Error", axios.AxiosError.ERR_NETWORK, config));
      };
      const ontimeout = function handleTimeout() {
        reject(new axios.AxiosError("timeout of " + config.timeout + "ms exceeded", axios.AxiosError.ECONNABORTED, config));
      };
      utils$1.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
          delete requestHeaders[key];
        }
      });
      if (requestData === void 0) {
        requestData = null;
      }
      const onload = function handleLoad(resp) {
        const responseHeaders = "responseHeaders" in resp ? parseHeaders(resp.responseHeaders) : {};
        const responseData = !config.responseType || config.responseType === "text" ? resp.responseText : resp.response;
        const response = {
          data: responseData,
          status: resp.status,
          statusText: resp.statusText,
          headers: responseHeaders,
          config,
          request: {
responseURL: resp.finalUrl,
            status: resp.status,
            statusText: resp.statusText,
            responseXML: null
          }
        };
        settle(resolve, reject, response);
      };
      if (config.cancelToken) {
        config.cancelToken.promise.then(function onCanceled(cancel) {
          reject(cancel);
        });
      }
      let responseType;
      if (config.responseType && config.responseType !== "json") {
        responseType = config.responseType;
      }
      const method4 = config.method.toUpperCase();
      if (method4 === "UNLINK" || method4 === "PURGE" || method4 === "LINK") {
        reject(new axios.AxiosError(`${method4} is not a supported method by GM.xmlHttpRequest`));
      } else {
        GM.xmlHttpRequest({
          method: method4,
          url: buildURL(buildFullPath(config.baseURL, config.url), config.params, config.paramsSerializer),
          headers: Object.fromEntries(Object.entries(requestHeaders).map(([key, val]) => [key, val.toString()])),
          responseType,
          data: requestData,
          timeout: config.timeout,
          ontimeout,
          onload,
          onerror
        });
      }
    });
  }
  const genDate = () => dayjs().format("YYYY-MM-DD");
  function dailyCache(namespace) {
    async function cleanUp() {
      const date4 = genDate();
      const keys2 = await GM.listValues();
      keys2.filter((k) => k.startsWith(`${namespace}:`) && k !== `${namespace}:${date4}`).forEach((k) => GM.deleteValue(k));
    }
    cleanUp();
    return {
      async set(val) {
        cleanUp();
        await GM.setValue(`${namespace}:${genDate()}`, val);
      },
      get() {
        cleanUp();
        return GM.getValue(`${namespace}:${genDate()}`);
      }
    };
  }
  const copyProperty = (to, from2, property, ignoreNonConfigurable) => {
    if (property === "length" || property === "prototype") {
      return;
    }
    if (property === "arguments" || property === "caller") {
      return;
    }
    const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
    const fromDescriptor = Object.getOwnPropertyDescriptor(from2, property);
    if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
      return;
    }
    Object.defineProperty(to, property, fromDescriptor);
  };
  const canCopyProperty = function(toDescriptor, fromDescriptor) {
    return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
  };
  const changePrototype = (to, from2) => {
    const fromPrototype = Object.getPrototypeOf(from2);
    if (fromPrototype === Object.getPrototypeOf(to)) {
      return;
    }
    Object.setPrototypeOf(to, fromPrototype);
  };
  const wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
  const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
  const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
  const changeToString = (to, from2, name) => {
    const withName = name === "" ? "" : `with ${name.trim()}() `;
    const newToString = wrappedToString.bind(null, withName, from2.toString());
    Object.defineProperty(newToString, "name", toStringName);
    const { writable, enumerable: enumerable4, configurable } = toStringDescriptor;
    Object.defineProperty(to, "toString", { value: newToString, writable, enumerable: enumerable4, configurable });
  };
  function mimicFunction(to, from2, { ignoreNonConfigurable = false } = {}) {
    const { name } = to;
    for (const property of Reflect.ownKeys(from2)) {
      copyProperty(to, from2, property, ignoreNonConfigurable);
    }
    changePrototype(to, from2);
    changeToString(to, from2, name);
    return to;
  }
  const cacheStore = new WeakMap();
  function pMemoize(fn, options) {
    const defaultCacheKey = ([firstArgument]) => firstArgument;
    const { cacheKey: cacheKey2 = defaultCacheKey, cache: cache2 = new Map() } = options ?? {};
    const promiseCache = new Map();
    const memoized = function(...arguments_) {
      const key = cacheKey2(arguments_);
      if (promiseCache.has(key)) {
        return promiseCache.get(key);
      }
      const promise = (async () => {
        try {
          if (cache2 && await cache2.has(key)) {
            return await cache2.get(key);
          }
          const promise2 = fn.apply(this, arguments_);
          const result = await promise2;
          try {
            return result;
          } finally {
            if (cache2) {
              const allow = options?.shouldCache ? await options.shouldCache(result, { key, argumentsList: arguments_ }) : true;
              if (allow) {
                await cache2.set(key, result);
              }
            }
          }
        } finally {
          promiseCache.delete(key);
        }
      })();
      promiseCache.set(key, promise);
      return promise;
    };
    mimicFunction(memoized, fn, {
      ignoreNonConfigurable: true
    });
    cacheStore.set(memoized, cache2);
    return memoized;
  }
  function reusePendingPromise(fn, generateKey) {
    generateKey ??= (...args) => JSON.stringify(args);
    return pMemoize(fn, {
      cache: false,
      cacheKey(args) {
        return generateKey(...args);
      }
    });
  }
  async function encWbi(_params) {
    const {
      img_key,
      sub_key
    } = await getWbiKeys();
    const mixin_key = getMixinKey(img_key + sub_key);
    const wts = Math.round(Date.now() / 1e3);
    const params = {
      ..._params,
      wts
    };
    const chr_filter = /[!'()*]/g;
    const query = Object.keys(params).sort().map((key) => {
      return `${encodeURIComponent(key)}=${encodeURIComponent(
params[key].toString().replaceAll(chr_filter, "")
    )}`;
    }).join("&");
    const wbi_sign = sparkMd5.hash(query + mixin_key);
    return {
      ...params,
      wts,
      w_rid: wbi_sign
    };
  }
  const keysCache = dailyCache("wbi-keys");
  const getWbiKeys = reusePendingPromise(async function() {
    const cached2 = await keysCache.get();
    const shouldReuse = cached2?.val && cached2?.ts && Date.now() - cached2.ts <= ms("6h");
    if (shouldReuse) return cached2.val;
    return fetchWbiKeys();
  });
  async function fetchWbiKeys() {
    const res = await axios.get("/x/web-interface/nav", {
      baseURL: HOST_API
    });
    const json = res.data;
    const img_url = json.data.wbi_img.img_url;
    const sub_url = json.data.wbi_img.sub_url;
    const keys2 = {
      img_key: img_url.slice(img_url.lastIndexOf("/") + 1, img_url.lastIndexOf(".")),
      sub_key: sub_url.slice(sub_url.lastIndexOf("/") + 1, sub_url.lastIndexOf("."))
    };
    await keysCache.set({
      val: keys2,
      ts: Date.now()
    });
    return keys2;
  }
  const mixinKeyEncTab = [46, 47, 18, 2, 53, 8, 23, 32, 15, 50, 10, 31, 58, 3, 45, 35, 27, 43, 5, 49, 33, 9, 42, 19, 29, 28, 14, 39, 12, 38, 41, 13, 37, 48, 7, 16, 24, 55, 40, 61, 26, 17, 0, 1, 60, 51, 30, 4, 22, 25, 54, 21, 56, 59, 6, 63, 57, 62, 11, 36, 20, 34, 44, 52];
  function getMixinKey(orig) {
    return mixinKeyEncTab.map((n2) => orig[n2]).join("").slice(0, 32);
  }
  function appSign(params, appkey, appsec) {
    params.appkey = appkey;
    const searchParams2 = new URLSearchParams(params);
    searchParams2.sort();
    return sparkMd5.hash(searchParams2.toString() + appsec);
  }
  const appApiCommonParams = {
    platform: "ios",
    mobi_app: "ipad",
    device: "pad",
    build: "37300100",
    c_locale: "zh-Hans_CN",
    s_locale: "zh-Hans_CN"
  };
  class NeedValidAccessKeyError extends Error {
    constructor(msg, cause) {
      msg ||= "需要有效的 access_key";
      super(msg, {
        cause
      });
      this.name = "NeedValidAccessKeyError";
    }
  }
  const request = axios.create({
    baseURL: HOST_API,
    withCredentials: true
  });
  request.interceptors.request.use(async function(config) {
    config.params ||= {};
    if (config.url?.includes("/wbi/") && !(config.params.w_rid || config.params.wts)) {
      config.params = await encWbi(config.params);
    }
    return config;
  });
  function isWebApiSuccess(json) {
    return json?.code === 0 && ["0", "success", "ok"].includes(json?.message?.toLowerCase());
  }
  class WebApiError extends Error {
    constructor(json) {
      const msg = "WebApiError: " + json.message;
      super(msg);
      this.json = json;
      this.name = "WebApiError";
    }
  }
  const gmrequest = axios.create({
adapter: xhrAdapter
  });
  gmrequest.interceptors.request.use(function(config) {
    if (!config.params?.sign) {
      const {
        appkey,
        appsec
      } = TVKeyInfo;
      config.params = {
        appkey,
        access_key: settings.accessKey || "",
        ...omit$1(config.params, ["sign"])
      };
      config.params.sign = appSign(config.params, appkey, appsec);
    }
    return config;
  });
  gmrequest.interceptors.response.use((res) => {
    if (res.config.responseType === "json" && res.data && res.data instanceof ArrayBuffer) {
      appWarn("response data is ArrayBuffer");
      const decoder = new TextDecoder();
      const u8arr = new Uint8Array(res.data);
      const text = decoder.decode(u8arr);
      res.data = text;
      try {
        res.data = JSON.parse(text);
      } catch {
      }
    }
    return res;
  });
  function parseCookie() {
    const cookies = {};
    document.cookie.split(";").map((pair) => pair.trim()).filter(Boolean).forEach((pair) => {
      const [key, val] = pair.split("=").map((s2) => s2.trim()).filter(Boolean);
      if (!key) return;
      cookies[key] = val;
    });
    return cookies;
  }
  function getCsrfToken() {
    const csrfToken = parseCookie().bili_jct;
    if (!csrfToken) {
      toast("找不到 csrf token, 请检查是否登录");
      throw new Error("找不到 csrf token, 请检查是否登录");
    }
    return csrfToken;
  }
  function getUid() {
    return parseCookie().DedeUserID;
  }
  function getHasLogined() {
    const cookies = parseCookie();
    return !!cookies.DedeUserID;
  }
  const $loginState = valtioFactory(() => {
    return {
      cookie: document.cookie,
      logined: getHasLogined()
    };
  });
  function checkLoginStatus() {
    $loginState.update();
    return $loginState.state.value.logined;
  }
  function useHasLogined() {
    return $loginState.use().logined;
  }
  async function listAll() {
    const json = (await request.get("https://member.bilibili.com/x/web/draft/list")).data;
    const drafts = json.artlist?.drafts || [];
    return drafts;
  }
  async function addupdate(payload) {
    const form = new URLSearchParams({
      title: "",
      banner_url: "",
      content: "",
      summary: "",
      words: "0",
      category: "15",
      tid: "0",
      reprint: "0",
      tags: "",
      image_urls: "",
      origin_image_urls: "",
      dynamic_intro: "",
      media_id: "0",
      spoiler: "0",
      original: "0",
      top_video_bvid: "",
      aid: "",
      csrf: getCsrfToken(),
      ...payload
    });
    const json = (await request.post("/x/article/creative/draft/addupdate", form)).data;
    const aid = json?.data?.aid?.toString();
    const success = isWebApiSuccess(json);
    if (!success) {
      toast(json.message || "addupdate error");
    }
    return {
      success,
      aid
    };
  }
  async function draftView(aid) {
    const json = (await request.get("/x/article/creative/draft/view", {
      params: {
        aid
      }
    })).data;
    return json?.data?.content || "";
  }
  class BilibiliArticleDraft {
    title;
    constructor(title) {
      this.title = title;
    }
    getData = async () => {
      const {
        title
      } = this;
      const allDrafts = await listAll();
      const draft = allDrafts.find((d2) => d2.title === title);
      if (!draft) {
        const {
          success,
          aid
        } = await addupdate({
          title
        });
        return;
      }
      const content = await draftView(draft.id);
      const parser = new DOMParser();
      const parsed2 = parser.parseFromString(content, "text/html");
      const text = (parsed2.body.textContent || "").trim();
      if (!text) return;
      try {
        return JSON.parse(text);
      } catch {
        return;
      }
    };

_aid;
    setData = async (data2) => {
      const {
        title
      } = this;
      if (!this._aid) {
        const allDrafts = await listAll();
        const draft = allDrafts.find((d2) => d2.title === title);
        if (!draft) {
          const {
            success: success2,
            aid: newDraftAid
          } = await addupdate({
            title
          });
          if (!success2) return false;
          this._aid = newDraftAid;
        } else {
          this._aid = draft.id.toString();
        }
      }
      const dataStr = JSON.stringify(data2);
      const {
        success
      } = await addupdate({
        aid: this._aid,
        title,
        content: `<p>${dataStr}</p>`,
        words: dataStr.length.toString()
      });
      return success;
    };
  }
  const debug$g = baseDebug.extend("settings");
  const articleDraft = new BilibiliArticleDraft(APP_NAME);
  const privateKeys = ["accessKey", "accessKeyExpireAt"];
  const getBackupOmitPaths = () => [
    ...privateKeys,
    ...internalBooleanPaths,
"backupSettingsToArticleDraft",
"fav.addSeparator",
    "watchlaterAddSeparator",
    "watchlaterItemsOrder",
    "popularWeeklyUseShuffle",
    "popularGeneralUseAnonymous"
  ];
  const restoreOmitPaths = [
    ...privateKeys,
"backupSettingsToArticleDraft"
  ];
  let HAS_RESTORED_SETTINGS = false;
  function set_HAS_RESTORED_SETTINGS(val) {
    HAS_RESTORED_SETTINGS = val;
  }
  let lastBackupVal;
  const setDataThrottled = throttle$2(articleDraft.setData, ms("5s"));
  async function saveToDraft(val) {
    if (!val.backupSettingsToArticleDraft) return;
    if (HAS_RESTORED_SETTINGS) return;
    const {
      pickedSettings: currentBackupVal
    } = pickSettings(val, allowedLeafSettingsPaths, getBackupOmitPaths());
    const shouldBackup = !lastBackupVal || !isEqual$2(lastBackupVal, currentBackupVal);
    if (!shouldBackup) return;
    try {
      await setDataThrottled(currentBackupVal);
      lastBackupVal = currentBackupVal;
      debug$g("backup to article draft complete");
    } catch (e) {
      console.error(e.stack || e);
    }
  }
  const debug$f = baseDebug.extend("settings");
  const initialSettings = {
    accessKey: "",
    accessKeyExpireAt: 0,


pureRecommend: true,
appRecommend: {
      addOtherTabContents: false
},

modalFeedFullScreen: false,
grid: {
useCustomGrid: true,
gridDisplayMode: EGridDisplayMode.NormalGrid,
twoColumnModeAlign: ETwoColumnModeAlign.Center,
enableForceColumn: false,
      forceColumnCount: 4,
cardMinWidth: 320
    },
videoCard: {
actions: {
        openInPipWindow: false,
        showLargePreview: true
      },
videoPreview: {
        useMp4: true,
useScale: false,
useVideoCardAsTrigger: false,
usePreferredCdn: true,
        addTo: {
          searchPage: true
        }
      },
      imgPreview: {
        enabled: true,
autoPreviewWhenKeyboardSelect: false,
autoPreviewWhenHover: true,
disableWhenMultiSelecting: true
      }
    },

autoPreviewUpdateInterval: 700,
useDelayForHover: false,
enableSidebar: true,
    sidebarAlign: ESidebarAlign.Right,
dynamicFeed: {
      showLive: true,
videoOnly: false,
followGroup: {
        enabled: true,
forceUseMergeTimelineIds: []
      },
      whenViewAll: {
        enableHideSomeContents: false,
hideIds: []
},
      advancedFilter: false,
      __internal: {
        cacheAllItemsEntry: false,
        cacheAllItemsUpMids: [],
externalFilterInput: false
}
    },
watchlaterAddSeparator: true,
watchlaterItemsOrder: WatchlaterItemsOrder.AddTimeDesc,
watchlaterUseNormalVideoUrl: false,

fav: {
addSeparator: true,
excludedFolderIds: [],
useCustomFavPicker: {
        onPlayPage: false
      }
    },
popularGeneralUseAnonymous: false,

popularWeeklyUseShuffle: false,


spaceUpload: {
      showVol: false,
      useSyncFilterTextFromSearchText: false
    },
filter: {
      enabled: true,
minDuration: {
        enabled: false,
        value: 60
},
minPlayCount: {
        enabled: false,
        value: 1e4
      },
minDanmakuCount: {
        enabled: false,
        value: 10
      },
exemptForFollowed: {
        video: true,
picture: true
      },
hideGotoTypePicture: false,
      hideGotoTypeBangumi: false,
      byAuthor: {
        enabled: false,
        keywords: []
      },
      byTitle: {
        enabled: false,
        keywords: []
      },
dfByTitle: {
        enabled: false,
        keywords: []
      },
      dfHideOpusMids: {
        enabled: false,
        keywords: []
      }
    },
style: {
      general: {
        popoverBorderColorUseColorPrimary: false
      },
      pureRecommend: {
useStickyTabbar: true,
stickyTabbarShadow: false,
useWhiteBackground: true,
hideTopChannel: false
      },
      videoCard: {

useBorder: true,
        useBorderOnlyOnHover: true,
        useBoxShadow: false
      }
    },
theme: "",
    colorPickerThemeSelectedColor: "",


backupSettingsToArticleDraft: false,
videoLinkOpenMode: EVideoLinkOpenMode.Normal,
    pipWindow: {
      defaultLocked: true,
autoWebFullscreen: true
},
hidingTabKeys: [ETab.KeepFollowOnly, ETab.Live, ETab.Liked],
    customTabKeysOrder: [],
    showBackForwardButtons: false,
multiSelect: {
      clearWhenExit: true,
      showIcon: true
    },
__internalEnableCopyBvidInfo: false,
__internalAddTabbarCopyBvidButton: false,
    __internalHotSubUseDropdown: false,
    __internalRecTabRenderAsSegments: false
  };
  const settings = proxy(cloneDeep(initialSettings));
  const allowedLeafSettingsPaths = getLeafPaths(initialSettings);
  const internalBooleanPaths = allowedLeafSettingsPaths.filter((p2) => p2.includes("__internal") && typeof get$1(initialSettings, p2) === "boolean");
  debug$f("allowedLeafSettingsPaths = %O, internalBooleanPaths = %O", allowedLeafSettingsPaths, internalBooleanPaths);
  function useSettingsSnapshot(options) {
    return useSnapshot(settings, options);
  }
  function getSettingsSnapshot() {
    return snapshot(settings);
  }
  const storageKey$1 = `settings`;
  async function __pickSettingsFromGmStorage() {
    const saved = await GM.getValue(storageKey$1);
    if (!saved || typeof saved !== "object") return {};
    runSettingsMigration(saved);
    return pickSettings(saved, allowedLeafSettingsPaths).pickedSettings;
  }
  async function loadAndSetup() {
    const val = await __pickSettingsFromGmStorage();
    updateSettings(val);
    subscribe$3(settings, () => {
      _onSettingsChange();
    });
    reciveGmValueUpdatesFromOtherTab({
      storageKey: storageKey$1,
      setPersist(val2) {
        _persist = val2;
      },
      onUpdate(newValue) {
        updateSettings(newValue);
      }
    });
  }
  async function _onSettingsChange() {
    const snap = cloneDeep(snapshot(settings));
    await _saveToGmStorage(snap);
    await saveToDraft(snap);
  }
  let _persist = true;
  async function _saveToGmStorage(snap) {
    if (!_persist) return;
    await GM.setValue(storageKey$1, snap);
  }
  function updateSettings(payload) {
    const {
      pickedPaths
    } = pickSettings(payload, allowedLeafSettingsPaths);
    for (const p2 of pickedPaths) {
      const v = get$1(payload, p2);
      set$1(settings, p2, v);
    }
  }
  function resetSettings() {
    return updateSettings(initialSettings);
  }
  function runSettingsMigration(val) {
    if (!val) return;
    const config = [
      ["dynamicFeed.showLive", "dynamicFeedShowLive"],
      ["dynamicFeed.followGroup.enabled", "dynamicFeedFollowGroupEnabled"],
      ["dynamicFeed.followGroup.forceUseMergeTimelineIds", "dynamicFeedFollowGroupForceUseMergeTimelineIds"],
      ["dynamicFeed.whenViewAll.enableHideSomeContents", "dynamicFeedWhenViewAllEnableHideSomeContents"],
      ["dynamicFeed.whenViewAll.hideIds", "dynamicFeedWhenViewAllHideIds"],

["fav.addSeparator", "favAddSeparator"],
      ["fav.excludedFolderIds", "favExcludedFolderIds"],
      ["filter.enabled", "filterEnabled"],
      ["filter.minPlayCount.enabled", "filterMinPlayCountEnabled"],
      ["filter.minPlayCount.value", "filterMinPlayCount"],
      ["filter.minDuration.enabled", "filterMinDurationEnabled"],
      ["filter.minDuration.value", "filterMinDuration"],
      ["filter.exemptForFollowed.video", "exemptForFollowedVideo"],
      ["filter.exemptForFollowed.picture", "exemptForFollowedPicture"],
      ["filter.hideGotoTypePicture", "filterOutGotoTypePicture"],
      ["filter.hideGotoTypeBangumi", "filterOutGotoTypeBangumi"],
      ["filter.byAuthor.enabled", "filterByAuthorNameEnabled"],
      ["filter.byAuthor.keywords", "filterByAuthorNameKeywords"],
      ["filter.byTitle.enabled", "filterByTitleEnabled"],
      ["filter.byTitle.keywords", "filterByTitleKeywords"],
["style.pureRecommend.useStickyTabbar", "styleUseStickyTabbarInPureRecommend"],
["style.pureRecommend.useWhiteBackground", "styleUseWhiteBackground"],
      ["style.pureRecommend.hideTopChannel", "styleHideTopChannel"],
      ["style.videoCard.useBorder", "styleUseCardBorder"],
      ["style.videoCard.useBorderOnlyOnHover", "styleUseCardBorderOnlyOnHover"],
      ["style.videoCard.useBoxShadow", "styleUseCardBoxShadow"],
["pipWindow.defaultLocked", "pipWindowDefaultLocked"],
["videoCard.imgPreview.autoPreviewWhenKeyboardSelect", "autoPreviewWhenKeyboardSelect"],
      ["videoCard.imgPreview.autoPreviewWhenHover", "autoPreviewWhenHover"],
["grid.useCustomGrid", "style.pureRecommend.useCustomGrid"],
["grid.enableForceColumn", "grid.enableForceCoumn"],
["dynamicFeed.advancedFilter", "dynamicFeedAdvancedSearch"],
      ["dynamicFeed.advancedFilter", "dynamicFeed.advancedSearch"]
    ];
    for (const [configPath, legacyConfigPath] of config) {
      const haveValue = (v) => !isNil(v);
      if (haveValue(get$1(val, configPath))) {
        continue;
      }
      if (!haveValue(get$1(val, legacyConfigPath))) {
        continue;
      }
      set$1(val, configPath, get$1(val, legacyConfigPath));
    }
  }
  function pickSettings(source, paths, omit2 = []) {
    const pickedSettings = {};
    const pickedPaths = paths.filter((p2) => allowedLeafSettingsPaths.includes(p2) && !omit2.includes(p2) && !isNil(get$1(source, p2)));
    pickedPaths.forEach((p2) => {
      const v = get$1(source, p2);
      set$1(pickedSettings, p2, v);
    });
    return {
      pickedPaths,
      pickedSettings
    };
  }
  function useSettingsInnerArray(path) {
    const snap = useSettingsSnapshot();
    return get$1(snap, path);
  }
  async function getNewestValueOfSettingsInnerArray(path) {
    const newest = await __pickSettingsFromGmStorage();
    return get$1(newest, path) || get$1(getSettingsSnapshot(), path);
  }
  function setSettingsInnerArray(path, value) {
    set$1(settings, path, value);
  }
  async function updateSettingsInnerArray(path, {
    add: add2,
    remove
  }) {
    const arr = await getNewestValueOfSettingsInnerArray(path);
    const s2 = new Set(arr);
    for (const x of add2 ?? []) s2.add(x);
    for (const x of remove ?? []) s2.delete(x);
    setSettingsInnerArray(path, Array.from(s2));
  }
  await( loadAndSetup());
  if (IN_BILIBILI_HOMEPAGE && settings.accessKey && settings.accessKeyExpireAt && Date.now() >= settings.accessKeyExpireAt) {
    toast("access_key 已过期, 请重新获取 !!!");
  }
  var duration$2 = { exports: {} };
  var duration$1 = duration$2.exports;
  var hasRequiredDuration;
  function requireDuration() {
    if (hasRequiredDuration) return duration$2.exports;
    hasRequiredDuration = 1;
    (function(module, exports$1) {
      !(function(t2, s2) {
        module.exports = s2();
      })(duration$1, (function() {
        var t2, s2, n2 = 1e3, i2 = 6e4, e = 36e5, r2 = 864e5, o2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, u2 = 31536e6, d2 = 2628e6, a2 = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/, h2 = { years: u2, months: d2, days: r2, hours: e, minutes: i2, seconds: n2, milliseconds: 1, weeks: 6048e5 }, c2 = function(t3) {
          return t3 instanceof g2;
        }, f2 = function(t3, s3, n3) {
          return new g2(t3, n3, s3.$l);
        }, m2 = function(t3) {
          return s2.p(t3) + "s";
        }, l2 = function(t3) {
          return t3 < 0;
        }, $ = function(t3) {
          return l2(t3) ? Math.ceil(t3) : Math.floor(t3);
        }, y = function(t3) {
          return Math.abs(t3);
        }, v = function(t3, s3) {
          return t3 ? l2(t3) ? { negative: true, format: "" + y(t3) + s3 } : { negative: false, format: "" + t3 + s3 } : { negative: false, format: "" };
        }, g2 = (function() {
          function l3(t3, s3, n3) {
            var i3 = this;
            if (this.$d = {}, this.$l = n3, void 0 === t3 && (this.$ms = 0, this.parseFromMilliseconds()), s3) return f2(t3 * h2[m2(s3)], this);
            if ("number" == typeof t3) return this.$ms = t3, this.parseFromMilliseconds(), this;
            if ("object" == typeof t3) return Object.keys(t3).forEach((function(s4) {
              i3.$d[m2(s4)] = t3[s4];
            })), this.calMilliseconds(), this;
            if ("string" == typeof t3) {
              var e2 = t3.match(a2);
              if (e2) {
                var r3 = e2.slice(2).map((function(t4) {
                  return null != t4 ? Number(t4) : 0;
                }));
                return this.$d.years = r3[0], this.$d.months = r3[1], this.$d.weeks = r3[2], this.$d.days = r3[3], this.$d.hours = r3[4], this.$d.minutes = r3[5], this.$d.seconds = r3[6], this.calMilliseconds(), this;
              }
            }
            return this;
          }
          var y2 = l3.prototype;
          return y2.calMilliseconds = function() {
            var t3 = this;
            this.$ms = Object.keys(this.$d).reduce((function(s3, n3) {
              return s3 + (t3.$d[n3] || 0) * h2[n3];
            }), 0);
          }, y2.parseFromMilliseconds = function() {
            var t3 = this.$ms;
            this.$d.years = $(t3 / u2), t3 %= u2, this.$d.months = $(t3 / d2), t3 %= d2, this.$d.days = $(t3 / r2), t3 %= r2, this.$d.hours = $(t3 / e), t3 %= e, this.$d.minutes = $(t3 / i2), t3 %= i2, this.$d.seconds = $(t3 / n2), t3 %= n2, this.$d.milliseconds = t3;
          }, y2.toISOString = function() {
            var t3 = v(this.$d.years, "Y"), s3 = v(this.$d.months, "M"), n3 = +this.$d.days || 0;
            this.$d.weeks && (n3 += 7 * this.$d.weeks);
            var i3 = v(n3, "D"), e2 = v(this.$d.hours, "H"), r3 = v(this.$d.minutes, "M"), o3 = this.$d.seconds || 0;
            this.$d.milliseconds && (o3 += this.$d.milliseconds / 1e3, o3 = Math.round(1e3 * o3) / 1e3);
            var u3 = v(o3, "S"), d3 = t3.negative || s3.negative || i3.negative || e2.negative || r3.negative || u3.negative, a3 = e2.format || r3.format || u3.format ? "T" : "", h3 = (d3 ? "-" : "") + "P" + t3.format + s3.format + i3.format + a3 + e2.format + r3.format + u3.format;
            return "P" === h3 || "-P" === h3 ? "P0D" : h3;
          }, y2.toJSON = function() {
            return this.toISOString();
          }, y2.format = function(t3) {
            var n3 = t3 || "YYYY-MM-DDTHH:mm:ss", i3 = { Y: this.$d.years, YY: s2.s(this.$d.years, 2, "0"), YYYY: s2.s(this.$d.years, 4, "0"), M: this.$d.months, MM: s2.s(this.$d.months, 2, "0"), D: this.$d.days, DD: s2.s(this.$d.days, 2, "0"), H: this.$d.hours, HH: s2.s(this.$d.hours, 2, "0"), m: this.$d.minutes, mm: s2.s(this.$d.minutes, 2, "0"), s: this.$d.seconds, ss: s2.s(this.$d.seconds, 2, "0"), SSS: s2.s(this.$d.milliseconds, 3, "0") };
            return n3.replace(o2, (function(t4, s3) {
              return s3 || String(i3[t4]);
            }));
          }, y2.as = function(t3) {
            return this.$ms / h2[m2(t3)];
          }, y2.get = function(t3) {
            var s3 = this.$ms, n3 = m2(t3);
            return "milliseconds" === n3 ? s3 %= 1e3 : s3 = "weeks" === n3 ? $(s3 / h2[n3]) : this.$d[n3], s3 || 0;
          }, y2.add = function(t3, s3, n3) {
            var i3;
            return i3 = s3 ? t3 * h2[m2(s3)] : c2(t3) ? t3.$ms : f2(t3, this).$ms, f2(this.$ms + i3 * (n3 ? -1 : 1), this);
          }, y2.subtract = function(t3, s3) {
            return this.add(t3, s3, true);
          }, y2.locale = function(t3) {
            var s3 = this.clone();
            return s3.$l = t3, s3;
          }, y2.clone = function() {
            return f2(this.$ms, this);
          }, y2.humanize = function(s3) {
            return t2().add(this.$ms, "ms").locale(this.$l).fromNow(!s3);
          }, y2.valueOf = function() {
            return this.asMilliseconds();
          }, y2.milliseconds = function() {
            return this.get("milliseconds");
          }, y2.asMilliseconds = function() {
            return this.as("milliseconds");
          }, y2.seconds = function() {
            return this.get("seconds");
          }, y2.asSeconds = function() {
            return this.as("seconds");
          }, y2.minutes = function() {
            return this.get("minutes");
          }, y2.asMinutes = function() {
            return this.as("minutes");
          }, y2.hours = function() {
            return this.get("hours");
          }, y2.asHours = function() {
            return this.as("hours");
          }, y2.days = function() {
            return this.get("days");
          }, y2.asDays = function() {
            return this.as("days");
          }, y2.weeks = function() {
            return this.get("weeks");
          }, y2.asWeeks = function() {
            return this.as("weeks");
          }, y2.months = function() {
            return this.get("months");
          }, y2.asMonths = function() {
            return this.as("months");
          }, y2.years = function() {
            return this.get("years");
          }, y2.asYears = function() {
            return this.as("years");
          }, l3;
        })(), p2 = function(t3, s3, n3) {
          return t3.add(s3.years() * n3, "y").add(s3.months() * n3, "M").add(s3.days() * n3, "d").add(s3.hours() * n3, "h").add(s3.minutes() * n3, "m").add(s3.seconds() * n3, "s").add(s3.milliseconds() * n3, "ms");
        };
        return function(n3, i3, e2) {
          t2 = e2, s2 = e2().$utils(), e2.duration = function(t3, s3) {
            var n4 = e2.locale();
            return f2(t3, { $l: n4 }, s3);
          }, e2.isDuration = c2;
          var r3 = i3.prototype.add, o3 = i3.prototype.subtract;
          i3.prototype.add = function(t3, s3) {
            return c2(t3) ? p2(this, t3, 1) : r3.bind(this)(t3, s3);
          }, i3.prototype.subtract = function(t3, s3) {
            return c2(t3) ? p2(this, t3, -1) : o3.bind(this)(t3, s3);
          };
        };
      }));
    })(duration$2);
    return duration$2.exports;
  }
  var durationExports = requireDuration();
  const duration = getDefaultExportFromCjs(durationExports);
  function insertWithoutScoping(cache2, serialized) {
    if (cache2.inserted[serialized.name] === void 0) {
      return cache2.insert("", serialized, cache2.sheet, true);
    }
  }
  function merge(registered, css2, className) {
    var registeredStyles = [];
    var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
    if (registeredStyles.length < 2) {
      return className;
    }
    return rawClassName + css2(registeredStyles);
  }
  var createEmotion = function createEmotion2(options) {
    var cache2 = createCache$1(options);
    cache2.sheet.speedy = function(value) {
      this.isSpeedy = value;
    };
    cache2.compat = true;
    var css2 = function css3() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var serialized = serializeStyles(args, cache2.registered, void 0);
      insertStyles(cache2, serialized, false);
      return cache2.key + "-" + serialized.name;
    };
    var keyframes2 = function keyframes3() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      var serialized = serializeStyles(args, cache2.registered);
      var animation = "animation-" + serialized.name;
      insertWithoutScoping(cache2, {
        name: serialized.name,
        styles: "@keyframes " + animation + "{" + serialized.styles + "}"
      });
      return animation;
    };
    var injectGlobal = function injectGlobal2() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      var serialized = serializeStyles(args, cache2.registered);
      insertWithoutScoping(cache2, serialized);
    };
    var cx = function cx2() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return merge(cache2.registered, css2, classnames(args));
    };
    return {
      css: css2,
      cx,
      injectGlobal,
      keyframes: keyframes2,
      hydrate: function hydrate(ids2) {
        ids2.forEach(function(key) {
          cache2.inserted[key] = true;
        });
      },
      flush: function flush() {
        cache2.registered = {};
        cache2.inserted = {};
        cache2.sheet.flush();
      },
      sheet: cache2.sheet,
      cache: cache2,
      getRegisteredStyles: getRegisteredStyles.bind(null, cache2.registered),
      merge: merge.bind(null, cache2.registered, css2)
    };
  };
  var classnames = function classnames2(args) {
    var cls = "";
    for (var i2 = 0; i2 < args.length; i2++) {
      var arg = args[i2];
      if (arg == null) continue;
      var toAdd = void 0;
      switch (typeof arg) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(arg)) {
            toAdd = classnames2(arg);
          } else {
            toAdd = "";
            for (var k in arg) {
              if (arg[k] && k) {
                toAdd && (toAdd += " ");
                toAdd += k;
              }
            }
          }
          break;
        }
        default: {
          toAdd = arg;
        }
      }
      if (toAdd) {
        cls && (cls += " ");
        cls += toAdd;
      }
    }
    return cls;
  };
  var jsx2 = function jsx3(type4, props) {
    var args = arguments;
    if (props == null || !hasOwn.call(props, "css")) {
      return reactExports.createElement.apply(void 0, args);
    }
    var argsLength = args.length;
    var createElementArgArray = new Array(argsLength);
    createElementArgArray[0] = Emotion$1;
    createElementArgArray[1] = createEmotionProps(type4, props);
    for (var i2 = 2; i2 < argsLength; i2++) {
      createElementArgArray[i2] = args[i2];
    }
    return reactExports.createElement.apply(null, createElementArgArray);
  };
  (function(_jsx) {
    var JSX;
(function(_JSX) {
    })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
  })(jsx2 || (jsx2 = {}));
  var Global = withEmotionCache(function(props, cache2) {
    var styles = props.styles;
    var serialized = serializeStyles([styles], void 0, reactExports.useContext(ThemeContext));
    var sheetRef = reactExports.useRef();
    useInsertionEffectWithLayoutFallback(function() {
      var key = cache2.key + "-global";
      var sheet = new cache2.sheet.constructor({
        key,
        nonce: cache2.sheet.nonce,
        container: cache2.sheet.container,
        speedy: cache2.sheet.isSpeedy
      });
      var rehydrating = false;
      var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
      if (cache2.sheet.tags.length) {
        sheet.before = cache2.sheet.tags[0];
      }
      if (node2 !== null) {
        rehydrating = true;
        node2.setAttribute("data-emotion", key);
        sheet.hydrate([node2]);
      }
      sheetRef.current = [sheet, rehydrating];
      return function() {
        sheet.flush();
      };
    }, [cache2]);
    useInsertionEffectWithLayoutFallback(function() {
      var sheetRefCurrent = sheetRef.current;
      var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
      if (rehydrating) {
        sheetRefCurrent[1] = false;
        return;
      }
      if (serialized.next !== void 0) {
        insertStyles(cache2, serialized.next, true);
      }
      if (sheet.tags.length) {
        var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
        sheet.before = element;
        sheet.flush();
      }
      cache2.insert("", serialized, sheet, false);
    }, [cache2, serialized.name]);
    return null;
  });
  function css() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return serializeStyles(args);
  }
  var zh_CN$6 = {};
  var interopRequireDefault = { exports: {} };
  var hasRequiredInteropRequireDefault;
  function requireInteropRequireDefault() {
    if (hasRequiredInteropRequireDefault) return interopRequireDefault.exports;
    hasRequiredInteropRequireDefault = 1;
    (function(module) {
      function _interopRequireDefault(e) {
        return e && e.__esModule ? e : {
          "default": e
        };
      }
      module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(interopRequireDefault);
    return interopRequireDefault.exports;
  }
  var zh_CN$5 = {};
  var hasRequiredZh_CN$6;
  function requireZh_CN$6() {
    if (hasRequiredZh_CN$6) return zh_CN$5;
    hasRequiredZh_CN$6 = 1;
    Object.defineProperty(zh_CN$5, "__esModule", {
      value: true
    });
    zh_CN$5.default = void 0;
    const locale2 = {
items_per_page: "条/页",
      jump_to: "跳至",
      jump_to_confirm: "确定",
      page: "页",
prev_page: "上一页",
      next_page: "下一页",
      prev_5: "向前 5 页",
      next_5: "向后 5 页",
      prev_3: "向前 3 页",
      next_3: "向后 3 页",
      page_size: "页码"
    };
    zh_CN$5.default = locale2;
    return zh_CN$5;
  }
  var zh_CN$4 = {};
  var zh_CN$3 = {};
  var zh_CN$2 = {};
  var common = {};
  var hasRequiredCommon;
  function requireCommon() {
    if (hasRequiredCommon) return common;
    hasRequiredCommon = 1;
    Object.defineProperty(common, "__esModule", {
      value: true
    });
    common.commonLocale = void 0;
    common.commonLocale = {
      yearFormat: "YYYY",
      dayFormat: "D",
      cellMeridiemFormat: "A",
      monthBeforeYear: true
    };
    return common;
  }
  var hasRequiredZh_CN$5;
  function requireZh_CN$5() {
    if (hasRequiredZh_CN$5) return zh_CN$2;
    hasRequiredZh_CN$5 = 1;
    Object.defineProperty(zh_CN$2, "__esModule", {
      value: true
    });
    zh_CN$2.default = void 0;
    var _common = requireCommon();
    function _typeof2(o2) {
      "@babel/helpers - typeof";
      return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, _typeof2(o2);
    }
    function ownKeys2(e, r2) {
      var t2 = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o2 = Object.getOwnPropertySymbols(e);
        r2 && (o2 = o2.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e, r3).enumerable;
        })), t2.push.apply(t2, o2);
      }
      return t2;
    }
    function _objectSpread3(e) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys2(Object(t2), true).forEach(function(r3) {
          _defineProperty2(e, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys2(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e;
    }
    function _defineProperty2(obj, key, value) {
      key = _toPropertyKey2(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey2(t2) {
      var i2 = _toPrimitive2(t2, "string");
      return "symbol" == _typeof2(i2) ? i2 : String(i2);
    }
    function _toPrimitive2(t2, r2) {
      if ("object" != _typeof2(t2) || !t2) return t2;
      var e = t2[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i2 = e.call(t2, r2);
        if ("object" != _typeof2(i2)) return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    var locale2 = _objectSpread3(_objectSpread3({}, _common.commonLocale), {}, {
      locale: "zh_CN",
      today: "今天",
      now: "此刻",
      backToToday: "返回今天",
      ok: "确定",
      timeSelect: "选择时间",
      dateSelect: "选择日期",
      weekSelect: "选择周",
      clear: "清除",
      week: "周",
      month: "月",
      year: "年",
      previousMonth: "上个月 (翻页上键)",
      nextMonth: "下个月 (翻页下键)",
      monthSelect: "选择月份",
      yearSelect: "选择年份",
      decadeSelect: "选择年代",
      previousYear: "上一年 (Control键加左方向键)",
      nextYear: "下一年 (Control键加右方向键)",
      previousDecade: "上一年代",
      nextDecade: "下一年代",
      previousCentury: "上一世纪",
      nextCentury: "下一世纪",
      yearFormat: "YYYY年",
      cellDateFormat: "D",
      monthBeforeYear: false
    });
    zh_CN$2.default = locale2;
    return zh_CN$2;
  }
  var zh_CN$1 = {};
  var hasRequiredZh_CN$4;
  function requireZh_CN$4() {
    if (hasRequiredZh_CN$4) return zh_CN$1;
    hasRequiredZh_CN$4 = 1;
    Object.defineProperty(zh_CN$1, "__esModule", {
      value: true
    });
    zh_CN$1.default = void 0;
    const locale2 = {
      placeholder: "请选择时间",
      rangePlaceholder: ["开始时间", "结束时间"]
    };
    zh_CN$1.default = locale2;
    return zh_CN$1;
  }
  var hasRequiredZh_CN$3;
  function requireZh_CN$3() {
    if (hasRequiredZh_CN$3) return zh_CN$3;
    hasRequiredZh_CN$3 = 1;
    var _interopRequireDefault = requireInteropRequireDefault().default;
    Object.defineProperty(zh_CN$3, "__esModule", {
      value: true
    });
    zh_CN$3.default = void 0;
    var _zh_CN = _interopRequireDefault(requireZh_CN$5());
    var _zh_CN2 = _interopRequireDefault( requireZh_CN$4());
    const locale2 = {
      lang: {
        placeholder: "请选择日期",
        yearPlaceholder: "请选择年份",
        quarterPlaceholder: "请选择季度",
        monthPlaceholder: "请选择月份",
        weekPlaceholder: "请选择周",
        rangePlaceholder: ["开始日期", "结束日期"],
        rangeYearPlaceholder: ["开始年份", "结束年份"],
        rangeMonthPlaceholder: ["开始月份", "结束月份"],
        rangeQuarterPlaceholder: ["开始季度", "结束季度"],
        rangeWeekPlaceholder: ["开始周", "结束周"],
        ..._zh_CN.default
      },
      timePickerLocale: {
        ..._zh_CN2.default
      }
    };
    locale2.lang.ok = "确定";
    zh_CN$3.default = locale2;
    return zh_CN$3;
  }
  var hasRequiredZh_CN$2;
  function requireZh_CN$2() {
    if (hasRequiredZh_CN$2) return zh_CN$4;
    hasRequiredZh_CN$2 = 1;
    var _interopRequireDefault = requireInteropRequireDefault().default;
    Object.defineProperty(zh_CN$4, "__esModule", {
      value: true
    });
    zh_CN$4.default = void 0;
    var _zh_CN = _interopRequireDefault( requireZh_CN$3());
    zh_CN$4.default = _zh_CN.default;
    return zh_CN$4;
  }
  var hasRequiredZh_CN$1;
  function requireZh_CN$1() {
    if (hasRequiredZh_CN$1) return zh_CN$6;
    hasRequiredZh_CN$1 = 1;
    var _interopRequireDefault = requireInteropRequireDefault().default;
    Object.defineProperty(zh_CN$6, "__esModule", {
      value: true
    });
    zh_CN$6.default = void 0;
    var _zh_CN = _interopRequireDefault(requireZh_CN$6());
    var _zh_CN2 = _interopRequireDefault( requireZh_CN$2());
    var _zh_CN3 = _interopRequireDefault( requireZh_CN$3());
    var _zh_CN4 = _interopRequireDefault( requireZh_CN$4());
    const typeTemplate2 = "${label}不是一个有效的${type}";
    const localeValues2 = {
      locale: "zh-cn",
      Pagination: _zh_CN.default,
      DatePicker: _zh_CN3.default,
      TimePicker: _zh_CN4.default,
      Calendar: _zh_CN2.default,
global: {
        placeholder: "请选择",
        close: "关闭",
        sortable: "可排序"
      },
      Table: {
        filterTitle: "筛选",
        filterConfirm: "确定",
        filterReset: "重置",
        filterEmptyText: "无筛选项",
        filterCheckAll: "全选",
        filterSearchPlaceholder: "在筛选项中搜索",
        emptyText: "暂无数据",
        selectAll: "全选当页",
        selectInvert: "反选当页",
        selectNone: "清空所有",
        selectionAll: "全选所有",
        sortTitle: "排序",
        expand: "展开行",
        collapse: "关闭行",
        triggerDesc: "点击降序",
        triggerAsc: "点击升序",
        cancelSort: "取消排序"
      },
      Modal: {
        okText: "确定",
        cancelText: "取消",
        justOkText: "知道了"
      },
      Tour: {
        Next: "下一步",
        Previous: "上一步",
        Finish: "结束导览"
      },
      Popconfirm: {
        cancelText: "取消",
        okText: "确定"
      },
      Transfer: {
        titles: ["", ""],
        searchPlaceholder: "请输入搜索内容",
        itemUnit: "项",
        itemsUnit: "项",
        remove: "删除",
        selectCurrent: "全选当页",
        removeCurrent: "删除当页",
        selectAll: "全选所有",
        deselectAll: "取消全选",
        removeAll: "删除全部",
        selectInvert: "反选当页"
      },
      Upload: {
        uploading: "文件上传中",
        removeFile: "删除文件",
        uploadError: "上传错误",
        previewFile: "预览文件",
        downloadFile: "下载文件"
      },
      Empty: {
        description: "暂无数据"
      },
      Icon: {
        icon: "图标"
      },
      Text: {
        edit: "编辑",
        copy: "复制",
        copied: "复制成功",
        expand: "展开",
        collapse: "收起"
      },
      Form: {
        optional: "（可选）",
        defaultValidateMessages: {
          default: "字段验证错误${label}",
          required: "请输入${label}",
          enum: "${label}必须是其中一个[${enum}]",
          whitespace: "${label}不能为空字符",
          date: {
            format: "${label}日期格式无效",
            parse: "${label}不能转换为日期",
            invalid: "${label}是一个无效日期"
          },
          types: {
            string: typeTemplate2,
            method: typeTemplate2,
            array: typeTemplate2,
            object: typeTemplate2,
            number: typeTemplate2,
            date: typeTemplate2,
            boolean: typeTemplate2,
            integer: typeTemplate2,
            float: typeTemplate2,
            regexp: typeTemplate2,
            email: typeTemplate2,
            url: typeTemplate2,
            hex: typeTemplate2
          },
          string: {
            len: "${label}须为${len}个字符",
            min: "${label}最少${min}个字符",
            max: "${label}最多${max}个字符",
            range: "${label}须在${min}-${max}字符之间"
          },
          number: {
            len: "${label}必须等于${len}",
            min: "${label}最小值为${min}",
            max: "${label}最大值为${max}",
            range: "${label}须在${min}-${max}之间"
          },
          array: {
            len: "须为${len}个${label}",
            min: "最少${min}个${label}",
            max: "最多${max}个${label}",
            range: "${label}数量须在${min}-${max}之间"
          },
          pattern: {
            mismatch: "${label}与模式不匹配${pattern}"
          }
        }
      },
      QRCode: {
        expired: "二维码过期",
        refresh: "点击刷新",
        scanned: "已扫描"
      },
      ColorPicker: {
        presetEmpty: "暂无",
        transparent: "无色",
        singleColor: "单色",
        gradientColor: "渐变色"
      }
    };
    zh_CN$6.default = localeValues2;
    return zh_CN$6;
  }
  var zh_CN;
  var hasRequiredZh_CN;
  function requireZh_CN() {
    if (hasRequiredZh_CN) return zh_CN;
    hasRequiredZh_CN = 1;
    zh_CN = requireZh_CN$1();
    return zh_CN;
  }
  var zh_CNExports = requireZh_CN();
  const zhCN = getDefaultExportFromCjs(zh_CNExports);
  const appCustomFontId = "--bilibili-gate--font";
  const appVideoCardBorderRadiusId = "--bilibili-gate--video-card--border-radius";
  const appPrimaryColorId = "--bilibili-gate--primary-color";
  const appBorderColorId = "--bilibili-gate--border-color";
  const appTextColorId = "--bilibili-gate--text-color";
  const appBgId = "--bilibili-gate--bg";
  const appPrimaryColorLv1Id = "--bilibili-gate--primary-color--lv1";
  const appPrimaryColorLv2Id = "--bilibili-gate--primary-color--lv2";
  const appPrimaryColorLv3Id = "--bilibili-gate--primary-color--lv3";
  const appBgLv1Id = "--bilibili-gate--bg--lv1";
  const appBgLv2Id = "--bilibili-gate--bg--lv2";
  const appBgLv3Id = "--bilibili-gate--bg--lv3";
  const biliPink = "#ff6699";
  const appCustomFontValue = '"Alibaba PuHuiTi 3.0", "PingFang SC", "HarmonyOS_Regular", "Helvetica Neue", "Microsoft YaHei", sans-serif';
  const appUsingFont = "var(--custom-font-family--options--font-family, var(--bilibili-gate--font))";
  const appClsRoot = "bilibili-gate-root";
  const appClsDark = "bilibili-gate-using-dark";
  const appClsLight = "bilibili-gate-using-light";
  const appClsDarkSelector = "html.bilibili-gate-using-dark";
  const appClsLightSelector = "html.bilibili-gate-using-light";
  const cssVars = {
    appCustomFontId,
    appVideoCardBorderRadiusId,
    appPrimaryColorId,
    appBorderColorId,
    appTextColorId,
    appBgId,
    appPrimaryColorLv1Id,
    appPrimaryColorLv2Id,
    appPrimaryColorLv3Id,
    appBgLv1Id,
    appBgLv2Id,
    appBgLv3Id,
    biliPink,
    appCustomFontValue,
    appUsingFont,
    appClsRoot,
    appClsDark,
    appClsLight,
    appClsDarkSelector,
    appClsLightSelector
  };
  const debug$e = baseDebug.extend("utility:dom");
  const DEFAULT_POLL_TIMEOUT = 10 * 1e3;
  const DEFAULT_POLL_INTERVAL = 200;
  async function poll$1(fn, options) {
    const interval = options?.interval ?? DEFAULT_POLL_INTERVAL;
    let timeout = options?.timeout ?? DEFAULT_POLL_TIMEOUT;
    if (timeout === 0) timeout = Infinity;
    const validate = options?.validate ?? ((val) => !isNil(val));
    const abortSignal = options?.abortSignal;
    const start = performance.now();
    let result = fn();
    const emittery = new Emittery();
    abortSignal?.addEventListener("abort", () => {
      emittery.emit("abort");
    });
    const hasLeftTime = () => performance.now() - start < timeout;
    while (!validate(result) && hasLeftTime() && !abortSignal?.aborted) {
      const p1 = delay$1(interval);
      const p2 = emittery.once("abort");
      await Promise.race([p1, p2]);
      p2.off();
      result = fn();
    }
    return result;
  }
  async function tryAction(selector, action2, moreOptions) {
    const pollTimeout = moreOptions?.pollTimeout ?? DEFAULT_POLL_TIMEOUT;
    const pollInterval = moreOptions?.pollInterval ?? DEFAULT_POLL_INTERVAL;
    const selectorPredicate = moreOptions?.selectorPredicate;
    const warnOnTimeout = moreOptions?.warnOnTimeout ?? false;
    const arr = await poll$1(() => {
      let arr2 = Array.from(document.querySelectorAll(selector));
      if (selectorPredicate) arr2 = arr2.filter(selectorPredicate);
      if (arr2.length) return arr2;
    }, {
      timeout: pollTimeout,
      interval: pollInterval
    });
    if (!arr?.length) {
      debug$e("tryAction: timeout for selector = `%s`", selector);
      if (warnOnTimeout) {
        appWarn("tryAction timeout, selector = `%s`", selector);
      }
      return;
    }
    debug$e("tryAction: selector=`%s` count=%s", selector, arr.length);
    for (const el of arr) {
      await Promise.resolve(action2(el));
    }
  }
  async function tryToRemove(selector, selectorPredicate, delayMs) {
    return tryAction(selector, (el) => el.remove(), {
      selectorPredicate,
      warnOnTimeout: false
    });
  }
  function shouldDisableShortcut() {
    const activeTagName = document.activeElement?.tagName?.toLowerCase() ?? "";
    if (["input", "textarea"].includes(activeTagName)) {
      return true;
    }
    if (document.querySelector(".center-search__bar.is-focus")) {
      return true;
    }
    return false;
  }
  function getElementOffset(el, rect) {
    rect ??= el.getBoundingClientRect();
    const docElem = document.documentElement;
    return {
      top: rect.top + window.scrollY - docElem.clientTop,
      left: rect.left + window.scrollX - docElem.clientLeft
    };
  }
  function whenIdle(options) {
    return new Promise((resolve) => {
      if (typeof requestIdleCallback === "function") {
        requestIdleCallback(() => resolve(), options);
      } else {
        setTimeout(resolve);
      }
    });
  }
  let ORIGINAL_TITLE = "";
  function setPageTitle(title) {
    if (!ORIGINAL_TITLE) {
      ORIGINAL_TITLE = document.title;
    }
    document.title = `${title} - ${ORIGINAL_TITLE}`;
  }
  function classListToSelector(...classNames) {
    return classNames.map((x) => x.trim()).filter(Boolean).map((x) => x.startsWith(".") ? x : `.${x}`).join(",");
  }
  const DarkModeConfig = {
    Evolved: {
      getDetectEl: () => document.body,
      detect: (el) => el.classList.contains("dark"),
      trigger: '.custom-navbar-item[role="listitem"][data-name="darkMode"]',
      triggerInner: '.navbar-dark-mode[item="darkMode"]'
    },
    Bili: {
      getDetectEl: () => document.documentElement,
      detect: (el) => el.classList.contains("bili_dark"),
      isTrigger: (el) => {
        const a2 = el.closest(".avatar-panel-popover a.single-link-item");
        if (!a2) return false;
        return !!Array.from(a2.querySelectorAll(".link-title span")).find((span) => ["深色", "浅色"].includes(span.textContent || ""));
      }
    }
  };
  const detect = (item) => {
    const el = item.getDetectEl();
    if (!el) return false;
    return item.detect(el);
  };
  const $darkMode = valtioFactory(() => {
    return detect(DarkModeConfig.Bili) || detect(DarkModeConfig.Evolved) || document.body.classList.contains("bilibili-helper-dark-mode") || document.documentElement.classList.contains("dark");
  });
  function useIsDarkMode() {
    return $darkMode.use();
  }
  const onDarkModeChange = () => {
    document.documentElement.classList.toggle(appClsDark, $darkMode.get());
    document.documentElement.classList.toggle(appClsLight, !$darkMode.get());
  };
  onDarkModeChange();
  subscribe$3($darkMode.state, onDarkModeChange);
  const ob = new MutationObserver(async () => {
    await delay$1(0);
    $darkMode.updateThrottled();
  });
  ob.observe(document.body, {
    attributes: true,
    attributeFilter: ["class"]
  });
  ob.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ["data-darkreader-scheme"]
  });
  deferBiliDefaultDetect();
  async function deferBiliDefaultDetect() {
    const link = await poll$1(DarkModeConfig.Bili.getDetectEl);
    if (!link) return;
    ob.observe(link, {
      attributes: true
    });
  }
  document.addEventListener("click", darkModeTriggerClickHandler, {
    passive: true
  });
  async function darkModeTriggerClickHandler(e) {
    const t2 = e.target;
    const isClickOnTrigger = DarkModeConfig.Bili.isTrigger(t2) || t2.closest(DarkModeConfig.Evolved.trigger);
    if (!isClickOnTrigger) return;
    await delay$1(0);
    $darkMode.updateThrottled();
  }
  const debug$d = baseDebug.extend("components:css-vars");
  debug$d(":export = %O", cssVars);
  const cssVar = (id2) => {
    if (!id2.startsWith("--")) id2 = `--${id2}`;
    return `var(${id2})`;
  };
  const videoCardBorderRadiusValue = cssVar(cssVars.appVideoCardBorderRadiusId);
  const appPrimaryColorValue = cssVar(cssVars.appPrimaryColorId);
  const appBorderColorValue = cssVar(cssVars.appBorderColorId);
  cssVar(cssVars.appTextColorId);
  const appBgValue = cssVar(cssVars.appBgId);
  const appBgLv1Value = cssVar(cssVars.appBgLv1Id);
  const appBgLv2Value = cssVar(cssVars.appBgLv2Id);
  cssVar(cssVars.appBgLv3Id);
  const buttonOpenCss = {
    name: "rmyi3a",
    styles: "color:var(--ant-button-default-hover-color);border-color:var(--ant-button-default-hover-border-color);background:var(--ant-button-default-hover-bg)"
  };
  function useButtonOpenColor() {
    return theme.useToken().token.colorPrimaryHover;
  }
  function usePopoverBorderColor() {
    const {
      popoverBorderColorUseColorPrimary
    } = useSnapshot(settings.style.general);
    const buttonOpenColor = useButtonOpenColor();
    return popoverBorderColorUseColorPrimary ? buttonOpenColor : appBorderColorValue;
  }
  function usePopoverBorderStyle() {
    const color2 = usePopoverBorderColor();
    return reactExports.useMemo(() => ({
      border: `1px solid ${color2}`
    }), [color2]);
  }
  function useAntLinkCss() {
    const {
      colorLink,
      colorLinkActive,
      colorLinkHover
    } = theme.useToken().token;
    return reactExports.useMemo(() => css("color:", colorLink, ";&:visited{color:", colorLink, ";}&:hover{color:", colorLinkHover, ";}&:active{color:", colorLinkActive, ";}", ""), [colorLink, colorLinkActive, colorLinkHover]);
  }
  const APP_CLS_USE_ANT_LINK_COLOR = `${APP_NAMESPACE}--use-ant-link-color`;
  function useAntLinkColorGlobalStyle() {
    const s2 = useAntLinkCss();
    return css(":root .", APP_CLS_USE_ANT_LINK_COLOR, "{", s2, ";}", "");
  }
  var createUpdateEffect = function(hook) {
    return function(effect2, deps) {
      var isMounted = reactExports.useRef(false);
      hook(function() {
        return function() {
          isMounted.current = false;
        };
      }, []);
      hook(function() {
        if (!isMounted.current) {
          isMounted.current = true;
        } else {
          return effect2();
        }
      }, deps);
    };
  };
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  function __extends(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var __assign = function() {
    __assign = Object.assign || function __assign2(t2) {
      for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  function __rest(s2, e) {
    var t2 = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  }
  function __decorate(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
    else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  }
  function __param(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f2) {
      if (f2 !== void 0 && typeof f2 !== "function") throw new TypeError("Function expected");
      return f2;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _2, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
      for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
      context.addInitializer = function(f2) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f2 || null));
      };
      var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_2 = accept(result.get)) descriptor.get = _2;
        if (_2 = accept(result.set)) descriptor.set = _2;
        if (_2 = accept(result.init)) initializers.unshift(_2);
      } else if (_2 = accept(result)) {
        if (kind === "field") initializers.unshift(_2);
        else descriptor[key] = _2;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  }
  function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  }
  function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
  }
  function __setFunctionName(f2, name, prefix2) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f2, "name", { configurable: true, value: prefix2 ? "".concat(prefix2, " ", name) : name });
  }
  function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1) throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f2, y, t2, g2 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g2.next = verb(0), g2["throw"] = verb(1), g2["return"] = verb(2), typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
      return this;
    }), g2;
    function verb(n2) {
      return function(v) {
        return step([n2, v]);
      };
    }
    function step(op) {
      if (f2) throw new TypeError("Generator is already executing.");
      while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
        if (f2 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
        if (y = 0, t2) op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2]) _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f2 = t2 = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  var __createBinding = Object.create ? (function(o2, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o2, k2, desc);
  }) : (function(o2, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    o2[k2] = m2[k];
  });
  function __exportStar(m2, o2) {
    for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2)) __createBinding(o2, m2, p2);
  }
  function __values(o2) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
    if (m2) return m2.call(o2);
    if (o2 && typeof o2.length === "number") return {
      next: function() {
        if (o2 && i2 >= o2.length) o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o2, n2) {
    var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
    if (!m2) return o2;
    var i2 = m2.call(o2), r2, ar = [], e;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  }
  function __spread() {
    for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
      ar = ar.concat(__read(arguments[i2]));
    return ar;
  }
  function __spreadArrays() {
    for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s2 += arguments[i2].length;
    for (var r2 = Array(s2), k = 0, i2 = 0; i2 < il; i2++)
      for (var a2 = arguments[i2], j = 0, jl = a2.length; j < jl; j++, k++)
        r2[k] = a2[j];
    return r2;
  }
  function __spreadArray(to, from2, pack) {
    if (pack || arguments.length === 2) for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar) ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from2));
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];
    return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function awaitReturn(f2) {
      return function(v) {
        return Promise.resolve(v).then(f2, reject);
      };
    }
    function verb(n2, f2) {
      if (g2[n2]) {
        i2[n2] = function(v) {
          return new Promise(function(a2, b) {
            q.push([n2, v, a2, b]) > 1 || resume(n2, v);
          });
        };
        if (f2) i2[n2] = f2(i2[n2]);
      }
    }
    function resume(n2, v) {
      try {
        step(g2[n2](v));
      } catch (e) {
        settle2(q[0][3], e);
      }
    }
    function step(r2) {
      r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle2(q[0][2], r2);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle2(f2, v) {
      if (f2(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator(o2) {
    var i2, p2;
    return i2 = {}, verb("next"), verb("throw", function(e) {
      throw e;
    }), verb("return"), i2[Symbol.iterator] = function() {
      return this;
    }, i2;
    function verb(n2, f2) {
      i2[n2] = o2[n2] ? function(v) {
        return (p2 = !p2) ? { value: __await(o2[n2](v)), done: false } : f2 ? f2(v) : v;
      } : f2;
    }
  }
  function __asyncValues(o2) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o2[Symbol.asyncIterator], i2;
    return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n2) {
      i2[n2] = o2[n2] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o2[n2](v), settle2(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle2(resolve, reject, d2, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d2 });
      }, reject);
    }
  }
  function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", { value: raw });
    } else {
      cooked.raw = raw;
    }
    return cooked;
  }
  var __setModuleDefault = Object.create ? (function(o2, v) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v });
  }) : function(o2, v) {
    o2["default"] = v;
  };
  var ownKeys = function(o2) {
    ownKeys = Object.getOwnPropertyNames || function(o3) {
      var ar = [];
      for (var k in o3) if (Object.prototype.hasOwnProperty.call(o3, k)) ar[ar.length] = k;
      return ar;
    };
    return ownKeys(o2);
  };
  function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k = ownKeys(mod), i2 = 0; i2 < k.length; i2++) if (k[i2] !== "default") __createBinding(result, mod, k[i2]);
    }
    __setModuleDefault(result, mod);
    return result;
  }
  function __importDefault(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  }
  function __classPrivateFieldGet(receiver, state2, kind, f2) {
    if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state2 === "function" ? receiver !== state2 || !f2 : !state2.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state2.get(receiver);
  }
  function __classPrivateFieldSet(receiver, state2, value, kind, f2) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state2 === "function" ? receiver !== state2 || !f2 : !state2.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state2.set(receiver, value), value;
  }
  function __classPrivateFieldIn(state2, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state2 === "function" ? receiver === state2 : state2.has(receiver);
  }
  function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async });
    } else if (async) {
      env.stack.push({ async: true });
    }
    return value;
  }
  var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message2) {
    var e = new Error(message2);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  function __disposeResources(env) {
    function fail(e) {
      env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    var r2, s2 = 0;
    function next2() {
      while (r2 = env.stack.pop()) {
        try {
          if (!r2.async && s2 === 1) return s2 = 0, env.stack.push(r2), Promise.resolve().then(next2);
          if (r2.dispose) {
            var result = r2.dispose.call(r2.value);
            if (r2.async) return s2 |= 2, Promise.resolve(result).then(next2, function(e) {
              fail(e);
              return next2();
            });
          } else s2 |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s2 === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
      if (env.hasError) throw env.error;
    }
    return next2();
  }
  function __rewriteRelativeImportExtension(path, preserveJsx) {
    if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m2, tsx, d2, ext, cm) {
        return tsx ? preserveJsx ? ".jsx" : ".js" : d2 && (!ext || !cm) ? m2 : d2 + ext + "." + cm.toLowerCase() + "js";
      });
    }
    return path;
  }
  const tslib_es6 = {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __esDecorate,
    __runInitializers,
    __propKey,
    __setFunctionName,
    __metadata,
    __awaiter,
    __generator,
    __createBinding,
    __exportStar,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn,
    __addDisposableResource,
    __disposeResources,
    __rewriteRelativeImportExtension
  };
  const tslib_es6$1 = Object.freeze( Object.defineProperty({
    __proto__: null,
    __addDisposableResource,
    get __assign() {
      return __assign;
    },
    __asyncDelegator,
    __asyncGenerator,
    __asyncValues,
    __await,
    __awaiter,
    __classPrivateFieldGet,
    __classPrivateFieldIn,
    __classPrivateFieldSet,
    __createBinding,
    __decorate,
    __disposeResources,
    __esDecorate,
    __exportStar,
    __extends,
    __generator,
    __importDefault,
    __importStar,
    __makeTemplateObject,
    __metadata,
    __param,
    __propKey,
    __read,
    __rest,
    __rewriteRelativeImportExtension,
    __runInitializers,
    __setFunctionName,
    __spread,
    __spreadArray,
    __spreadArrays,
    __values,
    default: tslib_es6
  }, Symbol.toStringTag, { value: "Module" }));
  var isFunction = function(value) {
    return typeof value === "function";
  };
  var isString = function(value) {
    return typeof value === "string";
  };
  var isNumber = function(value) {
    return typeof value === "number";
  };
  var useMemoizedFn = function(fn) {
    var fnRef = reactExports.useRef(fn);
    fnRef.current = reactExports.useMemo(function() {
      return fn;
    }, [fn]);
    var memoizedFn = reactExports.useRef(void 0);
    if (!memoizedFn.current) {
      memoizedFn.current = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return fnRef.current.apply(this, args);
      };
    }
    return memoizedFn.current;
  };
  const useUpdateEffect = createUpdateEffect(reactExports.useEffect);
  var useAutoRunPlugin = function(fetchInstance, _a) {
    var manual = _a.manual, _b = _a.ready, ready = _b === void 0 ? true : _b, _c = _a.defaultParams, defaultParams = _c === void 0 ? [] : _c, _d = _a.refreshDeps, refreshDeps = _d === void 0 ? [] : _d, refreshDepsAction = _a.refreshDepsAction;
    var hasAutoRun = reactExports.useRef(false);
    hasAutoRun.current = false;
    useUpdateEffect(function() {
      if (!manual && ready) {
        hasAutoRun.current = true;
        fetchInstance.run.apply(fetchInstance, __spreadArray([], __read(defaultParams), false));
      }
    }, [ready]);
    useUpdateEffect(function() {
      if (hasAutoRun.current) {
        return;
      }
      if (!manual) {
        hasAutoRun.current = true;
        if (refreshDepsAction) {
          refreshDepsAction();
        } else {
          fetchInstance.refresh();
        }
      }
    }, __spreadArray([], __read(refreshDeps), false));
    return {
      onBefore: function() {
        if (!ready) {
          return {
            stopNow: true
          };
        }
      }
    };
  };
  useAutoRunPlugin.onInit = function(_a) {
    var _b = _a.ready, ready = _b === void 0 ? true : _b, manual = _a.manual;
    return {
      loading: !manual && ready
    };
  };
  function depsAreSame$1(oldDeps, deps) {
    if (oldDeps === deps) {
      return true;
    }
    for (var i2 = 0; i2 < oldDeps.length; i2++) {
      if (!Object.is(oldDeps[i2], deps[i2])) {
        return false;
      }
    }
    return true;
  }
  var useCreation = function(factory, deps) {
    var current = reactExports.useRef({
      deps,
      obj: void 0,
      initialized: false
    }).current;
    if (current.initialized === false || !depsAreSame$1(current.deps, deps)) {
      current.deps = deps;
      current.obj = factory();
      current.initialized = true;
    }
    return current.obj;
  };
  function useLatest$1(value) {
    var ref2 = reactExports.useRef(value);
    ref2.current = value;
    return ref2;
  }
  var useUnmount$1 = function(fn) {
    var fnRef = useLatest$1(fn);
    reactExports.useEffect(function() {
      return function() {
        fnRef.current();
      };
    }, []);
  };
  var cache$3 = new Map();
  var setCache = function(key, cacheTime, cachedData) {
    var currentCache = cache$3.get(key);
    if (currentCache === null || currentCache === void 0 ? void 0 : currentCache.timer) {
      clearTimeout(currentCache.timer);
    }
    var timer = void 0;
    if (cacheTime > -1) {
      timer = setTimeout(function() {
        cache$3.delete(key);
      }, cacheTime);
    }
    cache$3.set(key, __assign(__assign({}, cachedData), { timer }));
  };
  var getCache = function(key) {
    return cache$3.get(key);
  };
  var cachePromise = new Map();
  var getCachePromise = function(cacheKey2) {
    return cachePromise.get(cacheKey2);
  };
  var setCachePromise = function(cacheKey2, promise) {
    cachePromise.set(cacheKey2, promise);
    promise.then(function(res) {
      cachePromise.delete(cacheKey2);
      return res;
    }).catch(function() {
      cachePromise.delete(cacheKey2);
    });
  };
  var listeners$2 = {};
  var trigger = function(key, data2) {
    if (listeners$2[key]) {
      listeners$2[key].forEach(function(item) {
        return item(data2);
      });
    }
  };
  var subscribe$2 = function(key, listener) {
    if (!listeners$2[key]) {
      listeners$2[key] = [];
    }
    listeners$2[key].push(listener);
    return function unsubscribe() {
      var index = listeners$2[key].indexOf(listener);
      listeners$2[key].splice(index, 1);
    };
  };
  var useCachePlugin = function(fetchInstance, _a) {
    var cacheKey2 = _a.cacheKey, _b = _a.cacheTime, cacheTime = _b === void 0 ? 5 * 60 * 1e3 : _b, _c = _a.staleTime, staleTime = _c === void 0 ? 0 : _c, customSetCache = _a.setCache, customGetCache = _a.getCache;
    var unSubscribeRef = reactExports.useRef(void 0);
    var currentPromiseRef = reactExports.useRef(void 0);
    var _setCache = function(key, cachedData) {
      if (customSetCache) {
        customSetCache(cachedData);
      } else {
        setCache(key, cacheTime, cachedData);
      }
      trigger(key, cachedData.data);
    };
    var _getCache = function(key, params) {
      if (params === void 0) {
        params = [];
      }
      if (customGetCache) {
        return customGetCache(params);
      }
      return getCache(key);
    };
    useCreation(function() {
      if (!cacheKey2) {
        return;
      }
      var cacheData = _getCache(cacheKey2);
      if (cacheData && Object.hasOwnProperty.call(cacheData, "data")) {
        fetchInstance.state.data = cacheData.data;
        fetchInstance.state.params = cacheData.params;
        if (staleTime === -1 || Date.now() - cacheData.time <= staleTime) {
          fetchInstance.state.loading = false;
        }
      }
      unSubscribeRef.current = subscribe$2(cacheKey2, function(data2) {
        fetchInstance.setState({ data: data2 });
      });
    }, []);
    useUnmount$1(function() {
      var _a2;
      (_a2 = unSubscribeRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unSubscribeRef);
    });
    if (!cacheKey2) {
      return {};
    }
    return {
      onBefore: function(params) {
        var cacheData = _getCache(cacheKey2, params);
        if (!cacheData || !Object.hasOwnProperty.call(cacheData, "data")) {
          return {};
        }
        if (staleTime === -1 || Date.now() - cacheData.time <= staleTime) {
          return {
            loading: false,
            data: cacheData === null || cacheData === void 0 ? void 0 : cacheData.data,
            error: void 0,
            returnNow: true
          };
        } else {
          return {
            data: cacheData === null || cacheData === void 0 ? void 0 : cacheData.data,
            error: void 0
          };
        }
      },
      onRequest: function(service, args) {
        var servicePromise = getCachePromise(cacheKey2);
        if (servicePromise && servicePromise !== currentPromiseRef.current) {
          return { servicePromise };
        }
        servicePromise = service.apply(void 0, __spreadArray([], __read(args), false));
        currentPromiseRef.current = servicePromise;
        setCachePromise(cacheKey2, servicePromise);
        return { servicePromise };
      },
      onSuccess: function(data2, params) {
        var _a2;
        if (cacheKey2) {
          (_a2 = unSubscribeRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unSubscribeRef);
          _setCache(cacheKey2, {
            data: data2,
            params,
            time: Date.now()
          });
          unSubscribeRef.current = subscribe$2(cacheKey2, function(d2) {
            fetchInstance.setState({ data: d2 });
          });
        }
      },
      onMutate: function(data2) {
        var _a2;
        if (cacheKey2) {
          (_a2 = unSubscribeRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unSubscribeRef);
          _setCache(cacheKey2, {
            data: data2,
            params: fetchInstance.state.params,
            time: Date.now()
          });
          unSubscribeRef.current = subscribe$2(cacheKey2, function(d2) {
            fetchInstance.setState({ data: d2 });
          });
        }
      }
    };
  };
  var isObject_1;
  var hasRequiredIsObject;
  function requireIsObject() {
    if (hasRequiredIsObject) return isObject_1;
    hasRequiredIsObject = 1;
    function isObject2(value) {
      var type4 = typeof value;
      return value != null && (type4 == "object" || type4 == "function");
    }
    isObject_1 = isObject2;
    return isObject_1;
  }
  var _freeGlobal;
  var hasRequired_freeGlobal;
  function require_freeGlobal() {
    if (hasRequired_freeGlobal) return _freeGlobal;
    hasRequired_freeGlobal = 1;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    _freeGlobal = freeGlobal;
    return _freeGlobal;
  }
  var _root;
  var hasRequired_root;
  function require_root() {
    if (hasRequired_root) return _root;
    hasRequired_root = 1;
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    _root = root2;
    return _root;
  }
  var now_1;
  var hasRequiredNow;
  function requireNow() {
    if (hasRequiredNow) return now_1;
    hasRequiredNow = 1;
    var root2 = require_root();
    var now2 = function() {
      return root2.Date.now();
    };
    now_1 = now2;
    return now_1;
  }
  var _trimmedEndIndex;
  var hasRequired_trimmedEndIndex;
  function require_trimmedEndIndex() {
    if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;
    hasRequired_trimmedEndIndex = 1;
    var reWhitespace = /\s/;
    function trimmedEndIndex(string3) {
      var index = string3.length;
      while (index-- && reWhitespace.test(string3.charAt(index))) {
      }
      return index;
    }
    _trimmedEndIndex = trimmedEndIndex;
    return _trimmedEndIndex;
  }
  var _baseTrim;
  var hasRequired_baseTrim;
  function require_baseTrim() {
    if (hasRequired_baseTrim) return _baseTrim;
    hasRequired_baseTrim = 1;
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string3) {
      return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
    }
    _baseTrim = baseTrim;
    return _baseTrim;
  }
  var _Symbol;
  var hasRequired_Symbol;
  function require_Symbol() {
    if (hasRequired_Symbol) return _Symbol;
    hasRequired_Symbol = 1;
    var root2 = require_root();
    var Symbol2 = root2.Symbol;
    _Symbol = Symbol2;
    return _Symbol;
  }
  var _getRawTag;
  var hasRequired_getRawTag;
  function require_getRawTag() {
    if (hasRequired_getRawTag) return _getRawTag;
    hasRequired_getRawTag = 1;
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    _getRawTag = getRawTag;
    return _getRawTag;
  }
  var _objectToString;
  var hasRequired_objectToString;
  function require_objectToString() {
    if (hasRequired_objectToString) return _objectToString;
    hasRequired_objectToString = 1;
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString2(value) {
      return nativeObjectToString.call(value);
    }
    _objectToString = objectToString2;
    return _objectToString;
  }
  var _baseGetTag;
  var hasRequired_baseGetTag;
  function require_baseGetTag() {
    if (hasRequired_baseGetTag) return _baseGetTag;
    hasRequired_baseGetTag = 1;
    var Symbol2 = require_Symbol(), getRawTag = require_getRawTag(), objectToString2 = require_objectToString();
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
    }
    _baseGetTag = baseGetTag;
    return _baseGetTag;
  }
  var isObjectLike_1;
  var hasRequiredIsObjectLike;
  function requireIsObjectLike() {
    if (hasRequiredIsObjectLike) return isObjectLike_1;
    hasRequiredIsObjectLike = 1;
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    isObjectLike_1 = isObjectLike;
    return isObjectLike_1;
  }
  var isSymbol_1;
  var hasRequiredIsSymbol;
  function requireIsSymbol() {
    if (hasRequiredIsSymbol) return isSymbol_1;
    hasRequiredIsSymbol = 1;
    var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
    var symbolTag2 = "[object Symbol]";
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag2;
    }
    isSymbol_1 = isSymbol2;
    return isSymbol_1;
  }
  var toNumber_1;
  var hasRequiredToNumber;
  function requireToNumber() {
    if (hasRequiredToNumber) return toNumber_1;
    hasRequiredToNumber = 1;
    var baseTrim = require_baseTrim(), isObject2 = requireIsObject(), isSymbol2 = requireIsSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber2(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    toNumber_1 = toNumber2;
    return toNumber_1;
  }
  var debounce_1;
  var hasRequiredDebounce;
  function requireDebounce() {
    if (hasRequiredDebounce) return debounce_1;
    hasRequiredDebounce = 1;
    var isObject2 = requireIsObject(), now2 = requireNow(), toNumber2 = requireToNumber();
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max, nativeMin = Math.min;
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber2(wait) || 0;
      if (isObject2(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time2) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time2;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time2) {
        lastInvokeTime = time2;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time2) : result;
      }
      function remainingWait(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time2 = now2();
        if (shouldInvoke(time2)) {
          return trailingEdge(time2);
        }
        timerId = setTimeout(timerExpired, remainingWait(time2));
      }
      function trailingEdge(time2) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time2);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now2());
      }
      function debounced() {
        var time2 = now2(), isInvoking = shouldInvoke(time2);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time2;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    debounce_1 = debounce2;
    return debounce_1;
  }
  var debounceExports = requireDebounce();
  const debounce = getDefaultExportFromCjs(debounceExports);
  var useDebouncePlugin = function(fetchInstance, _a) {
    var debounceWait = _a.debounceWait, debounceLeading = _a.debounceLeading, debounceTrailing = _a.debounceTrailing, debounceMaxWait = _a.debounceMaxWait;
    var debouncedRef = reactExports.useRef(void 0);
    var options = reactExports.useMemo(function() {
      var ret = {};
      if (debounceLeading !== void 0) {
        ret.leading = debounceLeading;
      }
      if (debounceTrailing !== void 0) {
        ret.trailing = debounceTrailing;
      }
      if (debounceMaxWait !== void 0) {
        ret.maxWait = debounceMaxWait;
      }
      return ret;
    }, [debounceLeading, debounceTrailing, debounceMaxWait]);
    reactExports.useEffect(function() {
      if (debounceWait) {
        var _originRunAsync_1 = fetchInstance.runAsync.bind(fetchInstance);
        debouncedRef.current = debounce(function(callback) {
          callback();
        }, debounceWait, options);
        fetchInstance.runAsync = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return new Promise(function(resolve, reject) {
            var _a2;
            (_a2 = debouncedRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(debouncedRef, function() {
              _originRunAsync_1.apply(void 0, __spreadArray([], __read(args), false)).then(resolve).catch(reject);
            });
          });
        };
        return function() {
          var _a2;
          (_a2 = debouncedRef.current) === null || _a2 === void 0 ? void 0 : _a2.cancel();
          fetchInstance.runAsync = _originRunAsync_1;
        };
      }
    }, [debounceWait, options]);
    if (!debounceWait) {
      return {};
    }
    return {
      onCancel: function() {
        var _a2;
        (_a2 = debouncedRef.current) === null || _a2 === void 0 ? void 0 : _a2.cancel();
      }
    };
  };
  var useLoadingDelayPlugin = function(fetchInstance, _a) {
    var loadingDelay = _a.loadingDelay, ready = _a.ready;
    var timerRef = reactExports.useRef(void 0);
    if (!loadingDelay) {
      return {};
    }
    var cancelTimeout = function() {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
    return {
      onBefore: function() {
        cancelTimeout();
        if (ready !== false) {
          timerRef.current = setTimeout(function() {
            fetchInstance.setState({
              loading: true
            });
          }, loadingDelay);
        }
        return {
          loading: false
        };
      },
      onFinally: function() {
        cancelTimeout();
      },
      onCancel: function() {
        cancelTimeout();
      }
    };
  };
  var isBrowser$1 = !!(typeof window !== "undefined" && window.document && window.document.createElement);
  function isDocumentVisible() {
    if (isBrowser$1) {
      return document.visibilityState !== "hidden";
    }
    return true;
  }
  var listeners$1 = new Set();
  function subscribe$1(listener) {
    listeners$1.add(listener);
    return function unsubscribe() {
      listeners$1.has(listener) && listeners$1.delete(listener);
    };
  }
  if (isBrowser$1) {
    var revalidate$1 = function() {
      if (!isDocumentVisible())
        return;
      listeners$1.forEach(function(listener) {
        return listener();
      });
    };
    window.addEventListener("visibilitychange", revalidate$1, false);
  }
  var usePollingPlugin = function(fetchInstance, _a) {
    var pollingInterval = _a.pollingInterval, _b = _a.pollingWhenHidden, pollingWhenHidden = _b === void 0 ? true : _b, _c = _a.pollingErrorRetryCount, pollingErrorRetryCount = _c === void 0 ? -1 : _c;
    var timerRef = reactExports.useRef(void 0);
    var unsubscribeRef = reactExports.useRef(void 0);
    var countRef = reactExports.useRef(0);
    var stopPolling = function() {
      var _a2;
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
      (_a2 = unsubscribeRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unsubscribeRef);
    };
    useUpdateEffect(function() {
      if (!pollingInterval) {
        stopPolling();
      }
    }, [pollingInterval]);
    if (!pollingInterval) {
      return {};
    }
    return {
      onBefore: function() {
        stopPolling();
      },
      onError: function() {
        countRef.current += 1;
      },
      onSuccess: function() {
        countRef.current = 0;
      },
      onFinally: function() {
        if (pollingErrorRetryCount === -1 ||
pollingErrorRetryCount !== -1 && countRef.current <= pollingErrorRetryCount) {
          timerRef.current = setTimeout(function() {
            if (!pollingWhenHidden && !isDocumentVisible()) {
              unsubscribeRef.current = subscribe$1(function() {
                fetchInstance.refresh();
              });
            } else {
              fetchInstance.refresh();
            }
          }, pollingInterval);
        } else {
          countRef.current = 0;
        }
      },
      onCancel: function() {
        stopPolling();
      }
    };
  };
  function limit(fn, timespan) {
    var pending = false;
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (pending)
        return;
      pending = true;
      fn.apply(void 0, __spreadArray([], __read(args), false));
      setTimeout(function() {
        pending = false;
      }, timespan);
    };
  }
  var isOnline = function() {
    if (isBrowser$1 && typeof navigator.onLine !== "undefined") {
      return navigator.onLine;
    }
    return true;
  };
  var listeners = new Set();
  function subscribe(listener) {
    listeners.add(listener);
    return function unsubscribe() {
      listeners.has(listener) && listeners.delete(listener);
    };
  }
  if (isBrowser$1) {
    var revalidate = function() {
      if (!isDocumentVisible() || !isOnline())
        return;
      listeners.forEach(function(listener) {
        return listener();
      });
    };
    window.addEventListener("visibilitychange", revalidate, false);
    window.addEventListener("focus", revalidate, false);
  }
  var useRefreshOnWindowFocusPlugin = function(fetchInstance, _a) {
    var refreshOnWindowFocus = _a.refreshOnWindowFocus, _b = _a.focusTimespan, focusTimespan = _b === void 0 ? 5e3 : _b;
    var unsubscribeRef = reactExports.useRef(void 0);
    var stopSubscribe = function() {
      var _a2;
      (_a2 = unsubscribeRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unsubscribeRef);
    };
    reactExports.useEffect(function() {
      if (refreshOnWindowFocus) {
        var limitRefresh_1 = limit(fetchInstance.refresh.bind(fetchInstance), focusTimespan);
        unsubscribeRef.current = subscribe(function() {
          limitRefresh_1();
        });
      }
      return function() {
        stopSubscribe();
      };
    }, [refreshOnWindowFocus, focusTimespan]);
    useUnmount$1(function() {
      stopSubscribe();
    });
    return {};
  };
  var useRetryPlugin = function(fetchInstance, _a) {
    var retryInterval = _a.retryInterval, retryCount = _a.retryCount;
    var timerRef = reactExports.useRef(void 0);
    var countRef = reactExports.useRef(0);
    var triggerByRetry = reactExports.useRef(false);
    if (!retryCount) {
      return {};
    }
    return {
      onBefore: function() {
        if (!triggerByRetry.current) {
          countRef.current = 0;
        }
        triggerByRetry.current = false;
        if (timerRef.current) {
          clearTimeout(timerRef.current);
        }
      },
      onSuccess: function() {
        countRef.current = 0;
      },
      onError: function() {
        countRef.current += 1;
        if (retryCount === -1 || countRef.current <= retryCount) {
          var timeout = retryInterval !== null && retryInterval !== void 0 ? retryInterval : Math.min(1e3 * Math.pow(2, countRef.current), 3e4);
          timerRef.current = setTimeout(function() {
            triggerByRetry.current = true;
            fetchInstance.refresh();
          }, timeout);
        } else {
          countRef.current = 0;
        }
      },
      onCancel: function() {
        countRef.current = 0;
        if (timerRef.current) {
          clearTimeout(timerRef.current);
        }
      }
    };
  };
  var throttle_1;
  var hasRequiredThrottle;
  function requireThrottle() {
    if (hasRequiredThrottle) return throttle_1;
    hasRequiredThrottle = 1;
    var debounce2 = requireDebounce(), isObject2 = requireIsObject();
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle2(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject2(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce2(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    throttle_1 = throttle2;
    return throttle_1;
  }
  var throttleExports = requireThrottle();
  const throttle = getDefaultExportFromCjs(throttleExports);
  var useThrottlePlugin = function(fetchInstance, _a) {
    var throttleWait = _a.throttleWait, throttleLeading = _a.throttleLeading, throttleTrailing = _a.throttleTrailing;
    var throttledRef = reactExports.useRef(void 0);
    var options = {};
    if (throttleLeading !== void 0) {
      options.leading = throttleLeading;
    }
    if (throttleTrailing !== void 0) {
      options.trailing = throttleTrailing;
    }
    reactExports.useEffect(function() {
      if (throttleWait) {
        var _originRunAsync_1 = fetchInstance.runAsync.bind(fetchInstance);
        throttledRef.current = throttle(function(callback) {
          callback();
        }, throttleWait, options);
        fetchInstance.runAsync = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return new Promise(function(resolve, reject) {
            var _a2;
            (_a2 = throttledRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(throttledRef, function() {
              _originRunAsync_1.apply(void 0, __spreadArray([], __read(args), false)).then(resolve).catch(reject);
            });
          });
        };
        return function() {
          var _a2;
          fetchInstance.runAsync = _originRunAsync_1;
          (_a2 = throttledRef.current) === null || _a2 === void 0 ? void 0 : _a2.cancel();
        };
      }
    }, [throttleWait, throttleLeading, throttleTrailing]);
    if (!throttleWait) {
      return {};
    }
    return {
      onCancel: function() {
        var _a2;
        (_a2 = throttledRef.current) === null || _a2 === void 0 ? void 0 : _a2.cancel();
      }
    };
  };
  var useMount = function(fn) {
    reactExports.useEffect(function() {
      var result = fn === null || fn === void 0 ? void 0 : fn();
      if (result && typeof result === "object" && typeof result.then === "function") {
        return;
      }
      return result;
    }, []);
  };
  var useUpdate = function() {
    var _a = __read(reactExports.useState({}), 2), setState = _a[1];
    return reactExports.useCallback(function() {
      return setState({});
    }, []);
  };
  var Fetch = (
(function() {
      function Fetch2(serviceRef, options, subscribe2, initState) {
        if (initState === void 0) {
          initState = {};
        }
        this.serviceRef = serviceRef;
        this.options = options;
        this.subscribe = subscribe2;
        this.initState = initState;
        this.pluginImpls = [];
        this.count = 0;
        this.state = {
          loading: false,
          params: void 0,
          data: void 0,
          error: void 0
        };
        this.state = __assign(__assign(__assign({}, this.state), { loading: !options.manual }), initState);
      }
      Fetch2.prototype.setState = function(s2) {
        if (s2 === void 0) {
          s2 = {};
        }
        this.state = __assign(__assign({}, this.state), s2);
        this.subscribe();
      };
      Fetch2.prototype.runPluginHandler = function(event) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          rest[_i - 1] = arguments[_i];
        }
        var r2 = this.pluginImpls.map(function(i2) {
          var _a;
          return (_a = i2[event]) === null || _a === void 0 ? void 0 : _a.call.apply(_a, __spreadArray([i2], __read(rest), false));
        }).filter(Boolean);
        return Object.assign.apply(Object, __spreadArray([{}], __read(r2), false));
      };
      Fetch2.prototype.runAsync = function() {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          params[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function() {
          var currentCount, _a, _b, stopNow, _c, returnNow, state2, servicePromise, res, error_1;
          var _d;
          var _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
          return __generator(this, function(_q) {
            switch (_q.label) {
              case 0:
                this.count += 1;
                currentCount = this.count;
                _a = this.runPluginHandler("onBefore", params), _b = _a.stopNow, stopNow = _b === void 0 ? false : _b, _c = _a.returnNow, returnNow = _c === void 0 ? false : _c, state2 = __rest(_a, ["stopNow", "returnNow"]);
                if (stopNow) {
                  return [2, new Promise(function() {
                  })];
                }
                this.setState(__assign({ loading: true, params }, state2));
                if (returnNow) {
                  return [2, Promise.resolve(state2.data)];
                }
                (_f = (_e = this.options).onBefore) === null || _f === void 0 ? void 0 : _f.call(_e, params);
                _q.label = 1;
              case 1:
                _q.trys.push([1, 3, , 4]);
                servicePromise = this.runPluginHandler("onRequest", this.serviceRef.current, params).servicePromise;
                if (!servicePromise) {
                  servicePromise = (_d = this.serviceRef).current.apply(_d, __spreadArray([], __read(params), false));
                }
                return [4, servicePromise];
              case 2:
                res = _q.sent();
                if (currentCount !== this.count) {
                  return [2, new Promise(function() {
                  })];
                }
                this.setState({
                  data: res,
                  error: void 0,
                  loading: false
                });
                (_h = (_g = this.options).onSuccess) === null || _h === void 0 ? void 0 : _h.call(_g, res, params);
                this.runPluginHandler("onSuccess", res, params);
                (_k = (_j = this.options).onFinally) === null || _k === void 0 ? void 0 : _k.call(_j, params, res, void 0);
                if (currentCount === this.count) {
                  this.runPluginHandler("onFinally", params, res, void 0);
                }
                return [2, res];
              case 3:
                error_1 = _q.sent();
                if (currentCount !== this.count) {
                  return [2, new Promise(function() {
                  })];
                }
                this.setState({
                  error: error_1,
                  loading: false
                });
                (_m = (_l = this.options).onError) === null || _m === void 0 ? void 0 : _m.call(_l, error_1, params);
                this.runPluginHandler("onError", error_1, params);
                (_p = (_o = this.options).onFinally) === null || _p === void 0 ? void 0 : _p.call(_o, params, void 0, error_1);
                if (currentCount === this.count) {
                  this.runPluginHandler("onFinally", params, void 0, error_1);
                }
                throw error_1;
              case 4:
                return [
                  2
];
            }
          });
        });
      };
      Fetch2.prototype.run = function() {
        var _this = this;
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          params[_i] = arguments[_i];
        }
        this.runAsync.apply(this, __spreadArray([], __read(params), false)).catch(function(error) {
          if (!_this.options.onError) {
            console.error(error);
          }
        });
      };
      Fetch2.prototype.cancel = function() {
        this.count += 1;
        this.setState({
          loading: false
        });
        this.runPluginHandler("onCancel");
      };
      Fetch2.prototype.refresh = function() {
        this.run.apply(this, __spreadArray([], __read(this.state.params || []), false));
      };
      Fetch2.prototype.refreshAsync = function() {
        return this.runAsync.apply(this, __spreadArray([], __read(this.state.params || []), false));
      };
      Fetch2.prototype.mutate = function(data2) {
        var targetData = isFunction(data2) ? data2(this.state.data) : data2;
        this.runPluginHandler("onMutate", targetData);
        this.setState({
          data: targetData
        });
      };
      return Fetch2;
    })()
  );
  function useRequestImplement(service, options, plugins) {
    if (options === void 0) {
      options = {};
    }
    if (plugins === void 0) {
      plugins = [];
    }
    var _a = options.manual, manual = _a === void 0 ? false : _a, _b = options.ready, ready = _b === void 0 ? true : _b, rest = __rest(options, ["manual", "ready"]);
    var fetchOptions = __assign({ manual, ready }, rest);
    var serviceRef = useLatest$1(service);
    var update = useUpdate();
    var fetchInstance = useCreation(function() {
      var initState = plugins.map(function(p2) {
        var _a2;
        return (_a2 = p2 === null || p2 === void 0 ? void 0 : p2.onInit) === null || _a2 === void 0 ? void 0 : _a2.call(p2, fetchOptions);
      }).filter(Boolean);
      return new Fetch(serviceRef, fetchOptions, update, Object.assign.apply(Object, __spreadArray([{}], __read(initState), false)));
    }, []);
    fetchInstance.options = fetchOptions;
    fetchInstance.pluginImpls = plugins.map(function(p2) {
      return p2(fetchInstance, fetchOptions);
    });
    useMount(function() {
      if (!manual && ready) {
        var params = fetchInstance.state.params || options.defaultParams || [];
        fetchInstance.run.apply(fetchInstance, __spreadArray([], __read(params), false));
      }
    });
    useUnmount$1(function() {
      fetchInstance.cancel();
    });
    return {
      loading: fetchInstance.state.loading,
      data: fetchInstance.state.data,
      error: fetchInstance.state.error,
      params: fetchInstance.state.params || [],
      cancel: useMemoizedFn(fetchInstance.cancel.bind(fetchInstance)),
      refresh: useMemoizedFn(fetchInstance.refresh.bind(fetchInstance)),
      refreshAsync: useMemoizedFn(fetchInstance.refreshAsync.bind(fetchInstance)),
      run: useMemoizedFn(fetchInstance.run.bind(fetchInstance)),
      runAsync: useMemoizedFn(fetchInstance.runAsync.bind(fetchInstance)),
      mutate: useMemoizedFn(fetchInstance.mutate.bind(fetchInstance))
    };
  }
  function useRequest(service, options, plugins) {
    return useRequestImplement(service, options, __spreadArray(__spreadArray([], __read([]), false), [
      useDebouncePlugin,
      useLoadingDelayPlugin,
      usePollingPlugin,
      useRefreshOnWindowFocusPlugin,
      useThrottlePlugin,
      useAutoRunPlugin,
      useCachePlugin,
      useRetryPlugin
    ], false));
  }
  function useToggle(defaultValue2, reverseValue) {
    if (defaultValue2 === void 0) {
      defaultValue2 = false;
    }
    var _a = __read(reactExports.useState(defaultValue2), 2), state2 = _a[0], setState = _a[1];
    var actions = reactExports.useMemo(function() {
      var reverseValueOrigin = !defaultValue2;
      var toggle = function() {
        return setState(function(s2) {
          return s2 === defaultValue2 ? reverseValueOrigin : defaultValue2;
        });
      };
      var set2 = function(value) {
        return setState(value);
      };
      var setLeft = function() {
        return setState(defaultValue2);
      };
      var setRight = function() {
        return setState(reverseValueOrigin);
      };
      return {
        toggle,
        set: set2,
        setLeft,
        setRight
      };
    }, []);
    return [state2, actions];
  }
  function useBoolean(defaultValue2) {
    var _a = __read(useToggle(false), 2), state2 = _a[0], _b = _a[1], toggle = _b.toggle, set2 = _b.set;
    var actions = reactExports.useMemo(function() {
      var setTrue = function() {
        return set2(true);
      };
      var setFalse = function() {
        return set2(false);
      };
      return {
        toggle,
        set: function(v) {
          return set2(!!v);
        },
        setTrue,
        setFalse
      };
    }, []);
    return [state2, actions];
  }
  function getTargetElement(target, defaultElement) {
    if (!isBrowser$1) {
      return void 0;
    }
    if (!target) {
      return defaultElement;
    }
    var targetElement;
    if (isFunction(target)) {
      targetElement = target();
    } else if ("current" in target) {
      targetElement = target.current;
    } else {
      targetElement = target;
    }
    return targetElement;
  }
  var checkIfAllInShadow = function(targets) {
    return targets.every(function(item) {
      var targetElement = getTargetElement(item);
      if (!targetElement) {
        return false;
      }
      if (targetElement.getRootNode() instanceof ShadowRoot) {
        return true;
      }
      return false;
    });
  };
  var getShadow = function(node2) {
    if (!node2) {
      return document;
    }
    return node2.getRootNode();
  };
  var getDocumentOrShadow = function(target) {
    if (!target || !document.getRootNode) {
      return document;
    }
    var targets = Array.isArray(target) ? target : [target];
    if (checkIfAllInShadow(targets)) {
      return getShadow(getTargetElement(targets[0]));
    }
    return document;
  };
  var createEffectWithTarget$1 = function(useEffectType) {
    var useEffectWithTarget2 = function(effect2, deps, target) {
      var hasInitRef = reactExports.useRef(false);
      var lastElementRef = reactExports.useRef([]);
      var lastDepsRef = reactExports.useRef([]);
      var unLoadRef = reactExports.useRef(void 0);
      useEffectType(function() {
        var _a;
        var targets = Array.isArray(target) ? target : [target];
        var els = targets.map(function(item) {
          return getTargetElement(item);
        });
        if (!hasInitRef.current) {
          hasInitRef.current = true;
          lastElementRef.current = els;
          lastDepsRef.current = deps;
          unLoadRef.current = effect2();
          return;
        }
        if (els.length !== lastElementRef.current.length || !depsAreSame$1(lastElementRef.current, els) || !depsAreSame$1(lastDepsRef.current, deps)) {
          (_a = unLoadRef.current) === null || _a === void 0 ? void 0 : _a.call(unLoadRef);
          lastElementRef.current = els;
          lastDepsRef.current = deps;
          unLoadRef.current = effect2();
        }
      });
      useUnmount$1(function() {
        var _a;
        (_a = unLoadRef.current) === null || _a === void 0 ? void 0 : _a.call(unLoadRef);
        hasInitRef.current = false;
      });
    };
    return useEffectWithTarget2;
  };
  var useEffectWithTarget$1 = createEffectWithTarget$1(reactExports.useEffect);
  function useClickAway(onClickAway, target, eventName) {
    if (eventName === void 0) {
      eventName = "click";
    }
    var onClickAwayRef = useLatest$1(onClickAway);
    useEffectWithTarget$1(function() {
      var handler = function(event) {
        var targets = Array.isArray(target) ? target : [target];
        if (targets.some(function(item) {
          var targetElement = getTargetElement(item);
          return !targetElement || targetElement.contains(event.target);
        })) {
          return;
        }
        onClickAwayRef.current(event);
      };
      var documentOrShadow = getDocumentOrShadow(target);
      var eventNames = Array.isArray(eventName) ? eventName : [eventName];
      eventNames.forEach(function(event) {
        return documentOrShadow.addEventListener(event, handler);
      });
      return function() {
        eventNames.forEach(function(event) {
          return documentOrShadow.removeEventListener(event, handler);
        });
      };
    }, Array.isArray(eventName) ? eventName : [eventName], target);
  }
  var reactFastCompare;
  var hasRequiredReactFastCompare;
  function requireReactFastCompare() {
    if (hasRequiredReactFastCompare) return reactFastCompare;
    hasRequiredReactFastCompare = 1;
    var hasElementType = typeof Element !== "undefined";
    var hasMap = typeof Map === "function";
    var hasSet = typeof Set === "function";
    var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
    function equal(a2, b) {
      if (a2 === b) return true;
      if (a2 && b && typeof a2 == "object" && typeof b == "object") {
        if (a2.constructor !== b.constructor) return false;
        var length2, i2, keys2;
        if (Array.isArray(a2)) {
          length2 = a2.length;
          if (length2 != b.length) return false;
          for (i2 = length2; i2-- !== 0; )
            if (!equal(a2[i2], b[i2])) return false;
          return true;
        }
        var it;
        if (hasMap && a2 instanceof Map && b instanceof Map) {
          if (a2.size !== b.size) return false;
          it = a2.entries();
          while (!(i2 = it.next()).done)
            if (!b.has(i2.value[0])) return false;
          it = a2.entries();
          while (!(i2 = it.next()).done)
            if (!equal(i2.value[1], b.get(i2.value[0]))) return false;
          return true;
        }
        if (hasSet && a2 instanceof Set && b instanceof Set) {
          if (a2.size !== b.size) return false;
          it = a2.entries();
          while (!(i2 = it.next()).done)
            if (!b.has(i2.value[0])) return false;
          return true;
        }
        if (hasArrayBuffer && ArrayBuffer.isView(a2) && ArrayBuffer.isView(b)) {
          length2 = a2.length;
          if (length2 != b.length) return false;
          for (i2 = length2; i2-- !== 0; )
            if (a2[i2] !== b[i2]) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b.source && a2.flags === b.flags;
        if (a2.valueOf !== Object.prototype.valueOf && typeof a2.valueOf === "function" && typeof b.valueOf === "function") return a2.valueOf() === b.valueOf();
        if (a2.toString !== Object.prototype.toString && typeof a2.toString === "function" && typeof b.toString === "function") return a2.toString() === b.toString();
        keys2 = Object.keys(a2);
        length2 = keys2.length;
        if (length2 !== Object.keys(b).length) return false;
        for (i2 = length2; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys2[i2])) return false;
        if (hasElementType && a2 instanceof Element) return false;
        for (i2 = length2; i2-- !== 0; ) {
          if ((keys2[i2] === "_owner" || keys2[i2] === "__v" || keys2[i2] === "__o") && a2.$$typeof) {
            continue;
          }
          if (!equal(a2[keys2[i2]], b[keys2[i2]])) return false;
        }
        return true;
      }
      return a2 !== a2 && b !== b;
    }
    reactFastCompare = function isEqual2(a2, b) {
      try {
        return equal(a2, b);
      } catch (error) {
        if ((error.message || "").match(/stack|recursion/i)) {
          console.warn("react-fast-compare cannot handle circular refs");
          return false;
        }
        throw error;
      }
    };
    return reactFastCompare;
  }
  var reactFastCompareExports = requireReactFastCompare();
  const isEqual = getDefaultExportFromCjs(reactFastCompareExports);
  var depsEqual$1 = function(aDeps, bDeps) {
    if (aDeps === void 0) {
      aDeps = [];
    }
    if (bDeps === void 0) {
      bDeps = [];
    }
    return isEqual(aDeps, bDeps);
  };
  function useEventListener(eventName, handler, options) {
    if (options === void 0) {
      options = {};
    }
    var _a = options.enable, enable2 = _a === void 0 ? true : _a;
    var handlerRef = useLatest$1(handler);
    useEffectWithTarget$1(function() {
      if (!enable2) {
        return;
      }
      var targetElement = getTargetElement(options.target, window);
      if (!(targetElement === null || targetElement === void 0 ? void 0 : targetElement.addEventListener)) {
        return;
      }
      var eventListener = function(event) {
        return handlerRef.current(event);
      };
      var eventNameArray = Array.isArray(eventName) ? eventName : [eventName];
      eventNameArray.forEach(function(event) {
        targetElement.addEventListener(event, eventListener, {
          capture: options.capture,
          once: options.once,
          passive: options.passive
        });
      });
      return function() {
        eventNameArray.forEach(function(event) {
          targetElement.removeEventListener(event, eventListener, {
            capture: options.capture
          });
        });
      };
    }, [eventName, options.capture, options.once, options.passive, enable2], options.target);
  }
  const useHover = (function(target, options) {
    var _a = {}, onEnter = _a.onEnter, onLeave = _a.onLeave, onChange = _a.onChange;
    var _b = __read(useBoolean(), 2), state2 = _b[0], _c = _b[1], setTrue = _c.setTrue, setFalse = _c.setFalse;
    useEventListener("mouseenter", function() {
      onEnter === null || onEnter === void 0 ? void 0 : onEnter();
      setTrue();
      onChange === null || onChange === void 0 ? void 0 : onChange(true);
    }, {
      target
    });
    useEventListener("mouseleave", function() {
      onLeave === null || onLeave === void 0 ? void 0 : onLeave();
      setFalse();
      onChange === null || onChange === void 0 ? void 0 : onChange(false);
    }, {
      target
    });
    return state2;
  });
  var useDeepCompareEffectWithTarget = function(effect2, deps, target) {
    var ref2 = reactExports.useRef(void 0);
    var signalRef = reactExports.useRef(0);
    if (!depsEqual$1(deps, ref2.current)) {
      signalRef.current += 1;
    }
    ref2.current = deps;
    useEffectWithTarget$1(effect2, [signalRef.current], target);
  };
  var isAppleDevice$1 = /(mac|iphone|ipod|ipad)/i.test(typeof navigator !== "undefined" ? navigator === null || navigator === void 0 ? void 0 : navigator.platform : "");
  var aliasKeyCodeMap = {
    "0": 48,
    "1": 49,
    "2": 50,
    "3": 51,
    "4": 52,
    "5": 53,
    "6": 54,
    "7": 55,
    "8": 56,
    "9": 57,
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    ctrl: 17,
    alt: 18,
    pausebreak: 19,
    capslock: 20,
    esc: 27,
    space: 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    leftarrow: 37,
    uparrow: 38,
    rightarrow: 39,
    downarrow: 40,
    insert: 45,
    delete: 46,
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    leftwindowkey: 91,
    rightwindowkey: 92,
    meta: isAppleDevice$1 ? [91, 93] : [91, 92],
    selectkey: 93,
    numpad0: 96,
    numpad1: 97,
    numpad2: 98,
    numpad3: 99,
    numpad4: 100,
    numpad5: 101,
    numpad6: 102,
    numpad7: 103,
    numpad8: 104,
    numpad9: 105,
    multiply: 106,
    add: 107,
    subtract: 109,
    decimalpoint: 110,
    divide: 111,
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    numlock: 144,
    scrolllock: 145,
    semicolon: 186,
    equalsign: 187,
    comma: 188,
    dash: 189,
    period: 190,
    forwardslash: 191,
    graveaccent: 192,
    openbracket: 219,
    backslash: 220,
    closebracket: 221,
    singlequote: 222
  };
  var modifierKey = {
    ctrl: function(event) {
      return event.ctrlKey;
    },
    shift: function(event) {
      return event.shiftKey;
    },
    alt: function(event) {
      return event.altKey;
    },
    meta: function(event) {
      if (event.type === "keyup") {
        return aliasKeyCodeMap.meta.includes(event.keyCode);
      }
      return event.metaKey;
    }
  };
  function isValidKeyType(value) {
    return isString(value) || isNumber(value);
  }
  function countKeyByEvent(event) {
    var countOfModifier = Object.keys(modifierKey).reduce(function(total, key) {
      if (modifierKey[key](event)) {
        return total + 1;
      }
      return total;
    }, 0);
    return [16, 17, 18, 91, 92].includes(event.keyCode) ? countOfModifier : countOfModifier + 1;
  }
  function genFilterKey(event, keyFilter, exactMatch) {
    var e_1, _a;
    if (!event.key) {
      return false;
    }
    if (isNumber(keyFilter)) {
      return event.keyCode === keyFilter ? keyFilter : false;
    }
    var genArr = keyFilter.split(".");
    var genLen = 0;
    try {
      for (var genArr_1 = __values(genArr), genArr_1_1 = genArr_1.next(); !genArr_1_1.done; genArr_1_1 = genArr_1.next()) {
        var key = genArr_1_1.value;
        var genModifier = modifierKey[key];
        var aliasKeyCode = aliasKeyCodeMap[key.toLowerCase()];
        if (genModifier && genModifier(event) || aliasKeyCode && aliasKeyCode === event.keyCode) {
          genLen++;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (genArr_1_1 && !genArr_1_1.done && (_a = genArr_1.return)) _a.call(genArr_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    if (exactMatch) {
      return genLen === genArr.length && countKeyByEvent(event) === genArr.length ? keyFilter : false;
    }
    return genLen === genArr.length ? keyFilter : false;
  }
  function genKeyFormatter(keyFilter, exactMatch) {
    if (isFunction(keyFilter)) {
      return keyFilter;
    }
    if (isValidKeyType(keyFilter)) {
      return function(event) {
        return genFilterKey(event, keyFilter, exactMatch);
      };
    }
    if (Array.isArray(keyFilter)) {
      return function(event) {
        return keyFilter.find(function(item) {
          return genFilterKey(event, item, exactMatch);
        });
      };
    }
    return function() {
      return Boolean(keyFilter);
    };
  }
  var defaultEvents = ["keydown"];
  function useKeyPress$2(keyFilter, eventHandler, option) {
    var _a = option || {}, _b = _a.events, events2 = _b === void 0 ? defaultEvents : _b, target = _a.target, _c = _a.exactMatch, exactMatch = _c === void 0 ? false : _c, _d = _a.useCapture, useCapture = _d === void 0 ? false : _d;
    var eventHandlerRef = useLatest$1(eventHandler);
    var keyFilterRef = useLatest$1(keyFilter);
    useDeepCompareEffectWithTarget(function() {
      var e_2, _a2;
      var _b2;
      var el = getTargetElement(target, window);
      if (!el) {
        return;
      }
      var callbackHandler = function(event) {
        var _a3;
        var keyEvent = event;
        var genGuard = genKeyFormatter(keyFilterRef.current, exactMatch);
        var keyGuard = genGuard(keyEvent);
        var firedKey = isValidKeyType(keyGuard) ? keyGuard : keyEvent.key;
        if (keyGuard) {
          return (_a3 = eventHandlerRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(eventHandlerRef, keyEvent, firedKey);
        }
      };
      try {
        for (var events_1 = __values(events2), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
          var eventName = events_1_1.value;
          (_b2 = el === null || el === void 0 ? void 0 : el.addEventListener) === null || _b2 === void 0 ? void 0 : _b2.call(el, eventName, callbackHandler, useCapture);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (events_1_1 && !events_1_1.done && (_a2 = events_1.return)) _a2.call(events_1);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
      return function() {
        var e_3, _a3;
        var _b3;
        try {
          for (var events_2 = __values(events2), events_2_1 = events_2.next(); !events_2_1.done; events_2_1 = events_2.next()) {
            var eventName2 = events_2_1.value;
            (_b3 = el === null || el === void 0 ? void 0 : el.removeEventListener) === null || _b3 === void 0 ? void 0 : _b3.call(el, eventName2, callbackHandler, useCapture);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (events_2_1 && !events_2_1.done && (_a3 = events_2.return)) _a3.call(events_2);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
      };
    }, [events2], target);
  }
  function useLockFn(fn) {
    var _this = this;
    var lockRef = reactExports.useRef(false);
    return reactExports.useCallback(function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return __awaiter(_this, void 0, void 0, function() {
        var ret, e_1;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (lockRef.current) {
                return [
                  2
];
              }
              lockRef.current = true;
              _a.label = 1;
            case 1:
              _a.trys.push([1, 3, 4, 5]);
              return [4, fn.apply(void 0, __spreadArray([], __read(args), false))];
            case 2:
              ret = _a.sent();
              return [2, ret];
            case 3:
              e_1 = _a.sent();
              throw e_1;
            case 4:
              lockRef.current = false;
              return [
                7
];
            case 5:
              return [
                2
];
          }
        });
      });
    }, [fn]);
  }
  function useRafState(initialState) {
    var ref2 = reactExports.useRef(0);
    var _a = __read(reactExports.useState(initialState), 2), state2 = _a[0], setState = _a[1];
    var setRafState = reactExports.useCallback(function(value) {
      cancelAnimationFrame(ref2.current);
      ref2.current = requestAnimationFrame(function() {
        setState(value);
      });
    }, []);
    useUnmount$1(function() {
      cancelAnimationFrame(ref2.current);
    });
    return [state2, setRafState];
  }
  var defaultShouldUpdate = function(a2, b) {
    return !Object.is(a2, b);
  };
  function usePrevious$1(state2, shouldUpdate) {
    if (shouldUpdate === void 0) {
      shouldUpdate = defaultShouldUpdate;
    }
    var prevRef = reactExports.useRef(void 0);
    var curRef = reactExports.useRef(void 0);
    if (shouldUpdate(curRef.current, state2)) {
      prevRef.current = curRef.current;
      curRef.current = state2;
    }
    return prevRef.current;
  }
  var useUnmountedRef = function() {
    var unmountedRef = reactExports.useRef(false);
    reactExports.useEffect(function() {
      unmountedRef.current = false;
      return function() {
        unmountedRef.current = true;
      };
    }, []);
    return unmountedRef;
  };
  const materialSymbolsCloseRounded = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "m12 13.4l-4.9 4.9q-.275.275-.7.275t-.7-.275t-.275-.7t.275-.7l4.9-4.9l-4.9-4.9q-.275-.275-.275-.7t.275-.7t.7-.275t.7.275l4.9 4.9l4.9-4.9q.275-.275.7-.275t.7.275t.275.7t-.275.7L13.4 12l4.9 4.9q.275.275.275.7t-.275.7t-.7.275t-.7-.275z" })
  ] });
  const ForwardRef$Q = reactExports.forwardRef(materialSymbolsCloseRounded);
  const BaseModalClassNames = {
    modalMask: clsx("fixed inset-0 flex items-center justify-center bg-black/50", clsZBaseModal),
    modal: "max-h-[calc(90vh-50px)] w-500px flex flex-col overflow-hidden b-1px b-transparent rounded-10px b-solid bg-gate-bg px-15px pb-15px text-gate-text dark:b-gate-border",
    modalHeader: "flex items-center justify-between border-b-0 py-10px",
    modalTitle: "mb-0 flex items-center text-[1.5rem] line-height-1.5",
    modalBody: "flex-grow-1 overflow-y-auto pt-0"
  };
  const APP_CLS_MODAL_VISIBLE = `${APP_NAMESPACE}-modal-visible`;
  const modalGlobalStyle = css("body:has(.", APP_CLS_MODAL_VISIBLE, "){overflow-y:hidden;}", "");
  function BaseModal({
    show,
    onHide: onHide2,
    children,
    clsModalMask,
    clsModal,
    width,
    hideWhenMaskOnClick = false,
    hideWhenEsc = false
  }) {
    const wrapperRef = reactExports.useRef(null);
    const onMaskClick = useMemoizedFn((e) => {
      const target = e.target;
      if (wrapperRef.current?.contains(target)) return;
      const selectors = [
        '.ant-tooltip-container[role="tooltip"]',
'.ant-popover-container[role="tooltip"]',
".ant-select-dropdown"
];
      if (target.closest(selectors.join(","))) return;
      if (hideWhenMaskOnClick) {
        onHide2();
      }
    });
    useKeyPress$2("esc", (e) => {
      if (!show) return;
      if (hideWhenEsc) {
        e.preventDefault();
        e.stopImmediatePropagation();
        setTimeout(onHide2);
      }
    }, {
      exactMatch: true
    });
    const _clsModalMask = r(BaseModalClassNames.modalMask, clsModalMask);
    const _clsModal = r(BaseModalClassNames.modal, clsModal);
    if (!show) {
      return null;
    }
    return reactDomExports.createPortal( jsx$1("div", { className: clsx(APP_CLS_ROOT, {
      [APP_CLS_MODAL_VISIBLE]: show
    }), "data-role": "base-modal", children: jsx$1("div", { className: _clsModalMask, onClick: onMaskClick, children: jsx$1("div", { className: _clsModal, style: {
      width
    }, ref: wrapperRef, children }) }) }), document.body);
  }
  const ModalClose = ({
    className,
    ...props
  }) => {
    const _className = r("ml-10px size-24px cursor-pointer transition-duration-150 transition-ease transition-property-transform hover:rotate-90 hover:scale-105%", className);
    return jsx$1(ForwardRef$Q, { ...props, className: _className });
  };
  let PurpleColors = (function(PurpleColors$1) {
    PurpleColors$1["Lavender"] = "#e6e6fa";
    PurpleColors$1["Thistle"] = "#d8bfd8";
    PurpleColors$1["Plum"] = "#dda0dd";
    PurpleColors$1["Mauve"] = "#e0b0ff";
    PurpleColors$1["Wisteria"] = "#c9a0dc";
    PurpleColors$1["Orchid"] = "#da70d6";
    PurpleColors$1["MediumOrchid"] = "#ba55d3";
    PurpleColors$1["MediumPurple"] = "#9370db";
    PurpleColors$1["Amethyst"] = "#9966cc";
    PurpleColors$1["BlueViolet"] = "#8a2be2";
    PurpleColors$1["Purple"] = "#800080";
    PurpleColors$1["Violet"] = "#8f00ff";
    PurpleColors$1["Magenta"] = "#ff00ff";
    PurpleColors$1["Grape"] = "#6f2da8";
    PurpleColors$1["Indigo"] = "#4b0082";
    PurpleColors$1["Eggplant"] = "#301934";
    return PurpleColors$1;
  })({});
  const PURPLE_COLORS = [
    {
      name: "Lavender",
      nameZh: "薰衣草",
      hex: PurpleColors.Lavender,
      desc: "淡紫偏粉"
    },
    {
      name: "Thistle",
      nameZh: "蓟紫色",
      hex: PurpleColors.Thistle,
      desc: "带灰调"
    },
    {
      name: "Plum",
      nameZh: "李子紫",
      hex: PurpleColors.Plum,
      desc: "柔和温暖"
    },
    {
      name: "Mauve",
      nameZh: "淡紫色",
      hex: PurpleColors.Mauve,
      desc: "烟粉色调"
    },
    {
      name: "Wisteria",
      nameZh: "紫藤色",
      hex: PurpleColors.Wisteria,
      desc: "温柔浅紫"
    },
    {
      name: "Orchid",
      nameZh: "兰花紫",
      hex: PurpleColors.Orchid,
      desc: "偏红亮紫"
    },
    {
      name: "Medium Orchid",
      nameZh: "中兰花紫",
      hex: PurpleColors.MediumOrchid,
      desc: "稍深更艳"
    },
    {
      name: "Medium Purple",
      nameZh: "中紫色",
      hex: PurpleColors.MediumPurple,
      desc: "柔和略蓝"
    },
    {
      name: "Amethyst",
      nameZh: "紫水晶色",
      hex: PurpleColors.Amethyst,
      desc: "经典冷紫"
    },
    {
      name: "Blue Violet",
      nameZh: "蓝紫色",
      hex: PurpleColors.BlueViolet,
      desc: "较冷"
    },
    {
      name: "Purple",
      nameZh: "标准紫色",
      hex: PurpleColors.Purple,
      desc: "饱和且暗"
    },
    {
      name: "Violet",
      nameZh: "紫罗兰",
      hex: PurpleColors.Violet,
      desc: "更偏蓝光谱"
    },
    {
      name: "Magenta",
      nameZh: "洋红色",
      hex: PurpleColors.Magenta,
      desc: "红紫交界"
    },
    {
      name: "Grape",
      nameZh: "葡萄紫",
      hex: PurpleColors.Grape,
      desc: "饱和深紫"
    },
    {
      name: "Indigo",
      nameZh: "靛青色",
      hex: PurpleColors.Indigo,
      desc: "蓝紫之间"
    },
    {
      name: "Eggplant",
      nameZh: "茄子紫",
      hex: PurpleColors.Eggplant,
      desc: "极深紫红"
    }
  ];
  const LX_THEMES = [
    {
      id: "green",
      name: "绿意盎然",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(77, 175, 124)",
      colorTheme: "rgb(77, 175, 124)"
    },
    {
      id: "blue",
      name: "蓝田生玉",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(52, 152, 219)",
      colorTheme: "rgb(52, 152, 219)"
    },
    {
      id: "blue_plus",
      name: "蛋雅深蓝",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(77, 131, 175)",
      colorTheme: "rgb(77, 131, 175)"
    },
    {
      id: "orange",
      name: "橙黄橘绿",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(245, 171, 53)",
      colorTheme: "rgb(245, 171, 53)"
    },
    {
      id: "red",
      name: "热情似火",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(214, 69, 65)",
      colorTheme: "rgb(214, 69, 65)"
    },
    {
      id: "pink",
      name: "粉装玉琢",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(241, 130, 141)",
      colorTheme: "rgb(241, 130, 141)"
    },
    {
      id: "purple",
      name: "重斤球紫",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(155, 89, 182)",
      colorTheme: "rgb(155, 89, 182)"
    },
    {
      id: "grey",
      name: "灰常美丽",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(108, 122, 137)",
      colorTheme: "rgb(108, 122, 137)"
    },
    {
      id: "ming",
      name: "青出于黑",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(51, 110, 123)",
      colorTheme: "rgb(51, 110, 123)"
    },
    {
      id: "blue2",
      name: "清热板蓝",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(79, 98, 208)",
      colorTheme: "rgb(79, 98, 208)"
    },
    {
      id: "black",
      name: "黑灯瞎火",
      isDark: true,
      isCustom: false,
      colorPrimary: "rgb(150, 150, 150)",
      colorTheme: "rgb(59,59,59)"
    },
    {
      id: "mid_autumn",
      name: "月里嫦娥",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(74, 55, 82)",
      colorTheme: "rgb(74, 55, 82)"
    },
    {
      id: "naruto",
      name: "木叶之村",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(87, 144, 167)",
      colorTheme: "rgb(87, 144, 167)"
    },
    {
      id: "china_ink",
      name: "近墨者黑",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgba(47, 47, 47, 1)",
      colorTheme: "rgba(47, 47, 47, 1)"
    },
    {
      id: "happy_new_year",
      name: "新年快乐",
      isDark: false,
      isCustom: false,
      colorPrimary: "rgb(192, 57, 43)",
      colorTheme: "rgb(192, 57, 43)"
    }
  ];
  const BILI_BRAND_PINK_THEME = {
    id: "default-bili-pink",
    name: "B站粉",
    colorPrimary: BiliBrandColor.Pink,
    tooltip: "B站品牌色"
  };
  const COLOR_PICKER_THEME = {
    id: "color-picker",
    name: "自定义",
    isCustom: true,
    colorPrimary: BiliBrandColor.Pink
};
  function toThemes(groupName, definitionStr) {
    return definitionStr.split("\n").map((s2) => s2.trim()).filter(Boolean).map((line2) => {
      const [colorPrimary, name] = line2.split(" ").filter(Boolean);
      return {
        id: `${groupName}:${name}`,
        name,
        colorPrimary
      };
    });
  }
  const LongwashingGroupName = "UP长期洗涤";
  const LongwashingThemes = toThemes(LongwashingGroupName, `
  #0545b2 理想之蓝
  #f4cd00 柠檬黄
  #ef2729 石榴红
  #f89c00 鹿箭
  #233728 黛绿
  #f2b9b7 和熙粉
  #f3cc91 芝士黄
  #6b4c68 葡萄紫
  #ff7227 落日橙
  #004d62 碧海天
  #23909b 洗碧空
  #aeb400 芥丝绿
  #425a17 箬叶青

  #002fa7 克莱因蓝
  #003153 普鲁士蓝
  #01847f 马尔斯绿
  #fbd26a 申布伦黄
  #470024 勃艮第红
  #492d22 凡戴克棕
  `);
  const BIBIBILI_EVOLVED_SYNC_ID = "bilibili-evolved-sync";
  const ThemeGroups = [{
    name: "预设",
    themes: [BILI_BRAND_PINK_THEME, {
      id: "bilibili-blue",
      name: "B站蓝",
      colorPrimary: BiliBrandColor.Blue,
      tooltip: "B站品牌色"
    }, {
      id: "app-custom-高能红",
      name: "高能红",
      colorPrimary: "#fd453e"
    }, {
      id: "app-custom-咸蛋黄",
      name: "咸蛋黄",
      colorPrimary: "#ffc034"
    }, {
      id: "app-custom-早苗绿",
      name: "早苗绿",
      colorPrimary: "#85c255"
    }, {
      id: "app-custom-宝石蓝",
      name: "宝石蓝",
      colorPrimary: "#0095ef"
    }, {
      id: "app-custom-罗兰紫",
      name: "罗兰紫",
      colorPrimary: "#a029ac"
    }, {
      id: BIBIBILI_EVOLVED_SYNC_ID,
      name: "B-Evolved",
      colorPrimary: `var(--theme-color,${getEvolvedThemeColorFallback()})`,
      tooltip: jsxs(Fragment, { children: [
        "使用 Bilibili-Evolved 的主题色",
jsx$1("br", {}),
        "在 Bilibili-Evolved 设置中修改主题色后可能需要刷新页面同步"
      ] })
    }, COLOR_PICKER_THEME]
  }, {
    name: "LX Themes",
    themes: LX_THEMES,
    tooltip: jsxs(Fragment, { children: [
      "提取自",
      " ",
jsx$1("a", { target: "_blank", href: "https://github.com/lyswhut/lx-music-desktop/", children: "lx-music-desktop" }),
jsx$1("br", {}),
      "Apache License 2.0"
    ] })
  }, {
    name: LongwashingGroupName,
    themes: LongwashingThemes,
    tooltip: jsxs(Fragment, { children: [
      "提取自",
      " ",
jsx$1("a", { target: "_blank", href: "https://www.bilibili.com/video/BV1g3411u7Lg/", children: "BV1g3411u7Lg" }),
      " ",
      "&",
      " ",
jsx$1("a", { target: "_blank", href: "https://www.bilibili.com/video/BV1xu411q7sU/", children: "BV1xu411q7sU" })
    ] })
  }, {
    name: "紫定能行",
    themes: PURPLE_COLORS.map((color2) => ({
      id: `purple-colors-${color2.name}`,
      name: color2.nameZh,
      colorPrimary: color2.hex,
      tooltip: jsxs(Fragment, { children: [
        color2.name,
        " ",
        color2.nameZh,
        " ",
jsx$1("br", {}),
        color2.desc
      ] })
    })),
    tooltip: jsxs(Fragment, { children: [
      "提取自",
      " ",
jsx$1("a", { target: "_blank", href: "https://magicdawn.github.io/purple-colors/", children: "purple-colors" }),
      " "
    ] })
  }];
  const ALL_THEMES = ThemeGroups.map((x) => x.themes).flat();
  const EXTRA_TOOLTIP = {
    [`${LongwashingGroupName}:马尔斯绿`]: jsxs(Fragment, { children: [
      "马尔斯绿 MARRS GREEN ",
jsx$1("br", {}),
      "2017年英国的百年造纸商G.F SMITH和英国城市文化节联合发起了「选出全世界最受欢迎的颜色」的活动， ",
jsx$1("br", {}),
      "在为期半年由来自100多个约3万名用户的投票后，由来自苏格兰的联合国教科文组织工作人员 ",
jsx$1("br", {}),
      "安妮•马尔斯（ANNIE MARRS）提交的一种蓝绿色当选。 ",
jsx$1("br", {}),
      "马尔斯绿也因此由ANNIE MARRS的姓氏和主色调组合而得名。 ",
jsx$1("br", {}),
      "马尔斯绿的灵感来源于ANNIE家乡苏格兰的泰勒河畔自然景观的一种蓝绿色调。 ",
jsx$1("br", {})
    ] })
  };
  function useCurrentTheme() {
    let {
      theme: themeId,
      colorPickerThemeSelectedColor
    } = useSettingsSnapshot();
    themeId ||= BILI_BRAND_PINK_THEME.id;
    return reactExports.useMemo(() => {
      const theme2 = ALL_THEMES.find((t2) => t2.id === themeId) || BILI_BRAND_PINK_THEME;
      if (theme2.id === COLOR_PICKER_THEME.id && colorPickerThemeSelectedColor) {
        return {
          ...theme2,
          colorPrimary: colorPickerThemeSelectedColor
        };
      }
      return theme2;
    }, [themeId, colorPickerThemeSelectedColor]);
  }
  function useColorPrimaryHex() {
    const currentTheme = useCurrentTheme();
    const evolvedThemeColor = $evolvedThemeColor.use();
    let colorPrimary = currentTheme.colorPrimary;
    if (currentTheme.id === BIBIBILI_EVOLVED_SYNC_ID) {
      colorPrimary = evolvedThemeColor || getEvolvedThemeColorFallback();
    }
    return colorPrimary;
  }
  function getBgSrcVaribale(dark, useWhiteBackground) {
    return dark ? "--bg1" : useWhiteBackground ? "--bg1" : "--bg2";
  }
  function BaseGlobalStyle() {
    const colorPrimary = useColorPrimaryHex();
    const dark = useIsDarkMode();
    const antLinkColorGlobalStyle = useAntLinkColorGlobalStyle();
    const {
      style: {
        pureRecommend: {
          useWhiteBackground
        }
      }
    } = useSettingsSnapshot();
    const config = reactExports.useMemo(() => {
      return {
        bgSrc: getBgSrcVaribale(dark, useWhiteBackground),
        bgFallback: dark ? "#17181a" : useWhiteBackground ? "#fff" : "#f6f7f8",
        text: dark ? "#fff" : "#333"
      };
    }, [dark, useWhiteBackground]);
    return jsx$1(Global, { styles: [antLinkColorGlobalStyle, modalGlobalStyle, css`
            :root {
              ${appPrimaryColorId}: ${colorPrimary};
              ${appBgId}: var(${config.bgSrc}, ${config.bgFallback});
              ${appTextColorId}: var(--text1, ${config.text});
            }
          `, "", ""] });
  }
  var _ref$5 = {
    name: "1ughwg6",
    styles: ".bili-feed4 .bili-header{min-height:64px!important;}"
  };
  var _ref2$1 = {
    name: "rpxvzv",
    styles: "#i_cecream,body>#app{.bili-feed4-layout{display:none;}}.desktop-download-tip,.vip-login-tip,.palette-button-adcard{display:none!important;}"
  };
  function HomePageGlobalStyle() {
    const {
      grid: {
        useCustomGrid
      },
      style: {
        pureRecommend: {
          useWhiteBackground,
          hideTopChannel
        }
      }
    } = useSettingsSnapshot();
    const dark = useIsDarkMode();
    const backToTopRight = useBackToTopRight();
    const usingEvolevdHeader = $usingEvolevdHeader.use();
    const width = $headerWidth.use() ?? 90;
    const padding = "0 10px";
    if (!IN_BILIBILI_HOMEPAGE) return;
    return jsx$1(Global, { styles: [
      _ref2$1,
      useCustomGrid && css("#i_cecream,body>#app,.bili-feed4 .bili-header,.bili-feed4 .bili-header .bili-header__bar{max-width:unset;}.bili-feed4-layout,.bili-feed4 .bili-header .bili-header__channel{max-width:", width, "%;padding:", padding, ";}", ""),
      useCustomGrid && typeof backToTopRight === "number" && css(".", APP_CLS_ROOT, "{--back-top-right:", backToTopRight, "px;}", ""),

css("body{background-color:", appBgValue, "!important;}.large-header,#i_cecream,body>#app,.bili-header.large-header,.bili-header.large-header .bili-header__channel{background-color:", appBgValue, ";}", ""),
!dark && !useWhiteBackground && css(".bili-header .bili-header__channel .channel-entry-more__link,.bili-header .bili-header__channel .channel-link{background-color:", appBgLv1Value, ";}", ""),
      hideTopChannel && css(".bili-header__channel,.bili-header__banner{display:none!important;}", !usingEvolevdHeader && _ref$5, " .bili-feed4 .bili-header .bili-header__bar{&.slide-down,&:not(.slide-down){animation:headerSlideDown 0.3s linear forwards!important;box-shadow:0 2px 4px ", dark ? "rgb(255 255 255 / 5%)" : "rgb(0 0 0 / 8%)", "!important;}}.bili-header__bar:not(.slide-down){background-color:var(--bg1);color:var(--text1);transition:background-color 0.2s linear;animation-name:headerSlideDown;.left-entry{.mini-header__title,.entry-title,.default-entry,.loc-mc-box__text,.download-entry,.loc-entry{color:var(--text1);}}.right-entry .right-entry__outside{.right-entry-text,.right-entry-icon{color:var(--text2);}}}.area-header-wrapper{margin-top:10px;}", ""),
      "",
      ""
    ] });
  }
  function compose(...fns) {
    return function(c2) {
      return fns.reduceRight((content, fn) => fn ? fn(content) : content, c2);
    };
  }
  function AppRoot({
    children,
    cssInsertContainer,
    cssInsertContainerEmotionKey
  }) {
    if (cssInsertContainer) {
      invariant$1(cssInsertContainerEmotionKey, "cssInsertContainerEmotionKey is required when cssInsertContainer is provided");
    }
    const emotionCache = reactExports.useMemo(() => {
      if (cssInsertContainer) {
        return createEmotion({
          key: cssInsertContainerEmotionKey,
          container: cssInsertContainer
        }).cache;
      }
    }, [cssInsertContainer, cssInsertContainerEmotionKey]);
    const dark = useIsDarkMode();
    const colorPrimary = useColorPrimaryHex();
    const wrap2 = compose(
!!emotionCache && ((c2) => jsx$1(CacheProvider, { value: emotionCache, children: c2 })),
!!cssInsertContainer && ((c2) => jsx$1(StyleProvider, { container: cssInsertContainer, children: c2 })),
(c2) => jsx$1(ConfigProvider, { locale: zhCN, button: {
        autoInsertSpace: false
      }, getPopupContainer: (triggerNode) => triggerNode?.closest("." + APP_CLS_ROOT) ?? document.body, theme: {
        algorithm: dark ? theme.darkAlgorithm : theme.defaultAlgorithm,
        token: {
          colorPrimary,
          colorBgSpotlight: colorPrimary,
zIndexPopupBase: parseZ(clsZAntdPopupBase),
          fontFamily: appUsingFont
        },
        components: {
          Notification: {
            zIndexPopup: parseZ(clsZAntdPopupBase)
          },
          Button: {
defaultShadow: "none",
            primaryShadow: "none"
          },
          Dropdown: {
}
        }
      }, children: c2 })
    );
    return wrap2(children);
  }
  function SetupForPage({
    antd,
    baseGlobalStyle,
    homePageGlobalStyle
  }) {
    return jsxs(Fragment, { children: [
      antd && jsx$1(AntdStaticFunctionsSetup, {}),
      baseGlobalStyle && jsx$1(BaseGlobalStyle, {}),
      homePageGlobalStyle && jsx$1(HomePageGlobalStyle, {})
    ] });
  }
  function useCombinedRefs() {
    for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
      refs[_key] = arguments[_key];
    }
    return reactExports.useMemo(
      () => (node2) => {
        refs.forEach((ref2) => ref2(node2));
      },
refs
    );
  }
  const canUseDOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
  function isWindow(element) {
    const elementString = Object.prototype.toString.call(element);
    return elementString === "[object Window]" ||
elementString === "[object global]";
  }
  function isNode(node2) {
    return "nodeType" in node2;
  }
  function getWindow(target) {
    var _target$ownerDocument, _target$ownerDocument2;
    if (!target) {
      return window;
    }
    if (isWindow(target)) {
      return target;
    }
    if (!isNode(target)) {
      return window;
    }
    return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;
  }
  function isDocument(node2) {
    const {
      Document: Document2
    } = getWindow(node2);
    return node2 instanceof Document2;
  }
  function isHTMLElement(node2) {
    if (isWindow(node2)) {
      return false;
    }
    return node2 instanceof getWindow(node2).HTMLElement;
  }
  function isSVGElement(node2) {
    return node2 instanceof getWindow(node2).SVGElement;
  }
  function getOwnerDocument(target) {
    if (!target) {
      return document;
    }
    if (isWindow(target)) {
      return target.document;
    }
    if (!isNode(target)) {
      return document;
    }
    if (isDocument(target)) {
      return target;
    }
    if (isHTMLElement(target) || isSVGElement(target)) {
      return target.ownerDocument;
    }
    return document;
  }
  const useIsomorphicLayoutEffect = canUseDOM ? reactExports.useLayoutEffect : reactExports.useEffect;
  function useEvent(handler) {
    const handlerRef = reactExports.useRef(handler);
    useIsomorphicLayoutEffect(() => {
      handlerRef.current = handler;
    });
    return reactExports.useCallback(function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return handlerRef.current == null ? void 0 : handlerRef.current(...args);
    }, []);
  }
  function useInterval() {
    const intervalRef = reactExports.useRef(null);
    const set2 = reactExports.useCallback((listener, duration2) => {
      intervalRef.current = setInterval(listener, duration2);
    }, []);
    const clear = reactExports.useCallback(() => {
      if (intervalRef.current !== null) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    }, []);
    return [set2, clear];
  }
  function useLatestValue(value, dependencies) {
    if (dependencies === void 0) {
      dependencies = [value];
    }
    const valueRef = reactExports.useRef(value);
    useIsomorphicLayoutEffect(() => {
      if (valueRef.current !== value) {
        valueRef.current = value;
      }
    }, dependencies);
    return valueRef;
  }
  function useLazyMemo(callback, dependencies) {
    const valueRef = reactExports.useRef();
    return reactExports.useMemo(
      () => {
        const newValue = callback(valueRef.current);
        valueRef.current = newValue;
        return newValue;
      },
[...dependencies]
    );
  }
  function useNodeRef(onChange) {
    const onChangeHandler = useEvent(onChange);
    const node2 = reactExports.useRef(null);
    const setNodeRef = reactExports.useCallback(
      (element) => {
        if (element !== node2.current) {
          onChangeHandler == null ? void 0 : onChangeHandler(element, node2.current);
        }
        node2.current = element;
      },
[]
    );
    return [node2, setNodeRef];
  }
  function usePrevious(value) {
    const ref2 = reactExports.useRef();
    reactExports.useEffect(() => {
      ref2.current = value;
    }, [value]);
    return ref2.current;
  }
  let ids = {};
  function useUniqueId(prefix2, value) {
    return reactExports.useMemo(() => {
      if (value) {
        return value;
      }
      const id2 = ids[prefix2] == null ? 0 : ids[prefix2] + 1;
      ids[prefix2] = id2;
      return prefix2 + "-" + id2;
    }, [prefix2, value]);
  }
  function createAdjustmentFn(modifier) {
    return function(object4) {
      for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        adjustments[_key - 1] = arguments[_key];
      }
      return adjustments.reduce((accumulator, adjustment) => {
        const entries = Object.entries(adjustment);
        for (const [key, valueAdjustment] of entries) {
          const value = accumulator[key];
          if (value != null) {
            accumulator[key] = value + modifier * valueAdjustment;
          }
        }
        return accumulator;
      }, {
        ...object4
      });
    };
  }
  const add = createAdjustmentFn(1);
  const subtract = createAdjustmentFn(-1);
  function hasViewportRelativeCoordinates(event) {
    return "clientX" in event && "clientY" in event;
  }
  function isKeyboardEvent(event) {
    if (!event) {
      return false;
    }
    const {
      KeyboardEvent
    } = getWindow(event.target);
    return KeyboardEvent && event instanceof KeyboardEvent;
  }
  function isTouchEvent(event) {
    if (!event) {
      return false;
    }
    const {
      TouchEvent
    } = getWindow(event.target);
    return TouchEvent && event instanceof TouchEvent;
  }
  function getEventCoordinates(event) {
    if (isTouchEvent(event)) {
      if (event.touches && event.touches.length) {
        const {
          clientX: x,
          clientY: y
        } = event.touches[0];
        return {
          x,
          y
        };
      } else if (event.changedTouches && event.changedTouches.length) {
        const {
          clientX: x,
          clientY: y
        } = event.changedTouches[0];
        return {
          x,
          y
        };
      }
    }
    if (hasViewportRelativeCoordinates(event)) {
      return {
        x: event.clientX,
        y: event.clientY
      };
    }
    return null;
  }
  const CSS = Object.freeze({
    Translate: {
      toString(transform) {
        if (!transform) {
          return;
        }
        const {
          x,
          y
        } = transform;
        return "translate3d(" + (x ? Math.round(x) : 0) + "px, " + (y ? Math.round(y) : 0) + "px, 0)";
      }
    },
    Scale: {
      toString(transform) {
        if (!transform) {
          return;
        }
        const {
          scaleX: scaleX2,
          scaleY: scaleY2
        } = transform;
        return "scaleX(" + scaleX2 + ") scaleY(" + scaleY2 + ")";
      }
    },
    Transform: {
      toString(transform) {
        if (!transform) {
          return;
        }
        return [CSS.Translate.toString(transform), CSS.Scale.toString(transform)].join(" ");
      }
    },
    Transition: {
      toString(_ref4) {
        let {
          property,
          duration: duration2,
          easing
        } = _ref4;
        return property + " " + duration2 + "ms " + easing;
      }
    }
  });
  const SELECTOR = "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]";
  function findFirstFocusableNode(element) {
    if (element.matches(SELECTOR)) {
      return element;
    }
    return element.querySelector(SELECTOR);
  }
  const hiddenStyles = {
    display: "none"
  };
  function HiddenText(_ref4) {
    let {
      id: id2,
      value
    } = _ref4;
    return React.createElement("div", {
      id: id2,
      style: hiddenStyles
    }, value);
  }
  function LiveRegion(_ref4) {
    let {
      id: id2,
      announcement,
      ariaLiveType = "assertive"
    } = _ref4;
    const visuallyHidden = {
      position: "fixed",
      top: 0,
      left: 0,
      width: 1,
      height: 1,
      margin: -1,
      border: 0,
      padding: 0,
      overflow: "hidden",
      clip: "rect(0 0 0 0)",
      clipPath: "inset(100%)",
      whiteSpace: "nowrap"
    };
    return React.createElement("div", {
      id: id2,
      style: visuallyHidden,
      role: "status",
      "aria-live": ariaLiveType,
      "aria-atomic": true
    }, announcement);
  }
  function useAnnouncement() {
    const [announcement, setAnnouncement] = reactExports.useState("");
    const announce = reactExports.useCallback((value) => {
      if (value != null) {
        setAnnouncement(value);
      }
    }, []);
    return {
      announce,
      announcement
    };
  }
  const DndMonitorContext = reactExports.createContext(null);
  function useDndMonitor(listener) {
    const registerListener = reactExports.useContext(DndMonitorContext);
    reactExports.useEffect(() => {
      if (!registerListener) {
        throw new Error("useDndMonitor must be used within a children of <DndContext>");
      }
      const unsubscribe = registerListener(listener);
      return unsubscribe;
    }, [listener, registerListener]);
  }
  function useDndMonitorProvider() {
    const [listeners2] = reactExports.useState(() => new Set());
    const registerListener = reactExports.useCallback((listener) => {
      listeners2.add(listener);
      return () => listeners2.delete(listener);
    }, [listeners2]);
    const dispatch = reactExports.useCallback((_ref4) => {
      let {
        type: type4,
        event
      } = _ref4;
      listeners2.forEach((listener) => {
        var _listener$type;
        return (_listener$type = listener[type4]) == null ? void 0 : _listener$type.call(listener, event);
      });
    }, [listeners2]);
    return [dispatch, registerListener];
  }
  const defaultScreenReaderInstructions = {
    draggable: "\n    To pick up a draggable item, press the space bar.\n    While dragging, use the arrow keys to move the item.\n    Press space again to drop the item in its new position, or press escape to cancel.\n  "
  };
  const defaultAnnouncements = {
    onDragStart(_ref4) {
      let {
        active
      } = _ref4;
      return "Picked up draggable item " + active.id + ".";
    },
    onDragOver(_ref22) {
      let {
        active,
        over
      } = _ref22;
      if (over) {
        return "Draggable item " + active.id + " was moved over droppable area " + over.id + ".";
      }
      return "Draggable item " + active.id + " is no longer over a droppable area.";
    },
    onDragEnd(_ref32) {
      let {
        active,
        over
      } = _ref32;
      if (over) {
        return "Draggable item " + active.id + " was dropped over droppable area " + over.id;
      }
      return "Draggable item " + active.id + " was dropped.";
    },
    onDragCancel(_ref4) {
      let {
        active
      } = _ref4;
      return "Dragging was cancelled. Draggable item " + active.id + " was dropped.";
    }
  };
  function Accessibility(_ref4) {
    let {
      announcements = defaultAnnouncements,
      container,
      hiddenTextDescribedById,
      screenReaderInstructions = defaultScreenReaderInstructions
    } = _ref4;
    const {
      announce,
      announcement
    } = useAnnouncement();
    const liveRegionId = useUniqueId("DndLiveRegion");
    const [mounted, setMounted] = reactExports.useState(false);
    reactExports.useEffect(() => {
      setMounted(true);
    }, []);
    useDndMonitor(reactExports.useMemo(() => ({
      onDragStart(_ref22) {
        let {
          active
        } = _ref22;
        announce(announcements.onDragStart({
          active
        }));
      },
      onDragMove(_ref32) {
        let {
          active,
          over
        } = _ref32;
        if (announcements.onDragMove) {
          announce(announcements.onDragMove({
            active,
            over
          }));
        }
      },
      onDragOver(_ref42) {
        let {
          active,
          over
        } = _ref42;
        announce(announcements.onDragOver({
          active,
          over
        }));
      },
      onDragEnd(_ref5) {
        let {
          active,
          over
        } = _ref5;
        announce(announcements.onDragEnd({
          active,
          over
        }));
      },
      onDragCancel(_ref6) {
        let {
          active,
          over
        } = _ref6;
        announce(announcements.onDragCancel({
          active,
          over
        }));
      }
    }), [announce, announcements]));
    if (!mounted) {
      return null;
    }
    const markup = React.createElement(React.Fragment, null, React.createElement(HiddenText, {
      id: hiddenTextDescribedById,
      value: screenReaderInstructions.draggable
    }), React.createElement(LiveRegion, {
      id: liveRegionId,
      announcement
    }));
    return container ? reactDomExports.createPortal(markup, container) : markup;
  }
  var Action;
  (function(Action2) {
    Action2["DragStart"] = "dragStart";
    Action2["DragMove"] = "dragMove";
    Action2["DragEnd"] = "dragEnd";
    Action2["DragCancel"] = "dragCancel";
    Action2["DragOver"] = "dragOver";
    Action2["RegisterDroppable"] = "registerDroppable";
    Action2["SetDroppableDisabled"] = "setDroppableDisabled";
    Action2["UnregisterDroppable"] = "unregisterDroppable";
  })(Action || (Action = {}));
  function noop() {
  }
  function useSensor(sensor, options) {
    return reactExports.useMemo(
      () => ({
        sensor,
        options: {}
      }),
[sensor, options]
    );
  }
  function useSensors() {
    for (var _len = arguments.length, sensors = new Array(_len), _key = 0; _key < _len; _key++) {
      sensors[_key] = arguments[_key];
    }
    return reactExports.useMemo(
      () => [...sensors].filter((sensor) => sensor != null),
[...sensors]
    );
  }
  const defaultCoordinates = Object.freeze({
    x: 0,
    y: 0
  });
  function distanceBetween(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
  }
  function sortCollisionsAsc(_ref4, _ref22) {
    let {
      data: {
        value: a2
      }
    } = _ref4;
    let {
      data: {
        value: b
      }
    } = _ref22;
    return a2 - b;
  }
  function sortCollisionsDesc(_ref32, _ref4) {
    let {
      data: {
        value: a2
      }
    } = _ref32;
    let {
      data: {
        value: b
      }
    } = _ref4;
    return b - a2;
  }
  function getFirstCollision(collisions, property) {
    if (!collisions || collisions.length === 0) {
      return null;
    }
    const [firstCollision] = collisions;
    return firstCollision[property];
  }
  function centerOfRectangle(rect, left, top) {
    if (left === void 0) {
      left = rect.left;
    }
    if (top === void 0) {
      top = rect.top;
    }
    return {
      x: left + rect.width * 0.5,
      y: top + rect.height * 0.5
    };
  }
  const closestCenter = (_ref4) => {
    let {
      collisionRect,
      droppableRects,
      droppableContainers
    } = _ref4;
    const centerRect = centerOfRectangle(collisionRect, collisionRect.left, collisionRect.top);
    const collisions = [];
    for (const droppableContainer of droppableContainers) {
      const {
        id: id2
      } = droppableContainer;
      const rect = droppableRects.get(id2);
      if (rect) {
        const distBetween = distanceBetween(centerOfRectangle(rect), centerRect);
        collisions.push({
          id: id2,
          data: {
            droppableContainer,
            value: distBetween
          }
        });
      }
    }
    return collisions.sort(sortCollisionsAsc);
  };
  function getIntersectionRatio(entry, target) {
    const top = Math.max(target.top, entry.top);
    const left = Math.max(target.left, entry.left);
    const right = Math.min(target.left + target.width, entry.left + entry.width);
    const bottom = Math.min(target.top + target.height, entry.top + entry.height);
    const width = right - left;
    const height = bottom - top;
    if (left < right && top < bottom) {
      const targetArea = target.width * target.height;
      const entryArea = entry.width * entry.height;
      const intersectionArea = width * height;
      const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
      return Number(intersectionRatio.toFixed(4));
    }
    return 0;
  }
  const rectIntersection = (_ref4) => {
    let {
      collisionRect,
      droppableRects,
      droppableContainers
    } = _ref4;
    const collisions = [];
    for (const droppableContainer of droppableContainers) {
      const {
        id: id2
      } = droppableContainer;
      const rect = droppableRects.get(id2);
      if (rect) {
        const intersectionRatio = getIntersectionRatio(rect, collisionRect);
        if (intersectionRatio > 0) {
          collisions.push({
            id: id2,
            data: {
              droppableContainer,
              value: intersectionRatio
            }
          });
        }
      }
    }
    return collisions.sort(sortCollisionsDesc);
  };
  function adjustScale(transform, rect1, rect2) {
    return {
      ...transform,
      scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,
      scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1
    };
  }
  function getRectDelta(rect1, rect2) {
    return rect1 && rect2 ? {
      x: rect1.left - rect2.left,
      y: rect1.top - rect2.top
    } : defaultCoordinates;
  }
  function createRectAdjustmentFn(modifier) {
    return function adjustClientRect(rect) {
      for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        adjustments[_key - 1] = arguments[_key];
      }
      return adjustments.reduce((acc, adjustment) => ({
        ...acc,
        top: acc.top + modifier * adjustment.y,
        bottom: acc.bottom + modifier * adjustment.y,
        left: acc.left + modifier * adjustment.x,
        right: acc.right + modifier * adjustment.x
      }), {
        ...rect
      });
    };
  }
  const getAdjustedRect = createRectAdjustmentFn(1);
  function parseTransform(transform) {
    if (transform.startsWith("matrix3d(")) {
      const transformArray = transform.slice(9, -1).split(/, /);
      return {
        x: +transformArray[12],
        y: +transformArray[13],
        scaleX: +transformArray[0],
        scaleY: +transformArray[5]
      };
    } else if (transform.startsWith("matrix(")) {
      const transformArray = transform.slice(7, -1).split(/, /);
      return {
        x: +transformArray[4],
        y: +transformArray[5],
        scaleX: +transformArray[0],
        scaleY: +transformArray[3]
      };
    }
    return null;
  }
  function inverseTransform(rect, transform, transformOrigin) {
    const parsedTransform = parseTransform(transform);
    if (!parsedTransform) {
      return rect;
    }
    const {
      scaleX: scaleX2,
      scaleY: scaleY2,
      x: translateX,
      y: translateY
    } = parsedTransform;
    const x = rect.left - translateX - (1 - scaleX2) * parseFloat(transformOrigin);
    const y = rect.top - translateY - (1 - scaleY2) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(" ") + 1));
    const w = scaleX2 ? rect.width / scaleX2 : rect.width;
    const h2 = scaleY2 ? rect.height / scaleY2 : rect.height;
    return {
      width: w,
      height: h2,
      top: y,
      right: x + w,
      bottom: y + h2,
      left: x
    };
  }
  const defaultOptions = {
    ignoreTransform: false
  };
  function getClientRect(element, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    let rect = element.getBoundingClientRect();
    if (options.ignoreTransform) {
      const {
        transform,
        transformOrigin
      } = getWindow(element).getComputedStyle(element);
      if (transform) {
        rect = inverseTransform(rect, transform, transformOrigin);
      }
    }
    const {
      top,
      left,
      width,
      height,
      bottom,
      right
    } = rect;
    return {
      top,
      left,
      width,
      height,
      bottom,
      right
    };
  }
  function getTransformAgnosticClientRect(element) {
    return getClientRect(element, {
      ignoreTransform: true
    });
  }
  function getWindowClientRect(element) {
    const width = element.innerWidth;
    const height = element.innerHeight;
    return {
      top: 0,
      left: 0,
      right: width,
      bottom: height,
      width,
      height
    };
  }
  function isFixed(node2, computedStyle) {
    if (computedStyle === void 0) {
      computedStyle = getWindow(node2).getComputedStyle(node2);
    }
    return computedStyle.position === "fixed";
  }
  function isScrollable(element, computedStyle) {
    if (computedStyle === void 0) {
      computedStyle = getWindow(element).getComputedStyle(element);
    }
    const overflowRegex = /(auto|scroll|overlay)/;
    const properties2 = ["overflow", "overflowX", "overflowY"];
    return properties2.some((property) => {
      const value = computedStyle[property];
      return typeof value === "string" ? overflowRegex.test(value) : false;
    });
  }
  function getScrollableAncestors(element, limit2) {
    const scrollParents = [];
    function findScrollableAncestors(node2) {
      if (limit2 != null && scrollParents.length >= limit2) {
        return scrollParents;
      }
      if (!node2) {
        return scrollParents;
      }
      if (isDocument(node2) && node2.scrollingElement != null && !scrollParents.includes(node2.scrollingElement)) {
        scrollParents.push(node2.scrollingElement);
        return scrollParents;
      }
      if (!isHTMLElement(node2) || isSVGElement(node2)) {
        return scrollParents;
      }
      if (scrollParents.includes(node2)) {
        return scrollParents;
      }
      const computedStyle = getWindow(element).getComputedStyle(node2);
      if (node2 !== element) {
        if (isScrollable(node2, computedStyle)) {
          scrollParents.push(node2);
        }
      }
      if (isFixed(node2, computedStyle)) {
        return scrollParents;
      }
      return findScrollableAncestors(node2.parentNode);
    }
    if (!element) {
      return scrollParents;
    }
    return findScrollableAncestors(element);
  }
  function getFirstScrollableAncestor(node2) {
    const [firstScrollableAncestor] = getScrollableAncestors(node2, 1);
    return firstScrollableAncestor != null ? firstScrollableAncestor : null;
  }
  function getScrollableElement(element) {
    if (!canUseDOM || !element) {
      return null;
    }
    if (isWindow(element)) {
      return element;
    }
    if (!isNode(element)) {
      return null;
    }
    if (isDocument(element) || element === getOwnerDocument(element).scrollingElement) {
      return window;
    }
    if (isHTMLElement(element)) {
      return element;
    }
    return null;
  }
  function getScrollXCoordinate(element) {
    if (isWindow(element)) {
      return element.scrollX;
    }
    return element.scrollLeft;
  }
  function getScrollYCoordinate(element) {
    if (isWindow(element)) {
      return element.scrollY;
    }
    return element.scrollTop;
  }
  function getScrollCoordinates(element) {
    return {
      x: getScrollXCoordinate(element),
      y: getScrollYCoordinate(element)
    };
  }
  var Direction;
  (function(Direction2) {
    Direction2[Direction2["Forward"] = 1] = "Forward";
    Direction2[Direction2["Backward"] = -1] = "Backward";
  })(Direction || (Direction = {}));
  function isDocumentScrollingElement(element) {
    if (!canUseDOM || !element) {
      return false;
    }
    return element === document.scrollingElement;
  }
  function getScrollPosition(scrollingContainer) {
    const minScroll = {
      x: 0,
      y: 0
    };
    const dimensions = isDocumentScrollingElement(scrollingContainer) ? {
      height: window.innerHeight,
      width: window.innerWidth
    } : {
      height: scrollingContainer.clientHeight,
      width: scrollingContainer.clientWidth
    };
    const maxScroll = {
      x: scrollingContainer.scrollWidth - dimensions.width,
      y: scrollingContainer.scrollHeight - dimensions.height
    };
    const isTop = scrollingContainer.scrollTop <= minScroll.y;
    const isLeft = scrollingContainer.scrollLeft <= minScroll.x;
    const isBottom = scrollingContainer.scrollTop >= maxScroll.y;
    const isRight = scrollingContainer.scrollLeft >= maxScroll.x;
    return {
      isTop,
      isLeft,
      isBottom,
      isRight,
      maxScroll,
      minScroll
    };
  }
  const defaultThreshold = {
    x: 0.2,
    y: 0.2
  };
  function getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, _ref4, acceleration, thresholdPercentage) {
    let {
      top,
      left,
      right,
      bottom
    } = _ref4;
    if (acceleration === void 0) {
      acceleration = 10;
    }
    if (thresholdPercentage === void 0) {
      thresholdPercentage = defaultThreshold;
    }
    const {
      isTop,
      isBottom,
      isLeft,
      isRight
    } = getScrollPosition(scrollContainer);
    const direction = {
      x: 0,
      y: 0
    };
    const speed = {
      x: 0,
      y: 0
    };
    const threshold = {
      height: scrollContainerRect.height * thresholdPercentage.y,
      width: scrollContainerRect.width * thresholdPercentage.x
    };
    if (!isTop && top <= scrollContainerRect.top + threshold.height) {
      direction.y = Direction.Backward;
      speed.y = acceleration * Math.abs((scrollContainerRect.top + threshold.height - top) / threshold.height);
    } else if (!isBottom && bottom >= scrollContainerRect.bottom - threshold.height) {
      direction.y = Direction.Forward;
      speed.y = acceleration * Math.abs((scrollContainerRect.bottom - threshold.height - bottom) / threshold.height);
    }
    if (!isRight && right >= scrollContainerRect.right - threshold.width) {
      direction.x = Direction.Forward;
      speed.x = acceleration * Math.abs((scrollContainerRect.right - threshold.width - right) / threshold.width);
    } else if (!isLeft && left <= scrollContainerRect.left + threshold.width) {
      direction.x = Direction.Backward;
      speed.x = acceleration * Math.abs((scrollContainerRect.left + threshold.width - left) / threshold.width);
    }
    return {
      direction,
      speed
    };
  }
  function getScrollElementRect(element) {
    if (element === document.scrollingElement) {
      const {
        innerWidth,
        innerHeight
      } = window;
      return {
        top: 0,
        left: 0,
        right: innerWidth,
        bottom: innerHeight,
        width: innerWidth,
        height: innerHeight
      };
    }
    const {
      top,
      left,
      right,
      bottom
    } = element.getBoundingClientRect();
    return {
      top,
      left,
      right,
      bottom,
      width: element.clientWidth,
      height: element.clientHeight
    };
  }
  function getScrollOffsets(scrollableAncestors) {
    return scrollableAncestors.reduce((acc, node2) => {
      return add(acc, getScrollCoordinates(node2));
    }, defaultCoordinates);
  }
  function getScrollXOffset(scrollableAncestors) {
    return scrollableAncestors.reduce((acc, node2) => {
      return acc + getScrollXCoordinate(node2);
    }, 0);
  }
  function getScrollYOffset(scrollableAncestors) {
    return scrollableAncestors.reduce((acc, node2) => {
      return acc + getScrollYCoordinate(node2);
    }, 0);
  }
  function scrollIntoViewIfNeeded(element, measure) {
    if (measure === void 0) {
      measure = getClientRect;
    }
    if (!element) {
      return;
    }
    const {
      top,
      left,
      bottom,
      right
    } = measure(element);
    const firstScrollableAncestor = getFirstScrollableAncestor(element);
    if (!firstScrollableAncestor) {
      return;
    }
    if (bottom <= 0 || right <= 0 || top >= window.innerHeight || left >= window.innerWidth) {
      element.scrollIntoView({
        block: "center",
        inline: "center"
      });
    }
  }
  const properties = [["x", ["left", "right"], getScrollXOffset], ["y", ["top", "bottom"], getScrollYOffset]];
  class Rect {
    constructor(rect, element) {
      this.rect = void 0;
      this.width = void 0;
      this.height = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.right = void 0;
      this.left = void 0;
      const scrollableAncestors = getScrollableAncestors(element);
      const scrollOffsets = getScrollOffsets(scrollableAncestors);
      this.rect = {
        ...rect
      };
      this.width = rect.width;
      this.height = rect.height;
      for (const [axis, keys2, getScrollOffset] of properties) {
        for (const key of keys2) {
          Object.defineProperty(this, key, {
            get: () => {
              const currentOffsets = getScrollOffset(scrollableAncestors);
              const scrollOffsetsDeltla = scrollOffsets[axis] - currentOffsets;
              return this.rect[key] + scrollOffsetsDeltla;
            },
            enumerable: true
          });
        }
      }
      Object.defineProperty(this, "rect", {
        enumerable: false
      });
    }
  }
  class Listeners {
    constructor(target) {
      this.target = void 0;
      this.listeners = [];
      this.removeAll = () => {
        this.listeners.forEach((listener) => {
          var _this$target;
          return (_this$target = this.target) == null ? void 0 : _this$target.removeEventListener(...listener);
        });
      };
      this.target = target;
    }
    add(eventName, handler, options) {
      var _this$target2;
      (_this$target2 = this.target) == null ? void 0 : _this$target2.addEventListener(eventName, handler, options);
      this.listeners.push([eventName, handler, options]);
    }
  }
  function getEventListenerTarget(target) {
    const {
      EventTarget: EventTarget2
    } = getWindow(target);
    return target instanceof EventTarget2 ? target : getOwnerDocument(target);
  }
  function hasExceededDistance(delta, measurement) {
    const dx = Math.abs(delta.x);
    const dy = Math.abs(delta.y);
    if (typeof measurement === "number") {
      return Math.sqrt(dx ** 2 + dy ** 2) > measurement;
    }
    if ("x" in measurement && "y" in measurement) {
      return dx > measurement.x && dy > measurement.y;
    }
    if ("x" in measurement) {
      return dx > measurement.x;
    }
    if ("y" in measurement) {
      return dy > measurement.y;
    }
    return false;
  }
  var EventName;
  (function(EventName2) {
    EventName2["Click"] = "click";
    EventName2["DragStart"] = "dragstart";
    EventName2["Keydown"] = "keydown";
    EventName2["ContextMenu"] = "contextmenu";
    EventName2["Resize"] = "resize";
    EventName2["SelectionChange"] = "selectionchange";
    EventName2["VisibilityChange"] = "visibilitychange";
  })(EventName || (EventName = {}));
  function preventDefault(event) {
    event.preventDefault();
  }
  function stopPropagation(event) {
    event.stopPropagation();
  }
  var KeyboardCode;
  (function(KeyboardCode2) {
    KeyboardCode2["Space"] = "Space";
    KeyboardCode2["Down"] = "ArrowDown";
    KeyboardCode2["Right"] = "ArrowRight";
    KeyboardCode2["Left"] = "ArrowLeft";
    KeyboardCode2["Up"] = "ArrowUp";
    KeyboardCode2["Esc"] = "Escape";
    KeyboardCode2["Enter"] = "Enter";
    KeyboardCode2["Tab"] = "Tab";
  })(KeyboardCode || (KeyboardCode = {}));
  const defaultKeyboardCodes = {
    start: [KeyboardCode.Space, KeyboardCode.Enter],
    cancel: [KeyboardCode.Esc],
    end: [KeyboardCode.Space, KeyboardCode.Enter, KeyboardCode.Tab]
  };
  const defaultKeyboardCoordinateGetter = (event, _ref4) => {
    let {
      currentCoordinates
    } = _ref4;
    switch (event.code) {
      case KeyboardCode.Right:
        return {
          ...currentCoordinates,
          x: currentCoordinates.x + 25
        };
      case KeyboardCode.Left:
        return {
          ...currentCoordinates,
          x: currentCoordinates.x - 25
        };
      case KeyboardCode.Down:
        return {
          ...currentCoordinates,
          y: currentCoordinates.y + 25
        };
      case KeyboardCode.Up:
        return {
          ...currentCoordinates,
          y: currentCoordinates.y - 25
        };
    }
    return void 0;
  };
  class KeyboardSensor {
    constructor(props) {
      this.props = void 0;
      this.autoScrollEnabled = false;
      this.referenceCoordinates = void 0;
      this.listeners = void 0;
      this.windowListeners = void 0;
      this.props = props;
      const {
        event: {
          target
        }
      } = props;
      this.props = props;
      this.listeners = new Listeners(getOwnerDocument(target));
      this.windowListeners = new Listeners(getWindow(target));
      this.handleKeyDown = this.handleKeyDown.bind(this);
      this.handleCancel = this.handleCancel.bind(this);
      this.attach();
    }
    attach() {
      this.handleStart();
      this.windowListeners.add(EventName.Resize, this.handleCancel);
      this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
      setTimeout(() => this.listeners.add(EventName.Keydown, this.handleKeyDown));
    }
    handleStart() {
      const {
        activeNode,
        onStart
      } = this.props;
      const node2 = activeNode.node.current;
      if (node2) {
        scrollIntoViewIfNeeded(node2);
      }
      onStart(defaultCoordinates);
    }
    handleKeyDown(event) {
      if (isKeyboardEvent(event)) {
        const {
          active,
          context,
          options
        } = this.props;
        const {
          keyboardCodes = defaultKeyboardCodes,
          coordinateGetter = defaultKeyboardCoordinateGetter,
          scrollBehavior = "smooth"
        } = options;
        const {
          code
        } = event;
        if (keyboardCodes.end.includes(code)) {
          this.handleEnd(event);
          return;
        }
        if (keyboardCodes.cancel.includes(code)) {
          this.handleCancel(event);
          return;
        }
        const {
          collisionRect
        } = context.current;
        const currentCoordinates = collisionRect ? {
          x: collisionRect.left,
          y: collisionRect.top
        } : defaultCoordinates;
        if (!this.referenceCoordinates) {
          this.referenceCoordinates = currentCoordinates;
        }
        const newCoordinates = coordinateGetter(event, {
          active,
          context: context.current,
          currentCoordinates
        });
        if (newCoordinates) {
          const coordinatesDelta = subtract(newCoordinates, currentCoordinates);
          const scrollDelta = {
            x: 0,
            y: 0
          };
          const {
            scrollableAncestors
          } = context.current;
          for (const scrollContainer of scrollableAncestors) {
            const direction = event.code;
            const {
              isTop,
              isRight,
              isLeft,
              isBottom,
              maxScroll,
              minScroll
            } = getScrollPosition(scrollContainer);
            const scrollElementRect = getScrollElementRect(scrollContainer);
            const clampedCoordinates = {
              x: Math.min(direction === KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),
              y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))
            };
            const canScrollX = direction === KeyboardCode.Right && !isRight || direction === KeyboardCode.Left && !isLeft;
            const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;
            if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {
              const newScrollCoordinates = scrollContainer.scrollLeft + coordinatesDelta.x;
              const canScrollToNewCoordinates = direction === KeyboardCode.Right && newScrollCoordinates <= maxScroll.x || direction === KeyboardCode.Left && newScrollCoordinates >= minScroll.x;
              if (canScrollToNewCoordinates && !coordinatesDelta.y) {
                scrollContainer.scrollTo({
                  left: newScrollCoordinates,
                  behavior: scrollBehavior
                });
                return;
              }
              if (canScrollToNewCoordinates) {
                scrollDelta.x = scrollContainer.scrollLeft - newScrollCoordinates;
              } else {
                scrollDelta.x = direction === KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;
              }
              if (scrollDelta.x) {
                scrollContainer.scrollBy({
                  left: -scrollDelta.x,
                  behavior: scrollBehavior
                });
              }
              break;
            } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {
              const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;
              const canScrollToNewCoordinates = direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y;
              if (canScrollToNewCoordinates && !coordinatesDelta.x) {
                scrollContainer.scrollTo({
                  top: newScrollCoordinates,
                  behavior: scrollBehavior
                });
                return;
              }
              if (canScrollToNewCoordinates) {
                scrollDelta.y = scrollContainer.scrollTop - newScrollCoordinates;
              } else {
                scrollDelta.y = direction === KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;
              }
              if (scrollDelta.y) {
                scrollContainer.scrollBy({
                  top: -scrollDelta.y,
                  behavior: scrollBehavior
                });
              }
              break;
            }
          }
          this.handleMove(event, add(subtract(newCoordinates, this.referenceCoordinates), scrollDelta));
        }
      }
    }
    handleMove(event, coordinates) {
      const {
        onMove
      } = this.props;
      event.preventDefault();
      onMove(coordinates);
    }
    handleEnd(event) {
      const {
        onEnd
      } = this.props;
      event.preventDefault();
      this.detach();
      onEnd();
    }
    handleCancel(event) {
      const {
        onCancel
      } = this.props;
      event.preventDefault();
      this.detach();
      onCancel();
    }
    detach() {
      this.listeners.removeAll();
      this.windowListeners.removeAll();
    }
  }
  KeyboardSensor.activators = [{
    eventName: "onKeyDown",
    handler: (event, _ref4, _ref22) => {
      let {
        keyboardCodes = defaultKeyboardCodes,
        onActivation
      } = _ref4;
      let {
        active
      } = _ref22;
      const {
        code
      } = event.nativeEvent;
      if (keyboardCodes.start.includes(code)) {
        const activator = active.activatorNode.current;
        if (activator && event.target !== activator) {
          return false;
        }
        event.preventDefault();
        onActivation == null ? void 0 : onActivation({
          event: event.nativeEvent
        });
        return true;
      }
      return false;
    }
  }];
  function isDistanceConstraint(constraint) {
    return Boolean(constraint && "distance" in constraint);
  }
  function isDelayConstraint(constraint) {
    return Boolean(constraint && "delay" in constraint);
  }
  class AbstractPointerSensor {
    constructor(props, events2, listenerTarget) {
      var _getEventCoordinates;
      if (listenerTarget === void 0) {
        listenerTarget = getEventListenerTarget(props.event.target);
      }
      this.props = void 0;
      this.events = void 0;
      this.autoScrollEnabled = true;
      this.document = void 0;
      this.activated = false;
      this.initialCoordinates = void 0;
      this.timeoutId = null;
      this.listeners = void 0;
      this.documentListeners = void 0;
      this.windowListeners = void 0;
      this.props = props;
      this.events = events2;
      const {
        event
      } = props;
      const {
        target
      } = event;
      this.props = props;
      this.events = events2;
      this.document = getOwnerDocument(target);
      this.documentListeners = new Listeners(this.document);
      this.listeners = new Listeners(listenerTarget);
      this.windowListeners = new Listeners(getWindow(target));
      this.initialCoordinates = (_getEventCoordinates = getEventCoordinates(event)) != null ? _getEventCoordinates : defaultCoordinates;
      this.handleStart = this.handleStart.bind(this);
      this.handleMove = this.handleMove.bind(this);
      this.handleEnd = this.handleEnd.bind(this);
      this.handleCancel = this.handleCancel.bind(this);
      this.handleKeydown = this.handleKeydown.bind(this);
      this.removeTextSelection = this.removeTextSelection.bind(this);
      this.attach();
    }
    attach() {
      const {
        events: events2,
        props: {
          options: {
            activationConstraint,
            bypassActivationConstraint
          }
        }
      } = this;
      this.listeners.add(events2.move.name, this.handleMove, {
        passive: false
      });
      this.listeners.add(events2.end.name, this.handleEnd);
      if (events2.cancel) {
        this.listeners.add(events2.cancel.name, this.handleCancel);
      }
      this.windowListeners.add(EventName.Resize, this.handleCancel);
      this.windowListeners.add(EventName.DragStart, preventDefault);
      this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
      this.windowListeners.add(EventName.ContextMenu, preventDefault);
      this.documentListeners.add(EventName.Keydown, this.handleKeydown);
      if (activationConstraint) {
        if (bypassActivationConstraint != null && bypassActivationConstraint({
          event: this.props.event,
          activeNode: this.props.activeNode,
          options: this.props.options
        })) {
          return this.handleStart();
        }
        if (isDelayConstraint(activationConstraint)) {
          this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);
          this.handlePending(activationConstraint);
          return;
        }
        if (isDistanceConstraint(activationConstraint)) {
          this.handlePending(activationConstraint);
          return;
        }
      }
      this.handleStart();
    }
    detach() {
      this.listeners.removeAll();
      this.windowListeners.removeAll();
      setTimeout(this.documentListeners.removeAll, 50);
      if (this.timeoutId !== null) {
        clearTimeout(this.timeoutId);
        this.timeoutId = null;
      }
    }
    handlePending(constraint, offset2) {
      const {
        active,
        onPending
      } = this.props;
      onPending(active, constraint, this.initialCoordinates, offset2);
    }
    handleStart() {
      const {
        initialCoordinates
      } = this;
      const {
        onStart
      } = this.props;
      if (initialCoordinates) {
        this.activated = true;
        this.documentListeners.add(EventName.Click, stopPropagation, {
          capture: true
        });
        this.removeTextSelection();
        this.documentListeners.add(EventName.SelectionChange, this.removeTextSelection);
        onStart(initialCoordinates);
      }
    }
    handleMove(event) {
      var _getEventCoordinates2;
      const {
        activated,
        initialCoordinates,
        props
      } = this;
      const {
        onMove,
        options: {
          activationConstraint
        }
      } = props;
      if (!initialCoordinates) {
        return;
      }
      const coordinates = (_getEventCoordinates2 = getEventCoordinates(event)) != null ? _getEventCoordinates2 : defaultCoordinates;
      const delta = subtract(initialCoordinates, coordinates);
      if (!activated && activationConstraint) {
        if (isDistanceConstraint(activationConstraint)) {
          if (activationConstraint.tolerance != null && hasExceededDistance(delta, activationConstraint.tolerance)) {
            return this.handleCancel();
          }
          if (hasExceededDistance(delta, activationConstraint.distance)) {
            return this.handleStart();
          }
        }
        if (isDelayConstraint(activationConstraint)) {
          if (hasExceededDistance(delta, activationConstraint.tolerance)) {
            return this.handleCancel();
          }
        }
        this.handlePending(activationConstraint, delta);
        return;
      }
      if (event.cancelable) {
        event.preventDefault();
      }
      onMove(coordinates);
    }
    handleEnd() {
      const {
        onAbort,
        onEnd
      } = this.props;
      this.detach();
      if (!this.activated) {
        onAbort(this.props.active);
      }
      onEnd();
    }
    handleCancel() {
      const {
        onAbort,
        onCancel
      } = this.props;
      this.detach();
      if (!this.activated) {
        onAbort(this.props.active);
      }
      onCancel();
    }
    handleKeydown(event) {
      if (event.code === KeyboardCode.Esc) {
        this.handleCancel();
      }
    }
    removeTextSelection() {
      var _this$document$getSel;
      (_this$document$getSel = this.document.getSelection()) == null ? void 0 : _this$document$getSel.removeAllRanges();
    }
  }
  const events = {
    cancel: {
      name: "pointercancel"
    },
    move: {
      name: "pointermove"
    },
    end: {
      name: "pointerup"
    }
  };
  class PointerSensor extends AbstractPointerSensor {
    constructor(props) {
      const {
        event
      } = props;
      const listenerTarget = getOwnerDocument(event.target);
      super(props, events, listenerTarget);
    }
  }
  PointerSensor.activators = [{
    eventName: "onPointerDown",
    handler: (_ref4, _ref22) => {
      let {
        nativeEvent: event
      } = _ref4;
      let {
        onActivation
      } = _ref22;
      if (!event.isPrimary || event.button !== 0) {
        return false;
      }
      onActivation == null ? void 0 : onActivation({
        event
      });
      return true;
    }
  }];
  const events$1 = {
    move: {
      name: "mousemove"
    },
    end: {
      name: "mouseup"
    }
  };
  var MouseButton;
  (function(MouseButton2) {
    MouseButton2[MouseButton2["RightClick"] = 2] = "RightClick";
  })(MouseButton || (MouseButton = {}));
  class MouseSensor extends AbstractPointerSensor {
    constructor(props) {
      super(props, events$1, getOwnerDocument(props.event.target));
    }
  }
  MouseSensor.activators = [{
    eventName: "onMouseDown",
    handler: (_ref4, _ref22) => {
      let {
        nativeEvent: event
      } = _ref4;
      let {
        onActivation
      } = _ref22;
      if (event.button === MouseButton.RightClick) {
        return false;
      }
      onActivation == null ? void 0 : onActivation({
        event
      });
      return true;
    }
  }];
  const events$2 = {
    cancel: {
      name: "touchcancel"
    },
    move: {
      name: "touchmove"
    },
    end: {
      name: "touchend"
    }
  };
  class TouchSensor extends AbstractPointerSensor {
    constructor(props) {
      super(props, events$2);
    }
    static setup() {
      window.addEventListener(events$2.move.name, noop2, {
        capture: false,
        passive: false
      });
      return function teardown() {
        window.removeEventListener(events$2.move.name, noop2);
      };
      function noop2() {
      }
    }
  }
  TouchSensor.activators = [{
    eventName: "onTouchStart",
    handler: (_ref4, _ref22) => {
      let {
        nativeEvent: event
      } = _ref4;
      let {
        onActivation
      } = _ref22;
      const {
        touches
      } = event;
      if (touches.length > 1) {
        return false;
      }
      onActivation == null ? void 0 : onActivation({
        event
      });
      return true;
    }
  }];
  var AutoScrollActivator;
  (function(AutoScrollActivator2) {
    AutoScrollActivator2[AutoScrollActivator2["Pointer"] = 0] = "Pointer";
    AutoScrollActivator2[AutoScrollActivator2["DraggableRect"] = 1] = "DraggableRect";
  })(AutoScrollActivator || (AutoScrollActivator = {}));
  var TraversalOrder;
  (function(TraversalOrder2) {
    TraversalOrder2[TraversalOrder2["TreeOrder"] = 0] = "TreeOrder";
    TraversalOrder2[TraversalOrder2["ReversedTreeOrder"] = 1] = "ReversedTreeOrder";
  })(TraversalOrder || (TraversalOrder = {}));
  function useAutoScroller(_ref4) {
    let {
      acceleration,
      activator = AutoScrollActivator.Pointer,
      canScroll,
      draggingRect,
      enabled: enabled2,
      interval = 5,
      order = TraversalOrder.TreeOrder,
      pointerCoordinates,
      scrollableAncestors,
      scrollableAncestorRects,
      delta,
      threshold
    } = _ref4;
    const scrollIntent = useScrollIntent({
      delta,
      disabled: !enabled2
    });
    const [setAutoScrollInterval, clearAutoScrollInterval] = useInterval();
    const scrollSpeed = reactExports.useRef({
      x: 0,
      y: 0
    });
    const scrollDirection = reactExports.useRef({
      x: 0,
      y: 0
    });
    const rect = reactExports.useMemo(() => {
      switch (activator) {
        case AutoScrollActivator.Pointer:
          return pointerCoordinates ? {
            top: pointerCoordinates.y,
            bottom: pointerCoordinates.y,
            left: pointerCoordinates.x,
            right: pointerCoordinates.x
          } : null;
        case AutoScrollActivator.DraggableRect:
          return draggingRect;
      }
    }, [activator, draggingRect, pointerCoordinates]);
    const scrollContainerRef = reactExports.useRef(null);
    const autoScroll = reactExports.useCallback(() => {
      const scrollContainer = scrollContainerRef.current;
      if (!scrollContainer) {
        return;
      }
      const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;
      const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;
      scrollContainer.scrollBy(scrollLeft, scrollTop);
    }, []);
    const sortedScrollableAncestors = reactExports.useMemo(() => order === TraversalOrder.TreeOrder ? [...scrollableAncestors].reverse() : scrollableAncestors, [order, scrollableAncestors]);
    reactExports.useEffect(
      () => {
        if (!enabled2 || !scrollableAncestors.length || !rect) {
          clearAutoScrollInterval();
          return;
        }
        for (const scrollContainer of sortedScrollableAncestors) {
          if ((canScroll == null ? void 0 : canScroll(scrollContainer)) === false) {
            continue;
          }
          const index = scrollableAncestors.indexOf(scrollContainer);
          const scrollContainerRect = scrollableAncestorRects[index];
          if (!scrollContainerRect) {
            continue;
          }
          const {
            direction,
            speed
          } = getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, rect, acceleration, threshold);
          for (const axis of ["x", "y"]) {
            if (!scrollIntent[axis][direction[axis]]) {
              speed[axis] = 0;
              direction[axis] = 0;
            }
          }
          if (speed.x > 0 || speed.y > 0) {
            clearAutoScrollInterval();
            scrollContainerRef.current = scrollContainer;
            setAutoScrollInterval(autoScroll, interval);
            scrollSpeed.current = speed;
            scrollDirection.current = direction;
            return;
          }
        }
        scrollSpeed.current = {
          x: 0,
          y: 0
        };
        scrollDirection.current = {
          x: 0,
          y: 0
        };
        clearAutoScrollInterval();
      },
[
        acceleration,
        autoScroll,
        canScroll,
        clearAutoScrollInterval,
        enabled2,
        interval,
JSON.stringify(rect),
JSON.stringify(scrollIntent),
        setAutoScrollInterval,
        scrollableAncestors,
        sortedScrollableAncestors,
        scrollableAncestorRects,
JSON.stringify(threshold)
      ]
    );
  }
  const defaultScrollIntent = {
    x: {
      [Direction.Backward]: false,
      [Direction.Forward]: false
    },
    y: {
      [Direction.Backward]: false,
      [Direction.Forward]: false
    }
  };
  function useScrollIntent(_ref22) {
    let {
      delta,
      disabled
    } = _ref22;
    const previousDelta = usePrevious(delta);
    return useLazyMemo((previousIntent) => {
      if (disabled || !previousDelta || !previousIntent) {
        return defaultScrollIntent;
      }
      const direction = {
        x: Math.sign(delta.x - previousDelta.x),
        y: Math.sign(delta.y - previousDelta.y)
      };
      return {
        x: {
          [Direction.Backward]: previousIntent.x[Direction.Backward] || direction.x === -1,
          [Direction.Forward]: previousIntent.x[Direction.Forward] || direction.x === 1
        },
        y: {
          [Direction.Backward]: previousIntent.y[Direction.Backward] || direction.y === -1,
          [Direction.Forward]: previousIntent.y[Direction.Forward] || direction.y === 1
        }
      };
    }, [disabled, delta, previousDelta]);
  }
  function useCachedNode(draggableNodes, id2) {
    const draggableNode = id2 != null ? draggableNodes.get(id2) : void 0;
    const node2 = draggableNode ? draggableNode.node.current : null;
    return useLazyMemo((cachedNode) => {
      var _ref4;
      if (id2 == null) {
        return null;
      }
      return (_ref4 = node2 != null ? node2 : cachedNode) != null ? _ref4 : null;
    }, [node2, id2]);
  }
  function useCombineActivators(sensors, getSyntheticHandler) {
    return reactExports.useMemo(() => sensors.reduce((accumulator, sensor) => {
      const {
        sensor: Sensor
      } = sensor;
      const sensorActivators = Sensor.activators.map((activator) => ({
        eventName: activator.eventName,
        handler: getSyntheticHandler(activator.handler, sensor)
      }));
      return [...accumulator, ...sensorActivators];
    }, []), [sensors, getSyntheticHandler]);
  }
  var MeasuringStrategy;
  (function(MeasuringStrategy2) {
    MeasuringStrategy2[MeasuringStrategy2["Always"] = 0] = "Always";
    MeasuringStrategy2[MeasuringStrategy2["BeforeDragging"] = 1] = "BeforeDragging";
    MeasuringStrategy2[MeasuringStrategy2["WhileDragging"] = 2] = "WhileDragging";
  })(MeasuringStrategy || (MeasuringStrategy = {}));
  var MeasuringFrequency;
  (function(MeasuringFrequency2) {
    MeasuringFrequency2["Optimized"] = "optimized";
  })(MeasuringFrequency || (MeasuringFrequency = {}));
  const defaultValue = new Map();
  function useDroppableMeasuring(containers, _ref4) {
    let {
      dragging,
      dependencies,
      config
    } = _ref4;
    const [queue, setQueue] = reactExports.useState(null);
    const {
      frequency,
      measure,
      strategy
    } = config;
    const containersRef = reactExports.useRef(containers);
    const disabled = isDisabled();
    const disabledRef = useLatestValue(disabled);
    const measureDroppableContainers = reactExports.useCallback(function(ids2) {
      if (ids2 === void 0) {
        ids2 = [];
      }
      if (disabledRef.current) {
        return;
      }
      setQueue((value) => {
        if (value === null) {
          return ids2;
        }
        return value.concat(ids2.filter((id2) => !value.includes(id2)));
      });
    }, [disabledRef]);
    const timeoutId = reactExports.useRef(null);
    const droppableRects = useLazyMemo((previousValue) => {
      if (disabled && !dragging) {
        return defaultValue;
      }
      if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || queue != null) {
        const map = new Map();
        for (let container of containers) {
          if (!container) {
            continue;
          }
          if (queue && queue.length > 0 && !queue.includes(container.id) && container.rect.current) {
            map.set(container.id, container.rect.current);
            continue;
          }
          const node2 = container.node.current;
          const rect = node2 ? new Rect(measure(node2), node2) : null;
          container.rect.current = rect;
          if (rect) {
            map.set(container.id, rect);
          }
        }
        return map;
      }
      return previousValue;
    }, [containers, queue, dragging, disabled, measure]);
    reactExports.useEffect(() => {
      containersRef.current = containers;
    }, [containers]);
    reactExports.useEffect(
      () => {
        if (disabled) {
          return;
        }
        measureDroppableContainers();
      },
[dragging, disabled]
    );
    reactExports.useEffect(
      () => {
        if (queue && queue.length > 0) {
          setQueue(null);
        }
      },
[JSON.stringify(queue)]
    );
    reactExports.useEffect(
      () => {
        if (disabled || typeof frequency !== "number" || timeoutId.current !== null) {
          return;
        }
        timeoutId.current = setTimeout(() => {
          measureDroppableContainers();
          timeoutId.current = null;
        }, frequency);
      },
[frequency, disabled, measureDroppableContainers, ...dependencies]
    );
    return {
      droppableRects,
      measureDroppableContainers,
      measuringScheduled: queue != null
    };
    function isDisabled() {
      switch (strategy) {
        case MeasuringStrategy.Always:
          return false;
        case MeasuringStrategy.BeforeDragging:
          return dragging;
        default:
          return !dragging;
      }
    }
  }
  function useInitialValue(value, computeFn) {
    return useLazyMemo((previousValue) => {
      if (!value) {
        return null;
      }
      if (previousValue) {
        return previousValue;
      }
      return typeof computeFn === "function" ? computeFn(value) : value;
    }, [computeFn, value]);
  }
  function useInitialRect(node2, measure) {
    return useInitialValue(node2, measure);
  }
  function useMutationObserver(_ref4) {
    let {
      callback,
      disabled
    } = _ref4;
    const handleMutations = useEvent(callback);
    const mutationObserver = reactExports.useMemo(() => {
      if (disabled || typeof window === "undefined" || typeof window.MutationObserver === "undefined") {
        return void 0;
      }
      const {
        MutationObserver: MutationObserver2
      } = window;
      return new MutationObserver2(handleMutations);
    }, [handleMutations, disabled]);
    reactExports.useEffect(() => {
      return () => mutationObserver == null ? void 0 : mutationObserver.disconnect();
    }, [mutationObserver]);
    return mutationObserver;
  }
  function useResizeObserver(_ref4) {
    let {
      callback,
      disabled
    } = _ref4;
    const handleResize = useEvent(callback);
    const resizeObserver = reactExports.useMemo(
      () => {
        if (disabled || typeof window === "undefined" || typeof window.ResizeObserver === "undefined") {
          return void 0;
        }
        const {
          ResizeObserver: ResizeObserver2
        } = window;
        return new ResizeObserver2(handleResize);
      },
[disabled]
    );
    reactExports.useEffect(() => {
      return () => resizeObserver == null ? void 0 : resizeObserver.disconnect();
    }, [resizeObserver]);
    return resizeObserver;
  }
  function defaultMeasure(element) {
    return new Rect(getClientRect(element), element);
  }
  function useRect(element, measure, fallbackRect) {
    if (measure === void 0) {
      measure = defaultMeasure;
    }
    const [rect, setRect] = reactExports.useState(null);
    function measureRect() {
      setRect((currentRect) => {
        if (!element) {
          return null;
        }
        if (element.isConnected === false) {
          var _ref4;
          return (_ref4 = currentRect != null ? currentRect : fallbackRect) != null ? _ref4 : null;
        }
        const newRect = measure(element);
        if (JSON.stringify(currentRect) === JSON.stringify(newRect)) {
          return currentRect;
        }
        return newRect;
      });
    }
    const mutationObserver = useMutationObserver({
      callback(records) {
        if (!element) {
          return;
        }
        for (const record of records) {
          const {
            type: type4,
            target
          } = record;
          if (type4 === "childList" && target instanceof HTMLElement && target.contains(element)) {
            measureRect();
            break;
          }
        }
      }
    });
    const resizeObserver = useResizeObserver({
      callback: measureRect
    });
    useIsomorphicLayoutEffect(() => {
      measureRect();
      if (element) {
        resizeObserver == null ? void 0 : resizeObserver.observe(element);
        mutationObserver == null ? void 0 : mutationObserver.observe(document.body, {
          childList: true,
          subtree: true
        });
      } else {
        resizeObserver == null ? void 0 : resizeObserver.disconnect();
        mutationObserver == null ? void 0 : mutationObserver.disconnect();
      }
    }, [element]);
    return rect;
  }
  function useRectDelta(rect) {
    const initialRect = useInitialValue(rect);
    return getRectDelta(rect, initialRect);
  }
  const defaultValue$1 = [];
  function useScrollableAncestors(node2) {
    const previousNode = reactExports.useRef(node2);
    const ancestors = useLazyMemo((previousValue) => {
      if (!node2) {
        return defaultValue$1;
      }
      if (previousValue && previousValue !== defaultValue$1 && node2 && previousNode.current && node2.parentNode === previousNode.current.parentNode) {
        return previousValue;
      }
      return getScrollableAncestors(node2);
    }, [node2]);
    reactExports.useEffect(() => {
      previousNode.current = node2;
    }, [node2]);
    return ancestors;
  }
  function useScrollOffsets(elements) {
    const [scrollCoordinates, setScrollCoordinates] = reactExports.useState(null);
    const prevElements = reactExports.useRef(elements);
    const handleScroll = reactExports.useCallback((event) => {
      const scrollingElement = getScrollableElement(event.target);
      if (!scrollingElement) {
        return;
      }
      setScrollCoordinates((scrollCoordinates2) => {
        if (!scrollCoordinates2) {
          return null;
        }
        scrollCoordinates2.set(scrollingElement, getScrollCoordinates(scrollingElement));
        return new Map(scrollCoordinates2);
      });
    }, []);
    reactExports.useEffect(() => {
      const previousElements = prevElements.current;
      if (elements !== previousElements) {
        cleanup2(previousElements);
        const entries = elements.map((element) => {
          const scrollableElement = getScrollableElement(element);
          if (scrollableElement) {
            scrollableElement.addEventListener("scroll", handleScroll, {
              passive: true
            });
            return [scrollableElement, getScrollCoordinates(scrollableElement)];
          }
          return null;
        }).filter((entry) => entry != null);
        setScrollCoordinates(entries.length ? new Map(entries) : null);
        prevElements.current = elements;
      }
      return () => {
        cleanup2(elements);
        cleanup2(previousElements);
      };
      function cleanup2(elements2) {
        elements2.forEach((element) => {
          const scrollableElement = getScrollableElement(element);
          scrollableElement == null ? void 0 : scrollableElement.removeEventListener("scroll", handleScroll);
        });
      }
    }, [handleScroll, elements]);
    return reactExports.useMemo(() => {
      if (elements.length) {
        return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates) => add(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);
      }
      return defaultCoordinates;
    }, [elements, scrollCoordinates]);
  }
  function useScrollOffsetsDelta(scrollOffsets, dependencies) {
    if (dependencies === void 0) {
      dependencies = [];
    }
    const initialScrollOffsets = reactExports.useRef(null);
    reactExports.useEffect(
      () => {
        initialScrollOffsets.current = null;
      },
dependencies
    );
    reactExports.useEffect(() => {
      const hasScrollOffsets = scrollOffsets !== defaultCoordinates;
      if (hasScrollOffsets && !initialScrollOffsets.current) {
        initialScrollOffsets.current = scrollOffsets;
      }
      if (!hasScrollOffsets && initialScrollOffsets.current) {
        initialScrollOffsets.current = null;
      }
    }, [scrollOffsets]);
    return initialScrollOffsets.current ? subtract(scrollOffsets, initialScrollOffsets.current) : defaultCoordinates;
  }
  function useSensorSetup(sensors) {
    reactExports.useEffect(
      () => {
        if (!canUseDOM) {
          return;
        }
        const teardownFns = sensors.map((_ref4) => {
          let {
            sensor
          } = _ref4;
          return sensor.setup == null ? void 0 : sensor.setup();
        });
        return () => {
          for (const teardown of teardownFns) {
            teardown == null ? void 0 : teardown();
          }
        };
      },

sensors.map((_ref22) => {
        let {
          sensor
        } = _ref22;
        return sensor;
      })
    );
  }
  function useSyntheticListeners(listeners2, id2) {
    return reactExports.useMemo(() => {
      return listeners2.reduce((acc, _ref4) => {
        let {
          eventName,
          handler
        } = _ref4;
        acc[eventName] = (event) => {
          handler(event, id2);
        };
        return acc;
      }, {});
    }, [listeners2, id2]);
  }
  function useWindowRect(element) {
    return reactExports.useMemo(() => element ? getWindowClientRect(element) : null, [element]);
  }
  const defaultValue$2 = [];
  function useRects(elements, measure) {
    if (measure === void 0) {
      measure = getClientRect;
    }
    const [firstElement] = elements;
    const windowRect = useWindowRect(firstElement ? getWindow(firstElement) : null);
    const [rects, setRects] = reactExports.useState(defaultValue$2);
    function measureRects() {
      setRects(() => {
        if (!elements.length) {
          return defaultValue$2;
        }
        return elements.map((element) => isDocumentScrollingElement(element) ? windowRect : new Rect(measure(element), element));
      });
    }
    const resizeObserver = useResizeObserver({
      callback: measureRects
    });
    useIsomorphicLayoutEffect(() => {
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
      measureRects();
      elements.forEach((element) => resizeObserver == null ? void 0 : resizeObserver.observe(element));
    }, [elements]);
    return rects;
  }
  function getMeasurableNode(node2) {
    if (!node2) {
      return null;
    }
    if (node2.children.length > 1) {
      return node2;
    }
    const firstChild = node2.children[0];
    return isHTMLElement(firstChild) ? firstChild : node2;
  }
  function useDragOverlayMeasuring(_ref4) {
    let {
      measure
    } = _ref4;
    const [rect, setRect] = reactExports.useState(null);
    const handleResize = reactExports.useCallback((entries) => {
      for (const {
        target
      } of entries) {
        if (isHTMLElement(target)) {
          setRect((rect2) => {
            const newRect = measure(target);
            return rect2 ? {
              ...rect2,
              width: newRect.width,
              height: newRect.height
            } : newRect;
          });
          break;
        }
      }
    }, [measure]);
    const resizeObserver = useResizeObserver({
      callback: handleResize
    });
    const handleNodeChange = reactExports.useCallback((element) => {
      const node2 = getMeasurableNode(element);
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
      if (node2) {
        resizeObserver == null ? void 0 : resizeObserver.observe(node2);
      }
      setRect(node2 ? measure(node2) : null);
    }, [measure, resizeObserver]);
    const [nodeRef, setRef2] = useNodeRef(handleNodeChange);
    return reactExports.useMemo(() => ({
      nodeRef,
      rect,
      setRef: setRef2
    }), [rect, nodeRef, setRef2]);
  }
  const defaultSensors = [{
    sensor: PointerSensor,
    options: {}
  }, {
    sensor: KeyboardSensor,
    options: {}
  }];
  const defaultData = {
    current: {}
  };
  const defaultMeasuringConfiguration = {
    draggable: {
      measure: getTransformAgnosticClientRect
    },
    droppable: {
      measure: getTransformAgnosticClientRect,
      strategy: MeasuringStrategy.WhileDragging,
      frequency: MeasuringFrequency.Optimized
    },
    dragOverlay: {
      measure: getClientRect
    }
  };
  class DroppableContainersMap extends Map {
    get(id2) {
      var _super$get;
      return id2 != null ? (_super$get = super.get(id2)) != null ? _super$get : void 0 : void 0;
    }
    toArray() {
      return Array.from(this.values());
    }
    getEnabled() {
      return this.toArray().filter((_ref4) => {
        let {
          disabled
        } = _ref4;
        return !disabled;
      });
    }
    getNodeFor(id2) {
      var _this$get$node$curren, _this$get;
      return (_this$get$node$curren = (_this$get = this.get(id2)) == null ? void 0 : _this$get.node.current) != null ? _this$get$node$curren : void 0;
    }
  }
  const defaultPublicContext = {
    activatorEvent: null,
    active: null,
    activeNode: null,
    activeNodeRect: null,
    collisions: null,
    containerNodeRect: null,
    draggableNodes: new Map(),
    droppableRects: new Map(),
    droppableContainers: new DroppableContainersMap(),
    over: null,
    dragOverlay: {
      nodeRef: {
        current: null
      },
      rect: null,
      setRef: noop
    },
    scrollableAncestors: [],
    scrollableAncestorRects: [],
    measuringConfiguration: defaultMeasuringConfiguration,
    measureDroppableContainers: noop,
    windowRect: null,
    measuringScheduled: false
  };
  const defaultInternalContext = {
    activatorEvent: null,
    activators: [],
    active: null,
    activeNodeRect: null,
    ariaDescribedById: {
      draggable: ""
    },
    dispatch: noop,
    draggableNodes: new Map(),
    over: null,
    measureDroppableContainers: noop
  };
  const InternalContext = reactExports.createContext(defaultInternalContext);
  const PublicContext = reactExports.createContext(defaultPublicContext);
  function getInitialState() {
    return {
      draggable: {
        active: null,
        initialCoordinates: {
          x: 0,
          y: 0
        },
        nodes: new Map(),
        translate: {
          x: 0,
          y: 0
        }
      },
      droppable: {
        containers: new DroppableContainersMap()
      }
    };
  }
  function reducer(state2, action2) {
    switch (action2.type) {
      case Action.DragStart:
        return {
          ...state2,
          draggable: {
            ...state2.draggable,
            initialCoordinates: action2.initialCoordinates,
            active: action2.active
          }
        };
      case Action.DragMove:
        if (state2.draggable.active == null) {
          return state2;
        }
        return {
          ...state2,
          draggable: {
            ...state2.draggable,
            translate: {
              x: action2.coordinates.x - state2.draggable.initialCoordinates.x,
              y: action2.coordinates.y - state2.draggable.initialCoordinates.y
            }
          }
        };
      case Action.DragEnd:
      case Action.DragCancel:
        return {
          ...state2,
          draggable: {
            ...state2.draggable,
            active: null,
            initialCoordinates: {
              x: 0,
              y: 0
            },
            translate: {
              x: 0,
              y: 0
            }
          }
        };
      case Action.RegisterDroppable: {
        const {
          element
        } = action2;
        const {
          id: id2
        } = element;
        const containers = new DroppableContainersMap(state2.droppable.containers);
        containers.set(id2, element);
        return {
          ...state2,
          droppable: {
            ...state2.droppable,
            containers
          }
        };
      }
      case Action.SetDroppableDisabled: {
        const {
          id: id2,
          key,
          disabled
        } = action2;
        const element = state2.droppable.containers.get(id2);
        if (!element || key !== element.key) {
          return state2;
        }
        const containers = new DroppableContainersMap(state2.droppable.containers);
        containers.set(id2, {
          ...element,
          disabled
        });
        return {
          ...state2,
          droppable: {
            ...state2.droppable,
            containers
          }
        };
      }
      case Action.UnregisterDroppable: {
        const {
          id: id2,
          key
        } = action2;
        const element = state2.droppable.containers.get(id2);
        if (!element || key !== element.key) {
          return state2;
        }
        const containers = new DroppableContainersMap(state2.droppable.containers);
        containers.delete(id2);
        return {
          ...state2,
          droppable: {
            ...state2.droppable,
            containers
          }
        };
      }
      default: {
        return state2;
      }
    }
  }
  function RestoreFocus(_ref4) {
    let {
      disabled
    } = _ref4;
    const {
      active,
      activatorEvent,
      draggableNodes
    } = reactExports.useContext(InternalContext);
    const previousActivatorEvent = usePrevious(activatorEvent);
    const previousActiveId = usePrevious(active == null ? void 0 : active.id);
    reactExports.useEffect(() => {
      if (disabled) {
        return;
      }
      if (!activatorEvent && previousActivatorEvent && previousActiveId != null) {
        if (!isKeyboardEvent(previousActivatorEvent)) {
          return;
        }
        if (document.activeElement === previousActivatorEvent.target) {
          return;
        }
        const draggableNode = draggableNodes.get(previousActiveId);
        if (!draggableNode) {
          return;
        }
        const {
          activatorNode,
          node: node2
        } = draggableNode;
        if (!activatorNode.current && !node2.current) {
          return;
        }
        requestAnimationFrame(() => {
          for (const element of [activatorNode.current, node2.current]) {
            if (!element) {
              continue;
            }
            const focusableNode = findFirstFocusableNode(element);
            if (focusableNode) {
              focusableNode.focus();
              break;
            }
          }
        });
      }
    }, [activatorEvent, disabled, draggableNodes, previousActiveId, previousActivatorEvent]);
    return null;
  }
  function applyModifiers(modifiers, _ref4) {
    let {
      transform,
      ...args
    } = _ref4;
    return modifiers != null && modifiers.length ? modifiers.reduce((accumulator, modifier) => {
      return modifier({
        transform: accumulator,
        ...args
      });
    }, transform) : transform;
  }
  function useMeasuringConfiguration(config) {
    return reactExports.useMemo(
      () => ({
        draggable: {
          ...defaultMeasuringConfiguration.draggable,
          ...config == null ? void 0 : config.draggable
        },
        droppable: {
          ...defaultMeasuringConfiguration.droppable,
          ...config == null ? void 0 : config.droppable
        },
        dragOverlay: {
          ...defaultMeasuringConfiguration.dragOverlay,
          ...config == null ? void 0 : config.dragOverlay
        }
      }),
[config == null ? void 0 : config.draggable, config == null ? void 0 : config.droppable, config == null ? void 0 : config.dragOverlay]
    );
  }
  function useLayoutShiftScrollCompensation(_ref4) {
    let {
      activeNode,
      measure,
      initialRect,
      config = true
    } = _ref4;
    const initialized = reactExports.useRef(false);
    const {
      x,
      y
    } = typeof config === "boolean" ? {
      x: config,
      y: config
    } : config;
    useIsomorphicLayoutEffect(() => {
      const disabled = !x && !y;
      if (disabled || !activeNode) {
        initialized.current = false;
        return;
      }
      if (initialized.current || !initialRect) {
        return;
      }
      const node2 = activeNode == null ? void 0 : activeNode.node.current;
      if (!node2 || node2.isConnected === false) {
        return;
      }
      const rect = measure(node2);
      const rectDelta = getRectDelta(rect, initialRect);
      if (!x) {
        rectDelta.x = 0;
      }
      if (!y) {
        rectDelta.y = 0;
      }
      initialized.current = true;
      if (Math.abs(rectDelta.x) > 0 || Math.abs(rectDelta.y) > 0) {
        const firstScrollableAncestor = getFirstScrollableAncestor(node2);
        if (firstScrollableAncestor) {
          firstScrollableAncestor.scrollBy({
            top: rectDelta.y,
            left: rectDelta.x
          });
        }
      }
    }, [activeNode, x, y, initialRect, measure]);
  }
  const ActiveDraggableContext = reactExports.createContext({
    ...defaultCoordinates,
    scaleX: 1,
    scaleY: 1
  });
  var Status;
  (function(Status2) {
    Status2[Status2["Uninitialized"] = 0] = "Uninitialized";
    Status2[Status2["Initializing"] = 1] = "Initializing";
    Status2[Status2["Initialized"] = 2] = "Initialized";
  })(Status || (Status = {}));
  const DndContext = reactExports.memo(function DndContext2(_ref4) {
    var _sensorContext$curren, _dragOverlay$nodeRef$, _dragOverlay$rect, _over$rect;
    let {
      id: id2,
      accessibility,
      autoScroll = true,
      children,
      sensors = defaultSensors,
      collisionDetection = rectIntersection,
      measuring,
      modifiers,
      ...props
    } = _ref4;
    const store2 = reactExports.useReducer(reducer, void 0, getInitialState);
    const [state2, dispatch] = store2;
    const [dispatchMonitorEvent, registerMonitorListener] = useDndMonitorProvider();
    const [status, setStatus] = reactExports.useState(Status.Uninitialized);
    const isInitialized2 = status === Status.Initialized;
    const {
      draggable: {
        active: activeId,
        nodes: draggableNodes,
        translate
      },
      droppable: {
        containers: droppableContainers
      }
    } = state2;
    const node2 = activeId != null ? draggableNodes.get(activeId) : null;
    const activeRects = reactExports.useRef({
      initial: null,
      translated: null
    });
    const active = reactExports.useMemo(() => {
      var _node$data;
      return activeId != null ? {
        id: activeId,
data: (_node$data = node2 == null ? void 0 : node2.data) != null ? _node$data : defaultData,
        rect: activeRects
      } : null;
    }, [activeId, node2]);
    const activeRef = reactExports.useRef(null);
    const [activeSensor, setActiveSensor] = reactExports.useState(null);
    const [activatorEvent, setActivatorEvent] = reactExports.useState(null);
    const latestProps = useLatestValue(props, Object.values(props));
    const draggableDescribedById = useUniqueId("DndDescribedBy", id2);
    const enabledDroppableContainers = reactExports.useMemo(() => droppableContainers.getEnabled(), [droppableContainers]);
    const measuringConfiguration = useMeasuringConfiguration(measuring);
    const {
      droppableRects,
      measureDroppableContainers,
      measuringScheduled
    } = useDroppableMeasuring(enabledDroppableContainers, {
      dragging: isInitialized2,
      dependencies: [translate.x, translate.y],
      config: measuringConfiguration.droppable
    });
    const activeNode = useCachedNode(draggableNodes, activeId);
    const activationCoordinates = reactExports.useMemo(() => activatorEvent ? getEventCoordinates(activatorEvent) : null, [activatorEvent]);
    const autoScrollOptions = getAutoScrollerOptions();
    const initialActiveNodeRect = useInitialRect(activeNode, measuringConfiguration.draggable.measure);
    useLayoutShiftScrollCompensation({
      activeNode: activeId != null ? draggableNodes.get(activeId) : null,
      config: autoScrollOptions.layoutShiftCompensation,
      initialRect: initialActiveNodeRect,
      measure: measuringConfiguration.draggable.measure
    });
    const activeNodeRect = useRect(activeNode, measuringConfiguration.draggable.measure, initialActiveNodeRect);
    const containerNodeRect = useRect(activeNode ? activeNode.parentElement : null);
    const sensorContext = reactExports.useRef({
      activatorEvent: null,
      active: null,
      activeNode,
      collisionRect: null,
      collisions: null,
      droppableRects,
      draggableNodes,
      draggingNode: null,
      draggingNodeRect: null,
      droppableContainers,
      over: null,
      scrollableAncestors: [],
      scrollAdjustedTranslate: null
    });
    const overNode = droppableContainers.getNodeFor((_sensorContext$curren = sensorContext.current.over) == null ? void 0 : _sensorContext$curren.id);
    const dragOverlay = useDragOverlayMeasuring({
      measure: measuringConfiguration.dragOverlay.measure
    });
    const draggingNode = (_dragOverlay$nodeRef$ = dragOverlay.nodeRef.current) != null ? _dragOverlay$nodeRef$ : activeNode;
    const draggingNodeRect = isInitialized2 ? (_dragOverlay$rect = dragOverlay.rect) != null ? _dragOverlay$rect : activeNodeRect : null;
    const usesDragOverlay = Boolean(dragOverlay.nodeRef.current && dragOverlay.rect);
    const nodeRectDelta = useRectDelta(usesDragOverlay ? null : activeNodeRect);
    const windowRect = useWindowRect(draggingNode ? getWindow(draggingNode) : null);
    const scrollableAncestors = useScrollableAncestors(isInitialized2 ? overNode != null ? overNode : activeNode : null);
    const scrollableAncestorRects = useRects(scrollableAncestors);
    const modifiedTranslate = applyModifiers(modifiers, {
      transform: {
        x: translate.x - nodeRectDelta.x,
        y: translate.y - nodeRectDelta.y,
        scaleX: 1,
        scaleY: 1
      },
      activatorEvent,
      active,
      activeNodeRect,
      containerNodeRect,
      draggingNodeRect,
      over: sensorContext.current.over,
      overlayNodeRect: dragOverlay.rect,
      scrollableAncestors,
      scrollableAncestorRects,
      windowRect
    });
    const pointerCoordinates = activationCoordinates ? add(activationCoordinates, translate) : null;
    const scrollOffsets = useScrollOffsets(scrollableAncestors);
    const scrollAdjustment = useScrollOffsetsDelta(scrollOffsets);
    const activeNodeScrollDelta = useScrollOffsetsDelta(scrollOffsets, [activeNodeRect]);
    const scrollAdjustedTranslate = add(modifiedTranslate, scrollAdjustment);
    const collisionRect = draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null;
    const collisions = active && collisionRect ? collisionDetection({
      active,
      collisionRect,
      droppableRects,
      droppableContainers: enabledDroppableContainers,
      pointerCoordinates
    }) : null;
    const overId = getFirstCollision(collisions, "id");
    const [over, setOver] = reactExports.useState(null);
    const appliedTranslate = usesDragOverlay ? modifiedTranslate : add(modifiedTranslate, activeNodeScrollDelta);
    const transform = adjustScale(appliedTranslate, (_over$rect = over == null ? void 0 : over.rect) != null ? _over$rect : null, activeNodeRect);
    const activeSensorRef = reactExports.useRef(null);
    const instantiateSensor = reactExports.useCallback(
      (event, _ref22) => {
        let {
          sensor: Sensor,
          options
        } = _ref22;
        if (activeRef.current == null) {
          return;
        }
        const activeNode2 = draggableNodes.get(activeRef.current);
        if (!activeNode2) {
          return;
        }
        const activatorEvent2 = event.nativeEvent;
        const sensorInstance = new Sensor({
          active: activeRef.current,
          activeNode: activeNode2,
          event: activatorEvent2,
          options,

context: sensorContext,
          onAbort(id3) {
            const draggableNode = draggableNodes.get(id3);
            if (!draggableNode) {
              return;
            }
            const {
              onDragAbort
            } = latestProps.current;
            const event2 = {
              id: id3
            };
            onDragAbort == null ? void 0 : onDragAbort(event2);
            dispatchMonitorEvent({
              type: "onDragAbort",
              event: event2
            });
          },
          onPending(id3, constraint, initialCoordinates, offset2) {
            const draggableNode = draggableNodes.get(id3);
            if (!draggableNode) {
              return;
            }
            const {
              onDragPending
            } = latestProps.current;
            const event2 = {
              id: id3,
              constraint,
              initialCoordinates,
              offset: offset2
            };
            onDragPending == null ? void 0 : onDragPending(event2);
            dispatchMonitorEvent({
              type: "onDragPending",
              event: event2
            });
          },
          onStart(initialCoordinates) {
            const id3 = activeRef.current;
            if (id3 == null) {
              return;
            }
            const draggableNode = draggableNodes.get(id3);
            if (!draggableNode) {
              return;
            }
            const {
              onDragStart
            } = latestProps.current;
            const event2 = {
              activatorEvent: activatorEvent2,
              active: {
                id: id3,
                data: draggableNode.data,
                rect: activeRects
              }
            };
            reactDomExports.unstable_batchedUpdates(() => {
              onDragStart == null ? void 0 : onDragStart(event2);
              setStatus(Status.Initializing);
              dispatch({
                type: Action.DragStart,
                initialCoordinates,
                active: id3
              });
              dispatchMonitorEvent({
                type: "onDragStart",
                event: event2
              });
              setActiveSensor(activeSensorRef.current);
              setActivatorEvent(activatorEvent2);
            });
          },
          onMove(coordinates) {
            dispatch({
              type: Action.DragMove,
              coordinates
            });
          },
          onEnd: createHandler2(Action.DragEnd),
          onCancel: createHandler2(Action.DragCancel)
        });
        activeSensorRef.current = sensorInstance;
        function createHandler2(type4) {
          return async function handler() {
            const {
              active: active2,
              collisions: collisions2,
              over: over2,
              scrollAdjustedTranslate: scrollAdjustedTranslate2
            } = sensorContext.current;
            let event2 = null;
            if (active2 && scrollAdjustedTranslate2) {
              const {
                cancelDrop
              } = latestProps.current;
              event2 = {
                activatorEvent: activatorEvent2,
                active: active2,
                collisions: collisions2,
                delta: scrollAdjustedTranslate2,
                over: over2
              };
              if (type4 === Action.DragEnd && typeof cancelDrop === "function") {
                const shouldCancel = await Promise.resolve(cancelDrop(event2));
                if (shouldCancel) {
                  type4 = Action.DragCancel;
                }
              }
            }
            activeRef.current = null;
            reactDomExports.unstable_batchedUpdates(() => {
              dispatch({
                type: type4
              });
              setStatus(Status.Uninitialized);
              setOver(null);
              setActiveSensor(null);
              setActivatorEvent(null);
              activeSensorRef.current = null;
              const eventName = type4 === Action.DragEnd ? "onDragEnd" : "onDragCancel";
              if (event2) {
                const handler2 = latestProps.current[eventName];
                handler2 == null ? void 0 : handler2(event2);
                dispatchMonitorEvent({
                  type: eventName,
                  event: event2
                });
              }
            });
          };
        }
      },
[draggableNodes]
    );
    const bindActivatorToSensorInstantiator = reactExports.useCallback((handler, sensor) => {
      return (event, active2) => {
        const nativeEvent = event.nativeEvent;
        const activeDraggableNode = draggableNodes.get(active2);
        if (
activeRef.current !== null ||
!activeDraggableNode ||
nativeEvent.dndKit || nativeEvent.defaultPrevented
        ) {
          return;
        }
        const activationContext = {
          active: activeDraggableNode
        };
        const shouldActivate = handler(event, sensor.options, activationContext);
        if (shouldActivate === true) {
          nativeEvent.dndKit = {
            capturedBy: sensor.sensor
          };
          activeRef.current = active2;
          instantiateSensor(event, sensor);
        }
      };
    }, [draggableNodes, instantiateSensor]);
    const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);
    useSensorSetup(sensors);
    useIsomorphicLayoutEffect(() => {
      if (activeNodeRect && status === Status.Initializing) {
        setStatus(Status.Initialized);
      }
    }, [activeNodeRect, status]);
    reactExports.useEffect(
      () => {
        const {
          onDragMove
        } = latestProps.current;
        const {
          active: active2,
          activatorEvent: activatorEvent2,
          collisions: collisions2,
          over: over2
        } = sensorContext.current;
        if (!active2 || !activatorEvent2) {
          return;
        }
        const event = {
          active: active2,
          activatorEvent: activatorEvent2,
          collisions: collisions2,
          delta: {
            x: scrollAdjustedTranslate.x,
            y: scrollAdjustedTranslate.y
          },
          over: over2
        };
        reactDomExports.unstable_batchedUpdates(() => {
          onDragMove == null ? void 0 : onDragMove(event);
          dispatchMonitorEvent({
            type: "onDragMove",
            event
          });
        });
      },
[scrollAdjustedTranslate.x, scrollAdjustedTranslate.y]
    );
    reactExports.useEffect(
      () => {
        const {
          active: active2,
          activatorEvent: activatorEvent2,
          collisions: collisions2,
          droppableContainers: droppableContainers2,
          scrollAdjustedTranslate: scrollAdjustedTranslate2
        } = sensorContext.current;
        if (!active2 || activeRef.current == null || !activatorEvent2 || !scrollAdjustedTranslate2) {
          return;
        }
        const {
          onDragOver
        } = latestProps.current;
        const overContainer = droppableContainers2.get(overId);
        const over2 = overContainer && overContainer.rect.current ? {
          id: overContainer.id,
          rect: overContainer.rect.current,
          data: overContainer.data,
          disabled: overContainer.disabled
        } : null;
        const event = {
          active: active2,
          activatorEvent: activatorEvent2,
          collisions: collisions2,
          delta: {
            x: scrollAdjustedTranslate2.x,
            y: scrollAdjustedTranslate2.y
          },
          over: over2
        };
        reactDomExports.unstable_batchedUpdates(() => {
          setOver(over2);
          onDragOver == null ? void 0 : onDragOver(event);
          dispatchMonitorEvent({
            type: "onDragOver",
            event
          });
        });
      },
[overId]
    );
    useIsomorphicLayoutEffect(() => {
      sensorContext.current = {
        activatorEvent,
        active,
        activeNode,
        collisionRect,
        collisions,
        droppableRects,
        draggableNodes,
        draggingNode,
        draggingNodeRect,
        droppableContainers,
        over,
        scrollableAncestors,
        scrollAdjustedTranslate
      };
      activeRects.current = {
        initial: draggingNodeRect,
        translated: collisionRect
      };
    }, [active, activeNode, collisions, collisionRect, draggableNodes, draggingNode, draggingNodeRect, droppableRects, droppableContainers, over, scrollableAncestors, scrollAdjustedTranslate]);
    useAutoScroller({
      ...autoScrollOptions,
      delta: translate,
      draggingRect: collisionRect,
      pointerCoordinates,
      scrollableAncestors,
      scrollableAncestorRects
    });
    const publicContext = reactExports.useMemo(() => {
      const context = {
        active,
        activeNode,
        activeNodeRect,
        activatorEvent,
        collisions,
        containerNodeRect,
        dragOverlay,
        draggableNodes,
        droppableContainers,
        droppableRects,
        over,
        measureDroppableContainers,
        scrollableAncestors,
        scrollableAncestorRects,
        measuringConfiguration,
        measuringScheduled,
        windowRect
      };
      return context;
    }, [active, activeNode, activeNodeRect, activatorEvent, collisions, containerNodeRect, dragOverlay, draggableNodes, droppableContainers, droppableRects, over, measureDroppableContainers, scrollableAncestors, scrollableAncestorRects, measuringConfiguration, measuringScheduled, windowRect]);
    const internalContext = reactExports.useMemo(() => {
      const context = {
        activatorEvent,
        activators,
        active,
        activeNodeRect,
        ariaDescribedById: {
          draggable: draggableDescribedById
        },
        dispatch,
        draggableNodes,
        over,
        measureDroppableContainers
      };
      return context;
    }, [activatorEvent, activators, active, activeNodeRect, dispatch, draggableDescribedById, draggableNodes, over, measureDroppableContainers]);
    return React.createElement(DndMonitorContext.Provider, {
      value: registerMonitorListener
    }, React.createElement(InternalContext.Provider, {
      value: internalContext
    }, React.createElement(PublicContext.Provider, {
      value: publicContext
    }, React.createElement(ActiveDraggableContext.Provider, {
      value: transform
    }, children)), React.createElement(RestoreFocus, {
      disabled: (accessibility == null ? void 0 : accessibility.restoreFocus) === false
    })), React.createElement(Accessibility, {
      ...accessibility,
      hiddenTextDescribedById: draggableDescribedById
    }));
    function getAutoScrollerOptions() {
      const activeSensorDisablesAutoscroll = (activeSensor == null ? void 0 : activeSensor.autoScrollEnabled) === false;
      const autoScrollGloballyDisabled = typeof autoScroll === "object" ? autoScroll.enabled === false : autoScroll === false;
      const enabled2 = isInitialized2 && !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;
      if (typeof autoScroll === "object") {
        return {
          ...autoScroll,
          enabled: enabled2
        };
      }
      return {
        enabled: enabled2
      };
    }
  });
  const NullContext = reactExports.createContext(null);
  const defaultRole = "button";
  const ID_PREFIX$1 = "Draggable";
  function useDraggable(_ref4) {
    let {
      id: id2,
      data: data2,
      disabled = false,
      attributes: attributes2
    } = _ref4;
    const key = useUniqueId(ID_PREFIX$1);
    const {
      activators,
      activatorEvent,
      active,
      activeNodeRect,
      ariaDescribedById,
      draggableNodes,
      over
    } = reactExports.useContext(InternalContext);
    const {
      role = defaultRole,
      roleDescription = "draggable",
      tabIndex = 0
    } = attributes2 != null ? attributes2 : {};
    const isDragging2 = (active == null ? void 0 : active.id) === id2;
    const transform = reactExports.useContext(isDragging2 ? ActiveDraggableContext : NullContext);
    const [node2, setNodeRef] = useNodeRef();
    const [activatorNode, setActivatorNodeRef] = useNodeRef();
    const listeners2 = useSyntheticListeners(activators, id2);
    const dataRef = useLatestValue(data2);
    useIsomorphicLayoutEffect(
      () => {
        draggableNodes.set(id2, {
          id: id2,
          key,
          node: node2,
          activatorNode,
          data: dataRef
        });
        return () => {
          const node3 = draggableNodes.get(id2);
          if (node3 && node3.key === key) {
            draggableNodes.delete(id2);
          }
        };
      },
[draggableNodes, id2]
    );
    const memoizedAttributes = reactExports.useMemo(() => ({
      role,
      tabIndex,
      "aria-disabled": disabled,
      "aria-pressed": isDragging2 && role === defaultRole ? true : void 0,
      "aria-roledescription": roleDescription,
      "aria-describedby": ariaDescribedById.draggable
    }), [disabled, role, tabIndex, isDragging2, roleDescription, ariaDescribedById.draggable]);
    return {
      active,
      activatorEvent,
      activeNodeRect,
      attributes: memoizedAttributes,
      isDragging: isDragging2,
      listeners: disabled ? void 0 : listeners2,
      node: node2,
      over,
      setNodeRef,
      setActivatorNodeRef,
      transform
    };
  }
  function useDndContext() {
    return reactExports.useContext(PublicContext);
  }
  const ID_PREFIX$1$1 = "Droppable";
  const defaultResizeObserverConfig = {
    timeout: 25
  };
  function useDroppable(_ref4) {
    let {
      data: data2,
      disabled = false,
      id: id2,
      resizeObserverConfig
    } = _ref4;
    const key = useUniqueId(ID_PREFIX$1$1);
    const {
      active,
      dispatch,
      over,
      measureDroppableContainers
    } = reactExports.useContext(InternalContext);
    const previous = reactExports.useRef({
      disabled
    });
    const resizeObserverConnected = reactExports.useRef(false);
    const rect = reactExports.useRef(null);
    const callbackId = reactExports.useRef(null);
    const {
      disabled: resizeObserverDisabled,
      updateMeasurementsFor,
      timeout: resizeObserverTimeout
    } = {
      ...defaultResizeObserverConfig,
      ...resizeObserverConfig
    };
    const ids2 = useLatestValue(updateMeasurementsFor != null ? updateMeasurementsFor : id2);
    const handleResize = reactExports.useCallback(
      () => {
        if (!resizeObserverConnected.current) {
          resizeObserverConnected.current = true;
          return;
        }
        if (callbackId.current != null) {
          clearTimeout(callbackId.current);
        }
        callbackId.current = setTimeout(() => {
          measureDroppableContainers(Array.isArray(ids2.current) ? ids2.current : [ids2.current]);
          callbackId.current = null;
        }, resizeObserverTimeout);
      },
[resizeObserverTimeout]
    );
    const resizeObserver = useResizeObserver({
      callback: handleResize,
      disabled: resizeObserverDisabled || !active
    });
    const handleNodeChange = reactExports.useCallback((newElement, previousElement) => {
      if (!resizeObserver) {
        return;
      }
      if (previousElement) {
        resizeObserver.unobserve(previousElement);
        resizeObserverConnected.current = false;
      }
      if (newElement) {
        resizeObserver.observe(newElement);
      }
    }, [resizeObserver]);
    const [nodeRef, setNodeRef] = useNodeRef(handleNodeChange);
    const dataRef = useLatestValue(data2);
    reactExports.useEffect(() => {
      if (!resizeObserver || !nodeRef.current) {
        return;
      }
      resizeObserver.disconnect();
      resizeObserverConnected.current = false;
      resizeObserver.observe(nodeRef.current);
    }, [nodeRef, resizeObserver]);
    reactExports.useEffect(
      () => {
        dispatch({
          type: Action.RegisterDroppable,
          element: {
            id: id2,
            key,
            disabled,
            node: nodeRef,
            rect,
            data: dataRef
          }
        });
        return () => dispatch({
          type: Action.UnregisterDroppable,
          key,
          id: id2
        });
      },
[id2]
    );
    reactExports.useEffect(() => {
      if (disabled !== previous.current.disabled) {
        dispatch({
          type: Action.SetDroppableDisabled,
          id: id2,
          key,
          disabled
        });
        previous.current.disabled = disabled;
      }
    }, [id2, key, disabled, dispatch]);
    return {
      active,
      rect,
      isOver: (over == null ? void 0 : over.id) === id2,
      node: nodeRef,
      over,
      setNodeRef
    };
  }
  function setRefValue(ref2, value) {
    if (isNil(ref2)) return;
    if (typeof ref2 === "function") {
      ref2(value);
    } else {
      ref2.current = value;
    }
  }
  function useDelegatedRef(...innerRefs) {
    const ref2 = reactExports.useRef(null);
    return reactExports.useMemo(() => {
      return {
        get current() {
          return ref2.current;
        },
        set current(val) {
          ref2.current = val;
          innerRefs.forEach((r2) => r2 && setRefValue(r2, val));
        }
      };
    }, [ref2, ...innerRefs]);
  }
  const $windowSize = valtioFactory(() => ({
    width: window.innerWidth,
    height: window.innerHeight
  }));
  document.addEventListener("resize", $windowSize.updateThrottled);
  document.addEventListener("orientationchange", $windowSize.updateThrottled);
  document.addEventListener("scroll", throttle$2($windowSize.update, 1e3));
  function CollapsePanel({
    expanded,
    children,
    ...props
  }) {
    return jsx$1("div", { ...props, "data-classname": "wrapper", css: css("transition:grid-template-rows 0.2s ease-out;display:grid;grid-template-rows:", expanded ? 1 : 0, "fr;", ""), children: jsx$1("div", { "data-classname": "inner", className: "overflow-hidden", children }) });
  }
  function AntdTooltip(props) {
    return jsx$1(Tooltip, { ...props, styles: {
      ...props.styles,
      root: {
        width: "max-content",
        maxWidth: "50vw",
        ...props.styles?.root
      }
    }, children: props.children });
  }
  const iconParkOutlineTips = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M40 20c0 6.808-4.252 12.622-10.244 14.934H18.244C12.252 32.622 8 26.808 8 20c0-8.837 7.163-16 16-16s16 7.163 16 16" }),
jsx$1("path", { d: "m29.756 34.934l-.68 8.15a1 1 0 0 1-.996.916h-8.16a1 1 0 0 1-.996-.917l-.68-8.15M18 17v6l6-3l6 3v-6" })
    ] })
  ] });
  const ForwardRef$P = reactExports.forwardRef(iconParkOutlineTips);
  const DefaultIconComponent = ForwardRef$P;
  const TOOLTIP_BLACK_BG_COLOR = "rgb(0 0 0 / 0.85)";
  function HelpInfo({
    children,
    tooltipProps,
    IconComponent,
    className,
    useBlackBg,
    ...restSvgProps
  }) {
    IconComponent ??= DefaultIconComponent;
    const icon = jsx$1(IconComponent, { ...restSvgProps, className: r("ml-4px size-16px cursor-pointer", className) });
    return !!children && jsx$1(AntdTooltip, { color: useBlackBg ? TOOLTIP_BLACK_BG_COLOR : void 0, ...tooltipProps, title: children, children: icon });
  }
  function useBooleanSettingsPath(configPath, extraAction) {
    const snap = useSettingsSnapshot();
    const checked = !!get$1(snap, configPath, false);
    const onChange = reactExports.useCallback((val) => {
      set$1(settings, configPath, val);
      extraAction?.(val);
    }, []);
    const checkboxOnChange = reactExports.useCallback((e) => {
      onChange(e.target.checked);
    }, []);
    const onToggle = reactExports.useCallback(() => {
      onChange(!get$1(settings, configPath, false));
    }, []);
    return {
      checked,
      onChange,
      checkboxOnChange,
      onToggle
    };
  }
  function __FlagSettingItem({
    configPath,
    label,
    extraAction,
    tooltip,
    tooltipProps,
    as,
    checkboxProps,
    switchProps,
    ref: ref2
  }) {
    const {
      checked,
      onChange,
      checkboxOnChange
    } = useBooleanSettingsPath(configPath, extraAction);
    const wrapTooltip = (children) => {
      if (!tooltip) return children;
      return jsx$1(AntdTooltip, { ...tooltipProps, title: tooltip, children });
    };
    let usingLabel;
    if (typeof label === "function") {
      usingLabel = label(checked);
    } else {
      usingLabel = (label ?? configPath) || null;
    }
    if (as === "checkbox") {
      let label2 = jsx$1("span", { style: {
        userSelect: "none"
      }, children: usingLabel });
      if (tooltip) label2 = wrapTooltip(label2);
      return jsx$1(Checkbox, { ...checkboxProps, ref: ref2, checked, onChange: checkboxOnChange, styles: {
        label: {
          paddingInline: 6
        }
      }, children: label2 });
    }
    if (as === "switch") {
      let content = jsx$1(Switch, { ...switchProps, checked, onChange, ref: ref2 });
      if (tooltip) content = wrapTooltip(content);
      return content;
    }
  }
  const CheckboxSettingItem = function({
    configPath,
    label,
    extraAction,
    tooltip,
    tooltipProps,
    ref: ref2,
    ...otherProps
  }) {
    return jsx$1(__FlagSettingItem, { ...{
      ref: ref2,
      configPath,
      label,
      extraAction,
      tooltip,
      tooltipProps,
      as: "checkbox",
      checkboxProps: otherProps
    } });
  };
  function SwitchSettingItem({
    configPath,
    extraAction,
    tooltip,
    tooltipProps,
    ref: ref2,
    ...otherProps
  }) {
    return jsx$1(__FlagSettingItem, { ...{
      ref: ref2,
      configPath,
      extraAction,
      tooltip,
      tooltipProps,
      as: "switch",
      switchProps: otherProps
    } });
  }
  async function toastAndReload(msg = "即将刷新网页!") {
    antMessage.info(msg);
    await delay$1(500);
    location.reload();
  }
  function explainForFlag(checked, unchecked) {
    return jsxs(Fragment, { children: [
jsxs("div", { className: "flex items-center", children: [
        "✅: ",
        checked
      ] }),
jsxs("div", { className: "flex items-center", children: [
        "❎: ",
        unchecked
      ] })
    ] });
  }
  let lastUrl;
  function genUrl() {
    attempt(() => {
      if (lastUrl) URL.revokeObjectURL(lastUrl);
      lastUrl = void 0;
    });
    const val = getSettingsSnapshot();
    const json = JSON.stringify(val, null, 2);
    const blob = new Blob([json], {
      type: "application/json"
    });
    lastUrl = URL.createObjectURL(blob);
    return lastUrl;
  }
  function exportSettings() {
    const url2 = genUrl();
    const filename = `${APP_NAME}-settings ${dayjs().format("YYYY-MM-DD HH:mm:ss")}.json`;
    if (typeof GM_download !== "undefined") {
      GM_download?.({
        url: url2,
        name: filename
      });
    } else {
      const link = document.createElement("a");
      link.href = url2;
      link.download = filename;
      link.click();
    }
  }
  async function importSettings() {
    const file = await chooseSingleJsonFile();
    if (!file) return;
    const text = await file.text();
    if (!text) return toast("文件内容为空!");
    let settingsFromFile;
    try {
      settingsFromFile = JSON.parse(text);
    } catch {
      return toast("无法解析文件内容!");
    }
    runSettingsMigration(settingsFromFile);
    const {
      pickedPaths,
      pickedSettings
    } = pickSettings(settingsFromFile, allowedLeafSettingsPaths);
    if (!pickedPaths.length) {
      return toast("没有有效的设置!");
    }
    set_HAS_RESTORED_SETTINGS(true);
    updateSettings(pickedSettings);
    antMessage.success("导入成功!");
    return toastAndReload();
  }
  function chooseSingleJsonFile() {
    return chooseFile({
      accept: ".json",
      multiple: false
    });
  }
  function chooseFile(options) {
    return new Promise((resolve) => {
      const input = document.createElement("input");
      input.type = "file";
      Object.assign(input, options);
      input.addEventListener("change", () => {
        resolve(input.files?.[0] || null);
      });
      input.click();
    });
  }
  const sharedClassNames = {
    tabPane: "max-h-[max(362px,calc(90vh-50px-56px-15px))] min-h-362px overflow-y-auto pr-12px",
    settingsGroup: "mb-10px",
    settingsGroupTitle: "flex items-center text-2em",
    settingsGroupSubTitle: "flex items-center text-1.25em",
    settingsLine: "flex flex-row flex-wrap items-center gap-x-10px gap-y-1"
  };
  function SettingsGroup({
    children,
    title,
    titleClassName,
    contentClassName,
    resetSettingPaths,
    ...rest
  }) {
    const hasResetButton = !!resetSettingPaths?.length;
    return jsxs("div", { className: sharedClassNames.settingsGroup, "data-role": "settings-group", ...rest, children: [
jsxs("div", { "data-role": "settings-group-title", className: r(sharedClassNames.settingsGroupTitle, hasResetButton && "justify-between", titleClassName), children: [
        hasResetButton ? jsx$1("div", { className: "flex items-center", children: title }) : title,
        resetSettingPaths && jsx$1(ResetPartialSettingsButton, { paths: resetSettingPaths })
      ] }),
jsx$1("div", { "data-role": "settings-group-content", className: r("flex flex-col gap-y-1", contentClassName), children })
    ] });
  }
  function resetPartialSettings(paths) {
    const {
      pickedSettings
    } = pickSettings(initialSettings, paths);
    updateSettings(pickedSettings);
  }
  function ResetPartialSettingsButton({
    paths,
    className
  }) {
    return jsx$1(Popconfirm, { title: "确定重置下面的设置项?", onConfirm: () => resetPartialSettings(paths), children: jsxs(Button$1, { className: clsx("gap-x-4px", className), children: [
jsx$1(ForwardRef$_, { className: "mt--1px size-12px" }),
jsx$1("span", { children: "重置" })
    ] }) });
  }
  const tablerRestore = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsx$1("path", { d: "M3.06 13a9 9 0 1 0 .49-4.087" }),
jsx$1("path", { d: "M3 4.001v5h5M11 12a1 1 0 1 0 2 0a1 1 0 1 0-2 0" })
    ] })
  ] });
  const ForwardRef$O = reactExports.forwardRef(tablerRestore);
  const tablerFileExport = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsx$1("path", { d: "M14 3v4a1 1 0 0 0 1 1h4" }),
jsx$1("path", { d: "M11.5 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v5m-5 6h7m-3-3l3 3l-3 3" })
    ] })
  ] });
  const ForwardRef$N = reactExports.forwardRef(tablerFileExport);
  const tablerFileImport = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsx$1("path", { d: "M14 3v4a1 1 0 0 0 1 1h4" }),
jsx$1("path", { d: "M5 13V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2h-5.5M2 19h7m-3-3l3 3l-3 3" })
    ] })
  ] });
  const ForwardRef$M = reactExports.forwardRef(tablerFileImport);
  const icOutlineCloud = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M12 6c2.62 0 4.88 1.86 5.39 4.43l.3 1.5l1.53.11A2.98 2.98 0 0 1 22 15c0 1.65-1.35 3-3 3H6c-2.21 0-4-1.79-4-4c0-2.05 1.53-3.76 3.56-3.97l1.07-.11l.5-.95A5.47 5.47 0 0 1 12 6m0-2C9.11 4 6.6 5.64 5.35 8.04A5.994 5.994 0 0 0 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5c0-2.64-2.05-4.78-4.65-4.96A7.49 7.49 0 0 0 12 4" })
  ] });
  const ForwardRef$L = reactExports.forwardRef(icOutlineCloud);
  const iconParkOutlineDownC = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4S4 12.954 4 24s8.954 20 20 20Z" }),
jsx$1("path", { strokeLinecap: "round", d: "m33 21l-9 9l-9-9" })
    ] })
  ] });
  const ForwardRef$K = reactExports.forwardRef(iconParkOutlineDownC);
  function onResetSettings() {
    resetSettings();
    return toastAndReload();
  }
  async function onRestoreSettings() {
    const remoteSettings = await articleDraft.getData();
    runSettingsMigration(remoteSettings);
    const {
      pickedPaths,
      pickedSettings
    } = pickSettings(remoteSettings, allowedLeafSettingsPaths, restoreOmitPaths);
    if (!pickedPaths.length) {
      return antMessage.error("备份不存在或没有有效的配置");
    }
    set_HAS_RESTORED_SETTINGS(true);
    updateSettings(pickedSettings);
    return toastAndReload();
  }
  function TabPaneAdvance() {
    const [internalKeysExpanded, setInternalKeysExpanded] = reactExports.useState(false);
    return jsxs("div", { className: sharedClassNames.tabPane, children: [
jsx$1(SettingsGroup, { title: "设置项", children: jsxs(Space, { size: 20, children: [
jsx$1(Popconfirm, { title: "确定", description: "确定恢复默认设置? 此操作不可逆!", onConfirm: onResetSettings, children: jsxs(Button$1, { danger: true, type: "primary", children: [
jsx$1(ForwardRef$O, {}),
          "恢复默认设置"
        ] }) }),
jsxs(Space, { size: 5, children: [
jsx$1(AntdTooltip, { title: "导出所有设置项到文件中, 包含 access_key 等数据, 请妥善保存", children: jsxs(Button$1, { onClick: () => exportSettings(), children: [
jsx$1(ForwardRef$N, {}),
            "导出设置"
          ] }) }),
jsx$1(AntdTooltip, { title: "从文件中导入设置项, 将覆盖当前设置, 此操作不可逆!", children: jsxs(Button$1, { onClick: () => importSettings(), children: [
jsx$1(ForwardRef$M, {}),
            "导入设置"
          ] }) })
        ] })
      ] }) }),
jsx$1(SettingsGroup, { title: jsxs(Fragment, { children: [
jsx$1(ForwardRef$L, { className: "mr-4px size-28px" }),
        "备份"
      ] }), children: jsxs("div", { className: "flex items-center gap-x-40px", children: [
jsxs("span", { className: "flex items-center gap-x-8px", children: [
jsx$1(CheckboxSettingItem, { configPath: "backupSettingsToArticleDraft", label: "备份设置到专栏草稿箱中", tooltip: `专栏 - 草稿箱 - ${APP_NAME}` }),
jsxs("a", { className: "inline-flex items-center", href: "https://member.bilibili.com/platform/upload/text/draft", target: "_blank", children: [
jsx$1(IconForOpenExternalLink, { className: "mr-4px size-16px" }),
            "去草稿箱浏览"
          ] })
        ] }),
jsx$1(Popconfirm, { title: "确定", description: "将覆盖本地设置? 此操作不可逆!", onConfirm: onRestoreSettings, children: jsxs(Button$1, { danger: true, type: "primary", children: [
jsx$1(ForwardRef$O, {}),
          "从专栏草稿箱中恢复"
        ] }) })
      ] }) }),
jsx$1(SettingsGroup, { title: jsxs(Fragment, { children: [
        "其他",
jsx$1(HelpInfo, { children: "这里是一些作者不愿意解释的设置项 😬" }),
jsx$1(Button$1, { onClick: () => setInternalKeysExpanded((v) => !v), className: "ml-10px inline-icon-only-round-button", css: internalKeysExpanded && buttonOpenCss, children: jsx$1(ForwardRef$K, { className: clsx("size-16px transition-300 transition-transform", internalKeysExpanded ? "rotate-180" : "rotate-0") }) })
      ] }), children: jsx$1(CollapsePanel, { expanded: internalKeysExpanded, children: jsxs("div", { className: "w-full flex gap-x-20px b-1px b-gate-border rounded-6px b-solid p-10px", children: [
jsx$1(ResetPartialSettingsButton, { paths: internalBooleanPaths, className: "flex-none" }),
jsx$1("div", { className: "flex flex-1 flex-wrap items-start gap-x-20px gap-y-10px", children: internalBooleanPaths.map((k) => jsx$1(CheckboxSettingItem, { configPath: k, tooltip: jsxs(Fragment, { children: [
          k,
          INTERNAL_BOOLEAN_TOOLTIPS[k] && jsxs(Fragment, { children: [
jsx$1("br", {}),
            INTERNAL_BOOLEAN_TOOLTIPS[k]
          ] })
        ] }), label: startCase(k.startsWith("__internal") ? k.slice("__internal".length) : k.replaceAll("__internal.", "")) }, k)) })
      ] }) }) })
    ] });
  }
  const INTERNAL_BOOLEAN_TOOLTIPS = {};
  function tweakColorWithOklch(originalColor, {
    l: l2,
    c: c2,
    h: h2,
    alpha: alpha2,
    deltaL,
    deltaC,
    deltaH,
    deltaAlpha
  } = {}) {
    const lValue = l2 ?? (deltaL ? `calc(l + ${deltaL})` : "l");
    const cValue = c2 ?? (deltaC ? `calc(c + ${deltaC})` : "c");
    const hValue = h2 ?? (deltaH ? `calc(h + ${deltaH})` : "h");
    const alphaValue = alpha2 ?? (deltaAlpha ? `calc(alpha + ${deltaAlpha})` : "alpha");
    return `oklch(from ${originalColor} ${lValue} ${cValue} ${hValue} / ${alphaValue})`;
  }
  function tweakLightness(originalColor, delta) {
    return tweakColorWithOklch(originalColor, {
      deltaL: delta
    });
  }
  function TooltipContentDivider({
    className,
    ...restProps
  }) {
    return jsx$1(Divider, { variant: "solid", ...restProps, className: r("my-7px", className), css: css("border-top-color:", tweakColorWithOklch(appPrimaryColorValue, {
      l: 0.9
    }), ";", "") });
  }
  const newSignedForm = (params) => {
    const sign = appSign(params, TVKeyInfo.appkey, TVKeyInfo.appsec);
    return new URLSearchParams({
      ...params,
      sign
    });
  };
  async function getQrCodeInfo() {
    const res = await request.post(
      "https://passport.bilibili.com/x/passport-tv-login/qrcode/auth_code",
      newSignedForm({
        appkey: TVKeyInfo.appkey,
        local_id: "0",
        ts: "0"
      })
);
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      toast(json?.message || "获取 auth_code 失败");
      return;
    }
    return json.data;
  }
  async function poll(auth_code) {
    const res = await request.post("https://passport.bilibili.com/x/passport-tv-login/qrcode/poll", newSignedForm({
      appkey: TVKeyInfo.appkey,
      auth_code,
      local_id: "0",
      ts: "0"
    }));
    const json = res.data;
    const msgMap = {
      "0": "成功",
      "-3": "API校验密匙错误",
      "-400": "请求错误",
      "-404": "啥都木有",
      "86038": "二维码已失效",
      "86039": "二维码尚未确认",
      "86090": "二维码已扫码未确认"
    };
    if (!isWebApiSuccess(json)) {
      const code = json.code.toString();
      const message2 = json.message || msgMap[code] || "未知错误";
      if (code === "86038") {
        return {
          success: false,
          message: message2,
          action: "refresh"
        };
      }
      if (code === "86039" || code === "86090") {
        return {
          success: false,
          message: message2,
          action: "wait"
        };
      }
      return {
        success: false,
        message: message2,
        action: void 0
      };
    }
    const accessKey = json.data.access_token;
    const accessKeyExpireAt = Date.now() + json.data.expires_in * 1e3;
    return {
      success: true,
      message: "获取成功",
      accessKey,
      accessKeyExpireAt
    };
  }
  const initialValue = {
    show: false,
    qrcodeUrl: "",
    auth_code: "",
    message: "",
    expired: false
  };
  const store$3 = proxy({
    ...initialValue
  });
  function updateStore(data2) {
    renderOnce$1();
    Object.assign(store$3, data2);
  }
  function showQrCodeModal(data2) {
    updateStore({
      ...initialValue,
      ...data2,
      show: true
    });
  }
  const emitter$2 = new Emittery();
  function hideQrCodeModal() {
    updateStore({
      ...initialValue
    });
    emitter$2.emit("hide");
  }
  function whenQrCodeModalHide() {
    return emitter$2.once("hide");
  }
  function whenQrCodeRefresh() {
    return emitter$2.once("refresh");
  }
  function TvQrCodeAuth() {
    const {
      qrcodeUrl,
      show,
      message: message2,
      expired
    } = useSnapshot(store$3);
    const onHide2 = hideQrCodeModal;
    const onRefresh = () => {
      emitter$2.emit("refresh");
    };
    return jsxs(BaseModal, { show, onHide: onHide2, hideWhenMaskOnClick: false, hideWhenEsc: false, clsModalMask: "backdrop-blur-10px", clsModal: "aspect-ratio-10/16", width: 260, children: [
jsxs("div", { className: BaseModalClassNames.modalHeader, children: [
jsx$1("div", { className: BaseModalClassNames.modalTitle }),
jsx$1(ModalClose, { onClick: onHide2 })
      ] }),
jsxs("div", { className: clsx(BaseModalClassNames.modalBody, "flex flex-col items-center justify-center text-center"), children: [
jsx$1("div", { className: "mb-2px min-h-25px flex-center text-size-14px", children: message2 || "" }),
        qrcodeUrl && jsxs("div", { className: "relative mx-auto mb-40px flex-shrink-0", children: [
jsx$1(QRCode, { className: "p-8px", value: qrcodeUrl, size: 200, icon: "https://is1-ssl.mzstatic.com/image/thumb/Purple211/v4/72/9c/b6/729cb6d8-75f5-0a56-0508-3a26cbba69ae/AppIcon-1x_U007emarketing-0-6-0-0-85-220-0.png/230x0w.webp" }),
          expired && jsxs("div", { className: "absolute inset-0 flex flex-col cursor-pointer items-center justify-center bg-black/65 text-white", onClick: onRefresh, children: [
jsx$1("div", { className: "mb-8px text-size-14px font-600", children: "二维码已过期" }),
jsx$1("div", { className: "border border-white/40 rounded-6px px-12px py-6px text-size-13px", children: "点击刷新" })
          ] })
        ] }),
jsxs("div", { className: "footnote text-size-13px line-height-snug", children: [
          "打开「哔哩哔哩」或「bilibili」App ",
jsx$1("br", {}),
          "扫码获取 access_key"
        ] })
      ] })
    ] });
  }
  const renderOnce$1 = once(function render2() {
    const container = document.createElement("div");
    container.classList.add("modal-tv-qrcode-auth", APP_CLS_ROOT);
    document.body.appendChild(container);
    const r2 = clientExports.createRoot(container);
    r2.render( jsx$1(AppRoot, { children: jsx$1(TvQrCodeAuth, {}) }));
  });
  async function refreshQrCode() {
    const qrinfo = await getQrCodeInfo();
    if (!qrinfo) return;
    showQrCodeModal({
      qrcodeUrl: qrinfo.url,
      auth_code: qrinfo.auth_code
    });
    return true;
  }
  async function getAccessKeyByQrCode() {
    let pollfor;
    let res;
    const next2 = await refreshQrCode();
    if (!next2) return;
    pollfor = store$3.auth_code;
    function shouldBreak() {
      if (!store$3.show) return true;
      if (!store$3.auth_code) return true;
      if (pollfor !== store$3.auth_code) return true;
    }
    function shouldContinue() {
      return !shouldBreak();
    }
    while (shouldContinue()) {
      const p1 = delay$1(1500);
      const p2 = whenQrCodeModalHide();
      await Promise.race([p1, p2]);
      p2.off();
      if (shouldBreak()) return;
      res = await poll(store$3.auth_code);
      const {
        success,
        accessKey,
        accessKeyExpireAt,
        message: message2,
        action: action2
      } = res;
      if (shouldBreak()) return;
      updateStore({
        message: message2
      });
      if (success) {
        await delay$1(1e3);
        hideQrCodeModal();
        return {
          accessKey,
          accessKeyExpireAt
        };
      }
      if (action2 === "refresh") {
        updateStore({
          message: "二维码已过期，请点击刷新",
          expired: true
        });
        const p12 = whenQrCodeModalHide();
        const p22 = whenQrCodeRefresh();
        await Promise.race([p12, p22]);
        p12.off();
        p22.off();
        if (shouldBreak()) return;
        const next22 = await refreshQrCode();
        if (!next22) return;
        pollfor = store$3.auth_code;
        updateStore({
          message: "已刷新二维码",
          expired: false
        });
        continue;
      }
      if (action2 === "wait") {
        continue;
      }
      updateStore({
        message: message2
      });
      toast(message2);
      return;
    }
  }
  async function getAccessKey() {
    const {
      accessKey,
      accessKeyExpireAt
    } = await getAccessKeyByQrCode() || {};
    if (!accessKey || !accessKeyExpireAt) return;
    settings.accessKey = accessKey;
    settings.accessKeyExpireAt = accessKeyExpireAt;
    toast("获取成功");
  }
  function deleteAccessKey() {
    settings.accessKey = "";
    settings.accessKeyExpireAt = 0;
    toast("已删除 access_key");
  }
  const btnAccessKeyHelpLink = jsx$1(Button$1, { target: "_blank", href: "https://github.com/indefined/UserScripts/tree/master/bilibiliHome#%E6%8E%88%E6%9D%83%E8%AF%B4%E6%98%8E", children: "access_key 说明" });
  function AccessKeyManage({
    style: style2,
    className
  }) {
    const {
      runAsync,
      loading
    } = useRequest(getAccessKey, {
      manual: true
    });
    const {
      accessKey
    } = useSettingsSnapshot();
    const onDeleteAccessKey = deleteAccessKey;
    return jsx$1(Space, { size: "small", style: style2, className, children: !accessKey ? jsxs(Fragment, { children: [
jsx$1(Button$1, { onClick: runAsync, loading, children: "获取 access_key" }),
      btnAccessKeyHelpLink
    ] }) : jsxs(Fragment, { children: [
jsx$1(Button$1, { onClick: runAsync, loading, children: "重新获取 access_key" }),
jsx$1(Popconfirm, { onConfirm: onDeleteAccessKey, title: "确定删除 access_key?", children: jsx$1(Button$1, { children: "删除 access_key" }) }),
      btnAccessKeyHelpLink
    ] }) });
  }
  const materialSymbolsAlignHorizontalLeft = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M2 22V2h2v20zm4-5v-3h10v3zm0-7V7h16v3z" })
  ] });
  const ForwardRef$J = reactExports.forwardRef(materialSymbolsAlignHorizontalLeft);
  const materialSymbolsAlignHorizontalCenter = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M11 22v-5H6v-3h5v-4H3V7h8V2h2v5h8v3h-8v4h5v3h-5v5z" })
  ] });
  const ForwardRef$I = reactExports.forwardRef(materialSymbolsAlignHorizontalCenter);
  const materialSymbolsAlignHorizontalRight = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M20 22V2h2v20zM8 17v-3h10v3zm-6-7V7h16v3z" })
  ] });
  const ForwardRef$H = reactExports.forwardRef(materialSymbolsAlignHorizontalRight);
  const clsTwoColumnModeWidth = "w-720px";
  const clsForTwoColumnModeAlign = (pos, mode) => {
    switch (pos) {
      case ETwoColumnModeAlign.Left:
        return mode === "flex" ? "justify-left" : "ml-0 mr-auto";
      case ETwoColumnModeAlign.Right:
        return mode === "flex" ? "justify-right" : "ml-auto mr-0";
      default:
        return mode === "flex" ? "justify-center" : "mx-auto";
    }
  };
  function TwoColumnModeAlignSwitcher({
    className
  }) {
    const {
      grid: {
        gridDisplayMode,
        twoColumnModeAlign
      }
    } = useSettingsSnapshot();
    return jsxs(Radio.Group, { className, disabled: gridDisplayMode !== EGridDisplayMode.TwoColumnGrid, buttonStyle: "solid", size: "small", value: twoColumnModeAlign, onChange: (e) => {
      settings.grid.twoColumnModeAlign = e.target.value;
    }, children: [
jsx$1(Radio.Button, { value: ETwoColumnModeAlign.Left, className: "inline-flex-center", children: jsx$1(ForwardRef$J, { className: "size-16px" }) }),
jsx$1(Radio.Button, { value: ETwoColumnModeAlign.Center, className: "inline-flex-center", children: jsx$1(ForwardRef$I, { className: "size-16px" }) }),
jsx$1(Radio.Button, { value: ETwoColumnModeAlign.Right, className: "inline-flex-center", children: jsx$1(ForwardRef$H, { className: "size-16px" }) })
    ] });
  }
  const tablerLayoutGrid = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 5a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1zm10 0a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1zM4 15a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1zm10 0a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1z" })
  ] });
  const ForwardRef$G = reactExports.forwardRef(tablerLayoutGrid);
  const tablerListDetails = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M13 5h8m-8 4h5m-5 6h8m-8 4h5M3 5a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1zm0 10a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1z" })
  ] });
  const ForwardRef$F = reactExports.forwardRef(tablerListDetails);
  function gridDisplayModeChecker(x) {
    return {
      usingListMode: x === EGridDisplayMode.List,
      usingTwoColumnMode: x === EGridDisplayMode.TwoColumnGrid,
      usingCenterEmptyMode: x === EGridDisplayMode.CenterEmptyGrid
    };
  }
  function useGridDisplayModeChecker() {
    const {
      gridDisplayMode
    } = useSnapshot(settings.grid);
    return gridDisplayModeChecker(gridDisplayMode);
  }
  function isDisplayAsList(displayMode) {
    return displayMode === EGridDisplayMode.List;
  }
  function useIsDisplayAsList() {
    return useSnapshot(settings.grid).gridDisplayMode === EGridDisplayMode.List;
  }
  function GridDisplayModeSwitcher({
    className
  }) {
    const {
      gridDisplayMode
    } = useSnapshot(settings.grid);
    const clsRadioWrapper = "[&_.ant-radio-wrapper]:inline-flex [&_.ant-radio-wrapper]:items-center";
    const clsRadioLabel = "[&_.ant-radio-label]:inline-flex [&_.ant-radio-label]:items-center ![&_.ant-radio-label]:pl-4px";
    const _className = r("flex items-center gap-x-15px", clsRadioWrapper, clsRadioLabel, className);
    return jsx$1(Radio.Group, { size: "large", className: _className, value: gridDisplayMode, onChange: (e) => {
      settings.grid.gridDisplayMode = e.target.value;
    }, options: [{
      value: EGridDisplayMode.NormalGrid,
      label: jsx$1(AntdTooltip, { title: "这个是默认的网格模式", children: jsxs("span", { className: "inline-flex-center", children: [
jsx$1(ForwardRef$G, { className: "mx-4px size-16px cursor-pointer" }),
        "网格"
      ] }) })
    }, {
      value: EGridDisplayMode.List,
      label: jsxs(Fragment, { children: [
jsx$1(ForwardRef$F, { className: "mx-4px size-16px cursor-pointer" }),
        "列表"
      ] })
    }, {
      value: EGridDisplayMode.TwoColumnGrid,
      label: jsxs(Fragment, { children: [
        "双列模式",
jsx$1(TwoColumnModeAlignSwitcher, { className: "ml-5px" })
      ] })
    }, {
      value: EGridDisplayMode.CenterEmptyGrid,
      label: jsx$1(Fragment, { children: jsx$1(AntdTooltip, { title: "网格中间不显示卡片", children: "中空模式" }) })
    }] });
  }
  const IN_BILIBILI_VIDEO_PLAY_PAGE = IN_BILIBILI_MAIN && ["/video/", "/list/watchlater", "/bangumi/play/"].some((prefix2) => location.pathname.startsWith(prefix2));
  const handlers = [["/video/", () => {
    return /^\/video\/(?<bvid>BV\w+)\/?/.exec(location.pathname)?.groups?.bvid;
  }], ["/list/watchlater", () => {
    return new URLSearchParams(location.search).get("bvid") || void 0;
  }], ["/bangumi/play/", () => {
    return void 0;
  }]];
  function getCurrentPageBvid() {
    const config = handlers.find(([prefix2]) => location.pathname.startsWith(prefix2));
    return config?.[1]();
  }
  function formatFavFolderUrl(id2, ctype = 21) {
    return `https://space.bilibili.com/${getUid()}/favlist?fid=${id2}&ftype=create`;
  }
  function formatFavCollectionUrl(id2, ctype = 21) {
    return `https://space.bilibili.com/${getUid()}/favlist?fid=${id2}&ftype=collect&ctype=${ctype}`;
  }
  function formatFavPlaylistUrl(id2) {
    return `https://www.bilibili.com/list/ml${id2}`;
  }
  function formatBvidUrl(bvid) {
    return `https://www.bilibili.com/video/${bvid}`;
  }
  function isFavFolderDefault(attr) {
    return attr.toString(2).at(-2) === "0";
  }
  function isFavFolderPrivate(attr) {
    return attr.toString(2).at(-1) === "1";
  }
  async function favDeal({
    avid,
    add_media_ids = "",
    del_media_ids = ""
  }) {
    const form = new URLSearchParams({
      rid: avid.toString(),
      type: "2",
      add_media_ids,
      del_media_ids,
      platform: "web",
      eab_x: "2",
      ramval: "0",
      ga: "1",
      gaia_source: "web_normal",
      csrf: getCsrfToken()
    });
    const res = await request.post("/x/v3/fav/resource/deal", form);
    const json = res.data;
    const success = isWebApiSuccess(json);
    if (!success) {
      toast(json?.message || "fav deal api fail");
    }
    return success;
  }
  const UserFavApi = {
    getVideoFavState,
    addFav,
    removeFavs,
    moveFavs,
modifyFav
  };
  async function removeFavs(folderId, resources) {
    const form = new URLSearchParams({
      resources: [resources].flat().join(","),
      media_id: folderId.toString(),
      platform: "web",
      csrf: getCsrfToken()
    });
    const res = await request.post("/x/v3/fav/resource/batch-del", form);
    const json = res.data;
    const success = isWebApiSuccess(json);
    if (!success) {
      toast(json.message || OPERATION_FAIL_MSG);
    }
    return success;
  }
  async function moveFavs(resources, src, target) {
    const form = new URLSearchParams({
      resources: [resources].flat().join(","),
      src_media_id: src.toString(),
      tar_media_id: target.toString(),
      mid: getUid(),
      platform: "web",
      csrf: getCsrfToken()
    });
    const res = await request.post("/x/v3/fav/resource/move", form);
    const json = res.data;
    const success = isWebApiSuccess(json);
    if (!success) {
      toast(json?.message || "fav deal api fail");
    }
    return success;
  }
  async function getVideoFavState(avid) {
    if (!getHasLogined()) return;
    const res = await request.get("/x/v3/fav/folder/created/list-all", {
      params: {
        up_mid: getUid(),
        type: 2,
        rid: avid
      }
    });
    const json = res.data;
    const favFolders = json.data.list.filter((folder) => folder.fav_state > 0);
    const favFolderNames = favFolders.map((f2) => f2.title);
    const favFolderUrls = favFolders.map((f2) => formatFavFolderUrl(f2.id));
    const favFolderIds = favFolders.map((f2) => f2.id);
    return {
      favFolders,
      favFolderNames,
      favFolderUrls,
      favFolderIds
    };
  }
  let defaultFavFolderId;
  let defaultFavFolderTitle;
  async function addFav(avid, folderId) {
    if (!folderId && (!defaultFavFolderId || !defaultFavFolderTitle)) {
      await updateFavFolderList();
      const {
        folders
      } = favStore;
      const defaultFolder = folders.find((f2) => isFavFolderDefault(f2.attr)) ?? folders[0];
      if (!defaultFolder) return toast("没有找到默认收藏夹!");
      defaultFavFolderId = defaultFolder.id;
      defaultFavFolderTitle = defaultFolder.title;
    }
    folderId ||= defaultFavFolderId;
    if (!folderId) {
      return toast("没有找到默认收藏夹!");
    }
    return await favDeal({
      avid,
      add_media_ids: folderId.toString()
    });
  }
  async function fetchAllFavFolders() {
    const res = await request.get("/x/v3/fav/folder/created/list-all", {
      params: {
        up_mid: getUid()
      }
    });
    const json = res.data;
    const folders = json.data.list;
    return folders;
  }
  async function modifyFav(avid, sourceFolderIds, targetFolderId) {
    const source = (sourceFolderIds ?? []).filter((x) => x !== void 0);
    const target = [targetFolderId].filter((x) => x !== void 0);
    const delArr = difference(source, target);
    const addArr = difference(target, source);
    const success = await favDeal({
      avid,
      del_media_ids: delArr.length ? delArr.join(",") : void 0,
      add_media_ids: addArr.length ? addArr.join(",") : void 0
    });
    return success;
  }
  async function getFavFolderInfo(folderId) {
    const res = await request.get("/x/v3/fav/folder/info", {
      params: {
        media_id: folderId,
        web_location: "0.0"
      }
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) throw new WebApiError(json);
    return json.data;
  }
  async function editFavFolder(folderId, newTitle) {
    const info = await getFavFolderInfo(folderId);
    if (!info) return;
    const form = new URLSearchParams({
      media_id: folderId.toString(),
      title: newTitle,
      intro: info.intro,
      cover: info.cover,
      privacy: isFavFolderPrivate(info.attr) ? "1" : "0",
csrf: getCsrfToken()
    });
    const res = await request.post("/x/v3/fav/folder/edit", form);
    const json = res.data;
    const success = isWebApiSuccess(json);
    if (!success) {
      const msg = json.message || "编辑收藏夹失败";
      toast(msg);
    }
    return success;
  }
  async function fetchFavCollections(page) {
    const res = await request.get("/x/v3/fav/folder/collected/list", {
      params: {
        up_mid: getUid(),
        platform: "web",
        ps: 20,
        pn: page
      }
    });
    const json = res.data;
    return json.data;
  }
  async function fetchAllFavCollections() {
    let page = 1;
    let hasMore = true;
    let items = [];
    while (hasMore) {
      const data2 = await fetchFavCollections(page);
      items.push(...data2.list);
      hasMore = data2.has_more;
      page++;
    }
    items = items.filter((x) => {
      if (x.title === "该合集已失效" && x.upper.mid === 0) return false;
      return true;
    });
    items = uniqBy(items, (x) => x.id);
    return items;
  }
  async function fetchCollectionDetail(collectionId, page) {
    const res = await request.get("/x/space/fav/season/list", {
      params: {
        season_id: collectionId,
        ps: 20,
        pn: page
      }
    });
    const json = res.data;
    return json.data;
  }
  var FavItemsOrder = ((FavItemsOrder2) => {
    FavItemsOrder2["Initial"] = "initial";
    FavItemsOrder2["Shuffle"] = "shuffle";
    FavItemsOrder2["PubTimeDesc"] = "pub-time-desc";
    FavItemsOrder2["PubTimeAsc"] = "pub-time-asc";
    FavItemsOrder2["PlayCountDesc"] = "play-count-desc";
    FavItemsOrder2["CollectCountDesc"] = "collect-count-desc";
    FavItemsOrder2["FavTimeDesc"] = "fav-time-desc";
    FavItemsOrder2["FavTimeAsc"] = "fav-time-asc";
    return FavItemsOrder2;
  })(FavItemsOrder || {});
  function handleItemsOrder(items, itemsOrder) {
    if (itemsOrder === "initial") {
      return items;
    }
    if (itemsOrder === "shuffle") {
      return shuffle(items);
    }
    if (itemsOrder === "pub-time-desc" || itemsOrder === "pub-time-asc") {
      const order = itemsOrder === "pub-time-desc" ? "desc" : "asc";
      return orderBy(items, [(x) => x.pubtime], [order]);
    }
    if ((itemsOrder === "fav-time-desc" || itemsOrder === "fav-time-asc") && items.every((x) => x.from === "fav-folder")) {
      const order = itemsOrder === "fav-time-desc" ? "desc" : "asc";
      return orderBy(items, [(x) => x.fav_time], [order]);
    }
    if (itemsOrder === "play-count-desc") {
      return orderBy(items, [(x) => x.cnt_info.play], ["desc"]);
    }
    if (itemsOrder === "collect-count-desc") {
      return orderBy(items, [(x) => x.cnt_info.collect], ["desc"]);
    }
    return items;
  }
  var EApiType = ((EApiType2) => {
    EApiType2["Separator"] = "separator";
    EApiType2["AppRecommend"] = "app-recommend";
    EApiType2["PcRecommend"] = "pc-recommend";
    EApiType2["DynamicFeed"] = "dynamic-feed";
    EApiType2["Watchlater"] = "watchlater";
    EApiType2["Fav"] = "fav";
    EApiType2["PopularGeneral"] = "popular-general";
    EApiType2["PopularWeekly"] = "popular-weekly";
    EApiType2["Rank"] = "ranking";
    EApiType2["Live"] = "live";
    EApiType2["SpaceUpload"] = "space-upload";
    EApiType2["Liked"] = "liked";
    return EApiType2;
  })(EApiType || {});
  function isAppRecommend(item) {
    return item.api === EApiType.AppRecommend;
  }
  function isPcRecommend(item) {
    return item.api === EApiType.PcRecommend;
  }
  function isDynamicFeed(item) {
    return item.api === EApiType.DynamicFeed;
  }
  function isWatchlater(item) {
    return item.api === EApiType.Watchlater;
  }
  function isFav(item) {
    return item.api === EApiType.Fav;
  }
  function isRank(item) {
    return item.api === EApiType.Rank;
  }
  function isLive(item) {
    return item.api === EApiType.Live;
  }
  function isSpaceUpload(item) {
    return item.api === EApiType.SpaceUpload;
  }
  function getIdbCache(tableName) {
    const db = localforage.createInstance({
      driver: localforage.INDEXEDDB,
      name: APP_NAMESPACE,
      storeName: tableName
    });
    return {
      db,
      get(key) {
        return db.getItem(key.toString());
      },
      set(key, entry) {
        return db.setItem(key.toString(), entry);
      },
      delete(key) {
        return db.removeItem(key.toString());
      }
    };
  }
  function wrapWithIdbCache({
    fn,
    generateKey,
    tableName,
    ttl,
    concurrency,
autoCleanUp = true
  }) {
    const cache2 = typeof tableName === "string" ? getIdbCache(tableName) : tableName;
    const cleanUp = throttle$2(() => {
      cache2.db.iterate((cached2, key) => {
        if (!shouldReuseCached(cached2)) {
          cache2.db.removeItem(key);
        }
      });
    }, 1e3);
    if (autoCleanUp) {
      whenIdle().then(cleanUp);
    }
    function shouldReuseCached(cached2) {
      return Boolean(cached2 && cached2.val && cached2.ts && Date.now() - cached2.ts <= ttl);
    }
    async function queryCache(...args) {
      const key = generateKey(...args);
      const cached2 = await cache2.get(key);
      if (cached2 && shouldReuseCached(cached2)) {
        return cached2.val;
      }
    }
    const fnLimited = concurrency && concurrency > 0 ? limitFunction(fn, concurrency) : fn;
    const fnMemoized = pMemoize(fnLimited, {
      cacheKey(args) {
        return generateKey(...args);
      },
      cache: {
        async has(key) {
          const cached2 = await cache2.get(key);
          return shouldReuseCached(cached2);
        },
        async get(key) {
          const cached2 = await cache2.get(key);
          if (cached2 && shouldReuseCached(cached2)) return cached2.val;
        },
        async set(key, val) {
          if (isNil(val)) return;
          await cache2.set(key, {
            val,
            ts: Date.now()
          });
        },
        async delete(key) {
          await cache2.delete(key);
        }
      }
    });
    Object.defineProperties(fnMemoized, {
      cache: {
        value: cache2
      },
      cleanUp: {
        value: cleanUp
      },
      generateKey: {
        value: generateKey
      },
      shouldReuseCached: {
        value: shouldReuseCached
      },
      queryCache: {
        value: queryCache
      }
    });
    return fnMemoized;
  }
  async function __fetchVideoDetail(bvid) {
    const res = await request.get("/x/web-interface/view", {
      params: {
        bvid
      }
    });
    const json = res.data;
    const data2 = json.data;
    return data2;
  }
  const getVideoDetail = wrapWithIdbCache({
    fn: __fetchVideoDetail,
    generateKey: (bvid) => bvid,
    tableName: "video-detail",
    ttl: ms("3M"),
    concurrency: 3
  });
  async function __fetchVideoPageList(bvid) {
    const res = await request.get("/x/player/pagelist", {
      params: {
        bvid
      }
    });
    const json = res.data;
    return json?.data || [];
  }
  const getVideoPageList = wrapWithIdbCache({
    fn: __fetchVideoPageList,
    generateKey: (bvid) => bvid,
    tableName: "video-page-list",
    ttl: ms("3M"),
    concurrency: 3
  });
  async function modifyRelations(upMid, act2) {
    const uid = getUid();
    const csrf = getCsrfToken();
    const params = new URLSearchParams({
      fid: upMid,
      act: String(act2),
      re_src: "11",
      gaia_source: "web_main",
      spmid: "333.999.0.0",
      extend_content: JSON.stringify({
        entity: "user",
        entity_id: uid,
        fp: d()
      }),
      csrf
    });
    const res = await request.post("/x/relation/modify", params);
    const json = res.data;
    const success = isWebApiSuccess(json);
    if (!success) {
      toast(json.message || "未知错误");
    }
    return success;
  }
  function d() {
    let t2;
    let e;
    const i2 = (
(null === (t2 = window.reportObserver) || void 0 === t2 || null === (e = t2.cache) || void 0 === e ? void 0 : e.fpriskMsg) || {}
    );
    let n2 = "empty";
    return i2 && (n2 = `${i2.webdriver}${i2.screenResolution}${i2.platform}${i2.hardwareConcurrency}${i2.deviceMemory}${i2.colorDepth}${i2.indexedDb}${i2.language}${i2.openDatabase}${i2.touchSupport}${i2.userAgent}`), decodeURIComponent(n2);
  }
  const debug$c = baseDebug.extend("service:user:relations:blacklist");
  const blacklistAdd = blacklistActionFactory("follow");
  const blacklistRemove = blacklistActionFactory("remove");
  const UserBlacklistService = {
    add: blacklistAdd,
    remove: blacklistRemove
  };
  const {
    set: blacklistMids,
    replaceAllWith: blacklistMidsReplaceAllWith
  } = await( proxySetWithGmStorage("blacklist-mids"));
  function useInBlacklist(upMid) {
    const set2 = useSnapshot(blacklistMids);
    return !!upMid && set2.has(upMid);
  }
  function blacklistActionFactory(action2) {
    const act2 = action2 === "follow" ? 5 : 6;
    return async function blacklistAction(upMid) {
      const success = await modifyRelations(upMid, act2);
      if (success) {
        const set2 = blacklistMids;
        if (action2 === "follow") {
          set2.add(upMid);
        } else if (action2 === "remove") {
          set2.delete(upMid);
        }
      }
      return success;
    };
  }
  async function getUserBlacklist() {
    const ps = 20;
    const getPage = async (pn) => {
      const res = await request.get("/x/relation/blacks", {
        params: {
          re_version: 0,
          ps,
          pn
        }
      });
      const json = res.data;
      if (!isWebApiSuccess(json)) return;
      const total2 = json.data.total;
      const mids22 = json.data.list.map((x) => x.mid);
      return {
        total: total2,
        mids: mids22
      };
    };
    const ret = await getPage(1);
    if (!ret) return;
    const {
      total,
      mids: mids2 = []
    } = ret;
    let blackMids = mids2;
    if (total) {
      const maxPn = Math.ceil(total / ps);
      for (let pn = 2; pn <= maxPn; pn++) {
        const {
          mids: mids22 = []
        } = await getPage(pn) || {};
        blackMids = blackMids.concat(mids22);
      }
    }
    return blackMids;
  }
  (async () => {
    if (!IN_BILIBILI_HOMEPAGE) return;
    await whenIdle();
    const ids2 = await getUserBlacklist();
    debug$c("user blocklist fetched: %o", ids2);
    if (ids2) {
      blacklistMidsReplaceAllWith(ids2.map((x) => x.toString()));
    }
  })();
  var DynamicFeedEnums;
  ((DynamicFeedEnums2) => {
    ((ItemType2) => {
      ItemType2["Av"] = "DYNAMIC_TYPE_AV";
      ItemType2["Draw"] = "DYNAMIC_TYPE_DRAW";
      ItemType2["PgcUnion"] = "DYNAMIC_TYPE_PGC_UNION";
      ItemType2["UgcSeason"] = "DYNAMIC_TYPE_UGC_SEASON";
      ItemType2["Forward"] = "DYNAMIC_TYPE_FORWARD";
      ItemType2["Article"] = "DYNAMIC_TYPE_ARTICLE";
      ItemType2["LiveRcmd"] = "DYNAMIC_TYPE_LIVE_RCMD";
    })(DynamicFeedEnums2.ItemType || (DynamicFeedEnums2.ItemType = {}));
    ((AuthorType2) => {
      AuthorType2["Normal"] = "AUTHOR_TYPE_NORMAL";
      AuthorType2["Pgc"] = "AUTHOR_TYPE_PGC";
      AuthorType2["UgcSeason"] = "AUTHOR_TYPE_UGC_SEASON";
    })(DynamicFeedEnums2.AuthorType || (DynamicFeedEnums2.AuthorType = {}));
    ((MajorType2) => {
      MajorType2["Archive"] = "MAJOR_TYPE_ARCHIVE";
      MajorType2["Opus"] = "MAJOR_TYPE_OPUS";
      MajorType2["Pgc"] = "MAJOR_TYPE_PGC";
      MajorType2["UgcSeason"] = "MAJOR_TYPE_UGC_SEASON";
      MajorType2["LiveRcmd"] = "MAJOR_TYPE_LIVE_RCMD";
    })(DynamicFeedEnums2.MajorType || (DynamicFeedEnums2.MajorType = {}));
    ((AdditionalType2) => {
      AdditionalType2["Goods"] = "ADDITIONAL_TYPE_GOODS";
      AdditionalType2["Reserve"] = "ADDITIONAL_TYPE_RESERVE";
    })(DynamicFeedEnums2.AdditionalType || (DynamicFeedEnums2.AdditionalType = {}));
  })(DynamicFeedEnums || (DynamicFeedEnums = {}));
  function getArchive(item) {
    const major = item.modules.module_dynamic.major;
    if (major?.type !== "MAJOR_TYPE_ARCHIVE") return;
    return major.archive;
  }
  async function fetchKvData({
    appKey,
    nscode,
    versionId
  }) {
    const params = {
      appKey,
      nscode,
      versionId
    };
    const res = await request.get("/x/kv-frontend/namespace/data", {
      params
    });
    const json = res.data;
    return json;
  }
  function generateCacheKey({
    appKey,
    nscode
  }) {
    return new URLSearchParams([["appKey", appKey], ["nscode", nscode.toString()]]).toString();
  }
  const kvVersionCache = getIdbCache("kv-latest-version");
  const revalidateKvData = reusePendingPromise(async ({
    appKey,
    nscode
  }) => {
    const cacheKey2 = generateCacheKey({
      appKey,
      nscode
    });
    const entry = await kvVersionCache.get(cacheKey2);
    let versionId = "0";
    if (entry && entry.versionId && entry.data && Object.keys(entry.data).length) {
      versionId = entry.versionId;
    }
    const fetched = await fetchKvData({
      appKey,
      nscode,
      versionId
    });
    if (entry?.data && fetched.code === -304 && fetched.message === "Not Modified") {
      return entry.data;
    }
    await kvVersionCache.set(cacheKey2, fetched.data);
    return fetched.data.data;
  });
  const getKvData = wrapWithIdbCache({
    fn: revalidateKvData,
    tableName: "get-kv-data",
    generateKey: ({
      appKey,
      nscode
    }) => generateCacheKey({
      appKey,
      nscode
    }),
    ttl: ms("1h")
  });
  function getGroupFromKvRecord(data2 = {}, prefix2) {
    if (!prefix2.endsWith(".")) prefix2 += ".";
    const grouped = {};
    if (data2) {
      Object.keys(data2).filter((k) => k.startsWith(prefix2)).forEach((k) => {
        const key = k.slice(prefix2.length);
        const val = data2[k] || "";
        grouped[key] = val;
      });
    }
    return grouped;
  }
  const STATIC_RANK_TABS = [{
    tid: 0,
    name: "全部",
    slug: "all",
    season_type: 0,
    type: "all"
  }, {
    tid: 0,
    name: "番剧",
    slug: "anime",
    season_type: 1,
    type: "anime"
  }, {
    tid: 0,
    name: "国创",
    slug: "guochuang",
    season_type: 4,
    type: "guochuang"
  }, {
    tid: 0,
    name: "纪录片",
    slug: "documentary",
    season_type: 3,
    type: "documentary"
  }, {
    tid: 0,
    name: "电影",
    slug: "movie",
    season_type: 2,
    type: "movie"
  }, {
    tid: 0,
    name: "电视剧",
    slug: "tv",
    season_type: 5,
    type: "tv"
  }, {
    tid: 0,
    name: "综艺",
    slug: "variety",
    season_type: 7,
    type: "variety"
  }, {
    tid: 1005,
    name: "动画",
    slug: "douga",
    season_type: 0,
    type: "douga"
  }, {
    tid: 1008,
    name: "游戏",
    slug: "game",
    season_type: 0,
    type: "game"
  }, {
    tid: 1007,
    name: "鬼畜",
    slug: "kichiku",
    season_type: 0,
    type: "kichiku"
  }, {
    tid: 1003,
    name: "音乐",
    slug: "music",
    season_type: 0,
    type: "music"
  }, {
    tid: 1004,
    name: "舞蹈",
    slug: "dance",
    season_type: 0,
    type: "dance"
  }, {
    tid: 1001,
    name: "影视",
    slug: "cinephile",
    season_type: 0,
    type: "cinephile"
  }, {
    tid: 1002,
    name: "娱乐",
    slug: "ent",
    season_type: 0,
    type: "ent"
  }, {
    tid: 1010,
    name: "知识",
    slug: "knowledge",
    season_type: 0,
    type: "knowledge"
  }, {
    tid: 1012,
    name: "科技数码",
    slug: "tech",
    season_type: 0,
    type: "tech"
  }, {
    tid: 1020,
    name: "美食",
    slug: "food",
    season_type: 0,
    type: "food"
  }, {
    tid: 1013,
    name: "汽车",
    slug: "car",
    season_type: 0,
    type: "car"
  }, {
    tid: 1014,
    name: "时尚美妆",
    slug: "fashion",
    season_type: 0,
    type: "fashion"
  }, {
    tid: 1018,
    name: "体育运动",
    slug: "sports",
    season_type: 0,
    type: "sports"
  }, {
    tid: 1024,
    name: "动物",
    slug: "animal",
    season_type: 0,
    type: "animal"
  }];
  const defaultRankTab = {
    name: "全站",
    tid: 0,
    slug: "all"
  };
  async function getRankTabsConfig() {
    try {
      return await parseRankTabsConfig() || STATIC_RANK_TABS;
    } catch (e) {
      appError("parseRankTabsConfig failed", e);
      return STATIC_RANK_TABS;
    }
  }
  async function parseRankTabsConfig() {
    const _raw = await getKvData({
      appKey: "333.1339",
      nscode: 10
    });
    const record = getGroupFromKvRecord(_raw, "channel_list");
    const popular_page_sort = JSON.parse(record.popular_page_sort || "");
    if (!popular_page_sort.length) return;
    const list2 = [];
    const push = (obj) => {
      list2.push({
        tid: obj.tid || 0,
        name: obj.name,
        slug: obj.route,
        season_type: obj.seasonType || 0,
        type: obj.route
      });
    };
    for (const slug of popular_page_sort) {
      if (!record[slug]) continue;
      const obj = JSON.parse(record[slug]);
      push(obj);
    }
    return uniqBy(list2, (x) => x.slug);
  }
  var ERankApiType = ((ERankApiType2) => {
    ERankApiType2["Normal"] = "normal";
    ERankApiType2["PgcSeason"] = "pgc/season";
    ERankApiType2["PgcWeb"] = "pgc/web";
    return ERankApiType2;
  })(ERankApiType || {});
  function getRankTabRequestConfig(rankTab) {
    if (!["anime", "guochuang", "documentary", "movie", "tv", "variety"].includes(rankTab.type || "")) {
      return {
        apiType: "normal",
        url: `/x/web-interface/ranking/v2?rid=${rankTab.tid}&type=all`
      };
    }
    const {
      season_type
    } = rankTab;
    const query = `?day=3&season_type=${season_type}`;
    let url2 = `/pgc/web/rank/list${query}`;
    let apiType = "pgc/web";
    if (season_type && [2, 3, 4, 5, 7].includes(season_type)) {
      url2 = `/pgc/season/rank/web/list${query}`;
      apiType = "pgc/season";
    }
    return {
      apiType,
      url: url2
    };
  }
  function isNormalRankItem(item) {
    return item.from === "normal";
  }
  function isPgcSeasonRankItem(item) {
    return item.from === "pgc/season";
  }
  function isPgcWebRankItem(item) {
    return item.from === "pgc/web";
  }
  const XOR_CODE = 23442827791579n;
  const MASK_CODE = 2251799813685247n;
  const MAX_AID = 1n << 51n;
  const BASE = 58n;
  const data = "FcwAPNKTMug3GV5Lj7EJnHpWsx4tb8haYeviqBz6rkCy12mUSDQX9RdoZf";
  function av2bv(aid) {
    const bytes = [
      "B",
      "V",
      "1",
      "0",
      "0",
      "0",
      "0",
      "0",
      "0",
      "0",
      "0",
      "0"
    ];
    let bvIndex = bytes.length - 1;
    let tmp = (MAX_AID | BigInt(aid)) ^ XOR_CODE;
    while (tmp > 0) {
      bytes[bvIndex] = data[Number(tmp % BigInt(BASE))];
      tmp = tmp / BASE;
      bvIndex -= 1;
    }
    [bytes[3], bytes[9]] = [bytes[9], bytes[3]];
    [bytes[4], bytes[7]] = [bytes[7], bytes[4]];
    return bytes.join("");
  }
  function bv2av(bvid) {
    const bvidArr = Array.from(bvid);
    [bvidArr[3], bvidArr[9]] = [bvidArr[9], bvidArr[3]];
    [bvidArr[4], bvidArr[7]] = [bvidArr[7], bvidArr[4]];
    bvidArr.splice(0, 3);
    const tmp = bvidArr.reduce((pre, bvidChar) => pre * BASE + BigInt(data.indexOf(bvidChar)), 0n);
    return Number(tmp & MASK_CODE ^ XOR_CODE);
  }
  const IconForStatPlay = defineSvgComponent((props) => {
    return jsxs("svg", { viewBox: "0 0 24 24", fill: "currentColor", ...props, children: [
jsx$1("path", { d: "M12 4.99805C9.48178 4.99805 7.283 5.12616 5.73089 5.25202C4.65221 5.33949 3.81611 6.16352 3.72 7.23254C3.60607 8.4998 3.5 10.171 3.5 11.998C3.5 13.8251 3.60607 15.4963 3.72 16.76355C3.81611 17.83255 4.65221 18.6566 5.73089 18.7441C7.283 18.8699 9.48178 18.998 12 18.998C14.5185 18.998 16.7174 18.8699 18.2696 18.74405C19.3481 18.65655 20.184 17.8328 20.2801 16.76405C20.394 15.4973 20.5 13.82645 20.5 11.998C20.5 10.16965 20.394 8.49877 20.2801 7.23205C20.184 6.1633 19.3481 5.33952 18.2696 5.25205C16.7174 5.12618 14.5185 4.99805 12 4.99805zM5.60965 3.75693C7.19232 3.62859 9.43258 3.49805 12 3.49805C14.5677 3.49805 16.8081 3.62861 18.3908 3.75696C20.1881 3.90272 21.6118 5.29278 21.7741 7.09773C21.8909 8.3969 22 10.11405 22 11.998C22 13.88205 21.8909 15.5992 21.7741 16.8984C21.6118 18.7033 20.1881 20.09335 18.3908 20.23915C16.8081 20.3675 14.5677 20.498 12 20.498C9.43258 20.498 7.19232 20.3675 5.60965 20.2392C3.81206 20.0934 2.38831 18.70295 2.22603 16.8979C2.10918 15.5982 2 13.8808 2 11.998C2 10.1153 2.10918 8.39787 2.22603 7.09823C2.38831 5.29312 3.81206 3.90269 5.60965 3.75693z", fill: "currentColor" }),
jsx$1("path", { d: "M14.7138 10.96875C15.50765 11.4271 15.50765 12.573 14.71375 13.0313L11.5362 14.8659C10.74235 15.3242 9.75 14.7513 9.75001 13.8346L9.75001 10.1655C9.75001 9.24881 10.74235 8.67587 11.5362 9.13422L14.7138 10.96875z", fill: "currentColor" })
    ] });
  });
  const IconForStatDanmaku = defineSvgComponent((props) => {
    return jsxs("svg", { viewBox: "0 0 24 24", fill: "currentColor", ...props, children: [
jsx$1("path", { d: "M12 4.99805C9.48178 4.99805 7.283 5.12616 5.73089 5.25202C4.65221 5.33949 3.81611 6.16352 3.72 7.23254C3.60607 8.4998 3.5 10.171 3.5 11.998C3.5 13.8251 3.60607 15.4963 3.72 16.76355C3.81611 17.83255 4.65221 18.6566 5.73089 18.7441C7.283 18.8699 9.48178 18.998 12 18.998C14.5185 18.998 16.7174 18.8699 18.2696 18.74405C19.3481 18.65655 20.184 17.8328 20.2801 16.76405C20.394 15.4973 20.5 13.82645 20.5 11.998C20.5 10.16965 20.394 8.49877 20.2801 7.23205C20.184 6.1633 19.3481 5.33952 18.2696 5.25205C16.7174 5.12618 14.5185 4.99805 12 4.99805zM5.60965 3.75693C7.19232 3.62859 9.43258 3.49805 12 3.49805C14.5677 3.49805 16.8081 3.62861 18.3908 3.75696C20.1881 3.90272 21.6118 5.29278 21.7741 7.09773C21.8909 8.3969 22 10.11405 22 11.998C22 13.88205 21.8909 15.5992 21.7741 16.8984C21.6118 18.7033 20.1881 20.09335 18.3908 20.23915C16.8081 20.3675 14.5677 20.498 12 20.498C9.43258 20.498 7.19232 20.3675 5.60965 20.2392C3.81206 20.0934 2.38831 18.70295 2.22603 16.8979C2.10918 15.5982 2 13.8808 2 11.998C2 10.1153 2.10918 8.39787 2.22603 7.09823C2.38831 5.29312 3.81206 3.90269 5.60965 3.75693z", fill: "currentColor" }),
jsx$1("path", { d: "M15.875 10.75L9.875 10.75C9.46079 10.75 9.125 10.4142 9.125 10C9.125 9.58579 9.46079 9.25 9.875 9.25L15.875 9.25C16.2892 9.25 16.625 9.58579 16.625 10C16.625 10.4142 16.2892 10.75 15.875 10.75z", fill: "currentColor" }),
jsx$1("path", { d: "M17.375 14.75L11.375 14.75C10.9608 14.75 10.625 14.4142 10.625 14C10.625 13.5858 10.9608 13.25 11.375 13.25L17.375 13.25C17.7892 13.25 18.125 13.5858 18.125 14C18.125 14.4142 17.7892 14.75 17.375 14.75z", fill: "currentColor" }),
jsx$1("path", { d: "M7.875 10C7.875 10.4142 7.53921 10.75 7.125 10.75L6.625 10.75C6.21079 10.75 5.875 10.4142 5.875 10C5.875 9.58579 6.21079 9.25 6.625 9.25L7.125 9.25C7.53921 9.25 7.875 9.58579 7.875 10z", fill: "currentColor" }),
jsx$1("path", { d: "M9.375 14C9.375 14.4142 9.03921 14.75 8.625 14.75L8.125 14.75C7.71079 14.75 7.375 14.4142 7.375 14C7.375 13.5858 7.71079 13.25 8.125 13.25L8.625 13.25C9.03921 13.25 9.375 13.5858 9.375 14z", fill: "currentColor" })
    ] });
  });
  const IconForRoll = defineSvgComponent(function(props) {
    return jsxs("svg", { viewBox: "0 0 16 16", fill: "currentColor", ...props, children: [
jsx$1("path", { d: "M8.624933333333333 13.666666666666666C8.624933333333333 14.011849999999999 8.345125 14.291666666666666 7.999933333333333 14.291666666666666C4.525166666666666 14.291666666666666 1.7082933333333332 11.474791666666665 1.7082933333333332 8C1.7082933333333332 6.013308333333333 2.629825 4.2414233333333335 4.066321666666667 3.089385C4.335603333333333 2.8734283333333335 4.728959999999999 2.9166533333333335 4.944915 3.1859349999999997C5.160871666666666 3.4552099999999997 5.1176466666666665 3.848573333333333 4.848366666666666 4.0645283333333335C3.694975 4.98953 2.9582933333333328 6.40852 2.9582933333333328 8C2.9582933333333328 10.784416666666667 5.215528333333333 13.041666666666666 7.999933333333333 13.041666666666666C8.345125 13.041666666666666 8.624933333333333 13.321483333333333 8.624933333333333 13.666666666666666zM11.060475 12.810558333333333C10.844225000000002 12.541558333333331 10.887033333333335 12.148125 11.156041666666667 11.931875C12.306858333333333 11.006775 13.041599999999999 9.589424999999999 13.041599999999999 8C13.041599999999999 5.215561666666666 10.784408333333332 2.958333333333333 7.999933333333333 2.958333333333333C7.6548083333333325 2.958333333333333 7.374933333333333 2.6785083333333333 7.374933333333333 2.333333333333333C7.374933333333333 1.9881533333333332 7.6548083333333325 1.7083333333333333 7.999933333333333 1.7083333333333333C11.474725000000001 1.7083333333333333 14.291599999999999 4.525206666666667 14.291599999999999 8C14.291599999999999 9.984108333333333 13.372483333333332 11.753958333333332 11.939225 12.906125C11.670166666666663 13.122375 11.276725 13.079625 11.060475 12.810558333333333z", fill: "currentColor" }),
jsx$1("path", { d: "M1.375 3.4130866666666666C1.375 3.0679066666666666 1.654825 2.7880866666666666 2 2.7880866666666666L4.333333333333333 2.7880866666666666C4.862608333333333 2.7880866666666666 5.291666666666666 3.2171449999999995 5.291666666666666 3.7464199999999996L5.291666666666666 6.079753333333334C5.291666666666666 6.424928333333334 5.011841666666666 6.704736666666666 4.666666666666666 6.704736666666666C4.321491666666667 6.704736666666666 4.041666666666666 6.424928333333334 4.041666666666666 6.079753333333334L4.041666666666666 4.038086666666667L2 4.038086666666667C1.654825 4.038086666666667 1.375 3.7582616666666664 1.375 3.4130866666666666z", fill: "currentColor" }),
jsx$1("path", { d: "M14.625 12.5864C14.625 12.931591666666666 14.345183333333333 13.2114 14 13.2114L11.666666666666666 13.2114C11.137408333333335 13.2114 10.708333333333332 12.782383333333332 10.708333333333332 12.253066666666665L10.708333333333332 9.919733333333333C10.708333333333332 9.574608333333334 10.98815 9.294733333333333 11.333333333333332 9.294733333333333C11.678516666666667 9.294733333333333 11.958333333333332 9.574608333333334 11.958333333333332 9.919733333333333L11.958333333333332 11.9614L14 11.9614C14.345183333333333 11.9614 14.625 12.241275000000002 14.625 12.5864z", fill: "currentColor" })
    ] });
  });
  function parseDuration(d2) {
    if (!d2) return 0;
    const units = [1, 60, 360];
    const splited = d2.split(":").map(Number).reverse();
    const total = splited.reduce((total2, cur, index) => {
      return total2 + cur * units[index];
    }, 0);
    return total;
  }
  function formatDuration(d2) {
    d2 ||= 0;
    return dayjs.duration(d2 || 0, "seconds").format(d2 >= 3600 ? "HH:mm:ss" : "mm:ss");
  }
  function formatCount(count) {
    if (!count) {
      if (typeof count === "number") return "0";
      else return count;
    }
    if (count <= 9999) {
      return count.toString();
    }
    const trimDotZero = (s2) => s2.replace(/\.0$/, "");
    count /= 1e4;
    if (count <= 9999) {
      const c2 = trimDotZero(count.toFixed(1));
      return `${c2}万`;
    }
    count /= 1e4;
    if (count <= 9999) {
      const c2 = trimDotZero(count.toFixed(1));
      return `${c2}亿`;
    }
    console.warn(`formatCount(count = ${count}); can not handle input`);
  }
  function parseCount(str) {
    if (!str) return;
    if (str === "-") return 0;
    if (/^\d+$/.test(str)) return Number(str);
    if (/^\d+(?:\.\d+)?万$/.test(str)) return Number(str.slice(0, -1)) * 1e4;
    if (/^\d+(?:\.\d+)?亿$/.test(str)) return Number(str.slice(0, -1)) * 1e8;
  }
  const currentYear = dayjs().format("YYYY");
  function formatTimeStamp(unixTs, includeTime = false) {
    if (!unixTs) return "";
    const t2 = dayjs.unix(unixTs);
    const extraFormat = includeTime ? " HH:mm" : "";
    if (t2.format("YYYY") === currentYear) {
      return t2.format(`M-D${extraFormat}`);
    } else {
      return t2.format(`YY-M-D${extraFormat}`);
    }
  }
  function isRecentTimeStamp(ts) {
    const yesterdayStart = dayjs().subtract(1, "day").startOf("day").unix();
    return ts >= yesterdayStart;
  }
  function formatRecentTimeStamp(ts, zhDate) {
    if (!ts) return;
    const t2 = dayjs.unix(ts);
    const isToday = t2.format(
      "YYYY-MM-DD"
) === dayjs().format(
      "YYYY-MM-DD"
);
    const isTodayRecent = isToday && Date.now() - ts * 1e3 <= ms("12h");
    const isYesterday = t2.format(
      "YYYY-MM-DD"
) === dayjs().subtract(1, "day").format(
      "YYYY-MM-DD"
);
    const isCurrentYear = t2.format(
      "YYYY"
) === dayjs().format(
      "YYYY"
);
    if (isTodayRecent) {
      const minutes = dayjs().diff(t2, "minutes");
      const hours = dayjs().diff(t2, "hours");
      if (minutes < 1) {
        return "刚刚";
      } else if (minutes < 60) {
        return `${minutes}分钟前`;
      } else {
        return `${hours}小时前`;
      }
    }
    if (isToday) return t2.format(
      "今天 HH:mm"
);
    if (isYesterday) return t2.format(
      "昨天 HH:mm"
);
    if (isCurrentYear) {
      return t2.format(
        "M月D日"

);
    } else {
      return t2.format(
        "YYYY年M月D日"

);
    }
  }
  const VideoStateMap = {
    "1": "橙色通过",
    "0": "开放浏览",
    "-1": "待审",
    "-2": "被打回",
    "-3": "网警锁定",
    "-4": "被锁定",
    "-5": "管理员锁定",
    "-6": "修复待审",
    "-7": "暂缓审核",
    "-8": "补档待审",
    "-9": "等待转码",
    "-10": "延迟审核",
    "-11": "视频源待修",
    "-12": "转储失败",
    "-13": "允许评论待审",
    "-14": "临时回收站",
    "-15": "分发中",
    "-16": "转码失败",
    "-20": "创建未提交",
    "-30": "创建已提交",
    "-40": "定时发布",
    "-100": "用户删除"
  };
  function getVideoInvalidReason(state2) {
    if (state2 === void 0) return;
    if (state2 >= 0) return;
    return VideoStateMap[state2];
  }
  const iconParkOutlineThumbsUp = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, d: "M27.6 18.6v-7.2A5.4 5.4 0 0 0 22.2 6L15 22.2V42h20.916a3.6 3.6 0 0 0 3.6-3.06L42 22.74a3.6 3.6 0 0 0-3.6-4.14zM15 22h-4.806C8.085 21.963 6.283 23.71 6 25.8v12.6a4.16 4.16 0 0 0 4.194 3.6H15z" })
  ] });
  const ForwardRef$E = reactExports.forwardRef(iconParkOutlineThumbsUp);
  const tablerHeartFilled = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M6.979 3.074a6 6 0 0 1 4.988 1.425l.037.033l.034-.03a6 6 0 0 1 4.733-1.44l.246.036a6 6 0 0 1 3.364 10.008l-.18.185l-.048.041l-7.45 7.379a1 1 0 0 1-1.313.082l-.094-.082l-7.493-7.422A6 6 0 0 1 6.979 3.074" })
  ] });
  const ForwardRef$D = reactExports.forwardRef(tablerHeartFilled);
  const tablerCoinYen = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsx$1("path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 1 0-18 0m6 0h6m-6 3h6M9 8l3 4.5" }),
jsx$1("path", { d: "m15 8l-3 4.5V17" })
    ] })
  ] });
  const ForwardRef$C = reactExports.forwardRef(tablerCoinYen);
  const iconParkOutlinePreviewOpen = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M24 36c11.046 0 20-12 20-12s-8.954-12-20-12S4 24 4 24s8.954 12 20 12Z" }),
jsx$1("path", { d: "M24 29a5 5 0 1 0 0-10a5 5 0 0 0 0 10Z" })
    ] })
  ] });
  const ForwardRef$B = reactExports.forwardRef(iconParkOutlinePreviewOpen);
  const tablerMessageCircle = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "m3 20l1.3-3.9C1.976 12.663 2.874 8.228 6.4 5.726c3.526-2.501 8.59-2.296 11.845.48c3.255 2.777 3.695 7.266 1.029 10.501S11.659 20.922 7.7 19z" })
  ] });
  const ForwardRef$A = reactExports.forwardRef(tablerMessageCircle);
  const tablerArrowForwardUp = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsx$1("path", { d: "m15 14l4-4l-4-4" }),
jsx$1("path", { d: "M19 10H8a4 4 0 1 0 0 8h1" })
    ] })
  ] });
  const ForwardRef$z = reactExports.forwardRef(tablerArrowForwardUp);
  function defineStatItems(items) {
    return items;
  }
  const clsForBiliIcon = "size-18px";
  const clsForThirdPartyIcon = "size-16px";
  const StatFieldIconConfig = {
    "play": jsx$1(IconForStatPlay, { className: clsForBiliIcon }),
"danmaku": jsx$1(IconForStatDanmaku, { className: clsForBiliIcon }),
    "like": jsx$1(ForwardRef$E, { className: clsForThirdPartyIcon }),
    "bangumi:follow": jsx$1(ForwardRef$D, { className: clsForThirdPartyIcon }),
    "favorite": jsx$1(IconForFav, { className: clsForThirdPartyIcon }),
    "coin": jsx$1(ForwardRef$C, { className: clsForThirdPartyIcon }),
    "live:viewed-by": jsx$1(ForwardRef$B, { className: clsForThirdPartyIcon }),
    "dynamic-feed:comment": jsx$1(ForwardRef$A, { className: clsForThirdPartyIcon }),
    "dynamic-feed:forward": jsx$1(ForwardRef$z, { className: clsForThirdPartyIcon })
  };
  const StatItemDisplay = reactExports.memo(function({
    field,
    value
  }) {
    const text = reactExports.useMemo(() => {
      if (typeof value === "number" || value && /^\d+$/.test(value)) {
        return formatCount(Number(value)) ?? STAT_NUMBER_FALLBACK;
      } else {
        return value ?? STAT_NUMBER_FALLBACK;
      }
    }, [value]);
    const icon = StatFieldIconConfig[field];
    return jsxs("span", { "data-field": field, className: "bili-video-card__stats--item gap-x-2px mr-0!", children: [
      icon,
jsx$1("span", { className: clsx("bili-video-card__stats--text line-height-18px"), children: text })
    ] });
  });
  var PcRecGoto = ((PcRecGoto2) => {
    PcRecGoto2["AV"] = "av";
    PcRecGoto2["Ad"] = "ad";
    PcRecGoto2["Live"] = "live";
    return PcRecGoto2;
  })(PcRecGoto || {});
  const radixIconsPerson = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 15 15", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M7.5.875A3.626 3.626 0 0 1 11.127 4.5A3.624 3.624 0 0 1 8.5 7.983c1.197.145 2.224.568 2.997 1.33c.981.967 1.478 2.408 1.478 4.288a.475.475 0 0 1-.949 0c0-1.72-.453-2.88-1.196-3.613c-.745-.733-1.856-1.113-3.33-1.113c-1.472 0-2.584.38-3.328 1.113s-1.197 1.893-1.197 3.613a.475.475 0 0 1-.949 0c0-1.88.497-3.32 1.479-4.289c.772-.76 1.799-1.183 2.995-1.328a3.627 3.627 0 0 1 1-7.109m0 .95a2.676 2.676 0 1 0 0 5.35a2.676 2.676 0 0 0 0-5.35" })
  ] });
  const ForwardRef$y = reactExports.forwardRef(radixIconsPerson);
  const mynauiUsersGroup = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.5, d: "M17 19.5c0-1.657-2.239-3-5-3s-5 1.343-5 3m14-3c0-1.23-1.234-2.287-3-2.75M3 16.5c0-1.23 1.234-2.287 3-2.75m12-4.014a3 3 0 1 0-4-4.472M6 9.736a3 3 0 0 1 4-4.472m2 8.236a3 3 0 1 1 0-6a3 3 0 0 1 0 6" })
  ] });
  const ForwardRef$x = reactExports.forwardRef(mynauiUsersGroup);
  const tablerPlus = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 5v14m-7-7h14" })
  ] });
  const ForwardRef$w = reactExports.forwardRef(tablerPlus);
  const IconForUp = ForwardRef$y;
  const IconForGroup = ForwardRef$x;
  const IconForPopoverTrigger = ForwardRef$w;
  function formatFollowGroupUrl(followGroupId) {
    return `https://space.bilibili.com/${getUid()}/fans/follow?tagid=${followGroupId}`;
  }
  function formatSpaceUrl(mid) {
    return `https://space.bilibili.com/${mid}`;
  }
  const cache$2 = dailyCache("w_webid");
  const get_w_webId = reusePendingPromise(async () => {
    const cached2 = await cache$2.get();
    if (cached2) return cached2;
    return fetch_w_webId();
  });
  async function fetch_w_webId() {
    const mid = getUid();
    if (!mid) return;
    const spacePageUrl = formatSpaceUrl(mid);
    const res = await request.get(spacePageUrl, {
      responseType: "text",
      withCredentials: true
    });
    const html = res.data;
    const parser = new DOMParser();
    const parsed2 = parser.parseFromString(html, "text/html");
    const jsonText = decodeURIComponent(parsed2.getElementById("__RENDER_DATA__")?.textContent?.trim() || "");
    if (!jsonText) return;
    const id2 = JSON.parse(jsonText)?.access_id;
    if (id2) await cache$2.set(id2);
    return id2;
  }
  async function getAllFollowGroups({
    removeEmpty = true
  } = {}) {
    const params = await encWbi({
      web_location: "0.0",
      w_webid: await get_w_webId() || ""
    });
    const res = await request.get("/x/relation/tags", {
      params
    });
    const json = res.data;
    const groups = json.data || [];
    if (removeEmpty) {
      return groups.filter((x) => !!x.count);
    }
    return groups;
  }
  async function getFollowGroupContent(tagid) {
    const ps = 20;
    const singleRequest = async (page) => {
      const res = await request.get("/x/relation/tag", {
        params: {
          mid: getUid(),
          tagid,
          pn: page,
          ps
        }
      });
      const json = res.data;
      return json.data || [];
    };
    let pn = 1;
    let items = [];
    let currentPageItems = [];
    do {
      currentPageItems = await singleRequest(pn);
      items = items.concat(currentPageItems);
      pn++;
    } while (currentPageItems.length === ps);
    const mids2 = uniq(items.map((x) => x.mid));
    return mids2;
  }
  async function getRecentUpdateUpList() {
    const res = await request.get("/x/polymer/web-dynamic/v1/portal");
    const json = res.data;
    const list2 = json?.data?.up_list || [];
    return list2;
  }
  var DynamicFeedQueryKey = ((DynamicFeedQueryKey2) => {
    DynamicFeedQueryKey2["Mid"] = "dyn-mid";
    DynamicFeedQueryKey2["GroupId"] = "dyn-group-id";
    DynamicFeedQueryKey2["FilterTextFull"] = "dyn-filter-text";
    DynamicFeedQueryKey2["FilterTextShort"] = "dyn-filter";
    DynamicFeedQueryKey2["Offset"] = "dyn-offset";
    DynamicFeedQueryKey2["MinId"] = "dyn-min-id";
    DynamicFeedQueryKey2["MinTs"] = "dyn-min-ts";
    return DynamicFeedQueryKey2;
  })(DynamicFeedQueryKey || {});
  const searchParams$3 = new URLSearchParams(location.search);
  const QUERY_DYNAMIC_UP_MID = searchParams$3.get(
    "dyn-mid"
)?.trim();
  const QUERY_DYNAMIC_GROUP_ID = searchParams$3.get(
    "dyn-group-id"
)?.trim() ? Number(searchParams$3.get(
    "dyn-group-id"
).trim()) : void 0;
  const QUERY_DYNAMIC_OFFSET = searchParams$3.get(
    "dyn-offset"
) || void 0;
  const QUERY_DYNAMIC_FILTER_TEXT = QUERY_DYNAMIC_UP_MID ? searchParams$3.get(
    "dyn-filter-text"
) || searchParams$3.get(
    "dyn-filter"
) || void 0 : void 0;
  const QUERY_DYNAMIC_MIN_ID = QUERY_DYNAMIC_UP_MID ? searchParams$3.get(
    "dyn-min-id"
) : void 0;
  const QUERY_DYNAMIC_MIN_TS = QUERY_DYNAMIC_MIN_ID ? searchParams$3.get(
    "dyn-min-ts"
) : void 0;
  const SHOW_DYNAMIC_FEED_ONLY = IN_BILIBILI_HOMEPAGE && (!!QUERY_DYNAMIC_UP_MID || QUERY_DYNAMIC_GROUP_ID !== void 0);
  let upMidInitial;
  let upNameInitial;
  let groupIdInitial;
  if (SHOW_DYNAMIC_FEED_ONLY) {
    if (QUERY_DYNAMIC_UP_MID) {
      upMidInitial = QUERY_DYNAMIC_UP_MID;
      upNameInitial = searchParams$3.get("dyn-name") ?? upMidInitial?.toString() ?? void 0;
    } else if (QUERY_DYNAMIC_GROUP_ID !== void 0) {
      groupIdInitial = QUERY_DYNAMIC_GROUP_ID;
    }
  }
  var DynamicFeedVideoType = ((DynamicFeedVideoType2) => {
    DynamicFeedVideoType2["All"] = "all";
    DynamicFeedVideoType2["UploadOnly"] = "upload-only";
    DynamicFeedVideoType2["DynamicOnly"] = "dynamic-only";
    return DynamicFeedVideoType2;
  })(DynamicFeedVideoType || {});
  var DynamicFeedBadgeText = ((DynamicFeedBadgeText2) => {
    DynamicFeedBadgeText2["Upload"] = "投稿视频";
    DynamicFeedBadgeText2["Dynamic"] = "动态视频";
    DynamicFeedBadgeText2["ChargeOnly"] = "充电专属";
    return DynamicFeedBadgeText2;
  })(DynamicFeedBadgeText || {});
  const DynamicFeedVideoTypeLabel = {
    [
      "all"
]: "全部",
    [
      "upload-only"
]: "仅投稿视频",
    [
      "dynamic-only"
]: "仅动态视频"
  };
  var DynamicFeedVideoMinDuration = ((DynamicFeedVideoMinDuration2) => {
    DynamicFeedVideoMinDuration2["All"] = "all";
    DynamicFeedVideoMinDuration2["_5m"] = "5min";
    DynamicFeedVideoMinDuration2["_2m"] = "2min";
    DynamicFeedVideoMinDuration2["_1m"] = "1min";
    DynamicFeedVideoMinDuration2["_30s"] = "30s";
    DynamicFeedVideoMinDuration2["_10s"] = "10s";
    return DynamicFeedVideoMinDuration2;
  })(DynamicFeedVideoMinDuration || {});
  const DynamicFeedVideoMinDurationConfig = {
[
      "all"
]: {
      label: "全部时长",
      duration: 0
    },
    [
      "5min"
]: {
      label: "5分钟",
      duration: 5 * 60
    },
    [
      "2min"
]: {
      label: "2分钟",
      duration: 2 * 60
    },
    [
      "1min"
]: {
      label: "1分钟",
      duration: 60
    },
    [
      "30s"
]: {
      label: "30秒",
      duration: 30
    },
    [
      "10s"
]: {
      label: "10秒",
      duration: 10
    }
  };
  const DF_SELECTED_KEY_ALL = "all";
  const DF_SELECTED_KEY_PREFIX_UP = "up:";
  const DF_SELECTED_KEY_PREFIX_GROUP = "group:";
  const hideChargeOnlyVideosForKeysSet = (await( proxySetWithGmStorage("dynamic-feed:hide-charge-only-videos-for-keys"))).set;
  const addSeparatorsMap = (await( proxyMapWithGmStorage("dynamic-feed:add-separators"))).map;
  const dfStore = createDfStore();
  function createDfStore() {
    return proxy({
      upMid: upMidInitial,
      upName: upNameInitial,
      upFace: void 0,
      upList: [],
      upListUpdatedAt: 0,
      groups: [],
      groupsUpdatedAt: 0,
      selectedGroupId: groupIdInitial,
      get selectedGroup() {
        if (typeof this.selectedGroupId !== "number") return;
        return this.groups.find((x) => x.tagid === this.selectedGroupId);
      },
      dynamicFeedVideoType: "all",
      filterText: QUERY_DYNAMIC_FILTER_TEXT ?? void 0,
get viewingAll() {
        return this.selectedKey === DF_SELECTED_KEY_ALL;
      },
      get viewingSomeUp() {
        return !!this.upMid;
      },
      get viewingSomeGroup() {
        return typeof this.selectedGroupId === "number";
      },
get selectedKey() {
        if (this.upMid) return `${DF_SELECTED_KEY_PREFIX_UP}${this.upMid}`;
        if (this.selectedGroupId !== void 0) return `${DF_SELECTED_KEY_PREFIX_GROUP}${this.selectedGroupId}`;
        return DF_SELECTED_KEY_ALL;
      },
      hideChargeOnlyVideosForKeysSet,
      get hideChargeOnlyVideos() {
        return this.hideChargeOnlyVideosForKeysSet.has(this.selectedKey);
      },
      addSeparatorsMap,
      get addSeparators() {
        return this.addSeparatorsMap.get("global") ?? false;
      },
      filterMinDuration: "all",
      get filterMinDurationValue() {
        return DynamicFeedVideoMinDurationConfig[this.filterMinDuration].duration;
      },
updateUpList,
      updateGroups
    });
  }
  proxy({
    followGroupInfo: {}
  });
  async function updateUpList(force = false) {
    const cacheHit = !force && dfStore.upList.length && dfStore.upListUpdatedAt && dfStore.upListUpdatedAt - Date.now() < ms("5min");
    if (cacheHit) return;
    const list2 = await getRecentUpdateUpList();
    dfStore.upList = list2;
    dfStore.upListUpdatedAt = Date.now();
  }
  async function updateGroups(force = false) {
    {
      const {
        followGroup,
        whenViewAll
      } = settings.dynamicFeed;
      const enabled2 = followGroup.enabled || !!whenViewAll.hideIds.filter((x) => x.startsWith(DF_SELECTED_KEY_PREFIX_GROUP)).length;
      if (!enabled2) return;
    }
    const cacheHit = !force && dfStore.groups.length && dfStore.groupsUpdatedAt && dfStore.groupsUpdatedAt - Date.now() < ms("1h");
    if (cacheHit) return;
    dfStore.groups = await getAllFollowGroups({
      removeEmpty: true
    });
    dfStore.groupsUpdatedAt = Date.now();
  }
  function updateFilterData() {
    if (!getUid()) return;
    return Promise.all([updateUpList(), updateGroups()]);
  }
  void (async () => {
    if (!IN_BILIBILI_HOMEPAGE) return;
    await delay$1(5e3);
    if (!dfStore.upList.length || !dfStore.groups.length) {
      await whenIdle();
      updateFilterData();
    }
  })();
  if (QUERY_DYNAMIC_UP_MID) {
    subscribeOnKeys(dfStore, ["upName", "filterText", "selectedGroup", "viewingSomeUp", "viewingAll"], ({
      upName,
      filterText,
      selectedGroup,
      viewingSomeUp,
      viewingAll
    }) => {
      let title = viewingAll ? "动态" : viewingSomeUp ? `「${upName}」的动态` : `「${selectedGroup?.name}」分组动态`;
      if (filterText) {
        title = `🔍【${filterText}】 - ${title}`;
      }
      setPageTitle(title);
    });
  }
  function dynamicFeedDetectAd(item) {
    const {
      major,
      additional
    } = item.modules.module_dynamic;
    if (additional?.type === DynamicFeedEnums.AdditionalType.Goods) return true;
    if (major?.type === DynamicFeedEnums.MajorType.Opus) {
      const title = major.opus.title || "";
      if (["B站密令", "大红包"].some((keyword) => title.includes(keyword))) {
        return true;
      }
    }
    return false;
  }
  function normalizeDynamicFeedItem(item) {
    if (dynamicFeedDetectAd(item)) return;
    const major = item.modules.module_dynamic.major;
    if (!major) return;
    const author = item.modules.module_author;
    const additional = item.modules.module_dynamic.additional;
    const majorType = major.type;
    const sharedCardData = {
      authorName: author.name,
      authorFace: author.face,
      authorMid: author.mid.toString(),
      followed: author.following,
      pubts: author.pub_ts,
statItems: defineStatItems([{
        field: "like",
        value: item.modules.module_stat.like.count
      }, {
        field: "dynamic-feed:comment",
        value: item.modules.module_stat.comment.count
      }, {
        field: "dynamic-feed:forward",
        value: item.modules.module_stat.forward.count
      }]),
      recommendReason: author.pub_action
    };
    if (majorType === DynamicFeedEnums.MajorType.Archive && major.archive) {
      const v = major.archive;
      return {
        ...sharedCardData,
avid: v.aid,
        bvid: v.bvid,
goto: "av",
        href: `/video/${v.bvid}/`,
        title: v.title,
        cover: v.cover,
        duration: parseDuration(v.duration_text) || 0,
        durationStr: v.duration_text,
recommendReason: v.badge.text === DynamicFeedBadgeText.Upload ? v.badge.text : void 0,
        topMarkIcon: v.badge.text === DynamicFeedBadgeText.Upload ? void 0 : v.badge.icon_url ?? void 0,
        topMarkText: v.badge.text === DynamicFeedBadgeText.Upload ? void 0 : v.badge.text,
statItems: defineStatItems([{
          field: "play",
          value: v.stat.play
        }, {
          field: "danmaku",
          value: v.stat.danmaku
        }]),
        play: parseCount(v.stat.play),
        danmaku: parseCount(v.stat.danmaku)
      };
    }
    if (majorType === DynamicFeedEnums.MajorType.Opus && major.opus) {
      const {
        opus
      } = major;
      const hasPic = !!opus.pics?.length;
      const isReserve = additional?.type === DynamicFeedEnums.AdditionalType.Reserve;
      const isLiveReserve = isReserve && /直播预告/.test(additional.reserve.title);
      const topMarkText = (() => {
        if (isLiveReserve) return "直播预告";
        if (isReserve) return additional.reserve.title?.split("：")[0] || "预约";
        if (item.type === DynamicFeedEnums.ItemType.Draw) return hasPic ? "图片" : "文字动态";
        if (item.type === DynamicFeedEnums.ItemType.Article) return "专栏";
      })();
      return {
        ...sharedCardData,
        goto: "opus",
        href: opus.jump_url,
        cover: opus.pics?.[0]?.url,
        title: opus.title || opus.summary?.text || "",
        topMarkText
      };
    }
    if (majorType === DynamicFeedEnums.MajorType.Pgc && major.pgc) {
      const {
        pgc
      } = major;
      return {
        ...sharedCardData,
        cover: pgc.cover,
        goto: "bangumi",
        href: pgc.jump_url,
        title: pgc.title,
        statItems: defineStatItems([{
          field: "play",
          value: pgc.stat.play
        }, {
          field: "danmaku",
          value: pgc.stat.danmaku
        }]),
        topMarkText: author.label,
pubts: author.pub_ts,
pubdateDisplay: author.pub_time
};
    }
    if (majorType === DynamicFeedEnums.MajorType.UgcSeason && major.ugc_season) {
      const {
        ugc_season
      } = major;
      return {
        ...sharedCardData,
        bvid: ugc_season.bvid,
        avid: ugc_season.aid.toString(),
        goto: "av",
        duration: parseDuration(ugc_season.duration_text),
        durationStr: ugc_season.duration_text,
        cover: ugc_season.cover,
        href: `/video/${ugc_season.bvid}/`,
        title: ugc_season.title,
        statItems: defineStatItems([{
          field: "play",
          value: ugc_season.stat.play
        }, {
          field: "danmaku",
          value: ugc_season.stat.danmaku
        }]),
        play: parseCount(ugc_season.stat.play),
        danmaku: parseCount(ugc_season.stat.danmaku),
        recommendReason: author.pub_action,
        topMarkText: "合集",
authorMid: void 0
      };
    }
  }
  var castComparer = function(comparer) {
    return function(a2, b, order) {
      return comparer(a2, b, order) * order;
    };
  };
  var throwInvalidConfigErrorIfTrue = function(condition, context) {
    if (condition)
      throw Error("Invalid sort config: " + context);
  };
  var unpackObjectSorter = function(sortByObj) {
    var _a = sortByObj || {}, asc = _a.asc, desc = _a.desc;
    var order = asc ? 1 : -1;
    var sortBy = asc || desc;
    throwInvalidConfigErrorIfTrue(!sortBy, "Expected `asc` or `desc` property");
    throwInvalidConfigErrorIfTrue(asc && desc, "Ambiguous object with `asc` and `desc` config properties");
    var comparer = sortByObj.comparer && castComparer(sortByObj.comparer);
    return { order, sortBy, comparer };
  };
  var multiPropertySorterProvider = function(defaultComparer2) {
    return function multiPropertySorter(sortBy, sortByArr, depth, order, comparer, a2, b) {
      var valA;
      var valB;
      if (typeof sortBy === "string") {
        valA = a2[sortBy];
        valB = b[sortBy];
      } else if (typeof sortBy === "function") {
        valA = sortBy(a2);
        valB = sortBy(b);
      } else {
        var objectSorterConfig = unpackObjectSorter(sortBy);
        return multiPropertySorter(objectSorterConfig.sortBy, sortByArr, depth, objectSorterConfig.order, objectSorterConfig.comparer || defaultComparer2, a2, b);
      }
      var equality = comparer(valA, valB, order);
      if ((equality === 0 || valA == null && valB == null) && sortByArr.length > depth) {
        return multiPropertySorter(sortByArr[depth], sortByArr, depth + 1, order, comparer, a2, b);
      }
      return equality;
    };
  };
  function getSortStrategy(sortBy, comparer, order) {
    if (sortBy === void 0 || sortBy === true) {
      return function(a2, b) {
        return comparer(a2, b, order);
      };
    }
    if (typeof sortBy === "string") {
      throwInvalidConfigErrorIfTrue(sortBy.includes("."), "String syntax not allowed for nested properties.");
      return function(a2, b) {
        return comparer(a2[sortBy], b[sortBy], order);
      };
    }
    if (typeof sortBy === "function") {
      return function(a2, b) {
        return comparer(sortBy(a2), sortBy(b), order);
      };
    }
    if (Array.isArray(sortBy)) {
      var multiPropSorter_1 = multiPropertySorterProvider(comparer);
      return function(a2, b) {
        return multiPropSorter_1(sortBy[0], sortBy, 1, order, comparer, a2, b);
      };
    }
    var objectSorterConfig = unpackObjectSorter(sortBy);
    return getSortStrategy(objectSorterConfig.sortBy, objectSorterConfig.comparer || comparer, objectSorterConfig.order);
  }
  var sortArray = function(order, ctx, sortBy, comparer) {
    var _a;
    if (!Array.isArray(ctx)) {
      return ctx;
    }
    if (Array.isArray(sortBy) && sortBy.length < 2) {
      _a = sortBy, sortBy = _a[0];
    }
    return ctx.sort(getSortStrategy(sortBy, comparer, order));
  };
  function createNewSortInstance(opts) {
    var comparer = castComparer(opts.comparer);
    return function(arrayToSort) {
      var ctx = Array.isArray(arrayToSort) && !opts.inPlaceSorting ? arrayToSort.slice() : arrayToSort;
      return {
        asc: function(sortBy) {
          return sortArray(1, ctx, sortBy, comparer);
        },
        desc: function(sortBy) {
          return sortArray(-1, ctx, sortBy, comparer);
        },
        by: function(sortBy) {
          return sortArray(1, ctx, sortBy, comparer);
        }
      };
    };
  }
  var defaultComparer = function(a2, b, order) {
    if (a2 == null)
      return order;
    if (b == null)
      return -order;
    if (typeof a2 !== typeof b) {
      return typeof a2 < typeof b ? -1 : 1;
    }
    if (a2 < b)
      return -1;
    if (a2 > b)
      return 1;
    return 0;
  };
  var sort = createNewSortInstance({
    comparer: defaultComparer
  });
  createNewSortInstance({
    comparer: defaultComparer,
    inPlaceSorting: true
  });
  function fastOrderBy(list2, props, orders) {
    if (props.length !== orders.length) throw new Error("props & orders length not match");
    const _by = props.map((prop, index) => {
      const order = orders[index];
      if (order === "asc") return { asc: prop };
      else if (order === "desc") return { desc: prop };
      return {
        asc: prop,
        comparer: order
      };
    });
    return sort(list2).by(_by);
  }
  function fastSortWithRules(list2, rules2) {
    const _by = rules2.map(({ order, prop }) => {
      if (order === "asc") return { asc: prop };
      else if (order === "desc") return { desc: prop };
      return {
        asc: prop,
        comparer: order
      };
    });
    return sort(list2).by(_by);
  }
  function mapNameForSort(name) {
    return name.replace(/([A-Z])/, "999999$1").replace(/([a-z])/, "999998$1");
  }
  function zhLocaleComparer(a2, b) {
    return a2.localeCompare(b, "zh-CN");
  }
  function sortListByName(entries, prop) {
    return fastSortWithRules(entries, [{
      prop: (item) => {
        const val = typeof prop === "function" ? prop(item) : item[prop];
        return mapNameForSort(val);
      },
      order: zhLocaleComparer
    }]);
  }
  function assertNever(x) {
    throw new Error(`Unexpected object: ${x}`);
  }
  function mapFavFolderTitleForSort(title) {
    title = title.replace(new RegExp("^[\\s\\p{RGI_Emoji}]+", "v"), "");
    title = mapNameForSort(title);
    return title;
  }
  function sortFavFolders(originalFolders, order) {
    const ruleDefaultFirst = {
      prop: (f2) => isFavFolderDefault(f2.attr) ? 1 : 0,
      order: "desc"
    };
    const ruleByNameAsc = {
      prop: (f2) => mapFavFolderTitleForSort(f2.title),
      order: zhLocaleComparer
    };
    const ruleByCountDesc = {
      prop: "media_count",
      order: "desc"
    };
    if (order === "default") return originalFolders;
    if (order === "name") return fastSortWithRules(originalFolders, [ruleDefaultFirst, ruleByNameAsc]);
    if (order === "count") return fastSortWithRules(originalFolders, [ruleDefaultFirst, ruleByCountDesc, ruleByNameAsc]);
    assertNever(order);
  }
  function FavFolderOrderSwitcher(props) {
    return jsx$1(Segmented, { size: "middle", options: [{
      label: "默认",
      value: "default"
    }, {
      label: "名称",
      value: "name"
    }, {
      label: "数量",
      value: "count"
    }], ...props });
  }
  class BaseTabService {
    qs;
    constructor(qsPageSize) {
      this.qs = new QueueStrategy(qsPageSize);
    }
    get hasMore() {
      return !!this.qs.bufferQueue.length || this.hasMoreExceptQueue;
    }
    restore() {
      this.qs.restore();
    }
    async loadMore(abortSignal) {
      if (!this.hasMore) return;
      if (this.qs.bufferQueue.length) return this.qs.sliceFromQueue();
      const more = await this.fetchMore(abortSignal);
      if (more?.length) this.qs.bufferQueue.push(...more);
      return this.qs.sliceFromQueue();
    }
  }
  class QueueStrategy {
returnQueue = [];
    bufferQueue = [];
    get hasCache() {
      return !!this.returnQueue.length;
    }
    ps;
    constructor(ps = 20) {
      this.ps = ps;
    }
    sliceCountFromQueue(count) {
      if (this.bufferQueue.length) {
        const sliced = this.bufferQueue.slice(0, count);
        this.bufferQueue = this.bufferQueue.slice(count);
        return this.doReturnItems(sliced) ?? [];
      } else {
        return [];
      }
    }
    sliceFromQueue(page = 1) {
      return this.sliceCountFromQueue(this.ps * page);
    }
doReturnItems(items) {
      this.returnQueue = [...this.returnQueue, ...items ?? []];
      return items;
    }
restore() {
      this.bufferQueue = [...this.returnQueue, ...this.bufferQueue];
      this.returnQueue = [];
    }
    get fetchedCount() {
      return this.returnQueue.length + this.bufferQueue.length;
    }
  }
  function usePopupContainer() {
    const ref2 = reactExports.useRef(null);
    const getPopupContainer = reactExports.useCallback(() => {
      return ref2.current?.closest(`.${APP_CLS_TAB_BAR}`)?.parentElement || document.body;
    }, []);
    return {
      ref: ref2,
      getPopupContainer
    };
  }
  class PopularGeneralRecService {
    constructor(anonymous) {
      this.anonymous = anonymous;
    }
    hasMore = true;
    page = 1;
    tabbarView = jsx$1(PopularGeneralTabbarView, {});
    async loadMore() {
      if (!this.hasMore) return;
      const res = await request.get("/x/web-interface/popular", {
        params: {
          ps: 20,
          pn: this.page
        },
        withCredentials: !this.anonymous
      });
      const json = res.data;
      if (!isWebApiSuccess(json)) {
        return toast(json.message || REQUEST_FAIL_MSG), void 0;
      }
      this.page++;
      this.hasMore = !json.data.no_more;
      const items = (json.data.list || []).map((item) => {
        return {
          ...item,
          api: EApiType.PopularGeneral,
          uniqId: `${EApiType.PopularGeneral}:${item.bvid}`
        };
      });
      return items;
    }
  }
  function PopularGeneralTabbarView() {
    const onRefresh = useOnRefresh();
    const tooltip = jsx$1(Fragment, { children: "✅ 匿名访问: 使用游客身份访问" });
    const extraAction = async () => {
      await delay$1(100);
      onRefresh();
    };
    const checkbox = jsx$1(CheckboxSettingItem, { configPath: "popularGeneralUseAnonymous", tooltip, label: "匿名访问", extraAction });
    return checkbox;
  }
  function getBiliPlayerConfig() {
    const key = "bpx_player_profile";
    const str = localStorage.getItem(key);
    if (!str) return;
    try {
      const val = JSON.parse(str);
      return val;
    } catch {
      return;
    }
  }
  function getBiliPlayerConfigAutoPlay() {
    const config = getBiliPlayerConfig();
    return !!config?.media.autoplay;
  }
  const C$2 = {
    top: (inlinePosition) => clsx("absolute top-8px", inlinePosition === "left" ? "left-8px" : "right-8px", inlinePosition === "left" ? clsZLeftMarks : clsZRightActions),
    topContainer: (inlinePosition) => clsx(C$2.top(inlinePosition), "flex items-center gap-x-5px", inlinePosition === "left" ? "flex-row" : "flex-row-reverse"),
    tooltip: (inlinePosition) => clsx("pointer-events-none absolute bottom--6px translate-y-100% select-none whitespace-nowrap rounded-4px bg-gate-primary px-8px py-4px text-12px text-white line-height-18px", inlinePosition === "left" ? "left-0" : "right-0")
  };
  const VideoCardActionButton = reactExports.memo(function VideoCardActionButton2({
    inlinePosition,
    icon,
    tooltip,
    visible = true,
    active = false,
    className,
    useMotion = false,
    motionProps,
    ref: propRef,
    ...divProps
  }) {
    const {
      triggerRef,
      tooltipEl
    } = useTooltip({
      inlinePosition,
      tooltip
    });
    const _className = reactExports.useMemo(() => {
      return g("action-button", "relative size-28px cursor-pointer rounded-6px bg-[rgb(33_33_33_/_0.7)] color-white", "b-1px b-solid", active ? "b-gate-primary" : "b-#444", "hover:b-gate-primary", useMotion ? "inline-flex" : visible ? "inline-flex" : "hidden", "items-center justify-center", "[&_svg]:pointer-events-none [&_svg]:select-none", className);
    }, [active, className, visible, useMotion]);
    const ref2 = useDelegatedRef(triggerRef, propRef);
    const sharedProps = {
      ...divProps,
      className: _className,
      ref: ref2,
      children: jsxs(Fragment, { children: [
        icon,
        tooltipEl
      ] })
    };
    if (!useMotion) {
      return jsx$1("div", { ...sharedProps });
    } else {
      return jsx$1(AnimatePresence, { children: visible && jsx$1(motion.div, { ...sharedProps, ...motionProps }, "action-button") });
    }
  });
  function useTooltip({
    inlinePosition,
    tooltip,
    tooltipClassName
  }) {
    const triggerRef = reactExports.useRef(null);
    const hovering = useHover(triggerRef);
    const _className = r(C$2.tooltip(inlinePosition), tooltipClassName, hovering ? "block" : "hidden");
    const tooltipEl = tooltip ? jsx$1("span", { className: _className, children: tooltip }) : void 0;
    return {
      triggerRef,
      tooltipEl
    };
  }
  function createLessFrequentFn(fn, initialTargetTimes, harder = true) {
    let times2 = 0;
    let targetTimes = initialTargetTimes;
    return (...args) => {
      times2++;
      if (times2 === targetTimes) {
        times2 = 0;
        if (harder) targetTimes++;
        return fn(...args);
      }
    };
  }
  function useLessFrequentFn(fn, initialTargetTimes, harder = true) {
    const _fn = useMemoizedFn(fn);
    return reactExports.useMemo(() => {
      return createLessFrequentFn(_fn, initialTargetTimes, harder);
    }, [_fn, initialTargetTimes, harder]);
  }
  const radixIconsOpenInNewWindow = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 15 15", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M8.5 6q.049 0 .098.009q.076.017.142.054q.061.034.114.083q.05.052.082.113A.5.5 0 0 1 9 6.5v3a.5.5 0 0 1-1 0V7.707l-5.146 5.147a.5.5 0 1 1-.708-.707L7.293 7H5.5a.5.5 0 0 1 0-1zM12 2a1 1 0 0 1 1 1v9a1 1 0 0 1-1 1H8.5a.5.5 0 0 1 0-1H12V3H3v3.5a.5.5 0 0 1-1 0V3a1 1 0 0 1 1-1z" })
  ] });
  const ForwardRef$v = reactExports.forwardRef(radixIconsOpenInNewWindow);
  const radixIconsCross2 = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 15 15", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M10.969 3.219a.574.574 0 1 1 .812.812L8.313 7.5l3.468 3.469l.074.09a.575.575 0 0 1-.796.796l-.09-.074L7.5 8.312l-3.469 3.47a.574.574 0 1 1-.812-.813L6.688 7.5l-3.47-3.469l-.073-.09a.575.575 0 0 1 .796-.797l.09.075L7.5 6.687z" })
  ] });
  const ForwardRef$u = reactExports.forwardRef(radixIconsCross2);
  const radixIconsLockOpen1 = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 15 15", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M7.499 0c1.072 0 1.966.338 2.589 1.002c.619.66.912 1.58.912 2.634V6h1a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h7V3.636c0-.876-.242-1.524-.642-1.95C8.963 1.267 8.357 1 7.5 1c-.888 0-1.502.269-1.895.715l-.077.092C5.197 2.233 5 2.843 5 3.633H4c0-.95.237-1.795.737-2.44l.121-.145C5.482.342 6.4 0 7.5 0M3 13h9V7H3z" })
  ] });
  const ForwardRef$t = reactExports.forwardRef(radixIconsLockOpen1);
  const radixIconsLockClosed = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 15 15", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M7.501.978c1.074 0 1.968.345 2.59 1.014c.616.664.909 1.587.909 2.642V6h1a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h1V4.636c0-1.055.293-1.979.91-2.643c.622-.67 1.517-1.015 2.591-1.015M3 13h9V7H3zM7.501 1.978c-.855 0-1.461.27-1.857.696C5.243 3.105 5 3.76 5 4.636V6h5V4.634c0-.877-.241-1.531-.642-1.962c-.395-.426-1.001-.694-1.857-.694" })
  ] });
  const ForwardRef$s = reactExports.forwardRef(radixIconsLockClosed);
  function renderInPipWindow(newHref, pipWindow) {
    const cssInsertContainer = pipWindow.document.head;
    createEmotion({
      key: "pip-window",
      container: cssInsertContainer
    });
    Array.from(document.querySelectorAll("style")).filter((s2) => {
      return [APP_NAMESPACE, "ant", "rc"].some((x) => s2.textContent.includes(x));
    }).forEach((s2) => {
      const style2 = pipWindow.document.createElement("style");
      style2.textContent = s2.textContent;
      pipWindow.document.head.appendChild(style2);
    });
    const container = document.createElement("div");
    container.classList.add(APP_CLS_ROOT);
    container.style.lineHeight = "0";
    pipWindow.document.body.appendChild(container);
    const root2 = clientExports.createRoot(container);
    root2.render( jsx$1(AppRoot, { cssInsertContainer, cssInsertContainerEmotionKey: "pip-window", children: jsx$1(ConfigProvider, { getPopupContainer: () => pipWindow.document.body, getTargetContainer: () => pipWindow, children: jsxs(App, { message: {
      getContainer: () => pipWindow.document.body
    }, children: [
jsx$1(SetupForPage, { baseGlobalStyle: true }),
jsx$1(PipWindowContent, { newHref, pipWindow })
    ] }) }) }));
  }
  var _ref$4 = {
    name: "pb1257",
    styles: "*{box-sizing:border-box;}:root,body,iframe{margin:0;padding:0;overscroll-behavior:none;}"
  };
  function PipWindowContent({
    newHref,
    pipWindow
  }) {
    const hovering = useHover(pipWindow.document.documentElement);
    const [locked, setLocked] = reactExports.useState(() => settings.pipWindow.defaultLocked);
    return jsxs(Fragment, { children: [
jsx$1(Global, { styles: [_ref$4, "", ""] }),
jsx$1("iframe", { src: newHref, className: "block h-100vh w-full border-none" }),
jsx$1(LockOverlay, { locked, setLocked, pipWindow }),
jsxs("div", { className: clsx("fixed right-10px top-10px z-9999 flex-row-reverse items-center gap-x-6px", hovering ? "flex" : "hidden"), children: [
jsx$1(CloseThenOpenButton, { pipWindow, newHref }),
jsx$1(LockButton, { locked, setLocked })
      ] })
    ] });
  }
  const actionButtonExtraClassName = "size-30px [&_svg]:size-16px";
  function LockOverlay({
    locked,
    setLocked,
    pipWindow
  }) {
    const {
      message: message2
    } = App.useApp();
    const onOverlayClick = useLessFrequentFn(() => {
      message2.info("请先点击右上角「🔓解锁按钮」解锁");
    }, 3);
    reactExports.useMemo(() => {
      return defineAntMenus([{
        key: "unlock",
        label: "解锁",
        icon: jsx$1(ForwardRef$t, {}),
        onClick() {
          setLocked(false);
        }
      }]);
    }, []);
    return locked && jsx$1("div", { className: clsx("locked-overlay", "fixed inset-0 z-9999 select-none bg-transparent"), onClick: onOverlayClick });
  }
  function CloseThenOpenButton({
    newHref,
    pipWindow
  }) {
    const onClick = () => {
      pipWindow.close();
      const u2 = new URL(newHref);
      u2.searchParams.delete(EQueryKey.PlayerScreenMode);
      u2.searchParams.delete(EQueryKey.ForceAutoPlay);
      openNewTab(u2.href);
    };
    return jsx$1(VideoCardActionButton, { inlinePosition: "right", icon: jsx$1(ForwardRef$v, {}), tooltip: "新窗口打开", onClick, className: actionButtonExtraClassName });
  }
  function LockButton({
    locked,
    setLocked
  }) {
    const [currentState, targetState] = locked ? ["锁定", "解锁"] : ["解锁", "锁定"];
    return jsx$1(VideoCardActionButton, { inlinePosition: "right", icon: locked ? jsx$1(ForwardRef$s, {}) : jsx$1(ForwardRef$t, {}), tooltip: `已${currentState}, 点击${targetState}`, className: actionButtonExtraClassName, onClick: () => setLocked((x) => !x) });
  }
  const debug$b = baseDebug.extend("VideoCard:useOpenRelated");
  function useOpenRelated({
    href,
    item,
    cardData,
    actionButtonVisible,
    hasOpenInPopupActionButton,
    getLargePreviewCurrentTime,
    hideLargePreview,
    shouldUseLargePreviewCurrentTime
  }) {
    const {
      videoLinkOpenMode
    } = useSettingsSnapshot();
    function getHref(action2) {
      const u2 = new URL(href, location.href);
      action2?.(u2);
      const newHref = u2.href;
      return newHref;
    }
    const handleVideoLinkClick = useMemoizedFn((e) => {
      e.stopPropagation();
      e.preventDefault();
      onOpenWithMode(void 0, e);
    });
    const onOpenWithMode = useMemoizedFn((mode, e) => {
      mode ||= settings.videoLinkOpenMode;
      const newHref = getHref((u2) => {
        if (mode === EVideoLinkOpenMode.NormalWebFullscreen || mode === EVideoLinkOpenMode.Popup && settings.pipWindow.autoWebFullscreen) {
          u2.searchParams.set(EQueryKey.PlayerScreenMode, EPlayerScreenMode.WebFullscreen);
          if (mode === EVideoLinkOpenMode.Popup && !getBiliPlayerConfigAutoPlay()) {
            u2.searchParams.set(EQueryKey.ForceAutoPlay, EForceAutoPlay.ON);
          }
        }
        if (shouldUseLargePreviewCurrentTime()) {
          const largePreviewT = getLargePreviewCurrentTime();
          if (largePreviewT) {
            hideLargePreview();
            u2.searchParams.set("t", largePreviewT.toString());
          }
        }
      });
      const handleCommon = () => {
        const backgroud = mode === EVideoLinkOpenMode.Background || !!(e?.metaKey || e?.ctrlKey);
        const active = !backgroud;
        openNewTab(newHref, active);
      };
      const handleCurrentPage = () => {
        location.href = newHref;
      };
      const handlers2 = {
        [EVideoLinkOpenMode.Normal]: handleCommon,
        [EVideoLinkOpenMode.Background]: handleCommon,
        [EVideoLinkOpenMode.CurrentPage]: handleCurrentPage,
        [EVideoLinkOpenMode.NormalWebFullscreen]: handleCommon,
        [EVideoLinkOpenMode.Popup]: () => handlePopup(newHref),
        [EVideoLinkOpenMode.Iina]: handleIINA
      };
      handlers2[mode]?.();
    });
    function handlePopup(newHref) {
      const {
        width,
        height
      } = getRecItemDimension({
        item
      });
      return openInPipOrPopup(newHref, cardData.bvid, width, height);
    }
    function handleIINA() {
      let usingHref = href;
      if (item.api === EApiType.Watchlater) usingHref = `/video/${item.bvid}`;
      const fullHref = new URL(usingHref, location.href).href;
      const iinaUrl = `iina://open?url=${encodeURIComponent(fullHref)}`;
      window.open(iinaUrl, "_self");
    }
    const consistentOpenMenus = reactExports.useMemo(() => {
      return Object.values(EVideoLinkOpenMode).filter((mode) => VideoLinkOpenModeConfig[mode].enabled === void 0).map((mode) => {
        return {
          key: VideoLinkOpenModeKey[mode],
          label: VideoLinkOpenModeConfig[mode].label,
          icon: VideoLinkOpenModeConfig[mode].icon,
          onClick: () => onOpenWithMode(mode)
        };
      });
    }, []);
    const conditionalOpenMenus = reactExports.useMemo(() => {
      return Object.values(EVideoLinkOpenMode).filter((mode) => typeof VideoLinkOpenModeConfig[mode].enabled === "boolean" && VideoLinkOpenModeConfig[mode].enabled).length ? Object.values(EVideoLinkOpenMode).filter((mode) => typeof VideoLinkOpenModeConfig[mode].enabled === "boolean" && VideoLinkOpenModeConfig[mode].enabled).map((mode) => {
        return {
          key: VideoLinkOpenModeKey[mode],
          label: VideoLinkOpenModeConfig[mode].label,
          icon: VideoLinkOpenModeConfig[mode].icon,
          onClick: () => onOpenWithMode(mode)
        };
      }) : [];
    }, []);
    const openInPopupActionButtonEl = reactExports.useMemo(() => {
      if (videoLinkOpenMode === EVideoLinkOpenMode.Popup) return;
      if (item.api === EApiType.Live) return;
      if (!hasDocumentPictureInPicture) return;
      if (!hasOpenInPopupActionButton) return;
      return jsx$1(VideoCardActionButton, { visible: actionButtonVisible, inlinePosition: "right", icon: VideoLinkOpenModeConfig.Popup.icon, tooltip: VideoLinkOpenModeConfig.Popup.label, onClick: (e) => {
        e.preventDefault();
        e.stopPropagation();
        onOpenWithMode(EVideoLinkOpenMode.Popup);
      } });
    }, [videoLinkOpenMode, actionButtonVisible]);
    const onOpenInPopup = useMemoizedFn(() => {
      onOpenWithMode(EVideoLinkOpenMode.Popup);
    });
    return {
      onOpenWithMode,
      handleVideoLinkClick,
      consistentOpenMenus,
      conditionalOpenMenus,
      openInPopupActionButtonEl,
      onOpenInPopup
    };
  }
  function getRecItemDimension({
    item,
    dimensionFromApi
  }) {
    let width;
    let height;
    let aspectRatio2;
    if (dimensionFromApi) {
      [width, height] = [dimensionFromApi.width, dimensionFromApi.height];
      if (dimensionFromApi.rotate === 1) [width, height] = [height, width];
      aspectRatio2 = width / height;
    } else if (item?.api === EApiType.AppRecommend && item.uri?.startsWith("bilibili://")) {
      const searchParams2 = new URL(item.uri).searchParams;
      const playerWidth = Number(searchParams2.get("player_width") || 0);
      const playerHeight = Number(searchParams2.get("player_height") || 0);
      const playerRotate = Number(searchParams2.get("player_rotate") || 0);
      if (playerWidth && playerHeight && !Number.isNaN(playerWidth) && !Number.isNaN(playerHeight)) {
        [width, height] = [playerWidth, playerHeight];
        if (playerRotate === 1) [width, height] = [height, width];
        aspectRatio2 = width / height;
      }
    } else if (item?.api === EApiType.Rank && isNormalRankItem(item)) {
      const w = item.dimension.width;
      const h2 = item.dimension.height;
      const rotate2 = item.dimension.rotate;
      if (w && h2 && !Number.isNaN(w) && !Number.isNaN(h2)) {
        [width, height] = [w, h2];
        if (rotate2 === 1) [width, height] = [height, width];
        aspectRatio2 = width / height;
      }
    }
    return {
      width,
      height,
      aspectRatio: aspectRatio2
    };
  }
  const hasDocumentPictureInPicture = !!window.documentPictureInPicture?.requestWindow;
  async function openInPipOrPopup(newHref, bvid, videoWidth, videoHeight) {
    let popupWidth = 1e3;
    let popupHeight = Math.ceil(popupWidth / 16 * 9);
    const MAX_API_WAIT = 200;
    if ((!videoWidth || !videoHeight) && bvid) {
      const videoPages = await Promise.race([getVideoPageList(bvid), delay$1(MAX_API_WAIT)]);
      if (videoPages?.[0]?.dimension) {
        const {
          dimension
        } = videoPages[0];
        videoWidth = dimension.width;
        videoHeight = dimension.height;
      }
    }
    if (videoWidth && videoHeight && videoWidth < videoHeight) {
      const maxHeight = Math.min(Math.floor(window.screen.availHeight * 0.8), 1e3);
      const maxWidth = Math.floor(maxHeight / videoHeight * videoWidth);
      popupWidth = Math.min(720, maxWidth);
      popupHeight = Math.floor(popupWidth / videoWidth * videoHeight);
    }
    debug$b("openInPipOrPopup newHref=%s size=%sx%s", newHref, popupWidth, popupHeight);
    let pipWindow;
    if (hasDocumentPictureInPicture) {
      try {
        pipWindow = await window.documentPictureInPicture?.requestWindow({
          width: popupWidth,
          height: popupHeight,
          disallowReturnToOpener: true
        });
      } catch {
      }
    }
    if (pipWindow) {
      renderInPipWindow(newHref, pipWindow);
    } else {
      openPopupWindow(newHref, popupWidth, popupHeight);
    }
  }
  function openPopupWindow(newHref, popupWidth, popupHeight) {
    const left = (window.innerWidth - popupWidth) / 2;
    const top = (window.innerHeight - popupHeight) / 2 - 50;
    const features = ["popup=true", `width=${popupWidth}`, `height=${popupHeight}`, `left=${left}`, `top=${top}`].join(",");
    debug$b("openInPopup: features -> %s", features);
    window.open(newHref, "_blank", features);
  }
  function useLinkNewTab() {
    const {
      videoLinkOpenMode
    } = useSettingsSnapshot();
    return videoLinkOpenMode !== EVideoLinkOpenMode.CurrentPage;
  }
  function useLinkTarget() {
    const newTab = useLinkNewTab();
    return newTab ? "_blank" : "_self";
  }
  function getLinkTarget() {
    const newTab = settings.videoLinkOpenMode !== EVideoLinkOpenMode.CurrentPage;
    return newTab ? "_blank" : "_self";
  }
  function CustomTargetLink(props) {
    const target = useLinkTarget();
    return jsx$1("a", { ...props, target, children: props.children });
  }
  let episodes = [];
  let cacheKey = "";
  function genCacheKey() {
    const now2 = dayjs();
    return [now2.format("YYYYMMDD"), now2.hour() < 18 ? "lt-18" : "gte-18"].join("_");
  }
  async function getEpisodeList() {
    const useCache2 = episodes.length && cacheKey && cacheKey === genCacheKey();
    if (useCache2) return episodes;
    const res = await request.get("/x/web-interface/popular/series/list");
    const json = res.data;
    const list2 = json.data.list;
    episodes = list2;
    cacheKey = genCacheKey();
    return episodes;
  }
  class PopularWeeklyRecService {
    constructor(useShuffle) {
      this.useShuffle = useShuffle;
    }
    static PAGE_SIZE = 20;
    episodesLoaded = false;
    episodes = [];
qs = new QueueStrategy(PopularWeeklyRecService.PAGE_SIZE);
    get hasMore() {
      if (!this.episodesLoaded) return true;
      return !!this.qs.bufferQueue.length || !!this.episodes.length;
    }
    async loadMore() {
      if (!this.episodesLoaded) {
        this.episodes = await getEpisodeList();
        this.episodesLoaded = true;
        if (this.useShuffle) this.episodes = shuffle(this.episodes);
      }
      if (!this.hasMore) return;
      if (!this.useShuffle) {
        if (this.qs.bufferQueue.length) return this.qs.sliceFromQueue();
        const ep = this.episodes[0];
        const epNum = ep.number;
        const items = await fetchWeeklyItems(epNum);
        this.qs.bufferQueue.push({
          api: EApiType.Separator,
          uniqId: `${EApiType.PopularWeekly}:separator:${epNum}`,
          content: jsx$1(CustomTargetLink, { href: `https://www.bilibili.com/v/popular/weekly?num=${epNum}`, children: ep.name })
        }, ...items);
        this.episodes = this.episodes.slice(1);
        return this.qs.sliceFromQueue();
      }
      const prefetchPage = 5;
      while (this.qs.bufferQueue.length < PopularWeeklyRecService.PAGE_SIZE * prefetchPage && this.episodes.length) {
        this.episodes = shuffle(this.episodes);
        const episodes2 = this.episodes.slice(0, prefetchPage);
        this.episodes = this.episodes.slice(prefetchPage);
        const fetched = await pmap(episodes2.map((x) => x.number), (episodeNum) => fetchWeeklyItems(episodeNum), 2);
        this.qs.bufferQueue = shuffle([...this.qs.bufferQueue, ...fetched.flat()]);
      }
      return this.qs.sliceFromQueue();
    }
    get tabbarView() {
      return jsx$1(PopularWeeklyTabbarView, {});
    }
  }
  const cache$1 = {};
  async function fetchWeeklyItems(episodeNum) {
    if (!cache$1[episodeNum]?.length) {
      const res = await request.get("/x/web-interface/popular/series/one", {
        params: {
          number: episodeNum
        }
      });
      const json = res.data;
      const items2 = (json.data.list || []).map((item) => {
        return {
          ...item,
          api: EApiType.PopularWeekly,
          uniqId: `${EApiType.PopularWeekly}:${item.bvid}`
        };
      });
      cache$1[episodeNum] = items2;
    }
    const items = cache$1[episodeNum];
    return items;
  }
  function PopularWeeklyTabbarView() {
    const onRefresh = useOnRefresh();
    return jsx$1(Fragment, { children: jsx$1(SwitchSettingItem, { configPath: "popularWeeklyUseShuffle", checkedChildren: "随机顺序: 开", unCheckedChildren: "随机顺序: 关", extraAction: async () => {
      await delay$1(100);
      onRefresh();
    } }) });
  }
  const storageKey = "rank-store-slug";
  const initialSlug = await( GM.getValue(storageKey)) || defaultRankTab.slug;
  const rankStore = proxy({
    slug: initialSlug,
    tabs: [],
    get currentTab() {
      return this.tabs.find((x) => x.slug === this.slug) || defaultRankTab;
    }
  });
  const updateRankTabs = reusePendingPromise(async () => {
    if (rankStore.tabs.length) return;
    const rankTabs = await getRankTabsConfig();
    rankStore.tabs = rankTabs;
  });
  subscribeKey(rankStore, "slug", () => {
    GM.setValue(storageKey, rankStore.slug);
  });
  class RankRecService {
    constructor(slug) {
      this.slug = slug;
    }
    loaded = false;
    qs = new QueueStrategy(20);
    tabbarView = jsx$1(RankTabbarView, {});
    sidebarView = jsx$1(RankSidebarView, {});
    get hasMore() {
      if (!this.loaded) return true;
      return !!this.qs.bufferQueue.length;
    }
    get rankTab() {
      return snapshot(rankStore).tabs.find((x) => x.slug === this.slug) || defaultRankTab;
    }
    async loadMore(abortSignal) {
      if (!this.hasMore) return;
      if (!this.loaded) {
        await updateRankTabs();
        const {
          url: url2,
          apiType
        } = getRankTabRequestConfig(this.rankTab);
        const res = await request.get(url2, {
          signal: abortSignal
        });
        const json = res.data;
        this.loaded = true;
        if (!isWebApiSuccess(json)) {
          toast(json.message || REQUEST_FAIL_MSG);
          return;
        }
        const list2 = json?.data?.list || json?.result?.list || [];
        const items = list2.map((item, index) => {
          const rankingNo = index + 1;
          return {
            ...item,
            api: EApiType.Rank,
            uniqId: `${EApiType.Rank}:${this.rankTab.slug}:rankingNo-${rankingNo}`,
            rankingNo,
            slug: this.rankTab.slug,
            rankTab: this.rankTab,
            from: apiType
          };
        });
        this.qs.bufferQueue = items;
      }
      return this.qs.sliceFromQueue();
    }
  }
  function useMenuItems() {
    const {
      tabs
    } = useSnapshot(rankStore);
    const {
      normalList,
      pgcList
    } = reactExports.useMemo(() => {
      const listWithApiType = tabs.map((x) => ({
        ...x,
        apiType: getRankTabRequestConfig(x).apiType
      }));
      const pgcList2 = listWithApiType.filter((x) => [ERankApiType.PgcSeason, ERankApiType.PgcWeb].includes(x.apiType));
      const normalList2 = listWithApiType.filter((x) => x.apiType === ERankApiType.Normal);
      return {
        normalList: normalList2,
        pgcList: pgcList2
      };
    }, [tabs]);
    return {
      normalList,
      pgcList
    };
  }
  function RankTabbarView() {
    const {
      enableSidebar
    } = useSettingsSnapshot();
    const {
      ref: ref2,
      getPopupContainer
    } = usePopupContainer();
    const onRefresh = useOnRefresh();
    const {
      slug,
      currentTab
    } = useSnapshot(rankStore);
    const {
      normalList,
      pgcList
    } = useMenuItems();
    const renderRankTabList = (list2, label, helpInfoContent) => {
      if (!list2.length) return null;
      return jsxs("div", { className: "mt-15px max-w-350px first:mt-0", children: [
jsxs("p", { className: "mb-5px flex-v-center rounded-5px bg-gate-primary py-5px pl-6px text-white", children: [
          label,
          !!helpInfoContent && jsx$1(HelpInfo, { children: helpInfoContent })
        ] }),
jsx$1("div", { className: "grid grid-cols-4 gap-x-10px gap-y-8px px-2px", children: list2.map((c2) => {
          const active = c2.slug === slug;
          return jsx$1(Button$1, { className: clsx({
            "b-gate-primary": active,
            "color-gate-primary": active
          }), onClick: (e) => {
            setPopoverOpen(false);
            rankStore.slug = c2.slug;
            onRefresh();
          }, children: jsx$1("span", { children: c2.name }) }, c2.slug);
        }) })
      ] });
    };
    const handleDropdownButtonClick = useMemoizedFn((e) => {
      const list2 = [...normalList, ...pgcList];
      if (!list2.length) return;
      const index = list2.findIndex((x) => x.slug === slug);
      if (index === -1) return;
      const offset2 = e.shiftKey ? -1 : 1;
      const nextIndex = (index + offset2 + list2.length) % list2.length;
      rankStore.slug = list2[nextIndex].slug;
      onRefresh();
    });
    const popoverContent = jsxs(Fragment, { children: [
      renderRankTabList(normalList, "视频"),
      renderRankTabList(pgcList, "PGC内容", "不能提供预览")
    ] });
    const [popoverOpen, setPopoverOpen] = reactExports.useState(false);
    const popover = jsx$1(Popover, { arrow: false, open: popoverOpen, onOpenChange: setPopoverOpen, placement: "bottomLeft", getPopupContainer, content: popoverContent, styles: {
      container: {
        border: `1px solid ${usePopoverBorderColor()}`
      }
    }, children: jsx$1(Button$1, { css: [popoverOpen && buttonOpenCss, "", ""], onClick: handleDropdownButtonClick, className: "outline-none!", children: currentTab.name }) });
    if (enableSidebar) return void 0;
    return jsx$1("div", { ref: ref2, children: popover });
  }
  function RankSidebarView() {
    const {
      slug
    } = useSnapshot(rankStore);
    const {
      normalList,
      pgcList
    } = useMenuItems();
    const onRefresh = useOnRefresh();
    const onSelect = useMemoizedFn((slug2) => {
      rankStore.slug = slug2;
      onRefresh();
    });
    const menuItems = reactExports.useMemo(() => {
      const groupNormal = {
        type: "group",
        label: "视频",
        children: normalList.map((x) => ({
          key: x.slug,
          label: x.name,
          onClick: () => onSelect(x.slug)
        }))
      };
      const groupPgc = {
        type: "group",
        label: "PGC内容",
        children: pgcList.map((x) => ({
          key: x.slug,
          label: x.name,
          onClick: () => onSelect(x.slug)
        }))
      };
      return [groupNormal, groupPgc];
    }, [normalList, pgcList]);
    return jsx$1(Menu, { items: menuItems, selectedKeys: [slug], mode: "inline", inlineIndent: 10 });
  }
  const subtabServiceCreators = {
    [EHotSubTab.PopularGeneral]: () => new PopularGeneralRecService(settings.popularGeneralUseAnonymous),
    [EHotSubTab.PopularWeekly]: () => new PopularWeeklyRecService(settings.popularWeeklyUseShuffle),
    [EHotSubTab.Rank]: () => new RankRecService(rankStore.slug)
  };
  function isHotTabUsingShuffle(shuffleForPopularWeekly) {
    const {
      subtab
    } = hotStore;
    shuffleForPopularWeekly ??= settings.popularWeeklyUseShuffle;
    const change = subtab === EHotSubTab.PopularWeekly && shuffleForPopularWeekly;
    return change;
  }
  const imgOf = (src) => jsx$1("img", { src, alt: "", className: "size-18px" });
  const HotSubTabConfig = {
    [EHotSubTab.PopularGeneral]: {
icon: imgOf("https://s1.hdslb.com/bfs/static/jinkela/popular/assets/icon_popular.png"),
      label: "综合热门",
      desc: "各个领域中新奇好玩的优质内容都在这里~",
      swr: true,
      anonymousUsage: true
    },
    [EHotSubTab.PopularWeekly]: {
icon: imgOf("https://s1.hdslb.com/bfs/static/jinkela/popular/assets/icon_weekly.png"),
      label: "每周必看",
      desc: "每周五晚 18:00 更新",
      anonymousUsage: true
    },
    [EHotSubTab.Rank]: {
icon: imgOf("https://s1.hdslb.com/bfs/static/jinkela/popular/assets/icon_rank.png"),
      label: "排行榜",
      desc: "排行榜根据稿件内容质量，近期的数据综合展示，动态更新",
      anonymousUsage: true,
      swr: true
    }
  };
  class HotRecService extends BaseTabService {
    subtab;
    service;
    constructor() {
      super(20);
      this.subtab = hotStore.subtab;
      this.service = subtabServiceCreators[hotStore.subtab]();
    }
    get tabbarView() {
      return jsx$1(HotTabbarView, { children: this.service.tabbarView });
    }
    get sidebarView() {
      return this.service.sidebarView;
    }
    get hasMoreExceptQueue() {
      return this.service.hasMore;
    }
    fetchMore(abortSignal) {
      return this.service.loadMore(abortSignal);
    }
  }
  const hotStore = await( proxyWithGmStorage({
    subtab: EHotSubTab.PopularGeneral
  }, "hot-store"));
  if (!Object.values(EHotSubTab).includes(hotStore.subtab)) {
    hotStore.subtab = EHotSubTab.PopularGeneral;
  }
  function HotTabbarView({
    children
  }) {
    const {
      subtab: activeSubtab
    } = useSnapshot(hotStore);
    const {
      icon,
      label
    } = HotSubTabConfig[activeSubtab];
    const onRefresh = useOnRefresh();
    const {
      ref: ref2,
      getPopupContainer
    } = usePopupContainer();
    const {
      __internalHotSubUseDropdown
    } = useSettingsSnapshot();
    const menus = reactExports.useMemo(() => [EHotSubTab.PopularGeneral, EHotSubTab.PopularWeekly, EHotSubTab.Rank].map((subtab, index) => {
      const config = HotSubTabConfig[subtab];
      const active = subtab === activeSubtab;
      return [index > 0 && {
        type: "divider"
      }, {
        key: subtab,
        label: jsx$1("span", { className: clsx({
          "color-gate-primary": active
        }), children: config.label }),
        icon: config.icon,
        onClick() {
          if (subtab === hotStore.subtab) return;
          hotStore.subtab = subtab;
          onRefresh();
        }
      }].filter(Boolean);
    }).flat(), [activeSubtab]);
    const dropdownMenu = jsx$1(Dropdown, { menu: {
      items: menus
    }, getPopupContainer, rootClassName: '![&_[role="separator"]]:mx-0 ![&_[role="separator"]]:my-2px', children: jsxs(Button$1, { ref: ref2, className: "w-114px flex items-center justify-start gap-0 pl-16px", children: [
      icon,
jsx$1("span", { className: "ml-8px", children: label })
    ] }) });
    const tab2 = reactExports.useMemo(() => {
      return jsx$1(Space.Compact, { children: [EHotSubTab.PopularGeneral, EHotSubTab.PopularWeekly, EHotSubTab.Rank].map((subtab, index) => {
        const {
          icon: icon2,
          label: label2,
          desc
        } = HotSubTabConfig[subtab];
        const active = subtab === activeSubtab;
        return jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
          label2,
          ": ",
          desc
        ] }), children: jsx$1(Button$1, { className: "[&_.ant-btn-icon]:line-height-0", icon: icon2, variant: active ? "solid" : "outlined", color: active ? "primary" : "default", onClick: () => {
          if (subtab === hotStore.subtab) return;
          hotStore.subtab = subtab;
          onRefresh();
        }, children: label2 }) }, subtab);
      }) });
    }, [activeSubtab]);
    return jsxs(Fragment, { children: [
      __internalHotSubUseDropdown ? dropdownMenu : tab2,
      children
    ] });
  }
  const sidebarBottomLine = jsx$1(Divider, { className: "[&.ant-divider-horizontal.ant-divider-with-text]:my-5px [&.ant-divider-horizontal.ant-divider-with-text]:text-14px", children: "底线" });
  function useSidebarVisible(tab2) {
    const {
      enableSidebar
    } = useSettingsSnapshot();
    const {
      usingTwoColumnMode
    } = useGridDisplayModeChecker();
    const hotSubTab = useSnapshot(hotStore).subtab;
    const {
      insideModal
    } = useRecSelfContext();
    return reactExports.useMemo(() => {
      if (!enableSidebar) return false;
      if (insideModal && usingTwoColumnMode) return false;
      if (tab2 === ETab.DynamicFeed) {
        if (QUERY_DYNAMIC_UP_MID) return false;
        return true;
      }
      if (tab2 === ETab.Hot) return hotSubTab === EHotSubTab.Rank;
      if (tab2 === ETab.Fav) return true;
      return false;
    }, [tab2, enableSidebar, hotSubTab, insideModal, usingTwoColumnMode]);
  }
  function useRevealMenuSelectedKey(menuItems, selectedKey) {
    const menuRef = reactExports.useRef(null);
    const revealSelected = useMemoizedFn((key) => {
      key ||= selectedKey;
      if (!key) return;
      const el = menuRef.current?.menu?.findItem({
        key
      });
      if (!el) return;
      el.scrollIntoViewIfNeeded ? el.scrollIntoViewIfNeeded() : el.scrollIntoView();
      return true;
    });
    const scrollCalled = reactExports.useRef(false);
    const checkAndScroll = useMemoizedFn(() => {
      if (scrollCalled.current) return;
      const called = revealSelected();
      if (called) {
        scrollCalled.current = true;
      }
    });
    useMount(() => checkAndScroll());
    useUpdateEffect(() => checkAndScroll(), [menuItems]);
    return {
      menuRef,
      revealSelected
    };
  }
  const multiSelectStore = proxy({
    multiSelecting: false,
    selectedIdSet: proxySet(),
shiftMultiSelectAnchorUniqId: void 0
  });
  function useMultiSelecting() {
    const {
      multiSelecting
    } = useSnapshot(multiSelectStore);
    return multiSelecting;
  }
  function useMultiSelectState(uniqId) {
    const {
      multiSelecting,
      selectedIdSet
    } = useSnapshot(multiSelectStore);
    return multiSelecting && !!uniqId && selectedIdSet.has(uniqId);
  }
  const recGridStateStack = [];
  function getCurrentGridItems() {
    return recGridStateStack.at(-1)?.items ?? [];
  }
  function setCurrentGridItems(items) {
    const state2 = recGridStateStack.at(-1);
    if (!state2) return;
    state2.items = items;
  }
  function useSetupGridState() {
    useMount(() => {
      recGridStateStack.push({
        items: []
      });
      return () => {
        recGridStateStack.pop();
      };
    });
  }
  function getMultiSelectedItems() {
    const {
      multiSelecting,
      selectedIdSet
    } = multiSelectStore;
    return multiSelecting ? getCurrentGridItems().filter((item) => selectedIdSet.has(item.uniqId)) : [];
  }
  function getMultiSelectedCardDatas() {
    return getMultiSelectedItems().map(normalizeCardData);
  }
  function getGenericCardDatas() {
    const {
      multiSelecting
    } = multiSelectStore;
    let items = multiSelecting ? getMultiSelectedItems() : getCurrentGridItems();
    if (multiSelecting && !items.length) items = getCurrentGridItems();
    const cardDatas = items.map(normalizeCardData);
    return cardDatas.toReversed();
  }
  function copyBvidsSingleLine() {
    const bvids = getGenericCardDatas().map((cardData) => cardData.bvid);
    const content = bvids.join(" ");
    copyContent(content, 1);
  }
  function getBvidInfo(cardData) {
    let {
      bvid,
      authorName,
      pubts,
      title
    } = cardData;
    const date4 = dayjs.unix(pubts ?? 0).format("YYYY-MM-DD");
    title = title.replaceAll(/\n+/g, " ");
    return `${bvid} ;; [${authorName}] ${date4} ${title}`;
  }
  function copyBvidInfos() {
    const lines = getGenericCardDatas().map(getBvidInfo);
    const content = lines.join("\n");
    copyContent(content, 1);
  }
  function copyVideoLinks() {
    const lines = getMultiSelectedCardDatas().map((cardData) => {
      let href = cardData.href;
      if (!href) return;
      if (href.startsWith("/")) href = new URL(href, location.href).href;
      return href;
    }).filter(Boolean);
    const content = lines.join("\n");
    copyContent(content);
  }
  function handleMultiSelectWithShiftKey(anchorUniqId, toUniqId) {
    const {
      multiSelecting,
      selectedIdSet
    } = multiSelectStore;
    if (!multiSelecting) return;
    if (!anchorUniqId || !toUniqId || anchorUniqId === toUniqId) return;
    const list2 = getCurrentGridItems();
    const anchorIndex = list2.findIndex((item) => item.uniqId === anchorUniqId);
    const toIndex = list2.findIndex((item) => item.uniqId === toUniqId);
    const isIndexValid = (index) => index >= 0 && index <= list2.length - 1;
    if (!isIndexValid(anchorIndex) || !isIndexValid(toIndex)) return;
    const range3 = [anchorIndex, toIndex];
    const [start, end] = fastOrderBy(range3, [(x) => x], ["asc"]);
    const selected = selectedIdSet.has(anchorUniqId);
    for (let i2 = start; i2 <= end; i2++) {
      const uniqId = getCurrentGridItems()[i2].uniqId;
      selected ? selectedIdSet.add(uniqId) : selectedIdSet.delete(uniqId);
    }
  }
  const biUiChecksGrid = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M2 10h3a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1v-3a1 1 0 0 1 1-1m9-9h3a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1h-3a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1m0 9a1 1 0 0 0-1 1v3a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1v-3a1 1 0 0 0-1-1zm0-10a2 2 0 0 0-2 2v3a2 2 0 0 0 2 2h3a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zM2 9a2 2 0 0 0-2 2v3a2 2 0 0 0 2 2h3a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2zm7 2a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2h-3a2 2 0 0 1-2-2zM0 2a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2zm5.354.854a.5.5 0 1 0-.708-.708L3 3.793l-.646-.647a.5.5 0 1 0-.708.708l1 1a.5.5 0 0 0 .708 0z" })
  ] });
  const ForwardRef$r = reactExports.forwardRef(biUiChecksGrid);
  const fluentSelectAllOn16Regular = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 16 16", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M9.854 5.854a.5.5 0 0 0-.708-.708L6.5 7.793L5.354 6.646a.5.5 0 1 0-.708.708l1.5 1.5a.5.5 0 0 0 .708 0zM2 4.5A2.5 2.5 0 0 1 4.5 2h5A2.5 2.5 0 0 1 12 4.5v5A2.5 2.5 0 0 1 9.5 12h-5A2.5 2.5 0 0 1 2 9.5zM4.5 3A1.5 1.5 0 0 0 3 4.5v5A1.5 1.5 0 0 0 4.5 11h5A1.5 1.5 0 0 0 11 9.5v-5A1.5 1.5 0 0 0 9.5 3zM7 14a2.5 2.5 0 0 1-2-1h4.5A3.5 3.5 0 0 0 13 9.5V4c.607.456 1 1.182 1 2v3.5A4.5 4.5 0 0 1 9.5 14z" })
  ] });
  const ForwardRef$q = reactExports.forwardRef(fluentSelectAllOn16Regular);
  const icOutlineSwapHoriz = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M6.99 11L3 15l3.99 4v-3H14v-2H6.99zM21 9l-3.99-4v3H10v2h7.01v3z" })
  ] });
  const ForwardRef$p = reactExports.forwardRef(icOutlineSwapHoriz);
  const ionExitOutline = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 512 512", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 32, d: "M320 176v-40a40 40 0 0 0-40-40H88a40 40 0 0 0-40 40v240a40 40 0 0 0 40 40h192a40 40 0 0 0 40-40v-40m64-160l80 80l-80 80m-193-80h273" })
  ] });
  const ForwardRef$o = reactExports.forwardRef(ionExitOutline);
  function MultiSelectButton({
    iconOnly,
    addCopyActions = false
  }) {
    const {
      multiSelecting
    } = useSnapshot(multiSelectStore);
    const popoverBorderColor = usePopoverBorderColor();
    const exitCheck = useMemoizedFn(() => {
      const isExit = !multiSelectStore.multiSelecting;
      if (!isExit) return;
      multiSelectStore.shiftMultiSelectAnchorUniqId = void 0;
      if (settings.multiSelect.clearWhenExit) {
        multiSelectStore.selectedIdSet.clear();
      }
    });
    const btn = jsxs(Button$1, { type: multiSelecting ? "primary" : "default", className: clsx(iconOnly ? "icon-only-round-button" : "inline-flex-center"), onClick: () => {
      multiSelectStore.multiSelecting = !multiSelectStore.multiSelecting;
      exitCheck();
    }, children: [
jsx$1(ForwardRef$r, { className: "size-12px" }),
      !iconOnly && jsxs(Fragment, { children: [
        "多选",
        multiSelectStore.multiSelecting ? "中" : ""
      ] })
    ] });
    const wrapActionsPopover = (btn2) => {
      return jsx$1(Popover, { styles: {
        container: {
          border: `1px solid ${popoverBorderColor}`
        }
      }, content: jsxs("div", { className: "max-w-288px", children: [
jsxs("div", { className: "flex items-start gap-x-6px", children: [
jsx$1(IconForInfo, { className: "mt-1 size-14px" }),
jsxs("div", { className: "flex-1 break-all", children: [
            "使用 ",
jsx$1("kbd", { className: clsx(kbdClassName, "mx-1"), children: "Shift" }),
            " 键扩选: 切换选中状态后, 按住",
            " ",
jsx$1("kbd", { className: clsx(kbdClassName, "mx-1"), children: "Shift" }),
            "键再选择区间终点, 整个区间会与起点选中状态同步."
          ] })
        ] }),
jsx$1(Divider, { variant: "solid", className: "my-7px" }),
jsxs("div", { className: "flex flex-wrap items-center gap-x-15px gap-y-2px", children: [
jsxs(Button$1, { className: "inline-flex items-center", onClick: () => multiSelectStore.selectedIdSet.clear(), children: [
jsx$1(IconForDelete, { className: "size-18px" }),
            "清空"
          ] }),
jsxs(Button$1, { className: "inline-flex items-center", onClick: () => {
            const newIdList = getCurrentGridItems().map((x) => x.uniqId);
            multiSelectStore.selectedIdSet = proxySet(newIdList);
          }, children: [
jsx$1(ForwardRef$q, { className: "size-18px" }),
            "全选"
          ] }),
jsxs(Button$1, { className: "inline-flex items-center", onClick: () => {
            const newIdList = getCurrentGridItems().filter((x) => !multiSelectStore.selectedIdSet.has(x.uniqId)).map((x) => x.uniqId);
            multiSelectStore.selectedIdSet = proxySet(newIdList);
          }, children: [
jsx$1(ForwardRef$p, { className: "size-18px" }),
            "反选"
          ] }),
jsx$1("div", { className: "flex-basis-100%" }),
jsxs(Button$1, { className: "inline-flex items-center", onClick: () => {
            multiSelectStore.multiSelecting = false;
            exitCheck();
          }, children: [
jsx$1(ForwardRef$o, { className: "size-18px" }),
            "退出"
          ] }),
jsx$1(CheckboxSettingItem, { configPath: "multiSelect.clearWhenExit", label: "退出时清空", tooltip: "退出多选时, 清空所有已选择项" })
        ] }),
        addCopyActions && jsxs(Fragment, { children: [
jsx$1(Divider, { variant: "solid", className: "my-7px" }),
jsx$1("div", { className: "flex flex-wrap gap-x-10px gap-y-5px", children: jsx$1(CopyBvidButtons, { showCopyBvidInfo: true }) })
        ] })
      ] }), children: btn2 });
    };
    if (multiSelecting) {
      return wrapActionsPopover(btn);
    } else {
      return iconOnly ? jsx$1(AntdTooltip, { title: "多选", arrow: false, children: btn }) : btn;
    }
  }
  const objectToString = Object.prototype.toString;
  const isError = (value) => objectToString.call(value) === "[object Error]";
  const errorMessages = new Set([
    "network error",
"Failed to fetch",
"NetworkError when attempting to fetch resource.",
"The Internet connection appears to be offline.",
"Network request failed",
"fetch failed",
"terminated",
" A network error occurred.",
"Network connection lost"
]);
  function isNetworkError(error) {
    const isValid = error && isError(error) && error.name === "TypeError" && typeof error.message === "string";
    if (!isValid) {
      return false;
    }
    const { message: message2, stack: stack2 } = error;
    if (message2 === "Load failed") {
      return stack2 === void 0 || "__sentry_captured__" in error;
    }
    if (message2.startsWith("error sending request for url")) {
      return true;
    }
    return errorMessages.has(message2);
  }
  function validateRetries(retries) {
    if (typeof retries === "number") {
      if (retries < 0) {
        throw new TypeError("Expected `retries` to be a non-negative number.");
      }
      if (Number.isNaN(retries)) {
        throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
      }
    } else if (retries !== void 0) {
      throw new TypeError("Expected `retries` to be a number or Infinity.");
    }
  }
  function validateNumberOption(name, value, { min = 0, allowInfinity = false } = {}) {
    if (value === void 0) {
      return;
    }
    if (typeof value !== "number" || Number.isNaN(value)) {
      throw new TypeError(`Expected \`${name}\` to be a number${allowInfinity ? " or Infinity" : ""}.`);
    }
    if (!allowInfinity && !Number.isFinite(value)) {
      throw new TypeError(`Expected \`${name}\` to be a finite number.`);
    }
    if (value < min) {
      throw new TypeError(`Expected \`${name}\` to be ≥ ${min}.`);
    }
  }
  class AbortError2 extends Error {
    constructor(message2) {
      super();
      if (message2 instanceof Error) {
        this.originalError = message2;
        ({ message: message2 } = message2);
      } else {
        this.originalError = new Error(message2);
        this.originalError.stack = this.stack;
      }
      this.name = "AbortError";
      this.message = message2;
    }
  }
  function calculateDelay(retriesConsumed, options) {
    const attempt2 = Math.max(1, retriesConsumed + 1);
    const random2 = options.randomize ? Math.random() + 1 : 1;
    let timeout = Math.round(random2 * options.minTimeout * options.factor ** (attempt2 - 1));
    timeout = Math.min(timeout, options.maxTimeout);
    return timeout;
  }
  function calculateRemainingTime(start, max) {
    if (!Number.isFinite(max)) {
      return max;
    }
    return max - (performance.now() - start);
  }
  async function onAttemptFailure({ error, attemptNumber, retriesConsumed, startTime, options }) {
    const normalizedError = error instanceof Error ? error : new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
    if (normalizedError instanceof AbortError2) {
      throw normalizedError.originalError;
    }
    const retriesLeft = Number.isFinite(options.retries) ? Math.max(0, options.retries - retriesConsumed) : options.retries;
    const maxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;
    const context = Object.freeze({
      error: normalizedError,
      attemptNumber,
      retriesLeft,
      retriesConsumed
    });
    await options.onFailedAttempt(context);
    if (calculateRemainingTime(startTime, maxRetryTime) <= 0) {
      throw normalizedError;
    }
    const consumeRetry = await options.shouldConsumeRetry(context);
    const remainingTime = calculateRemainingTime(startTime, maxRetryTime);
    if (remainingTime <= 0 || retriesLeft <= 0) {
      throw normalizedError;
    }
    if (normalizedError instanceof TypeError && !isNetworkError(normalizedError)) {
      if (consumeRetry) {
        throw normalizedError;
      }
      options.signal?.throwIfAborted();
      return false;
    }
    if (!await options.shouldRetry(context)) {
      throw normalizedError;
    }
    if (!consumeRetry) {
      options.signal?.throwIfAborted();
      return false;
    }
    const delayTime = calculateDelay(retriesConsumed, options);
    const finalDelay = Math.min(delayTime, remainingTime);
    options.signal?.throwIfAborted();
    if (finalDelay > 0) {
      await new Promise((resolve, reject) => {
        const onAbort = () => {
          clearTimeout(timeoutToken);
          options.signal?.removeEventListener("abort", onAbort);
          reject(options.signal.reason);
        };
        const timeoutToken = setTimeout(() => {
          options.signal?.removeEventListener("abort", onAbort);
          resolve();
        }, finalDelay);
        if (options.unref) {
          timeoutToken.unref?.();
        }
        options.signal?.addEventListener("abort", onAbort, { once: true });
      });
    }
    options.signal?.throwIfAborted();
    return true;
  }
  async function pRetry(input, options = {}) {
    options = { ...options };
    validateRetries(options.retries);
    if (Object.hasOwn(options, "forever")) {
      throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
    }
    options.retries ??= 10;
    options.factor ??= 2;
    options.minTimeout ??= 1e3;
    options.maxTimeout ??= Number.POSITIVE_INFINITY;
    options.maxRetryTime ??= Number.POSITIVE_INFINITY;
    options.randomize ??= false;
    options.onFailedAttempt ??= () => {
    };
    options.shouldRetry ??= () => true;
    options.shouldConsumeRetry ??= () => true;
    validateNumberOption("factor", options.factor, { min: 0, allowInfinity: false });
    validateNumberOption("minTimeout", options.minTimeout, { min: 0, allowInfinity: false });
    validateNumberOption("maxTimeout", options.maxTimeout, { min: 0, allowInfinity: true });
    validateNumberOption("maxRetryTime", options.maxRetryTime, { min: 0, allowInfinity: true });
    if (!(options.factor > 0)) {
      options.factor = 1;
    }
    options.signal?.throwIfAborted();
    let attemptNumber = 0;
    let retriesConsumed = 0;
    const startTime = performance.now();
    while (Number.isFinite(options.retries) ? retriesConsumed <= options.retries : true) {
      attemptNumber++;
      try {
        options.signal?.throwIfAborted();
        const result = await input(attemptNumber);
        options.signal?.throwIfAborted();
        return result;
      } catch (error) {
        if (await onAttemptFailure({
          error,
          attemptNumber,
          retriesConsumed,
          startTime,
          options
        })) {
          retriesConsumed++;
        }
      }
    }
    throw new Error("Retry attempts exhausted without throwing an error.");
  }
  var SpaceUploadOrder = ((SpaceUploadOrder2) => {
    SpaceUploadOrder2["Latest"] = "pubdate";
    SpaceUploadOrder2["View"] = "click";
    SpaceUploadOrder2["Fav"] = "stow";
    return SpaceUploadOrder2;
  })(SpaceUploadOrder || {});
  const SpaceUploadOrderConfig = {
    [
      "pubdate"
]: {
      icon: jsx$1(IconForTimestamp, {}),
      label: "最新发布"
    },
    [
      "click"
]: {
      icon: jsx$1(IconForPlayer, {}),
      label: "最多播放"
    },
    [
      "stow"
]: {
      icon: jsx$1(IconForFav, {}),
      label: "最多收藏"
    }
  };
  const SPACE_UPLOAD_API_PAGE_SIZE = 40;
  async function getSpaceUpload({
    mid,
    order = "pubdate",
    keyword = "",
    pagenum = 1
  }) {
    const res = await request.get("/x/space/wbi/arc/search", {
      params: {
        mid,
        order,
        keyword,
        ps: SPACE_UPLOAD_API_PAGE_SIZE,
        pn: pagenum
      }
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      throw new Error(`request json error: ${json.message}` || OPERATION_FAIL_MSG);
    }
    const items = json.data.list.vlist || [];
    const count = json.data.page.count;
    let hasMore;
    let endVol;
    {
      const {
        count: count2,
        pn,
        ps
      } = json.data.page;
      hasMore = pn * ps < count2;
      endVol = count2 - (pn - 1) * ps;
    }
    return {
      items,
      hasMore,
      count,
      endVol
    };
  }
  async function tryGetSpaceUpload(...args) {
    return await pRetry(() => getSpaceUpload(...args), {
      retries: 5,
      factor: 1.5,
      onFailedAttempt: (err) => console.error(err)
    });
  }
  var SpaceUploadQueryKey = ((SpaceUploadQueryKey2) => {
    SpaceUploadQueryKey2["Mid"] = "space-mid";
    SpaceUploadQueryKey2["GroupId"] = "space-group-id";
    SpaceUploadQueryKey2["SearchText"] = "space-search-text";
    SpaceUploadQueryKey2["FilterText"] = "space-filter-text";
    SpaceUploadQueryKey2["InitialPage"] = "space-initial-page";
    return SpaceUploadQueryKey2;
  })(SpaceUploadQueryKey || {});
  const searchParams$2 = new URLSearchParams(location.search);
  const QUERY_SPACE_UPLOAD_MID = searchParams$2.get(
    "space-mid"
) || void 0;
  const QUERY_SPACE_UPLOAD_GROUP_ID = searchParams$2.get(
    "space-group-id"
) || void 0;
  const QUERY_SPACE_UPLOAD_SEARCH_TEXT = searchParams$2.get(
    "space-search-text"
) || void 0;
  const QUERY_SPACE_UPLOAD_FILTER_TEXT = searchParams$2.get(
    "space-filter-text"
) || void 0;
  const QUERY_SPACE_UPLOAD_INITIAL_PAGE = searchParams$2.get(
    "space-initial-page"
) || void 0;
  const mids = (QUERY_SPACE_UPLOAD_MID || "").split(/[,_-]/).map((x) => x.trim()).filter(Boolean).filter((x) => /^\d+$/.test(x));
  const groupId = QUERY_SPACE_UPLOAD_GROUP_ID ? Number(QUERY_SPACE_UPLOAD_GROUP_ID) : void 0;
  const SHOW_SPACE_UPLOAD_ONLY = !!mids.length || groupId !== void 0;
  const store$2 = proxy({
    mids,
    groupId,
    order: SpaceUploadOrder.Latest,
    searchText: QUERY_SPACE_UPLOAD_SEARCH_TEXT,
    filterText: QUERY_SPACE_UPLOAD_FILTER_TEXT,
    get isMultipleTraget() {
      return this.mids.length > 1 || this.groupId !== void 0;
    },
    get allowedOrders() {
      return [SpaceUploadOrder.Latest, SpaceUploadOrder.View, !this.isMultipleTraget && SpaceUploadOrder.Fav].filter(Boolean);
    },
    get usingOrder() {
      return this.allowedOrders.includes(this.order) ? this.order : this.allowedOrders[0];
    }
  });
  function getOnlyTab() {
    if (SHOW_DYNAMIC_FEED_ONLY) return ETab.DynamicFeed;
    if (SHOW_FAV_TAB_ONLY) return ETab.Fav;
    if (SHOW_SPACE_UPLOAD_ONLY) return ETab.SpaceUpload;
    if (searchParams$1.get(
      "gate-tab"
)) return searchParams$1.get(
      "gate-tab"
);
  }
  var GateQueryKey = ((GateQueryKey2) => {
    GateQueryKey2["MainSwitch"] = "gate";
    GateQueryKey2["Tab"] = "gate-tab";
    return GateQueryKey2;
  })(GateQueryKey || {});
  const searchParams$1 = new URL(location.href).searchParams;
  function inGateEntry() {
    return searchParams$1.has(
      "gate"
);
  }
  function getGateEntryHref() {
    const u2 = new URL(location.href);
    u2.search = "";
    u2.searchParams.set("gate", "1");
    return u2.href;
  }
  const lineMdDownloadOutlineLoop = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsxs("path", { strokeDasharray: 20, d: "M12 4h2v6h2.5l-4.5 4.5M12 4h-2v6h-2.5l4.5 4.5", children: [
jsx$1("animate", { attributeName: "d", dur: "1.5s", keyTimes: "0;0.5;1", repeatCount: "indefinite", values: "M12 4h2v6h2.5l-4.5 4.5M12 4h-2v6h-2.5l4.5 4.5;M12 4h2v3h2.5l-4.5 4.5M12 4h-2v3h-2.5l4.5 4.5;M12 4h2v6h2.5l-4.5 4.5M12 4h-2v6h-2.5l4.5 4.5" }),
jsx$1("animate", { fill: "freeze", attributeName: "stroke-dashoffset", dur: "0.5s", values: "20;0" })
      ] }),
jsx$1("path", { strokeDasharray: 14, strokeDashoffset: 14, d: "M6 19h12", children: jsx$1("animate", { fill: "freeze", attributeName: "stroke-dashoffset", begin: "0.5s", dur: "0.2s", to: 0 }) })
    ] })
  ] });
  const ForwardRef$n = reactExports.forwardRef(lineMdDownloadOutlineLoop);
  function CopyBvidButtons({
    showCopyBvidInfo
  }) {
    const {
      __internalEnableCopyBvidInfo
    } = useSettingsSnapshot();
    const hasCopyBvidInfo = showCopyBvidInfo ?? __internalEnableCopyBvidInfo;
    return jsxs(Fragment, { children: [
jsxs(Button$1, { onClick: copyBvidsSingleLine, className: "inline-flex-center", children: [
jsx$1(IconForCopy, {}),
        " 复制 BVID"
      ] }),
      hasCopyBvidInfo && jsxs(Button$1, { onClick: copyBvidInfos, className: "inline-flex-center", children: [
jsx$1(IconForCopy, {}),
        " 复制 BVID 信息"
      ] })
    ] });
  }
  function CopyBvidButtonsTabbarView() {
    const {
      __internalAddTabbarCopyBvidButton: enabled2
    } = useSettingsSnapshot();
    if (!enabled2) return null;
    return jsx$1("div", { className: "flex items-center gap-x-2", children: jsxs(ConfigProvider, { theme: {
      components: {
        Button: {
          paddingInline: 6
        }
      }
    }, children: [
jsx$1(ButtonLoadToEnd, {}),
jsx$1(MultiSelectButton, { iconOnly: false }),
jsx$1(CopyBvidButtons, {})
    ] }) });
  }
  function ButtonLoadToEnd() {
    const supportsLoadToEnd = reactExports.useMemo(querySupportsLoadToEnd, []);
    const {
      recSharedEmitter
    } = useRecSelfContext();
    const $req = useRequest(() => recSharedEmitter.emit("load-to-end"), {
      manual: true
    });
    return supportsLoadToEnd && jsxs(Button$1, { className: "flex items-center gap-x-1", loading: $req.loading, onClick: () => $req.run(), children: [
      !$req.loading && jsx$1(ForwardRef$n, { className: "size-18px" }),
      "加载全部"
    ] });
  }
  function querySupportsLoadToEnd() {
    const onlyTab = getOnlyTab();
    return !!onlyTab && [ETab.DynamicFeed, ETab.SpaceUpload].includes(onlyTab);
  }
  const dropdownMenuStyle = {
    overscrollBehavior: "contain",
    maxHeight: "60vh",
    overflowY: "scroll",
    scrollbarWidth: "thin",
    paddingRight: "12px"
  };
  const lucideList = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M3 5h.01M3 12h.01M3 19h.01M8 5h13M8 12h13M8 19h13" })
  ] });
  const ForwardRef$m = reactExports.forwardRef(lucideList);
  const lucideFolderLock = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsx$1("rect", { width: 8, height: 5, x: 14, y: 17, rx: 1 }),
jsx$1("path", { d: "M10 20H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H20a2 2 0 0 1 2 2v2.5" }),
jsx$1("path", { d: "M20 17v-2a2 2 0 1 0-4 0v2" })
    ] })
  ] });
  const ForwardRef$l = reactExports.forwardRef(lucideFolderLock);
  const lucideFolder = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z" })
  ] });
  const ForwardRef$k = reactExports.forwardRef(lucideFolder);
  const ionLayersOutline = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 512 512", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 32, d: "m434.8 137.65l-149.36-68.1c-16.19-7.4-42.69-7.4-58.88 0L77.3 137.65c-17.6 8-17.6 21.09 0 29.09l148 67.5c16.89 7.7 44.69 7.7 61.58 0l148-67.5c17.52-8 17.52-21.1-.08-29.09M160 308.52l-82.7 37.11c-17.6 8-17.6 21.1 0 29.1l148 67.5c16.89 7.69 44.69 7.69 61.58 0l148-67.5c17.6-8 17.6-21.1 0-29.1l-79.94-38.47" }),
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 32, d: "m160 204.48l-82.8 37.16c-17.6 8-17.6 21.1 0 29.1l148 67.49c16.89 7.7 44.69 7.7 61.58 0l148-67.49c17.7-8 17.7-21.1.1-29.1L352 204.48" })
  ] });
  const ForwardRef$j = reactExports.forwardRef(ionLayersOutline);
  const IconForAll = ForwardRef$m;
  const IconForPrivateFolder = ForwardRef$l;
  const IconForPublicFolder = ForwardRef$k;
  const IconForCollection = ForwardRef$j;
  const viewLocalStore = proxyWithLocalStorage({
    sidebarFavFolderOrder: "default"
  }, "fav-rec-service:view");
  function useScopeMenus$1(parentView, extraOnMenuItemClick) {
    const {
      folders,
      collections,
      selectedKey
    } = useSnapshot(favStore);
    const {
      sidebarFavFolderOrder
    } = useSnapshot(viewLocalStore);
    const onRefresh = useOnRefresh();
    const menuItems = reactExports.useMemo(() => {
      let menuItemFavFolders;
      {
        let _folders = folders;
        let labelAddon;
        if (parentView === "sidebarView") {
          labelAddon = jsx$1(FavFolderOrderSwitcher, { value: sidebarFavFolderOrder, onChange: (v) => viewLocalStore.sidebarFavFolderOrder = v, className: "ml-4" });
          _folders = sortFavFolders(folders, sidebarFavFolderOrder);
        }
        const subMenus = _folders.map((f2) => {
          isFavFolderDefault(f2.attr);
          const isPrivate = isFavFolderPrivate(f2.attr);
          const key = `fav-folder:${f2.id}`;
          const icon = isPrivate ? jsx$1(IconForPrivateFolder, {}) : jsx$1(IconForPublicFolder, {});
          const label = `${f2.title} (${f2.media_count})`;
          return {
            key,
            icon,
            label,
            async onClick() {
              favStore.selectedFavFolderId = f2.id;
              favStore.selectedFavCollectionId = void 0;
              extraOnMenuItemClick?.();
              await delay$1(100);
              onRefresh();
            }
          };
        });
        menuItemFavFolders = !!_folders.length && {
          type: "group",
          label: jsxs("div", { className: "flex items-center justify-between line-height-snug", children: [
            "收藏夹",
            labelAddon
          ] }),
          children: subMenus
        };
      }
      let menuItemFavCollections;
      {
        const collectionGrouped = groupBy(collections, (x) => x.upper.name);
        let entries = Object.entries(collectionGrouped).map(([upName, collections2]) => ({
          upName,
          collections: sortListByName(collections2, "title")
        }));
        entries = sortListByName(entries, "upName");
        const subMenus = [];
        for (const {
          upName,
          collections: collections2
        } of entries) {
          const upMid = collections2[0]?.upper.mid;
          const upSpaceUrl = upMid ? formatSpaceUrl(upMid) : "#";
          subMenus.push(...defineAntMenus([{
            type: "group",
            label: jsxs("span", { className: "flex items-center gap-x-2px", children: [
jsx$1(IconForOpenExternalLink, { className: "mt-2px size-15px flex-none" }),
jsxs("a", { target: "_blank", href: upSpaceUrl, children: [
                "@",
                upName
              ] })
            ] }),
            children: collections2.map((f2) => {
              const key = `fav-collection:${f2.id}`;
              const label = jsxs("span", { className: "ml-8px flex items-center gap-x-2px", children: [
jsx$1(IconForCollection, { className: "size-15px flex-none" }),
                f2.title,
                " (",
                f2.media_count,
                ")"
              ] });
              return {
                key,
                label,
                title: `${f2.title} (${f2.media_count})`,
                async onClick() {
                  favStore.selectedFavFolderId = void 0;
                  favStore.selectedFavCollectionId = f2.id;
                  extraOnMenuItemClick?.();
                  await delay$1(100);
                  onRefresh();
                }
              };
            })
          }]));
        }
        menuItemFavCollections = !!collections.length && {
          type: "group",
          label: "合集",
          children: subMenus
        };
      }
      return defineAntMenus([{
        key: "all",
        icon: jsx$1(IconForAll, {}),
        label: "全部",
        async onClick() {
          favStore.selectedFavFolderId = void 0;
          favStore.selectedFavCollectionId = void 0;
          extraOnMenuItemClick?.();
          await delay$1(100);
          onRefresh();
        }
      }, menuItemFavFolders, menuItemFavCollections]);
    }, [folders, collections, parentView, sidebarFavFolderOrder, onRefresh]);
    return {
      menuItems,
      selectedKey
    };
  }
  function FavTabbarView({
    extraContent
  }) {
    const {
      fav,
      enableSidebar
    } = useSettingsSnapshot();
    const {
      selectedFavFolder,
      selectedFavCollection,
      selectedLabel,
      selectedKey
    } = useSnapshot(favStore);
    const onRefresh = useOnRefresh();
    const {
      ref: ref2,
      getPopupContainer
    } = usePopupContainer();
    useMount(() => {
      updateFavList();
    });
    useUpdateEffect(() => {
      void (async () => {
        await delay$1(100);
        onRefresh();
      })();
    }, [fav.addSeparator]);
    const [scopeDropdownOpen, setScopeDropdownOpen] = reactExports.useState(false);
    const {
      menuItems
    } = useScopeMenus$1("tabbarView", () => {
      setScopeDropdownOpen(false);
    });
    const dropdownButtonClassName = "relative top-[-0.5px] size-15px";
    const dropdownButtonIcon = selectedFavFolder ? isFavFolderPrivate(selectedFavFolder.attr) ? jsx$1(IconForPrivateFolder, { className: dropdownButtonClassName }) : jsx$1(IconForPublicFolder, { className: dropdownButtonClassName }) : selectedFavCollection ? jsx$1(IconForCollection, { className: dropdownButtonClassName }) : jsx$1(IconForAll, { className: dropdownButtonClassName });
    const dropdownButtonLabel = selectedLabel;
    const scopeSelectionDropdown = jsx$1(Dropdown, { open: scopeDropdownOpen, onOpenChange: setScopeDropdownOpen, placement: "bottomLeft", getPopupContainer, menu: {
      items: menuItems,
      style: {
        ...dropdownMenuStyle,
        border: `1px solid ${usePopoverBorderColor()}`
      },
      selectedKeys: [selectedKey]
    }, children: jsx$1(Button$1, { css: [scopeDropdownOpen && buttonOpenCss, "", ""], children: jsxs("span", { className: "h-full flex items-center gap-x-4px", children: [
      dropdownButtonIcon,
      dropdownButtonLabel
    ] }) }) });
    return jsxs("div", { ref: ref2, className: "flex items-center gap-x-10px", children: [
      !enableSidebar && scopeSelectionDropdown,
      extraContent,
jsx$1(CopyBvidButtonsTabbarView, {})
    ] });
  }
  function ViewingAllExcludeFolderConfig({
    allFavFolderServices,
    state: state2
  }) {
    const {
      fav
    } = useSettingsSnapshot();
    const onRefresh = useOnRefresh();
    const {
      ref: ref2,
      getPopupContainer
    } = usePopupContainer();
    const {
      totalCountInFavFolders
    } = useSnapshot(state2);
    const [excludeFavFolderIdsChanged, setExcludeFavFolderIdsChanged] = reactExports.useState(false);
    const handleChange = useMemoizedFn((newTargetKeys, direction, moveKeys) => {
      setExcludeFavFolderIdsChanged(true);
      settings.fav.excludedFolderIds = newTargetKeys.map((k) => k.toString());
    });
    const foldersCount = reactExports.useMemo(() => allFavFolderServices.filter((x) => !fav.excludedFolderIds.includes(x.entry.id.toString())).length, [allFavFolderServices, fav.excludedFolderIds]);
    const onPopupOpenChange = useMemoizedFn((open2) => {
      if (open2) {
        setExcludeFavFolderIdsChanged(false);
      } else if (excludeFavFolderIdsChanged) {
        onRefresh();
      }
    });
    return jsx$1(Popover, { getTooltipContainer: getPopupContainer, trigger: "click", placement: "bottom", onOpenChange: onPopupOpenChange, getPopupContainer: (el) => el.parentElement || document.body, content: jsx$1(Fragment, { children: jsx$1(Transfer, { dataSource: allFavFolderServices, rowKey: (row) => row.entry.id.toString(), titles: ["收藏夹", "忽略"], targetKeys: fav.excludedFolderIds, onChange: handleChange, render: (item) => item.entry.title, oneWay: true, style: {
      marginBottom: 10
    } }) }), children: jsxs(Tag, { ref: ref2, color: "success", className: "mx-0 cursor-pointer text-size-12px", children: [
      "收藏夹(",
      foldersCount,
      ") 收藏(",
      totalCountInFavFolders,
      ")"
    ] }) });
  }
  function FavSidebarView() {
    const {
      menuItems,
      selectedKey
    } = useScopeMenus$1("sidebarView");
    const {
      menuRef
    } = useRevealMenuSelectedKey(menuItems, selectedKey);
    return jsxs(Fragment, { children: [
jsx$1(Menu, { ref: menuRef, items: menuItems, selectedKeys: [selectedKey], mode: "inline", inlineIndent: 10 }),
      sidebarBottomLine
    ] });
  }
  var ELiveStatus = ((ELiveStatus2) => {
    ELiveStatus2[ELiveStatus2["Offline"] = 0] = "Offline";
    ELiveStatus2[ELiveStatus2["Streaming"] = 1] = "Streaming";
    ELiveStatus2[ELiveStatus2["Rolling"] = 2] = "Rolling";
    return ELiveStatus2;
  })(ELiveStatus || {});
  class QuickLRU extends Map {
    #size = 0;
    #cache = new Map();
    #oldCache = new Map();
    #maxSize;
    #maxAge;
    #onEviction;
    constructor(options = {}) {
      super();
      if (!(options.maxSize && options.maxSize > 0)) {
        throw new TypeError("`maxSize` must be a number greater than 0");
      }
      if (typeof options.maxAge === "number" && options.maxAge === 0) {
        throw new TypeError("`maxAge` must be a number greater than 0");
      }
      this.#maxSize = options.maxSize;
      this.#maxAge = options.maxAge || Number.POSITIVE_INFINITY;
      this.#onEviction = options.onEviction;
    }
get __oldCache() {
      return this.#oldCache;
    }
    #emitEvictions(cache2) {
      if (typeof this.#onEviction !== "function") {
        return;
      }
      for (const [key, item] of cache2) {
        this.#onEviction(key, item.value);
      }
    }
    #deleteIfExpired(key, item) {
      if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
        if (typeof this.#onEviction === "function") {
          this.#onEviction(key, item.value);
        }
        return this.delete(key);
      }
      return false;
    }
    #getOrDeleteIfExpired(key, item) {
      const deleted = this.#deleteIfExpired(key, item);
      if (deleted === false) {
        return item.value;
      }
    }
    #getItemValue(key, item) {
      return item.expiry ? this.#getOrDeleteIfExpired(key, item) : item.value;
    }
    #peek(key, cache2) {
      const item = cache2.get(key);
      return this.#getItemValue(key, item);
    }
    #set(key, value) {
      this.#cache.set(key, value);
      this.#size++;
      if (this.#size >= this.#maxSize) {
        this.#size = 0;
        this.#emitEvictions(this.#oldCache);
        this.#oldCache = this.#cache;
        this.#cache = new Map();
      }
    }
    #moveToRecent(key, item) {
      this.#oldCache.delete(key);
      this.#set(key, item);
    }
    *#entriesAscending() {
      for (const item of this.#oldCache) {
        const [key, value] = item;
        if (!this.#cache.has(key)) {
          const deleted = this.#deleteIfExpired(key, value);
          if (deleted === false) {
            yield item;
          }
        }
      }
      for (const item of this.#cache) {
        const [key, value] = item;
        const deleted = this.#deleteIfExpired(key, value);
        if (deleted === false) {
          yield item;
        }
      }
    }
    get(key) {
      if (this.#cache.has(key)) {
        const item = this.#cache.get(key);
        return this.#getItemValue(key, item);
      }
      if (this.#oldCache.has(key)) {
        const item = this.#oldCache.get(key);
        if (this.#deleteIfExpired(key, item) === false) {
          this.#moveToRecent(key, item);
          return item.value;
        }
      }
    }
    set(key, value, { maxAge = this.#maxAge } = {}) {
      const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
      if (this.#cache.has(key)) {
        this.#cache.set(key, {
          value,
          expiry
        });
      } else {
        this.#set(key, { value, expiry });
      }
      return this;
    }
    has(key) {
      if (this.#cache.has(key)) {
        return !this.#deleteIfExpired(key, this.#cache.get(key));
      }
      if (this.#oldCache.has(key)) {
        return !this.#deleteIfExpired(key, this.#oldCache.get(key));
      }
      return false;
    }
    peek(key) {
      if (this.#cache.has(key)) {
        return this.#peek(key, this.#cache);
      }
      if (this.#oldCache.has(key)) {
        return this.#peek(key, this.#oldCache);
      }
    }
    expiresIn(key) {
      const item = this.#cache.get(key) ?? this.#oldCache.get(key);
      if (item) {
        return item.expiry ? item.expiry - Date.now() : Number.POSITIVE_INFINITY;
      }
    }
    delete(key) {
      const deleted = this.#cache.delete(key);
      if (deleted) {
        this.#size--;
      }
      return this.#oldCache.delete(key) || deleted;
    }
    clear() {
      this.#cache.clear();
      this.#oldCache.clear();
      this.#size = 0;
    }
    resize(newSize) {
      if (!(newSize && newSize > 0)) {
        throw new TypeError("`maxSize` must be a number greater than 0");
      }
      const items = [...this.#entriesAscending()];
      const removeCount = items.length - newSize;
      if (removeCount < 0) {
        this.#cache = new Map(items);
        this.#oldCache = new Map();
        this.#size = items.length;
      } else {
        if (removeCount > 0) {
          this.#emitEvictions(items.slice(0, removeCount));
        }
        this.#oldCache = new Map(items.slice(removeCount));
        this.#cache = new Map();
        this.#size = 0;
      }
      this.#maxSize = newSize;
    }
    evict(count = 1) {
      const requested = Number(count);
      if (!requested || requested <= 0) {
        return;
      }
      const items = [...this.#entriesAscending()];
      const evictCount = Math.trunc(Math.min(requested, Math.max(items.length - 1, 0)));
      if (evictCount <= 0) {
        return;
      }
      this.#emitEvictions(items.slice(0, evictCount));
      this.#oldCache = new Map(items.slice(evictCount));
      this.#cache = new Map();
      this.#size = 0;
    }
    *keys() {
      for (const [key] of this) {
        yield key;
      }
    }
    *values() {
      for (const [, value] of this) {
        yield value;
      }
    }
    *[Symbol.iterator]() {
      for (const item of this.#cache) {
        const [key, value] = item;
        const deleted = this.#deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
      for (const item of this.#oldCache) {
        const [key, value] = item;
        if (!this.#cache.has(key)) {
          const deleted = this.#deleteIfExpired(key, value);
          if (deleted === false) {
            yield [key, value.value];
          }
        }
      }
    }
    *entriesDescending() {
      let items = [...this.#cache];
      for (let i2 = items.length - 1; i2 >= 0; --i2) {
        const item = items[i2];
        const [key, value] = item;
        const deleted = this.#deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
      items = [...this.#oldCache];
      for (let i2 = items.length - 1; i2 >= 0; --i2) {
        const item = items[i2];
        const [key, value] = item;
        if (!this.#cache.has(key)) {
          const deleted = this.#deleteIfExpired(key, value);
          if (deleted === false) {
            yield [key, value.value];
          }
        }
      }
    }
    *entriesAscending() {
      for (const [key, value] of this.#entriesAscending()) {
        yield [key, value.value];
      }
    }
    get size() {
      if (!this.#size) {
        return this.#oldCache.size;
      }
      let oldCacheSize = 0;
      for (const key of this.#oldCache.keys()) {
        if (!this.#cache.has(key)) {
          oldCacheSize++;
        }
      }
      return Math.min(this.#size + oldCacheSize, this.#maxSize);
    }
    get maxSize() {
      return this.#maxSize;
    }
    get maxAge() {
      return this.#maxAge;
    }
    entries() {
      return this.entriesAscending();
    }
    forEach(callbackFunction, thisArgument = this) {
      for (const [key, value] of this.entriesAscending()) {
        callbackFunction.call(thisArgument, value, key, this);
      }
    }
    get [Symbol.toStringTag]() {
      return "QuickLRU";
    }
    toString() {
      return `QuickLRU(${this.size}/${this.maxSize})`;
    }
    [ Symbol.for("nodejs.util.inspect.custom")]() {
      return this.toString();
    }
  }
  const tablerFaceIdError = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 8V6a2 2 0 0 1 2-2h2M4 16v2a2 2 0 0 0 2 2h2m8-16h2a2 2 0 0 1 2 2v2m-4 12h2a2 2 0 0 0 2-2v-2M9 10h.01M15 10h.01M9.5 15.05a3.5 3.5 0 0 1 5 0" })
  ] });
  const ForwardRef$i = reactExports.forwardRef(tablerFaceIdError);
  function isAxiosError(err) {
    return err instanceof Error && err.name === "AxiosError";
  }
  function wrapWithParagraph(node2) {
    if (!node2) return node2;
    return jsx$1("p", { className: "mt-10px", children: node2 });
  }
  function inspectErrDetail(err) {
    if (!(err && err instanceof Error)) {
      return wrapWithParagraph(JSON.stringify(err));
    }
    const errMessage = !!err.message && jsxs(Fragment, { children: [
      "Error Message: ",
      err.message
    ] });
    const errStack = !!err.stack && jsxs(Fragment, { children: [
      "Error Stack: ",
jsx$1("br", {}),
      err.stack
    ] });
    let errCause;
    let errAxiosErrorDetail;
    if (err.cause) {
      errCause = jsxs(Fragment, { children: [
        "Error Cause: ",
        inspectErrDetail(err.cause)
      ] });
    }
    if (isAxiosError(err)) {
      const _err = cloneDeep(err);
      if (_err.config?.params?.access_key) {
        _err.config.params.access_key = "*".repeat(_err.config.params.access_key.length);
      }
      errAxiosErrorDetail = jsxs(Fragment, { children: [
        "axios config: ",
        JSON.stringify(_err.config, null, 2)
      ] });
    }
    return jsxs(Fragment, { children: [
      wrapWithParagraph(errMessage),
      wrapWithParagraph(errStack),
      wrapWithParagraph(errCause),
      wrapWithParagraph(errAxiosErrorDetail)
    ] });
  }
  function getErrLabel(err) {
    if (err && err instanceof ShowMessageError && err.message) return err.message;
    if (err && err instanceof NeedValidAccessKeyError) return err.message;
    return "出错了, 请刷新重试!";
  }
  class ShowMessageError extends Error {
    constructor(message2) {
      super(message2);
      this.name = "ShowMessageError";
    }
  }
  function ErrorDetail({
    err,
    tab: tab2
  }) {
    const target = useLinkTarget();
    const errLabel = reactExports.useMemo(() => getErrLabel(err), [err]);
    const errDetail = reactExports.useMemo(() => inspectErrDetail(err), [err]);
    return jsxs("div", { className: "flex flex-col items-center gap-y-0.5em p-20px text-center text-size-20px", children: [
jsx$1(AntdTooltip, { title: jsxs("div", { className: "py-10px", children: [
jsx$1("h3", { children: "错误详情" }),
jsx$1("div", { className: "max-h-50vh overflow-hidden overflow-y-auto whitespace-pre-wrap break-normal", children: errDetail })
      ] }), children: jsxs("p", { className: "flex cursor-pointer items-center justify-center", children: [
jsx$1(ForwardRef$i, { className: "mr-4px" }),
        errLabel
      ] }) }),
      tab2 === ETab.Hot && hotStore.subtab === EHotSubTab.PopularWeekly && jsxs("p", { className: "mt-8px flex items-center justify-center", children: [
        "可能需手动输入验证码",
jsx$1(IconForOpenExternalLink, { className: "ml-12px" }),
jsx$1("a", { href: "https://www.bilibili.com/v/popular/weekly", target, className: "ml-2px", children: "每周必看" })
      ] }),
      tab2 === ETab.Liked && err instanceof NeedValidAccessKeyError && jsx$1(AccessKeyManage, { className: "mt-0.5em" })
    ] });
  }
  function followActionFactory(action2) {
    const act2 = action2 === "follow" ? 1 : 2;
    return async function followAction(upMid) {
      const success = await modifyRelations(upMid, act2);
      return success;
    };
  }
  const follow = followActionFactory("follow");
  const unfollow = followActionFactory("unfollow");
  const UserfollowService = {
    follow,
    unfollow
  };
  function isFollowedFromRelationAttribute(relationAttribute) {
    return [1, 2, 6].includes(relationAttribute.attribute);
  }
  async function queryFollowState(upMid) {
    const res = await request.get("/x/relation", {
      params: {
        fid: upMid
      }
    });
    const json = res.data;
    return json.data;
  }
  const queryFollowStateMemoized = pMemoize(queryFollowState, {
    cacheKey: ([upMid]) => upMid.toString()
  });
  async function __fetchSpaceAccInfo(mid) {
    const res = await request.get("/x/space/wbi/acc/info", {
      params: {
        mid,
        w_webid: await get_w_webId() || ""
      }
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      appWarn("space acc info error for %s: %o", mid, json);
      return;
    }
    const info = json.data;
    return info;
  }
  const getSpaceAccInfo = wrapWithIdbCache({
    fn: __fetchSpaceAccInfo,
    generateKey: (mid) => mid.toString(),
    tableName: "space-acc-info",
    ttl: ms("10d"),
    concurrency: 2
});
  async function __fetchUserNickname(mid) {
    const info = await getSpaceAccInfo(mid);
    const nickname = info?.name;
    return nickname;
  }
  const getUserNickname = wrapWithIdbCache({
    fn: __fetchUserNickname,
    generateKey: (mid) => mid.toString(),
    tableName: "user-nickname",
    ttl: ms("10d")
  });
  async function setNicknameCache(mid, nickname) {
    await getUserNickname.cache.set(mid.toString(), {
      val: nickname,
      ts: Date.now()
    });
  }
  const advancedFilterHelpInfo = jsxs(Fragment, { children: [
    "1. 可以使用多个过滤词, 用空格分隔, 逻辑关系为且 (AND) ",
jsx$1("br", {}),
    '2. 可以使用引号包裹过滤词, 如 "word or sentence" ',
jsx$1("br", {}),
    '3. 可以使用 -"word or sentence" 排除; 必须使用引号(单引号 或 双引号) ',
jsx$1("br", {})
  ] });
  function parseAdvancedFilter(input) {
    const includes2 = [];
    const excludes = [];
    if (!input.trim()) {
      return {
        includes: includes2,
        excludes
      };
    }
    let currentPos = 0;
    const inputLength = input.length;
    while (currentPos < inputLength) {
      while (currentPos < inputLength && input[currentPos] === " ") {
        currentPos++;
      }
      if (currentPos >= inputLength) break;
      let isExclude = false;
      let word = "";
      if (input[currentPos] === "-") {
        const nextChar = input[currentPos + 1];
        if (nextChar === '"' || nextChar === "'") {
          isExclude = true;
          currentPos++;
        }
      }
      if (input[currentPos] === '"' || input[currentPos] === "'") {
        const startQuoteChar = input[currentPos];
        currentPos++;
        let escaped = false;
        while (currentPos < inputLength) {
          const char2 = input[currentPos];
          if (escaped) {
            word += char2;
            escaped = false;
            currentPos++;
            continue;
          }
          if (char2 === "\\") {
            const nextChar = input[currentPos + 1];
            if (nextChar === '"' || nextChar === "'") {
              escaped = true;
              currentPos++;
              continue;
            }
            word += char2;
            currentPos++;
            continue;
          }
          if (char2 === startQuoteChar) {
            currentPos++;
            break;
          }
          word += char2;
          currentPos++;
        }
      } else {
        while (currentPos < inputLength && input[currentPos] !== " ") {
          if (input[currentPos] === "\\") {
            currentPos++;
            if (currentPos < inputLength) {
              word += input[currentPos];
              currentPos++;
            }
            continue;
          }
          word += input[currentPos];
          currentPos++;
        }
      }
      if (word) {
        if (isExclude) {
          excludes.push(word);
        } else {
          includes2.push(word);
        }
      }
    }
    return {
      includes: includes2,
      excludes
    };
  }
  function isSpaceUploadItemChargeOnly(item) {
    if (item.elec_arc_type === 1 || !item.elec_arc_type && item.is_charging_arc) return true;
    if (item.elec_arc_type === 2) return true;
    return false;
  }
  const GenericOrderSwitcher = function({
    value,
    onChange,
    disabled,
    list: list2,
    listDisplayConfig,
    dropdownProps,
    extraHelpInfo: extraHelpInfo2,
    $ref
  }) {
    const {
      icon,
      label
    } = listDisplayConfig[value];
    const onToggle = useMemoizedFn((e) => {
      const allowed = list2.filter((x) => x !== "divider");
      const index = allowed.indexOf(value);
      if (index === -1) return;
      const nextIndex = (index + (e.shiftKey ? -1 : 1) + allowed.length) % allowed.length;
      const next2 = allowed[nextIndex];
      onChange(next2);
    });
    const dropdownMenuItems = reactExports.useMemo(() => {
      return defineAntMenus(list2.map((x) => {
        if (x === "divider") return {
          type: "divider"
        };
        const {
          icon: icon2,
          label: label2
        } = listDisplayConfig[x];
        return {
          key: x,
          icon: icon2,
          label: label2,
          onClick: () => onChange(x)
        };
      }));
    }, [list2, listDisplayConfig, onChange]);
    const [open2, setOpen] = reactExports.useState(false);
    const dropdownBorderStyle = usePopoverBorderStyle();
    return jsxs("span", { className: "inline-flex items-center", ref: $ref, children: [
jsx$1(Dropdown, { open: open2, onOpenChange: setOpen, disabled, menu: {
        items: dropdownMenuItems,
        selectedKeys: [value.toString()],
        styles: {
          root: dropdownBorderStyle
        }
      }, placement: "bottomRight", classNames: {
        root: "text-13px",
        item: "justify-start",
        itemContent: "flex-shrink-0"
      }, ...dropdownProps, children: jsxs(Button$1, { className: clsx(clsAntdButton, "px-3"), css: [open2 && buttonOpenCss, "", ""], disabled, onClick: onToggle, children: [
        icon,
        label
      ] }) }),
jsxs(HelpInfo, { children: [
        extraHelpInfo2,
        extraHelpInfo2 && jsx$1(TooltipContentDivider, {}),
        "操作说明: ",
jsx$1("br", {}),
        "1. 点击/下拉切换 ",
jsx$1("br", {}),
        "2. 按住 ",
jsx$1("kbd", { className: kbdClassName, children: "Shift" }),
        " 键点击逆序切换 ",
jsx$1("br", {})
      ] })
    ] });
  };
  function SpaceUploadTabbarView() {
    const {
      searchText,
      filterText
    } = useSnapshot(store$2, {
      sync: true
    });
    const {
      allowedOrders,
      usingOrder
    } = useSnapshot(store$2);
    const {
      spaceUpload: {
        useSyncFilterTextFromSearchText
      }
    } = useSettingsSnapshot();
    const onRefresh = useOnRefresh();
    const {
      recSharedEmitter
    } = useRecSelfContext();
    const onSyncStoreToUrl = useMemoizedFn(() => {
      syncFilterTextFromSearchText();
      const {
        searchText: searchText2,
        filterText: filterText2
      } = store$2;
      const currentUrl = location.href;
      const u2 = new URL(currentUrl);
      searchText2 ? u2.searchParams.set(SpaceUploadQueryKey.SearchText, searchText2) : u2.searchParams.delete(SpaceUploadQueryKey.SearchText);
      filterText2 ? u2.searchParams.set(SpaceUploadQueryKey.FilterText, filterText2) : u2.searchParams.delete(SpaceUploadQueryKey.FilterText);
      if (u2.href !== currentUrl) {
        history.replaceState({}, "", u2.href);
      }
    });
    const syncFilterTextFromSearchText = useMemoizedFn(() => {
      if (!settings.spaceUpload.useSyncFilterTextFromSearchText) return;
      store$2.filterText = store$2.searchText;
    });
    useMount(onSyncStoreToUrl);
    return jsxs("div", { className: "flex items-center gap-x-10px", children: [
jsx$1(GenericOrderSwitcher, { value: usingOrder, list: allowedOrders, listDisplayConfig: SpaceUploadOrderConfig, onChange: (value) => {
        store$2.order = value;
        onRefresh();
      } }),
jsx$1(Input.Search, { style: {
        width: 200
      }, placeholder: "搜索词", allowClear: true, value: searchText, onChange: (e) => store$2.searchText = e.target.value, onSearch: (value) => {
        store$2.searchText = value;
        onSyncStoreToUrl();
        onRefresh();
      } }),
jsxs(Space.Compact, { children: [
jsx$1(Space.Addon, { children: jsx$1(AntdTooltip, { title: jsx$1(Fragment, { children: "精准搜索: 自动将搜索词同步到过滤词" }), children: jsx$1(CheckboxSettingItem, { className: "[&>.ant-checkbox-label]:hidden", configPath: "spaceUpload.useSyncFilterTextFromSearchText", extraAction: (checked) => {
          if (checked) {
            onSyncStoreToUrl();
            onRefresh();
          }
        } }) }) }),
jsx$1(Input.Search, { style: {
          width: 200
        }, placeholder: "本地过滤词", allowClear: true, value: filterText, disabled: useSyncFilterTextFromSearchText, onChange: (e) => store$2.filterText = e.target.value, onSearch: (value) => {
          store$2.filterText = value;
          onSyncStoreToUrl();
          onRefresh();
        } })
      ] }),
jsx$1(CheckboxSettingItem, { configPath: "spaceUpload.showVol", label: "显示序号", className: "flex-none" }),
jsx$1(CopyBvidButtonsTabbarView, {})
    ] });
  }
  const spaceUploadAvatarCache = new QuickLRU({
    maxSize: 100
  });
  const spaceUploadFollowedMidSet = proxySet();
  async function trySetFollowedMidSet(upMid) {
    if (spaceUploadFollowedMidSet.has(upMid)) return;
    const state2 = await queryFollowStateMemoized(upMid);
    if (isFollowedFromRelationAttribute(state2)) {
      spaceUploadFollowedMidSet.add(upMid);
    }
  }
  function getSpaceUploadServiceConfig() {
    const snap = snapshot(store$2);
    return {
      mids: snap.mids,
      groupId: snap.groupId,
      order: snap.usingOrder,
      searchText: snap.searchText,
      filterText: snap.filterText,
      initialPage: QUERY_SPACE_UPLOAD_INITIAL_PAGE ? Number(QUERY_SPACE_UPLOAD_INITIAL_PAGE) : void 0
    };
  }
  class SpaceUploadService extends BaseTabService {
    constructor(config) {
      super(SpaceUploadService.PAGE_SIZE);
      this.config = config;
      Object.assign(this, config);
      this.mids = config.mids;
      this.order = config.order;
      invariant$1(this.mids.length || this.groupId !== void 0, "mid & groupId can not both be empty");
      this.searchText = this.searchText?.trim();
      if (this.initialPage && (this.groupId !== void 0 || this.mids.length > 1)) {
        throw new Error("initialPage not supported when merging");
      }
    }
    static PAGE_SIZE = 20;
mids;
    groupId;
    order;
    searchText;
    filterText;
    initialPage;
    sidebarView = void 0;
    tabbarView = jsx$1(SpaceUploadTabbarView, {});
    get hasMoreExceptQueue() {
      if (!this.service) return true;
      return this.service.hasMore;
    }
async fetchAvatars(mids2) {
      await Promise.all(mids2.map(async (mid) => {
        const info = await getSpaceAccInfo(mid);
        if (!info) return;
        spaceUploadAvatarCache.set(mid, info.face);
      }));
    }
    async fetchFollowState(mids2) {
      await pmap(mids2, trySetFollowedMidSet, 3);
    }
    pageTitleSet = false;
    async setPageTitle() {
      if (this.pageTitleSet) return;
      const prefixes = [];
      if (this.searchText) prefixes.push(`🔍【${this.searchText}】`);
      if (this.filterText) prefixes.push(`⏳【${this.filterText}】`);
      let author;
      if (this.mids.length) {
        const nicknames = await pmap(this.mids, getUserNickname, 3);
        author = nicknames.map((x) => x?.trim()).filter(Boolean).map((name) => `「${name}」`).join("、");
      } else {
        const tags = await getAllFollowGroups();
        const name = tags.find((x) => x.tagid === this.groupId)?.name || "";
        author = name ? `「${name}」` : "";
      }
      const title = [prefixes.join(""), `${author}的投稿`].map((x) => x.trim()).filter(Boolean).join(" - ");
      setPageTitle(title);
      this.pageTitleSet = true;
    }
singleUpService;
    mergeTimelineService;
    async setupServices() {
      if (this.singleUpService || this.mergeTimelineService) return;
      if (this.mids.length === 1) {
        this.singleUpService = new SingleUpService(this.mids[0], this.order, this.searchText, this.initialPage);
        return;
      }
      if (this.mids.length) {
        this.mergeTimelineService = new MergeTimelineService(this.mids, this.order, this.searchText);
        return;
      }
      if (this.groupId !== void 0) {
        const mids2 = await getFollowGroupContent(this.groupId);
        mids2.forEach((x) => spaceUploadFollowedMidSet.add(x));
        if (!mids2.length) throw new Error("Group is Empty!");
        this.mergeTimelineService = new MergeTimelineService(mids2.map((x) => x.toString()), this.order, this.searchText);
        return;
      }
    }
    get service() {
      return this.singleUpService || this.mergeTimelineService;
    }
    warnNeedLoginOnce = once(toastNeedLogin);
    async fetchMore(abortSignal) {
      if (!checkLoginStatus()) {
        this.warnNeedLoginOnce();
        throw new ShowMessageError(NEED_LOGIN_MESSAGE);
      }
      this.setPageTitle();
      await this.setupServices();
      invariant$1(this.service, "this.service should exist after setupServices");
      const items = await this.service.loadMore(abortSignal) || [];
      const endVol = this.singleUpService ? this.singleUpService.endVol : this.mergeTimelineService.count - this.qs.fetchedCount;
      let list2 = items.map((item, index) => {
        return {
          ...item,
          api: EApiType.SpaceUpload,
          uniqId: `${EApiType.SpaceUpload}:${item.bvid}`,
          groupId: this.groupId,
          vol: endVol - index,
          page: this.singleUpService ? this.singleUpService.page - 1 : void 0
        };
      });
      list2 = list2.filter((item) => !isSpaceUploadItemChargeOnly(item));
      if (this.filterText) {
        const {
          includes: includes2,
          excludes
        } = parseAdvancedFilter(this.filterText);
        list2 = list2.filter((item) => {
          return includes2.every((include) => item.title.includes(include)) && excludes.every((exclude) => !item.title.includes(exclude));
        });
      }
      {
        const mids2 = uniq(list2.filter((item) => item.author.trim() !== "账号已注销")).map((item) => item.mid).filter(Boolean);
        await Promise.all([this.fetchAvatars(mids2), this.fetchFollowState(mids2)]);
      }
      return list2;
    }
  }
  class MergeTimelineService {
    constructor(mids2, order, searchText) {
      this.mids = mids2;
      this.order = order;
      this.searchText = searchText;
      invariant$1(this.mids.length === 1 || this.mids.length > 1 && this.order !== SpaceUploadOrder.Fav, "SpaceUploadItem.Fav not supported when merging");
      this.singleUpServices = mids2.map((mid) => new SingleUpService(mid, this.order, this.searchText));
    }
    singleUpServices;
    get hasMore() {
      return this.singleUpServices.some((service) => service.hasMore);
    }
    get count() {
      return this.singleUpServices.reduce((total, service) => total + service.count, 0);
    }
    async refillQueues(abortSignal) {
      await pmap(this.singleUpServices, (s2) => s2.refillQueue(1, abortSignal), 5);
    }
    async loadMore(abortSignal) {
      if (!this.hasMore) return;
      if (this.mids.length === 1) {
        return this.singleUpServices[0].loadMore(abortSignal);
      }
      const pickedItems = [];
      const expectSize = 10;
      while (this.hasMore && pickedItems.length < expectSize) {
        await this.refillQueues(abortSignal);
        const restServices = this.singleUpServices.filter((s2) => s2.bufferQueue.length > 0);
        const pickedService = orderBy(restServices.map((service) => {
          const item = service.bufferQueue[0];
          const valueForSort = {
            [SpaceUploadOrder.Latest]: item.created,
            [SpaceUploadOrder.View]: item.play,
            [SpaceUploadOrder.Fav]: item.play
}[this.order];
          return {
            service,
            item,
            valueForSort
          };
        }), ["valueForSort"], ["desc"]).map((x) => x.service)[0];
        if (!pickedService) break;
        const head = pickedService.bufferQueue[0];
        pickedService.bufferQueue = pickedService.bufferQueue.slice(1);
        pickedItems.push(head);
      }
      return pickedItems;
    }
  }
  class SingleUpService {
    constructor(mid, order, searchText, initialPage) {
      this.mid = mid;
      this.order = order;
      this.searchText = searchText;
      this.initialPage = initialPage;
      this.page = this.initialPage ?? 1;
    }
    bufferQueue = [];
    hasMoreForApi = true;
    count = 0;
    endVol = 0;
    get hasMore() {
      return !!this.bufferQueue.length || this.hasMoreForApi;
    }
    async refillQueue(minimalQueueSize, abortSignal) {
      if (!this.hasMore) return;
      while (!abortSignal?.aborted && this.hasMoreForApi && this.bufferQueue.length < minimalQueueSize) {
        const items = await this.loadMore(abortSignal) || [];
        this.bufferQueue.push(...items);
      }
    }
    page;
    async loadMore(abortSignal) {
      const {
        items,
        hasMore,
        count,
        endVol
      } = await tryGetSpaceUpload({
        mid: this.mid,
        order: this.order,
        pagenum: this.page,
        keyword: this.searchText || ""
      });
      this.hasMoreForApi = hasMore;
      this.page++;
      this.count = count;
      this.endVol = endVol;
      return items;
    }
  }
  const toHttps = (url2) => (url2 || "").replace(/^http:\/\//, "https://");
  const DESC_SEPARATOR = "·";
  function lookinto(item, opts) {
    const api = item.api;
    const handler = opts[api];
    return handler(item);
  }
  function createCacheFor__normalizeCardData() {
    const weakMap = new WeakMap();
    const normalizeCardDataCache = weakMap;
    normalizeCardDataCache.clear ??= noop$4;
    normalizeCardDataCache.size = 0;
    return normalizeCardDataCache;
  }
  const normalizeCardData = memoize$1((item) => {
    const ret = lookinto(item, {
      [EApiType.AppRecommend]: apiAppAdapter,
      [EApiType.PcRecommend]: apiPcAdapter,
      [EApiType.DynamicFeed]: apiDynamicAdapter,
      [EApiType.Watchlater]: apiWatchlaterAdapter,
      [EApiType.Fav]: apiFavAdapter,
      [EApiType.PopularGeneral]: apiPopularGeneralAdapter,
      [EApiType.PopularWeekly]: apiPopularWeeklyAdapter,
      [EApiType.Rank]: apiRankAdapter,
      [EApiType.Live]: apiLiveAdapter,
      [EApiType.SpaceUpload]: apiSpaceUploadAdapter,
      [EApiType.Liked]: apiLikedAdapter
    });
    if (ret.authorFace) ret.authorFace = toHttps(ret.authorFace);
    if (ret.cover) ret.cover = toHttps(ret.cover);
    ret.bvid ||= void 0;
    ret.avid ||= void 0;
    return ret;
  }, {
    cache: createCacheFor__normalizeCardData(),
    getCacheKey: (item) => item
  });
  function apiAppAdapter(item) {
    return apiIpadAppAdapter(item);
  }
  function apiIpadAppAdapter(item) {
    const extractCountFor = (target) => {
      const {
        cover_left_text_1,
        cover_left_text_2,
        cover_left_text_3
      } = item;
      const arr = [cover_left_text_1, cover_left_text_2, cover_left_text_3].filter(Boolean);
      if (target === "play") {
        const text = arr.find((text2) => /观看|播放$/.test(text2));
        if (!text) return;
        const rest = text.replace(/观看|播放$/, "");
        return parseCount(rest);
      }
      if (target === "danmaku") {
        const text = arr.find((text2) => text2.endsWith("弹幕"));
        if (!text) return;
        const rest = text.replace(/弹幕$/, "");
        return parseCount(rest);
      }
      if (target === "bangumi:follow") {
        const text = arr.find((text2) => /追[剧番]$/.test(text2));
        if (!text) return;
        const rest = text.replace(/追[剧番]$/, "");
        return parseCount(rest);
      }
    };
    const avid = item.param;
    const bvid = item.bvid || av2bv(Number(item.param));
    const cid = item.player_args?.cid;
    const href = (() => {
      if (item.uri.startsWith("http://") || item.uri.startsWith("https://")) {
        return item.uri;
      }
      if (item.goto === "av") {
        return `/video/${bvid}/`;
      }
      if (item.goto === "bangumi") {
        appWarn(`bangumi uri should not starts with 'bilibili://': %s`, item.uri);
        return item.uri;
      }
      if (item.goto === "picture") {
        const id2 = /^bilibili:\/\/article\/(\d+)$/.exec(item.uri)?.[1];
        if (id2) return `/read/cv${id2}`;
        return item.uri;
      }
      return item.uri;
    })();
    const play = extractCountFor("play");
    const like = void 0;
    const coin = void 0;
    const danmaku = extractCountFor("danmaku");
    const favorite = void 0;
    const bangumiFollow = extractCountFor("bangumi:follow");
    const statItems = [{
      field: "play",
      value: play
    }, typeof danmaku === "number" ? {
      field: "danmaku",
      value: danmaku
    } : {
      field: "bangumi:follow",
      value: bangumiFollow
    }];
    const desc = item.desc || "";
    const [descAuthorName = void 0, descDate = void 0] = desc.split(DESC_SEPARATOR);
    return {
avid,
      bvid,
      cid,
      goto: item.goto,
      href,
      title: item.title,
      cover: item.cover,
      pubts: void 0,
      pubdateDisplay: descDate,
      duration: item.player_args?.duration || 0,
      durationStr: formatDuration(item.player_args?.duration),
      recommendReason: item.bottom_rcmd_reason || item.top_rcmd_reason,
play,
      like,
      coin,
      danmaku,
      favorite,
      bangumiFollow,
      statItems,
authorName: item.args.up_name || descAuthorName,
      authorFace: item.avatar.cover,
      authorMid: String(item.args.up_id || ""),
      appBadge: item.cover_badge,
      appBadgeDesc: item.desc
    };
  }
  function apiPcAdapter(item) {
    item.goto === PcRecGoto.AV;
    const _isLive = item.goto === PcRecGoto.Live;
    return {
avid: _isLive ? void 0 : String(item.id),
      bvid: _isLive ? void 0 : item.bvid,
      cid: _isLive ? void 0 : item.cid,
      goto: item.goto,
      href: item.goto === "av" ? `/video/${item.bvid}/` : item.uri,
      title: item.title,
      cover: item.pic,
      pubts: item.pubdate,
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason: _isLive ? item.room_info?.area.area_name : item.rcmd_reason?.content,
play: item.stat?.view,
      like: item.stat?.like,
      coin: void 0,
      danmaku: item.stat?.danmaku,
      favorite: void 0,
      statItems: _isLive ? defineStatItems([{
        field: "live:viewed-by",
        value: item.room_info?.watched_show.num
      }]) : defineStatItems([{
        field: "play",
        value: item.stat?.view
      }, {
        field: "danmaku",
        value: item.stat?.danmaku
      }]),
authorName: item.owner?.name,
      authorFace: item.owner?.face,
      authorMid: String(item.owner?.mid)
    };
  }
  function apiDynamicAdapter(item) {
    const ret = normalizeDynamicFeedItem(item);
    invariant$1(ret, "unexpected `normalizeDynamicFeedItem` empty result");
    return ret;
  }
  function apiWatchlaterAdapter(item) {
    const invalidReason = getVideoInvalidReason(item.state);
    const viewed = item.progress > 0;
    const title = `${viewed ? "【已观看】· " : ""}${item.title}`;
    const titleRender = invalidReason ? jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
      "视频已失效, 原因: ",
      invalidReason
    ] }), align: {
      offset: [0, -5]
    }, placement: "topLeft", children: jsxs("del", { children: [
      viewed ? "【已观看】· " : "",
      item.title,
      "`"
    ] }) }) : void 0;
    const {
      watchlaterUseNormalVideoUrl,
      watchlaterItemsOrder
    } = getSettingsSnapshot();
    const href = (() => {
      if (watchlaterUseNormalVideoUrl) return `https://www.bilibili.com/video/${item.bvid}/`;
      let autoListUrl = `https://www.bilibili.com/list/watchlater?bvid=${item.bvid}&oid=${item.aid}`;
      if (watchlaterItemsOrder === WatchlaterItemsOrder.AddTimeAsc) autoListUrl += "&desc=0";
      return autoListUrl;
    })();
    return {
avid: String(item.aid),
      bvid: item.bvid,
      cid: item.cid,
      goto: "av",
      href,
      title,
      titleRender,
      cover: item.pic,
      pubts: item.pubdate,
      pubdateDisplayForTitleAttr: `${formatTimeStamp(item.pubdate, true)} 发布, ${formatTimeStamp(item.add_at, true)} 添加稍后再看`,
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason: `${formatTimeStamp(item.add_at)} · 稍后再看`,
statItems: defineStatItems([
        {
          field: "play",
          value: item.stat.view
        },
        {
          field: "like",
          value: item.stat.like
        },
{
          field: "favorite",
          value: item.stat.favorite
        }
      ]),
      play: item.stat.view,
      like: item.stat.like,
      danmaku: item.stat.danmaku,
authorName: item.owner.name,
      authorFace: item.owner.face,
      authorMid: String(item.owner.mid)
    };
  }
  function apiFavAdapter(item) {
    const belongsToTitle = item.from === "fav-folder" ? item.folder.title : item.collection.title;
    const iconInTitleStyle = {
      display: "inline-block",
      verticalAlign: "middle",
      marginRight: 4,
      marginTop: -2
    };
    const fillWithColorPrimary = "[&_path]:fill-gate-primary";
    const iconInTitle = item.from === "fav-folder" ? isFavFolderPrivate(item.folder.attr) ? jsx$1(IconForPrivateFolder, { className: clsx("size-15px", fillWithColorPrimary), style: iconInTitleStyle }) : jsx$1(IconForPublicFolder, { className: clsx("size-15px", fillWithColorPrimary), style: iconInTitleStyle }) : jsx$1(IconForCollection, { className: clsx("size-15px", fillWithColorPrimary), style: iconInTitleStyle });
    return {
avid: String(item.id),
      bvid: item.bvid,
goto: "av",
      href: `/video/${item.bvid}/`,
      title: `【${belongsToTitle}】· ${item.title}`,
      titleRender: jsxs(Fragment, { children: [
        "【",
        iconInTitle,
        belongsToTitle,
        "】· ",
        item.title
      ] }),
      cover: item.cover,
      pubts: item.pubtime,
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason: item.from === "fav-folder" ? `${formatTimeStamp(item.fav_time)} · 收藏` : void 0,
play: item.cnt_info.play,
      danmaku: item.cnt_info.danmaku,
      favorite: item.cnt_info.collect,
      statItems: defineStatItems([{
        field: "play",
        value: item.cnt_info.play
      }, {
        field: "danmaku",
        value: item.cnt_info.danmaku
      }, {
        field: "favorite",
        value: item.cnt_info.collect
      }]),
authorName: item.upper.name,
      authorFace: item.upper.face,
      authorMid: String(item.upper.mid)
    };
  }
  function apiPopularGeneralAdapter(item) {
    return {
avid: String(item.aid),
      bvid: item.bvid,
      cid: item.cid,
      goto: "av",
      href: `/video/${item.bvid}/`,
      title: item.title,
      cover: item.pic,
      pubts: item.pubdate,
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason: item.rcmd_reason?.content,
play: item.stat.view,
      like: item.stat.like,
      coin: void 0,
      danmaku: item.stat.danmaku,
      favorite: void 0,
      statItems: defineStatItems([
        {
          field: "play",
          value: item.stat.view
        },
        {
          field: "like",
          value: item.stat.like
        }
]),
authorName: item.owner.name,
      authorFace: item.owner.face,
      authorMid: String(item.owner.mid)
    };
  }
  function apiPopularWeeklyAdapter(item) {
    return {
avid: String(item.aid),
      bvid: item.bvid,
      cid: item.cid,
      goto: "av",
      href: `/video/${item.bvid}/`,
      title: item.title,
      cover: item.pic,
      pubts: item.pubdate,
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason: item.rcmd_reason,
play: item.stat.view,
      like: item.stat.like,
      danmaku: item.stat.danmaku,
      statItems: defineStatItems([
        {
          field: "play",
          value: item.stat.view
        },
        {
          field: "like",
          value: item.stat.like
        }
]),
authorName: item.owner.name,
      authorFace: item.owner.face,
      authorMid: String(item.owner.mid)
    };
  }
  function apiRankAdapter(item) {
    if (isPgcWebRankItem(item) || isPgcSeasonRankItem(item)) {
      const cover = item.new_ep.cover;
      const rankingDesc = item.new_ep.index_show;
      return {
avid: "",
        bvid: "",
        goto: "bangumi",
        href: item.url,
        title: item.title,
        cover,
        pubts: void 0,
        pubdateDisplay: void 0,
        duration: 0,
        durationStr: "",
play: item.stat.view,
        like: item.stat.follow,
        danmaku: item.stat.danmaku,
        statItems: defineStatItems([
          {
            field: "play",
            value: item.stat.view
          },
          {
            field: "bangumi:follow",
            value: item.stat.follow
          }
]),
        rankingDesc
      };
    }
    let recommendReason = (item.dynamic || item.desc)?.trim();
    if (recommendReason === "-") recommendReason = void 0;
    if (recommendReason && item.title.includes(recommendReason)) recommendReason = void 0;
    return {
avid: String(item.aid),
      bvid: item.bvid,
      cid: item.cid,
      goto: "av",
      href: `/video/${item.bvid}/`,
      title: item.title,
      cover: item.pic,
      pubts: item.pubdate,
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason,
play: item.stat.view,
      like: item.stat.like,
      danmaku: item.stat.danmaku,
      statItems: defineStatItems([
        {
          field: "play",
          value: item.stat.view
        },
        {
          field: "like",
          value: item.stat.like
        }
]),
authorName: item.owner.name,
      authorFace: item.owner.face,
      authorMid: String(item.owner.mid)
    };
  }
  function apiLiveAdapter(item) {
    const area = `${item.area_name_v2}`;
    const liveExtraDesc = item.live_status === ELiveStatus.Streaming ? "" : `${DESC_SEPARATOR}${formatLiveTime(item.record_live_time)} 直播过`;
    const coverFallback = "https://s1.hdslb.com/bfs/static/blive/blfe-link-center/static/img/average-backimg.e65973e.png";
    function formatLiveTime(ts) {
      const today = dayjs().format("YYYYMMDD");
      const yesterday = dayjs().subtract(1, "day").format("YYYYMMDD");
      const d2 = dayjs.unix(ts);
      if (d2.format("YYYYMMDD") === today) {
        return d2.format("HH:mm");
      }
      if (d2.format("YYYYMMDD") === yesterday) {
        return `昨天 ${d2.format("HH:mm")}`;
      }
      return d2.format("MM-DD HH:mm");
    }
    return {
goto: "live",
      href: `https://live.bilibili.com/${item.roomid}`,
      title: item.title,
      cover: item.room_cover || coverFallback,
      recommendReason: area,
      liveExtraDesc,
statItems: defineStatItems([{
        field: "live:viewed-by",
        value: item.text_small
      }]),
authorName: item.uname,
      authorFace: item.face,
      authorMid: String(item.uid)
    };
  }
  function apiSpaceUploadAdapter(item) {
    const duration2 = parseDuration(item.length);
    const durationStr = formatDuration(duration2);
    let recommendReason = item.description?.trim();
    if (recommendReason === "-") recommendReason = void 0;
    if (recommendReason && item.title.includes(recommendReason)) recommendReason = void 0;
    return {
avid: item.aid.toString(),
      bvid: item.bvid,
      cid: void 0,
      goto: "av",
      href: `/video/${item.bvid}/`,
      title: item.title,
      cover: item.pic,
      pubts: item.created,
      duration: duration2,
      durationStr,
      recommendReason,
play: item.play,
      like: void 0,
      coin: void 0,
      danmaku: item.video_review,
      favorite: void 0,
      statItems: defineStatItems([{
        field: "play",
        value: item.play
      }, {
        field: "danmaku",
        value: item.video_review
      }]),
authorName: item.author,
      authorFace: spaceUploadAvatarCache.get(item.mid),
      authorMid: item.mid.toString(),
      followed: spaceUploadFollowedMidSet.has(item.mid)
    };
  }
  function apiLikedAdapter(item) {
    const {
      videoDetail
    } = item;
    const avid = item.param;
    const bvid = av2bv(Number(avid));
    return {
avid,
      bvid,
      cid: void 0,
      goto: "av",
      href: `/video/${bvid}/`,
      title: item.title,
      cover: item.cover,
      pubts: videoDetail?.pubdate ?? item.ctime,
      duration: item.duration,
      durationStr: formatDuration(item.duration),
      recommendReason: void 0,
play: item.play,
      danmaku: item.danmaku,
      like: void 0,
      coin: void 0,
      favorite: void 0,
      statItems: defineStatItems([{
        field: "play",
        value: item.play
      }, {
        field: "danmaku",
        value: item.danmaku
      }]),
authorName: item.author,
      authorFace: videoDetail?.owner.face,
      authorMid: videoDetail?.owner.mid?.toString()
    };
  }
  const REG_MID_WITH_REMARK = /^(?<mid>\d+)\((?<remark>[\S ]+)\)$/;
  const REG_MID = /^\d+$/;
  function parseUpRepresent(author) {
    if (REG_MID_WITH_REMARK.test(author)) {
      const groups = REG_MID_WITH_REMARK.exec(author)?.groups;
      const mid = groups?.mid;
      const remark = groups?.remark;
      return {
        mid,
        remark
      };
    }
    if (REG_MID.test(author)) {
      return {
        mid: author,
        remark: void 0
      };
    }
    return {};
  }
  function parseFilterByAuthor(keywords) {
    const blockUpMids = new Set();
    const blockUpNames = new Set();
    keywords.forEach((keyword) => {
      const {
        mid
      } = parseUpRepresent(keyword);
      mid ? blockUpMids.add(mid) : blockUpNames.add(keyword);
    });
    return {
      blockUpMids,
      blockUpNames
    };
  }
  function parseFilterByTitle(keywords) {
    const titleRegexList = [];
    const titleKeywordList = [];
    keywords.forEach((keyword) => {
      if (keyword.startsWith("/") && keyword.endsWith("/")) {
        const regex = new RegExp(keyword.slice(1, -1), "i");
        titleRegexList.push(regex);
      } else {
        titleKeywordList.push(keyword);
      }
    });
    function test2(title) {
      return titleKeywordList.some((keyword) => title.includes(keyword)) || titleRegexList.some((regex) => regex.test(title));
    }
    return {
      titleKeywordList,
      titleRegexList,
      test: test2
    };
  }
  const debug$a = baseDebug.extend("modules:filter");
  function getFollowedStatus$1(recommendReason) {
    return !!recommendReason && ["已关注", "新关注"].includes(recommendReason);
  }
  function isApiRecLike(api) {
    return [EApiType.AppRecommend, EApiType.PcRecommend, EApiType.Rank, EApiType.PopularGeneral, EApiType.PopularWeekly].includes(api);
  }
  function filterRecItems(items, tab2) {
    if (!settings.filter.enabled && !blacklistMids.size) {
      return items;
    }
    const filter2 = getSettingsSnapshot().filter;
    const {
      minDuration,
      minPlayCount,
      minDanmakuCount,
      byAuthor,
      byTitle,
      dfByTitle,
      dfHideOpusMids
    } = filter2;
    const {
      blockUpMids,
      blockUpNames
    } = parseFilterByAuthor(byAuthor.keywords);
    const {
      test: filterByTitleTest
    } = parseFilterByTitle(byTitle.keywords);
    const {
      test: dfFilterByTitleTest
    } = parseFilterByTitle(dfByTitle.keywords);
    const {
      blockUpMids: dfBlockOpusMids
    } = parseFilterByAuthor(dfHideOpusMids.keywords);
    return items.filter((item) => {
      if (item.api === EApiType.Separator) return true;
      const {
        play,
        duration: duration2,
        danmaku,
        recommendReason,
        goto,
        authorName,
        authorMid,
        title,
        bvid,
        href
      } = normalizeCardData(item);
      const followed = getFollowedStatus$1(recommendReason);
      if (tab2 === "keep-follow-only" && !followed) return false;
      function check_blacklist_filterByUp_filterByTitle() {
        if (authorMid && blacklistMids.size && blacklistMids.has(authorMid)) {
          debug$a("filter out by blacklist-rule: %s %o", authorMid, {
            bvid,
            title
          });
          return false;
        }
        if (filter2.enabled && byAuthor.enabled && (blockUpMids.size || blockUpNames.size) && (authorName || authorMid) && (authorName && blockUpNames.has(authorName) || authorMid && blockUpMids.has(authorMid))) {
          debug$a("filter out by author-rule: %o", {
            authorName,
            authorMid,
            rules: byAuthor.keywords,
            blockUpMids,
            blockUpNames,
            bvid,
            title
          });
          return false;
        }
        let possibleTitles = [title];
        if (item.api === EApiType.Rank && isNormalRankItem(item) && item.desc) {
          possibleTitles.push(item.desc);
        }
        possibleTitles = possibleTitles.filter(Boolean);
        if (filter2.enabled && byTitle.enabled && byTitle.keywords.length && possibleTitles.length && possibleTitles.some(filterByTitleTest)) {
          debug$a("filter out by title-rule: %o", {
            possibleTitles,
            rules: byTitle.keywords,
            bvid
          });
          return false;
        }
      }
      if (isApiRecLike(item.api) && check_blacklist_filterByUp_filterByTitle() === false) {
        return false;
      }
      if ((item.api === EApiType.AppRecommend || item.api === EApiType.PcRecommend) && filter2.enabled) {
        const isVideo = goto === "av";
        const isPicture = goto === "picture";
        const isBangumi = goto === "bangumi";
        if (isVideo) return filterVideo();
        if (isPicture) return filterPicture();
        if (isBangumi) return filterBangumi();
      }
      function filterVideo() {
        if (followed && filter2.exemptForFollowed.video) return true;
        if (recommendReason === "关注了你") {
          debug$a("filter out by recommendReason-rule: %s %o", recommendReason, {
            bvid,
            title
          });
          return false;
        }
        if (minDuration.enabled && minDuration.value && duration2 && duration2 < minDuration.value) {
          debug$a("filter out by min-duration-rule: %s < %s %o", duration2, minDuration.value, {
            bvid,
            title
          });
          return false;
        }
        if (minPlayCount.enabled && minPlayCount.value && typeof play === "number" && play < minPlayCount.value) {
          debug$a("filter out by min-play-count-rule: %s < %s, %o", play, minPlayCount.value, {
            bvid,
            title
          });
          return false;
        }
        if (minDanmakuCount.enabled && minDanmakuCount.value && typeof danmaku === "number" && danmaku < minDanmakuCount.value) {
          debug$a("filter out by min-danmaku-count-rule: %s < %s, %o", danmaku, minDanmakuCount.value, {
            bvid,
            title
          });
          return false;
        }
        return true;
      }
      function filterPicture() {
        if (filter2.hideGotoTypePicture) {
          if (followed && filter2.exemptForFollowed.picture) {
            return true;
          }
          debug$a("filter out by goto-type-picture-rule: %s %o", goto, {
            bvid,
            title
          });
          return false;
        } else {
          return true;
        }
      }
      function filterBangumi() {
        if (filter2.hideGotoTypeBangumi) {
          debug$a("filter out by goto-type-bangumi-rule: %s %o", goto, {
            title,
            href
          });
          return false;
        }
        return true;
      }
      if (isDynamicFeed(item) && filter2.enabled) {
        const {
          major
        } = item.modules.module_dynamic;
        const isMajorOpus = major?.type === DynamicFeedEnums.MajorType.Opus;
        if (settings.filter.dfByTitle.enabled && settings.filter.dfByTitle.keywords.length) {
          let possibleTitles = [title];
          if (isMajorOpus) possibleTitles.push(major.opus.summary?.text || "");
          possibleTitles = uniq(possibleTitles.filter(Boolean));
          if (possibleTitles.some(dfFilterByTitleTest)) {
            debug$a("filter out by df-title-rule: %o", {
              possibleTitles,
              rules: dfByTitle.keywords,
              uniqId: item.uniqId,
              item
            });
            return false;
          }
        }
        if (isMajorOpus && dfHideOpusMids.enabled && dfHideOpusMids.keywords.length && authorMid && dfBlockOpusMids.has(authorMid)) {
          debug$a("filter out by df-hide-opus-mids-rule: %o", {
            dfHideOpusMids,
            authorMid,
            title,
            uniqId: item.uniqId
          });
          return false;
        }
      }
      return true;
    });
  }
  async function getLiveList(page) {
    const res = await request.get("https://api.live.bilibili.com/xlive/web-ucenter/user/following", {
      params: {
        page,
        page_size: LiveRecService.PAGE_SIZE,
        ignoreRecord: 1,
        hit_ab: true
      }
    });
    const json = res.data;
    return json;
  }
  class LiveRecService extends BaseTabService {
    constructor(streamingOnly = false) {
      super(LiveRecService.PAGE_SIZE);
      this.streamingOnly = streamingOnly;
    }
    static PAGE_SIZE = 20;
    tabbarView = void 0;
    sidebarView = void 0;
    hasMoreExceptQueue = true;
    separatorAdded = false;
    liveCount = -1;
    page = 1;
    totalPage = Infinity;
    async fetchMore(abortSignal) {
      if (this.page > this.totalPage) {
        this.hasMoreExceptQueue = false;
        return;
      }
      const json = await getLiveList(this.page);
      if (!isWebApiSuccess(json)) {
        toast(json.message || REQUEST_FAIL_MSG);
        this.hasMoreExceptQueue = false;
      }
      this.page++;
      const {
        count,
        live_count,
        totalPage
      } = json.data;
      this.totalPage = totalPage;
      this.liveCount = live_count;
      const items = json.data.list.map((item) => {
        const _item = {
          ...item,
          api: EApiType.Live,
          uniqId: `${EApiType.Live}:${item.roomid}`
        };
        return _item;
      });
      const last = items.at(-1);
      const gateTime = dayjs().subtract(2, "weeks").unix();
      if (last) {
        const lastStatus = last.live_status;
        const lastLiveTime = last.record_live_time;
        if (lastStatus !== ELiveStatus.Streaming && lastLiveTime && lastLiveTime < gateTime) {
          this.hasMoreExceptQueue = false;
        }
      }
      let ret = items;
      if (!this.streamingOnly && !this.separatorAdded && items.some((x) => x.live_status !== ELiveStatus.Streaming)) {
        this.separatorAdded = true;
        const index = items.findIndex((x) => x.live_status !== ELiveStatus.Streaming);
        ret.splice(index, 0, {
          api: EApiType.Separator,
          uniqId: `${EApiType.Live}:separator:recent`,
          content: "最近直播过"
        });
      }
      if (this.streamingOnly && items.some((x) => x.live_status !== ELiveStatus.Streaming)) {
        this.hasMoreExceptQueue = false;
        ret = items.filter((x) => x.live_status === ELiveStatus.Streaming);
      }
      return ret;
    }
  }
  const debug$9 = baseDebug.extend("modules:rec-services:dynamic-feed:api");
  async function fetchDynamicFeeds({
    videoOnly,
    offset: offset2,
    page,
    upMid,
    abortSignal
  }) {
    const params = {
      "timezone_offset": "-480",
      "type": videoOnly ? "video" : "all",
      "platform": "web",
      "features": "itemOpusStyle",
      "web_location": "0.0",
      "x-bili-device-req-json": JSON.stringify({
        platform: "web",
        device: "pc"
      }),
      "x-bili-web-req-json": JSON.stringify({
        spm_id: "0.0"
      }),
      "page": page
    };
    if (offset2) {
      params.offset = offset2;
    }
    const apiPath = "/x/polymer/web-dynamic/v1/feed/all";
    if (upMid) {
      params.host_mid = upMid;
    }
    const res = await request.get(apiPath, {
      signal: abortSignal,
      params
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      const msg = json.message || REQUEST_FAIL_MSG;
      toast(msg);
      throw new Error(msg, {
        cause: json
      });
    }
    const data2 = json.data;
    if (data2?.items?.length) {
      data2.items = data2.items.filter((item) => {
        const valid = !!normalizeDynamicFeedItem(item);
        if (!valid) {
          debug$9("dynamic-feed filter out: %o", {
            type: item.type,
            majorType: item.modules.module_dynamic.major?.type,
            additionalType: item.modules.module_dynamic.additional?.type,
            item
          });
        }
        return valid;
      });
    }
    return data2;
  }
  const cache = getIdbCache("dynamic-feed-items");
  const infoCache = getIdbCache("dynamic-feed-items-info");
  async function hasLocalDynamicFeedCache(upMid) {
    const existing = await infoCache.get(upMid);
    return !!existing?.count;
  }
  function createUpdateFilterCacheNotifyFns(upMid, upName) {
    const notiKey = (mid) => `update-filter-cache:${mid}`;
    const _onProgress = (page, total) => {
      antNotification.info({
        icon: jsx$1(ForwardRef$1j, { className: "size-16px" }),
        key: notiKey(upMid),
        title: `过滤缓存更新中...`,
        description: `「${upName}」更新中: Page(${page}) Total(${total})`,
        duration: false
});
    };
    const onProgress = throttle$2(_onProgress, 200);
    const onSuccess = () => {
      onProgress.flush();
      antNotification.success({
        key: notiKey(upMid),
        title: `缓存更新成功`,
        description: `「${upName}」的过滤缓存更新成功`,
        duration: false
});
    };
    return {
      notifyOnProgress: onProgress,
      notifyOnSuccess: onSuccess
    };
  }
  async function updateLocalDynamicFeedCache(upMid, onProgress) {
    if (await hasLocalDynamicFeedCache(upMid)) {
      await performIncrementalUpdate(upMid);
    } else {
      await performFullUpdate(upMid, void 0, onProgress);
    }
  }
  async function performIncrementalUpdateIfNeed(upMid, force = false) {
    const info = await infoCache.get(upMid);
    if (!force && info && info.count && info.updatedAt && Date.now() - info.updatedAt < 60 * 1e3) {
      return;
    }
    return performIncrementalUpdate(upMid);
  }
  async function performIncrementalUpdate(upMid) {
    if (!await hasLocalDynamicFeedCache(upMid)) return;
    const existing = await cache.get(upMid) || [];
    const existingIds = new Set(existing.map((x) => x.id_str));
    let page = 1;
    let offset2 = "";
    let hasMore = true;
    let newItems = [];
    while (hasMore) {
      const data2 = await fetchDynamicFeeds({
        upMid,
        page,
        offset: offset2,
        videoOnly: true
      });
      const items = data2.items;
      newItems = [...newItems, ...items];
      offset2 = data2.offset;
      hasMore = data2.has_more;
      page++;
      if (hasMore && existingIds.size) {
        const allIncluded = items.every((item) => existingIds.has(item.id_str));
        if (allIncluded) {
          hasMore = false;
        }
      }
    }
    const allItems = uniqBy([...newItems, ...existing], (x) => x.id_str);
    await cache.set(upMid, allItems);
    await infoCache.set(upMid, {
      count: allItems.length,
      updatedAt: Date.now()
    });
  }
  const fullUpdateInProgressCache = getIdbCache("dynamic-feed-items-in-progress");
  async function performFullUpdate(upMid, skipCache = false, onProgress) {
    const inProgressCached = skipCache ? void 0 : await fullUpdateInProgressCache.get(upMid);
    let page = inProgressCached?.page ?? 1;
    let offset2 = inProgressCached?.offset ?? "";
    let allItems = inProgressCached?.items ?? [];
    let hasMore = true;
    while (hasMore) {
      const data2 = await fetchDynamicFeeds({
        upMid,
        page,
        offset: offset2,
        videoOnly: true
      });
      const items = data2.items;
      allItems = [...allItems, ...items];
      offset2 = data2.offset;
      hasMore = data2.has_more;
      page++;
      await fullUpdateInProgressCache.set(upMid, {
        page,
        offset: offset2,
        items: allItems
      });
      onProgress?.(page, allItems.length);
    }
    const _allItems = uniqBy(allItems, (x) => x.id_str);
    await cache.set(upMid, _allItems);
    await infoCache.set(upMid, {
      count: _allItems.length,
      updatedAt: Date.now()
    });
    await fullUpdateInProgressCache.delete(upMid);
  }
  const fetchDynamicFeedsWithCache = wrapWithIdbCache({
    fn: fetchDynamicFeeds,
    generateKey: ({
      upMid,
      videoOnly
    }) => `upMid=${upMid}&videoOnly=${videoOnly}`,
    tableName: "dynamic-feed-newest-items",
ttl: 5 * 60 * 1e3
});
  class FollowGroupUpService {
    constructor(upMid, videoOnly, enableHeadCache = false) {
      this.upMid = upMid;
      this.videoOnly = videoOnly;
      this.enableHeadCache = enableHeadCache;
    }
    bufferQueue = [];
    hasMoreForApi = true;
    offset = "";
    page = 1;
get hasMore() {
      return !!this.bufferQueue.length || this.hasMoreForApi;
    }
    async loadMore() {
      const enableCache = this.page === 1 && !this.offset && this.enableHeadCache;
      const fn = enableCache ? fetchDynamicFeedsWithCache : fetchDynamicFeeds;
      const data2 = await fn({
        videoOnly: this.videoOnly,
        upMid: this.upMid,
        page: this.page,
        offset: this.offset
      });
      this.offset = data2.offset;
      this.hasMoreForApi = data2.has_more;
      this.page++;
      if (isEqual$2(data2, {
        has_more: true,
        items: [],
        offset: "",
        update_baseline: "",
        update_num: 0
      })) {
        this.hasMoreForApi = false;
      }
      return data2.items;
    }
    async fillQueue(minimalQueueSize, abortSignal) {
      while (!abortSignal?.aborted && this.hasMoreForApi && this.bufferQueue.length < minimalQueueSize) {
        const items = await this.loadMore();
        this.bufferQueue.push(...items);
      }
    }
  }
  class FollowGroupMergeTimelineService {
    constructor(upMids, videoOnly) {
      this.upMids = upMids;
      this.videoOnly = videoOnly;
      const enableHeadCache = upMids.length > FollowGroupMergeTimelineService.ENABLE_HEAD_CACHE_UPMID_COUNT_THRESHOLD;
      this.upServices = upMids.map((upMid) => new FollowGroupUpService(upMid, videoOnly, enableHeadCache));
    }
static ENABLE_MERGE_TIMELINE_UPMID_COUNT_THRESHOLD = 20;
static ENABLE_HEAD_CACHE_UPMID_COUNT_THRESHOLD = 10;
    upServices = [];
    get hasMore() {
      return this.upServices.some((s2) => s2.hasMore);
    }
    async loadMore(abortSignal) {
      if (!this.hasMore) return [];
      const refillQueues = async () => {
        const minimalQueueSize = 1;
        await pmap(this.upServices, (s2) => s2.fillQueue(minimalQueueSize, abortSignal), 5);
      };
      const pickedItems = [];
      const expectSize = 10;
      while (this.hasMore && pickedItems.length < expectSize) {
        await refillQueues();
        const restServices = this.upServices.filter((s2) => s2.hasMore);
        const pickedService = orderBy(restServices.map((service) => {
          const item = service.bufferQueue[0];
          const id2 = BigInt(item.id_str);
          return {
            service,
            item,
            id: id2
          };
        }), ["id"], ["desc"]).map((x) => x.service)[0];
        if (!pickedService) break;
        const head = pickedService.bufferQueue[0];
        pickedService.bufferQueue = pickedService.bufferQueue.slice(1);
        pickedItems.push(head);
      }
      return pickedItems;
    }
  }
  function useEmitterOn(emitter2, type4, handler) {
    const fn = useMemoizedFn(handler);
    reactExports.useEffect(() => {
      emitter2.on(type4, fn);
      return () => {
        emitter2.off(type4, fn);
      };
    }, [emitter2, type4, fn]);
  }
  function supportAvif() {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(true);
      img.onerror = (err) => resolve(false);
      img.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";
    });
  }
  const shouldUseAvif = !isSafari && await( supportAvif());
  function getAvatarSrc(avatar) {
    const suffix = shouldUseAvif ? ".avif" : ".webp";
    return `${avatar}@96w_96h_1c_1s_!web-avatar${suffix}`;
  }
  function preloadImg(src) {
    return new Promise((resolve) => {
      const img = new Image();
      img.src = src;
      img.onload = () => resolve(true);
      img.onerror = () => resolve(false);
    });
  }
  function usePopoverRelated({
    externalFilterInput,
    onRefresh,
    getPopupContainer
  }) {
    const {
      upMid,
      dynamicFeedVideoType,
      filterMinDuration,
      filterText,
      hideChargeOnlyVideos
    } = useSnapshot(dfStore);
    const filterInput = jsx$1(
      Input.Search,
      {
        style: {
          width: externalFilterInput ? "250px" : void 0
        },
        placeholder: "按标题关键字过滤",
        type: "search",
        autoCorrect: "off",
        autoCapitalize: "off",
        name: `filterText_${upMid}`,
        variant: "outlined",
        defaultValue: dfStore.filterText,
        autoComplete: "off",
        allowClear: true,
        onChange: (e) => {
          tryInstantFilterWithCache({
            filterText: e.target.value,
            upMid,
            onRefresh
          });
        },
        onSearch: async (val) => {
          dfStore.filterText = val || void 0;
          await delay$1(100);
          onRefresh();
        }
      }
    );
    const popoverContent = jsx$1(PopoverContent, { externalFilterInput, filterInput, refresh: onRefresh });
    const [popoverOpen, setPopoverOpen] = reactExports.useState(
      false
);
    const onPopoverOpenChange = setPopoverOpen;
    const showPopoverBadge = reactExports.useMemo(() => {
      return !!(dynamicFeedVideoType !== DynamicFeedVideoType.All || hideChargeOnlyVideos || filterText || filterMinDuration !== DynamicFeedVideoMinDuration.All);
    }, [dynamicFeedVideoType, hideChargeOnlyVideos, filterText, filterMinDuration]);
    const popoverTrigger = jsx$1(Popover, { open: popoverOpen, onOpenChange: onPopoverOpenChange, arrow: false, placement: "bottomLeft", getPopupContainer, content: popoverContent, styles: {
      container: {
        border: `1px solid ${usePopoverBorderColor()}`
      }
    }, children: jsx$1(Badge, { dot: showPopoverBadge, color: appPrimaryColorValue, offset: [-5, 5], children: jsx$1(Button$1, { className: "icon-only-round-button", css: popoverOpen && buttonOpenCss, children: jsx$1(IconForPopoverTrigger, { className: "ml-1px" }) }) }) });
    return {
      filterInput,
      popoverContent,
      popoverTrigger
    };
  }
  const classes = {
    wrapper: "max-w-350px",
    section: "mt-10px min-w-300px first:mt-0px",
    sectionTilte: "flex items-center pb-2px pl-2px text-20px",
    sectionContent: "flex flex-col items-start gap-x-10px gap-y-6px"
  };
  function PopoverContent({
    externalFilterInput,
    filterInput,
    refresh
  }) {
    const {
      viewingSomeUp,
      selectedGroup,
      viewingSomeGroup,
      selectedKey,
      dynamicFeedVideoType,
      filterMinDuration,
      hideChargeOnlyVideos,
      addSeparators,
      filterText
    } = useSnapshot(dfStore);
    let linkToReflectFilterTextEl;
    {
      const show = SHOW_DYNAMIC_FEED_ONLY && !!filterText;
      const disabled = filterText === QUERY_DYNAMIC_FILTER_TEXT;
      const {
        href
      } = reactExports.useMemo(() => {
        const u2 = new URL(location.href);
        if (u2.searchParams.has(DynamicFeedQueryKey.FilterTextFull)) {
          u2.searchParams.set(DynamicFeedQueryKey.FilterTextFull, filterText || "");
        } else if (u2.searchParams.has(DynamicFeedQueryKey.FilterTextShort)) {
          u2.searchParams.set(DynamicFeedQueryKey.FilterTextShort, filterText || "");
        } else {
          u2.searchParams.set(DynamicFeedQueryKey.FilterTextFull, filterText || "");
        }
        return {
          href: u2.href,
          path: `${u2.pathname}?${u2.search}`
        };
      }, [filterText]);
      linkToReflectFilterTextEl = show && jsx$1(AntdTooltip, { title: href, children: jsxs(Button$1, { disabled, href, children: [
        "转到过滤词为「",
        filterText || "空",
        "」的链接"
      ] }) });
    }
    return jsxs("div", { className: classes.wrapper, children: [
jsxs("div", { className: classes.section, children: [
jsxs("div", { className: classes.sectionTilte, children: [
          "视频类型",
jsxs(HelpInfo, { children: [
            "「",
            DynamicFeedBadgeText.ChargeOnly,
            "」在此程序中归类为「投稿视频」",
jsx$1("br", {}),
            "「动态视频」时长通常较短"
          ] })
        ] }),
jsx$1("div", { children: jsx$1(Radio.Group, { buttonStyle: "solid", value: dynamicFeedVideoType, onChange: async (v) => {
          dfStore.dynamicFeedVideoType = v.target.value;
          await delay$1(100);
          refresh?.();
        }, children: Object.values(DynamicFeedVideoType).map((v) => {
          return jsx$1(Radio.Button, { value: v, children: DynamicFeedVideoTypeLabel[v] }, v);
        }) }) })
      ] }),
      dynamicFeedVideoType !== DynamicFeedVideoType.DynamicOnly && jsxs("div", { className: classes.section, children: [
jsx$1("div", { className: classes.sectionTilte, children: "充电专属" }),
jsx$1("div", { className: classes.sectionContent, children: jsx$1(Checkbox, { className: "ml-5px", checked: hideChargeOnlyVideos, onChange: async (e) => {
          const val = e.target.checked;
          const set2 = dfStore.hideChargeOnlyVideosForKeysSet;
          if (val) {
            set2.add(selectedKey);
          } else {
            set2.delete(selectedKey);
          }
          await delay$1(100);
          refresh?.();
        }, children: jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
          "隐藏「",
          DynamicFeedBadgeText.ChargeOnly,
          "」视频 ",
jsx$1("br", {}),
          "仅对当前 UP 或 分组生效"
        ] }), children: jsxs("span", { style: {
          userSelect: "none"
        }, children: [
          "隐藏「",
          DynamicFeedBadgeText.ChargeOnly,
          "」"
        ] }) }) }) })
      ] }),
jsxs("div", { className: classes.section, children: [
jsx$1("div", { className: classes.sectionTilte, children: "最短时长" }),
jsx$1("div", { children: jsx$1(
          Radio.Group,
          {
            className: "overflow-hidden [&_.ant-radio-button-wrapper]:px-10px",
            buttonStyle: "solid",
            value: filterMinDuration,
            onChange: async (v) => {
              dfStore.filterMinDuration = v.target.value;
              await delay$1(100);
              refresh?.();
            },
            children: Object.values(DynamicFeedVideoMinDuration).map((k) => {
              const {
                label
              } = DynamicFeedVideoMinDurationConfig[k];
              return jsx$1(Radio.Button, { value: k, children: label }, k);
            })
          }
        ) })
      ] }),
      (!externalFilterInput || linkToReflectFilterTextEl) && jsxs("div", { className: classes.section, children: [
jsx$1("div", { className: classes.sectionTilte, children: "过滤" }),
jsxs("div", { className: classes.sectionContent, children: [
          !externalFilterInput && filterInput,
          linkToReflectFilterTextEl
        ] })
      ] }),
jsx$1(FilterCacheRelated, {}),
jsxs("div", { className: classes.section, children: [
jsxs("div", { className: classes.sectionTilte, children: [
          viewingSomeGroup ? "分组" : viewingSomeUp ? "UP" : "全部",
jsxs(HelpInfo, { children: [
            "当前",
            viewingSomeGroup ? "分组" : viewingSomeUp ? "UP" : "范围",
            "的一些操作~"
          ] }),
          viewingSomeGroup && selectedGroup && jsxs("span", { className: "ml-15px inline-flex items-center text-size-14px", children: [
            "(",
jsxs("a", { href: formatFollowGroupUrl(selectedGroup?.tagid || ""), target: "_blank", className: `mx-4px inline-flex items-center text-size-16px ${APP_CLS_USE_ANT_LINK_COLOR}`, children: [
jsx$1(IconForOpenExternalLink, { className: "mr-2px size-18px" }),
              selectedGroup?.name
            ] }),
            ")"
          ] })
        ] }),
jsxs("div", { className: classes.sectionContent, children: [
jsx$1(Checkbox, { checked: addSeparators, onChange: async (v) => {
            dfStore.addSeparatorsMap.set("global", v.target.checked);
            await delay$1(100);
            refresh?.();
          }, children: jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
            "添加今日/更早分割线 ",
jsx$1("br", {}),
            "当前实现为全局共享此设置"
          ] }), children: "添加分割线" }) }),
          viewingSomeGroup && !!selectedGroup && jsx$1(FollowGroupActions, { followGroup: selectedGroup, refresh })
        ] })
      ] })
    ] });
  }
  function FilterCacheRelated() {
    const {
      cacheAllItemsEntry,
      cacheAllItemsUpMids
    } = useSettingsSnapshot().dynamicFeed.__internal;
    const {
      viewingSomeUp,
      upMid,
      upName
    } = useSnapshot(dfStore);
    const $req = useRequest(async (upMid2, upName2) => {
      const {
        notifyOnProgress,
        notifyOnSuccess
      } = createUpdateFilterCacheNotifyFns(upMid2, upName2);
      await updateLocalDynamicFeedCache(upMid2, notifyOnProgress);
      notifyOnSuccess();
    }, {
      manual: true
    });
    const checked = reactExports.useMemo(() => !!upMid && cacheAllItemsUpMids.includes(upMid.toString()), [upMid, cacheAllItemsUpMids]);
    const onChange = reactExports.useCallback(async (e) => {
      if (!upMid) return;
      const val = e.target.checked;
      const args = val ? {
        add: [upMid]
      } : {
        remove: [upMid]
      };
      await updateSettingsInnerArray("dynamicFeed.__internal.cacheAllItemsUpMids", args);
    }, []);
    return jsx$1(Fragment, { children: cacheAllItemsEntry && viewingSomeUp && upMid && upName && jsxs("div", { className: classes.section, children: [
jsxs("div", { className: classes.sectionTilte, children: [
        "过滤缓存",
jsxs(HelpInfo, { children: [
          "开启过滤缓存后, 会加载并缓存 UP 所有的动态 ",
jsx$1("br", {}),
          "当本地有缓存且总条数 <= 5000时, 过滤框成为及时过滤, 无需点击过滤按钮"
        ] })
      ] }),
jsxs("div", { className: classes.sectionContent, children: [
jsxs("div", { className: "flex flex-wrap items-center gap-x-10px gap-y-3px", children: [
jsx$1(Checkbox, { className: "inline-flex items-center", checked, onChange, children: jsx$1(AntdTooltip, { title: "只有开启此项, 过滤时才会使用缓存", children: jsxs("span", { children: [
            "为「",
            upName,
            "」开启"
          ] }) }) }),
jsx$1(Button$1, { loading: $req.loading, onClick: async () => {
            await $req.runAsync(upMid, upName);
          }, children: "更新缓存" })
        ] }),
jsx$1(CheckboxSettingItem, { configPath: "dynamicFeed.advancedFilter", label: "使用高级过滤", tooltip: advancedFilterHelpInfo })
      ] })
    ] }) });
  }
  const tryInstantFilterWithCache = throttle$2(async function({
    filterText,
    upMid,
    onRefresh
  }) {
    if (!upMid) return;
    if (!(filterText || !filterText && dfStore.filterText)) return;
    if (!settings.dynamicFeed.__internal.cacheAllItemsEntry) return;
    if (!settings.dynamicFeed.__internal.cacheAllItemsUpMids.includes(upMid.toString())) return;
    if (!await hasLocalDynamicFeedCache(upMid)) return;
    const info = await infoCache.get(upMid);
    if (!info || !info.count) return;
    if (info.count >= 5e3) return;
    dfStore.filterText = filterText;
    await delay$1(0);
    onRefresh();
  }, 100);
  function FollowGroupMechanismNote() {
    return jsxs(Fragment, { children: [
jsx$1("p", { children: "机制介绍:" }),
jsxs("ul", { className: "text-13px", children: [
jsxs("li", { className: "flex items-start gap-x-10px", children: [
jsx$1("div", { children: "「从全部过滤」:" }),
jsx$1("div", { children: '基于全部动态 + 分组UP过滤, 速度可能巨慢, 且过滤后的数量取决于B站记录的"全部"动态范围' })
        ] }),
jsxs("li", { className: "flex items-start gap-x-10px", children: [
jsx$1("div", { children: "「拼接时间线」:" }),
jsxs("div", { children: [
            "可以理解为: 去看一遍分组所有 UP 的动态, 然后将它们拼接起来 ",
jsx$1("br", {}),
            "启动慢, 但可以加载所有动态; 且分组 UP 越多, 启动越慢 ",
jsx$1("br", {}),
            "默认分组 UP 数量不超过 ",
            FollowGroupMergeTimelineService.ENABLE_MERGE_TIMELINE_UPMID_COUNT_THRESHOLD,
            " ",
            "时会使用「拼接时间线」 ",
jsx$1("br", {}),
            "详见",
jsx$1("a", { className: "mx-5px", href: "https://magicdawn.fun/2024/12/01/bilibili-gate-dynamic-feed-merge-timeline/", target: "_blank", children: "介绍博客" })
          ] })
        ] })
      ] })
    ] });
  }
  function FollowGroupActions({
    followGroup,
    refresh
  }) {
    const {
      whenViewAll
    } = useSnapshot(settings.dynamicFeed);
    const midCount = followGroup.count;
    let forceMergeTimelineCheckbox;
    const forceMergeTimelineHandle = useValueInSettingsCollection(followGroup.tagid, "dynamicFeed.followGroup.forceUseMergeTimelineIds");
    {
      const {
        checked,
        onChange
      } = forceMergeTimelineHandle;
      const disabled = midCount <= FollowGroupMergeTimelineService.ENABLE_MERGE_TIMELINE_UPMID_COUNT_THRESHOLD;
      forceMergeTimelineCheckbox = jsx$1(Checkbox, { checked, onChange: (e) => {
        onChange(e);
        refresh?.();
      }, disabled, children: jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
jsx$1(FollowGroupMechanismNote, {}),
        disabled && jsxs("p", { className: "text-yellow-400 italic", children: [
          "当前分组 UP 数量: ",
          midCount,
          ", 无需设置"
        ] })
      ] }), children: "分组动态: 强制使用「拼接时间线」" }) });
    }
    let clearMergeTimelineHeadCacheButton;
    {
      const usingMergeTimeline = midCount <= FollowGroupMergeTimelineService.ENABLE_MERGE_TIMELINE_UPMID_COUNT_THRESHOLD || forceMergeTimelineHandle.checked;
      const usingMergeTimelineHeadCache = usingMergeTimeline && midCount > FollowGroupMergeTimelineService.ENABLE_HEAD_CACHE_UPMID_COUNT_THRESHOLD;
      clearMergeTimelineHeadCacheButton = usingMergeTimelineHeadCache && jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
        "当分组 UP 数量",
        " >  ",
        FollowGroupMergeTimelineService.ENABLE_HEAD_CACHE_UPMID_COUNT_THRESHOLD,
        "时, 「拼接时间线」功能会缓存每个 UP 的最新动态5分钟. ",
jsx$1("br", {}),
        "这里可以手动清除缓存"
      ] }), children: jsx$1(Button$1, { onClick: () => {
        fetchDynamicFeedsWithCache.cache.db.clear();
        antMessage.success("已清除缓存");
      }, children: "清除「拼接时间线」- 队头缓存" }) });
    }
    let addTo_dynamicFeedWhenViewAllHideIds_checkbox;
    {
      const {
        checked,
        onChange
      } = useValueInSettingsCollection(`${DF_SELECTED_KEY_PREFIX_GROUP}${followGroup.tagid}`, "dynamicFeed.whenViewAll.hideIds");
      addTo_dynamicFeedWhenViewAllHideIds_checkbox = whenViewAll.enableHideSomeContents && jsx$1(Checkbox, { checked, onChange, children: jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
        "在「全部」动态中隐藏来自此 ",
        followGroup.name,
        " 的动态"
      ] }), children: "在「全部」动态中隐藏来自此分组的动态" }) });
    }
    return jsxs(Fragment, { children: [
      addTo_dynamicFeedWhenViewAllHideIds_checkbox,
      forceMergeTimelineCheckbox,
      clearMergeTimelineHeadCacheButton
    ] });
  }
  function useValueInSettingsCollection(value, listSettingsPath) {
    const list2 = useSettingsInnerArray(listSettingsPath);
    const checked = reactExports.useMemo(() => list2.includes(value), [list2]);
    const setChecked = useMemoizedFn(async (checked2) => {
      const arg = checked2 ? {
        add: [value]
      } : {
        remove: [value]
      };
      await updateSettingsInnerArray(listSettingsPath, arg);
    });
    const onChange = reactExports.useCallback((e) => {
      setChecked(e.target.checked);
    }, []);
    return {
      checked,
      setChecked,
      onChange
    };
  }
  function dynamicFeedFilterSelectUp(payload) {
    Object.assign(dfStore, payload);
    if (payload.upMid) {
      const item = dfStore.upList.find((x) => x.mid.toString() === payload.upMid);
      if (item) item.has_update = false;
    }
  }
  const clearPayload = {
    upMid: void 0,
    upName: void 0,
    upFace: void 0,
    filterText: void 0,
    selectedGroupId: void 0,
    dynamicFeedVideoType: DynamicFeedVideoType.All,
    filterMinDuration: DynamicFeedVideoMinDuration.All
  };
  function useScopeMenus(form) {
    const {
      upList,
      groups,
      selectedKey
    } = useSnapshot(dfStore);
    const onRefresh = useOnRefresh();
    const {
      followGroup: {
        enabled: followGroupEnabled
      }
    } = useSettingsSnapshot().dynamicFeed;
    const {
      recSharedEmitter
    } = useRecSelfContext();
    const onSelect = useMemoizedFn(async (payload) => {
      dynamicFeedFilterSelectUp(payload);
      await delay$1(100);
      onRefresh();
    });
    const onClear = useMemoizedFn(() => {
      onSelect({
        ...clearPayload
      });
      recSharedEmitter.emit("dynamic-feed:clear");
    });
    const menuItems = reactExports.useMemo(() => {
      const itemAll = {
        key: "all",
        icon: jsx$1(Avatar, { size: "small", children: "全" }),
        label: "全部",
        title: "全部",
        onClick: onClear
      };
      let groupItems = [];
      if (followGroupEnabled) {
        groupItems = groups.map((group) => {
          return {
            key: `group:${group.tagid}`,
            icon: jsx$1(Avatar, { size: "small", children: group.name[0] || "组" }),
            label: `${group.name} (${group.count})`,
            title: `${group.name} (${group.count})`,
            onClick: () => onSelect({
              ...clearPayload,
              selectedGroupId: group.tagid
            })
          };
        });
      }
      let usingUpList = upList;
      if (form === "dropdown") {
        usingUpList = fastSortWithRules(upList, [{
          prop: (item) => item.has_update ? 1 : 0,
          order: "desc"
        }, {
          prop: (item) => mapNameForSort(item.uname),
          order: zhLocaleComparer
        }]);
      }
      const items = usingUpList.map((up) => {
        let avatar = jsx$1(Avatar, { size: "small", src: getAvatarSrc(up.face) });
        if (up.has_update) {
          avatar = jsx$1(Badge, { dot: true, children: avatar });
        }
        return {
          key: `up:${up.mid}`,
          icon: avatar,
          label: jsx$1("span", { title: up.uname, className: "block max-w-130px overflow-hidden text-ellipsis whitespace-nowrap", children: up.uname }),
          title: up.uname,
          onClick() {
            onSelect({
              ...clearPayload,
              upMid: up.mid.toString(),
              upName: up.uname,
              upFace: up.face
            });
          }
        };
      });
      return [itemAll, ...groupItems, ...items];
    }, [upList, followGroupEnabled, groups, form]);
    return {
      menuItems,
      selectedKey,
onClear,
      onSelect
    };
  }
  function DynamicFeedTabbarView() {
    const {
      dynamicFeed: {
        __internal: {
          externalFilterInput
        }
      }
    } = useSettingsSnapshot();
    const {
      viewingSomeUp,
      upName,
      upFace,
      selectedGroup
    } = useSnapshot(dfStore);
    const onRefresh = useOnRefresh();
    const {
      ref: ref2,
      getPopupContainer
    } = usePopupContainer();
    const sidebarVisible = useSidebarVisible(ETab.DynamicFeed);
    const {
      menuItems,
      selectedKey,
      onClear
    } = useScopeMenus("dropdown");
    useMount(() => {
      updateFilterData();
    });
    const followGroupMidsCount = selectedGroup?.count;
    const upIcon = jsx$1(IconForUp, { className: "mt--2px size-14px" });
    const upAvtar = upFace ? jsx$1(Avatar, { size: 20, src: getAvatarSrc(upFace) }) : void 0;
    const dropdownButtonIcon = viewingSomeUp ? upAvtar || upIcon : selectedGroup ? jsx$1(IconForGroup, { className: "size-18px" }) : void 0;
    const dropdownButtonLabel = viewingSomeUp ? upName : selectedGroup ? selectedGroup.name + (followGroupMidsCount ? ` (${followGroupMidsCount})` : "") : "全部";
    const [scopeDropdownOpen, setScopeDropdownOpen] = reactExports.useState(false);
    const scopeDropdownMenu = jsx$1(Dropdown, { open: scopeDropdownOpen, onOpenChange: setScopeDropdownOpen, placement: "bottomLeft", getPopupContainer, menu: {
      items: menuItems,
      style: {
        ...dropdownMenuStyle,
        border: `1px solid ${usePopoverBorderColor()}`
      },
      selectedKeys: [selectedKey]
    }, children: jsx$1(Button$1, { icon: dropdownButtonIcon, className: "gap-4px", css: [scopeDropdownOpen && buttonOpenCss, "", ""], children: dropdownButtonLabel }) });
    const {
      popoverTrigger,
      filterInput
    } = usePopoverRelated({
      externalFilterInput,
      onRefresh,
      getPopupContainer
    });
    return jsxs("div", { ref: ref2, className: "inline-flex items-center gap-x-8px", children: [
      !sidebarVisible && scopeDropdownMenu,
      sidebarVisible ? jsxs(Button$1, { onClick: onClear, className: "gap-0", disabled: !(viewingSomeUp || selectedGroup), children: [
jsx$1(IconForReset, { className: "mr-5px size-14px" }),
jsx$1("span", { children: "清除" })
      ] }) : (viewingSomeUp || selectedGroup) && jsxs(Button$1, { onClick: onClear, className: "gap-0", children: [
jsx$1(IconForReset, { className: "mr-5px size-14px" }),
jsx$1("span", { children: "清除" })
      ] }),
      popoverTrigger,
      externalFilterInput && filterInput,
jsx$1(CopyBvidButtonsTabbarView, {})
    ] });
  }
  function DynamicFeedSidebarView() {
    const sidebarVisible = useSidebarVisible(ETab.DynamicFeed);
    const {
      menuItems,
      selectedKey
    } = useScopeMenus("sidebar");
    const {
      menuRef,
      revealSelected
    } = useRevealMenuSelectedKey(menuItems, selectedKey);
    const {
      recSharedEmitter
    } = useRecSelfContext();
    useEmitterOn(recSharedEmitter, "dynamic-feed:clear", () => void revealSelected(DF_SELECTED_KEY_ALL));
    if (!sidebarVisible) return void 0;
    return jsxs(Fragment, { children: [
jsx$1(Menu, { ref: menuRef, items: menuItems, selectedKeys: [selectedKey], mode: "inline", inlineIndent: 10 }),
      sidebarBottomLine
    ] });
  }
  function getDynamicFeedServiceConfig(usingDfStore = dfStore) {
    const snap = snapshot(usingDfStore);
    return {

upMid: snap.upMid,
      groupId: snap.selectedGroupId,
filterText: snap.filterText,
dynamicFeedVideoType: snap.dynamicFeedVideoType,
      hideChargeOnlyVideos: snap.hideChargeOnlyVideos,
filterMinDuration: snap.filterMinDuration,
      filterMinDurationValue: snap.filterMinDurationValue,
selectedKey: snap.selectedKey,
      viewingAll: snap.viewingAll,
      viewingSomeUp: snap.viewingSomeUp,
      viewingSomeGroup: snap.viewingSomeGroup,
      addSeparators: snap.addSeparators,
showLiveInDynamicFeed: settings.dynamicFeed.showLive,
      videoOnly: settings.dynamicFeed.videoOnly,
      whenViewAllEnableHideSomeContents: settings.dynamicFeed.whenViewAll.enableHideSomeContents,
      whenViewAllHideIds: new Set(settings.dynamicFeed.whenViewAll.hideIds),
      advancedFilter: settings.dynamicFeed.advancedFilter,
      filterCacheEnabled: !!snap.upMid && settings.dynamicFeed.__internal.cacheAllItemsEntry &&
settings.dynamicFeed.__internal.cacheAllItemsUpMids.includes(snap.upMid.toString()),
forceUseMergeTime: !!snap.selectedGroup && settings.dynamicFeed.followGroup.forceUseMergeTimelineIds.includes(snap.selectedGroup.tagid),
startingOffset: QUERY_DYNAMIC_OFFSET,
      minId: isValidNumber(QUERY_DYNAMIC_MIN_ID) ? BigInt(QUERY_DYNAMIC_MIN_ID) : void 0,
      minTs: isValidNumber(QUERY_DYNAMIC_MIN_TS) ? Number(QUERY_DYNAMIC_MIN_TS) : void 0
    };
  }
  function isValidNumber(str) {
    return !!str && /^\d+$/.test(str);
  }
  const debug$8 = baseDebug.extend("modules:rec-services:dynamic-feed");
  class DynamicFeedRecService extends BaseTabService {
    constructor(config) {
      super(DynamicFeedRecService.PAGE_SIZE);
      this.config = config;
      if (this.config.showLiveInDynamicFeed) {
        const filterEmpty = !this.upMid && this.groupId === void 0 && !this.filterText && this.dynamicFeedVideoType === DynamicFeedVideoType.All && this.filterMinDuration === DynamicFeedVideoMinDuration.All;
        if (filterEmpty) {
          this.liveRecService = new LiveRecService(true);
        }
      }
      if (this.config.startingOffset) {
        this.offset = this.config.startingOffset;
      }
    }
    static PAGE_SIZE = 15;
    tabbarView = jsx$1(DynamicFeedTabbarView, {});
    sidebarView = jsx$1(DynamicFeedSidebarView, {});
    hasMoreExceptQueue = true;
    get hasMore() {
      if (this.qs.bufferQueue.length) return true;
      if (this.liveRecService?.hasMore) return true;
      if (this.viewingSomeGroup && this.groupMergeTimelineService) {
        return this.groupMergeTimelineService.hasMore;
      }
      if (this.hasMoreExceptQueue) return true;
      return false;
    }
    async shouldReduceMinCount() {
      if (this.viewingAll) ;
      if (this.viewingSomeGroup) {
        await this.loadGroupMids();
        return !this.groupMergeTimelineService;
      }
      if (this.filterText || this.dynamicFeedVideoType === DynamicFeedVideoType.DynamicOnly || this.filterMinDuration !== DynamicFeedVideoMinDuration.All) {
        return true;
      }
      return false;
    }
get upMid() {
      return this.config.upMid;
    }
get groupId() {
      return this.config.groupId;
    }
    get filterText() {
      return this.config.filterText;
    }
    get dynamicFeedVideoType() {
      return this.config.dynamicFeedVideoType;
    }
    get hideChargeOnlyVideos() {
      return this.config.hideChargeOnlyVideos;
    }
    get filterMinDuration() {
      return this.config.filterMinDuration;
    }
    get filterMinDurationValue() {
      return this.config.filterMinDurationValue;
    }
    get viewingSomeUp() {
      return this.config.viewingSomeUp;
    }

get viewingSomeGroup() {
      return this.config.viewingSomeGroup;
    }
    shouldEnableMergeTimeline(midCount) {
      return this.config.forceUseMergeTime || midCount > 0 && midCount <= FollowGroupMergeTimelineService.ENABLE_MERGE_TIMELINE_UPMID_COUNT_THRESHOLD;
    }
    groupMergeTimelineService;
    groupMids = new Set();
    groupMidsLoaded = false;
    async loadGroupMids() {
      if (this.groupId === void 0) return;
      if (this.groupMidsLoaded) return;
      try {
        const mids2 = await getFollowGroupContent(this.groupId);
        this.groupMids = new Set(mids2);
        if (this.shouldEnableMergeTimeline(mids2.length)) {
          this.groupMergeTimelineService = new FollowGroupMergeTimelineService(mids2.map((x) => x.toString()), this.config.videoOnly);
        }
      } finally {
        this.groupMidsLoaded = true;
      }
    }

get viewingAll() {
      return this.config.viewingAll;
    }
    viewingAllHideMids = new Set();
    viewingAllHideMidsLoaded = false;
    async loadViewingAllHideMids() {
      if (!this.viewingAll) return;
      if (!this.config.whenViewAllEnableHideSomeContents) return;
      if (!this.config.whenViewAllHideIds.size) return;
      if (this.viewingAllHideMidsLoaded) return;
      const mids2 = Array.from(this.config.whenViewAllHideIds).filter((x) => x.startsWith(DF_SELECTED_KEY_PREFIX_UP)).map((x) => x.slice(DF_SELECTED_KEY_PREFIX_UP.length));
      const groupIds = Array.from(this.config.whenViewAllHideIds).filter((x) => x.startsWith(DF_SELECTED_KEY_PREFIX_GROUP)).map((x) => x.slice(DF_SELECTED_KEY_PREFIX_GROUP.length));
      const set2 = this.viewingAllHideMids;
      mids2.forEach((x) => set2.add(x));
      const midsInGroup = (await pmap(groupIds, (id2) => getFollowGroupContent(id2), 3)).flat();
      midsInGroup.forEach((x) => set2.add(x.toString()));
      this.viewingAllHideMidsLoaded = true;
    }
async fetchMore(abortSignal) {
      const items = await this._fetchMore(abortSignal);
      return this.handleAddSeparators(items);
    }
    liveRecService;
    _queueForFilterCache;
    offset = "";
    page = 0;
async _fetchMore(abortSignal) {
      if (this.liveRecService?.hasMore) {
        const items2 = await this.liveRecService.loadMore(abortSignal) || [];
        return items2.filter((x) => x.api !== EApiType.Separator);
      }
      let rawItems;
      if (this.viewingSomeGroup) {
        await this.loadGroupMids();
      }
      if (this.viewingAll) {
        await this.loadViewingAllHideMids();
        debug$8("viewingAll: hide-mids = %o", this.viewingAllHideMids);
      }
      const useFilterCache = !!(this.upMid && this.filterText && this.config.filterCacheEnabled && await hasLocalDynamicFeedCache(this.upMid));
      const useAdvancedFilter = useFilterCache && this.config.advancedFilter;
      const useAdvancedFilterParsed = useAdvancedFilter ? parseAdvancedFilter((this.filterText || "").toLowerCase()) : void 0;
      if (useFilterCache) {
        if (!this._queueForFilterCache) {
          await performIncrementalUpdateIfNeed(this.upMid);
          this._queueForFilterCache = new QueueStrategy(20);
          this._queueForFilterCache.bufferQueue = (await cache.get(this.upMid) || []).filter((x) => {
            const v = getArchive(x);
            if (!v) return false;
            const title = v.title;
            return filterByFilterText({
              filterText: this.filterText,
              title,
              useAdvancedFilter,
              useAdvancedFilterParsed
            });
          });
        }
        rawItems = this._queueForFilterCache.sliceFromQueue(this.page + 1) || [];
        this.page++;
        this.hasMoreExceptQueue = !!this._queueForFilterCache.bufferQueue.length;
      } else if (this.viewingSomeGroup && this.groupMergeTimelineService) {
        rawItems = await this.groupMergeTimelineService.loadMore(abortSignal);
      } else {
        const data2 = await fetchDynamicFeeds({
          videoOnly: this.config.videoOnly,
          abortSignal,
          page: this.page + 1,
offset: this.offset,
          upMid: this.upMid
        });
        this.page++;
        this.hasMoreExceptQueue = data2.has_more;
        this.offset = data2.offset;
        rawItems = data2.items;
        if (this.config.minId) {
          const minId = this.config.minId;
          const idx = rawItems.findIndex((x) => BigInt(x.id_str) <= minId);
          if (idx !== -1) {
            this.hasMoreExceptQueue = false;
            rawItems = rawItems.slice(0, idx + 1);
          }
        }
        if (this.config.minTs) {
          const minTs = this.config.minTs;
          const idx = rawItems.findIndex((x) => x.modules.module_author.pub_ts <= minTs);
          if (idx !== -1) {
            this.hasMoreExceptQueue = false;
            rawItems = rawItems.slice(0, idx + 1);
          }
        }
      }
      const items = rawItems.filter((x) => {
        if (!this.viewingSomeGroup) return true;
        if (this.groupMergeTimelineService) return true;
        if (!this.groupMids.size) return true;
        const mid = x.modules.module_author.mid;
        return this.groupMids.has(mid);
      }).filter((x) => {
        if (this.dynamicFeedVideoType === DynamicFeedVideoType.All) return true;
        const v = getArchive(x);
        if (!v) return false;
        const currentLabel = v.badge.text;
        if (this.dynamicFeedVideoType === DynamicFeedVideoType.DynamicOnly) {
          return currentLabel === DynamicFeedBadgeText.Dynamic;
        }
        if (this.dynamicFeedVideoType === DynamicFeedVideoType.UploadOnly) {
          return currentLabel === DynamicFeedBadgeText.Upload || currentLabel === DynamicFeedBadgeText.ChargeOnly;
        }
        return false;
      }).filter((x) => {
        if (!this.hideChargeOnlyVideos) return true;
        const v = getArchive(x);
        if (!v) return true;
        const chargeOnly = v.badge.text === DynamicFeedBadgeText.ChargeOnly;
        return !chargeOnly;
      }).filter((x) => {
        if (this.filterMinDuration === DynamicFeedVideoMinDuration.All) return true;
        const v = getArchive(x);
        if (!v) return false;
        const duration2 = parseDuration(v.duration_text);
        return duration2 >= this.filterMinDurationValue;
      }).filter((x) => {
        if (!this.filterText) return true;
        const v = getArchive(x);
        if (!v) return false;
        const title = v.title || "";
        return filterByFilterText({
          filterText: this.filterText,
          title,
          useAdvancedFilter,
          useAdvancedFilterParsed
        });
      }).filter((x) => {
        if (this.config.selectedKey !== DF_SELECTED_KEY_ALL) return true;
        const set2 = this.viewingAllHideMids;
        if (!set2.size) return true;
        const mid = x.modules.module_author.mid;
        return !set2.has(mid.toString());
      }).map((item) => {
        return {
          ...item,
          api: EApiType.DynamicFeed,
          uniqId: `${EApiType.DynamicFeed}:${item.id_str || crypto.randomUUID()}`,
          groupId: this.viewingSomeGroup ? this.groupId : void 0
        };
      });
      function filterByFilterText({
        title,
        filterText,
        useAdvancedFilter: useAdvancedFilter2,
        useAdvancedFilterParsed: useAdvancedFilterParsed2
      }) {
        title = title.toLowerCase();
        filterText = filterText.toLowerCase();
        const simpleFilter = () => title.includes(filterText);
        const advancedFilter = () => {
          return (useAdvancedFilterParsed2?.includes ?? []).every((x) => title.includes(x)) && (useAdvancedFilterParsed2?.excludes ?? []).every((x) => !title.includes(x));
        };
        return useAdvancedFilter2 ? advancedFilter() : simpleFilter();
      }
      const {
        upMid,
        upName
      } = dfStore;
      if (
QUERY_DYNAMIC_UP_MID && upMid && upName && upName === upMid.toString() && items[0]
      ) {
        const authorName = items[0].modules.module_author.name;
        const authorFace = items[0].modules.module_author.face;
        dfStore.upName = authorName;
        dfStore.upFace = authorFace;
      }
      if (this.viewingSomeGroup && dfStore.groups.length) {
        const group = dfStore.groups.find((x) => x.tagid === this.groupId);
        if (group) group.count = this.groupMids.size;
      }
      return items;
    }
    separatorsConfig = (() => {
      return {
        today: {
          added: false,
          content: "今日",
          getInsertIndex: getTodaySeparatorInsertIndex
        },
        earlier: {
          added: false,
          content: "更早",
          getInsertIndex: insertIndexFinderViaPubTsRange(-Infinity, dayjs().startOf("day").unix())
        }
      };
    })();
    handleAddSeparators(items) {
      if (!this.config.addSeparators) return items;
      const ret = items;
      {
        const config = this.separatorsConfig.today;
        const {
          getInsertIndex,
          content,
          added
        } = config;
        if (!added) {
          const idx = getInsertIndex(items);
          if (idx !== -1) {
            ret.splice(idx, 0, {
              api: EApiType.Separator,
              uniqId: `${EApiType.DynamicFeed}:separator:today`,
              content
            });
            config.added = true;
          }
        }
      }
      {
        const config = this.separatorsConfig.earlier;
        const {
          getInsertIndex,
          content,
          added
        } = config;
        if (!added) {
          const idx = getInsertIndex(items);
          if (idx !== -1) {
            ret.splice(idx, 0, {
              api: EApiType.Separator,
              uniqId: `${EApiType.DynamicFeed}:separator:earlier`,
              content
            });
            config.added = true;
          }
        }
      }
      return ret;
    }
  }
  function insertIndexFinderViaPubTsRange(lower, upper) {
    return (items) => {
      return items.findIndex((x) => {
        if (x.api !== EApiType.DynamicFeed) return false;
        const pubTs = x.modules.module_author.pub_ts;
        return pubTs >= lower && pubTs < upper;
      });
    };
  }
  function getTodaySeparatorInsertIndex(items) {
    const index = items.findIndex((x) => x.api === EApiType.Live && x.live_status === ELiveStatus.Streaming);
    if (index !== -1) return index;
    const todayInsertIndexFinder = insertIndexFinderViaPubTsRange(dayjs().startOf("day").unix(), dayjs().endOf("day").unix());
    return todayInsertIndexFinder(items);
  }
  const FAV_PAGE_SIZE = 20;
  const clsFavSeparatorItem = "ml-30px inline-flex items-center text-15px [&_svg]:mr-5px [&_svg]:mt--1px first:ml-0";
  class FavCollectionService {
    constructor(collectionId, addSeparator, itemsOrder) {
      this.collectionId = collectionId;
      this.addSeparator = addSeparator;
      this.itemsOrder = itemsOrder;
    }
    get hasMore() {
      if (this.addSeparator && !this.separatorAdded) return true;
      if (!this.loaded) return true;
      return !!this.bufferQueue.length;
    }
loaded = false;
    bufferQueue = [];
    separatorAdded = false;
    get separator() {
      return {
        api: EApiType.Separator,
        uniqId: `${EApiType.Fav}:collection:separator:${this.collectionId}`,
        content: jsx$1(FavCollectionSeparator, { service: this })
      };
    }
state = proxy({
      firstBvid: void 0,
      info: void 0
    });
    async loadMore(abortSignal) {
      if (!this.hasMore) return;
      if (this.addSeparator && !this.separatorAdded) {
        this.separatorAdded = true;
        return [this.separator];
      }
      if (!this.loaded) {
        const data2 = await fetchCollectionDetail(this.collectionId, 1);
        const medias = data2?.medias || [];
        const info = data2?.info;
        await attemptAsync(() => this.loadUserAvatarFromSpaceAccInfo(medias, abortSignal));
        let items = medias.map((x) => {
          return {
            ...x,
            api: EApiType.Fav,
            uniqId: `${EApiType.Fav}:collection:${this.collectionId}:${x.bvid}`,
            collection: data2.info,
            from: "fav-collection"
          };
        });
        const shouldAddVol = [FavItemsOrder.PubTimeDesc, FavItemsOrder.PubTimeAsc, FavItemsOrder.Shuffle].includes(this.itemsOrder);
        if (shouldAddVol) {
          items = handleItemsOrder(items, FavItemsOrder.PubTimeDesc);
          items.forEach((item, index, arr) => {
            item.vol = arr.length - index;
            item.volTooltip = jsxs(Fragment, { children: [
              "按投稿时间 Vol.",
              item.vol
            ] });
          });
        }
        items = handleItemsOrder(items, this.itemsOrder);
        this.bufferQueue = items;
        this.loaded = true;
        this.state.firstBvid = items[0]?.bvid;
        this.state.info = cloneDeep(info);
        favStore.selectedFavCollectionDetailInfo = cloneDeep(info);
      }
      if (this.itemsOrder === FavItemsOrder.Shuffle) {
        this.bufferQueue = shuffle(this.bufferQueue);
      }
      let sliced;
      [sliced, this.bufferQueue] = [this.bufferQueue.slice(0, FAV_PAGE_SIZE), this.bufferQueue.slice(FAV_PAGE_SIZE)];
      return sliced;
    }
async loadUserAvatarFromSpaceAccInfo(items, abortSignal) {
      if (!items.length) return;
      const midsCount = countBy(items, (x) => x.upper.mid);
      const list2 = Object.entries(midsCount).map(([mid, count]) => ({
        mid,
        count
      }));
      const topMids = orderBy(list2, [(x) => x.count], ["desc"]).slice(0, 3).map((x) => x.mid);
      await Promise.all(topMids.map(async (mid) => {
        if (abortSignal?.aborted) return;
        const info = await getSpaceAccInfo(mid);
        const face = info?.face;
        if (face) {
          items.filter((x) => x.upper.mid.toString() === mid).forEach((x) => {
            x.upper.face ||= face;
          });
        }
      }));
    }
    get extraTabbarView() {
      return jsx$1(FavItemsOrderSwitcher, {});
    }
  }
  function FavCollectionSeparator({
    service
  }) {
    const {
      firstBvid,
      info
    } = useSnapshot(service.state);
    return jsxs(Fragment, { children: [
jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
        "UP: ",
        info?.upper.name,
        " ",
jsx$1("br", {}),
        "简介: ",
        info?.intro || "无"
      ] }), children: jsxs(CustomTargetLink, { href: formatFavCollectionUrl(service.collectionId), className: clsFavSeparatorItem, children: [
jsx$1(IconForOpenExternalLink, { className: "size-16px" }),
        "去个人空间查看合集: ",
        info?.title
      ] }) }),
      firstBvid && jsxs(CustomTargetLink, { href: formatBvidUrl(firstBvid), className: clsFavSeparatorItem, children: [
jsx$1(IconForPlayer, { className: "size-16px" }),
        "播放全部"
      ] })
    ] });
  }
  function FavFolderRenamePopover({
    folderId,
    currentFolderTitle,
    onClosePopover
  }) {
    const $req = useRequest((newTitle) => editFavFolder(folderId, newTitle), {
      manual: true
    });
    const [folderTitle, setFolderTitle] = reactExports.useState(currentFolderTitle);
    const handleSubmit = useMemoizedFn(async () => {
      const newTitle = folderTitle.trim();
      if (!newTitle) return toast("收藏夹名称不能为空!");
      if (newTitle === currentFolderTitle) return toast("无变更!");
      const success = await $req.runAsync(newTitle);
      if (!success) return;
      onClosePopover();
      const folder = favStore.folders.find((f2) => f2.id === folderId);
      if (folder) folder.title = folderTitle;
    });
    return jsxs("div", { className: "flex flex-col gap-y-2", children: [
jsx$1("div", { children: "重命名收藏夹" }),
jsx$1(Input, { placeholder: "收藏夹名称", value: folderTitle, onChange: (e) => setFolderTitle(e.target.value), onPressEnter: handleSubmit }),
jsxs("div", { className: "flex justify-end gap-x-2", children: [
jsx$1(Button$1, { onClick: onClosePopover, children: "取消" }),
jsx$1(Button$1, { type: "primary", loading: $req.loading, onClick: handleSubmit, disabled: !folderTitle || folderTitle === currentFolderTitle, children: "确定" })
      ] })
    ] });
  }
  function FavFolderSeparator({
    service
  }) {
    const [renamePopoverOpen, setRenamePopoverOpen] = reactExports.useState(false);
    const {
      viewingSomeFolder
    } = useSnapshot(favStore);
    const {
      id: folderId,
      attr: folderAttr,
      title: folderTitleFromService
    } = service.entry;
    const folderTitle = useSnapshot(favStore.folders).find((f2) => f2.id === folderId)?.title ?? folderTitleFromService;
    const clsIcon = "size-16px";
    return jsxs(Fragment, { children: [
jsxs(CustomTargetLink, { href: formatFavFolderUrl(folderId, folderAttr), className: clsFavSeparatorItem, children: [
jsx$1(IconForOpenExternalLink, { className: clsIcon }),
        "去个人空间查看收藏夹: ",
        folderTitle
      ] }),
jsxs(CustomTargetLink, { href: formatFavPlaylistUrl(folderId), className: clsFavSeparatorItem, children: [
jsx$1(IconForPlayer, { className: clsIcon }),
        "播放全部"
      ] }),
      viewingSomeFolder && jsx$1(Popover, { open: renamePopoverOpen, onOpenChange: setRenamePopoverOpen, trigger: "click", content: jsx$1(FavFolderRenamePopover, { folderId, currentFolderTitle: folderTitle, onClosePopover: () => setRenamePopoverOpen(false) }), children: jsxs(Button$1, { className: clsx(clsFavSeparatorItem, "gap-x-1 px-0 text-15px!"), type: "link", children: [
jsx$1(IconForEdit, { className: clsIcon }),
        "重命名"
      ] }) })
    ] });
  }
  const FAV_FOLDER_API_SUPPOETED_ORDER = [FavItemsOrder.FavTimeDesc, FavItemsOrder.PlayCountDesc, FavItemsOrder.PubTimeDesc];
  function isFavFolderApiSuppoetedOrder(order) {
    return FAV_FOLDER_API_SUPPOETED_ORDER.includes(order);
  }
  const favFolderAllItemsCache = getIdbCache("fav-folder-all-items");
  async function clearFavFolderAllItemsCache(folderId) {
    await favFolderAllItemsCache.delete(folderId);
  }
  class FavFolderService {
    constructor(folderId, addSeparator, itemsOrder) {
      this.folderId = folderId;
      this.addSeparator = addSeparator;
      this.itemsOrder = itemsOrder;
      if (this.itemsOrder === FavItemsOrder.Initial) {
        throw new Error("this should not happen!");
      }
      if (isFavFolderApiSuppoetedOrder(this.itemsOrder)) {
        this.needLoadAll = false;
      } else {
        this.needLoadAll = true;
      }
    }
    needLoadAll;
    get hasMore() {
      if (this.addSeparator && !this.separatorAdded) return true;
      if (this.needLoadAll) {
        if (!this.allItemsLoaded) return true;
        return !!this.bufferQueue.length;
      } else {
        if (!this.innerService) return true;
        return this.innerService.hasMore;
      }
    }
    separatorAdded = false;
    get separator() {
      this.assertInnerService();
      return {
        api: EApiType.Separator,
        uniqId: `${EApiType.Fav}:folder:separator:${this.folderId}`,
        content: jsx$1(FavFolderSeparator, { service: this.innerService })
      };
    }
    entry;
    innerService;
assertInnerService() {
      invariant$1(this.innerService, "this.innerService should not be undefined");
      invariant$1(this.entry, "this.entry should not be undefined");
    }
    async createService() {
      if (this.innerService) return;
      await updateFavList();
      const entry = snapshot(favStore.folders).find((f2) => f2.id === this.folderId);
      invariant$1(entry, `favStore.favFolders should have this entry[fid=${this.folderId}]`);
      this.entry = entry;
      if (isFavFolderApiSuppoetedOrder(this.itemsOrder)) {
        this.innerService = new FavFolderBasicService(entry, this.itemsOrder);
      } else {
        this.innerService = new FavFolderBasicService(entry);
      }
    }
    async loadMore(abortSignal) {
      if (!this.innerService) await this.createService();
      if (!this.hasMore) return;
      if (this.addSeparator && !this.separatorAdded) {
        this.separatorAdded = true;
        return [this.separator];
      }
      if (this.needLoadAll) {
        if (!this.allItemsLoaded) await this.loadAllItems(abortSignal);
        if (this.itemsOrder === FavItemsOrder.Shuffle) {
          this.bufferQueue = shuffle(this.bufferQueue);
        }
        const sliced = this.bufferQueue.slice(0, FAV_PAGE_SIZE);
        this.bufferQueue = this.bufferQueue.slice(FAV_PAGE_SIZE);
        return sliced;
      } else {
        const ret = await this.innerService?.loadMore(abortSignal);
        this.runSideEffects();
        return ret;
      }
    }
    allItemsLoaded = false;
    bufferQueue = [];
    async loadAllItems(abortSignal) {
      const allItems = await this.fetchAllItems(abortSignal);
      this.bufferQueue = handleItemsOrder(allItems, this.itemsOrder);
      this.allItemsLoaded = true;
      this.runSideEffects();
    }
    _fetchAllItems = async (abortSignal) => {
      this.assertInnerService();
      const allItems = [];
      while (this.innerService.hasMore && !abortSignal.aborted) {
        const items = await this.innerService.loadMore(abortSignal) || [];
        allItems.push(...items);
      }
      return allItems;
    };
_fetchAllItemsWithCache = wrapWithIdbCache({
      fn: this._fetchAllItems,
      tableName: favFolderAllItemsCache,
      generateKey: () => `${this.folderId}`,
      ttl: ms("5min")
    });
    fetchAllItems = (abortSignal) => {
      this.assertInnerService();
      const shouldUseCache = this.entry.media_count > FavFolderBasicService.PAGE_SIZE * 3;
      return shouldUseCache ? this._fetchAllItemsWithCache(abortSignal) : this._fetchAllItems(abortSignal);
    };
    runSideEffects() {
      this.assertInnerService();
      if (typeof this.innerService.info?.media_count === "number") {
        updateFavFolderMediaCount(this.folderId, this.innerService.info.media_count);
      }
    }
    get extraTabbarView() {
      return jsx$1(FavItemsOrderSwitcher, {});
    }
  }
  class FavFolderBasicService {
    constructor(entry, itemsOrder = FavItemsOrder.FavTimeDesc) {
      this.entry = entry;
      this.itemsOrder = itemsOrder;
      this.hasMore = entry.media_count > 0;
    }
    static PAGE_SIZE = 20;
    hasMore;
    info;
    page = 0;
async loadMore(abortSignal) {
      if (!this.hasMore) return;
      const order = {
        [FavItemsOrder.FavTimeDesc]: "mtime",
        [FavItemsOrder.PlayCountDesc]: "view",
        [FavItemsOrder.PubTimeDesc]: "pubtime"
      }[this.itemsOrder];
      const res = await request.get("/x/v3/fav/resource/list", {
        params: {
          media_id: this.entry.id,
          pn: this.page + 1,
ps: FavFolderBasicService.PAGE_SIZE,
          keyword: "",
          order,
type: "0",
tid: "0",
platform: "web"
        }
      });
      const json = res.data;
      if (!isWebApiSuccess(json)) {
        toast(json.message || REQUEST_FAIL_MSG);
        return;
      }
      this.page++;
      this.hasMore = json.data.has_more;
      this.info = json.data.info;
      let items = json.data.medias || [];
      items = items.filter((item) => {
        if (item.title === "已失效视频") return false;
        return true;
      });
      return items.map((item) => {
        return {
          ...item,
          from: "fav-folder",
          folder: this.info,
          api: EApiType.Fav,
          uniqId: `${EApiType.Fav}:folder:${this.info?.id || this.entry.id}:${item.bvid}`
        };
      });
    }
  }
  class FavAllService {
    constructor(addSeparator, itemsOrder, excludedFolderIds) {
      this.addSeparator = addSeparator;
      this.itemsOrder = itemsOrder;
      this.excludedFolderIds = excludedFolderIds;
      if (![FavItemsOrder.Initial, FavItemsOrder.Shuffle].includes(this.itemsOrder)) {
        throw new Error("invalid items order");
      }
    }
    get useShuffle() {
      return this.itemsOrder === FavItemsOrder.Shuffle;
    }
    shuffleBufferQueue = [];
    get hasMoreInService() {
      if (!this.serviceCreated) return true;
      return this.allServices.some((s2) => s2.hasMore);
    }
    get hasMore() {
      if (this.useShuffle) {
        return !!this.shuffleBufferQueue.length || this.hasMoreInService;
      } else {
        return this.hasMoreInService;
      }
    }
    get extraTabbarView() {
      return jsxs(Fragment, { children: [
jsx$1(FavItemsOrderSwitcher, {}),
jsx$1(ViewingAllExcludeFolderConfig, { allFavFolderServices: this.allFolderServices, state: this.state })
      ] });
    }
    async loadMore(abortSignal) {
      if (!this.serviceCreated) await this.createServices();
      if (!this.hasMore) return;
      if (!this.useShuffle) {
        const service = this.allServices.find((s2) => s2.hasMore);
        return service?.loadMore(abortSignal);
      }
      if (this.shuffleBufferQueue.length < FAV_PAGE_SIZE) {
        const count = 6;
        const batch = 2;
        while (this.hasMoreInService && this.shuffleBufferQueue.length < FAV_PAGE_SIZE * 3) {
          const restServices = this.allServices.filter((s2) => s2.hasMore);
          const pickedServices = shuffle(restServices).slice(0, count);
          const fetched = (await pmap(pickedServices, async (s2) => await s2.loadMore(abortSignal) || [], batch)).flat().filter((x) => x.api !== EApiType.Separator);
          this.shuffleBufferQueue = shuffle([...this.shuffleBufferQueue, ...shuffle(fetched)]);
        }
      }
      const sliced = this.shuffleBufferQueue.slice(0, FAV_PAGE_SIZE);
      this.shuffleBufferQueue = this.shuffleBufferQueue.slice(FAV_PAGE_SIZE);
      return sliced;
    }
allFolderServices = [];
state = proxy({
      totalCountInFavFolders: 0
    });
    serviceCreated = false;
    allServices = [];
    async createServices() {
      await updateFavList();
      const {
        folders,
        collections
      } = cloneDeep(snapshot(favStore));
      this.allFolderServices = folders.map((f2) => new FavFolderBasicService(f2));
      this.state.totalCountInFavFolders = folders.filter((f2) => !this.excludedFolderIds.includes(f2.id.toString())).reduce((count, f2) => count + f2.media_count, 0);
      {
        const _folders = folders.filter((f2) => !this.excludedFolderIds.includes(f2.id.toString()));
        let itemsOrder = this.itemsOrder;
        if (itemsOrder === FavItemsOrder.Initial) itemsOrder = FavItemsOrder.FavTimeDesc;
        this.allServices.push(..._folders.map((f2) => new FavFolderService(f2.id, this.addSeparator, itemsOrder)));
      }
      {
        this.allServices.push(...collections.map((c2) => new FavCollectionService(c2.id, this.addSeparator, this.itemsOrder)));
      }
      this.serviceCreated = true;
    }
  }
  function getFavServiceConfig() {
    const snap = snapshot(favStore);
    return {
      selectedKey: snap.selectedKey,
      viewingAll: snap.viewingAll,
      viewingSomeFolder: snap.viewingSomeFolder,
      viewingSomeCollection: snap.viewingSomeCollection,
      itemsOrder: getSavedOrder(snap.selectedKey, snap.savedOrderMap),
      selectedFavFolderId: snap.selectedFavFolderId,
      selectedFavCollectionId: snap.selectedFavCollectionId,
addSeparator: settings.fav.addSeparator,
      excludedFolderIds: settings.fav.excludedFolderIds
    };
  }
  class FavRecService extends BaseTabService {
    constructor(config) {
      super(FavRecService.PAGE_SIZE);
      this.config = config;
      const {
        viewingAll,
        viewingSomeFolder,
        viewingSomeCollection
      } = this.config;
      if (viewingAll) {
        this.innerService = new FavAllService(this.config.addSeparator, this.config.itemsOrder, this.config.excludedFolderIds);
      } else if (viewingSomeFolder) {
        this.innerService = new FavFolderService(this.config.selectedFavFolderId, this.config.addSeparator, this.config.itemsOrder);
      } else if (viewingSomeCollection) {
        this.innerService = new FavCollectionService(this.config.selectedFavCollectionId, this.config.addSeparator, this.config.itemsOrder);
      } else {
        throw new Error("unexpected case!");
      }
    }
    static PAGE_SIZE = FAV_PAGE_SIZE;
    innerService;
    get tabbarView() {
      const {
        tabbarView,
        extraTabbarView
      } = this.innerService;
      if (tabbarView) return tabbarView;
      return jsx$1(FavTabbarView, { extraContent: extraTabbarView });
    }
    sidebarView = jsx$1(FavSidebarView, {});
    get hasMoreExceptQueue() {
      return this.innerService.hasMore;
    }
    fetchMore(abortSignal) {
      return this.innerService.loadMore(abortSignal);
    }
decreaseTotal() {
      if (this.config.viewingAll) {
        this.innerService.state.totalCountInFavFolders -= 1;
      } else if (this.config.viewingSomeFolder && this.config.selectedFavFolderId) {
        updateFavFolderMediaCount(this.config.selectedFavFolderId, (x) => x - 1);
      } else if (this.config.viewingSomeCollection && this.config.selectedFavCollectionId) ;
    }
  }
  async function fetchWatchlaterItems({
    asc = false,
    searchText = "",
    abortSignal,
    extraParams
  } = {}) {
    const res = await request.get("/x/v2/history/toview/web", {
      signal: abortSignal,
      params: await encWbi({
        asc,
        key: searchText,
        viewed: 0,
web_location: 333.881,
        ...extraParams
      })
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      appWarn("getAllWatchlaterItems error %s, fulljson %o", json.message, json);
      return {
        err: json.message
      };
    }
    return {
      total: json.data.count,
      items: filterOutApiReturnedRecent(json.data.list || [])
    };
  }
  function filterOutApiReturnedRecent(items) {
    return items.filter((item) => !(item.title === "以下为更早添加的视频" && item.aid === 0 && item.bvid === "" && item.add_at === 0));
  }
  async function batchRemoveWatchlater(avids) {
    const form = new FormData();
    form.append("resources", avids.join(","));
    form.append("csrf", getCsrfToken());
    const params = await encWbi({});
    const res = await request.post("/x/v2/history/toview/v2/dels", form, {
      params
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      toast(json?.message || "出错了");
      return false;
    }
    return true;
  }
  const getRecentGate = () => dayjs().subtract(2, "days").unix();
  const recentGateDescription = "最近 48 小时内";
  const recentSeparator = {
    api: EApiType.Separator,
    uniqId: `${EApiType.Watchlater}:separator:recent`,
    content: jsxs(Fragment, { children: [
      "近期",
jsx$1(HelpInfo, { children: recentGateDescription })
    ] })
  };
  const earlierSeparator = {
    api: EApiType.Separator,
    uniqId: `${EApiType.Watchlater}:separator:earlier`,
    content: "更早"
  };
  const store$1 = proxy({
    searchText: void 0
  });
  function WatchlaterTabbarView({
    service
  }) {
    const {
      watchlaterAddSeparator,
      watchlaterItemsOrder,
      watchlaterUseNormalVideoUrl
    } = useSettingsSnapshot();
    const onRefresh = useOnRefresh();
    const {
      searchText
    } = useSnapshot(store$1, {
      sync: true
    });
    const multiSelecting = useMultiSelecting();
    const {
      recSharedEmitter
    } = useRecSelfContext();
    useUpdateEffect(() => {
      void (async () => {
        await delay$1(100);
        onRefresh();
      })();
    }, [watchlaterAddSeparator, watchlaterItemsOrder, watchlaterUseNormalVideoUrl]);
    const {
      total
    } = useSnapshot(service.state);
    const title = searchText ? `共 ${total} 条搜索结果` : `共 ${total} 个视频`;
    const totalTag = typeof total === "number" && jsx$1(Tag, { color: "success", style: {
      marginRight: 0,
      marginTop: 1,
      cursor: "pointer"
    }, title, onClick: () => {
      toast(`稍后再看: ${title}`);
    }, children: total });
    return jsxs("div", { className: "flex items-center gap-x-12px", children: [
jsx$1(WatchlaterOrderSwitcher, {}),
jsx$1(Input.Search, { allowClear: true, placeholder: "搜索稍后再看", style: {
        width: 180
      }, value: searchText, onChange: (e) => store$1.searchText = e.target.value, onSearch: (val) => {
        store$1.searchText = val;
        onRefresh();
      } }),
      totalTag,
      multiSelecting && jsx$1(AntdTooltip, { arrow: false, title: "移除稍后再看 (多选)", children: jsx$1(Button$1, { className: "icon-only-round-button", onClick: () => removeMultiSelectedWatchlaterItems(recSharedEmitter), children: jsx$1(IconForDelete, {}) }) }),
jsx$1(CopyBvidButtonsTabbarView, {})
    ] });
  }
  const WatchlaterItemsOrderConfig = {
    [WatchlaterItemsOrder.AddTimeDesc]: {
      icon: jsx$1(IconForTimeDesc, {}),
      label: "最近添加",
      helpInfo: "按添加时间倒序"
    },
    [WatchlaterItemsOrder.AddTimeAsc]: {
      icon: jsx$1(IconForTimeAsc, {}),
      label: "最早添加",
      helpInfo: "按添加时间增序"
    },
    [WatchlaterItemsOrder.Shuffle]: {
      icon: jsx$1(IconForShuffle, {}),
      label: "随机顺序",
      helpInfo: `随机但不包括近期添加的稍后再看, 近期指: ${recentGateDescription}`
    }
  };
  const list = Object.values(WatchlaterItemsOrder);
  const extraHelpInfo = jsx$1("div", { className: "grid grid-cols-[repeat(2,max-content)] gap-x-1 gap-y-0 line-height-normal", children: list.map((x) => {
    const {
      icon,
      label,
      helpInfo
    } = WatchlaterItemsOrderConfig[x];
    return jsxs(Fragment, { children: [
jsxs("div", { className: "flex-center gap-x-1", children: [
        icon,
        label,
        ": "
      ] }),
jsx$1("div", { children: helpInfo })
    ] });
  }) });
  function WatchlaterOrderSwitcher() {
    const onRefresh = useOnRefresh();
    const {
      ref: ref2,
      getPopupContainer
    } = usePopupContainer();
    const {
      watchlaterItemsOrder
    } = useSettingsSnapshot();
    const {
      searchText
    } = useSnapshot(store$1);
    const disabled = !!searchText;
    return jsx$1(GenericOrderSwitcher, { disabled, value: disabled ? WatchlaterItemsOrder.AddTimeDesc : watchlaterItemsOrder, onChange: (next2) => {
      settings.watchlaterItemsOrder = next2;
      onRefresh();
    }, list, listDisplayConfig: WatchlaterItemsOrderConfig, $ref: ref2, dropdownProps: {
      getPopupContainer
    }, extraHelpInfo });
  }
  const watchlaterState = proxy({
    updatedAt: 0,
    bvidSet: proxySet()
  });
  function useWatchlaterState(bvid) {
    const set2 = useSnapshot(watchlaterState).bvidSet;
    return !!bvid && set2.has(bvid);
  }
  function replaceWatchlaterStateBvidSet(newSet) {
    watchlaterState.updatedAt = Date.now();
    watchlaterState.bvidSet = proxySet(newSet);
  }
  function updateWatchlaterStateBvidSet(action2, bvid) {
    if (!watchlaterState.updatedAt) return;
    watchlaterState.bvidSet.add(bvid);
  }
  async function initWatchlaterState() {
    if (!getHasLogined() || !getUid()) return;
    const {
      items: allWatchlaterItems = []
    } = await fetchWatchlaterItems();
    if (!allWatchlaterItems.length) return;
    replaceWatchlaterStateBvidSet(allWatchlaterItems.map((x) => x.bvid));
  }
  if (IN_BILIBILI_HOMEPAGE) {
    void (async () => {
      await whenIdle();
      await pRetry(initWatchlaterState, {
        retries: 3,
        onFailedAttempt(error) {
          appWarn(`Try updateWatchlaterState ${error.attemptNumber} failed. There are ${error.retriesLeft} retries left`);
        }
      });
    })();
  }
  async function removeMultiSelectedWatchlaterItems(recSharedEmitter) {
    const selected = getMultiSelectedItems().map((item) => ({
      item,
      cardData: normalizeCardData(item)
    })).filter((x) => x.cardData.avid).map((x) => [x.cardData.avid, x.item.uniqId, x.cardData.title]).filter(Boolean);
    const avids = selected.map((x) => x[0]);
    const uniqIds = selected.map((x) => x[1]);
    const titles = selected.map((x) => x[2]);
    if (!avids.length) {
      return toast("没有选中的视频");
    }
    const success = await batchRemoveWatchlater(avids);
    if (!success) return;
    recSharedEmitter.emit("remove-cards", [uniqIds, titles]);
  }
  class WatchlaterRecService extends BaseTabService {
    constructor(order, addSeparator, prevShuffleBvidIndexMap, searchText) {
      super(WatchlaterRecService.PAGE_SIZE);
      this.searchText = searchText;
      this.innerService = order === WatchlaterItemsOrder.Shuffle && !this.searchText ? new ShuffleOrderService(addSeparator, prevShuffleBvidIndexMap) : new NormalOrderService(order, addSeparator, this.searchText);
    }
    static PAGE_SIZE = 10;
    sidebarView = void 0;
    innerService;
    get hasMoreExceptQueue() {
      return this.innerService.hasMore;
    }
    fetchMore(abortSignal) {
      return this.innerService.loadMore(abortSignal);
    }
    get tabbarView() {
      return jsx$1(WatchlaterTabbarView, { service: this });
    }
    get state() {
      return this.innerService.state;
    }
decreaseTotal() {
      if (this.innerService.state.total === void 0) return;
      this.innerService.state.total--;
    }
    getServiceSnapshot() {
      const bvidIndexMap = this.innerService instanceof ShuffleOrderService ? this.innerService.currentBvidIndexMap : void 0;
      return {
        bvidIndexMap
      };
    }
  }
  function extendItem(item) {
    return {
      ...item,
      api: EApiType.Watchlater,
      uniqId: `${EApiType.Watchlater}:${item.bvid}`
    };
  }
  function showApiRequestError(err) {
    toast(`获取稍后再看失败: ${err}`);
    throw new Error(`获取稍后再看失败: ${err}`, {
      cause: err
    });
  }
  class ShuffleOrderService {
    constructor(addSeparator, prevBvidIndexMap) {
      this.addSeparator = addSeparator;
      if (prevBvidIndexMap?.size) {
        this.keepOrder = true;
        this.prevBvidIndexMap = prevBvidIndexMap;
      } else {
        this.keepOrder = false;
      }
    }
    hasMore = true;
    state = proxy({
      total: void 0
    });
keepOrder;
    prevBvidIndexMap;
    async loadMore(abortSignal) {
      if (!this.hasMore) return;
      const items = await this.fetch(abortSignal);
      this.hasMore = false;
      return items;
    }
    currentBvidIndexMap;
    async fetch(abortSignal) {
      const {
        items: rawItems = [],
        err
      } = await fetchWatchlaterItems({
        asc: false,
        searchText: void 0,
        abortSignal
      });
      if (err !== void 0) {
        showApiRequestError(err);
      }
      replaceWatchlaterStateBvidSet(rawItems.map((x) => x.bvid).filter(Boolean));
      const items = rawItems.map(extendItem);
      const recentGate = getRecentGate();
      const firstNotRecentIndex = items.findIndex((item) => item.add_at < recentGate);
      let itemsWithSeparator = items;
      if (firstNotRecentIndex !== -1) {
        const recent = items.slice(0, firstNotRecentIndex);
        let earlier = items.slice(firstNotRecentIndex);
        if (this.keepOrder && this.prevBvidIndexMap?.size) {
          earlier = orderBy(earlier, [(item) => {
            return this.prevBvidIndexMap?.get(item.bvid) ?? -1;
          }], ["asc"]);
        } else {
          earlier = shuffle(earlier);
        }
        itemsWithSeparator = [!!recent.length && this.addSeparator && recentSeparator, ...recent, !!earlier.length && this.addSeparator && earlierSeparator, ...earlier].filter(Boolean);
      }
      this.state.total = rawItems.length;
      this.currentBvidIndexMap = new Map(itemsWithSeparator.filter((x) => x.api !== EApiType.Separator).map((x, index) => [x.bvid, index]));
      return itemsWithSeparator;
    }
  }
  class NormalOrderService {
constructor(order, addSeparator, searchText) {
      this.order = order;
      this.addSeparator = addSeparator;
      this.searchText = searchText;
      if (!this.searchText) {
        invariant$1(order !== WatchlaterItemsOrder.Shuffle, "shuffle not supported in NormalOrderService");
      }
    }
    firstPageLoaded = false;
    state = proxy({
      total: void 0
    });
    hasMore = true;
    page = 1;
    async loadMore() {
      if (!this.hasMore) return;
      const result = await fetchWatchlaterItems({
        asc: this.order === WatchlaterItemsOrder.AddTimeAsc,
        searchText: this.searchText,
        extraParams: {
          need_split: "true",
          ps: 20,
          pn: this.page
        }
      });
      if (result.err !== void 0) {
        this.hasMore = false;
        showApiRequestError(result.err);
        return;
      }
      const {
        items,
        total
      } = result;
      const maxPage = Math.ceil(total / 20);
      this.firstPageLoaded = true;
      this.state.total = result.total;
      this.hasMore = this.page < maxPage;
      this.page++;
      items.forEach((item) => {
        if (item.bvid) {
          updateWatchlaterStateBvidSet("add", item.bvid);
        }
      });
      const extendedItems = items.map(extendItem);
      return this.insertSeparator(extendedItems);
    }
    recentSeparatorInserted = false;
    earlierSeparatorInserted = false;
    insertSeparator(items) {
      if (!this.addSeparator) return items;
      let newItems = [...items];
      const recentGate = getRecentGate();
      const needEarlierSeparator = items.some((item) => item.add_at < recentGate);
      const needRecentSeparator = items.some((item) => item.add_at >= recentGate);
      if (this.order === WatchlaterItemsOrder.AddTimeAsc) {
        if (!this.earlierSeparatorInserted && needEarlierSeparator) {
          newItems = [earlierSeparator, ...newItems];
          this.earlierSeparatorInserted = true;
        }
        if (!this.recentSeparatorInserted && needRecentSeparator) {
          const idx = newItems.findIndex((item) => item.api === EApiType.Watchlater && item.add_at >= recentGate);
          newItems = [...newItems.slice(0, idx), recentSeparator, ...newItems.slice(idx)];
          this.recentSeparatorInserted = true;
        }
      } else {
        if (!this.recentSeparatorInserted && needRecentSeparator) {
          newItems = [recentSeparator, ...items];
          this.recentSeparatorInserted = true;
        }
        if (!this.earlierSeparatorInserted && needEarlierSeparator) {
          const idx = newItems.findIndex((item) => item.api === EApiType.Watchlater && item.add_at < recentGate);
          newItems = [...newItems.slice(0, idx), earlierSeparator, ...newItems.slice(idx)];
          this.earlierSeparatorInserted = true;
        }
      }
      return newItems;
    }
  }
  function getAppRecServiceConfig() {
    const snap = getSettingsSnapshot().appRecommend;
    return {
      addOtherTabContents: snap.addOtherTabContents
    };
  }
  const appRecShowContentFromOtherTabEl = (refresh) => jsx$1(CheckboxSettingItem, { configPath: "appRecommend.addOtherTabContents", label: "显示来自其他 Tab 的内容", tooltip: jsxs(Fragment, { children: [
    "显示来自其他 Tab 的内容 ",
jsx$1("br", {}),
    "如动态 / 收藏 / 稍后再看 ",
jsx$1("br", {}),
    "但是: 刷新时间会更长"
  ] }), extraAction: async () => {
    await delay$1(100);
    refresh?.();
  } });
  function AppRecTabbarView() {
    const onRefresh = useOnRefresh();
    const {
      hidingTabKeys
    } = useSettingsSnapshot();
    const showLikedEntry = hidingTabKeys.includes(ETab.Liked);
    return jsxs("div", { className: "flex items-center gap-x-10px", children: [
      appRecShowContentFromOtherTabEl(onRefresh),
      showLikedEntry && jsx$1(AntdTooltip, { title: "查看「我」点赞的视频", children: jsx$1("a", { href: `/?${GateQueryKey.Tab}=${ETab.Liked}`, target: "_blank", children: jsx$1(IconForLike, { className: "size-18px align-top" }) }) })
    ] });
  }
  class AppRecService extends BaseTabService {
    constructor(config) {
      super(AppRecService.PAGE_SIZE);
      this.config = config;
      this.innerService = new AppRecInnerService();
      this.allServices = [this.innerService];
      this.initOtherTabServices();
    }
    static PAGE_SIZE = 20;
    tabbarView = jsx$1(AppRecTabbarView, {});
    sidebarView = void 0;
    innerService;
    allServices = [];
    otherTabServices = [];
    initOtherTabServices() {
      if (!getHasLogined()) return;
      if (!this.config.addOtherTabContents) return;
      let dynamicFeedService;
      let favService;
      let watchlaterService;
      {
        const store2 = createDfStore();
        store2.upMid = void 0;
        store2.selectedGroupId = void 0;
        const config = getDynamicFeedServiceConfig(store2);
        Object.assign(config, {
          showLiveInDynamicFeed: true,
          whenViewAllEnableHideSomeContents: false,
          filterCacheEnabled: false
        });
        dynamicFeedService = new DynamicFeedRecService(config);
      }
      {
        const config = Object.assign(getFavServiceConfig(), {
          selectedKey: "all",
          viewingAll: true,
          viewingSomeFolder: false,
          viewingSomeCollection: false,
          itemsOrder: FavItemsOrder.Shuffle,
          selectedFavFolderId: void 0,
          selectedFavCollectionId: void 0,
          addSeparator: false
        });
        favService = new FavRecService(config);
      }
      {
        watchlaterService = new WatchlaterRecService(WatchlaterItemsOrder.AddTimeDesc, false);
      }
      this.otherTabServices = [dynamicFeedService, favService, watchlaterService];
      const allServices = [];
      const rate = 7 / 3;
      allServices.push(...this.otherTabServices);
      times(Math.round(rate * this.otherTabServices.length), () => allServices.push(this.innerService));
      this.allServices = shuffle(allServices);
    }
    get hasMore() {
      return !!this.qs.bufferQueue.length || this.innerService.hasMore || this.otherTabServices.some((s2) => s2.hasMore);
    }
    hasMoreExceptQueue = true;
    fetchMore(abortSignal) {
      return this.config.addOtherTabContents ? this._fetchWithOtherTabsChecked(abortSignal) : this._fetchFromApi(abortSignal, 2);
    }
    async _fetchWithOtherTabsChecked(abortSignal) {
      let items = [];
      while (this.hasMore && items.length < AppRecService.PAGE_SIZE * 3) {
        const restServices = this.allServices.filter((s2) => s2.hasMore);
        if (!restServices.length) break;
        const pickedServices = shuffle(restServices).slice(0, 3);
        const more = (await Promise.all(pickedServices.map(async (s2) => await s2.loadMore(abortSignal) || []))).flat().filter((x) => x.api !== EApiType.Separator);
        items.push(...more);
        items = shuffle(items);
      }
      return items;
    }
    _fetchFromApi(abortSignal, times2) {
      return this.innerService.getRecommendTimes(abortSignal, times2);
    }
async preloadTimesFromApiIfNeeded(abortSignal, times2) {
      if (this.qs.bufferQueue.length < AppRecService.PAGE_SIZE) {
        this.qs.bufferQueue.push(...await this._fetchFromApi(abortSignal, times2));
      }
    }
  }
  class AppRecInnerService {
static PAGE_SIZE = 16;
    hasMore = true;
    async getRecommend() {
      const res = await gmrequest.get(`${HOST_APP}/x/v2/feed/index`, {
        timeout: 2e4,
        responseType: "json",
        params: {
          build: "1",
          mobi_app: "iphone",
          device: "pad",
idx: Math.floor(Date.now() / 1e3) + randomInt(1e3)
        }
      });
      const json = res.data;
      if (!json.data) {
        throw new Error("Request fail with none invalid json", {
          cause: {
            type: "invalid-json",
            statusCode: res.status,
            json
          }
        });
      }
      const items = json?.data?.items || [];
      return items;
    }
    loadMore(abortSignal, times2 = 2) {
      return this.getRecommendTimes(abortSignal, times2);
    }
async getRecommendTimes(abortSignal, times2) {
      let list2 = (await Promise.all(range$1(times2).map(() => this.getRecommend()))).flat();
      list2 = list2.filter((item) => {
        if (item.card_goto?.includes("ad")) return false;
        if (item.goto?.includes("ad")) return false;
        if (item.ad_info) return false;
        if (item.card_goto === "banner") return false;
        if (item.goto === "av" && item.player_args === void 0) return false;
        return true;
      });
      list2 = uniqBy(list2, (item) => item.param);
      const extendedList = list2.map((item) => {
        return {
          ...item,
          api: EApiType.AppRecommend,
          uniqId: `${EApiType.AppRecommend}:${item.param}`
        };
      });
      return extendedList;
    }
  }
  async function fetchAppRecommendFollowedPubDate(item, cardData) {
    const {
      bvid,
      goto,
      recommendReason
    } = cardData;
    const isNormalVideo = goto === "av";
    const shouldFetch = isAppRecommend(item) && isNormalVideo && !!bvid && getFollowedStatus$1(recommendReason);
    if (!shouldFetch) return;
    const detail = await getVideoDetail(bvid);
    const ts = detail?.pubdate;
    return ts;
  }
  async function fetchMyLikedVideos(ps = 20, pn = 1) {
    const uid = getUid();
    const res = await gmrequest.get(`https://app.bilibili.com/x/v2/space/likearc?mid=${uid}`, {
      responseType: "json",
      params: {
        ...appApiCommonParams,
        vmid: uid,
        ps,
        pn
      }
    });
    const json = res.data;
    return json;
  }
  function LikedTabbarView({
    service
  }) {
    const {
      count
    } = service.useStore();
    if (!Number.isFinite(count)) return null;
    return jsxs(Fragment, { children: [
jsx$1(AntdTooltip, { title: `共 ${count} 个视频`, children: jsx$1(Tag, { color: "success", variant: "outlined", className: "cursor-pointer", children: count }) }),
jsx$1(CopyBvidButtonsTabbarView, {})
    ] });
  }
  class LikedRecService extends BaseTabService {
    static PAGE_SIZE = 20;
    constructor() {
      super(LikedRecService.PAGE_SIZE);
    }
    tabbarView = jsx$1(LikedTabbarView, { service: this });
    sidebarView;
    get hasMoreExceptQueue() {
      if (this.errorJson) return false;
      return LikedRecService.PAGE_SIZE * this.pn < this.store.count;
    }
    pn = 0;
    errorJson = void 0;
    store = proxy({
      count: Infinity
    });
    useStore = () => {
      return useSnapshot(this.store);
    };
    showErrorNotification(payload) {
      antNotification.error({
        key: "LikedRecService:error",
        title: "获取喜欢列表失败",
        ...payload
      });
    }
    async fetchMore(abortSignal) {
      if (!settings.accessKey) throw new NeedValidAccessKeyError();
      antNotification.destroy("LikedRecService:error");
      const json = await fetchMyLikedVideos(this.qs.ps, this.pn + 1);
      if (!isWebApiSuccess(json)) {
        this.errorJson = json;
        this.showErrorNotification({
          title: "获取喜欢列表失败",
          description: json.message
        });
        throw new Error("Request fail with none invalid json", {
          cause: json
        });
      }
      const {
        count,
        item: list2
      } = json.data;
      const [_2, detailList] = await attemptAsync(() => (
Promise.all(list2.map((x) => x.state ? getVideoDetail(av2bv(x.param)) : void 0))
      ));
      const extendedList = list2.map((item, index) => {
        return {
          ...item,
          api: EApiType.Liked,
          uniqId: `${EApiType.Liked}:${item.param}`,
          videoDetail: detailList?.[index]
        };
      });
      this.pn++;
      this.store.count = count;
      return extendedList;
    }
  }
  const debug$7 = baseDebug.extend("modules:rec-services:pc");
  class PcRecService extends BaseTabService {
    constructor(isKeepFollowOnly) {
      super(PcRecService.PAGE_SIZE);
      this.isKeepFollowOnly = isKeepFollowOnly;
    }
    static PAGE_SIZE = 30;
tabbarView = void 0;
    sidebarView = void 0;
    hasMoreExceptQueue = true;
    fetchMore(abortSignal) {
      const times2 = this.isKeepFollowOnly ? 5 : 2;
      return this.getRecommendTimes(abortSignal, times2);
    }
async preloadTimesFromApiIfNeeded(abortSignal, times2) {
      if (this.qs.bufferQueue.length < PcRecService.PAGE_SIZE) {
        this.qs.bufferQueue.push(...await this.getRecommendTimes(abortSignal, times2));
      }
    }
async preloadPcInitialRecItems(abortSignal) {
      const initialItems = await getWebInitialRecommendItems(abortSignal);
      this.qs.bufferQueue.push(...initialItems);
    }
    getRecommendTimes = async (abortSignal, times2) => {
      const list2 = (await Promise.all(range$1(times2).map(() => this.getRecommend(abortSignal)))).flat();
      return processRawList(list2);
    };
    page = 0;
    getRecommend = async (abortSignal) => {
      const curpage = ++this.page;
      const url2 = "/x/web-interface/wbi/index/top/feed/rcmd";
      const params = {
        fresh_type: 8,
fresh_idx_1h: curpage,
        fresh_idx: curpage,
        ps: PcRecService.PAGE_SIZE,
        web_location: 1430650,
        feed_version: "V8",
        homepage_ver: 1
      };
      const res = await request.get(url2, {
        signal: abortSignal,
        params
      });
      const json = res.data;
      if (!isWebApiSuccess(json) && json.code === -62011 && json.message === "暂时没有更多内容了") {
        this.hasMoreExceptQueue = false;
        return [];
      }
      if (!json.data?.item) {
        toast(json.message || "API 请求没有返回结果");
      }
      const items = json.data?.item || [];
      return items;
    };
  }
  function processRawList(list2) {
    const knownGotoSet = new Set([PcRecGoto.AV, PcRecGoto.Live, PcRecGoto.Ad]);
    list2.forEach((item) => {
      if (!knownGotoSet.has(item.goto)) {
        debug$7("uknown goto from API: %s %o", item.goto, item);
      }
    });
    const allowedGotoSet = new Set([PcRecGoto.AV]);
    list2 = list2.filter((item) => allowedGotoSet.has(item.goto));
    list2 = uniqBy(list2, (item) => item.id);
    list2.forEach((item) => {
      if (item.rcmd_reason?.reason_type === 1) {
        item.rcmd_reason.content ||= "已关注";
      }
    });
    const _list = list2.map((item) => {
      return {
        ...item,
        uniqId: `${EApiType.PcRecommend}:${item.bvid || item.room_info?.room_id || crypto.randomUUID()}`,
        api: EApiType.PcRecommend
      };
    });
    return _list;
  }
  async function getWebInitialRecommendItems(abortSignal) {
    const __pinia = await poll$1(() => {
      const [_22, ret] = attempt(() => unsafeWindow.__pinia);
      return ret;
    }, {
      interval: 100,
      timeout: 1e3,
      abortSignal
    });
    const rawList = __pinia?.feed?.data?.recommend?.item || [];
    debug$7("initial rec rawList: %o", rawList);
    const [_2, list2] = attempt(() => {
      const list22 = processRawList(rawList);
      list22.forEach((item) => normalizeCardData(item));
      return list22;
    });
    return list2 || [];
  }
  const REC_TABS = [ETab.KeepFollowOnly, ETab.PcRecommend, ETab.AppRecommend];
  function isRecTab(tab2) {
    return REC_TABS.includes(tab2);
  }
  const createServiceMap = {
    [ETab.AppRecommend]: () => new AppRecService(getAppRecServiceConfig()),
    [ETab.PcRecommend]: () => new PcRecService(false),
    [ETab.KeepFollowOnly]: () => new PcRecService(true),
    [ETab.DynamicFeed]: () => new DynamicFeedRecService(getDynamicFeedServiceConfig()),
    [ETab.Watchlater]: ({
      existingService
    }) => {
      const {
        watchlaterAddSeparator,
        watchlaterItemsOrder
      } = settings;
      const prevShuffleBvidIndexMap = existingService && existingService instanceof WatchlaterRecService ? existingService.getServiceSnapshot().bvidIndexMap : void 0;
      return new WatchlaterRecService(watchlaterItemsOrder, watchlaterAddSeparator, prevShuffleBvidIndexMap, snapshot(store$1).searchText);
    },
    [ETab.Fav]: () => new FavRecService(getFavServiceConfig()),
    [ETab.Hot]: () => new HotRecService(),
    [ETab.Live]: () => new LiveRecService(),
    [ETab.SpaceUpload]: () => new SpaceUploadService(getSpaceUploadServiceConfig()),
    [ETab.Liked]: () => new LikedRecService()
  };
  function getServiceFromRegistry(serviceRegistry, tab2) {
    const service = serviceRegistry[tab2];
    invariant$1(service, `serviceRegistry[tab=${tab2}] should not be nil`);
    return service;
  }
  const defaultRecSharedEmitter = new Emittery();
  class RecSelf {
    constructor(insideModal) {
      this.insideModal = insideModal;
    }
    recSharedEmitter = new Emittery();
    serviceRegistry = {};
    serviceQueueMap = {};
store = proxy({
      refreshing: false,
      refreshingTab: void 0,
      tabbarView: void 0,
      sidebarView: void 0,
      serviceQueueStateMap: {}
    });
    get refreshing() {
      return this.store.refreshing;
    }
    get refreshingTab() {
      return this.store.refreshingTab;
    }
    useStore = () => {
      return useSnapshot(this.store);
    };
    setStore = (payload) => {
      const wrapRefKeys = ["tabbarView", "sidebarView"];
      for (const key of wrapRefKeys) {
        const v = payload[key];
        if (typeof v === "object" && v !== null) {
          payload[key] = ref(v);
        }
      }
      Object.assign(this.store, payload);
    };
    useTabServiceQueueState = (tab2) => {
      return useSnapshot(this.store.serviceQueueStateMap)[tab2];
    };
    getTabServiceQueueState = (tab2) => {
      return snapshot(this.store.serviceQueueStateMap)[tab2];
    };
    setTabServiceQueueState = (tab2, state2) => {
      this.store.serviceQueueStateMap[tab2] = state2;
    };
    _calcTabBackForwardStatus = (tab2, state2) => {
      if (!isRecTab(tab2) || !state2 || state2.len <= 1) return [false, false];
      const {
        len,
        cursor: cursor2
      } = state2;
      return [cursor2 > 0, cursor2 < len - 1];
    };
    getTabBackForwardStatus = (tab2) => {
      return this._calcTabBackForwardStatus(tab2, this.getTabServiceQueueState(tab2));
    };
    useTabBackForwardStatus = (tab2) => {
      const state2 = this.useTabServiceQueueState(tab2);
      return reactExports.useMemo(() => this._calcTabBackForwardStatus(tab2, state2), [tab2, state2]);
    };
  }
  const RecSelfContext = reactExports.createContext(new RecSelf());
  function useInitRecSelf(...args) {
    return useCreation(() => new RecSelf(...args), []);
  }
  function useRecSelfContext() {
    return reactExports.useContext(RecSelfContext);
  }
  function useOnRefresh() {
    const {
      recSharedEmitter
    } = useRecSelfContext();
    return useLockFn((refreshType) => recSharedEmitter.emit("refresh", refreshType));
  }
  const clsIconSize = "size-16px";
  const FavItemsOrderConfig = {
    [FavItemsOrder.Initial]: {
      icon: jsx$1(IconForDefaultOrder, { className: clsIconSize }),
      label: "初始顺序"
    },
    [FavItemsOrder.Shuffle]: {
      icon: jsx$1(IconForShuffle, { className: clsIconSize }),
      label: "随机顺序"
    },
    [FavItemsOrder.PubTimeDesc]: {
      icon: jsx$1(IconForTimeDesc, { className: clsIconSize }),
      label: "最新投稿"
    },
    [FavItemsOrder.PubTimeAsc]: {
      icon: jsx$1(IconForTimeAsc, { className: clsIconSize }),
      label: "最早投稿"
    },
    [FavItemsOrder.PlayCountDesc]: {
      icon: jsx$1(IconForPlayer, { className: clsIconSize }),
      label: "最多播放"
    },
    [FavItemsOrder.CollectCountDesc]: {
      icon: jsx$1(IconForFav, { className: clsx(clsIconSize) }),
      label: "最多收藏"
    },
    [FavItemsOrder.FavTimeDesc]: {
      icon: jsx$1(IconForTimeDesc, { className: clsx(clsIconSize) }),
      label: "最近收藏"
    },
    [FavItemsOrder.FavTimeAsc]: {
      icon: jsx$1(IconForTimeAsc, { className: clsx(clsIconSize) }),
      label: "最早收藏"
    }
  };
  const MenuItemsConfig = {
    "all": [FavItemsOrder.Initial, FavItemsOrder.Shuffle],
    "fav-folder": [FavItemsOrder.FavTimeDesc, FavItemsOrder.PubTimeDesc, FavItemsOrder.PlayCountDesc, FavItemsOrder.CollectCountDesc, "divider", FavItemsOrder.FavTimeAsc, FavItemsOrder.PubTimeAsc, "divider", FavItemsOrder.Shuffle],
    "fav-collection": [FavItemsOrder.Initial, FavItemsOrder.PubTimeDesc, FavItemsOrder.PlayCountDesc, FavItemsOrder.CollectCountDesc, "divider", FavItemsOrder.PubTimeAsc, "divider", FavItemsOrder.Shuffle]
  };
  function _getSelectedKeyPrefix(selectedKey) {
    const prefix2 = selectedKey.split(":")[0];
    return prefix2;
  }
  function getMenuItemsFor(selectedKey) {
    const prefix2 = _getSelectedKeyPrefix(selectedKey);
    return MenuItemsConfig[prefix2] || Object.values(FavItemsOrder);
  }
  function _getFallbackOrder(selectedKey) {
    const prefix2 = _getSelectedKeyPrefix(selectedKey);
    if (prefix2 === "fav-folder") return FavItemsOrder.FavTimeDesc;
    if (prefix2 === "fav-collection") return FavItemsOrder.PubTimeDesc;
    return FavItemsOrder.Initial;
  }
  function getSavedOrder(selectedKey, savedOrderMap) {
    const allowed = getMenuItemsFor(selectedKey).filter((x) => x !== "divider");
    const current = savedOrderMap.get(selectedKey) || _getFallbackOrder(selectedKey);
    if (allowed.includes(current)) return current;
    return _getFallbackOrder(selectedKey);
  }
  function useSavedOrder(selectedKey, savedOrderMap) {
    return reactExports.useMemo(() => getSavedOrder(selectedKey, savedOrderMap), [savedOrderMap, selectedKey]);
  }
  function FavItemsOrderSwitcher() {
    const onRefresh = useOnRefresh();
    const {
      ref: popupRef,
      getPopupContainer
    } = usePopupContainer();
    const {
      selectedKey,
      savedOrderMap
    } = useSnapshot(favStore);
    const value = useSavedOrder(selectedKey, savedOrderMap);
    const menuItems = reactExports.useMemo(() => getMenuItemsFor(selectedKey), [selectedKey]);
    return jsx$1(GenericOrderSwitcher, { value, onChange: async (next2) => {
      favStore.savedOrderMap.set(selectedKey, next2);
      await delay$1(100);
      onRefresh();
    }, list: menuItems, listDisplayConfig: FavItemsOrderConfig, $ref: popupRef, dropdownProps: {
      getPopupContainer
    } });
  }
  const debug$6 = baseDebug.extend("modules:rec-services:fav:store");
  var FavQueryKey = ((FavQueryKey2) => {
    FavQueryKey2["CollectionIdFull"] = "fav-collection-id";
    FavQueryKey2["CollectionId"] = "fav-cid";
    FavQueryKey2["FolderIdFull"] = "fav-folder-id";
    FavQueryKey2["FolderId"] = "fav-fid";
    return FavQueryKey2;
  })(FavQueryKey || {});
  const parseId = (text) => {
    if (!text) return;
    const num = Number(text);
    if (Number.isNaN(num)) return;
    return num;
  };
  const searchParams = new URLSearchParams(location.search);
  const QUERY_FAV_COLLECTION_ID = parseId(searchParams.get(
    "fav-collection-id"
) ?? searchParams.get(
    "fav-cid"
));
  const QUERY_FAV_FOLDER_ID = parseId(searchParams.get(
    "fav-folder-id"
) ?? searchParams.get(
    "fav-fid"
));
  const SHOW_FAV_TAB_ONLY = IN_BILIBILI_HOMEPAGE && (typeof QUERY_FAV_FOLDER_ID === "number" || typeof QUERY_FAV_COLLECTION_ID === "number");
  const favStore = proxy({
    folders: [],
    foldersUpdateAt: 0,
    selectedFavFolderId: QUERY_FAV_FOLDER_ID,
    get selectedFavFolder() {
      if (typeof this.selectedFavFolderId !== "number") return;
      return this.folders.find((x) => x.id === this.selectedFavFolderId);
    },
    collections: [],
    collectionsUpdateAt: 0,
    selectedFavCollectionId: QUERY_FAV_COLLECTION_ID,
    selectedFavCollectionDetailInfo: void 0,
    get selectedFavCollection() {
      if (typeof this.selectedFavCollectionId !== "number") return;
      return this.collections.find((x) => x.id === this.selectedFavCollectionId);
    },
    get selectedKey() {
      let prefix2;
      let id2;
      if (this.selectedFavFolderId !== void 0) {
        prefix2 = "fav-folder";
        id2 = this.selectedFavFolderId;
      } else if (this.selectedFavCollectionId !== void 0) {
        prefix2 = "fav-collection";
        id2 = this.selectedFavCollectionId;
      } else {
        return "all";
      }
      return `${prefix2}:${id2}`;
    },
    get selectedLabel() {
      if (this.selectedFavFolder) {
        return `${this.selectedFavFolder.title} (${this.selectedFavFolder.media_count})`;
      }
      if (typeof this.selectedFavCollectionId === "number") {
        if (this.selectedFavCollection) {
          return `${this.selectedFavCollection.title} (${this.selectedFavCollection.media_count})`;
        }
        const info = this.selectedFavCollectionDetailInfo;
        if (info?.id === this.selectedFavCollectionId) {
          return `${info.title} (${info.media_count})`;
        }
        return;
      }
      return "全部";
    },
savedOrderMap: (await( proxyMapWithGmStorage("fav-saved-order"))).map,
    get usingShuffle() {
      const curret = getSavedOrder(this.selectedKey, this.savedOrderMap);
      return curret === FavItemsOrder.Shuffle;
    },
    get viewingAll() {
      return this.selectedKey === "all";
    },
    get viewingSomeFolder() {
      return typeof this.selectedFavFolderId === "number";
    },
    get viewingSomeCollection() {
      return typeof this.selectedFavCollectionId === "number";
    }
  });
  function updateFavFolderMediaCount(targetFavFolderId, count) {
    const folder = favStore.folders.find((x) => x.id === targetFavFolderId);
    if (!folder) return;
    const newCount = typeof count === "function" ? count(folder.media_count) : count;
    if (newCount === folder.media_count) return;
    folder.media_count = newCount;
    debug$6("update folder(id=%s title=%s) media_count to %s", folder.id, folder.title, newCount);
  }
  function updateFavList(force = false) {
    return Promise.all([updateFavFolderList(force), updateFavCollectionList(force)]);
  }
  const _updateFavFolderList = reusePendingPromise(async () => {
    const folders = await fetchAllFavFolders();
    favStore.folders = folders;
    favStore.foldersUpdateAt = Date.now();
  });
  async function updateFavFolderList(force = false) {
    if (!force) {
      const {
        folders,
        foldersUpdateAt
      } = favStore;
      const cacheValid = folders.length && foldersUpdateAt && Date.now() - foldersUpdateAt < ms("5min");
      if (cacheValid) return;
    }
    return _updateFavFolderList();
  }
  const _updateFavCollectionList = reusePendingPromise(async () => {
    const collections = await fetchAllFavCollections();
    favStore.collections = collections;
    favStore.collectionsUpdateAt = Date.now();
  });
  async function updateFavCollectionList(force = false) {
    if (!force) {
      const {
        collections,
        collectionsUpdateAt
      } = favStore;
      const cacheValid = collections.length && collectionsUpdateAt && Date.now() - collectionsUpdateAt < ms("5min");
      if (cacheValid) return;
    }
    return _updateFavCollectionList();
  }
  if (SHOW_FAV_TAB_ONLY) {
    subscribeKey(favStore, "selectedLabel", () => {
      if (!favStore.selectedLabel) return;
      setPageTitle(favStore.selectedLabel);
    });
  }
  setupFavStore();
  async function setupFavStore() {
    if (!(IN_BILIBILI_HOMEPAGE || IN_BILIBILI_VIDEO_PLAY_PAGE)) return;
    if (SHOW_FAV_TAB_ONLY) return;
    const storageKey2 = "fav-store";
    const persistStoreKeys = ["selectedFavFolderId", "selectedFavCollectionId", "folders"];
    const val = await GM.getValue(storageKey2);
    if (val) {
      for (const key of persistStoreKeys) {
        if (!isNil(val[key])) {
          favStore[key] = val[key];
        }
      }
    }
    const runInSequence = pLimit(1);
    subscribeOnKeys(favStore, persistStoreKeys, (snap) => {
      if (SHOW_FAV_TAB_ONLY) return;
      const val2 = pick(snap, persistStoreKeys);
      runInSequence(async () => {
        await GM.setValue(storageKey2, val2);
      });
    });
  }
  const TabConfig = {
    [ETab.AppRecommend]: {
      icon: jsx$1(IconForPhone, { className: "size-18px" }),
      label: "推荐",
      desc: "使用 Bilibili App 端推荐 API",
      anonymousUsage: true
    },
    [ETab.PcRecommend]: {
      icon: jsx$1(IconForPc, { className: "size-18px" }),
      label: "推荐",
      desc: "使用新版首页顶部推荐 API",
      anonymousUsage: true
    },
    [ETab.KeepFollowOnly]: {
      icon: jsx$1(IconForFollowedOnly, { className: "size-18px" }),
      label: "已关注",
      desc: "从PC端推荐中筛选出「已关注」,可能比较慢; 关注的UP更新在动态~"
    },
    [ETab.DynamicFeed]: {
      icon: jsx$1(IconForDynamicFeed, { className: "size-18px" }),
      label: "动态",
      desc: "视频投稿动态",
      swr: true
    },
    [ETab.Watchlater]: {
      icon: (

jsx$1(IconForWatchlater, { className: "size-17px [&_.circle]:stroke-current" })
      ),
      label: "稍后再看",
      desc: "「我」的稍后再看",
      swr: true
    },
    [ETab.Fav]: {
      icon: jsx$1(IconForFav, { className: "mt--1px size-16px" }),
      label: "收藏",
      desc: "「我」的收藏",
      get swr() {
        return !favStore.usingShuffle;
      }
    },
    [ETab.Hot]: {
      icon: jsx$1(IconForHot, { className: "size-16px" }),
      label: "热门",
      desc: "各个领域中新奇好玩的优质内容都在这里~",
      anonymousUsage: true,
      get swr() {
        return !isHotTabUsingShuffle();
      }
    },
    [ETab.Live]: {
      icon: jsx$1(IconForLive, { className: "size-16px" }),
      label: "直播",
      desc: "直播~",
      swr: true
    },
    [ETab.SpaceUpload]: {
      icon: jsx$1(IconForSpaceUpload, { className: "size-16px" }),
      label: "投稿",
      desc: "UP 视频投稿",
      anonymousUsage: true,
extraHelpInfo: jsxs("div", { className: "ml-20px", children: [
        "搜索词: 搜索相关作品 ",
jsx$1("br", {}),
        "本地过滤词: 本地过滤搜索结果; 本地过滤词支持高级规则:",
jsx$1("div", { className: "ml-20px", children: advancedFilterHelpInfo })
      ] })
    },
    [ETab.Liked]: {
      icon: jsx$1(IconForLike, { className: "size-16px" }),
      label: "赞",
      desc: "「我」的点赞. 使用 App 端个人空间 API, 需要 access_key"
    }
  };
  function TabIcon({
    tabKey,
    active,
    className
  }) {
    const {
      icon
    } = TabConfig[tabKey];
    const iconProps = icon.props;
    const newProps = {
      ...iconProps,
      className: r(iconProps.className, className),
      active: tabKey === ETab.Live ? active : void 0
};
    const cloned = reactExports.cloneElement(icon, newProps);
    return cloned;
  }
  const NEED_LOGIN_MESSAGE = "你需要登录B站后使用该功能! 如已完成登录, 请刷新网页重试~";
  function toastNeedLogin() {
    return toast(NEED_LOGIN_MESSAGE);
  }
  const iconParkOutlineHelp = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", children: [
jsx$1("path", { stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, d: "M24 44a19.94 19.94 0 0 0 14.142-5.858A19.94 19.94 0 0 0 44 24a19.94 19.94 0 0 0-5.858-14.142A19.94 19.94 0 0 0 24 4A19.94 19.94 0 0 0 9.858 9.858A19.94 19.94 0 0 0 4 24a19.94 19.94 0 0 0 5.858 14.142A19.94 19.94 0 0 0 24 44Z" }),
jsx$1("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "M24 28.625v-4a6 6 0 1 0-6-6" }),
jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M24 37.625a2.5 2.5 0 1 0 0-5a2.5 2.5 0 0 0 0 5", clipRule: "evenodd" })
    ] })
  ] });
  const ForwardRef$h = reactExports.forwardRef(iconParkOutlineHelp);
  const tablerEyeSearch = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsx$1("path", { d: "M10 12a2 2 0 1 0 4 0a2 2 0 0 0-4 0" }),
jsx$1("path", { d: "M12 18q-.492 0-.97-.05Q6.271 17.452 3 12q3.6-6 9-6q5.197 0 8.727 5.558M15 18a3 3 0 1 0 6 0a3 3 0 1 0-6 0m5.2 2.2L22 22" })
    ] })
  ] });
  const ForwardRef$g = reactExports.forwardRef(tablerEyeSearch);
  function TabPaneBasic() {
    const {
      grid: {
        useCustomGrid,
        enableForceColumn,
        forceColumnCount,
        cardMinWidth
      },
      style: style2,
      enableSidebar,
      sidebarAlign
    } = useSettingsSnapshot();
    useMount(() => {
      return subscribeKey(settings, "pureRecommend", async (v) => {
        await delay$1(0);
        toastAndReload();
      });
    });
    const handleCopyScriptVersion = useMemoizedFn(() => {
      const content = `v${"0.34.13"}`;
      GM.setClipboard(content);
      antMessage.success(`已复制当前版本: ${content}`);
    });
    const peekIconRef = reactExports.useRef(null);
    const peekIconHovering = useHover(peekIconRef);
    return jsxs("div", { className: sharedClassNames.tabPane, children: [
jsx$1(SettingsGroup, { title: jsxs(Fragment, { children: [
jsx$1(TabIcon, { tabKey: ETab.AppRecommend, className: "mr-5px mt-2px size-30px" }),
        "access_key",
jsxs(HelpInfo, { className: "ml-5px mt-6px size-18px", IconComponent: ForwardRef$h, tooltipProps: {
          classNames: {
            root: "text-14px"
          }
        }, children: [
          "App 端登录凭证, 使用情况: ",
jsx$1("br", {}),
jsx$1(TooltipContentDivider, {}),
jsxs("div", { className: "group flex items-start", children: [
jsxs("div", { className: "w-55px flex flex-none items-center", children: [
jsx$1(TabIcon, { tabKey: ETab.AppRecommend, className: "mr-1" }),
              " 推荐"
            ] }),
jsxs("ul", { className: "flex-1 list-disc pl-20px", children: [
jsx$1("li", { className: "w-max", children: "获取推荐" }),
jsx$1("li", { className: "w-max", children: "提交不喜欢" })
            ] })
          ] }),
jsx$1(TooltipContentDivider, {}),
jsxs("div", { className: "group flex items-start", children: [
jsxs("div", { className: "w-55px flex flex-none items-center", children: [
jsx$1(TabIcon, { tabKey: ETab.Liked, className: "mr-1" }),
              "赞"
            ] }),
jsx$1("ul", { className: "w-max flex-1 list-disc pl-20px", children: jsx$1("li", { className: "w-max", children: "获取点赞列表" }) })
          ] })
        ] })
      ] }), children: jsx$1(AccessKeyManage, {}) }),
jsx$1(SettingsGroup, { title: "开关", resetSettingPaths: ["pureRecommend", "multiSelect.showIcon", "showBackForwardButtons"], children: jsxs("div", { className: sharedClassNames.settingsLine, children: [
jsx$1(CheckboxSettingItem, { configPath: "pureRecommend", label: "覆盖默认推荐", tooltip: jsxs(Fragment, { children: [
          explainForFlag("覆盖默认推荐内容", `保留默认首页; 你可以从屏幕边缘找到入口面板, 使用 ${APP_NAME} 的功能.`),
          "P.S 需要刷新网页"
        ] }) }),
jsx$1(CheckboxSettingItem, { configPath: "multiSelect.showIcon", label: "「多选」按钮", tooltip: "是否显示「多选」按钮" }),
jsx$1(CheckboxSettingItem, { configPath: "showBackForwardButtons", label: "「后退 / 前进」按钮", tooltip: "是否显示「后退 / 前进」按钮" })
      ] }) }),
jsxs(SettingsGroup, { title: jsxs(Fragment, { children: [
        "布局",
jsx$1(AntdTooltip, { title: "透视", children: jsx$1(ForwardRef$g, { ref: peekIconRef, title: "透视", className: clsx("ml-1.5 size-1em cursor-pointer b-1px b-transparent rounded-md b-solid p-2px hover:b-gate-primary", {
          peeking: peekIconHovering
        }) }) })
      ] }), resetSettingPaths: ["grid.useCustomGrid", "grid.cardMinWidth", "grid.enableForceColumn", "grid.forceColumnCount", "enableSidebar", "sidebarAlign", "grid.gridDisplayMode", "grid.twoColumnModeAlign"], children: [
jsxs("div", { className: sharedClassNames.settingsLine, children: [
jsx$1(CheckboxSettingItem, { configPath: "grid.useCustomGrid", label: "使用自定义网格配置", tooltip: jsxs(Fragment, { children: [
            "网格配置指: 网格宽度, 间距, 列数等. ",
jsx$1("br", {}),
            explainForFlag( jsxs(Fragment, { children: [
              "使用 ",
              APP_NAME,
              " 自定义网格配置: 宽度为90%; 可跟随 Bilibili-Evolved 自定义顶栏配置"
            ] }), jsx$1(Fragment, { children: "使用 bili-feed4 版本B站首页默认的网格配置" }))
          ] }) }),
jsxs("div", { className: "flex items-center gap-x-1 px-6px", children: [
jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
              "如果期望显示更多的列, 可以调小这个值; ",
jsx$1("br", {}),
              "如果期望显示更少的列, 可以调大这个值; ",
jsx$1("br", {}),
              "手动设置列数时, 这个值不起作用. ",
jsx$1("br", {}),
jsx$1(CustomKbd, { children: "Alt / Opt" }),
              " + ",
jsx$1(CustomKbd, { children: "上下键" }),
              "可调整"
            ] }), children: jsx$1("span", { className: "cursor-pointer", children: "视频卡片最小宽度" }) }),
jsx$1(TypedInputNumber, { disabled: !useCustomGrid || enableForceColumn, value: cardMinWidth, onChange: (val) => {
              if (val) settings.grid.cardMinWidth = val;
            }, min: 150, max: 450, step: 10, size: "small", className: "w-75px" })
          ] }),
jsxs("div", { className: "flex items-center px-6px", children: [
jsx$1(CheckboxSettingItem, { disabled: !useCustomGrid, configPath: "grid.enableForceColumn", label: "手动设置列数", tooltip: jsx$1(Fragment, { children: "手动设置列数" }) }),
            useCustomGrid && enableForceColumn && jsx$1(TypedInputNumber, { value: forceColumnCount, onChange: (val) => {
              if (val) {
                settings.grid.forceColumnCount = val;
              }
            }, min: 0, max: 10, step: 1, size: "small", className: "w-50px" })
          ] })
        ] }),
jsxs("div", { className: "flex items-center gap-x-4px", children: [
jsx$1(CheckboxSettingItem, { configPath: "enableSidebar", label: "使用侧边栏", tooltip: explainForFlag("使用侧边栏(如动态 分组/UP 选择)", "使用下拉面板") }),
jsxs(Radio.Group, { disabled: !enableSidebar, buttonStyle: "solid", size: "small", value: sidebarAlign, onChange: (e) => void (settings.sidebarAlign = e.target.value), children: [
jsx$1(Radio.Button, { value: ESidebarAlign.Left, className: "inline-flex-center", children: jsx$1(ForwardRef$J, { className: "size-16px" }) }),
jsx$1(Radio.Button, { value: ESidebarAlign.Right, className: "inline-flex-center", children: jsx$1(ForwardRef$H, { className: "size-16px" }) })
          ] })
        ] }),
jsxs("div", { className: "flex items-center", children: [
          "网格显示模式",
jsx$1(GridDisplayModeSwitcher, { className: "ml-xl" })
        ] })
      ] }),
jsxs(SettingsGroup, { title: "样式", resetSettingPaths: ["style.general.popoverBorderColorUseColorPrimary", "style.pureRecommend.useStickyTabbar", "style.pureRecommend.stickyTabbarShadow", "grid.useCustomGrid", "style.pureRecommend.useWhiteBackground", "style.pureRecommend.hideTopChannel"], children: [
jsx$1("div", { className: sharedClassNames.settingsLine, children: jsx$1(CheckboxSettingItem, { configPath: "style.general.popoverBorderColorUseColorPrimary", label: "下拉面板使用主题色边框" }) }),
jsxs("div", { children: [
jsx$1("div", { className: "flex items-center text-1.2em", children: "全屏推荐" }),
jsxs("div", { className: sharedClassNames.settingsLine, children: [
jsx$1(CheckboxSettingItem, { configPath: "style.pureRecommend.useStickyTabbar", label: "固定 Tab 栏", tooltip: explainForFlag("Tab 栏会吸附在顶栏下方", "Tab 栏会随页面一起滚动") }),
jsx$1(CheckboxSettingItem, { disabled: !style2.pureRecommend.useStickyTabbar, configPath: "style.pureRecommend.stickyTabbarShadow", label: "固定 Tab 栏时添加边框 & 阴影", tooltip: explainForFlag("Tab 栏在吸附状态下: 加宽, 添加边框 & 阴影", "不改变") }),
jsx$1(CheckboxSettingItem, { configPath: "style.pureRecommend.useWhiteBackground", label: "使用纯白背景", tooltip: jsxs(Fragment, { children: [
              explainForFlag("纯白背景", "浅灰色背景"),
              "仅影响白色/浅色模式"
            ] }) }),
jsx$1(CheckboxSettingItem, { configPath: "style.pureRecommend.hideTopChannel", label: "隐藏顶部分区和Banner" })
          ] })
        ] })
      ] }),
jsx$1(SettingsGroup, { title: jsxs(Fragment, { children: [
        "帮助",
jsxs("span", { className: "relative top-4px ml-8px mr-4px inline-flex items-center text-size-14px", children: [
          "当前版本",
jsxs(Tag, { color: "green", className: "mx-4px cursor-pointer", onClick: handleCopyScriptVersion, children: [
            APP_NAME,
            " v",
            "0.34.13"
          ] }),
jsx$1(IconForCopy, { className: "size-16px cursor-pointer", onClick: handleCopyScriptVersion })
        ] })
      ] }), children: jsxs("div", { className: sharedClassNames.settingsLine, children: [
jsx$1(AntdTooltip, { title: "来个 Star 支持一下", children: jsx$1(Button$1, { href: "https://github.com/magicdawn/Bilibili-Gate", target: "_blank", children: "GitHub 主页" }) }),
jsx$1(Button$1, { href: "https://afdian.com/a/magicdawn", target: "_blank", children: "「爱发电」支持" }),
jsx$1(Button$1, { href: "https://greasyfork.org/zh-CN/scripts/443530-bilibili-gate", target: "_blank", children: "GreasyFork 主页" }),
jsx$1(Button$1, { href: "https://github.com/magicdawn/Bilibili-Gate/#%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AF%B4%E6%98%8E", target: "_blank", children: "查看可用的快捷键" }),
jsx$1(Button$1, { href: "https://github.com/magicdawn/Bilibili-Gate/releases", target: "_blank", children: "更新日志" })
      ] }) })
    ] });
  }
  function exportFilterByAuthor() {
    return _exportForPath("filter.byAuthor.keywords");
  }
  function importFilterByAuthor() {
    return _importForPath("filter.byAuthor.keywords");
  }
  function exportFilterByTitle() {
    return _exportForPath("filter.byTitle.keywords");
  }
  function importFilterByTitle() {
    return _importForPath("filter.byTitle.keywords");
  }
  function exportDfFilterByTitle() {
    return _exportForPath("filter.dfByTitle.keywords");
  }
  function importDfFilterByTitle() {
    return _importForPath("filter.dfByTitle.keywords");
  }
  function exportDfHideOpusMids() {
    return _exportForPath("filter.dfHideOpusMids.keywords");
  }
  function importDfHideOpusMids() {
    return _importForPath("filter.dfHideOpusMids.keywords");
  }
  function getJsonKey(p2) {
    return `__${APP_NAME}:${p2}__`;
  }
  async function _exportForPath(listSettingsPath) {
    const key = getJsonKey(listSettingsPath);
    const val = await getNewestValueOfSettingsInnerArray(listSettingsPath);
    if (!val?.length) return antMessage.error("没有可导出数据!");
    GM.setClipboard(JSON.stringify({
      [key]: val
    }, null, 2));
    antMessage.success("已复制到剪贴板!");
  }
  async function _importForPath(listSettingsPath) {
    const [errClip, text] = await attemptAsync(() => navigator.clipboard.readText());
    if (errClip) return antMessage.error("读取剪贴板失败!");
    if (!text) return antMessage.error("剪贴板内容为空!");
    const [errJson, json] = attempt(() => JSON.parse(text));
    if (errJson) return antMessage.error("无法解析剪贴板内容!");
    if (!json) return antMessage.error("剪贴板内容为空!");
    const key = getJsonKey(listSettingsPath);
    const val = json?.[key];
    if (!val?.length) return antMessage.error("没有符合条件的数据!");
    const currentList = await getNewestValueOfSettingsInnerArray(listSettingsPath);
    const toAdd = difference(val, currentList);
    if (!toAdd.length) return antMessage.warning("没有可导入内容, 已全部存在!");
    updateSettingsInnerArray(listSettingsPath, {
      add: toAdd
    });
    antMessage.success(`已导入 ${toAdd.length} 条数据!`);
  }
  const iconParkOutlineCloseSmall = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "m14 14l20 20m-20 0l20-20" })
  ] });
  const ForwardRef$f = reactExports.forwardRef(iconParkOutlineCloseSmall);
  const {
    Search
  } = Input;
  var _ref$3 = {
    name: "1mzc5hv",
    styles: "color:var(--ant-color-text-disabled);background-color:var(--ant-color-bg-container-disabled);box-shadow:none;opacity:1;pointer-events:none;cursor:not-allowed"
  };
  function EditableListSettingItem({
    configPath,
    searchProps,
    disabled,
    className,
    inputClassName,
    listClassName,
    renderHeader = identity
  }) {
    const rawList = useSettingsInnerArray(configPath);
    const list2 = reactExports.useMemo(() => uniq(rawList).toReversed(), [rawList]);
    const isUpRepresent = ["filter.byAuthor.keywords", "filter.dfHideOpusMids.keywords"].includes(configPath);
    const input = jsx$1(Search, { className: clsx("my-5px", inputClassName), enterButton: "添加", allowClear: true, disabled, size: "middle", ...searchProps, onSearch: async (val, e) => {
      if (!val) return;
      const set2 = new Set(await getNewestValueOfSettingsInnerArray(configPath));
      if (set2.has(val)) {
        antMessage.warning(`${val} 已存在`);
        return;
      }
      await updateSettingsInnerArray(configPath, {
        add: [val]
      });
      if (e?.target) {
        const el = e.target;
        const clearBtn = el.closest(".ant-input-wrapper")?.querySelector(".ant-input-clear-icon");
        clearBtn?.click();
      }
    } });
    const hasData = !!list2.length;
    const isEmpty2 = !hasData;
    const _listClassName = r(isEmpty2 ? "rounded-lg" : ["max-h-250px flex flex-wrap items-start gap-x-10px gap-y-5px overflow-y-auto pr-10px", listClassName]);
    const listEl = jsxs("div", { className: _listClassName, css: disabled && _ref$3, children: [
      isEmpty2 && jsx$1(Empty, { image: Empty.PRESENTED_IMAGE_SIMPLE, description: "空空如也", className: "[&.ant-empty-normal]:my-1 [&.ant-empty-normal]:py-5px" }),
      hasData && list2.map((t2) => {
        return jsx$1(TagItemDisplay, { tag: t2.toString(), TagComponent: isUpRepresent ? UpTagItemDisplay : void 0, onDelete: (tag) => updateSettingsInnerArray(configPath, {
          remove: [tag]
        }) }, t2);
      })
    ] });
    return jsxs(Fragment, { children: [
      renderHeader(input),
      listEl
    ] });
  }
  const TagItemDisplay = reactExports.memo(function({
    tag,
    renderTag,
    TagComponent,
    onDelete,
    className,
    ...restProps
  }) {
    const tagEl = reactExports.useMemo(() => {
      if (TagComponent) return jsx$1(TagComponent, { tag });
      renderTag ??= identity;
      return renderTag(tag);
    }, [TagComponent, renderTag, tag]);
    return jsxs("div", { ...restProps, className: clsx("relative inline-flex items-center b-1px b-gate-border rounded-5px b-solid px-6px py-2px hover:b-gate-primary hover:color-gate-primary", className), children: [
      tagEl,
jsx$1(ForwardRef$f, { className: "ml-2px size-16px cursor-pointer text-size-12px", onClick: () => onDelete?.(tag) })
    ] });
  });
  const UpTagItemDisplay = reactExports.memo(function({
    tag
  }) {
    const {
      mid,
      remark
    } = reactExports.useMemo(() => parseUpRepresent(tag), [tag]);
    const [nicknameByMid, setNicknameByMid] = reactExports.useState(void 0);
    reactExports.useEffect(() => {
      void (async () => {
        if (!mid) return;
        const nickname = await getUserNickname(mid);
        if (nickname) setNicknameByMid(nickname);
      })();
    }, [mid]);
    const label = mid ? (
nicknameByMid || remark || mid
    ) : tag;
    const tooltip = jsxs(Fragment, { children: [
      !!mid && jsxs(Fragment, { children: [
        "mid: ",
        mid,
        " ",
jsx$1("br", {})
      ] }),
      !!remark && jsxs(Fragment, { children: [
        "备注: ",
        remark,
        " ",
jsx$1("br", {}),
        remark === nicknameByMid && jsxs(Fragment, { children: [
          'P.S "备注" 与 "用户昵称" 相同, 是之前的数据, 现在你只需要填写 mid, 会自动获取昵称 ',
jsx$1("br", {})
        ] })
      ] }),
      !mid && jsxs(Fragment, { children: [
        "使用用户名过滤: 用户可能改名, 建议使用 mid 过滤 ",
jsx$1("br", {})
      ] })
    ] });
    return jsx$1(Fragment, { children: jsx$1(AntdTooltip, { title: tooltip, children: jsxs("span", { className: clsx("inline-flex items-center justify-center", mid ? "cursor-pointer" : "cursor-[edit]"), children: [
      mid && jsx$1(ForwardRef$y, { className: "mr-2px size-12px" }),
      mid ? jsx$1("a", { href: formatSpaceUrl(mid), target: "_blank", style: {
        color: "inherit"
      }, children: label }) : label
    ] }) }) });
  });
  const C$1 = {
    blockContainer: "b-1px b-gate-border rounded-lg b-solid p-x-2 p-y-1 light:hover:b-gate-primary"
  };
  function TabPaneFilter() {
    return jsx$1("div", { className: clsx(sharedClassNames.tabPane, "pr-15px"), children: jsx$1(SettingsGroup, { title: jsxs(Fragment, { children: [
      "内容过滤",
jsx$1(SwitchSettingItem, { configPath: "filter.enabled", className: "ml-10px" })
    ] }), children: jsx$1(Tabs, { items: [{
      key: "recommend",
      label: jsxs("span", { className: "inline-flex-center gap-x-1", children: [
jsx$1(TabIcon, { tabKey: ETab.AppRecommend }),
        "推荐 / 热门",
jsxs(HelpInfo, { className: "ml-1", children: [
          "生效范围: ",
jsx$1("br", {}),
          "视频/图文/影视: 推荐类 Tab ",
jsx$1("br", {}),
          "UP/标题: 推荐类、热门 Tab ",
jsx$1("br", {})
        ] })
      ] }),
      children: jsx$1(SubTabFilterForRec, {})
    }, {
      key: "dynamic-feed",
      label: jsxs("span", { className: "inline-flex-center gap-x-1", children: [
jsx$1(TabIcon, { tabKey: ETab.DynamicFeed }),
        "动态",
jsxs(HelpInfo, { className: "ml-1", children: [
          "使用场景: 关注的 UP 发布的部分内容 ",
jsx$1("br", {}),
jsxs("ol", { children: [
jsx$1("li", { children: "如果有规律可以按标题关键字过滤" }),
jsx$1("li", { children: "没有规律可以屏蔽 UP 发布的全部图文动态" })
          ] })
        ] })
      ] }),
      children: jsx$1(SubTabFilterForDynamicFeed, {})
    }] }) }) });
  }
  function SubTabFilterForRec() {
    const {
      enabled: enabled2,
      minDuration,
      minPlayCount,
      minDanmakuCount,
      hideGotoTypeBangumi,
      hideGotoTypePicture,
      byAuthor,
      byTitle
    } = useSettingsSnapshot().filter;
    const getExemptFollowedTooltipProps = (label) => {
      return {
        label: "「已关注」豁免",
        tooltipProps: {
          color: TOOLTIP_BLACK_BG_COLOR
        },
        tooltip: jsxs(Fragment, { children: [
          "「已关注」内容不考虑过滤条件, 总是展示",
jsx$1("br", {}),
          '"豁免" 一词来源',
          " ",
jsx$1("a", { target: "_blank", href: "https://github.com/magicdawn/Bilibili-Gate/issues/1#issuecomment-2197868587", children: "pilipala" })
        ] })
      };
    };
    return jsx$1(Fragment, { children: jsxs("div", { className: "grid grid-cols-2 gap-15px", children: [
jsxs("div", { children: [
jsx$1("div", { className: sharedClassNames.settingsGroupSubTitle, children: "视频" }),
jsxs("div", { className: "flex flex-col gap-y-1", children: [
jsxs("div", { className: "flex items-center", children: [
jsx$1(CheckboxSettingItem, { configPath: "filter.minDuration.enabled", label: "按视频时长过滤", tooltip: jsx$1(Fragment, { children: "不显示短视频" }), disabled: !enabled2, className: "min-w-130px" }),
jsxs(Space.Compact, { children: [
jsx$1(TypedInputNumber, { className: "w-130px", size: "small", min: 1, step: 10, value: minDuration.value, onChange: (val) => !isNil(val) && (settings.filter.minDuration.value = val), disabled: !enabled2 || !minDuration.enabled }),
jsx$1(Space.Addon, { children: "秒" })
            ] })
          ] }),
jsxs("div", { className: "flex items-center", children: [
jsx$1(CheckboxSettingItem, { disabled: !enabled2, configPath: "filter.minPlayCount.enabled", label: "按播放次数过滤", tooltip: jsx$1(Fragment, { children: "不显示播放次数很少的视频" }), className: "min-w-130px" }),
jsxs(Space.Compact, { children: [
jsx$1(TypedInputNumber, { className: "w-130px", size: "small", min: 1, step: 1e3, value: minPlayCount.value, onChange: (val) => !isNil(val) && (settings.filter.minPlayCount.value = val), disabled: !enabled2 || !minPlayCount.enabled }),
jsx$1(Space.Addon, { children: "次" })
            ] })
          ] }),
jsxs("div", { className: "flex items-center", children: [
jsx$1(CheckboxSettingItem, { disabled: !enabled2, configPath: "filter.minDanmakuCount.enabled", label: "按弹幕条数过滤", tooltip: jsx$1(Fragment, { children: "不显示弹幕条数很少的视频" }), className: "min-w-130px" }),
jsxs(Space.Compact, { children: [
jsx$1(TypedInputNumber, { className: "w-130px", size: "small", min: 1, step: 100, value: minDanmakuCount.value, onChange: (val) => !isNil(val) && (settings.filter.minDanmakuCount.value = val), disabled: !enabled2 || !minDanmakuCount.enabled }),
jsx$1(Space.Addon, { children: "条" })
            ] })
          ] }),
jsx$1(CheckboxSettingItem, { configPath: "filter.exemptForFollowed.video", disabled: !enabled2, ...getExemptFollowedTooltipProps() })
        ] })
      ] }),
jsxs("div", { children: [
jsx$1("div", { className: sharedClassNames.settingsGroupSubTitle, children: "图文" }),
jsx$1(CheckboxSettingItem, { configPath: "filter.hideGotoTypePicture", label: "过滤图文类型推荐", disabled: !enabled2, className: "flex", tooltip: jsxs(Fragment, { children: [
          "过滤 ",
jsx$1("kbd", { children: "goto = picture" }),
          " 的内容: 包括 (动态 & 专栏) 等"
        ] }) }),
jsx$1(CheckboxSettingItem, { className: "flex", disabled: !enabled2 || !hideGotoTypePicture, configPath: "filter.exemptForFollowed.picture", ...getExemptFollowedTooltipProps() }),
jsx$1("div", { className: clsx(sharedClassNames.settingsGroupSubTitle, "mt-2"), children: "影视" }),
jsx$1(CheckboxSettingItem, { configPath: "filter.hideGotoTypeBangumi", label: "过滤影视类型推荐", tooltip: jsxs(Fragment, { children: [
          "过滤 ",
jsx$1("kbd", { children: "goto = bangumi" }),
          " 的内容: 包括 (番剧 / 电影 / 国创 / 纪录片) 等"
        ] }), disabled: !enabled2 })
      ] }),
jsxs("div", { className: clsx(C$1.blockContainer, "col-span-full"), children: [
jsxs("div", { className: sharedClassNames.settingsGroupSubTitle, children: [
          "UP",
jsxs(HelpInfo, { children: [
            "根据 UP 过滤视频 ",
jsx$1("br", {}),
            "使用 mid 屏蔽时支持备注, 格式: ",
jsx$1(Tag, { color: "success", children: "mid(备注)" }),
            " 如",
            " ",
jsx$1(Tag, { color: "success", children: "8047632(B站官方)" }),
jsx$1("br", {}),
jsxs("div", { className: "mt-4px flex items-start", children: [
jsx$1(IconForInfo, { className: "mt-3px" }),
jsxs("div", { className: "ml-8px flex-1", children: [
                "B站官方支持黑名单, 对于不喜欢的 UP 可以直接拉黑 ",
jsx$1("br", {}),
                "此脚本会拉取官方黑名单, 并无视此页开关, 总是会过滤掉 ",
jsx$1("br", {}),
                "这里是客户端过滤, 与黑名单功能重复, 优先使用黑名单功能 ",
jsx$1("br", {})
              ] })
            ] })
          ] }),
jsx$1(SwitchSettingItem, { configPath: "filter.byAuthor.enabled", disabled: !enabled2, className: "ml-10px" }),
jsx$1("div", { className: "flex-1" }),
jsx$1(Popover, { placement: "left", content: jsxs("div", { className: "flex flex-col gap-x-10px gap-y-5px", children: [
jsxs(Button$1, { onClick: clear_filterByAuthor_uselessRemarkData, children: [
jsx$1(IconForDelete, {}),
              "清理无效备注数据"
            ] }),
jsxs(Button$1, { onClick: exportFilterByAuthor, disabled: !byAuthor.keywords.length, children: [
jsx$1(ForwardRef$N, {}),
              "导出"
            ] }),
jsxs(Button$1, { onClick: importFilterByAuthor, children: [
jsx$1(ForwardRef$M, {}),
              "导入"
            ] })
          ] }), children: jsx$1(Button$1, { className: "icon-only-round-button size-26px", children: jsx$1(IconForPopoverTrigger, { className: "size-16px" }) }) })
        ] }),
jsx$1(EditableListSettingItem, { configPath: "filter.byAuthor.keywords", searchProps: {
          placeholder: "添加UP: 全名 / mid / mid(备注)"
        }, disabled: !enabled2 || !byAuthor.enabled, className: "mt-2", listClassName: "max-h-130px" })
      ] }),
jsxs("div", { className: clsx(C$1.blockContainer, "col-span-full"), children: [
jsxs("div", { className: clsx(sharedClassNames.settingsGroupSubTitle), children: [
jsx$1("span", { children: "标题" }),
jsxs(HelpInfo, { children: [
            "根据标题关键词过滤视频 ",
jsx$1("br", {}),
            "支持普通关键字和正则(i), 语法：",
jsx$1(Tag, { color: "success", variant: "solid", children: "/abc|\\d+/" })
          ] }),
jsx$1(SwitchSettingItem, { configPath: "filter.byTitle.enabled", disabled: !enabled2, className: "ml-10px" }),
jsx$1("div", { className: "flex-1" }),
jsx$1(Popover, { placement: "left", content: jsxs("div", { className: "flex flex-col gap-x-10px gap-y-5px", children: [
jsxs(Button$1, { onClick: exportFilterByTitle, disabled: !byTitle.keywords.length, children: [
jsx$1(ForwardRef$N, {}),
              "导出"
            ] }),
jsxs(Button$1, { onClick: importFilterByTitle, children: [
jsx$1(ForwardRef$M, {}),
              "导入"
            ] })
          ] }), children: jsx$1(Button$1, { className: "icon-only-round-button size-26px", children: jsx$1(IconForPopoverTrigger, { className: "size-16px" }) }) })
        ] }),
jsx$1(EditableListSettingItem, { configPath: "filter.byTitle.keywords", searchProps: {
          placeholder: "添加过滤关键词"
        }, disabled: !enabled2 || !byTitle.enabled, listClassName: "max-h-130px" })
      ] })
    ] }) });
  }
  function SubTabFilterForDynamicFeed() {
    const {
      filter: {
        enabled: enabled2,
        dfByTitle,
        dfHideOpusMids
      }
    } = useSettingsSnapshot();
    return jsxs("div", { className: "flex flex-col gap-y-15px", children: [
jsxs("div", { className: C$1.blockContainer, children: [
jsxs("div", { className: sharedClassNames.settingsGroupSubTitle, children: [
jsx$1("span", { children: "标题" }),
jsxs(HelpInfo, { children: [
            "支持普通关键字和正则(i), 语法：",
jsx$1(Tag, { color: "success", variant: "solid", children: "/abc|\\d+/" }),
jsx$1("br", {}),
            "作用范围: 支持的动态类型: 视频 / 图文"
          ] }),
jsx$1(SwitchSettingItem, { configPath: "filter.dfByTitle.enabled", disabled: !enabled2, className: "ml-10px" }),
jsx$1("div", { className: "flex-1" }),
jsx$1(Popover, { placement: "left", content: jsxs("div", { className: "flex flex-col gap-x-10px gap-y-5px", children: [
jsxs(Button$1, { onClick: exportDfFilterByTitle, disabled: !dfByTitle.keywords.length, children: [
jsx$1(ForwardRef$N, {}),
              "导出"
            ] }),
jsxs(Button$1, { onClick: importDfFilterByTitle, children: [
jsx$1(ForwardRef$M, {}),
              "导入"
            ] })
          ] }), children: jsx$1(Button$1, { className: "icon-only-round-button size-26px", children: jsx$1(IconForPopoverTrigger, { className: "size-16px" }) }) })
        ] }),
jsx$1(EditableListSettingItem, { configPath: "filter.dfByTitle.keywords", searchProps: {
          placeholder: "添加过滤关键词"
        }, disabled: !enabled2 || !dfByTitle.enabled })
      ] }),
jsxs("div", { className: C$1.blockContainer, children: [
jsxs("div", { className: sharedClassNames.settingsGroupSubTitle, children: [
jsx$1("span", { children: "屏蔽 UP 的图文动态" }),
jsxs(HelpInfo, { children: [
            "支持 mid 或 mid(备注) ",
jsx$1("br", {}),
            "右键图文动态可快速添加"
          ] }),
jsx$1(SwitchSettingItem, { configPath: "filter.dfHideOpusMids.enabled", disabled: !enabled2, className: "ml-10px" }),
jsx$1("div", { className: "flex-1" }),
jsx$1(Popover, { placement: "left", content: jsxs("div", { className: "flex flex-col gap-x-10px gap-y-5px", children: [
jsxs(Button$1, { onClick: exportDfHideOpusMids, disabled: !dfHideOpusMids.keywords.length, children: [
jsx$1(ForwardRef$N, {}),
              "导出"
            ] }),
jsxs(Button$1, { onClick: importDfHideOpusMids, children: [
jsx$1(ForwardRef$M, {}),
              "导入"
            ] })
          ] }), children: jsx$1(Button$1, { className: "icon-only-round-button size-26px", children: jsx$1(IconForPopoverTrigger, { className: "size-16px" }) }) })
        ] }),
jsx$1(EditableListSettingItem, { configPath: "filter.dfHideOpusMids.keywords", searchProps: {
          placeholder: "添加 UP: mid / mid(备注)"
        }, disabled: !enabled2 || !dfHideOpusMids.enabled, listClassName: "max-h-130px" })
      ] })
    ] });
  }
  async function clear_filterByAuthor_uselessRemarkData() {
    const list2 = settings.filter.byAuthor.keywords;
    const newList = await pmap(
      list2,
      async (item) => {
        const {
          mid,
          remark
        } = parseUpRepresent(item);
        if (!mid || !remark) return item;
        const nickname = await getUserNickname(mid);
        if (nickname !== remark) return item;
        return mid;
      },
      Infinity
);
    if (isEqual$2(newList, list2)) {
      return antMessage.warning("没有「无效备注」数据!");
    }
    settings.filter.byAuthor.keywords = newList;
    return antMessage.success("已清理「无效备注」数据!");
  }
  function TabPaneOtherPages() {
    return jsxs("div", { className: sharedClassNames.tabPane, children: [
jsx$1(SettingsGroup, { title: "视频播放页", children: jsx$1(CheckboxSettingItem, { configPath: "fav.useCustomFavPicker.onPlayPage", label: `使用自定义收藏弹窗`, tooltip: jsxs(Fragment, { children: [
        "使用「",
        APP_NAME,
        "」提供的选择收藏夹弹窗 ",
jsx$1("br", {}),
jsxs("ul", { className: "ml-20px list-circle", children: [
jsx$1("li", { children: "支持拼音搜索, 帮你快速找到收藏夹" }),
jsx$1("li", { children: jsxs("span", { className: "flex-v-center", children: [
            "支持从收藏夹图标 或 快捷键",
jsx$1("kbd", { className: clsx(kbdClassName, "mx-1 h-14px py-0 line-height-14px"), children: "e" }),
            "触发"
          ] }) })
        ] })
      ] }) }) }),
jsx$1(SettingsGroup, { title: "搜索页", children: jsx$1(CheckboxSettingItem, { configPath: "videoCard.videoPreview.addTo.searchPage", label: "浮动预览: 添加到「搜索页」", tooltip: jsx$1(Fragment, { children: "在搜索页的视频也添加「浮动预览」" }) }) })
    ] });
  }
  function restrictToBoundingRect(transform, rect, boundingRect) {
    const value = {
      ...transform
    };
    if (rect.top + transform.y <= boundingRect.top) {
      value.y = boundingRect.top - rect.top;
    } else if (rect.bottom + transform.y >= boundingRect.top + boundingRect.height) {
      value.y = boundingRect.top + boundingRect.height - rect.bottom;
    }
    if (rect.left + transform.x <= boundingRect.left) {
      value.x = boundingRect.left - rect.left;
    } else if (rect.right + transform.x >= boundingRect.left + boundingRect.width) {
      value.x = boundingRect.left + boundingRect.width - rect.right;
    }
    return value;
  }
  const restrictToParentElement = (_ref4) => {
    let {
      containerNodeRect,
      draggingNodeRect,
      transform
    } = _ref4;
    if (!draggingNodeRect || !containerNodeRect) {
      return transform;
    }
    return restrictToBoundingRect(transform, draggingNodeRect, containerNodeRect);
  };
  const restrictToVerticalAxis = (_ref4) => {
    let {
      transform
    } = _ref4;
    return {
      ...transform,
      x: 0
    };
  };
  function arrayMove(array4, from2, to) {
    const newArray = array4.slice();
    newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from2, 1)[0]);
    return newArray;
  }
  function getSortedRects(items, rects) {
    return items.reduce((accumulator, id2, index) => {
      const rect = rects.get(id2);
      if (rect) {
        accumulator[index] = rect;
      }
      return accumulator;
    }, Array(items.length));
  }
  function isValidIndex(index) {
    return index !== null && index >= 0;
  }
  function itemsEqual(a2, b) {
    if (a2 === b) {
      return true;
    }
    if (a2.length !== b.length) {
      return false;
    }
    for (let i2 = 0; i2 < a2.length; i2++) {
      if (a2[i2] !== b[i2]) {
        return false;
      }
    }
    return true;
  }
  function normalizeDisabled(disabled) {
    if (typeof disabled === "boolean") {
      return {
        draggable: disabled,
        droppable: disabled
      };
    }
    return disabled;
  }
  const rectSortingStrategy = (_ref4) => {
    let {
      rects,
      activeIndex,
      overIndex,
      index
    } = _ref4;
    const newRects = arrayMove(rects, overIndex, activeIndex);
    const oldRect = rects[index];
    const newRect = newRects[index];
    if (!newRect || !oldRect) {
      return null;
    }
    return {
      x: newRect.left - oldRect.left,
      y: newRect.top - oldRect.top,
      scaleX: newRect.width / oldRect.width,
      scaleY: newRect.height / oldRect.height
    };
  };
  const defaultScale$1 = {
    scaleX: 1,
    scaleY: 1
  };
  const verticalListSortingStrategy = (_ref4) => {
    var _rects$activeIndex;
    let {
      activeIndex,
      activeNodeRect: fallbackActiveRect,
      index,
      rects,
      overIndex
    } = _ref4;
    const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;
    if (!activeNodeRect) {
      return null;
    }
    if (index === activeIndex) {
      const overIndexRect = rects[overIndex];
      if (!overIndexRect) {
        return null;
      }
      return {
        x: 0,
        y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top,
        ...defaultScale$1
      };
    }
    const itemGap = getItemGap$1(rects, index, activeIndex);
    if (index > activeIndex && index <= overIndex) {
      return {
        x: 0,
        y: -activeNodeRect.height - itemGap,
        ...defaultScale$1
      };
    }
    if (index < activeIndex && index >= overIndex) {
      return {
        x: 0,
        y: activeNodeRect.height + itemGap,
        ...defaultScale$1
      };
    }
    return {
      x: 0,
      y: 0,
      ...defaultScale$1
    };
  };
  function getItemGap$1(clientRects, index, activeIndex) {
    const currentRect = clientRects[index];
    const previousRect = clientRects[index - 1];
    const nextRect = clientRects[index + 1];
    if (!currentRect) {
      return 0;
    }
    if (activeIndex < index) {
      return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;
    }
    return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;
  }
  const ID_PREFIX = "Sortable";
  const Context = React.createContext({
    activeIndex: -1,
    containerId: ID_PREFIX,
    disableTransforms: false,
    items: [],
    overIndex: -1,
    useDragOverlay: false,
    sortedRects: [],
    strategy: rectSortingStrategy,
    disabled: {
      draggable: false,
      droppable: false
    }
  });
  function SortableContext(_ref4) {
    let {
      children,
      id: id2,
      items: userDefinedItems,
      strategy = rectSortingStrategy,
      disabled: disabledProp = false
    } = _ref4;
    const {
      active,
      dragOverlay,
      droppableRects,
      over,
      measureDroppableContainers
    } = useDndContext();
    const containerId = useUniqueId(ID_PREFIX, id2);
    const useDragOverlay = Boolean(dragOverlay.rect !== null);
    const items = reactExports.useMemo(() => userDefinedItems.map((item) => typeof item === "object" && "id" in item ? item.id : item), [userDefinedItems]);
    const isDragging2 = active != null;
    const activeIndex = active ? items.indexOf(active.id) : -1;
    const overIndex = over ? items.indexOf(over.id) : -1;
    const previousItemsRef = reactExports.useRef(items);
    const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);
    const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;
    const disabled = normalizeDisabled(disabledProp);
    useIsomorphicLayoutEffect(() => {
      if (itemsHaveChanged && isDragging2) {
        measureDroppableContainers(items);
      }
    }, [itemsHaveChanged, items, isDragging2, measureDroppableContainers]);
    reactExports.useEffect(() => {
      previousItemsRef.current = items;
    }, [items]);
    const contextValue = reactExports.useMemo(
      () => ({
        activeIndex,
        containerId,
        disabled,
        disableTransforms,
        items,
        overIndex,
        useDragOverlay,
        sortedRects: getSortedRects(items, droppableRects),
        strategy
      }),
[activeIndex, containerId, disabled.draggable, disabled.droppable, disableTransforms, items, overIndex, droppableRects, useDragOverlay, strategy]
    );
    return React.createElement(Context.Provider, {
      value: contextValue
    }, children);
  }
  const defaultNewIndexGetter = (_ref4) => {
    let {
      id: id2,
      items,
      activeIndex,
      overIndex
    } = _ref4;
    return arrayMove(items, activeIndex, overIndex).indexOf(id2);
  };
  const defaultAnimateLayoutChanges = (_ref22) => {
    let {
      containerId,
      isSorting,
      wasDragging,
      index,
      items,
      newIndex,
      previousItems,
      previousContainerId,
      transition
    } = _ref22;
    if (!transition || !wasDragging) {
      return false;
    }
    if (previousItems !== items && index === newIndex) {
      return false;
    }
    if (isSorting) {
      return true;
    }
    return newIndex !== index && containerId === previousContainerId;
  };
  const defaultTransition = {
    duration: 200,
    easing: "ease"
  };
  const transitionProperty = "transform";
  const disabledTransition = CSS.Transition.toString({
    property: transitionProperty,
    duration: 0,
    easing: "linear"
  });
  const defaultAttributes = {
    roleDescription: "sortable"
  };
  function useDerivedTransform(_ref4) {
    let {
      disabled,
      index,
      node: node2,
      rect
    } = _ref4;
    const [derivedTransform, setDerivedtransform] = reactExports.useState(null);
    const previousIndex = reactExports.useRef(index);
    useIsomorphicLayoutEffect(() => {
      if (!disabled && index !== previousIndex.current && node2.current) {
        const initial = rect.current;
        if (initial) {
          const current = getClientRect(node2.current, {
            ignoreTransform: true
          });
          const delta = {
            x: initial.left - current.left,
            y: initial.top - current.top,
            scaleX: initial.width / current.width,
            scaleY: initial.height / current.height
          };
          if (delta.x || delta.y) {
            setDerivedtransform(delta);
          }
        }
      }
      if (index !== previousIndex.current) {
        previousIndex.current = index;
      }
    }, [disabled, index, node2, rect]);
    reactExports.useEffect(() => {
      if (derivedTransform) {
        setDerivedtransform(null);
      }
    }, [derivedTransform]);
    return derivedTransform;
  }
  function useSortable(_ref4) {
    let {
      animateLayoutChanges = defaultAnimateLayoutChanges,
      attributes: userDefinedAttributes,
      disabled: localDisabled,
      data: customData,
      getNewIndex = defaultNewIndexGetter,
      id: id2,
      strategy: localStrategy,
      resizeObserverConfig,
      transition = defaultTransition
    } = _ref4;
    const {
      items,
      containerId,
      activeIndex,
      disabled: globalDisabled,
      disableTransforms,
      sortedRects,
      overIndex,
      useDragOverlay,
      strategy: globalStrategy
    } = reactExports.useContext(Context);
    const disabled = normalizeLocalDisabled(localDisabled, globalDisabled);
    const index = items.indexOf(id2);
    const data2 = reactExports.useMemo(() => ({
      sortable: {
        containerId,
        index,
        items
      },
      ...customData
    }), [containerId, customData, index, items]);
    const itemsAfterCurrentSortable = reactExports.useMemo(() => items.slice(items.indexOf(id2)), [items, id2]);
    const {
      rect,
      node: node2,
      isOver,
      setNodeRef: setDroppableNodeRef
    } = useDroppable({
      id: id2,
      data: data2,
      disabled: disabled.droppable,
      resizeObserverConfig: {
        updateMeasurementsFor: itemsAfterCurrentSortable,
        ...resizeObserverConfig
      }
    });
    const {
      active,
      activatorEvent,
      activeNodeRect,
      attributes: attributes2,
      setNodeRef: setDraggableNodeRef,
      listeners: listeners2,
      isDragging: isDragging2,
      over,
      setActivatorNodeRef,
      transform
    } = useDraggable({
      id: id2,
      data: data2,
      attributes: {
        ...defaultAttributes,
        ...userDefinedAttributes
      },
      disabled: disabled.draggable
    });
    const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);
    const isSorting = Boolean(active);
    const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);
    const shouldDisplaceDragSource = !useDragOverlay && isDragging2;
    const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;
    const strategy = localStrategy != null ? localStrategy : globalStrategy;
    const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({
      rects: sortedRects,
      activeNodeRect,
      activeIndex,
      overIndex,
      index
    }) : null;
    const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({
      id: id2,
      items,
      activeIndex,
      overIndex
    }) : index;
    const activeId = active == null ? void 0 : active.id;
    const previous = reactExports.useRef({
      activeId,
      items,
      newIndex,
      containerId
    });
    const itemsHaveChanged = items !== previous.current.items;
    const shouldAnimateLayoutChanges = animateLayoutChanges({
      active,
      containerId,
      isDragging: isDragging2,
      isSorting,
      id: id2,
      index,
      items,
      newIndex: previous.current.newIndex,
      previousItems: previous.current.items,
      previousContainerId: previous.current.containerId,
      transition,
      wasDragging: previous.current.activeId != null
    });
    const derivedTransform = useDerivedTransform({
      disabled: !shouldAnimateLayoutChanges,
      index,
      node: node2,
      rect
    });
    reactExports.useEffect(() => {
      if (isSorting && previous.current.newIndex !== newIndex) {
        previous.current.newIndex = newIndex;
      }
      if (containerId !== previous.current.containerId) {
        previous.current.containerId = containerId;
      }
      if (items !== previous.current.items) {
        previous.current.items = items;
      }
    }, [isSorting, newIndex, containerId, items]);
    reactExports.useEffect(() => {
      if (activeId === previous.current.activeId) {
        return;
      }
      if (activeId != null && previous.current.activeId == null) {
        previous.current.activeId = activeId;
        return;
      }
      const timeoutId = setTimeout(() => {
        previous.current.activeId = activeId;
      }, 50);
      return () => clearTimeout(timeoutId);
    }, [activeId]);
    return {
      active,
      activeIndex,
      attributes: attributes2,
      data: data2,
      rect,
      index,
      newIndex,
      items,
      isOver,
      isSorting,
      isDragging: isDragging2,
      listeners: listeners2,
      node: node2,
      overIndex,
      over,
      setNodeRef,
      setActivatorNodeRef,
      setDroppableNodeRef,
      setDraggableNodeRef,
      transform: derivedTransform != null ? derivedTransform : finalTransform,
      transition: getTransition()
    };
    function getTransition() {
      if (
derivedTransform ||
itemsHaveChanged && previous.current.newIndex === index
      ) {
        return disabledTransition;
      }
      if (shouldDisplaceDragSource && !isKeyboardEvent(activatorEvent) || !transition) {
        return void 0;
      }
      if (isSorting || shouldAnimateLayoutChanges) {
        return CSS.Transition.toString({
          ...transition,
          property: transitionProperty
        });
      }
      return void 0;
    }
  }
  function normalizeLocalDisabled(localDisabled, globalDisabled) {
    var _localDisabled$dragga, _localDisabled$droppa;
    if (typeof localDisabled === "boolean") {
      return {
        draggable: localDisabled,
droppable: false
      };
    }
    return {
      draggable: (_localDisabled$dragga = localDisabled == null ? void 0 : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,
      droppable: (_localDisabled$droppa = localDisabled == null ? void 0 : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable
    };
  }
  [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];
  const videoSourceTabState = await( proxyWithGmStorage({
    value: ETab.AppRecommend
  }, `video-source-tab`));
  {
    const onlyTab = getOnlyTab();
    if (onlyTab) videoSourceTabState.value = onlyTab;
  }
  function getSortedTabKeys(customTabKeysOrder) {
    return CONFIGURABLE_TAB_KEYS.slice().sort((a2, b) => {
      let aIndex = customTabKeysOrder.indexOf(a2);
      let bIndex = customTabKeysOrder.indexOf(b);
      if (aIndex === -1) aIndex = ALL_TAB_KEYS.indexOf(a2);
      if (bIndex === -1) bIndex = ALL_TAB_KEYS.indexOf(b);
      return aIndex - bIndex;
    });
  }
  function useSortedTabKeys(options) {
    const {
      customTabKeysOrder
    } = useSettingsSnapshot(options);
    return reactExports.useMemo(() => getSortedTabKeys(customTabKeysOrder), [customTabKeysOrder]);
  }
  function useCurrentDisplayingTabKeys() {
    const {
      hidingTabKeys,
      customTabKeysOrder
    } = useSettingsSnapshot();
    const logined = useHasLogined();
    const onlyTab = reactExports.useMemo(getOnlyTab, []);
    const keys2 = reactExports.useMemo(() => {
      const tabkeys = getSortedTabKeys(customTabKeysOrder);
      return tabkeys.filter((key) => {
        if (key === ETab.AppRecommend && !logined) return true;
        return !hidingTabKeys.includes(key);
      });
    }, [hidingTabKeys, customTabKeysOrder, logined]);
    if (onlyTab) return [onlyTab];
    return keys2;
  }
  function useCurrentDisplayingTabConfigList() {
    const keys2 = useCurrentDisplayingTabKeys();
    return reactExports.useMemo(() => keys2.map((key) => ({
      key,
      ...TabConfig[key]
    })), [keys2]);
  }
  function useCurrentUsingTab() {
    const tab2 = useSnapshot(videoSourceTabState).value;
    const displayTabKeys = useCurrentDisplayingTabKeys();
    const logined = useHasLogined();
    const fallbackTab = ETab.AppRecommend;
    if (!displayTabKeys.includes(tab2)) return fallbackTab;
    if (!logined &&
!TabConfig[tab2].anonymousUsage) {
      return fallbackTab;
    }
    return tab2;
  }
  function useDeferredTab() {
    const tab2 = reactExports.useDeferredValue(useCurrentUsingTab());
    const prevTab = usePrevious$1(tab2);
    const tabOrders = useSortedTabKeys();
    const direction = reactExports.useMemo(() => {
      return prevTab ? tabOrders.indexOf(tab2) > tabOrders.indexOf(prevTab) ? "right" : "left" : void 0;
    }, [tabOrders, tab2]);
    return {
      tab: tab2,
      prevTab,
      direction
    };
  }
  const radioBtnCss = {
    name: "18r7nz9",
    styles: "height:32px;line-height:unset;--ant-border-radius:16px;&:has(:focus-visible){outline:none;outline-offset:unset;}>.ant-radio-button+span{height:100%;}"
  };
  function VideoSourceTab({
    className
  }) {
    const logined = useHasLogined();
    const tab2 = useCurrentUsingTab();
    const currentTabConfigList = useCurrentDisplayingTabConfigList();
    const {
      __internalRecTabRenderAsSegments
    } = useSettingsSnapshot();
    const onChangeTab = useMemoizedFn((newTab) => {
      if (!logined && !TabConfig[newTab].anonymousUsage && !checkLoginStatus()) {
        return toastNeedLogin();
      }
      videoSourceTabState.value = newTab;
    });
    const renderAsRadio = jsx$1(Radio.Group, { optionType: "button", buttonStyle: "solid", size: "middle", value: tab2, className: clsx("inline-flex items-center", className), onFocus: (e) => {
      const target = e.target;
      target.blur();
    }, onChange: (e) => {
      const newValue = e.target.value;
      onChangeTab(newValue);
    }, children: currentTabConfigList.map(({
      key,
      label
    }) => jsx$1(
      Radio.Button,
      {
        css: radioBtnCss,
        className: "video-source-tab",
        tabIndex: -1,
        value: key,
        children: jsxs("span", { className: "h-full flex items-center line-height-unset", children: [
jsx$1(TabIcon, { tabKey: key, className: "mr-4px", active: key === tab2 }),
          label
        ] })
      },
      key
    )) });
    let renderAsSegment;
    {
      const options = reactExports.useMemo(() => {
        return currentTabConfigList.map(({
          key,
          label
        }) => {
          return {
            value: key,
            label: jsxs("div", { className: "flex items-center gap-x-6px", children: [
jsx$1(TabIcon, { tabKey: key, active: key === tab2 }),
              label
            ] })
          };
        });
      }, [currentTabConfigList, tab2]);
      renderAsSegment = jsx$1(Segmented, { size: "middle", options, value: tab2, onChange: onChangeTab });
    }
    return jsxs("div", { className: "flex-v-center", children: [
      __internalRecTabRenderAsSegments ? renderAsSegment : renderAsRadio,
jsx$1(HelpInfo, { className: "ml-6px size-16px", children: jsx$1(Fragment, { children: currentTabConfigList.map(({
        key,
        label,
        desc,
        extraHelpInfo: extraHelpInfo2
      }) => jsxs(reactExports.Fragment, { children: [
jsxs("div", { className: "h-22px flex items-center", children: [
jsx$1(TabIcon, { tabKey: key, className: "mr-4px", active: true }),
          label,
          ": ",
          desc
        ] }),
        !!extraHelpInfo2 && extraHelpInfo2
      ] }, key)) }) })
    ] });
  }
  const iconParkOutlineDrag = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M19 10a4 4 0 1 1-8 0a4 4 0 0 1 8 0m-4 18a4 4 0 1 0 0-8a4 4 0 0 0 0 8m0 14a4 4 0 1 0 0-8a4 4 0 0 0 0 8m22-32a4 4 0 1 1-8 0a4 4 0 0 1 8 0m-4 18a4 4 0 1 0 0-8a4 4 0 0 0 0 8m0 14a4 4 0 1 0 0-8a4 4 0 0 0 0 8", clipRule: "evenodd" })
  ] });
  const ForwardRef$e = reactExports.forwardRef(iconParkOutlineDrag);
  function TabPaneRecTabsConfig() {
    const {
      dynamicFeed
    } = useSettingsSnapshot();
    const sortedTabKeys = useSortedTabKeys();
    const getCssOrderStyle = (tab2) => {
      return {
        order: sortedTabKeys.indexOf(tab2) + 1
      };
    };
    return jsx$1("div", { className: sharedClassNames.tabPane, children: jsxs("div", { className: "grid grid-cols-[250px_1fr] gap-x-50px", children: [
jsx$1(SettingsGroup, { title: jsxs(Fragment, { children: [
        "Tab 设置",
jsx$1(HelpInfo, { className: "ml-5px", children: "勾选显示, 拖动排序" })
      ] }), resetSettingPaths: ["hidingTabKeys", "customTabKeysOrder"], children: jsx$1(VideoSourceTabOrder, {}) }),
jsxs(SettingsGroup, { title: "更多设置", contentClassName: "gap-y-15px", children: [
jsxs("div", { style: getCssOrderStyle(ETab.Watchlater), children: [
jsxs("div", { className: "flex items-center text-size-1.3em", children: [
jsx$1(TabIcon, { tabKey: ETab.Watchlater, className: "mr-5px mt--1px" }),
            "稍后再看"
          ] }),
jsxs("div", { className: sharedClassNames.settingsLine, children: [
jsx$1(CheckboxSettingItem, { configPath: "watchlaterAddSeparator", label: "添加分割线", tooltip: "添加「近期」「更早」分割线" }),
jsx$1(CheckboxSettingItem, { configPath: "watchlaterUseNormalVideoUrl", label: "使用普通视频链接", tooltip: explainForFlag("使用普通视频链接", "使用「稍后再看」自动列表链接") })
          ] })
        ] }),
jsxs("div", { style: getCssOrderStyle(ETab.Fav), children: [
jsxs("div", { className: "flex items-center text-size-1.3em", children: [
jsx$1(TabIcon, { tabKey: ETab.Fav, className: "mr-5px mt--2px" }),
            "收藏"
          ] }),
jsx$1("div", { className: sharedClassNames.settingsLine, children: jsx$1(CheckboxSettingItem, { configPath: "fav.addSeparator", label: "添加分割线", tooltip: "顺序显示时, 按收藏夹添加分割线" }) })
        ] }),
jsxs("div", { style: getCssOrderStyle(ETab.DynamicFeed), children: [
jsxs("div", { className: "flex items-center text-size-1.3em", children: [
jsx$1(TabIcon, { tabKey: ETab.DynamicFeed, className: "mr-5px mt--2px" }),
            "动态"
          ] }),
jsxs("div", { className: sharedClassNames.settingsLine, children: [
jsx$1(CheckboxSettingItem, { configPath: "dynamicFeed.followGroup.enabled", label: "启用分组筛选", tooltip: jsxs(Fragment, { children: [
              "动态 Tab 启用分组筛选 ",
jsx$1("br", {}),
jsx$1(FollowGroupMechanismNote, {})
            ] }) }),
jsx$1(CheckboxSettingItem, { configPath: "dynamicFeed.showLive", label: "在动态中显示直播", tooltip: jsxs(Fragment, { children: [
              "动态里显示正在直播的 UP",
jsx$1("br", {}),
              "P.S 仅在选择「全部」时展示"
            ] }) }),
jsx$1(CheckboxSettingItem, { configPath: "dynamicFeed.videoOnly", label: "只显示视频", tooltip: explainForFlag("只获取视频动态: 投稿视频 / 动态视频", "获取全部动态: 包含视频 / 图片 / 文章等") }),
jsx$1(CheckboxSettingItem, { configPath: "dynamicFeed.whenViewAll.enableHideSomeContents", label: "「全部」动态过滤", tooltip: jsxs(Fragment, { children: [
              "查看「全部」动态时 ",
jsx$1("br", {}),
              explainForFlag("将添加右键菜单, 点击可添加到「全部」动态的过滤列表", "关闭此功能")
            ] }) }),
            dynamicFeed.whenViewAll.enableHideSomeContents && jsx$1(Collapse$1, { size: "small", className: "w-full", items: [{
              key: "1",
              label: "在「全部」动态中隐藏 UP/分组 的动态",
              children: jsx$1(DynamicFeedWhenViewAllHideIdsPanel, {})
            }] })
          ] })
        ] }),
jsxs("div", { style: getCssOrderStyle(ETab.AppRecommend), children: [
jsxs("div", { className: "flex items-center text-size-1.3em", children: [
jsx$1(TabIcon, { tabKey: ETab.AppRecommend, className: "mr-5px" }),
            "App 推荐"
          ] }),
jsx$1("div", { className: sharedClassNames.settingsLine, children: jsx$1("div", { className: "flex items-center", children: appRecShowContentFromOtherTabEl() }) })
        ] })
      ] })
    ] }) });
  }
  function useCurrentShowingTabKeys() {
    const {
      hidingTabKeys
    } = useSettingsSnapshot();
    return reactExports.useMemo(() => CONFIGURABLE_TAB_KEYS.filter((key) => !hidingTabKeys.includes(key)), [hidingTabKeys]);
  }
  function VideoSourceTabOrder({
    className,
    style: style2
  }) {
    const currentShowingTabKeys = useCurrentShowingTabKeys();
    const sortedTabKeys = useSortedTabKeys({
      sync: true
    });
    const sensors = useSensors(useSensor(PointerSensor));
    const handleDragEnd = useMemoizedFn((e) => {
      const {
        over,
        active
      } = e;
      if (!over?.id || over.id === active.id) return;
      const oldIndex = sortedTabKeys.indexOf(active.id.toString());
      const newIndex = sortedTabKeys.indexOf(over.id.toString());
      const newList = arrayMove(sortedTabKeys, oldIndex, newIndex);
      settings.customTabKeysOrder = newList;
    });
    return jsx$1("div", { ...{
      className,
      style: style2
    }, children: jsx$1(Checkbox.Group, { className: "block line-height-[unset]", value: currentShowingTabKeys, onChange: (newVal) => {
      if (!newVal.length) {
        return antMessage.error("至少选择一项!");
      }
      updateSettings({
        hidingTabKeys: CONFIGURABLE_TAB_KEYS.filter((k) => !newVal.includes(k))
      });
    }, children: jsx$1(DndContext, { sensors, collisionDetection: closestCenter, onDragEnd: handleDragEnd, modifiers: [restrictToVerticalAxis, restrictToParentElement], children: jsx$1(SortableContext, { items: sortedTabKeys, strategy: verticalListSortingStrategy, children: sortedTabKeys.map((key) => jsx$1(VideoSourceTabSortableItem, { id: key }, key)) }) }) }) });
  }
  function VideoSourceTabSortableItem({
    id: id2
  }) {
    const {
      label,
      desc
    } = TabConfig[id2];
    const {
      attributes: attributes2,
      listeners: listeners2,
      setNodeRef,
      transform,
      transition,
      setActivatorNodeRef
    } = useSortable({
      id: id2
    });
    const style2 = {
      transform: CSS.Transform.toString(transform),
      transition
    };
    return jsxs("div", { ref: setNodeRef, style: style2, className: "mt-8px h-35px flex items-center justify-between b-1px b-gate-bg-lv-2 rounded-6px b-solid pl-10px pr-6px", children: [
jsxs(Checkbox, { value: id2, className: "inline-flex items-center [&_.ant-checkbox-label]:inline-flex [&_.ant-checkbox-label]:select-none [&_.ant-checkbox-label]:items-center", children: [
jsx$1(TabIcon, { tabKey: id2, className: "mr-5px" }),
jsx$1(AntdTooltip, { align: {
          offset: [0, -6]
        }, title: desc, children: label })
      ] }),
jsx$1("div", { ...listeners2, ...attributes2, ref: setActivatorNodeRef, className: "cursor-grab rounded-5px px-5px py-3px text-size-0 hover:bg-gate-bg-lv-3", children: jsx$1(ForwardRef$e, { className: "size-18px" }) })
    ] }, id2);
  }
  function DynamicFeedWhenViewAllHideIdsPanel() {
    const {
      hideIds
    } = useSnapshot(settings.dynamicFeed.whenViewAll);
    const onDelete = useMemoizedFn(async (mid) => {
      await updateSettingsInnerArray("dynamicFeed.whenViewAll.hideIds", {
        remove: [mid]
      });
    });
    const {
      groups
    } = useSnapshot(dfStore);
    useMount(() => {
      dfStore.updateGroups();
    });
    const empty = !hideIds.length;
    if (empty) {
      return jsx$1("div", { className: "flex items-center justify-center", children: jsx$1(Empty, {}) });
    }
    return jsx$1("div", { className: "max-h-250px flex flex-wrap gap-10px overflow-y-auto", children: hideIds.map((tag) => {
      return jsx$1(TagItemDisplay, { tag, onDelete, renderTag: (t2) => jsx$1(DynamicFeedWhenViewAllHideIdTag, { tag: t2, followGroups: groups }) }, tag);
    }) });
  }
  function DynamicFeedWhenViewAllHideIdTag({
    tag,
    followGroups
  }) {
    let mid;
    let followGroupId;
    if (tag.startsWith(DF_SELECTED_KEY_PREFIX_UP)) {
      mid = tag.slice(DF_SELECTED_KEY_PREFIX_UP.length);
    } else if (tag.startsWith(DF_SELECTED_KEY_PREFIX_GROUP)) {
      followGroupId = tag.slice(DF_SELECTED_KEY_PREFIX_GROUP.length);
    } else ;
    const [upNickname, setUpNickname] = reactExports.useState(void 0);
    useMount(async () => {
      if (!mid) return;
      const nickname = await getUserNickname(mid);
      if (nickname) setUpNickname(nickname);
    });
    const [followGroupName, setFollowGroupName] = reactExports.useState(void 0);
    useMount(() => {
      if (!followGroupId) return;
      const groupName = followGroups?.find((g2) => g2.tagid.toString() === followGroupId)?.name;
      if (groupName) setFollowGroupName(groupName);
    });
    const label = reactExports.useMemo(() => mid ? upNickname || mid : followGroupId ? followGroupName || followGroupId : "无效数据", [mid, upNickname, followGroupId, followGroupName]);
    const tooltip = reactExports.useMemo(() => mid ? `mid: ${mid}` : followGroupId ? `分组: ${followGroupId}` : `Tag: ${tag}`, [mid, followGroupId, tag]);
    const icon = reactExports.useMemo(() => mid ? jsx$1(IconForUp, { className: "mr-2px size-12px" }) : followGroupId ? jsx$1(IconForGroup, { className: "mr-2px size-16px" }) : void 0, [mid, followGroupId]);
    const href = reactExports.useMemo(() => mid ? formatSpaceUrl(mid) : followGroupId ? formatFollowGroupUrl(followGroupId) : void 0, [mid, followGroupId]);
    return jsx$1(Fragment, { children: jsx$1(AntdTooltip, { title: tooltip, children: jsxs("span", { className: clsx("inline-flex items-center", mid ? "cursor-pointer" : "cursor-text"), children: [
      icon,
      href ? jsx$1("a", { href, target: "_blank", children: label }) : label
    ] }) }) });
  }
  const borderCycleList = [
    {
      useBorder: false
    },
{
      useBorder: true,
      useBorderOnlyOnHover: true
    },
{
      useBorder: true,
      useBorderOnlyOnHover: false
    }
];
  const borderCycleListLabels = ["「卡片边框」: 禁用", "「卡片边框」: 仅在悬浮时显示", "「卡片边框」: 总是显示"];
  function useHotkeyForConfigBorder() {
    return useKeyPress$2(["shift.b"], (e) => {
      if (shouldDisableShortcut()) return;
      const curState = pick(settings.style.videoCard, ["useBorder", "useBorderOnlyOnHover"]);
      const curIndex = borderCycleList.findIndex((state2) => {
        return isEqual$2(state2, pick(curState, Object.keys(state2)));
      });
      if (curIndex === -1) throw new Error("unexpected curIndex = -1");
      const nextIndex = (curIndex + 1) % borderCycleList.length;
      const nextState = borderCycleList[nextIndex];
      Object.assign(settings.style.videoCard, nextState);
      const nextLabel = borderCycleListLabels[nextIndex];
      antMessage.success(nextLabel);
    }, {
      exactMatch: true
    });
  }
  function TabPaneVideoCard() {
    const {
      videoCard: {
        actions: {
          showLargePreview,
          openInPipWindow: openInPipWindow2
        },
        imgPreview: {
          enabled: imgPreviewEnabled
        }
      },
      videoLinkOpenMode,
      style: style2,
      autoPreviewUpdateInterval
    } = useSettingsSnapshot();
    const openModeOptions = reactExports.useMemo(() => {
      return Object.values(EVideoLinkOpenMode).filter((mode) => VideoLinkOpenModeConfig[mode].enabled ?? true).map((mode) => {
        const config = VideoLinkOpenModeConfig[mode];
        return {
          config,
          value: mode,
          label: jsxs("span", { className: "flex-v-center gap-x-8px", children: [
            config.icon,
jsx$1("span", { children: config.label })
          ] })
        };
      });
    }, []);
    return jsxs("div", { className: sharedClassNames.tabPane, children: [
jsx$1(SettingsGroup, { title: "视频链接", resetSettingPaths: ["videoLinkOpenMode"], children: jsxs("div", { className: "flex-v-center", children: [
        "打开方式",
jsxs(HelpInfo, { useBlackBg: true, children: [
          "选择点击视频(封面图片 或 标题)时打开的模式 ",
jsx$1("br", {}),
          openModeOptions.map(({
            value,
            config
          }) => {
            return !!config.desc && jsxs("div", { className: "mt-10px flex items-start first:mt-0", children: [
jsxs("span", { className: "inline-flex items-center", children: [
                config.icon,
jsx$1("span", { className: "ml-4px mr-10px min-w-95px", children: config.label })
              ] }),
jsx$1("span", { className: "desc", children: config.desc })
            ] }, value);
          })
        ] }),
jsx$1(Select, { className: "ml-8px w-160px", options: openModeOptions, value: videoLinkOpenMode, onChange: (v) => {
          updateSettings({
            videoLinkOpenMode: v
          });
        } })
      ] }) }),
jsx$1(SettingsGroup, { title: "边框样式", resetSettingPaths: ["style.videoCard.useBorder", "style.videoCard.useBorderOnlyOnHover", "style.videoCard.useBoxShadow"], children: jsxs("div", { className: sharedClassNames.settingsLine, children: [
jsx$1(CheckboxSettingItem, { configPath: "style.videoCard.useBorder", label: "使用卡片边框", tooltip: jsxs(Fragment, { children: [
          "勾选后, 视频卡片会有边框包裹, 更像是一个卡片~ ",
jsx$1("br", {}),
          "整个卡片区域可点击 / 可触发预览 / 可使用右键菜单 ",
jsx$1("br", {}),
          "否则只是封面区域可以 ",
jsx$1("br", {}),
          "使用快捷键 ",
jsx$1(Tag, { color: "green", children: "shift+b" }),
          " 切换状态 ",
jsx$1("br", {}),
          borderCycleListLabels.map((label) => jsx$1(Tag, { color: "success", className: "mx-1", children: label }, label))
        ] }) }),
jsx$1(CheckboxSettingItem, { configPath: "style.videoCard.useBorderOnlyOnHover", label: "仅在悬浮时显示", disabled: !style2.videoCard.useBorder, tooltip: explainForFlag("仅在悬浮时显示", "常驻显示") }),
jsx$1(CheckboxSettingItem, { configPath: "style.videoCard.useBoxShadow", disabled: !style2.videoCard.useBorder, label: "悬浮卡片时使用发光效果", tooltip: jsx$1(Fragment, { children: "悬浮卡片时使用发光效果, 看起来比较花哨~" }) })
      ] }) }),
jsxs(SettingsGroup, { title: jsxs(Fragment, { children: [
        "快照预览",
jsx$1(SwitchSettingItem, { configPath: "videoCard.imgPreview.enabled", tooltip: "关闭此功能", className: "ml-3" })
      ] }), resetSettingPaths: ["videoCard.imgPreview.enabled", "videoCard.imgPreview.autoPreviewWhenKeyboardSelect", "videoCard.imgPreview.autoPreviewWhenHover", "videoCard.imgPreview.disableWhenMultiSelecting", "useDelayForHover", "autoPreviewUpdateInterval"], children: [
jsxs("div", { className: sharedClassNames.settingsLine, children: [
jsx$1(CheckboxSettingItem, { disabled: !imgPreviewEnabled, configPath: "videoCard.imgPreview.autoPreviewWhenHover", label: "鼠标悬浮后自动开始", tooltip: jsxs(Fragment, { children: [
            explainForFlag("鼠标悬浮后自动开始预览, 不跟随鼠标位置", "预览进度跟随鼠标位置(百分比)"),
            "切换设置快捷键: ",
jsx$1(Tag, { color: "green", children: "shift+m" })
          ] }) }),
jsx$1(CheckboxSettingItem, { disabled: !imgPreviewEnabled, configPath: "videoCard.imgPreview.disableWhenMultiSelecting", label: "多选时禁用", tooltip: explainForFlag("多选开启时, 禁用快照预览", "不禁用") }),
jsx$1(CheckboxSettingItem, { disabled: !imgPreviewEnabled, configPath: "useDelayForHover", label: "延迟悬浮预览", tooltip: "延迟悬浮预览" }),
jsx$1(CheckboxSettingItem, { disabled: !imgPreviewEnabled, configPath: "videoCard.imgPreview.autoPreviewWhenKeyboardSelect", label: "键盘选中后自动开始", tooltip: jsxs(Fragment, { children: [
            "手动预览快捷键: ",
jsx$1(Tag, { color: "green", children: "." }),
            " or ",
jsx$1(Tag, { color: "green", children: "p" }),
            " ",
jsx$1("br", {}),
            "切换设置快捷键: ",
jsx$1(Tag, { color: "green", children: "shift+p" })
          ] }) })
        ] }),
jsxs("div", { className: sharedClassNames.settingsLine, children: [
          "自动预览更新间隔",
jsx$1(Slider, { disabled: !imgPreviewEnabled, className: "w-500px", min: 0, max: 1e3, keyboard: true, onChange: (val) => settings.autoPreviewUpdateInterval = val, value: autoPreviewUpdateInterval }),
jsxs("span", { style: {
            width: "65px"
          }, children: [
            "(",
            autoPreviewUpdateInterval,
            "ms)"
          ] })
        ] })
      ] }),
jsx$1(SettingsGroup, { title: jsxs(Fragment, { children: [
        "操作按钮",
jsxs(HelpInfo, { children: [
          "视频卡片右上角「稍后再看」按钮旁 ",
jsx$1("br", {}),
          "「稍后再看」因其通用性不提供关闭选项"
        ] })
      ] }), resetSettingPaths: ["videoCard.actions.showLargePreview", "videoCard.actions.openInPipWindow", "videoCard.videoPreview.useMp4", "videoCard.videoPreview.usePreferredCdn", "videoCard.videoPreview.useScale", "videoCard.videoPreview.useVideoCardAsTrigger", "pipWindow.defaultLocked", "pipWindow.autoWebFullscreen"], children: jsxs("div", { className: "grid grid-cols-[repeat(2,max-content)_1fr] items-start gap-x-20px", children: [
jsx$1(CheckboxSettingItem, { configPath: "videoCard.actions.showLargePreview", label: "浮动预览", tooltip: jsxs(Fragment, { children: [
          "创意来源「浮图秀」, 但使用视频预览 ",
jsx$1("br", {}),
          "操作说明: ",
jsx$1("br", {}),
          "1. 鼠标悬浮打开 「浮动预览」, 离开关闭 ",
jsx$1("br", {}),
          "2. 点击固定「浮动预览」, 固定指: 不再随鼠标移出关闭预览 ",
jsx$1("br", {}),
          "3. 可使用以下方式关闭固定的「浮动预览」",
jsxs("ul", { className: "ml-30px list-circle", children: [
jsx$1("li", { children: "再次点击视频卡片按钮" }),
jsx$1("li", { children: "点击预览视频右上方的「关闭」按钮" }),
jsx$1("li", { children: "触发其他卡片的「浮动预览」" }),
jsx$1("li", { children: "Esc键" }),
jsx$1("li", { children: "点击页面空白处" })
          ] })
        ] }) }),
jsx$1(CheckboxSettingItem, { configPath: "videoCard.actions.openInPipWindow", label: "小窗打开", tooltip: jsx$1(Fragment, { children: "仅当「文档画中画」API 可用时, 勾选生效" }) }),
jsx$1(Divider, { className: "grid-col-span-full my-2px py-0" }),
jsxs("div", { className: "flex flex-col", children: [
jsx$1(CheckboxSettingItem, { configPath: "videoCard.videoPreview.useMp4", disabled: !showLargePreview, label: "浮动预览: 使用 mp4", tooltip: explainForFlag("使用 mp4, 最高 720p, 有声音", "使用 dash, 最高 1080p, 无声音, 理论上更快") }),
jsx$1(CheckboxSettingItem, { configPath: "videoCard.videoPreview.usePreferredCdn", disabled: !showLargePreview, label: "浮动预览: 使用优选 CDN", tooltip: explainForFlag("使用优选 CDN (降低 MCDN & PCDN 优先级)", "使用默认 CDN") }),
jsx$1(CheckboxSettingItem, { configPath: "videoCard.videoPreview.useScale", disabled: !showLargePreview, label: "浮动预览: 使用放大效果", tooltip: explainForFlag("浮动预览面板: 放大展开 (类似浮图秀)", "浮动预览面板: 滑动展开") }),
jsx$1(CheckboxSettingItem, { configPath: "videoCard.videoPreview.useVideoCardAsTrigger", label: "浮动预览: 使用视频卡片作为触发器", tooltip: jsxs(Fragment, { children: [
            explainForFlag("使用「视频卡片」作为触发器", "使用「视频卡片右上角按钮」作为触发器, 悬浮视频卡片 1 秒后展开"),
jsx$1(Divider, { className: "my-1" }),
jsx$1("ul", { className: "ml-25px list-circle", children: jsx$1("li", { children: "与上面「浮动预览」开关独立" }) })
          ] }) })
        ] }),
jsxs("div", { className: "flex flex-col", children: [
jsx$1(CheckboxSettingItem, { configPath: "pipWindow.defaultLocked", disabled: !openInPipWindow2, label: "小窗: 默认锁定", tooltip: explainForFlag("小窗打开时: 默认锁定", "小窗打开时: 不锁定") }),
jsx$1(CheckboxSettingItem, { configPath: "pipWindow.autoWebFullscreen", disabled: !openInPipWindow2, label: "小窗: 自动网页全屏", tooltip: explainForFlag("自动网页全屏", "不启用") })
        ] })
      ] }) })
    ] });
  }
  function ThemesSelect() {
    const activeId = useCurrentTheme().id;
    const prevActiveId = usePrevious$1(activeId);
    const {
      colorPickerThemeSelectedColor
    } = useSettingsSnapshot();
    const [customColor, setCustomColor] = reactExports.useState(colorPickerThemeSelectedColor || BiliBrandColor.Pink);
    const customColorHex = reactExports.useMemo(() => {
      return typeof customColor === "string" ? customColor : customColor.toHexString();
    }, [customColor]);
    useMount(() => {
      $evolvedThemeColor.updateThrottled();
    });
    return jsx$1("div", { children: ThemeGroups.map(({
      name,
      themes,
      tooltip
    }) => {
      return jsxs(reactExports.Fragment, { children: [
jsxs("div", { className: "mt-2 flex items-center text-size-1.5em", children: [
          name,
jsx$1(HelpInfo, { className: "size-16px", useBlackBg: true, children: tooltip })
        ] }),
jsx$1("div", { className: "flex flex-wrap gap-x-5px gap-y-2px", children: themes.map((t2) => {
          const isActive2 = activeId === t2.id;
          const isCustom = t2.isCustom;
          const useAnimation = !!prevActiveId && prevActiveId !== t2.id;
          const innerSize = 28;
          const outerSize = innerSize + 8;
          let previewWrapper = jsx$1("div", { "data-role": "preview-wrapper", style: {
            width: outerSize
          }, className: clsx("mx-auto my-0 aspect-1 b-2px rounded-full b-solid", isActive2 ? "b-gate-primary" : "b-transparent", "flex items-center justify-center text-size-0"), children: jsx$1("div", { "data-role": "preview", className: "aspect-1 flex items-center justify-center rounded-full text-white", css: css("width:", innerSize, "px;background-color:", isCustom ? customColorHex : t2.colorPrimary, ";", ""), children: isActive2 && jsx$1(IconAnimatedChecked, { size: 18, useAnimation }) }) });
          if (t2.isCustom) {
            previewWrapper = jsx$1(
              ColorPicker,
              {
                value: customColor,
                onChange: (c2) => setCustomColor(c2),
                onOpenChange: (open2) => {
                  if (!open2) {
                    updateSettings({
                      colorPickerThemeSelectedColor: customColorHex
                    });
                  }
                },
                children: previewWrapper
              }
            );
          }
          let el = jsxs("div", { className: "min-w-60px cursor-pointer text-center", onClick: (e) => {
            updateSettings({
              theme: t2.id
            });
          }, children: [
            previewWrapper,
            t2.name
          ] });
          if (t2.tooltip || EXTRA_TOOLTIP[t2.id]) {
            el = jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
              t2.tooltip,
              EXTRA_TOOLTIP[t2.id]
            ] }), color: t2.colorPrimary, children: el });
          }
          el = jsx$1(reactExports.Fragment, { children: el }, t2.id);
          return el;
        }) })
      ] }, name);
    }) });
  }
  function useHotkeyForConfig(hotkey, configPath, label) {
    return useKeyPress$2(hotkey, (e) => {
      if (shouldDisableShortcut()) return;
      const current = Boolean(get$1(settings, configPath));
      const newValue = !current;
      set$1(settings, configPath, newValue);
      antMessage.success(`已${newValue ? "启用" : "禁用"}「${label}」`);
    }, {
      exactMatch: true
    });
  }
  const tab = "basic";
  const modalSettingsStore = proxy({
    tab
  });
  function ModalSettingsHotkey() {
    useHotkeyForConfig(["shift.p"], "videoCard.imgPreview.autoPreviewWhenKeyboardSelect", "键盘选中后自动开始预览");
    useHotkeyForConfig(["shift.m"], "videoCard.imgPreview.autoPreviewWhenHover", "鼠标悬浮后自动开始预览");
    useHotkeyForConfigBorder();
    return null;
  }
  const customTabsCss = {
    name: "4k370z",
    styles: "&.ant-tabs{.ant-tabs-tab{justify-content:end;padding-inline:5px 15px;}.ant-tabs-nav-operations{display:none;}}"
  };
  function ModalSettings({
    show,
    onHide: onHide2
  }) {
    const {
      tab: tab2
    } = useSnapshot(modalSettingsStore);
    return jsxs(BaseModal, { show, onHide: onHide2, hideWhenMaskOnClick: true, hideWhenEsc: true, width: 900, clsModalMask: "[&:has(svg.peeking)]:bg-transparent", clsModal: "max-h-unset [&:has(svg.peeking)]:opacity-10", children: [
jsxs("div", { className: BaseModalClassNames.modalHeader, children: [
jsxs("div", { className: BaseModalClassNames.modalTitle, children: [
jsx$1(IconForConfig, { className: "mr-4px mt--2px size-26px" }),
          "设置"
        ] }),
jsx$1(ModalClose, { onClick: onHide2 })
      ] }),
jsx$1("main", { className: BaseModalClassNames.modalBody, style: {
        overflow: "hidden"
      }, children: jsx$1(Tabs, { tabPlacement: "start", size: "middle", css: customTabsCss, activeKey: tab2, onChange: (tab3) => modalSettingsStore.tab = tab3, items: [{
        label: "常规设置",
        key: "basic",
        children: jsx$1(TabPaneBasic, {})
      }, {
        label: "视频卡片",
        key: "video-card",
        children: jsx$1(TabPaneVideoCard, {})
      }, {
        label: "内容过滤",
        key: "filter",
        children: jsx$1(TabPaneFilter, {})
      }, {
        label: "主题选择",
        key: "theme-select",
        children: jsx$1("div", { className: sharedClassNames.tabPane, children: jsx$1(ThemesSelect, {}) })
      }, {
        label: "Tab 设置",
        key: "video-source-tab-config",
        children: jsx$1(TabPaneRecTabsConfig, {})
      }, {
        label: "其他页面",
        key: "other-pages",
        children: jsx$1(TabPaneOtherPages, {})
      }, {
        label: "高级设置",
        key: "advance",
        children: jsx$1(TabPaneAdvance, {})
      }] }) })
    ] });
  }
  const iconParkOutlineRight = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "m19 12l12 12l-12 12" })
  ] });
  const ForwardRef$d = reactExports.forwardRef(iconParkOutlineRight);
  function CollapseBtn({
    children,
    initialOpen = false,
    ref: ref2
  }) {
    const [buttonsExpanded, buttonsExpandedActions] = useToggle(initialOpen);
    reactExports.useImperativeHandle(ref2, () => buttonsExpandedActions, [buttonsExpandedActions]);
    const btn = jsx$1(Button$1, { onClick: buttonsExpandedActions.toggle, className: "icon-only-round-button", children: jsx$1(ForwardRef$d, { className: clsx("size-13px", buttonsExpanded ? "rotate-z-0" : "rotate-z-180deg") }) });
    return jsxs(Fragment, { children: [
      btn,
      buttonsExpanded && children
    ] });
  }
  function wrapComponent({
    Component,
    defaultProps: defaultProps2,
    containerClassName
  }) {
    const proxyProps2 = proxy(defaultProps2);
    function WrappedComponent() {
      const props = useSnapshot(proxyProps2);
      return jsx$1(Component, { ...props });
    }
    const mount = once(() => {
      const div = document.createElement("div");
      div.className = clsx(APP_CLS_ROOT, containerClassName);
      document.body.appendChild(div);
      clientExports.createRoot(div).render( jsx$1(AppRoot, { children: jsx$1(WrappedComponent, {}) }));
    });
    function wrapAction(action2) {
      return (...args) => {
        mount();
        return action2(...args);
      };
    }
    const updateProps2 = wrapAction((newProps) => {
      Object.assign(proxyProps2, newProps);
    });
    return {
      WrappedComponent,
      proxyProps: proxyProps2,
      mount,
      wrapAction,
      updateProps: updateProps2
    };
  }
  const PcDislikeReasons = [{
    platform: "pc",
    text: "内容不感兴趣",
    value: 1,
    reason: 1
  }, {
    platform: "pc",
    text: "不想看此UP主",
    value: 2,
    reason: 4
  }];
  function normalizeDislikeReason(reason) {
    if (reason.platform === "app") return {
      reasonId: reason.id,
      text: reason.name,
      helpText: reason.toast
    };
    if (reason.platform === "pc") return {
      reasonId: reason.reason,
      text: reason.text
    };
    assertNever(reason);
  }
  const defaultProps$1 = {
    show: false,
    reasons: [],
    onHide: onHide$1,
    okAction: void 0
  };
  const {
    proxyProps: proxyProps$1,
    updateProps: updateProps$1
  } = wrapComponent({
    Component: ModalDislike,
    containerClassName: "show-dislike-container",
    defaultProps: defaultProps$1
  });
  const emitter$1 = new Emittery();
  function onHide$1() {
    emitter$1.emit("modal-close");
    updateProps$1({
      show: false,
      reasons: [],
      okAction: void 0
    });
  }
  async function pickDislikeReason(reasons, okAction) {
    updateProps$1({
      show: true,
      reasons,
      okAction
    });
    await emitter$1.once("modal-close");
  }
  const useModalDislikeVisible = function() {
    return useSnapshot(proxyProps$1).show;
  };
  function ModalDislike({
    show,
    reasons,
    onHide: onHide2,
    okAction
  }) {
    const modalBodyRef = reactExports.useRef(null);
    const keyPressEnabled = () => !!show && !!reasons?.length;
    const $req = useRequest(async (reason) => okAction?.(reason), {
      manual: true
    });
    const okActionLoading = $req.loading;
    const [activeIndex, setActiveIndex] = reactExports.useState(() => reasons.length ? reasons.length - 1 : 0);
    reactExports.useLayoutEffect(() => {
      if (!reasons.length) return;
      const platform = reasons[0].platform;
      if (platform === "app") {
        setActiveIndex(reasons.length - 1);
      } else if (platform === "pc") {
        setActiveIndex(0);
      } else {
        assertNever(platform);
      }
    }, [reasons]);
    const KEYS = ["1", "2", "3", "4", "5", "6"];
    useKeyPress$2(KEYS, (e) => {
      if (!keyPressEnabled()) return;
      if (!KEYS.includes(e.key)) return;
      if (!reasons?.length) return;
      const index = Number(e.key) - 1;
      if (!(index >= 0 && index < reasons.length)) return;
      setActiveIndex(index);
    });
    const increaseIndex = useMemoizedFn((by) => {
      if (!keyPressEnabled()) return;
      if (shouldDisableShortcut()) return;
      const len = reasons.length;
      let newIndex = activeIndex + by;
      if (newIndex < 0) newIndex = newIndex % len + len;
      if (newIndex > len - 1) newIndex = newIndex % len;
      setActiveIndex(newIndex);
    });
    useKeyPress$2("uparrow", () => increaseIndex(-1), {
      exactMatch: true
    });
    useKeyPress$2("downarrow", () => increaseIndex(1), {
      exactMatch: true
    });
    const onOk = useLockFn(async (e) => {
      if (!keyPressEnabled()) return;
      if (activeIndex < 0 || activeIndex > reasons.length - 1) return;
      const reason = reasons[activeIndex];
      if (!reason) return;
      e.preventDefault();
      e.stopPropagation();
      const result = await $req.runAsync(reason);
      if (result) onHide2();
    });
    useKeyPress$2("enter", onOk, {
      exactMatch: true
    });
    return jsxs(BaseModal, { show, onHide: onHide2, hideWhenMaskOnClick: true, hideWhenEsc: true, width: 350, clsModal: "rounded-15px", children: [
jsxs("div", { className: BaseModalClassNames.modalHeader, children: [
jsxs("div", { className: BaseModalClassNames.modalTitle, children: [
jsx$1(IconForDislike, { className: "size-25px" }),
jsx$1("span", { className: "ml-5px", children: "我不想看" }),
jsxs(HelpInfo, { children: [
            "选择后将减少相似内容推荐 ",
jsx$1("br", {}),
            "操作说明: ",
jsx$1("br", {}),
jsxs("div", { className: "ml-10px", children: [
              "1. 使用删除键打开弹窗, Esc 关闭 ",
jsx$1("br", {}),
              "2. 数字键 或 方向键选择 ",
jsx$1("br", {}),
              "3. 回车键 或 确定按钮提交 ",
jsx$1("br", {})
            ] })
          ] })
        ] }),
jsx$1(ModalClose, { onClick: onHide2 })
      ] }),
jsx$1("div", { className: BaseModalClassNames.modalBody, ref: modalBodyRef, children: jsx$1(Spin, { spinning: okActionLoading, indicator: antSpinIndicator, children: jsx$1("div", { className: "reason-list mb-20px mt-20px flex flex-col gap-y-10px", children: reasons.map((reason, index) => {
        const active = index === activeIndex;
        const {
          reasonId,
          text
        } = normalizeDislikeReason(reason);
        return jsxs("button", { className: clsx("reason", {
          active
        }, "relative flex cursor-pointer items-center b-2px rounded-6px b-solid bg-transparent px-6px py-12px", active ? "b-gate-primary" : "b-gate-border"), disabled: okActionLoading, onClick: () => {
          setActiveIndex(index);
        }, children: [
jsx$1("span", { "data-cls": "reason-no", className: "size-20px flex flex-none items-center justify-center rounded-full bg-gate-primary text-13px color-white", children: index + 1 }),
jsx$1("span", { className: "flex-1 px-4px text-14px", children: text }),
jsx$1("span", { className: "size-20px flex-none", children: active && jsx$1(IconAnimatedChecked, { className: "h-100% w-100% color-gate-primary", useAnimation: true }) })
        ] }, reasonId);
      }) }) }) }),
jsxs("div", { className: "mt-2 flex items-center justify-end gap-x-10px", children: [
jsx$1(Button$1, { onClick: onHide2, children: "取消" }),
jsx$1(Button$1, { type: "primary", onClick: onOk, loading: okActionLoading, children: "确定" })
      ] })
    ] });
  }
  const localStoreInitial = {
    modalWidth: 60,
favFolderOrder: "default"
  };
  const localStore = proxyWithLocalStorage({
    ...localStoreInitial
  }, "modal-fav-manager");
  function ConfigPopoverContent() {
    const {
      modalWidth,
      favFolderOrder
    } = useSnapshot(localStore);
    const clsTitle = "text-1.5em";
    const clsSubTitle = "text-1.2em";
    return jsxs("div", { className: "flex flex-col gap-y-10px", children: [
jsxs("div", { className: "flex items-center justify-between", children: [
jsx$1("div", { className: clsTitle, children: "窗口设置" }),
jsx$1(Button$1, { className: "icon-only-round-button size-24px", onClick: () => Object.assign(localStore, localStoreInitial), children: jsx$1(IconForReset, {}) })
      ] }),
jsxs("div", { children: [
jsxs("div", { className: clsSubTitle, children: [
          "窗口宽度 ",
          modalWidth,
          "%"
        ] }),
jsx$1(Slider, { className: "mt-0", value: modalWidth, min: 30, max: 90, onChange: (v) => {
          localStore.modalWidth = v;
        } })
      ] }),
jsxs("div", { children: [
jsx$1("div", { className: clsSubTitle, children: "收藏夹排序" }),
jsx$1(FavFolderOrderSwitcher, { value: favFolderOrder, onChange: (v) => localStore.favFolderOrder = v })
      ] })
    ] });
  }
  function ModalFavManager({
    show,
    onHide: onHide2,
    mode,
pickOkAction,
modifyInitialSelectedIds,
    modifyAllowEmpty,
    modifyOkAction
  }) {
    const {
      modalWidth,
      favFolderOrder
    } = useSnapshot(localStore);
    const [selectedFolderId, setSelectedFolderId] = reactExports.useState(void 0);
    const [filterText, setFilterText] = reactExports.useState(void 0);
    const $updateFoldersReq = useRequest(updateFavFolderList, {
      manual: true
    });
    const $pickOkActionReq = useRequest(async (result) => pickOkAction?.(result), {
      manual: true
    });
    const $modifyOkActionReq = useRequest(async (result) => modifyOkAction?.(result), {
      manual: true
    });
    const {
      folders
    } = useSnapshot(favStore);
    const foldersAfterFilter = reactExports.useMemo(() => {
      const mapped = folders.map((folder, index) => ({
        ...folder,
        vol: index + 1
      }));
      if (!filterText) return mapped;
      const included = mapped.filter((folder) => folder.title.includes(filterText));
      const includedIgnoreCase = mapped.filter((folder) => folder.title.toLowerCase().includes(filterText.toLowerCase()));
      const pinyinMatched = mapped.filter((folder) => PinyinMatch.match(folder.title, filterText));
      return uniqBy([...included, ...includedIgnoreCase, ...pinyinMatched], (x) => x.id);
    }, [folders, filterText]);
    const foldersAfterSort = reactExports.useMemo(() => sortFavFolders(foldersAfterFilter, favFolderOrder), [foldersAfterFilter, favFolderOrder]);
    const foldersForRender = foldersAfterSort;
    const modifyInitialSelectedIdsSet = reactExports.useMemo(() => new Set([modifyInitialSelectedIds].flat().filter((num) => typeof num === "number")), [modifyInitialSelectedIds]);
    const srcFavFolderBgClassName = useSrcFavFolderBgClassName();
    const allowEmptyResult = mode === "modify" && modifyAllowEmpty;
    const okButtonDisabled = reactExports.useMemo(() => {
      return !allowEmptyResult && !selectedFolderId ||
mode === "modify" && isEqual$2(Array.from(modifyInitialSelectedIdsSet), [selectedFolderId]);
    }, [allowEmptyResult, selectedFolderId, mode, modifyInitialSelectedIdsSet]);
    useKeyPress$2("r", () => {
      if (!show) return;
      if (shouldDisableShortcut()) return;
      $updateFoldersReq.run(true);
    }, {
      exactMatch: true
    });
    const onOk = useMemoizedFn(async () => {
      let selectedFolder;
      if (selectedFolderId) selectedFolder = folders.find((folder) => folder.id === selectedFolderId);
      if (!allowEmptyResult && !selectedFolder) return antMessage.error("请选择一个收藏夹");
      if (mode === "pick") {
        invariant$1(selectedFolder, "selectedFolder should not be empty when mode=pick");
        const success = await $pickOkActionReq.runAsync(selectedFolder);
        if (success) onHide2();
      }
      if (mode === "modify") {
        const success = await $modifyOkActionReq.runAsync(selectedFolder);
        if (success) onHide2();
      }
    });
    const sync_modifyMode_initialSelectedIdSet_to_componentState = useMemoizedFn(() => {
      if (!show || mode !== "modify" || !modifyInitialSelectedIdsSet.size) return;
      if (!selectedFolderId || !modifyInitialSelectedIdsSet.has(selectedFolderId)) {
        const first = Array.from(modifyInitialSelectedIdsSet)[0];
        setSelectedFolderId(first);
      }
    });
    reactExports.useEffect(() => {
      if (show) {
        $updateFoldersReq.run();
        sync_modifyMode_initialSelectedIdSet_to_componentState();
      }
    }, [show]);
    useUpdateEffect(() => {
      if (show && (!selectedFolderId || !modifyInitialSelectedIdsSet.has(selectedFolderId))) {
        const first = Array.from(modifyInitialSelectedIdsSet)[0];
        setSelectedFolderId(first);
      }
    }, [modifyInitialSelectedIdsSet]);
    return jsxs(BaseModal, { show, onHide: onHide2, hideWhenMaskOnClick: true, hideWhenEsc: true, width: `${modalWidth}vw`, clsModal: "rounded-15px", children: [
jsxs("div", { className: BaseModalClassNames.modalHeader, children: [
jsxs("div", { className: "flex flex-wrap items-center gap-x-10px gap-y-1", children: [
jsxs("div", { className: BaseModalClassNames.modalTitle, children: [
            mode === "pick" ? jsx$1(IconForMove, { className: "size-25px" }) : jsx$1(IconForEdit, { className: "size-25px" }),
jsx$1("span", { className: "ml-5px", children: mode === "pick" ? "选择目标收藏夹" : "修改收藏" })
          ] }),
jsx$1(Input, { className: "w-215px", allowClear: true, placeholder: "过滤: 支持拼音 / 拼音首字母", value: filterText, onChange: (e) => setFilterText(e.target.value), spellCheck: false }),
          !!filterText && jsxs("span", { className: "ml-5px", children: [
jsx$1("span", { className: clsx({
              "text-red": folders.length && !foldersForRender.length
            }), children: foldersForRender.length }),
            " ",
            "/ ",
jsx$1("span", { children: folders.length })
          ] }),
jsxs(HelpInfo, { className: "ml-5px size-1.3em", children: [
            "1. 使用 ",
jsx$1("kbd", { className: clsx(kbdClassName, "mx-2px"), children: "r" }),
            " 刷新收藏夹 ",
jsx$1("br", {}),
            "2. 使用 ",
jsx$1("kbd", { className: clsx(kbdClassName, "mx-2px"), children: "esc" }),
            " 取消操作, 关闭窗口 ",
jsx$1("br", {}),
            "3. 使用 拼音 / 拼音首字母 过滤收藏夹标题 ",
jsx$1("br", {})
          ] }),
jsx$1(Popover, { trigger: "click", title: jsx$1(ConfigPopoverContent, {}), children: jsx$1(IconForConfig, { className: "size-1.3em cursor-pointer" }) })
        ] }),
jsx$1(ModalClose, { onClick: onHide2 })
      ] }),
jsx$1("div", { className: clsx(BaseModalClassNames.modalBody), children: jsx$1(Spin, { spinning: $updateFoldersReq.loading || $pickOkActionReq.loading || $modifyOkActionReq.loading, indicator: antSpinIndicator, children: jsx$1("div", { className: "grid grid-cols-[repeat(auto-fill,minmax(225px,1fr))] mb-10px min-h-100px content-start items-center gap-10px pr-18px", children: foldersForRender.length ? foldersForRender.map((f2) => {
        const isSourceFolder = mode === "modify" && modifyInitialSelectedIdsSet.has(f2.id);
        const active = f2.id === selectedFolderId;
        return jsxs("button", { "data-id": f2.id, className: clsx({
          active
        }, "relative min-h-40px flex cursor-pointer items-center b-2px b-gate-border rounded-20px b-solid bg-transparent px-4px line-height-[1.2] hover:bg-gate-bg-lv1", active && "b-gate-primary color-white bg-gate-primary! hover:bg-gate-primary-lv1!"), onClick: () => {
          if (active && allowEmptyResult) {
            return setSelectedFolderId(void 0);
          }
          setSelectedFolderId(f2.id);
        }, children: [
          isSourceFolder && jsx$1(AntdTooltip, { title: "源收藏夹", placement: "left", children: jsx$1("span", { className: clsx("absolute left-2 top-50% size-2.5 flex-center translate-y--50% rounded-full", srcFavFolderBgClassName) }) }),
jsxs("span", { className: "flex-1 px-4px text-14px", children: [
            f2.title,
            " (",
            f2.media_count,
            ")"
          ] }),
jsx$1("span", { className: "mr-2px size-20px flex-none", children: active && jsx$1(IconAnimatedChecked, { className: "size-full color-white", useAnimation: true }) })
        ] }, f2.id);
      }) : jsx$1(Empty, { className: "grid-col-span-full", image: Empty.PRESENTED_IMAGE_SIMPLE, description: "未找到收藏夹", children: "无过滤结果, 请检查过滤词 !" }) }) }) }),
jsxs("div", { className: "mt-2 flex items-center justify-between", children: [
jsx$1("div", { className: "flex-v-center gap-x-10px", children: jsxs("a", { href: `https://space.bilibili.com/${getUid()}/favlist`, target: "_blank", className: "flex-v-center gap-x-1", children: [
jsx$1(IconForOpenExternalLink, { className: "size-1.1em" }),
          "去个人空间新建收藏夹"
        ] }) }),
jsxs("div", { className: "flex-v-center gap-x-10px", children: [
jsx$1(Button$1, { onClick: onHide2, children: "取消" }),
jsx$1(Button$1, { type: "primary", onClick: onOk, loading: $pickOkActionReq.loading || $modifyOkActionReq.loading, disabled: okButtonDisabled, children: "确定" })
        ] })
      ] })
    ] });
  }
  function useSrcFavFolderBgClassName() {
    const {
      theme: theme2
    } = useSettingsSnapshot();
    return theme2 === BILI_BRAND_PINK_THEME.id ? "bg-$brand_blue" : "bg-$brand_pink";
  }
  const defaultProps = {
    onHide,
    show: false,
    mode: "pick",
    pickOkAction: void 0,
    modifyInitialSelectedIds: void 0,
    modifyOkAction: void 0
  };
  const {
    proxyProps,
    updateProps
  } = wrapComponent({
    Component: ModalFavManager,
    containerClassName: "ModalFavManager",
    defaultProps
  });
  const emitter = new Emittery();
  function onHide() {
    updateProps({
      show: false
    });
    emitter.emit("modal-close");
  }
  function useModalMoveFavVisible() {
    return useSnapshot(proxyProps).show;
  }
  async function startPickFavFolder(pickOkAction) {
    updateProps({
      show: true,
      mode: "pick",
      pickOkAction
    });
    await emitter.once("modal-close");
  }
  async function startModifyFavItemToFolder(srcFolderIds, modifyOkAction, modifyAllowEmpty = true) {
    updateProps({
      show: true,
      mode: "modify",
      modifyInitialSelectedIds: srcFolderIds,
      modifyOkAction,
      modifyAllowEmpty
    });
    await emitter.once("modal-close");
  }
  async function handleModifyFavItemToFolder(avid, sourceFolderIds, targetFolder) {
    if (isEqual$2(sourceFolderIds, [targetFolder?.id])) {
      antMessage.warning("请选择不同的收藏夹!");
      return false;
    }
    const success = await UserFavApi.modifyFav(avid, sourceFolderIds, targetFolder?.id);
    if (!success) return false;
    const clearQueue = [...sourceFolderIds ?? [], targetFolder?.id].filter((x) => x !== void 0);
    clearQueue.forEach((fid) => clearFavFolderAllItemsCache(fid));
    let message2;
    if (!targetFolder) {
      message2 = "已取消收藏";
    } else {
      const prefix2 = sourceFolderIds?.length ? "已移动收藏到" : "已加入收藏";
      message2 = `${prefix2}「${targetFolder.title}」`;
    }
    antMessage.success(message2);
    return true;
  }
  var observerMap = new Map();
  var RootIds = new WeakMap();
  var rootId = 0;
  var unsupportedValue;
  function getRootId(root2) {
    if (!root2) return "0";
    if (RootIds.has(root2)) return RootIds.get(root2);
    rootId += 1;
    RootIds.set(root2, rootId.toString());
    return RootIds.get(root2);
  }
  function optionsToId(options) {
    return Object.keys(options).sort().filter(
      (key) => options[key] !== void 0
    ).map((key) => {
      return `${key}_${key === "root" ? getRootId(options.root) : options[key]}`;
    }).toString();
  }
  function createObserver(options) {
    const id2 = optionsToId(options);
    let instance = observerMap.get(id2);
    if (!instance) {
      const elements = new Map();
      let thresholds;
      const observer2 = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          var _a2;
          const inView = entry.isIntersecting && thresholds.some((threshold) => entry.intersectionRatio >= threshold);
          if (options.trackVisibility && typeof entry.isVisible === "undefined") {
            entry.isVisible = inView;
          }
          [...(_a2 = elements.get(entry.target)) != null ? _a2 : []].forEach((callback) => {
            callback(inView, entry);
          });
        });
      }, options);
      thresholds = observer2.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);
      instance = {
        id: id2,
        observer: observer2,
        elements
      };
      observerMap.set(id2, instance);
    }
    return instance;
  }
  function observe(element, callback, options = {}, fallbackInView = unsupportedValue) {
    if (typeof window.IntersectionObserver === "undefined" && fallbackInView !== void 0) {
      const bounds = element.getBoundingClientRect();
      callback(fallbackInView, {
        isIntersecting: fallbackInView,
        target: element,
        intersectionRatio: typeof options.threshold === "number" ? options.threshold : 0,
        time: 0,
        boundingClientRect: bounds,
        intersectionRect: bounds,
        rootBounds: bounds
      });
      return () => {
      };
    }
    const { id: id2, observer: observer2, elements } = createObserver(options);
    const callbacks = elements.get(element) || [];
    if (!elements.has(element)) {
      elements.set(element, callbacks);
    }
    callbacks.push(callback);
    observer2.observe(element);
    return function unobserve2() {
      callbacks.splice(callbacks.indexOf(callback), 1);
      if (callbacks.length === 0) {
        elements.delete(element);
        observer2.unobserve(element);
      }
      if (elements.size === 0) {
        observer2.disconnect();
        observerMap.delete(id2);
      }
    };
  }
  function useInView({
    threshold,
    delay: delay2,
    trackVisibility,
    rootMargin,
    root: root2,
    triggerOnce,
    skip,
    initialInView,
    fallbackInView,
    onChange
  } = {}) {
    var _a2;
    const [ref2, setRef2] = reactExports.useState(null);
    const callback = reactExports.useRef(onChange);
    const lastInViewRef = reactExports.useRef(initialInView);
    const [state2, setState] = reactExports.useState({
      inView: !!initialInView,
      entry: void 0
    });
    callback.current = onChange;
    reactExports.useEffect(
      () => {
        if (lastInViewRef.current === void 0) {
          lastInViewRef.current = initialInView;
        }
        if (skip || !ref2) return;
        let unobserve2;
        unobserve2 = observe(
          ref2,
          (inView, entry) => {
            const previousInView = lastInViewRef.current;
            lastInViewRef.current = inView;
            if (previousInView === void 0 && !inView) {
              return;
            }
            setState({
              inView,
              entry
            });
            if (callback.current) callback.current(inView, entry);
            if (entry.isIntersecting && triggerOnce && unobserve2) {
              unobserve2();
              unobserve2 = void 0;
            }
          },
          {
            root: root2,
            rootMargin,
            threshold,
trackVisibility,
            delay: delay2
          },
          fallbackInView
        );
        return () => {
          if (unobserve2) {
            unobserve2();
          }
        };
      },

[
Array.isArray(threshold) ? threshold.toString() : threshold,
        ref2,
        root2,
        rootMargin,
        triggerOnce,
        skip,
        trackVisibility,
        fallbackInView,
        delay2
      ]
    );
    const entryTarget = (_a2 = state2.entry) == null ? void 0 : _a2.target;
    const previousEntryTarget = reactExports.useRef(void 0);
    if (!ref2 && entryTarget && !triggerOnce && !skip && previousEntryTarget.current !== entryTarget) {
      previousEntryTarget.current = entryTarget;
      setState({
        inView: !!initialInView,
        entry: void 0
      });
      lastInViewRef.current = initialInView;
    }
    const result = [setRef2, state2.inView, state2.entry];
    result.ref = result[0];
    result.inView = result[1];
    result.entry = result[2];
    return result;
  }
  function isEmptyFragment(fragment) {
    const fragChildren = reactExports.Children.toArray(fragment.props?.children);
    return !fragChildren.length;
  }
  function useRefState(initialValue2) {
    const [state2, setState] = reactExports.useState(initialValue2);
    const ref2 = reactExports.useRef(state2);
    const setStateWraped = reactExports.useCallback((payload) => {
      const nextState = typeof payload === "function" ? payload(ref2.current) : payload;
      ref2.current = nextState;
      setState(nextState);
    }, [setState]);
    const getState = reactExports.useCallback(() => ref2.current, []);
    return [state2, setStateWraped, getState];
  }
  function useRefStateBox(initialValue2) {
    const [state2, set2, get2] = useRefState(initialValue2);
    const box2 = reactExports.useMemo(() => ({
      state: state2,
get: get2,
      set: set2,
      get val() {
        return get2();
      },
      set val(newValue) {
        set2(newValue);
      }
    }), [get2, set2]);
    box2.state = state2;
    return box2;
  }
  function useRefBox(initialValue2) {
    const ref2 = reactExports.useRef(initialValue2);
    const get2 = reactExports.useCallback(() => ref2.current, []);
    const set2 = reactExports.useCallback((newValue) => ref2.current = newValue, []);
    return reactExports.useMemo(() => ({
      get: get2,
      set: set2,
      get val() {
        return get2();
      },
      set val(newValue) {
        set2(newValue);
      }
    }), [get2, set2]);
  }
  function Picture({
    src,
    avif,
    webp,
    imgProps,
    className,
    ...props
  }) {
    avif ??= !isSafari;
    webp ??= true;
    return jsxs("picture", { className: r("h-full w-full object-cover", className), ...props, children: [
      avif && jsx$1("source", { srcSet: `${src}.avif`, type: "image/avif" }),
      webp && jsx$1("source", { srcSet: `${src}.webp`, type: "image/webp" }),
jsx$1("img", { src, loading: "lazy", className: "block h-full w-full", ...imgProps })
    ] });
  }
  const dislikedMap = proxyMap();
  function useDislikedReason(id2) {
    const map = useSnapshot(dislikedMap);
    return id2 ? map.get(id2) : void 0;
  }
  function delDisliked(id2) {
    dislikedMap.delete(id2);
  }
  function calcRecItemDislikedMapKey(item) {
    if (isAppRecommend(item)) return item.param;
    if (isPcRecommend(item)) return item.id.toString();
  }
  const win = typeof unsafeWindow !== "undefined" ? unsafeWindow : globalThis;
  const setGlobalValue = (key, val) => void attempt(() => win[key] = val);
  const gridItemsKey = `${APP_KEY_PREFIX}_gridItems`;
  function setGlobalGridItems(itemsWithSep) {
    const items = itemsWithSep.filter((x) => x.api !== EApiType.Separator);
    setCurrentGridItems(items);
    setGlobalValue(gridItemsKey, items);
  }
  const BIND_TO_UNSAFE_WINDOW_FNS = {
    getGenericCardDatas,
    copyBvidsSingleLine,
    copyBvidInfos
  };
  setTimeout(() => {
    Object.entries(BIND_TO_UNSAFE_WINDOW_FNS).forEach(([fnName, fn]) => {
      setGlobalValue(`${APP_KEY_PREFIX}_${fnName}`, fn);
    });
  });
  function useInFilterByAuthorList(authorMid) {
    const {
      enabled: enabled2,
      keywords
    } = useSnapshot(settings.filter.byAuthor);
    const {
      blockUpMids
    } = reactExports.useMemo(() => parseFilterByAuthor(keywords), [keywords]);
    if (!authorMid) return false;
    return enabled2 && blockUpMids.has(authorMid);
  }
  var domTarget = {};
  var utils = {};
  var _typeof = { exports: {} };
  var hasRequired_typeof;
  function require_typeof() {
    if (hasRequired_typeof) return _typeof.exports;
    hasRequired_typeof = 1;
    (function(module) {
      function _typeof2(o2) {
        "@babel/helpers - typeof";
        return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
          return typeof o3;
        } : function(o3) {
          return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o2);
      }
      module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(_typeof);
    return _typeof.exports;
  }
  var hasRequiredUtils;
  function requireUtils() {
    if (hasRequiredUtils) return utils;
    hasRequiredUtils = 1;
    var _interopRequireDefault = requireInteropRequireDefault();
    Object.defineProperty(utils, "__esModule", {
      value: true
    });
    utils.isUndef = utils.isString = utils.isObject = utils.isNumber = utils.isFunction = utils.isBoolean = void 0;
    var _typeof2 = _interopRequireDefault(require_typeof());
    utils.isObject = function isObject2(value) {
      return value !== null && (0, _typeof2["default"])(value) === "object";
    };
    utils.isFunction = function isFunction2(value) {
      return typeof value === "function";
    };
    utils.isString = function isString2(value) {
      return typeof value === "string";
    };
    utils.isBoolean = function isBoolean(value) {
      return typeof value === "boolean";
    };
    utils.isNumber = function isNumber2(value) {
      return typeof value === "number";
    };
    utils.isUndef = function isUndef(value) {
      return typeof value === "undefined";
    };
    return utils;
  }
  var isBrowser = {};
  var hasRequiredIsBrowser;
  function requireIsBrowser() {
    if (hasRequiredIsBrowser) return isBrowser;
    hasRequiredIsBrowser = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", {
        value: true
      });
      exports$1["default"] = void 0;
      var isBrowser2 = !!(typeof window !== "undefined" && window.document && window.document.createElement);
      exports$1["default"] = isBrowser2;
    })(isBrowser);
    return isBrowser;
  }
  var hasRequiredDomTarget;
  function requireDomTarget() {
    if (hasRequiredDomTarget) return domTarget;
    hasRequiredDomTarget = 1;
    var _interopRequireDefault = requireInteropRequireDefault();
    Object.defineProperty(domTarget, "__esModule", {
      value: true
    });
    domTarget.getTargetElement = getTargetElement2;
    var _index = requireUtils();
    var _isBrowser = _interopRequireDefault( requireIsBrowser());
    function getTargetElement2(target, defaultElement) {
      if (!_isBrowser["default"]) {
        return void 0;
      }
      if (!target) {
        return defaultElement;
      }
      var targetElement;
      if ((0, _index.isFunction)(target)) {
        targetElement = target();
      } else if ("current" in target) {
        targetElement = target.current;
      } else {
        targetElement = target;
      }
      return targetElement;
    }
    return domTarget;
  }
  var domTargetExports = requireDomTarget();
  async function getVideoPlayUrl(videoId, cid, useMp4 = false, usePreferredCdn = false) {
    const params = {
      cid,
      fnver: 0,
      fnval: useMp4 ? 1 : 16
};
    const _videoId = videoId.toString();
    if (_videoId.startsWith("BV")) {
      params.bvid = _videoId;
    } else if (/^\d+$/.test(_videoId)) {
      params.avid = _videoId;
    } else {
      throw new Error("Invalid videoId provided, must be avid | bvid");
    }
    const res = await request.get("/x/player/wbi/playurl", {
      params
    });
    const json = res.data;
    function reOrderUrls(urls) {
      return fastOrderBy(urls, [(u2) => getUrlPriority(u2, usePreferredCdn)], ["desc"]);
    }
    if (json?.data?.durl) {
      const urls = (json.data.durl || []).map((x) => [x.url, ...x.backup_url || []]).flat().filter(Boolean);
      if (urls.length) return reOrderUrls(urls);
    }
    const video = fastOrderBy(json.data?.dash?.video || [], ["id", "codecid"], ["desc", "desc"]);
    const dashUrls = video.map((x) => reOrderUrls([x.baseUrl, ...x.backupUrl || []])[0]).filter(Boolean);
    return dashUrls;
  }
  function getUrlPriority(url2, usePreferredCdn) {
    if (!usePreferredCdn) return 10;
    const {
      hostname: hostname2,
      searchParams: searchParams2,
      pathname: pathname2
    } = new URL(url2);
    if (hostname2.includes("mcdn") || searchParams2.get("os") === "mcdn") return 2;
    if (pathname2.startsWith("/v1/resource/")) return 1;
    if (hostname2.includes("-mirror")) return 100;
    return 10;
  }
  function isVideoshotDataValid(videoshotData) {
    return Boolean(videoshotData?.image?.length && videoshotData?.index?.length);
  }
  function isVideoshotJsonCacheable(json) {
    const success = isWebApiSuccess(json);
    if (!success) {
      return true;
    } else {
      return isVideoshotDataValid(json.data);
    }
  }
  async function __fetchVideoshotJson(bvid) {
    const res = await request.get("/x/player/videoshot", {
      params: {
        bvid,
        index: "1"
      }
    });
    const json = res.data;
    if (!isWebApiSuccess(json)) {
      appWarn("videoshot error for %s: %o", bvid, json);
    }
    if (!isVideoshotDataValid(json.data)) {
      appWarn("videoshot data invalid bvid=%s: %o", bvid, json.data);
    }
    return json;
  }
  const videoshotCache = new QuickLRU({
    maxSize: 1e4
  });
  const getVideoshotJson = reusePendingPromise(async (bvid) => {
    if (videoshotCache.has(bvid)) {
      const cached2 = videoshotCache.get(bvid);
      if (cached2) return cached2;
    }
    const MAX_RETRY = 5;
    const DELAY = 200;
    let retryTimes = 0;
    let videoshotJson;
    do {
      retryTimes++;
      videoshotJson = await __fetchVideoshotJson(bvid);
      if (isVideoshotJsonCacheable(videoshotJson)) {
        break;
      } else {
        await delay$1(DELAY);
      }
    } while (retryTimes < MAX_RETRY);
    if (isVideoshotJsonCacheable(videoshotJson)) {
      videoshotCache.set(bvid, videoshotJson);
    }
    const videoshotData = videoshotJson.data;
    if (settings.videoCard.imgPreview.autoPreviewWhenHover) {
      const imgs = videoshotData?.image || [];
      await preloadImg(imgs[0]);
      (async () => {
        for (const src of imgs.slice(1)) {
          await preloadImg(src);
        }
      })();
    }
    return videoshotJson;
  });
  const debug$5 = baseDebug.extend("VideoCard:services");
  function watchlaterFactory(action2) {
    return async function watchlaterOp(avid) {
      const form = new URLSearchParams({
        aid: avid,
        csrf: getCsrfToken()
      });
      const res = await request.post(`/x/v2/history/toview/${action2}`, form);
      const json = res.data;
      const success = isWebApiSuccess(json);
      if (!success) {
        toast(json?.message || "出错了");
      }
      return success;
    };
  }
  const watchlaterAdd = watchlaterFactory("add");
  const watchlaterDel = watchlaterFactory("del");
  async function fetchImagePreviewData(bvid) {
    const videoshotJson = await getVideoshotJson(bvid);
    return {
      videoshotJson
    };
  }
  function isImagePreviewDataValid(data2) {
    return isVideoshotDataValid(data2?.videoshotJson?.data);
  }
  const isVideoPreviewDataValid = (data2) => {
    return !!data2?.playUrls?.length;
  };
  const videoPreviewCache = new QuickLRU({
    maxSize: 1e4,
    maxAge: ms("1h")
  });
  const fetchVideoPreviewData = reusePendingPromise(async ({
    bvid,
    cid,
    useMp4,
    usePreferredCdn,
    aspectRatioFromItem
  }) => {
    const cacheKey2 = JSON.stringify([bvid, useMp4, usePreferredCdn]);
    const cached2 = videoPreviewCache.get(cacheKey2);
    if (cached2) return cached2;
    let dimension;
    if (cid === void 0 || aspectRatioFromItem === void 0) {
      const pages = await getVideoPageList(bvid);
      cid = pages[0]?.cid;
      dimension = pages[0]?.dimension;
      if (cid === void 0) {
        throw new TypeError(`can not get cid by bvid=${bvid}`);
      }
    }
    const [err, playUrls] = await attemptAsync(() => getVideoPlayUrl(bvid, cid, useMp4, usePreferredCdn));
    debug$5("playUrl: bvid=%s cid=%s %s", bvid, cid, playUrls);
    if (err) {
      antNotification.error({
        title: "获取视频播放地址失败",
        description: err.message || err
      });
      throw err;
    }
    if (playUrls?.length) {
      videoPreviewCache.set(cacheKey2, {
        playUrls,
        dimension
      });
    }
    return {
      playUrls: playUrls ?? void 0,
      dimension
    };
  });
  const debug$4 = baseDebug.extend("VideoCard:LargePreview");
  const DirectionConfig = {
    right: {
      multiplier: 1,
      axis: "x",
      reverse: "left"
    },
    left: {
      multiplier: -1,
      axis: "x",
      reverse: "right"
    },
    bottom: {
      multiplier: 1,
      axis: "y",
      reverse: "top"
    },
    top: {
      multiplier: -1,
      axis: "y",
      reverse: "bottom"
    }
  };
  const VisualPadding = {
    border: 40,
    card: 10
  };
  function getCoverRect(anchorElement) {
    return anchorElement?.closest(classListToSelector(APP_CLS_CARD, "bili-video-card"))?.querySelector(classListToSelector(APP_CLS_CARD_COVER, "bili-video-card__image"))?.getBoundingClientRect();
  }
  const LargePreview = reactExports.memo(function LargePreview2({
    children,
    aspectRatio: aspectRatio2 = 1.7777777777777777,
    cardDescendantTarget,
    ref: propRef,
    ...restProps
  }) {
    const popoverRef = useDelegatedRef(propRef);
    const [visible, setVisible] = reactExports.useState(false);
    const [position2, setPosition] = reactExports.useState(void 0);
    const hide = useMemoizedFn(() => {
      setVisible(false);
      setPosition(void 0);
    });
    const calculatePostion = useMemoizedFn(() => {
      const cardCoverRect = getCoverRect(domTargetExports.getTargetElement(cardDescendantTarget) ?? void 0);
      if (!cardCoverRect) return hide();
      const [viewportWidth, viewportHeight] = [document.documentElement.clientWidth, document.documentElement.clientHeight];
      const tolerance = 40;
      if (cardCoverRect.top > viewportHeight - tolerance || cardCoverRect.bottom < 0 + tolerance || cardCoverRect.left > viewportWidth - tolerance || cardCoverRect.right < 0 + tolerance) {
        return hide();
      }
      const possibleBoundingBox = {
        top: {
          x: 0,
          y: 0,
          width: viewportWidth,
          height: cardCoverRect.top
        },
        bottom: {
          x: 0,
          y: cardCoverRect.bottom,
          width: viewportWidth,
          height: viewportHeight - cardCoverRect.bottom
        },
        left: {
          x: 0,
          y: 0,
          width: cardCoverRect.left,
          height: viewportHeight
        },
        right: {
          x: cardCoverRect.right,
          y: 0,
          width: viewportWidth - cardCoverRect.right,
          height: viewportHeight
        }
      };
      const getScaleInBox = (bbox2) => {
        const w = aspectRatio2;
        const h2 = 1;
        const scaleX2 = bbox2.width / w;
        const scaleY2 = bbox2.height / h2;
        const scale22 = Math.min(scaleX2, scaleY2);
        return {
          scale: scale22,
          scaleLimit: scaleX2 > scaleY2 ? "height" : "width"
        };
      };
      const picked = orderBy(Object.entries(possibleBoundingBox).map(([direction2, bbox2]) => ({
        direction: direction2,
        bbox: bbox2,
        ...getScaleInBox(bbox2)
      })), ["scale", (x) => {
        switch (x.direction) {
          case "top":
            return cardCoverRect.top;
          case "bottom":
            return viewportHeight - cardCoverRect.bottom;
          case "left":
            return cardCoverRect.left;
          case "right":
            return viewportWidth - cardCoverRect.right;
        }
      }], ["desc", "desc"])[0];
      debug$4("picked direction", picked);
      const {
        direction,
        bbox,
        scale: scale2,
        scaleLimit
      } = picked;
      let elWidth;
      let elHeight;
      if (scaleLimit === "width") {
        elWidth = Math.floor(bbox.width - (VisualPadding.card + VisualPadding.border));
        elHeight = elWidth / aspectRatio2;
      } else if (scaleLimit === "height") {
        elHeight = Math.floor(bbox.height - (VisualPadding.card + VisualPadding.border));
        elWidth = elHeight * aspectRatio2;
      } else {
        throw new Error("unexpected scaleLimit");
      }
      let elPosX = 0;
      let elPosY = 0;
      let arrowTop = 0;
      let arrowLeft = 0;
      const setArrowTop = () => {
        arrowTop = cardCoverRect.y + cardCoverRect.height / 2 - elPosY;
      };
      const setArrowLeft = () => {
        arrowLeft = cardCoverRect.x + cardCoverRect.width / 2 - elPosX;
      };
      const fixX = () => {
        if (elPosX < VisualPadding.border) {
          elPosX = VisualPadding.border;
          return;
        }
        if (elPosX + elWidth > viewportWidth - VisualPadding.border) {
          elPosX = viewportWidth - VisualPadding.border - elWidth;
          return;
        }
      };
      const fixY = () => {
        if (elPosY < VisualPadding.border) {
          elPosY = VisualPadding.border;
          return;
        }
        if (elPosY + elHeight > viewportHeight - VisualPadding.border) {
          elPosY = viewportHeight - VisualPadding.border - elHeight;
          return;
        }
      };
      switch (direction) {
        case "top":
          elPosX = cardCoverRect.x + cardCoverRect.width / 2 - elWidth / 2;
          elPosY = cardCoverRect.top - VisualPadding.card - elHeight;
          fixX();
          setArrowLeft();
          break;
        case "bottom":
          elPosX = cardCoverRect.x + cardCoverRect.width / 2 - elWidth / 2;
          elPosY = cardCoverRect.bottom + VisualPadding.card;
          fixX();
          setArrowLeft();
          break;
        case "right":
          elPosX = cardCoverRect.right + VisualPadding.card;
          elPosY = cardCoverRect.y + cardCoverRect.height / 2 - elHeight / 2;
          fixY();
          setArrowTop();
          break;
        case "left":
          elPosX = cardCoverRect.left - VisualPadding.card - elWidth;
          elPosY = cardCoverRect.y + cardCoverRect.height / 2 - elHeight / 2;
          fixY();
          setArrowTop();
          break;
      }
      elPosX = Math.floor(elPosX);
      elPosY = Math.floor(elPosY);
      setVisible(true);
      setPosition({
        direction,
        elWidth,
        elHeight,
        elPosX,
        elPosY,
        arrowTop,
        arrowLeft
      });
    });
    const calculatePostionThrottled = reactExports.useMemo(() => throttle$2(calculatePostion, 100), [calculatePostion]);
    useMount(calculatePostionThrottled);
    useEventListener("resize", calculatePostionThrottled, {
      target: window
    });
    useEventListener("scroll", calculatePostionThrottled, {
      target: window
    });
    const {
      useScale
    } = useSettingsSnapshot().videoCard.videoPreview;
    const animationDuration = useScale ? 0.2 : 0.3;
    const initial = reactExports.useMemo(() => {
      const direction = position2?.direction;
      if (!direction) return;
      const {
        axis,
        multiplier,
        reverse
      } = DirectionConfig[direction];
      if (!useScale) {
        let animateDistance = 30;
        if (direction === "top") animateDistance = 20;
        if (axis === "x") {
          return {
            x: -multiplier * animateDistance,
            y: 0
          };
        } else {
          return {
            x: 0,
            y: -multiplier * animateDistance
          };
        }
      } else if (axis === "x") {
        return {
          scale: 0.5,
          transformOrigin: `${reverse} ${position2.arrowTop}px`
        };
      } else {
        return {
          scale: 0.5,
          transformOrigin: `${position2.arrowLeft}px ${reverse}`
        };
      }
    }, [position2, useScale]);
    const popoverEl = jsx$1("div", { ...restProps, ref: popoverRef, className: clsx("fixed", clsZVideoCardLargePreview, visible ? "block" : "hidden"), css: position2 && css("width:", position2.elWidth, "px;height:", position2.elHeight, "px;top:", position2.elPosY, "px;left:", position2.elPosX, "px;", ""), children: visible && jsxs(motion.div, { className: "relative h-100%", initial: {
      opacity: 0,
      ...initial
    }, animate: {
      opacity: 1,
      x: 0,
      y: 0,
      scale: 1
    }, transition: {
      bounce: 0,
      duration: animationDuration
    }, children: [
      position2?.direction && jsx$1(PopoverArrow, { size: 7, direction: position2.direction, arrowTop: position2.arrowTop, arrowLeft: position2.arrowLeft }),
jsx$1("div", { className: "h-full overflow-hidden rounded-20px bg-white/50% backdrop-blur-10px", css: css("box-shadow:0px 0px 1px 1px ", appPrimaryColorValue, ";", ""), children })
    ] }) });
    return popoverEl;
  });
  function PopoverArrow({
    size,
    direction,
    arrowTop,
    arrowLeft
  }) {
    const {
      axis,
      multiplier,
      reverse
    } = DirectionConfig[direction];
    const extra = reactExports.useMemo(() => {
      if (axis === "x") {
        return css`
        ${direction}: 100%;
        margin-${direction}: -1px;
        top: ${arrowTop}px;
        margin-top: -${size / 2}px;
      `;
      } else {
        return css`
        ${direction}: 100%;
        margin-${direction}: -1px;
        left: ${arrowLeft}px;
        margin-left: -${size / 2}px;
      `;
      }
    }, [size, direction, axis, arrowTop, arrowLeft]);
    return jsx$1("div", { className: "absolute box-content h-0 w-0", css: [ css("border:", size, "px solid transparent;", ""), extra, css`
          border-${direction}-color: ${appPrimaryColorValue};
        `, "", ""] });
  }
  const store = await( proxyWithGmStorage({
    volume: void 0,
muted: void 0
  }, "large-preview-store"));
  const RecoverableVideo = function({
    currentTimeRef,
    ref: propRef,
    ...videoProps
  }) {
    const ref2 = useDelegatedRef(propRef);
    const mountedRef = reactExports.useRef(false);
    useMount(() => {
      if (ref2.current) {
        if (typeof currentTimeRef.current === "number") {
          ref2.current.currentTime = currentTimeRef.current;
        }
        if (typeof store.volume === "number") {
          ref2.current.volume = store.volume;
        }
        if (typeof store.muted === "boolean") {
          ref2.current.muted = store.muted;
        }
      }
      mountedRef.current = true;
    });
    const onTimeUpdate = useMemoizedFn(() => {
      if (!mountedRef.current) return;
      currentTimeRef.current = ref2.current?.currentTime;
    });
    const onVolumeChange = useMemoizedFn(() => {
      if (!mountedRef.current) return;
      if (!ref2.current) return;
      store.volume = ref2.current.volume;
      store.muted = ref2.current.muted;
    });
    return jsx$1("video", { ref: ref2, ...videoProps, onTimeUpdate, onVolumeChange });
  };
  const iconParkOutlinePin = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, d: "M10.696 17.504c2.639-2.638 5.774-2.565 9.182-.696L32.62 9.745l-.721-4.958L43.213 16.1l-4.947-.71l-7.074 12.73c1.783 3.638 1.942 6.544-.697 9.182l-7.778-7.778L6.443 41.556l11.995-16.31z" })
  ] });
  const ForwardRef$c = reactExports.forwardRef(iconParkOutlinePin);
  const iconParkOutlineVideoTwo = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M39 6H9a3 3 0 0 0-3 3v30a3 3 0 0 0 3 3h30a3 3 0 0 0 3-3V9a3 3 0 0 0-3-3" }),
jsx$1("path", { d: "M20.5 28v-6.062l5.25 3.03L31 28l-5.25 3.031l-5.25 3.031zM6 15h36m-9-9l-6 9m-6-9l-6 9" })
    ] })
  ] });
  const ForwardRef$b = reactExports.forwardRef(iconParkOutlineVideoTwo);
  function clearTimerRef(timerRef) {
    if (timerRef.current === void 0) return;
    clearTimeout(timerRef.current);
    timerRef.current = void 0;
  }
  function useLargePreviewRelated({
shouldFetchPreviewData,
hasLargePreviewActionButton,
    actionButtonVisible,
    actionButtonProps,
    actionButtonCss,
bvid,
    cid,
    uniqId,
    recSharedEmitter,
    cardTarget,
aspectRatioFromItem,
    cover,
    videoCardAsTriggerRef
  }) {
    const {
      useMp4,
      useVideoCardAsTrigger,
      usePreferredCdn
    } = useSnapshot(settings.videoCard.videoPreview);
    const videoPreviewDataBox = useRefStateBox(void 0);
    const tryFetchVideoPreviewData = useLockFn(async () => {
      if (!shouldFetchPreviewData) return;
      if (isVideoPreviewDataValid(videoPreviewDataBox.val)) return;
      const data2 = await fetchVideoPreviewData({
        bvid,
        cid,
        useMp4,
        usePreferredCdn,
        aspectRatioFromItem
      });
      videoPreviewDataBox.set(data2);
    });
    useUpdateEffect(() => {
      videoPreviewDataBox.set(void 0);
    }, [useMp4, usePreferredCdn]);
    const $req = useRequest(tryFetchVideoPreviewData, {
      manual: true,
      loadingDelay: 100
});
    const [visible, setVisible] = reactExports.useState(false);
    const triggerAction = useRefStateBox(void 0);
    const triggerElement = useRefStateBox(void 0);
    const hideAt = useRefStateBox(void 0);
    const hoveringRef = useRefBox({});
    const isRecentlyHidden = useMemoizedFn(() => {
      if (!hideAt.val) return false;
      return Date.now() - hideAt.val < 1200;
    });
    const enterTimer = reactExports.useRef(void 0);
    const leaveTimer = reactExports.useRef(void 0);
    const clearTimers = useMemoizedFn(() => {
      clearTimerRef(enterTimer);
      clearTimerRef(leaveTimer);
    });
    const showBy = useMemoizedFn((action2, el) => {
      setVisible(true);
      triggerAction.set(action2);
      triggerElement.set(el);
      recSharedEmitter.emit("show-large-preview", uniqId);
      hideAt.set(void 0);
    });
    const hide = useMemoizedFn(() => {
      setVisible(false);
      triggerAction.set(void 0);
      triggerElement.set(void 0);
      hideAt.set(Date.now());
    });
    useEmitterOn(recSharedEmitter, "show-large-preview", (srcUniqId) => {
      if (srcUniqId === uniqId) return;
      clearTimers();
      hide();
    });
    const onMouseEnter = useMemoizedFn((triggerEl) => {
      hoveringRef.set({
        ...hoveringRef.val,
        [triggerEl]: true
      });
      if (triggerAction.val === "click") return;
      $req.run();
      clearTimers();
      let delayMs = 0;
      if (triggerEl === "video-card-action-button") delayMs = 200;
      if (triggerEl === "video-card") delayMs = 1e3;
      if (!delayMs) {
        showBy("hover", triggerEl);
      } else {
        enterTimer.current = setTimeout(() => showBy("hover", triggerEl), delayMs);
      }
    });
    const onMouseLeave = useMemoizedFn((triggerEl) => {
      hoveringRef.set({
        ...hoveringRef.val,
        [triggerEl]: false
      });
      if (triggerAction.val === "click") return;
      const checkHide = () => {
        if (hoveringRef.val.popover) return;
        if (hoveringRef.val["video-card-action-button"]) return;
        hide();
      };
      clearTimers();
      if (triggerEl === "video-card-action-button" || triggerEl === "video-card" || triggerEl === "popover") {
        leaveTimer.current = setTimeout(checkHide, 250);
      } else {
        checkHide();
      }
    });
    const onClick = useMemoizedFn((el) => {
      clearTimers();
      if (triggerAction.val === "click") {
        hide();
      } else {
        showBy("click", el);
      }
    });
    const getLargePreviewCurrentTime = useMemoizedFn(() => {
      if (!currentTimeRef.current) return;
      return Math.floor(currentTimeRef.current);
    });
    const shouldUseLargePreviewCurrentTime = useMemoizedFn(() => {
      if (visible) return true;
      if (isRecentlyHidden()) return true;
      return false;
    });
    const onOpenInNewTab = useMemoizedFn(() => {
      if (!bvid) return;
      const u2 = new URL(`https://${BiliDomain.Main}/video/${bvid}`);
      const t2 = getLargePreviewCurrentTime();
      if (t2) u2.searchParams.set("t", t2.toString());
      openNewTab(u2.href);
      videoRef.current?.pause();
      hide();
    });
    const usingAspectRatio = reactExports.useMemo(() => {
      return getRecItemDimension({
        dimensionFromApi: videoPreviewDataBox.state?.dimension
      })?.aspectRatio ?? aspectRatioFromItem;
    }, [videoPreviewDataBox.state?.dimension]);
    const videoRef = reactExports.useRef(null);
    const currentTimeRef = reactExports.useRef(void 0);
    const largePreviewRef = reactExports.useRef(null);
    const willRenderLargePreview = visible && !!videoPreviewDataBox.state?.playUrls?.length;
    const largePreviewEl = willRenderLargePreview && jsxs(LargePreview, { ref: largePreviewRef, aspectRatio: usingAspectRatio, onMouseEnter: (e) => onMouseEnter("popover"), onMouseLeave: (e) => onMouseLeave("popover"), cardDescendantTarget: cardTarget, children: [
jsx$1(
        RecoverableVideo,
        {
          ref: videoRef,
          currentTimeRef,
          autoPlay: true,
          controls: true,
          loop: true,
          poster: cover,
          className: "size-full object-contain",
          children: videoPreviewDataBox.state?.playUrls?.map((url2, i2) => jsx$1("source", { src: url2 }, i2))
        }
      ),
jsxs("div", { className: "absolute right-10px top-10px flex flex-row-reverse items-center justify-start gap-x-5px", children: [
        triggerAction.state === "click" ? jsx$1(VideoCardActionButton, { inlinePosition: "right", icon: jsx$1(ForwardRef$u, { className: "size-14px" }), tooltip: "关闭", onClick: (e) => {
          e.preventDefault();
          e.stopPropagation();
          hide();
        } }) : jsx$1(VideoCardActionButton, { inlinePosition: "right", icon: jsx$1(ForwardRef$c, { className: "size-14px" }), tooltip: "固定", onClick: (e) => {
          e.preventDefault();
          e.stopPropagation();
          onClick("popover-action-button");
        } }),
jsx$1(VideoCardActionButton, { inlinePosition: "right", icon: jsx$1(ForwardRef$v, { className: "size-14px" }), tooltip: "新窗口打开", onClick: (e) => {
          e.preventDefault();
          e.stopPropagation();
          onOpenInNewTab();
        } })
      ] })
    ] });
    const largePreviewActionButtonEl = hasLargePreviewActionButton && shouldFetchPreviewData && jsx$1(VideoCardActionButton, { css: actionButtonCss, ...actionButtonProps, visible: actionButtonVisible, active: willRenderLargePreview, inlinePosition: "right", icon: $req.loading ? jsx$1(IconForLoading, { className: "size-16px" }) : jsx$1(ForwardRef$b, { className: "size-15px" }), tooltip: triggerAction.state === "click" ? visible ? "关闭浮动预览" : "浮动预览" : "浮动预览", onMouseEnter: (e) => onMouseEnter("video-card-action-button"), onMouseLeave: (e) => onMouseLeave("video-card-action-button"), onClick: (e) => {
      e.preventDefault();
      e.stopPropagation();
      onClick("video-card-action-button");
    } }, "video-card-action-button");
    useKeyPress$2("esc", () => {
      if (shouldDisableShortcut()) return;
      hide();
    }, {
      exactMatch: true
    });
    useClickAway(() => hide(), [
      largePreviewRef,
() => domTargetExports.getTargetElement(cardTarget)?.closest(classListToSelector(APP_CLS_CARD, "bili-video-card"))
]);
    useEventListener("fullscreenchange", () => {
      if (!document.fullscreenElement) return;
      if (!visible || triggerAction.val === "click") return;
      if (document.fullscreenElement === videoRef.current) {
        showBy("click", "popover-video-fullscreen-button");
      }
    }, {
      target: document
    });
    const emptyRef = reactExports.useRef(null);
    const target = videoCardAsTriggerRef || emptyRef;
    useEventListener("mouseenter", () => {
      if (!useVideoCardAsTrigger || !videoCardAsTriggerRef) return;
      onMouseEnter("video-card");
    }, {
      target
    });
    useEventListener("mouseleave", () => {
      if (!useVideoCardAsTrigger || !videoCardAsTriggerRef) return;
      onMouseLeave("video-card");
    }, {
      target
    });
    return {
      largePreviewActionButtonEl,
      largePreviewEl,
      getLargePreviewCurrentTime,
      shouldUseLargePreviewCurrentTime,
      largePreviewVisible: visible,
      hideLargePreview: hide
    };
  }
  const c = tweakLightness(appPrimaryColorValue, 0.1);
  const Styles = {
    normalBorder: css("border-color:", appBorderColorValue, ";", ""),
    activeBorder: css("border-color:", appPrimaryColorValue, ";box-shadow:0px 0px 9px 4px ", c, ";", ""),
    rounded: css("border-radius:", videoCardBorderRadiusValue, ";", ""),
    bgLv1: css("background-color:", appBgLv1Value, ";", ""),
coverZoomEffect: {
      name: "dj03ws",
      styles: ".bili-video-card__cover{transform-origin:center center;transition:transform 0.2s ease-out;transform:scale(1.05);}"
    }
  };
  const multiSelectedCss = css(Styles.activeBorder, " &:hover{", Styles.activeBorder, ";}", "");
  function useBlockedCardCss(isBlockedCard) {
    const sepIdentifier = `--${APP_NAMESPACE}--separator-color`;
    return reactExports.useMemo(() => {
      if (!isBlockedCard) return;
      return css`
      ${Styles.rounded}
      ${Styles.normalBorder}

      background-color: ${appBgValue};
      ${sepIdentifier}:  ${appBgLv1Value};
      &:hover {
        background-color: ${appBgLv1Value};
        ${sepIdentifier}: ${appBgLv2Value};
      }

      /* disable padding */
      margin-inline: 0;
      .bili-video-card__wrap {
        padding: 0;
      }
    `;
    }, [isBlockedCard]);
  }
  var _ref$2 = {
    name: "7dle4o",
    styles: "border:1px solid transparent;transition-property:border-color,box-shadow,background-color;transition-duration:0.3s;transition-timing-function:ease-in-out"
  };
  function useCardBorderCss() {
    const {
      useDelayForHover,
      style: {
        videoCard: {
          useBorder,
          useBorderOnlyOnHover,
          useBoxShadow
        }
      }
    } = useSettingsSnapshot();
    const {
      multiSelecting
    } = useSnapshot(multiSelectStore);
    const displayingAsList = useIsDisplayAsList();
    return reactExports.useMemo(() => {
      return [_ref$2, (multiSelecting || useBorder && !displayingAsList) && [
css("cursor:pointer;", Styles.rounded, " &:hover{", Styles.bgLv1, " ", Styles.normalBorder, " ", useBoxShadow && Styles.activeBorder, " ", useDelayForHover && Styles.coverZoomEffect, ";}", ""),
(multiSelecting || !useBorderOnlyOnHover) && Styles.normalBorder
      ]];
    }, [useBorder, useBorderOnlyOnHover, useBoxShadow, useDelayForHover, displayingAsList, multiSelecting]);
  }
  function getActiveCardBorderCss(active) {
    return active && [Styles.rounded, Styles.activeBorder];
  }
  function appDislikeFactory(action2) {
    const pathname2 = {
      dislike: "/x/feed/dislike",
      cancel: "/x/feed/dislike/cancel"
    }[action2];
    return async function(item, reasonId) {
      const res = await gmrequest.get(HOST_APP + pathname2, {
        responseType: "json",
        params: {
          goto: item.goto,
          id: item.param,


reason_id: reasonId,
build: "1",
          mobi_app: "android",
          idx: (Date.now() / 1e3).toFixed(0)
        }
      });
      const json = res.data;
      const success = isWebApiSuccess(json);
      let message2 = json.message;
      if (!success) {
        message2 ||= OPERATION_FAIL_MSG;
        message2 += `(code ${json.code})`;
        message2 += "\n请重新获取 access_key 后重试";
      }
      return {
        success,
        json,
        message: message2
      };
    };
  }
  const appDislike = appDislikeFactory("dislike");
  const appCancelDislike = appDislikeFactory("cancel");
  function pcDislikeFactory(action2) {
    const pathname2 = {
      dislike: "/x/web-interface/feedback/dislike",
      cancel: "/x/web-interface/feedback/dislike/cancel"
    }[action2];
    return async function(item, reasonId) {
      const form = new URLSearchParams({
        app_id: "100",
        platform: "5",
        from_spmid: "",
        spmid: "333.1007.0.0",
        goto: item.goto,
        id: item.id.toString() || "0",
        mid: item.owner?.mid?.toString() || "0",
        track_id: item.track_id,
        feedback_page: "1",
        reason_id: reasonId.toString()
      });
      const res = await request.post(pathname2, form);
      const json = res.data;
      const success = isWebApiSuccess(json);
      const message2 = json?.message || REQUEST_FAIL_MSG;
      return {
        success,
        message: message2,
        json
      };
    };
  }
  const pcDislike = pcDislikeFactory("dislike");
  const pcCancelDislike = pcDislikeFactory("cancel");
  function handlerFactory(action2) {
    return async function(item, reason) {
      const {
        reasonId
      } = normalizeDislikeReason(reason);
      let err;
      let result;
      if (reason.platform === "app") {
        invariant$1(isAppRecommend(item), "expect app recommend");
        const fn = action2 === "dislike" ? appDislike : appCancelDislike;
        [err, result] = await attemptAsync(() => fn(item, reasonId));
      } else if (reason.platform === "pc") {
        invariant$1(isPcRecommend(item), "expect pc recommend");
        const fn = action2 === "dislike" ? pcDislike : pcCancelDislike;
        [err, result] = await attemptAsync(() => fn(item, reasonId));
      } else {
        assertNever(reason);
      }
      if (err || !result) {
        console.error(err?.stack || err);
        const message2 = err?.message;
        antMessage.error(message2);
        return false;
      }
      if (!result.success) {
        const message2 = result?.message || OPERATION_FAIL_MSG;
        antMessage.error(message2);
        return false;
      }
      const dislikeKey = calcRecItemDislikedMapKey(item);
      invariant$1(dislikeKey, "dislikeKey should not be empty");
      if (action2 === "dislike") {
        antMessage.success("已标记不想看");
        dislikedMap.set(dislikeKey, {
          ...reason
        });
      }
      if (action2 === "cancel") {
        antMessage.success("已撤销");
        delDisliked(dislikeKey);
      }
      return true;
    };
  }
  const handleDislike = handlerFactory("dislike");
  const handleCancelDislike = handlerFactory("cancel");
  const skeletonActive = "_skeleton-active_wlycr_12";
  function useInitFavContext(item, avid) {
    const [folderNames, setFolderNames] = reactExports.useState(void 0);
    const [folderUrls, setFolderUrls] = reactExports.useState(void 0);
    const [folderIds, setFolderIds] = reactExports.useState(void 0);
    const updateFavFolderNames = useMemoizedFn(async () => {
      if (!avid) return;
      const {
        enable: enableQuickFav
      } = getQuickFavConfig(item.api);
      if (!(enableQuickFav || isFav(item) && item.from === "fav-folder")) return;
      const result = await UserFavApi.getVideoFavState(avid);
      if (result) {
        setFolderNames(result.favFolderNames);
        setFolderUrls(result.favFolderUrls);
        setFolderIds(result.favFolderIds);
      }
    });
    return reactExports.useMemo(() => ({
      folderNames,
      folderUrls,
      folderIds,
      updateFavFolderNames
    }), [folderNames, folderUrls, folderIds, updateFavFolderNames]);
  }
  function getQuickFavConfig(api) {
    const enable2 = ![EApiType.Separator, EApiType.Live, EApiType.Fav].includes(api);
    const enableDetailMenu = api === EApiType.Watchlater || api === EApiType.Liked;
    return {
      enable: enable2,
      enableDetailMenu
    };
  }
  function getQuickFavMenus(ctx, item, avid) {
    if (!avid) return;
    const {
      enable: enable2,
      enableDetailMenu
    } = getQuickFavConfig(item.api);
    if (!enable2) return;
    const folderNames = ctx.folderNames ?? [];
    const folderUrls = ctx.folderUrls ?? [];
    const folderIds = ctx.folderIds ?? [];
    const favedMenus = defineAntMenus([{
key: "quick-fav:faved:modify-fav",
      icon: jsx$1(IconForFaved, { className: clsx(clsContextMenuIcon, "color-gate-primary") }),
      label: `已收藏在 ${(folderNames || []).map((n2) => `「${n2}」`).join("")}`,
      async onClick() {
        invariant$1(folderIds.length, "folderIds.length should not be empty");
        await startModifyFavItemToFolder(folderIds, (targetFolder) => {
          return handleModifyFavItemToFolder(avid, folderIds, targetFolder);
        });
      }
    }, {
test: enableDetailMenu,
      key: "quick-fav:faved:browse-fav-folder-in-self-space",
      icon: jsx$1(IconForOpenExternalLink, { className: clsContextMenuIcon }),
      label: "去个人空间查看收藏夹",
      onClick() {
        folderUrls.forEach((u2) => {
          window.open(u2, getLinkTarget());
        });
      }
    }]);
    const unfavedMenus = defineAntMenus([{
key: "quick-fav:unfaved:add-fav",
      icon: jsx$1(IconForFav, { className: clsContextMenuIcon }),
      label: "收藏到",
      async onClick() {
        await startPickFavFolder(async (targetFolder) => {
          const success = await UserFavApi.addFav(avid, targetFolder.id);
          if (success) antMessage.success(`已加入收藏夹「${targetFolder.title}」`);
          return success;
        });
      }
    }, {
test: enableDetailMenu,
      key: "quick-fav:unfaved:add-fav-to-default-folder",
      icon: jsx$1(IconForFav, { className: clsContextMenuIcon }),
      label: "收藏到「默认收藏夹」",
      async onClick() {
        const success = await UserFavApi.addFav(avid);
        if (success) antMessage.success(`已加入收藏夹「${defaultFavFolderTitle}」`);
      }
    }]);
    const faved = !!folderNames.length;
    return faved ? favedMenus : unfavedMenus;
  }
  function getFavTabMenus({
    ctx,
    item,
    cardData,
    tab: tab2,
    multiSelecting,
    multiSelectingAppendix,
    onRemoveCurrent,
    recSharedEmitter
  }) {
    if (!isFav(item)) return [];
    const {
      avid
    } = cardData;
    ctx.folderNames ?? [];
    ctx.folderUrls ?? [];
    const folderIds = ctx.folderIds ?? [];
    if (item.from === "fav-folder") {
      const batchMenus = multiSelecting ? [{
        key: "fav:batch-move-fav",
        label: `移动到其他收藏夹${multiSelectingAppendix}`,
        icon: jsx$1(ForwardRef$X, { className: clsContextMenuIcon }),
        async onClick() {
          if (!multiSelectStore.multiSelecting) return;
          const selectedFavItems = getMultiSelectedItems().filter((x) => isFav(x) && x.from === "fav-folder").toReversed();
          const folderIds2 = new Set(selectedFavItems.map((i2) => i2.folder.id));
          if (!folderIds2.size) return toast("至少选择一项视频");
          if (folderIds2.size > 1) return toast("多选移动: 只能批量移动同一源收藏夹下的视频");
          const srcFavFolderId = selectedFavItems[0].folder.id;
          const resources = selectedFavItems.map((x) => `${x.id}:${x.type}`);
          const uniqIds = selectedFavItems.map((x) => x.uniqId);
          const titles = selectedFavItems.map((x) => x.title);
          await startModifyFavItemToFolder([item.folder.id], async (targetFolder) => {
            invariant$1(targetFolder, "targetFolder should not be empty");
            const success = await UserFavApi.moveFavs(resources, srcFavFolderId, targetFolder.id);
            if (!success) return;
            clearFavFolderAllItemsCache(item.folder.id);
            clearFavFolderAllItemsCache(targetFolder.id);
            recSharedEmitter.emit("remove-cards", [uniqIds, titles, true]);
            antMessage.success(`已移动 ${uniqIds.length} 个视频到「${targetFolder.title}」收藏夹`);
            return success;
          }, false);
        }
      }] : [];
      return defineAntMenus([{
        key: "fav:browse-fav-folder-in-self-space",
        label: "去个人空间查看收藏夹",
        icon: jsx$1(IconForOpenExternalLink, { className: clsContextMenuIcon }),
        onClick() {
          const {
            id: id2
          } = item.folder;
          const url2 = formatFavFolderUrl(id2);
          window.open(url2, getLinkTarget());
        }
      }, {
        key: "fav:view-fav-in-new-window",
        label: "在新窗口中查看收藏夹",
        icon: jsx$1(IconForOpenExternalLink, { className: clsContextMenuIcon }),
        onClick() {
          const {
            id: id2
          } = item.folder;
          const url2 = `/?${FavQueryKey.FolderIdFull}=${id2}`;
          window.open(url2, getLinkTarget());
        }
      }, {
        test: !!avid,
        key: "modify-fav",
        icon: jsx$1(IconForEdit, { className: clsContextMenuIcon }),
        label: "编辑收藏",
        async onClick() {
          await startModifyFavItemToFolder(folderIds, async (targetFolder) => {
            const success = await handleModifyFavItemToFolder(avid, folderIds, targetFolder);
            if (success && targetFolder?.id !== item.folder.id) onRemoveCurrent?.(item, cardData, true);
            return success;
          }, false);
        }
      }, {
        key: "remove-fav",
        label: "移除收藏",
        icon: jsx$1(IconForDelete, { className: clsContextMenuIcon }),
        async onClick() {
          const confirm2 = await antModal.confirm({
            centered: true,
            title: "移除收藏",
            content: jsxs(Fragment, { children: [
              "确定将视频「",
              item.title,
              "」",
jsx$1("br", {}),
              "从收藏夹「",
              item.folder.title,
              "」中移除?"
            ] })
          });
          if (!confirm2) return;
          const resource = `${item.id}:${item.type}`;
          const success = await UserFavApi.removeFavs(item.folder.id, resource);
          if (!success) return;
          clearFavFolderAllItemsCache(item.folder.id);
          onRemoveCurrent?.(item, cardData);
        }
      }, ...batchMenus]);
    }
    if (item.from === "fav-collection") {
      return defineAntMenus([{
        key: "open-fav-collection",
        label: "浏览合集",
        icon: jsx$1(IconForOpenExternalLink, { className: clsContextMenuIcon }),
        onClick() {
          const {
            id: id2
          } = item.collection;
          const url2 = tab2 !== ETab.Fav || favStore.selectedKey === "all" && favStore.usingShuffle ? `/?${FavQueryKey.CollectionIdFull}=${id2}` : formatFavCollectionUrl(id2);
          window.open(url2, getLinkTarget());
        }
      }]);
    }
    return [];
  }
  const iconParkOutlineAddTwo = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M33 7.263A18.9 18.9 0 0 0 24 5C13.507 5 5 13.507 5 24s8.507 19 19 19a18.9 18.9 0 0 0 8-1.761" }),
jsx$1("path", { strokeLinejoin: "round", d: "M31 30h12m-28-8l7 7l19-18m-4 13v12" })
    ] })
  ] });
  const ForwardRef$a = reactExports.forwardRef(iconParkOutlineAddTwo);
  const iconParkOutlinePeopleMinus = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", children: [
jsx$1("path", { stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, d: "M19 20a7 7 0 1 0 0-14a7 7 0 0 0 0 14Z" }),
jsx$1("path", { d: "M30 35h12z", clipRule: "evenodd" }),
jsx$1("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "M30 35h12m-15-7h-8.2c-4.48 0-6.72 0-8.432.872a8 8 0 0 0-3.496 3.496C6 34.08 6 36.32 6 40.8V42h21" })
    ] })
  ] });
  const ForwardRef$9 = reactExports.forwardRef(iconParkOutlinePeopleMinus);
  const letsIconsViewHide = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", children: [
jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "M15.92 12.799Q16 12.41 16 12a4 4 0 0 0-4.799-3.92zM8.667 9.788a4 4 0 0 0 5.545 5.545l-1.474-1.474a2 2 0 0 1-2.597-2.597z", clipRule: "evenodd" }),
jsx$1("path", { fill: "currentColor", fillRule: "evenodd", d: "m16.52 17.64l-1.47-1.469c-.972.51-2.002.829-3.05.829c-1.526 0-3.014-.678-4.34-1.632c-1.32-.95-2.396-2.112-3.076-2.938c-.1-.121-.174-.212-.236-.291a2 2 0 0 1-.1-.139q.028-.045.1-.139c.062-.08.136-.17.236-.291c.665-.808 1.71-1.938 2.99-2.875l-1.43-1.43C4.797 8.297 3.723 9.47 3.04 10.3l-.073.088c-.314.375-.737.883-.737 1.613s.423 1.238.737 1.613l.073.088c.74.899 1.94 2.203 3.451 3.29C7.994 18.073 9.891 19 12 19c1.67 0 3.206-.581 4.52-1.36M8.806 5.686C9.79 5.269 10.864 5 12 5c2.11 0 4.006.927 5.509 2.009c1.51 1.087 2.711 2.391 3.45 3.29l.074.088c.314.375.737.883.737 1.613s-.423 1.238-.737 1.613l-.073.088a20.5 20.5 0 0 1-2.015 2.123l-1.416-1.416a18.5 18.5 0 0 0 2.123-2.27a2 2 0 0 0 .1-.138a2 2 0 0 0-.1-.139a14 14 0 0 0-.236-.291c-.68-.826-1.756-1.989-3.075-2.938C15.014 7.678 13.526 7 12 7c-.551 0-1.097.088-1.632.246z", clipRule: "evenodd" }),
jsx$1("path", { stroke: "currentColor", strokeWidth: 2, d: "m5 2l16 16" })
    ] })
  ] });
  const ForwardRef$8 = reactExports.forwardRef(letsIconsViewHide);
  const clsContextMenuIcon = "size-16px";
  function useContextMenus(options) {
    const {
      item,
      cardData,
      tab: tab2,
      favContext,
      watchlaterContext,
      hasDislikeEntry,
      onTriggerDislike,
      onRemoveCurrent,
      consistentOpenMenus,
      conditionalOpenMenus,
      multiSelecting
    } = options;
    const {
      avid,
      bvid,
      cover,
      href,
      recommendReason,
authorName,
      authorMid
    } = cardData;
    const {
      watchlaterItemsOrder,
      filter: {
        dfHideOpusMids: {
          enabled: dfHideOpusMidsEnabled
        }
      },
      dynamicFeed: {
        whenViewAll: {
          enableHideSomeContents
        }
      }
    } = useSettingsSnapshot();
    const watchlaterNewestItemPos = watchlaterItemsOrder === WatchlaterItemsOrder.AddTimeAsc ? "end" : "start";
    const watchlaterNewestItemPosText = watchlaterItemsOrder === WatchlaterItemsOrder.AddTimeAsc ? "移到最后" : "移到最前";
    const {
      recSharedEmitter
    } = useRecSelfContext();
    const onCopyLink = useMemoizedFn(() => {
      let content = href;
      if (href.startsWith("/")) {
        content = new URL(href, location.href).href;
      }
      copyContent(content);
    });
    const hasBlacklistEntry = !!authorMid && isApiRecLike(item.api) && tab2 !== ETab.KeepFollowOnly;
    const onBlacklistUp = useMemoizedFn(async () => {
      if (!authorMid) return antMessage.error("UP mid 为空!");
      const success = await UserBlacklistService.add(authorMid);
      if (success) {
        antMessage.success(`已加入黑名单: ${authorName}`);
      }
    });
    const onAddUpToFilterList = useMemoizedFn(async () => {
      if (!authorMid) return antMessage.error("UP mid 为空!");
      const content = `${authorMid}`;
      if (settings.filter.byAuthor.keywords.includes(content)) {
        return toast(`已在过滤名单中: ${content}`);
      }
      await updateSettingsInnerArray("filter.byAuthor.keywords", {
        add: [content]
      });
      if (authorName) setNicknameCache(authorMid, authorName);
      antMessage.success(`已加入过滤名单: ${authorName || authorMid}`);
    });
    const followed = (() => {
      if (!isNil(cardData.followed)) return cardData.followed;
      if (tab2 === ETab.DynamicFeed && isLive(item)) return true;
      if (tab2 === ETab.Live && isLive(item)) return true;
      if (isAppRecommend(item) || isPcRecommend(item)) return getFollowedStatus$1(recommendReason);
      return false;
    })();
    const hasUnfollowEntry = followed;
    const onUnfollowUp = useMemoizedFn(async () => {
      if (!authorMid) return;
      const confirm2 = await antModal.confirm({
        centered: true,
        title: "取消关注",
        content: jsxs(Fragment, { children: [
          "确定取消关注「",
          authorName,
          "」?"
        ] })
      });
      if (!confirm2) return;
      const success = await UserfollowService.unfollow(authorMid);
      if (success) {
        antMessage.success("已取消关注");
      }
    });
    const hasViewUpVideoListEntry = !!authorMid && !!authorName;
    const onViewUpDyn = useMemoizedFn(() => {
      if (!authorMid) return;
      openNewTab(`/?${DynamicFeedQueryKey.Mid}=${authorMid}`);
    });
    const onViewUpSpaceUpload = useMemoizedFn(() => {
      if (!authorMid) return;
      openNewTab(`/?${SpaceUploadQueryKey.Mid}=${authorMid}`);
    });
    const hasEntry_addMidTo_dynamicFeedWhenViewAllHideIds = enableHideSomeContents && isDynamicFeed(item) && dfStore.selectedKey === DF_SELECTED_KEY_ALL && !!authorMid;
    const onAddMidTo_dynamicFeedWhenViewAllHideIds = useMemoizedFn(async () => {
      if (!hasEntry_addMidTo_dynamicFeedWhenViewAllHideIds) return;
      await updateSettingsInnerArray("dynamicFeed.whenViewAll.hideIds", {
        add: [DF_SELECTED_KEY_PREFIX_UP + authorMid]
      });
      setNicknameCache(authorMid, authorName || "");
      antMessage.success(`在「全部」动态中隐藏【${authorName}】的动态`);
    });
    const hasEntry_hideUpOpusDynamic = dfHideOpusMidsEnabled && isDynamicFeed(item) && item.modules.module_dynamic.major?.type === DynamicFeedEnums.MajorType.Opus && !!authorMid;
    const onAddMidTo_dfHideOpusMids = useMemoizedFn(async () => {
      if (!authorMid) return antMessage.error("UP mid 为空!");
      const content = `${authorMid}`;
      if (settings.filter.dfHideOpusMids.keywords.includes(content)) {
        return toast(`已在过滤名单中: ${content}`);
      }
      await updateSettingsInnerArray("filter.dfHideOpusMids.keywords", {
        add: [content]
      });
      if (authorName) setNicknameCache(authorMid, authorName);
      antMessage.success(`已屏蔽【${authorName || authorMid}】的图文动态`);
    });
    const hasEntry_dynamicFeed_offsetAndMinId = !!(isDynamicFeed(item) && QUERY_DYNAMIC_UP_MID && dfStore.viewingSomeUp && authorMid);
    const dynamicViewStartFromHere = reactExports.useMemo(() => hasEntry_dynamicFeed_offsetAndMinId && {
      label: "动态: 从此项开始查看",
      key: "动态: 从此项开始查看",
      icon: jsx$1(IconForDesc, { className: clsContextMenuIcon }),
      onClick() {
        const u2 = new URL("/", location.href);
        u2.searchParams.set(DynamicFeedQueryKey.Mid, authorMid);
        const currentIndexInGrid = getCurrentGridItems().findIndex((x) => x.api === EApiType.DynamicFeed && x.id_str === item.id_str);
        const prevIdStr = getCurrentGridItems()[currentIndexInGrid - 1]?.id_str || item.id_str;
        u2.searchParams.set(DynamicFeedQueryKey.Offset, prevIdStr);
        openNewTab(u2.href);
      }
    }, [hasEntry_dynamicFeed_offsetAndMinId, item, authorMid]);
    const dynamicViewUpdateSinceThis = reactExports.useMemo(() => hasEntry_dynamicFeed_offsetAndMinId && {
      icon: jsx$1(IconForAsc, { className: clsContextMenuIcon }),
      label: "动态: 从此项开始截止",
      key: "动态: 从此项开始截止",
      onClick() {
        const u2 = new URL("/", location.href);
        u2.searchParams.set(DynamicFeedQueryKey.Mid, authorMid);
        u2.searchParams.set(DynamicFeedQueryKey.MinId, item.id_str);
        openNewTab(u2.href);
      }
    }, [hasEntry_dynamicFeed_offsetAndMinId, item, authorMid]);
    const spaceUploadViewStartFromHere = reactExports.useMemo(() => SHOW_SPACE_UPLOAD_ONLY && isSpaceUpload(item) && !!item.page && {
      key: "space-upload-view-start-from-here",
      label: `投稿: 从此页开始查看 (当前第${item.page}页)`,
      icon: jsx$1(IconForDesc, { className: clsContextMenuIcon }),
      onClick() {
        const u2 = new URL(location.href);
        u2.searchParams.set(SpaceUploadQueryKey.InitialPage, item.page.toString());
        openNewTab(u2.href);
      }
    }, [SHOW_SPACE_UPLOAD_ONLY, item]);
    const viewingGroupId = isDynamicFeed(item) || isSpaceUpload(item) ? item.groupId : void 0;
    const viewingSomeGroup = viewingGroupId !== void 0;
    const followGroups = useSnapshot(dfStore.groups);
    const viewingGroup = viewingGroupId !== void 0 ? followGroups.find((x) => x.tagid === viewingGroupId) : void 0;
    const viewingGroupName = viewingGroup?.name;
    const viewingGroupCount = viewingGroup?.count;
    return reactExports.useMemo(() => {
      const {
        watchlaterAdded,
        hasWatchlaterEntry,
        onToggleWatchlater
      } = watchlaterContext;
      const divider = {
        type: "divider"
      };
      const multiSelectingAppendix = multiSelecting ? " (多选)" : "";
      const copyMenus = defineAntMenus([{
        key: "copy-link",
        label: `复制视频链接${multiSelectingAppendix}`,
        icon: jsx$1(IconForCopy, { className: clsContextMenuIcon }),
        onClick() {
          if (multiSelectStore.multiSelecting) {
            copyVideoLinks();
          } else {
            onCopyLink();
          }
        }
      }, {
        test: !!bvid,
        key: "copy-bvid",
        label: `复制 BVID${multiSelectingAppendix}`,
        icon: jsx$1(IconForCopy, { className: clsContextMenuIcon }),
        onClick() {
          if (multiSelectStore.multiSelecting) {
            copyBvidsSingleLine();
          } else {
            copyContent(bvid);
          }
        }
      }, {
        test: !!bvid && settings.__internalEnableCopyBvidInfo,
        key: "copy-bvid-info",
        label: `复制 BVID 信息${multiSelectingAppendix}`,
        icon: jsx$1(IconForCopy, { className: clsContextMenuIcon }),
        onClick() {
          if (multiSelectStore.multiSelecting) {
            copyBvidInfos();
          } else {
            copyContent(getBvidInfo(cardData));
          }
        }
      }, {
        test: !!cover,
        key: "view-cover",
        label: "查看封面",
        icon: jsx$1(IconForOpenExternalLink, { className: clsContextMenuIcon }),
        onClick() {
          if (!cover) return;
          const url2 = cover;
          openNewTab(url2);
        }
      }]);
      const interestedMenus = defineAntMenus([
{
          test: hasViewUpVideoListEntry && followed,
key: `查看「投稿」与「动态」的区别`,
          label: `查看「投稿」与「动态」的区别`,
          icon: jsx$1(IconForOpenExternalLink, { className: clsContextMenuIcon }),
          onClick: () => openNewTab("https://github.com/magicdawn/Bilibili-Gate?tab=readme-ov-file#%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95-%E6%9F%A5%E7%9C%8B-up-%E7%9A%84%E6%8A%95%E7%A8%BF--%E6%9F%A5%E7%9C%8B-up-%E7%9A%84%E5%8A%A8%E6%80%81")
        },
        {
          test: hasViewUpVideoListEntry,
          key: "查看 UP 的投稿",
          label: `查看 UP 的投稿`,
          icon: jsx$1(IconForSpaceUpload, { className: clsContextMenuIcon }),
          onClick: onViewUpSpaceUpload
        },
        spaceUploadViewStartFromHere,
{
          test: hasViewUpVideoListEntry && followed,
          key: "查看 UP 的动态",
          label: `查看 UP 的动态`,
          icon: jsx$1(IconForDynamicFeed, { className: clsContextMenuIcon }),
          onClick: onViewUpDyn
        },
        dynamicViewUpdateSinceThis,
        dynamicViewStartFromHere,
        ...hasViewUpVideoListEntry && viewingSomeGroup ? defineAntMenus([{
          type: "divider"
        }, {
          test: hasViewUpVideoListEntry && viewingSomeGroup && (viewingGroupCount === void 0 || viewingGroupCount <= 30),
          key: "查看分组的投稿",
          label: `查看分组的投稿`,
          icon: jsx$1(IconForSpaceUpload, { className: clsContextMenuIcon }),
          onClick: () => openNewTab(`/?${SpaceUploadQueryKey.GroupId}=${viewingGroupId}`)
        }, {
          test: hasViewUpVideoListEntry && viewingSomeGroup,
          key: "查看分组的动态",
          label: `查看分组的动态`,
          icon: jsx$1(IconForDynamicFeed, { className: clsContextMenuIcon }),
          onClick: () => openNewTab(`/?${DynamicFeedQueryKey.GroupId}=${viewingGroupId}`)
        }, {
          type: "divider"
        }]) : [],
{
          test: hasWatchlaterEntry,
          key: "watchlater",
          label: watchlaterAdded ? "移除稍后再看" : "稍后再看",
          icon: watchlaterAdded ? jsx$1(IconForDelete, { className: clsContextMenuIcon }) : jsx$1(IconForWatchlater, { className: clsContextMenuIcon }),
          onClick() {
            onToggleWatchlater();
          }
        },
        {
          test: hasWatchlaterEntry && watchlaterAdded,
          key: "watchlater-readd",
          label: `重新添加稍候再看${tab2 === ETab.Watchlater ? ` (${watchlaterNewestItemPosText})` : ""}`,
          icon: jsx$1(ForwardRef$a, { className: clsContextMenuIcon }),
          async onClick() {
            const {
              success
            } = await onToggleWatchlater(void 0, watchlaterAdd);
            if (!success) return;
            antMessage.success("已重新添加");
            if (tab2 === ETab.Watchlater) {
              recSharedEmitter.emit("move-card-to", [item.uniqId, watchlaterNewestItemPos]);
            }
          }
        },
...getQuickFavMenus(favContext, item, avid) ?? []
      ]);
      const dislikeMenus = defineAntMenus([{
        test: hasDislikeEntry,
        key: "dislike",
        label: "我不想看",
        icon: jsx$1(IconForDislike, { width: 15, height: 15 }),
        onClick() {
          onTriggerDislike();
        }
      }, {
        test: hasUnfollowEntry,
        key: "unfollow-up",
        label: "取消关注",
        icon: jsx$1(ForwardRef$9, { className: clsContextMenuIcon }),
        onClick: onUnfollowUp
      }, {
        test: hasEntry_addMidTo_dynamicFeedWhenViewAllHideIds,
        key: "hasEntry_addMidTo_dynamicFeedWhenViewAllHideIds",
        label: "在「全部」动态中隐藏 UP 的动态",
        icon: jsx$1(ForwardRef$8, { className: clsContextMenuIcon }),
        onClick: onAddMidTo_dynamicFeedWhenViewAllHideIds
      }, {
        test: hasEntry_hideUpOpusDynamic,
        key: "hide-up-opus-dynamic",
        label: "屏蔽此 UP 的图文动态",
        icon: jsx$1(ForwardRef$8, { className: clsContextMenuIcon }),
        onClick: onAddMidTo_dfHideOpusMids
      }, {
        test: hasBlacklistEntry,
        key: "blacklist-up",
        label: "将 UP 加入黑名单",
        icon: jsx$1(IconForBlacklist, { className: clsContextMenuIcon }),
        onClick: onBlacklistUp
      }, {
        test: hasBlacklistEntry,
        key: "add-up-to-filterlist",
        label: "将 UP 加入过滤列表",
        icon: jsx$1(IconForBlacklist, { className: clsContextMenuIcon }),
        onClick: onAddUpToFilterList
      }]);
      const favTabMenus = getFavTabMenus({
        ctx: favContext,
        item,
        cardData,
        tab: tab2,
        multiSelecting,
        multiSelectingAppendix,
        onRemoveCurrent,
        recSharedEmitter
      });
      const menus = defineAntMenus([...consistentOpenMenus, !!copyMenus.length && divider, ...copyMenus, !!interestedMenus.length && divider, ...interestedMenus, !!dislikeMenus.length && divider, ...dislikeMenus, !!favTabMenus.length && divider, ...favTabMenus, !!conditionalOpenMenus.length && divider, ...conditionalOpenMenus]);
      return menus;
    }, [
      item,
      cardData,
      tab2,
watchlaterContext,
      favContext,
hasDislikeEntry,
      hasUnfollowEntry,
      hasBlacklistEntry,
      hasViewUpVideoListEntry,
      hasEntry_addMidTo_dynamicFeedWhenViewAllHideIds,
      hasEntry_hideUpOpusDynamic,
consistentOpenMenus,
      conditionalOpenMenus,
multiSelecting,
      viewingGroupId,
      viewingSomeGroup,
      viewingGroupName,
      viewingGroupCount,
      recSharedEmitter,
      onRemoveCurrent
    ]);
  }
  function showNativeContextMenuWhenAltKeyPressed(e) {
    if (e.altKey) {
      e.stopPropagation();
      return true;
    }
  }
  const $now = valtioFactory(() => Date.now());
  const firstTimeout = (dayjs().add(1, "minute").startOf("minute").valueOf() - $now.get()) % 3e4;
  setTimeout(() => {
    $now.update();
    setInterval($now.update, 3e4);
  }, firstTimeout);
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState !== "visible") return;
    $now.update();
  });
  const UnixTsDisplay = reactExports.memo(function UnixTsDisplay2({
    ts
  }) {
    if (!ts) return null;
    return isRecentTimeStamp(ts) ? jsx$1(ReactiveImpl, { ts }) : jsx$1(PlainImpl, { ts });
  });
  function PlainImpl({
    ts
  }) {
    return reactExports.useMemo(() => formatRecentTimeStamp(ts), [ts]);
  }
  function ReactiveImpl({
    ts
  }) {
    const now2 = $now.use();
    return jsx$1(PlainImpl, { ts }, now2);
  }
  const clsRecommendReason = clsx(APP_CLS_CARD_RECOMMEND_REASON, "max-w-[calc(100%-6px)] w-max cursor-default overflow-hidden text-ellipsis whitespace-nowrap b-1px b-gate-border rounded-9px b-solid px-8px py-0 text-12px color-gate-primary line-height-17px");
  const clsRecommendReasonInList = clsx("line-clamp-2 mt-10px h-auto whitespace-normal");
  const cssRecommendReason = css("background-color:oklch(from ", appPrimaryColorValue, " calc(l * 0.1 + 0.88) calc(c * 0.25) h);", appClsDarkSelector, " &{background-color:oklch(from ", appPrimaryColorValue, " calc(l * 0.3 + 0.175) calc(c * 0.25) h);}", "");
  const appBadgeCss = css("color:", appPrimaryColorValue, ";border-radius:2px;border:1px ", appPrimaryColorValue, " solid;line-height:20px;padding:0 10px;transform:scale(0.8);transform-origin:center left;", "");
  const descOwnerCss = {
    name: "nux2qa",
    styles: "font-size:var(--subtitle-font-size);line-height:var(--subtitle-line-height);color:var(--text3);a&:visited{color:var(--text3);}display:inline-flex;width:max-content;max-width:100%;align-items:center;justify-content:flex-start"
  };
  var _ref$1 = {
    name: "15xw6zv",
    styles: "display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1;overflow:hidden;text-overflow:ellipsis;max-width:100%"
  };
  var _ref2 = {
    name: "feo88y",
    styles: ".bili-video-card .bili-video-card__info--tit>a&{font-family:inherit;font-weight:initial;}"
  };
  var _ref3 = {
    name: "1eyh0r6",
    styles: "text-indent:0!important;.bili-video-card &.bili-video-card__info--tit{padding-right:0;height:auto;max-height:calc(2 * var(--title-line-height));}"
  };
  const VideoCardBottom = reactExports.memo(function({
    item,
    cardData,
    handleVideoLinkClick,
    className,
    gridDisplayMode
  }) {
    const {
      useBorder
    } = useSnapshot(settings.style.videoCard);
    const target = useLinkTarget();
    const displayingAsList = isDisplayAsList(gridDisplayMode);
    const {
goto,
      href,
      title,
      titleRender,
      pubts,
      pubdateDisplay,
      pubdateDisplayForTitleAttr,
      recommendReason,
authorName,
      authorFace,
      authorMid,
appBadge,
      appBadgeDesc,
      rankingDesc,
      liveExtraDesc
    } = cardData;
    const isNormalVideo = goto === "av";
    const authorHref = authorMid ? formatSpaceUrl(authorMid) : href;
    const streaming = item.api === EApiType.Live && item.live_status === ELiveStatus.Streaming;
    const {
      data: pubtsFromApi
    } = useRequest(() => fetchAppRecommendFollowedPubDate(item, cardData), {
      refreshDeps: [item, cardData]
    });
    const descTitleAttribute = reactExports.useMemo(() => {
      if (isNormalVideo && (authorName || pubts || pubtsFromApi || pubdateDisplay || pubdateDisplayForTitleAttr)) {
        let datePartForTitleAttribute;
        if (pubts || pubtsFromApi) {
          datePartForTitleAttribute = dayjs.unix(pubts || pubtsFromApi).format("YYYY年M月D日 HH:mm");
        } else {
          datePartForTitleAttribute = pubdateDisplay;
        }
        return [authorName, pubdateDisplayForTitleAttr || datePartForTitleAttribute].filter(Boolean).join(" · ");
      }
    }, [isNormalVideo, authorName, pubts, pubtsFromApi, pubdateDisplay, pubdateDisplayForTitleAttr]);
    const _recommendReasonClassName = r(clsRecommendReason, displayingAsList && clsRecommendReasonInList);
    return jsxs("div", { className: clsx(!displayingAsList ? "pt-15px" : "pt-5px", "flex gap-x-5px overflow-hidden px-5px", useBorder ? "mb-10px" : "mb-5px", className), children: [
      !!authorMid && jsxs("a", { href: authorHref, target, className: clsx("relative flex-center self-start rounded-full p-1px ring-1px", streaming ? "ring-gate-primary" : "ring-gate-border"), children: [
        authorFace ? jsx$1(Avatar, { src: getAvatarSrc(authorFace) }) : jsx$1(Avatar, { children: authorName?.[0] || appBadgeDesc?.[0] || "" }),
        streaming && jsx$1(IconForLive, { active: true, className: "absolute bottom-0 right-0 size-12px rounded-full bg-gate-primary" })
      ] }),
jsxs(
        "div",
        {
          className: "ml-5px flex flex-1 flex-col gap-y-4px overflow-hidden",
          children: [
jsx$1("h3", { className: "bili-video-card__info--tit", title, css: _ref3, children: jsx$1("a", { onClick: handleVideoLinkClick, onContextMenu: showNativeContextMenuWhenAltKeyPressed, href, target, rel: "noopener", css: _ref2, children: titleRender ?? title }) }),
            renderDesc()
          ]
        }
      )
    ] });
    function renderDesc() {
      const recommendReasonEl = !!recommendReason && jsx$1(
        "div",
        {
          title: recommendReason,
          css: cssRecommendReason,
          className: _recommendReasonClassName,
          children: recommendReason
        }
      );
      const defaultRender2 = () => {
        let date4;
        if (pubts || pubtsFromApi) {
          date4 = jsx$1(UnixTsDisplay, { ts: pubts || pubtsFromApi });
        } else if (pubdateDisplay) {
          date4 = pubdateDisplay;
        }
        return jsxs(Fragment, { children: [
jsxs("a", { className: "bili-video-card__info--owner", href: authorHref, target, title: descTitleAttribute, css: descOwnerCss, onContextMenu: showNativeContextMenuWhenAltKeyPressed, children: [
jsx$1("span", { className: "bili-video-card__info--author", children: authorName }),
            !!date4 && jsxs("span", { className: "bili-video-card__info--date", children: [
              DESC_SEPARATOR,
              date4
            ] })
          ] }),
          recommendReasonEl
        ] });
      };
      if (isNormalVideo) return defaultRender2();
      if (appBadge || appBadgeDesc) {
        return jsxs("a", { className: "bili-video-card__info--owner", css: descOwnerCss, href, target, onContextMenu: showNativeContextMenuWhenAltKeyPressed, children: [
          !!appBadge && jsx$1("span", { css: appBadgeCss, children: appBadge }),
          !!appBadgeDesc && jsx$1("span", { children: appBadgeDesc })
        ] });
      }
      if (isRank(item) && rankingDesc) {
        return jsx$1("div", { css: descOwnerCss, children: rankingDesc });
      }
      if (isLive(item) || isPcRecommend(item) && item.goto === PcRecGoto.Live) {
        return jsxs(Fragment, { children: [
jsxs("a", { css: [descOwnerCss, _ref$1, "", ""], href: authorHref, target, title: (authorName || "") + (liveExtraDesc || ""), onContextMenu: showNativeContextMenuWhenAltKeyPressed, children: [
            authorName,
            liveExtraDesc && jsx$1("span", { className: "ml-4px", children: liveExtraDesc })
          ] }),
          recommendReasonEl
        ] });
      }
      return defaultRender2();
    }
  });
  const iconParkOutlineDistraughtFace = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4S4 12.954 4 24s8.954 20 20 20Z" }),
jsx$1("path", { strokeLinecap: "round", d: "M24 29c5 0 7 4 7 4H17s2-4 7-4m8-12l-3 3l3 3m-16-6l3 3l-3 3" })
    ] })
  ] });
  const ForwardRef$7 = reactExports.forwardRef(iconParkOutlineDistraughtFace);
  const SkeletonCard = reactExports.memo(function SkeletonCard2({
    loading
  }) {
    return jsxs("div", { className: clsx("bili-video-card__skeleton", {
      hide: !loading,
      [skeletonActive]: loading
    }), children: [
jsx$1("div", { className: "bili-video-card__skeleton--cover", style: {
        borderRadius: videoCardBorderRadiusValue
      } }),
jsxs("div", { className: "bili-video-card__skeleton--info px-5px", children: [
jsx$1("div", { className: "bili-video-card__skeleton--avatar size-32px rounded-full" }),
jsxs("div", { className: "bili-video-card__skeleton--right ml-10px flex-1", children: [
jsx$1("p", { className: "bili-video-card__skeleton--text" }),
jsx$1("p", { className: "bili-video-card__skeleton--text short" }),
jsx$1("p", { className: "bili-video-card__skeleton--light" }),
jsx$1("p", { className: "bili-video-card__skeleton--text tiny" })
        ] })
      ] })
    ] });
  });
  const blockedCardClassNames = {
wrapper: "h-full flex flex-col overflow-hidden",
    cover: "relative aspect-16/9 rounded-t-6px",
    coverInner: "absolute left-0 top-0 h-full w-full flex flex-col items-center justify-center gap-y-2",
    dislikeReason: "text-center text-1.4em",
    dislikeDesc: "text-center text-1em",
    action: "relative flex-1",
    actionInner: "absolute left-0 top-0 h-full w-full flex items-center justify-center b-t-1px b-t-$bilibili-gate--separator-color b-t-solid transition-duration-300 transition-property-[border-color]",
    actionButton: "flex cursor-pointer items-center rounded-lg bg-transparent p-15px text-1.2em color-inherit"
  };
  const DislikedCard = reactExports.memo(function DislikedCard2({
    item,
    cardData,
    dislikedReason,
    emitter: emitter2 = defaultVideoCardEmitter
  }) {
    const onCancelDislike = useMemoizedFn(async () => {
      await handleCancelDislike(item, dislikedReason);
    });
    useEmitterOn(emitter2, "cancel-dislike", onCancelDislike);
    const {
      text,
      helpText
    } = reactExports.useMemo(() => normalizeDislikeReason(dislikedReason), [dislikedReason]);
    return jsxs("div", { className: blockedCardClassNames.wrapper, children: [
jsx$1("div", { className: blockedCardClassNames.cover, children: jsxs("div", { className: blockedCardClassNames.coverInner, children: [
jsx$1(ForwardRef$7, { className: "size-2.5em" }),
jsx$1("div", { className: blockedCardClassNames.dislikeReason, children: text }),
jsx$1("div", { className: blockedCardClassNames.dislikeDesc, children: helpText || "将减少此类内容推荐" })
      ] }) }),
jsx$1(__BottomRevertAction, { item, cardData, onClick: onCancelDislike })
    ] });
  });
  function __BottomRevertAction({
    item,
    cardData,
    onClick
  }) {
    return jsxs("div", { className: blockedCardClassNames.action, children: [
jsx$1(VideoCardBottom, { item, cardData, className: "invisible" }),
jsx$1("div", { className: blockedCardClassNames.actionInner, children: jsxs("button", { className: blockedCardClassNames.actionButton, onClick, children: [
jsx$1(IconForReset, { className: "mr-4px mt--2px" }),
        "撤销"
      ] }) })
    ] });
  }
  const BlockedCard = reactExports.memo(function BlockedCardInner({
    item,
    cardData,
    blockType
  }) {
    const {
      authorMid,
      authorName
    } = cardData;
    const label = blockType === "blacklist" ? "已拉黑" : "已加入过滤列表";
    const onCancel = useMemoizedFn(() => {
      return blockType === "blacklist" ? onCancelBlacklist() : onCancelFilter();
    });
    const onCancelBlacklist = useMemoizedFn(async () => {
      if (!authorMid) return;
      const success = await UserBlacklistService.remove(authorMid);
      if (success) antMessage.success(`已移出黑名单: ${authorName}`);
    });
    const onCancelFilter = useMemoizedFn(() => {
      if (!authorMid) return;
      const toRemove = settings.filter.byAuthor.keywords.filter((keyword) => parseUpRepresent(keyword).mid === authorMid);
      updateSettingsInnerArray("filter.byAuthor.keywords", {
        remove: toRemove
      });
      antMessage.success(`已移出过滤列表: ${authorName}`);
    });
    return jsxs("div", { className: blockedCardClassNames.wrapper, children: [
jsx$1("div", { className: blockedCardClassNames.cover, children: jsxs("div", { className: blockedCardClassNames.coverInner, children: [
jsx$1(IconForBlacklist, { className: "size-32px" }),
jsx$1("div", { className: blockedCardClassNames.dislikeReason, children: label }),
jsxs("div", { className: blockedCardClassNames.dislikeDesc, children: [
          "UP: ",
          authorName
        ] })
      ] }) }),
jsx$1(__BottomRevertAction, { item, cardData, onClick: onCancel })
    ] });
  });
  const clsPreviewImageWrapper = clsx(
    "pointer-events-none absolute inset-0 overflow-hidden",
    clsZPreviewImageWrapper,
    "rounded-b-none rounded-t-gate-video-card"
);
  const PreviewImage = reactExports.memo(function PreviewImage2({
    videoDuration,
    pvideo,
    progress: progress2,
    t: t2,
    className,
    ref: ref2,
    ...restProps
  }) {
    const rootElRef = reactExports.useRef(null);
    const [size, setSize] = reactExports.useState(() => ({
      width: 0,
      height: 0
    }));
    useMount(() => {
      const rect = rootElRef.current?.getBoundingClientRect();
      if (!rect) return;
      setSize({
        width: rect.width,
        height: rect.height
      });
    });
    const usingProgress = reactExports.useMemo(() => {
      function getProgress() {
        if (typeof progress2 === "number" && !Number.isNaN(progress2)) return progress2;
        return 0;
      }
      return minmax(getProgress() ?? 0, 0, 1);
    }, [progress2]);
    const usingT = reactExports.useMemo(() => t2 ?? Math.floor((videoDuration || 0) * usingProgress), [t2, videoDuration, usingProgress]);
    const getT = useMemoizedFn(() => usingT);
    reactExports.useImperativeHandle(ref2, () => ({
      getT
    }), [getT]);
    const innerProps = {
      progress: usingProgress,
      t: usingT,
      pvideo,
      elWidth: size.width,
      elHeight: size.height
    };
    return jsx$1("div", { ...restProps, ref: rootElRef, className: clsx(clsPreviewImageWrapper, className), children: !!(pvideo && size.width && size.height && usingProgress) && jsx$1(PreviewImageInner, { ...innerProps }) });
  });
  const PreviewImageInner = reactExports.memo(function PreviewImageInner2({
    t: t2,
    progress: progress2,
    pvideo,
    elWidth,
    elHeight
  }) {
    let index = reactExports.useMemo(() => {
      return calcIndex(pvideo?.index || [], t2) ?? 0;
    }, [pvideo, t2]);
    const {
      img_x_len: colCount,
      img_y_len: rowCount,
      img_x_size: w,
      img_y_size: h2
    } = pvideo;
    const countPerPreview = rowCount * colCount;
    index = index + 1;
    const snapshotIndex = Math.floor(index / countPerPreview);
    const indexInSnapshot = index - snapshotIndex * countPerPreview;
    const snapshotUrl = pvideo.image?.[snapshotIndex] || "";
    const indexRow = Math.floor(indexInSnapshot / colCount) + 1;
    const indexCol = indexInSnapshot - (indexRow - 1) * colCount;
    const newImgWidth = elWidth * colCount;
    const newImgHeight = elHeight * rowCount;
    const startY = (indexRow - 1) * elHeight;
    const startX = (indexCol - 1) * elWidth;
    return jsx$1("div", { className: "size-full", style: {
      backgroundColor: "black",
backgroundImage: `url(${snapshotUrl})`,
      backgroundPosition: `-${startX}px -${startY}px`,
      backgroundSize: `${newImgWidth}px ${newImgHeight}px`
    }, children: jsx$1(SimpleProgressBar, { progress: progress2 }) });
  });
  function SimpleProgressBar({
    progress: progress2,
    className,
    ...props
  }) {
    return jsx$1("div", { ...props, "data-role": "track", className: clsx("absolute inset-x-0 bottom-0 h-2px bg-gate-bg-lv1", className), children: jsx$1("div", { "data-role": "bar", className: "h-full bg-gate-primary", style: {
      width: `${progress2 * 100}%`
    } }) });
  }
  function calcIndex(arr, t2) {
    let index = findIndex(arr, t2);
    if (index !== -1) {
      return index;
    }
    if (t2 > arr.at(-1)) {
      index = arr.length - 1;
    }
  }
  function findIndex(arr, target) {
    let l2 = 0;
    let r2 = arr.length - 1;
    let possible = -1;
    while (l2 <= r2) {
      const mid = Math.floor((l2 + r2) / 2);
      const mv = arr[mid];
      if (target === mv) {
        return mid;
      }
      if (mv < target) {
        l2 = mid + 1;
        possible = mid;
      } else {
        r2 = mid - 1;
      }
    }
    if (possible === -1) return -1;
    const v = arr[possible];
    const v1 = arr[possible + 1] ?? 0;
    if (v < target && target < v1) {
      return possible;
    } else {
      return -1;
    }
  }
  const phCrownFill = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 256 256", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "currentColor", d: "M248 80a28 28 0 1 0-51.12 15.77l-26.79 33L146 73.4a28 28 0 1 0-36.06 0l-24.03 55.34l-26.79-33a28 28 0 1 0-26.6 12L47 194.63A16 16 0 0 0 62.78 208h130.44A16 16 0 0 0 209 194.63l14.47-86.85A28 28 0 0 0 248 80M128 40a12 12 0 1 1-12 12a12 12 0 0 1 12-12M24 80a12 12 0 1 1 12 12a12 12 0 0 1-12-12m196 12a12 12 0 1 1 12-12a12 12 0 0 1-12 12" })
  ] });
  const ForwardRef$6 = reactExports.forwardRef(phCrownFill);
  const iconParkOutlineMore = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("circle", { cx: 12, cy: 24, r: 3, fill: "currentColor" }),
jsx$1("circle", { cx: 24, cy: 24, r: 3, fill: "currentColor" }),
jsx$1("circle", { cx: 36, cy: 24, r: 3, fill: "currentColor" })
  ] });
  const ForwardRef$5 = reactExports.forwardRef(iconParkOutlineMore);
  const clsBadgeContainer = "pointer-events-none h-19px flex-center whitespace-nowrap rounded-2px bg-gate-primary px-4px text-center text-12px color-white";
  function SomeBadge({
    children,
    className
  }) {
    return jsx$1("span", { className: r(clsBadgeContainer, className), children });
  }
  function hasGeneralTopMark(cardData) {
    const {
      topMarkIcon,
      topMarkText
    } = cardData;
    return !!(topMarkIcon || topMarkText);
  }
  function GeneralTopMark({
    cardData
  }) {
    if (!hasGeneralTopMark(cardData)) return;
    const {
      topMarkIcon: icon,
      topMarkText: text
    } = cardData;
    const hasIcon = !!icon;
    return jsxs(SomeBadge, { className: clsx(
      "min-w-32px",
      hasIcon ? "pl-4px pr-6px" : "px-4px"
), children: [
      hasIcon && jsx$1(Picture, { src: `${icon}@!web-dynamic`, className: "h-16px w-16px" }),
      text
    ] });
  }
  function getColor(no) {
    const medalColors = ["#FFD700", "#C0C0C0", "#B36700"];
    return medalColors[no - 1] ?? appPrimaryColorValue;
  }
  function RankNumMark({
    item
  }) {
    const hasMedal = item.rankingNo <= 3;
    const medalIcon = jsx$1(ForwardRef$6, {});
    let hasOthers = false;
    let others = [];
    if (isNormalRankItem(item) && item.others?.length) {
      hasOthers = true;
      others = item.others;
    }
    const tooltip = `「${item.rankTab.name}」排行第 ${item.rankingNo} 名`;
    const {
      triggerRef,
      tooltipEl
    } = useTooltip({
      inlinePosition: "left",
      tooltip,
      tooltipClassName: "left--2px"
    });
    const roundButtonClassName = "relative size-28px flex-center whitespace-nowrap rounded-full text-14px color-white";
    const roundButtonStyle = reactExports.useMemo(() => ({
      backgroundColor: getColor(item.rankingNo)
    }), [item.rankingNo]);
    const newTab = useLinkNewTab();
    return jsxs(Fragment, { children: [
jsxs("div", { ref: triggerRef, className: roundButtonClassName, style: roundButtonStyle, children: [
        hasMedal ? medalIcon : jsx$1("span", { style: {
          marginLeft: -1
        }, children: item.rankingNo }),
        tooltipEl
      ] }),
      hasOthers && jsx$1(Dropdown, { placement: "bottomLeft", menu: {
        items: [{
          type: "group",
          label: "「其他上榜视频」",
          children: others.map((x) => {
            return {
              key: x.bvid,
              label: x.title,
              onClick() {
                const href = new URL(`/video/${x.bvid}`, location.href).href;
                if (newTab) {
                  openNewTab(href);
                } else {
                  location.href = href;
                }
              }
            };
          })
        }]
      }, children: jsx$1("div", { className: roundButtonClassName, style: roundButtonStyle, children: jsx$1(ForwardRef$5, {}) }) })
    ] });
  }
  function LiveBadge() {
    return jsxs(SomeBadge, { children: [
jsx$1(IconForLive, { active: true, className: "size-14px" }),
      "直播中"
    ] });
  }
  function ApiTypeTag({
    item
  }) {
    const text = reactExports.useMemo(() => {
      if (isDynamicFeed(item)) return "动态";
      if (isWatchlater(item)) return "稍后再看";
      if (isFav(item)) return item.from === "fav-folder" ? "收藏夹" : "合集";
      return item.api;
    }, [item]);
    const tooltip = reactExports.useMemo(() => {
      if (isFav(item) && item.from === "fav-collection") return item.volTooltip;
    }, [item]);
    const {
      triggerRef,
      tooltipEl
    } = useTooltip({
      inlinePosition: "left",
      tooltip
    });
    return jsxs("span", { ref: triggerRef, className: r(clsBadgeContainer, "pointer-events-auto"), children: [
      text,
      tooltipEl
    ] });
  }
  function VolMark({
    vol,
    volTooltip
  }) {
    const {
      triggerRef,
      tooltipEl
    } = useTooltip({
      inlinePosition: "left",
      tooltip: volTooltip,
      tooltipClassName: "left--2px"
    });
    return jsxs("div", { ref: triggerRef, className: "relative h-24px min-w-24px flex-center whitespace-nowrap rounded-8px bg-gate-primary px-6px text-center text-14px color-white", children: [
      vol,
      tooltipEl
    ] });
  }
  const dislikeIcon = jsx$1(IconForDislike, { className: "size-16px" });
  function useDislikeRelated({
    item,
    authed,
    actionButtonVisible
  }) {
    const hasDislikeEntry = isAppRecommend(item) && !!item.three_point?.dislike_reasons?.length || isPcRecommend(item);
    const onTriggerDislike = useMemoizedFn(async (e) => {
      e?.preventDefault();
      e?.stopPropagation();
      if (!hasDislikeEntry) {
        return antMessage.error("当前视频不支持提交「我不想看」");
      }
      const dislikeKey = calcRecItemDislikedMapKey(item);
      if (dislikeKey && dislikedMap.has(dislikeKey)) return;
      let reasons;
      if (isAppRecommend(item)) {
        if (!authed) return toast("请先获取 access_key !");
        reasons = (item.three_point?.dislike_reasons || []).map((x) => ({
          platform: "app",
          ...x
        }));
      } else if (isPcRecommend(item)) {
        reasons = PcDislikeReasons;
      } else {
        assertNever(item);
      }
      await pickDislikeReason(reasons, (reason) => handleDislike(item, reason));
    });
    const dislikeButtonEl = hasDislikeEntry && jsx$1(VideoCardActionButton, { visible: actionButtonVisible, inlinePosition: "left", icon: dislikeIcon, tooltip: "我不想看", onClick: onTriggerDislike });
    return {
      dislikeButtonEl,
      hasDislikeEntry,
      onTriggerDislike
    };
  }
  const lucideCircle = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("circle", { cx: 12, cy: 12, r: 10, fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2 })
  ] });
  const ForwardRef$4 = reactExports.forwardRef(lucideCircle);
  const lucideCircleCheck = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 24 24", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [
jsx$1("circle", { cx: 12, cy: 12, r: 10 }),
jsx$1("path", { d: "m9 12l2 2l4-4" })
    ] })
  ] });
  const ForwardRef$3 = reactExports.forwardRef(lucideCircleCheck);
  const IconForMultiSelectUnchecked = ForwardRef$4;
  const IconForMultiSelectChecked = ForwardRef$3;
  function useMultiSelectRelated({
    multiSelecting,
    multiSelected,
    uniqId
  }) {
    const toggleMultiSelect = useMemoizedFn((e) => {
      const {
        selectedIdSet,
        multiSelecting: multiSelecting2
      } = multiSelectStore;
      if (!multiSelecting2) return;
      e?.preventDefault();
      e?.stopPropagation();
      const shiftSelecting = !!e?.shiftKey;
      multiSelectStore.shiftMultiSelectAnchorUniqId ??= uniqId;
      if (!shiftSelecting) {
        multiSelectStore.shiftMultiSelectAnchorUniqId = uniqId;
      }
      if (shiftSelecting) {
        handleMultiSelectWithShiftKey(multiSelectStore.shiftMultiSelectAnchorUniqId, uniqId);
      } else {
        multiSelected ? selectedIdSet.delete(uniqId) : selectedIdSet.add(uniqId);
      }
    });
    const multiSelectBgEl = multiSelecting && jsx$1("div", { onClick: toggleMultiSelect, className: clsx("absolute inset-0 flex items-center justify-center bg-black/10", clsZMultiSelectBg) });
    const Icon2 = multiSelected ? IconForMultiSelectChecked : IconForMultiSelectUnchecked;
    const multiSelectEl = multiSelecting && jsx$1(Icon2, { onClick: toggleMultiSelect, className: clsx("size-30px cursor-pointer text-white [&_g]:fill-inherit", multiSelected ? "fill-gate-primary" : "fill-none") });
    return {
      toggleMultiSelect,
      multiSelectBgEl,
      multiSelectEl
    };
  }
  function debugAnimation(...args) {
    return;
  }
  function usePreviewRelated({
    uniqId,
    recSharedEmitter,
    title,
    active,
    videoDuration,
    tryFetchImagePreviewData,
    imagePreviewDataBox,
    autoPreviewWhenHover,
    videoPreviewWrapperRef
  }) {
    const hasVideoData = useMemoizedFn(() => {
      const data2 = imagePreviewDataBox.val?.videoshotJson?.data;
      return Boolean(data2?.index?.length && data2?.image?.length);
    });
    const [autoPreviewing, setAutoPreviewing] = reactExports.useState(false);
    const [previewProgress, setPreviewProgress] = useRafState();
    const [previewT, setPreviewT] = useRafState();
    const getProgress = useMemoizedFn(() => previewProgress || 0);
    const [mouseMoved, setMouseMoved] = reactExports.useState(false);
    const isHoveringBox = useRefStateBox(false);
    const isHoveringAfterDelayBox = useRefStateBox(false);
    const startByHoverBox = useRefBox(false);
    const [mouseProgress, setMouseProgress] = reactExports.useState(void 0);
    const updateMouseProgress = (e) => {
      const rect = videoPreviewWrapperRef.current?.getBoundingClientRect();
      if (!rect) return;
      const {
        x,
        width
      } = rect;
      const relativeX = e.pageX - window.scrollX - x;
      setMouseProgress(relativeX / width);
    };
    useEventListener("mouseenter", async (e) => {
      recSharedEmitter.emit("mouseenter", uniqId);
      isHoveringBox.set(true);
      updateMouseProgress(e);
      const p2 = tryFetchImagePreviewData();
      const HOVER_DELAY = 800;
      let delayPromise;
      if (settings.useDelayForHover) {
        delayPromise = delay$1(HOVER_DELAY);
      }
      await Promise.all([p2, delayPromise].filter(Boolean));
      if (!isHoveringBox.val) return;
      isHoveringAfterDelayBox.set(true);
      if (autoPreviewWhenHover && !idBox.val && hasVideoData()) {
        onStartPreviewAnimation(true);
      }
    }, {
      target: videoPreviewWrapperRef
    });
    const _mouseleaveAction = useMemoizedFn(() => {
      isHoveringBox.set(false);
      isHoveringAfterDelayBox.set(false);
    });
    useEventListener("mouseleave", _mouseleaveAction, {
      target: videoPreviewWrapperRef
    });
    useEmitterOn(recSharedEmitter, "mouseenter", (srcUniqId) => {
      if (srcUniqId === uniqId) return;
      _mouseleaveAction();
    });
    useEventListener("mousemove", (e) => {
      setMouseMoved(true);
      if (isHoveringBox.val && (!isHoveringAfterDelayBox.val || !autoPreviewWhenHover)) {
        updateMouseProgress(e);
      }
      if (!autoPreviewWhenHover) {
        animationController.stop();
      }
    }, {
      target: videoPreviewWrapperRef
    });
    const idBox = useRefBox(void 0);
    const onResume = reactExports.useRef(void 0);
    const animationController = useAnimationController({
      startByHoverBox,
      isHoveringBox,
      active,
      mouseMoved,
      idBox,
      autoPreviewWhenHover,
      setAutoPreviewing,
      setPreviewT,
      setPreviewProgress,
      onResume() {
        onResume.current?.();
      }
    });
    const onHotkeyPreviewAnimation = useMemoizedFn(async () => {
      if (!idBox.val) {
        await tryFetchImagePreviewData();
        if (hasVideoData()) {
          onStartPreviewAnimation(false);
        }
        return;
      }
      animationController.togglePaused();
    });
    const onStartPreviewAnimation = useMemoizedFn((startByHover) => {
      startByHoverBox.set(startByHover);
      setMouseMoved(false);
      animationController.reset();
      animationController.stop(true);
      setAutoPreviewing(true);
      setPreviewProgress((val) => val === void 0 ? 0 : val);
      setPreviewT(void 0);
      const RUN_DURATION = 8e3;
      let start = performance.now();
      let updateAt = 0;
      onResume.current = () => {
        start = performance.now() - getProgress() * RUN_DURATION;
      };
      function frame2(t2) {
        if (animationController.shouldStop()) {
          return animationController.stop();
        }
        if (!animationController.paused) {
          const now2 = performance.now();
          const elapsed = now2 - start;
          const p2 = minmax(elapsed % RUN_DURATION / RUN_DURATION, 0, 1);
          setPreviewProgress(p2);
          if (!updateAt || now2 - updateAt >= settings.autoPreviewUpdateInterval) {
            setPreviewProgress(p2);
            updateAt = now2;
            if (videoDuration) {
              const t22 = minmax(Math.round(p2 * videoDuration), 0, videoDuration);
              setPreviewT(t22);
            }
          }
        }
        idBox.val = requestAnimationFrame(frame2);
      }
      idBox.val = requestAnimationFrame(frame2);
    });
    const isHovering = isHoveringBox.state;
    const isHoveringAfterDelay = isHoveringAfterDelayBox.state;
    const videoshotData = imagePreviewDataBox.state?.videoshotJson?.data;
    const shouldShowPreview = !!videoshotData?.image?.length && !!videoDuration && (isHoveringAfterDelay || active) && (autoPreviewWhenHover ? autoPreviewing : true);
    const previewImageRef = reactExports.useRef(null);
    let previewImgProps;
    let previewImageEl;
    if (shouldShowPreview) {
      const sharedProps = {
        videoDuration,
        pvideo: videoshotData
      };
      if (autoPreviewWhenHover) {
        previewImgProps = {
          ...sharedProps,
          progress: previewProgress,
          t: previewT
        };
      } else {
        previewImgProps = {
          ...sharedProps,
          progress: mouseProgress
        };
      }
      previewImageEl = jsx$1(PreviewImage, { ref: previewImageRef, ...previewImgProps });
    }
    return {
      onHotkeyPreviewAnimation,
      onStartPreviewAnimation,
      autoPreviewing,
      mouseProgress,
      previewProgress,
      previewT,
isHovering,
      isHoveringAfterDelay,
shouldShowPreview,
      previewImageRef,
      previewImgProps,
      previewImageEl
    };
  }
  function useAnimationController({
    startByHoverBox,
    isHoveringBox,
    idBox,
    active,
    mouseMoved,
    autoPreviewWhenHover,
    setAutoPreviewing,
    setPreviewT,
    setPreviewProgress,
    onResume
  }) {
    const unmounted = useUnmountedRef();
    const shouldStop = useMemoizedFn(() => {
      if (unmounted.current) return true;
      if (startByHoverBox.val) {
        if (!isHoveringBox.val) return true;
      } else {
        if (!active) return true;
        if (mouseMoved) return true;
      }
      return false;
    });
    const stop = useMemoizedFn((isClear = false) => {
      if (!isClear) {
        debugAnimation(`stopAnimation: %o`, {
          autoPreviewWhenHover,
          unmounted: unmounted.current,
          isHovering: isHoveringBox.val,
          active,
          mouseMoved
        });
      }
      if (idBox.val) cancelAnimationFrame(idBox.val);
      idBox.val = void 0;
      setAutoPreviewing(false);
      setPreviewProgress(void 0);
      setPreviewT(void 0);
      controller.reset();
    });
    const _paused = reactExports.useRef(false);
    const controller = reactExports.useMemo(() => {
      return {
        shouldStop,
        stop,
        get paused() {
          return _paused.current;
        },
        set paused(val) {
          _paused.current = val;
        },
        togglePaused() {
          const prev2 = this.paused;
          this.paused = !this.paused;
          if (prev2) {
            onResume?.();
          }
        },
        reset() {
          this.paused = false;
        }
      };
    }, [shouldStop, stop, _paused, onResume]);
    return controller;
  }
  function useWatchlaterRelated({
    item,
    cardData,
    onRemoveCurrent,
    actionButtonVisible,
    watchlaterAdded
  }) {
    const {
      avid,
      bvid
    } = cardData;
    const hasWatchlaterEntry = reactExports.useMemo(() => {
      if (isAppRecommend(item) || isPcRecommend(item)) {
        return item.goto === "av";
      }
      if (item.api === EApiType.Rank) {
        return cardData.goto === "av";
      }
      if (item.api === EApiType.Live) {
        return false;
      }
      return !!bvid;
    }, [item, cardData]);
    const $req = useRequest((usingAction, avid2) => usingAction(avid2), {
      manual: true
    });
    const watchlaterAddedPrevious = usePrevious$1(watchlaterAdded);
    const onToggleWatchlater = useMemoizedFn(async (e, usingAction) => {
      e?.preventDefault();
      e?.stopPropagation();
      if ($req.loading) return {
        success: false
      };
      if (!avid || !bvid) {
        return {
          success: false
        };
      }
      usingAction ??= watchlaterAdded ? watchlaterDel : watchlaterAdd;
      const success = await $req.runAsync(usingAction, avid);
      const targetState = usingAction === watchlaterAdd ? true : false;
      if (success) {
        if (targetState) {
          watchlaterState.bvidSet.add(bvid);
        } else {
          watchlaterState.bvidSet.delete(bvid);
        }
        if (item.api === EApiType.Watchlater) {
          if (!targetState) {
            await delay$1(250);
            onRemoveCurrent?.(item, cardData);
          }
        } else {
          antMessage.success(`已${targetState ? "添加" : "移除"}稍后再看`);
        }
      }
      return {
        success,
        targetState
      };
    });
    const addedSize = 18;
    const icon = (() => {
      if ($req.loading) {
        return jsx$1(IconForLoading, { className: "size-16px" });
      }
      if (item.api === EApiType.Watchlater) {
        return watchlaterAdded ? jsx$1(IconForDelete, { className: "size-16px" }) : jsx$1(IconAnimatedChecked, { size: addedSize, useAnimation: watchlaterAddedPrevious === true });
      }
      return watchlaterAdded ? jsx$1(IconAnimatedChecked, { size: addedSize, useAnimation: watchlaterAddedPrevious === false }) : jsx$1(IconForWatchlater, { className: "size-20px" });
    })();
    const tooltip = item.api === EApiType.Watchlater ? watchlaterAdded ? "已添加稍后再看, 点击移除" : "已移除稍后再看" : watchlaterAdded ? "已添加稍后再看, 点击移除" : "稍后再看";
    const watchlaterButtonEl = hasWatchlaterEntry && jsx$1(VideoCardActionButton, { visible: actionButtonVisible, inlinePosition: "right", icon, tooltip, onClick: onToggleWatchlater });
    const context = reactExports.useMemo(() => {
      return {
        watchlaterAdded,
        hasWatchlaterEntry,
        onToggleWatchlater
      };
    }, [onToggleWatchlater, watchlaterAdded, hasWatchlaterEntry]);
    return {
      context,
      watchlaterButtonEl
    };
  }
  const VideoCard = reactExports.memo(function VideoCard2({
    style: style2,
    className,
    item,
    loading,
    active,
    onRemoveCurrent,
    emitter: emitter2,
    recSharedEmitter,
    tab: tab2,
    baseCss,
    gridDisplayMode,
    multiSelecting,
    ...restProps
  }) {
    loading = loading ?? !item;
    const cardData = reactExports.useMemo(() => item && normalizeCardData(item), [item]);
    const dislikeKey = reactExports.useMemo(() => item ? calcRecItemDislikedMapKey(item) : void 0, [item]);
    const dislikedReason = useDislikedReason(dislikeKey);
    const blacklisted = useInBlacklist(cardData?.authorMid);
    const blocked = useInFilterByAuthorList(cardData?.authorMid);
    const watchlaterAdded = useWatchlaterState(cardData?.bvid);
    const multiSelected = useMultiSelectState(item?.uniqId);
    const showingDislikeCard = !!dislikedReason;
    const showingBlacklistCard = blacklisted;
    const showingBlockedCard = blocked;
    const isBlockedCard = showingDislikeCard || showingBlacklistCard || showingBlockedCard;
    const blockedCardCss = useBlockedCardCss(isBlockedCard);
    const _className = clsx("bili-video-card", APP_CLS_CARD, {
      [APP_CLS_CARD_ACTIVE]: active
    }, "relative", className);
    const _css = [baseCss, blockedCardCss, isDisplayAsList(gridDisplayMode) && displayAsListCss.card, multiSelecting && multiSelected && multiSelectedCss];
    return jsx$1("div", { "data-bvid": cardData?.bvid, style: style2, className: _className, css: _css, ...restProps, children: loading ? jsx$1(SkeletonCard, { loading }) : item && cardData && (showingDislikeCard ? jsx$1(DislikedCard, { item, cardData, emitter: emitter2, dislikedReason }) : showingBlacklistCard ? jsx$1(BlockedCard, { item, cardData, blockType: "blacklist" }) : showingBlockedCard ? jsx$1(BlockedCard, { item, cardData, blockType: "filter" }) : jsx$1(VideoCardInner, { item, cardData, active, emitter: emitter2, recSharedEmitter, tab: tab2, onRemoveCurrent, watchlaterAdded, gridDisplayMode, multiSelecting, multiSelected })) });
  });
  var _ref = {
    name: "vpmszz",
    styles: "background-color:unset;position:static;height:100%"
  };
  const VideoCardInner = reactExports.memo(function VideoCardInner2({
    item,
    cardData,
    tab: tab2,
    active = false,
    onRemoveCurrent,
    emitter: emitter2 = defaultVideoCardEmitter,
    recSharedEmitter = defaultRecSharedEmitter,
    watchlaterAdded,
    gridDisplayMode,
    multiSelecting = false,
    multiSelected
  }) {
    const {
      accessKey,
      style: {
        videoCard: {
          useBorder: cardUseBorder,
          useBorderOnlyOnHover: cardUseBorderOnlyOnHover
        }
      },
      videoCard: {
        actions: videoCardActions,
        imgPreview: {
          enabled: imgPreviewEnabled,
          autoPreviewWhenHover,
          disableWhenMultiSelecting
        }
      },
      spaceUpload: {
        showVol
      },
      __internalEnableCopyBvidInfo
    } = useSettingsSnapshot();
    const {
avid,
      bvid,
      cid,
      goto,
      href,
      title,
      cover,
      duration: duration2,
      durationStr,
      recommendReason,
statItems,
authorName,
      authorMid
    } = cardData;
    const authed = !!accessKey;
    const isNormalVideo = goto === "av";
    const allowed = ["av", "bangumi", "picture", "live", "opus"];
    if (!allowed.includes(goto)) {
      appWarn(`none (${allowed.join(",")}) goto type %s`, goto, item);
    }
    const displayingAsList = isDisplayAsList(gridDisplayMode);
    const aspectRatioFromItem = reactExports.useMemo(() => getRecItemDimension({
      item
    })?.aspectRatio, [item]);
    const shouldFetchPreviewData = reactExports.useMemo(() => {
      if (!bvid) return false;
      if (!bvid.startsWith("BV")) return false;
      if (goto !== "av") return false;
      return true;
    }, [bvid, goto]);
    const showPreviewImageEl = (() => {
      if (!imgPreviewEnabled) return false;
      if (disableWhenMultiSelecting && multiSelecting) return false;
      return true;
    })();
    const imagePreviewDataBox = useRefStateBox(void 0);
    const tryFetchImagePreviewData = useLockFn(async () => {
      if (!shouldFetchPreviewData) return;
      if (!showPreviewImageEl) return;
      if (isImagePreviewDataValid(imagePreviewDataBox.val)) return;
      const data2 = await fetchImagePreviewData(bvid);
      imagePreviewDataBox.set(data2);
      if (!isWebApiSuccess(data2.videoshotJson)) {
        warnNoPreview(data2.videoshotJson);
      }
    });
    const warnNoPreview = useLessFrequentFn((json) => {
      antNotification.warning({
        title: `${json.message} (code: ${json.code})`,
        description: `${title} (${bvid})`,
        duration: 2
      });
    }, 3, false);
    const cardRef = reactExports.useRef(null);
    const coverRef = reactExports.useRef(null);
    const videoPreviewWrapperRef = cardUseBorder && !displayingAsList ? cardRef : coverRef;
    const {
      onStartPreviewAnimation,
      onHotkeyPreviewAnimation,
isHovering,
previewImageEl
    } = usePreviewRelated({
      uniqId: item.uniqId,
      recSharedEmitter,
      title,
      active,
      videoDuration: duration2,
      tryFetchImagePreviewData,
      imagePreviewDataBox,
      autoPreviewWhenHover,
      videoPreviewWrapperRef
    });
    useUpdateEffect(() => {
      if (!active) return;
      setGlobalValue(`${APP_KEY_PREFIX}_activeItem`, item);
      if (settings.videoCard.imgPreview.autoPreviewWhenKeyboardSelect) {
        tryFetchImagePreviewData().then(() => {
          onStartPreviewAnimation(false);
        });
      }
    }, [active]);
    const actionButtonVisible = active || isHovering;
    const {
      watchlaterButtonEl,
      context: watchlaterContext
    } = useWatchlaterRelated({
      item,
      cardData,
      onRemoveCurrent,
      actionButtonVisible,
      watchlaterAdded
    });
    const {
      dislikeButtonEl,
      hasDislikeEntry,
      onTriggerDislike
    } = useDislikeRelated({
      item,
      authed,
      actionButtonVisible
    });
    const {
      largePreviewActionButtonEl,
      largePreviewEl,
      shouldUseLargePreviewCurrentTime,
      getLargePreviewCurrentTime,
      largePreviewVisible,
      hideLargePreview
    } = useLargePreviewRelated({
      shouldFetchPreviewData,
      actionButtonVisible,
      hasLargePreviewActionButton: videoCardActions.showLargePreview,
bvid,
      cid,
      uniqId: item.uniqId,
      recSharedEmitter,
      cardTarget: cardRef,
aspectRatioFromItem,
      cover,
      videoCardAsTriggerRef: videoPreviewWrapperRef
});
    const favContext = useInitFavContext(item, avid);
    const {
      onOpenWithMode,
      handleVideoLinkClick,
      consistentOpenMenus,
      conditionalOpenMenus,
      openInPopupActionButtonEl,
      onOpenInPopup
    } = useOpenRelated({
      href,
      item,
      cardData,
      actionButtonVisible,
      hasOpenInPopupActionButton: videoCardActions.openInPipWindow,
      getLargePreviewCurrentTime,
      hideLargePreview,
      shouldUseLargePreviewCurrentTime
    });
    const {
      multiSelectBgEl,
      multiSelectEl,
      toggleMultiSelect
    } = useMultiSelectRelated({
      multiSelecting,
      multiSelected,
      uniqId: item.uniqId
    });
    const handleCardClick = useMemoizedFn((e) => {
      if (!cardUseBorder) return;
      if (e.target.closest(".ant-dropdown-menu")) return;
      if (e.target.closest("a")) return;
      onOpenWithMode();
    });
    useEmitterOn(emitter2, "open", () => onOpenWithMode());
    useEmitterOn(emitter2, "open-in-popup", onOpenInPopup);
    useEmitterOn(emitter2, "open-with-large-preview-visible", () => {
      if (!largePreviewVisible) return;
      hideLargePreview();
      onOpenWithMode();
    });
    useEmitterOn(emitter2, "toggle-watch-later", () => void watchlaterContext.onToggleWatchlater());
    useEmitterOn(emitter2, "trigger-dislike", () => void onTriggerDislike());
    useEmitterOn(emitter2, "start-preview-animation", onStartPreviewAnimation);
    useEmitterOn(emitter2, "hotkey-preview-animation", onHotkeyPreviewAnimation);
    const contextMenus = useContextMenus({
      item,
      cardData,
      tab: tab2,
      watchlaterContext,
      favContext,
      hasDislikeEntry,
      onTriggerDislike,
      onRemoveCurrent,
      consistentOpenMenus,
      conditionalOpenMenus,
      multiSelecting
    });
    const onContextMenuOpenChange = useMemoizedFn((open2) => {
      if (!open2) return;
      favContext.updateFavFolderNames();
    });
    const _hasGeneralTopMark = hasGeneralTopMark(cardData);
    const _isRank = isRank(item);
    const _isStreaming = (
isLive(item) && item.live_status === ELiveStatus.Streaming || isPcRecommend(item) && item.goto === PcRecGoto.Live
    );
    const hasApiTypeTag = tab2 === ETab.AppRecommend && !isAppRecommend(item) && !isLive(item);
    const hasVolMark = isSpaceUpload(item) && showVol || isFav(item) && !!item.vol && !hasApiTypeTag;
    const copyBvidInfoButtonEl = __internalEnableCopyBvidInfo && bvid && jsx$1(VideoCardActionButton, { visible: actionButtonVisible, inlinePosition: "right", icon: jsx$1(IconForCopy, { className: "size-14px" }), tooltip: "复制 BVID 信息", onClick: (e) => {
      e.stopPropagation();
      e.preventDefault();
      copyContent(getBvidInfo(cardData));
    } });
    const topLeftMarksEl = jsxs(Fragment, { children: [
      multiSelecting && multiSelectEl,
      dislikeButtonEl,
      _hasGeneralTopMark && jsx$1(GeneralTopMark, { cardData }),
      _isRank && jsx$1(RankNumMark, { item }),
      _isStreaming && jsx$1(LiveBadge, {}),
      hasApiTypeTag && jsx$1(ApiTypeTag, { item }),
      hasVolMark && !!item.vol && jsx$1(VolMark, { vol: item.vol, volTooltip: isFav(item) ? item.volTooltip : void 0 })
    ] });
    const topRightActionsEl = jsxs(Fragment, { children: [
      watchlaterButtonEl,
      copyBvidInfoButtonEl,
      openInPopupActionButtonEl,
      largePreviewActionButtonEl
    ] });
    const hasTopLeftMarks = !isEmptyFragment(topLeftMarksEl);
    const hasTopRightActions = !isEmptyFragment(topRightActionsEl);
    const clsTopLeftMarksContainer = r("left-top-marks", C$2.topContainer("left"), multiSelecting && "gap-x-10px");
    const watchlaterProgressBar = isWatchlater(item) && item.progress > 0 ? jsx$1(SimpleProgressBar, { progress: item.progress / item.duration, className: clsx("h-3px", clsZWatchlaterProgressBar) }) : void 0;
    const clsVideoCardPrefix = `.${APP_CLS_ROOT} .${APP_CLS_CARD}`;
    const coverRoundCss = reactExports.useMemo(() => {
      return [ css(clsVideoCardPrefix, " &{overflow:hidden;border-radius:", videoCardBorderRadiusValue, ";transition:border-radius 0.2s ease;}", ""), !displayingAsList && [
(active || multiSelecting || cardUseBorder && !cardUseBorderOnlyOnHover) && css(clsVideoCardPrefix, " &{border-bottom-left-radius:0;border-bottom-right-radius:0;}", ""),
cardUseBorder && css(clsVideoCardPrefix, ":hover &{border-bottom-left-radius:0;border-bottom-right-radius:0;}", "")
      ]];
    }, [displayingAsList, active, multiSelecting, cardUseBorder, cardUseBorderOnlyOnHover]);
    const shouldMakeCoverClear = reactExports.useMemo(() => {
      if (cardUseBorder && !cardUseBorderOnlyOnHover) return false;
      if (multiSelecting) return false;
      return !cardUseBorder || cardUseBorder && cardUseBorderOnlyOnHover && !isHovering;
    }, [cardUseBorder, cardUseBorderOnlyOnHover, isHovering, multiSelecting]);
    const target = useLinkTarget();
    const coverContent = jsxs(
      "a",
      {
        ref: coverRef,
        href,
        target,
        className: clsx(APP_CLS_CARD_COVER, "relative isolate block overflow-hidden", shouldMakeCoverClear && "ring-1px ring-gate-border"),
        css: [coverRoundCss, displayingAsList && displayAsListCss.cover, "", ""],
        onClick: handleVideoLinkClick,
        onContextMenu: (e) => {
          const handled = showNativeContextMenuWhenAltKeyPressed(e);
          if (handled) return;
          e.preventDefault();
        },
        children: [
jsx$1("div", { className: "bili-video-card__image", style: {
            aspectRatio: "16 / 9"
          }, children: cover ? jsx$1("div", { className: "bili-video-card__image--wrap", children: jsx$1(Picture, { src: `${cover}@672w_378h_1c_!web-home-common-cover`, className: "bili-video-card__cover v-img", style: {
            borderRadius: 0
          }, imgProps: {
            alt: title
          } }) }) : jsx$1("div", { className: "size-full flex-center", children: jsx$1("div", { className: "line-clamp-3 my-auto px-4 py-2 text-center text-1.2em line-height-snug", children: title }) }) }),
jsxs("div", { className: "bili-video-card__stats", css: css(clsVideoCardPrefix, " &{pointer-events:none;border-radius:0;}", ""), children: [
jsx$1("div", { className: "bili-video-card__stats--left gap-x-4px xl:gap-x-8px", children: statItems.map(({
              field,
              value
            }) => jsx$1(StatItemDisplay, { field, value }, field)) }),
jsx$1("span", { className: "bili-video-card__stats__duration relative top-0.5px", children: isNormalVideo && durationStr })
          ] }),
          watchlaterProgressBar,
          showPreviewImageEl && previewImageEl,
          multiSelectBgEl,
          hasTopLeftMarks && jsx$1("div", { className: clsTopLeftMarksContainer, children: topLeftMarksEl }),
          hasTopRightActions && jsx$1("div", { className: clsx("right-actions", C$2.topContainer("right")), children: topRightActionsEl })
        ]
      }
    );
    const bottomContent = jsx$1(VideoCardBottom, { item, cardData, gridDisplayMode, handleVideoLinkClick: multiSelecting ? toggleMultiSelect : handleVideoLinkClick });
    const extraContent = jsx$1(Fragment, { children: largePreviewEl });
    function wrapDropdown(c2) {
      return jsx$1(Dropdown, { trigger: ["contextMenu"], onOpenChange: onContextMenuOpenChange, getPopupContainer: () => {
        return cardRef.current?.closest(`.${APP_CLS_CARD}`) ?? document.body;
      }, rootClassName: clsx(clsZVideoCardContextMenu, clsGateVideoCardContextMenuRoot), menu: {
        items: contextMenus,
        className: "w-max"
}, children: c2 });
    }
    function wrapCardWrapper(c2) {
      return jsx$1("div", { className: "bili-video-card__wrap", ref: cardRef, css: [_ref, displayingAsList && displayAsListCss.cardWrap, "", ""], onClick: multiSelecting ? toggleMultiSelect : handleCardClick, onContextMenu: (e) => {
        if (cardUseBorder) {
          e.preventDefault();
        }
      }, children: c2 });
    }
    const wrappedContent = cardUseBorder && !displayingAsList ? wrapDropdown(wrapCardWrapper( jsxs(Fragment, { children: [
      coverContent,
      bottomContent
    ] }))) : wrapCardWrapper( jsxs(Fragment, { children: [
      wrapDropdown(coverContent),
      bottomContent
    ] }));
    return jsxs(Fragment, { children: [
      wrappedContent,
      extraContent
    ] });
  });
  var useKeyPress$1 = {};
  const require$$1 = getAugmentedNamespace(tslib_es6$1);
  var useLatest = {};
  var hasRequiredUseLatest;
  function requireUseLatest() {
    if (hasRequiredUseLatest) return useLatest;
    hasRequiredUseLatest = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", {
        value: true
      });
      exports$1["default"] = void 0;
      var _react = requireReact();
      function useLatest2(value) {
        var ref2 = (0, _react.useRef)(value);
        ref2.current = value;
        return ref2;
      }
      exports$1["default"] = useLatest2;
    })(useLatest);
    return useLatest;
  }
  var useDeepCompareWithTarget = {};
  var useEffectWithTarget = {};
  var createEffectWithTarget = {};
  var useUnmount = {};
  var isDev = {};
  var hasRequiredIsDev;
  function requireIsDev() {
    if (hasRequiredIsDev) return isDev;
    hasRequiredIsDev = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", {
        value: true
      });
      exports$1["default"] = void 0;
      var isDev2 = false;
      exports$1["default"] = isDev2;
    })(isDev);
    return isDev;
  }
  var hasRequiredUseUnmount;
  function requireUseUnmount() {
    if (hasRequiredUseUnmount) return useUnmount;
    hasRequiredUseUnmount = 1;
    (function(exports$1) {
      var _interopRequireDefault = requireInteropRequireDefault();
      Object.defineProperty(exports$1, "__esModule", {
        value: true
      });
      exports$1["default"] = void 0;
      var _typeof2 = _interopRequireDefault(require_typeof());
      var _react = requireReact();
      var _useLatest = _interopRequireDefault( requireUseLatest());
      var _utils = requireUtils();
      var _isDev = _interopRequireDefault( requireIsDev());
      var useUnmount2 = function useUnmount3(fn) {
        if (_isDev["default"]) {
          if (!(0, _utils.isFunction)(fn)) {
            console.error("useUnmount expected parameter is a function, got ".concat((0, _typeof2["default"])(fn)));
          }
        }
        var fnRef = (0, _useLatest["default"])(fn);
        (0, _react.useEffect)(function() {
          return function() {
            fnRef.current();
          };
        }, []);
      };
      exports$1["default"] = useUnmount2;
    })(useUnmount);
    return useUnmount;
  }
  var depsAreSame = {};
  var hasRequiredDepsAreSame;
  function requireDepsAreSame() {
    if (hasRequiredDepsAreSame) return depsAreSame;
    hasRequiredDepsAreSame = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", {
        value: true
      });
      exports$1["default"] = void 0;
      function depsAreSame2(oldDeps, deps) {
        if (oldDeps === deps) {
          return true;
        }
        for (var i2 = 0; i2 < oldDeps.length; i2++) {
          if (!Object.is(oldDeps[i2], deps[i2])) {
            return false;
          }
        }
        return true;
      }
      exports$1["default"] = depsAreSame2;
    })(depsAreSame);
    return depsAreSame;
  }
  var hasRequiredCreateEffectWithTarget;
  function requireCreateEffectWithTarget() {
    if (hasRequiredCreateEffectWithTarget) return createEffectWithTarget;
    hasRequiredCreateEffectWithTarget = 1;
    (function(exports$1) {
      var _interopRequireDefault = requireInteropRequireDefault();
      Object.defineProperty(exports$1, "__esModule", {
        value: true
      });
      exports$1["default"] = void 0;
      var _react = requireReact();
      var _useUnmount = _interopRequireDefault( requireUseUnmount());
      var _depsAreSame = _interopRequireDefault( requireDepsAreSame());
      var _domTarget = requireDomTarget();
      var createEffectWithTarget2 = function createEffectWithTarget3(useEffectType) {
        var useEffectWithTarget2 = function useEffectWithTarget3(effect2, deps, target) {
          var hasInitRef = (0, _react.useRef)(false);
          var lastElementRef = (0, _react.useRef)([]);
          var lastDepsRef = (0, _react.useRef)([]);
          var unLoadRef = (0, _react.useRef)(void 0);
          useEffectType(function() {
            var _a;
            var targets = Array.isArray(target) ? target : [target];
            var els = targets.map(function(item) {
              return (0, _domTarget.getTargetElement)(item);
            });
            if (!hasInitRef.current) {
              hasInitRef.current = true;
              lastElementRef.current = els;
              lastDepsRef.current = deps;
              unLoadRef.current = effect2();
              return;
            }
            if (els.length !== lastElementRef.current.length || !(0, _depsAreSame["default"])(lastElementRef.current, els) || !(0, _depsAreSame["default"])(lastDepsRef.current, deps)) {
              (_a = unLoadRef.current) === null || _a === void 0 ? void 0 : _a.call(unLoadRef);
              lastElementRef.current = els;
              lastDepsRef.current = deps;
              unLoadRef.current = effect2();
            }
          });
          (0, _useUnmount["default"])(function() {
            var _a;
            (_a = unLoadRef.current) === null || _a === void 0 ? void 0 : _a.call(unLoadRef);
            hasInitRef.current = false;
          });
        };
        return useEffectWithTarget2;
      };
      exports$1["default"] = createEffectWithTarget2;
    })(createEffectWithTarget);
    return createEffectWithTarget;
  }
  var hasRequiredUseEffectWithTarget;
  function requireUseEffectWithTarget() {
    if (hasRequiredUseEffectWithTarget) return useEffectWithTarget;
    hasRequiredUseEffectWithTarget = 1;
    (function(exports$1) {
      var _interopRequireDefault = requireInteropRequireDefault();
      Object.defineProperty(exports$1, "__esModule", {
        value: true
      });
      exports$1["default"] = void 0;
      var _react = requireReact();
      var _createEffectWithTarget = _interopRequireDefault( requireCreateEffectWithTarget());
      var useEffectWithTarget2 = (0, _createEffectWithTarget["default"])(_react.useEffect);
      exports$1["default"] = useEffectWithTarget2;
    })(useEffectWithTarget);
    return useEffectWithTarget;
  }
  var depsEqual = {};
  var hasRequiredDepsEqual;
  function requireDepsEqual() {
    if (hasRequiredDepsEqual) return depsEqual;
    hasRequiredDepsEqual = 1;
    var _interopRequireDefault = requireInteropRequireDefault();
    Object.defineProperty(depsEqual, "__esModule", {
      value: true
    });
    depsEqual.depsEqual = void 0;
    var _reactFastCompare = _interopRequireDefault(requireReactFastCompare());
    depsEqual.depsEqual = function depsEqual2(aDeps, bDeps) {
      if (aDeps === void 0) {
        aDeps = [];
      }
      if (bDeps === void 0) {
        bDeps = [];
      }
      return (0, _reactFastCompare["default"])(aDeps, bDeps);
    };
    return depsEqual;
  }
  var hasRequiredUseDeepCompareWithTarget;
  function requireUseDeepCompareWithTarget() {
    if (hasRequiredUseDeepCompareWithTarget) return useDeepCompareWithTarget;
    hasRequiredUseDeepCompareWithTarget = 1;
    (function(exports$1) {
      var _interopRequireDefault = requireInteropRequireDefault();
      Object.defineProperty(exports$1, "__esModule", {
        value: true
      });
      exports$1["default"] = void 0;
      var _react = requireReact();
      var _useEffectWithTarget = _interopRequireDefault( requireUseEffectWithTarget());
      var _depsEqual = requireDepsEqual();
      var useDeepCompareEffectWithTarget2 = function useDeepCompareEffectWithTarget3(effect2, deps, target) {
        var ref2 = (0, _react.useRef)(void 0);
        var signalRef = (0, _react.useRef)(0);
        if (!(0, _depsEqual.depsEqual)(deps, ref2.current)) {
          signalRef.current += 1;
        }
        ref2.current = deps;
        (0, _useEffectWithTarget["default"])(effect2, [signalRef.current], target);
      };
      exports$1["default"] = useDeepCompareEffectWithTarget2;
    })(useDeepCompareWithTarget);
    return useDeepCompareWithTarget;
  }
  var isAppleDevice = {};
  var hasRequiredIsAppleDevice;
  function requireIsAppleDevice() {
    if (hasRequiredIsAppleDevice) return isAppleDevice;
    hasRequiredIsAppleDevice = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", {
        value: true
      });
      exports$1["default"] = void 0;
      var isAppleDevice2 = /(mac|iphone|ipod|ipad)/i.test(typeof navigator !== "undefined" ? navigator === null || navigator === void 0 ? void 0 : navigator.platform : "");
      exports$1["default"] = isAppleDevice2;
    })(isAppleDevice);
    return isAppleDevice;
  }
  var hasRequiredUseKeyPress;
  function requireUseKeyPress() {
    if (hasRequiredUseKeyPress) return useKeyPress$1;
    hasRequiredUseKeyPress = 1;
    (function(exports$1) {
      var _interopRequireDefault = requireInteropRequireDefault();
      Object.defineProperty(exports$1, "__esModule", {
        value: true
      });
      exports$1["default"] = void 0;
      var _tslib = require$$1;
      var _useLatest = _interopRequireDefault( requireUseLatest());
      var _utils = requireUtils();
      var _domTarget = requireDomTarget();
      var _useDeepCompareWithTarget = _interopRequireDefault( requireUseDeepCompareWithTarget());
      var _isAppleDevice = _interopRequireDefault( requireIsAppleDevice());
      var aliasKeyCodeMap2 = {
        "0": 48,
        "1": 49,
        "2": 50,
        "3": 51,
        "4": 52,
        "5": 53,
        "6": 54,
        "7": 55,
        "8": 56,
        "9": 57,
        backspace: 8,
        tab: 9,
        enter: 13,
        shift: 16,
        ctrl: 17,
        alt: 18,
        pausebreak: 19,
        capslock: 20,
        esc: 27,
        space: 32,
        pageup: 33,
        pagedown: 34,
        end: 35,
        home: 36,
        leftarrow: 37,
        uparrow: 38,
        rightarrow: 39,
        downarrow: 40,
        insert: 45,
        "delete": 46,
        a: 65,
        b: 66,
        c: 67,
        d: 68,
        e: 69,
        f: 70,
        g: 71,
        h: 72,
        i: 73,
        j: 74,
        k: 75,
        l: 76,
        m: 77,
        n: 78,
        o: 79,
        p: 80,
        q: 81,
        r: 82,
        s: 83,
        t: 84,
        u: 85,
        v: 86,
        w: 87,
        x: 88,
        y: 89,
        z: 90,
        leftwindowkey: 91,
        rightwindowkey: 92,
        meta: _isAppleDevice["default"] ? [91, 93] : [91, 92],
        selectkey: 93,
        numpad0: 96,
        numpad1: 97,
        numpad2: 98,
        numpad3: 99,
        numpad4: 100,
        numpad5: 101,
        numpad6: 102,
        numpad7: 103,
        numpad8: 104,
        numpad9: 105,
        multiply: 106,
        add: 107,
        subtract: 109,
        decimalpoint: 110,
        divide: 111,
        f1: 112,
        f2: 113,
        f3: 114,
        f4: 115,
        f5: 116,
        f6: 117,
        f7: 118,
        f8: 119,
        f9: 120,
        f10: 121,
        f11: 122,
        f12: 123,
        numlock: 144,
        scrolllock: 145,
        semicolon: 186,
        equalsign: 187,
        comma: 188,
        dash: 189,
        period: 190,
        forwardslash: 191,
        graveaccent: 192,
        openbracket: 219,
        backslash: 220,
        closebracket: 221,
        singlequote: 222
      };
      var modifierKey2 = {
        ctrl: function ctrl(event) {
          return event.ctrlKey;
        },
        shift: function shift(event) {
          return event.shiftKey;
        },
        alt: function alt(event) {
          return event.altKey;
        },
        meta: function meta(event) {
          if (event.type === "keyup") {
            return aliasKeyCodeMap2.meta.includes(event.keyCode);
          }
          return event.metaKey;
        }
      };
      function isValidKeyType2(value) {
        return (0, _utils.isString)(value) || (0, _utils.isNumber)(value);
      }
      function countKeyByEvent2(event) {
        var countOfModifier = Object.keys(modifierKey2).reduce(function(total, key) {
          if (modifierKey2[key](event)) {
            return total + 1;
          }
          return total;
        }, 0);
        return [16, 17, 18, 91, 92].includes(event.keyCode) ? countOfModifier : countOfModifier + 1;
      }
      function genFilterKey2(event, keyFilter, exactMatch) {
        var e_1, _a;
        if (!event.key) {
          return false;
        }
        if ((0, _utils.isNumber)(keyFilter)) {
          return event.keyCode === keyFilter ? keyFilter : false;
        }
        var genArr = keyFilter.split(".");
        var genLen = 0;
        try {
          for (var genArr_1 = (0, _tslib.__values)(genArr), genArr_1_1 = genArr_1.next(); !genArr_1_1.done; genArr_1_1 = genArr_1.next()) {
            var key = genArr_1_1.value;
            var genModifier = modifierKey2[key];
            var aliasKeyCode = aliasKeyCodeMap2[key.toLowerCase()];
            if (genModifier && genModifier(event) || aliasKeyCode && aliasKeyCode === event.keyCode) {
              genLen++;
            }
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (genArr_1_1 && !genArr_1_1.done && (_a = genArr_1["return"])) _a.call(genArr_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        if (exactMatch) {
          return genLen === genArr.length && countKeyByEvent2(event) === genArr.length ? keyFilter : false;
        }
        return genLen === genArr.length ? keyFilter : false;
      }
      function genKeyFormatter2(keyFilter, exactMatch) {
        if ((0, _utils.isFunction)(keyFilter)) {
          return keyFilter;
        }
        if (isValidKeyType2(keyFilter)) {
          return function(event) {
            return genFilterKey2(event, keyFilter, exactMatch);
          };
        }
        if (Array.isArray(keyFilter)) {
          return function(event) {
            return keyFilter.find(function(item) {
              return genFilterKey2(event, item, exactMatch);
            });
          };
        }
        return function() {
          return Boolean(keyFilter);
        };
      }
      var defaultEvents2 = ["keydown"];
      function useKeyPress2(keyFilter, eventHandler, option) {
        var _a = option || {}, _b = _a.events, events2 = _b === void 0 ? defaultEvents2 : _b, target = _a.target, _c = _a.exactMatch, exactMatch = _c === void 0 ? false : _c, _d = _a.useCapture, useCapture = _d === void 0 ? false : _d;
        var eventHandlerRef = (0, _useLatest["default"])(eventHandler);
        var keyFilterRef = (0, _useLatest["default"])(keyFilter);
        (0, _useDeepCompareWithTarget["default"])(function() {
          var e_2, _a2;
          var _b2;
          var el = (0, _domTarget.getTargetElement)(target, window);
          if (!el) {
            return;
          }
          var callbackHandler = function callbackHandler2(event) {
            var _a3;
            var keyEvent = event;
            var genGuard = genKeyFormatter2(keyFilterRef.current, exactMatch);
            var keyGuard = genGuard(keyEvent);
            var firedKey = isValidKeyType2(keyGuard) ? keyGuard : keyEvent.key;
            if (keyGuard) {
              return (_a3 = eventHandlerRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(eventHandlerRef, keyEvent, firedKey);
            }
          };
          try {
            for (var events_1 = (0, _tslib.__values)(events2), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
              var eventName = events_1_1.value;
              (_b2 = el === null || el === void 0 ? void 0 : el.addEventListener) === null || _b2 === void 0 ? void 0 : _b2.call(el, eventName, callbackHandler, useCapture);
            }
          } catch (e_2_1) {
            e_2 = {
              error: e_2_1
            };
          } finally {
            try {
              if (events_1_1 && !events_1_1.done && (_a2 = events_1["return"])) _a2.call(events_1);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
          return function() {
            var e_3, _a3;
            var _b3;
            try {
              for (var events_2 = (0, _tslib.__values)(events2), events_2_1 = events_2.next(); !events_2_1.done; events_2_1 = events_2.next()) {
                var eventName2 = events_2_1.value;
                (_b3 = el === null || el === void 0 ? void 0 : el.removeEventListener) === null || _b3 === void 0 ? void 0 : _b3.call(el, eventName2, callbackHandler, useCapture);
              }
            } catch (e_3_1) {
              e_3 = {
                error: e_3_1
              };
            } finally {
              try {
                if (events_2_1 && !events_2_1.done && (_a3 = events_2["return"])) _a3.call(events_2);
              } finally {
                if (e_3) throw e_3.error;
              }
            }
          };
        }, [events2], target);
      }
      exports$1["default"] = useKeyPress2;
    })(useKeyPress$1);
    return useKeyPress$1;
  }
  var useKeyPressExports = requireUseKeyPress();
  const useKeyPress = getDefaultExportFromCjs(useKeyPressExports);
  function useShortcut({
    enabled: enabled2,
    refresh,
    minIndex = 0,
    maxIndex,
    gridRef,
    getScrollerRect,
    changeScrollY,
    videoCardEmitters,
    activeLargePreviewItemIndex
  }) {
    const [activeIndex, setActiveIndex] = reactExports.useState(void 0);
    const isEnabled = useMemoizedFn(() => {
      if (!enabled2) return false;
      if (shouldDisableShortcut()) return false;
      return true;
    });
    const activeIndexIsValid = useMemoizedFn(() => {
      if (typeof activeIndex !== "number") return false;
      if (!gridRef.current) return false;
      const scrollerRect = getScrollerRect();
      const rect = gridRef.current.querySelector(`.${APP_CLS_CARD}.${APP_CLS_CARD_ACTIVE}`)?.getBoundingClientRect();
      if (!scrollerRect || !rect) return false;
      if (rect.top - scrollerRect.top < -(scrollerRect.height + rect.height)) {
        return false;
      }
      if (rect.top - scrollerRect.top > scrollerRect.height * 2 + rect.height) {
        return false;
      }
      return true;
    });
    function getStep(direction) {
      const card = getCardAt(activeIndex);
      const activeLeft = card.getBoundingClientRect().left;
      const isLeftSame = (left) => Math.abs(activeLeft - left) < 1;
      {
        const col = getColumnCount(gridRef.current);
        const step2 = direction === "down" ? col : -col;
        const newCard = getCardAt(activeIndex + step2);
        if (newCard) {
          const left = newCard.getBoundingClientRect().left;
          if (isLeftSame(left)) {
            return step2;
          }
        }
      }
      let step = 0;
      let cur = card;
      const next2 = () => direction === "down" ? cur.nextElementSibling : cur.previousElementSibling;
      while (next2()) {
        cur = next2();
        if (!cur.classList.contains(APP_CLS_CARD)) continue;
        direction === "down" ? step++ : step--;
        const left = cur.getBoundingClientRect().left;
        if (isLeftSame(left)) {
          return step;
        }
      }
      return 0;
    }
    const addActiveIndex = (step) => (e) => {
      if (!isEnabled()) return;
      e?.preventDefault();
      let newActiveIndex;
      if (activeIndexIsValid()) {
        const _step = typeof step === "number" ? step : getStep(step);
        newActiveIndex = activeIndex + _step;
      } else {
        newActiveIndex = getInitialIndex();
      }
      if (newActiveIndex < minIndex) {
        makeVisible(minIndex);
        return;
      }
      if (newActiveIndex > maxIndex) {
        makeVisible(maxIndex);
        return;
      }
      setActiveIndex(newActiveIndex);
      makeVisible(newActiveIndex);
    };
    const useKey = (keyFilter, eventHandler) => {
      useKeyPress(keyFilter, (event, key) => {
        if (!isEnabled()) return;
        eventHandler(event, key);
      }, {
        exactMatch: true
      });
    };
    useKey("leftarrow", addActiveIndex(-1));
    useKey("rightarrow", addActiveIndex(1));
    useKey("tab", addActiveIndex(1));
    useKey("shift.tab", addActiveIndex(-1));
    useKey("uparrow", addActiveIndex("up"));
    useKey("downarrow", addActiveIndex("down"));
    const clearActiveIndex = () => {
      if (!isEnabled()) return;
      setActiveIndex(void 0);
    };
    const getActiveEmitter = () => {
      if (!isEnabled() || typeof activeIndex !== "number") return;
      return videoCardEmitters[activeIndex];
    };
    useKey("esc", clearActiveIndex);
    useKey("enter", (e) => {
      if (!isEnabled()) return;
      if (typeof activeIndex === "number") {
        e.preventDefault();
        return videoCardEmitters[activeIndex]?.emit("open");
      }
      if (typeof activeLargePreviewItemIndex === "number") {
        e.preventDefault();
        return videoCardEmitters[activeLargePreviewItemIndex]?.emit("open-with-large-preview-visible");
      }
    });
    useKey("x", () => getActiveEmitter()?.emit("open-in-popup"));
    useKey("backspace", () => getActiveEmitter()?.emit("trigger-dislike"));
    useKey(["s", "w"], () => getActiveEmitter()?.emit("toggle-watch-later"));
    useKey(["period", "p"], () => getActiveEmitter()?.emit("hotkey-preview-animation"));
    function getInitialIndex() {
      const scrollerRect = getScrollerRect();
      if (!scrollerRect) return 0;
      const cards = getCards();
      for (const [i2, card] of cards.entries()) {
        const rect = card.getBoundingClientRect();
        if (rect.top >= scrollerRect.top) {
          return i2;
        }
      }
      return 0;
    }
    const CARDS_SELECTOR = `.${APP_CLS_CARD}`;
    function getCards() {
      return [...gridRef.current?.querySelectorAll(CARDS_SELECTOR) || []];
    }
    function getCardAt(index) {
      return getCards()[index];
    }
    function makeVisible(index) {
      const card = getCardAt(index);
      card?.scrollIntoViewIfNeeded?.(false);
      const scrollerRect = getScrollerRect();
      const rect = card.getBoundingClientRect();
      if (!scrollerRect || !rect) return;
      if (rect.top <= scrollerRect.top) {
        const offset2 = -(scrollerRect.top - rect.top + 10);
        changeScrollY?.({
          offset: offset2
        });
        return;
      }
      if (scrollerRect.bottom - rect.bottom < 20) {
        const offset2 = 20 - (scrollerRect.bottom - rect.bottom);
        changeScrollY?.({
          offset: offset2
        });
        return;
      }
    }
    return {
      activeIndex,
      clearActiveIndex
    };
  }
  const countCache1 = new Map();
  const countCache2 = new Map();
  function getColumnCount(gridEl, mayHaveNarrowMode = true) {
    const {
      gridDisplayMode,
      useCustomGrid,
      enableForceColumn,
      forceColumnCount,
      cardMinWidth
    } = settings.grid;
    if (gridDisplayMode === EGridDisplayMode.List) return 1;
    if (mayHaveNarrowMode && gridDisplayMode === EGridDisplayMode.TwoColumnGrid) return 2;
    if (useCustomGrid && enableForceColumn && forceColumnCount) return forceColumnCount;
    gridEl ||= document.querySelector(`.${videoGrid}`);
    if (!gridEl) {
      appWarn("getColumnCount(): gridEl not found");
      return 0;
    }
    const countCache = useCustomGrid ? countCache1 : countCache2;
    const cacheKey2 = new URLSearchParams({
      width: Math.round(gridEl.clientWidth).toString(),
      cardMinWidth: useCustomGrid ? cardMinWidth.toString() : ""
    }).toString();
    {
      const count2 = countCache.get(cacheKey2);
      if (count2) return count2;
    }
    const style2 = window.getComputedStyle(gridEl);
    if (style2.display !== "grid") {
      appWarn('getColumnCount(): gridEl.style.display !== "grid"');
      return 0;
    }
    const count = style2.gridTemplateColumns.split(" ").length;
    countCache.set(cacheKey2, count);
    return count;
  }
  const debug$3 = baseDebug.extend("service");
  const recItemUniqer = (item) => {
    if (item.api === EApiType.Separator) return item.uniqId;
    const {
      bvid
    } = normalizeCardData(item);
    if (bvid) return bvid;
    return item.uniqId;
  };
  function concatRecItems(existing, newItems) {
    return uniqBy([...existing, ...newItems], recItemUniqer);
  }
  const willUsePcApi = (tab2) => tab2 === ETab.PcRecommend || tab2 === ETab.KeepFollowOnly;
  async function fetchMinCount(count, fetcherOptions, filterMultiplier = 5) {
    const {
      tab: tab2,
      service,
      abortSignal,
      firstFetch
    } = fetcherOptions;
    let items = [];
    let hasMore = true;
    const addMore = async (restCount) => {
      let cur = [];
      if (!isRecTab(tab2)) {
        cur = await service.loadMore(abortSignal) ?? [];
        hasMore = service.hasMore;
        cur = filterRecItems(cur, tab2);
        items = concatRecItems(items, cur);
        return;
      }
      let times2;
      if (tab2 === ETab.KeepFollowOnly) {
        times2 = 8;
        debug$3("getMinCount: addMore(restCount = %s) times=%s", restCount, times2);
      } else {
        const pagesize = willUsePcApi(tab2) ? PcRecService.PAGE_SIZE : AppRecService.PAGE_SIZE;
        const hasFilter = (() => {
          const {
            enabled: enabled2,
            byAuthor,
            byTitle,
            minDuration,
            minPlayCount,
            minDanmakuCount
          } = settings.filter;
          return enabled2 || byAuthor.enabled || byTitle.enabled || minDuration.enabled || minPlayCount.enabled || minDanmakuCount.enabled;
        })();
        const multipler = hasFilter ? filterMultiplier : 1.2;
        times2 = Math.ceil(restCount * multipler / pagesize);
        debug$3("getMinCount: addMore(restCount = %s) multipler=%s pagesize=%s times=%s", restCount, multipler, pagesize, times2);
      }
      if (willUsePcApi(tab2)) {
        const s2 = service;
        if (firstFetch) await s2.preloadPcInitialRecItems(abortSignal);
        await s2.preloadTimesFromApiIfNeeded(abortSignal, times2);
      } else {
        const s2 = service;
        if (!s2.config.addOtherTabContents) {
          await s2.preloadTimesFromApiIfNeeded(abortSignal, times2);
        }
      }
      cur = await service.loadMore(abortSignal) || [];
      cur = filterRecItems(cur, tab2);
      items = concatRecItems(items, cur);
      hasMore = service.hasMore;
    };
    await addMore(count);
    while (true) {
      if (abortSignal?.aborted) {
        debug$3("getMinCount: break for abortSignal");
        break;
      }
      if (!hasMore) {
        debug$3("getMinCount: break for tab=%s hasMore=false", tab2);
        break;
      }
      const len = items.filter((x) => x.api !== EApiType.Separator).length;
      if (len >= count) break;
      await addMore(count - items.length);
    }
    return items;
  }
  const getGridRefreshCount = () => getColumnCount() * 4;
  async function refreshForGrid(fetcherOptions) {
    let minCount = getGridRefreshCount();
    if (fetcherOptions.tab === ETab.DynamicFeed) {
      const _service = fetcherOptions.service;
      if (await _service.shouldReduceMinCount()) {
        minCount = 1;
      }
    }
    return fetchMinCount(minCount, fetcherOptions, 5);
  }
  var dist$1 = { exports: {} };
  var dist = dist$1.exports;
  var hasRequiredDist;
  function requireDist() {
    if (hasRequiredDist) return dist$1.exports;
    hasRequiredDist = 1;
    (function(module, exports$1) {
      !(function(e, t2) {
        module.exports = t2();
      })(dist, (() => (() => {
        var e = { d: (t3, r3) => {
          for (var s2 in r3) e.o(r3, s2) && !e.o(t3, s2) && Object.defineProperty(t3, s2, { enumerable: true, get: r3[s2] });
        }, o: (e2, t3) => Object.prototype.hasOwnProperty.call(e2, t3), r: (e2) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
        } }, t2 = {};
        e.r(t2), e.d(t2, { RingBuffer: () => r2 });
        class r2 {
          static fromArray(e2, t3 = 0) {
            const s2 = new r2(t3);
            return s2.fromArray(e2, 0 === t3), s2;
          }
          constructor(e2) {
            if (this.buffer = [], this.pos = 0, e2 < 0) throw new RangeError("Invalid size.");
            this.size = e2;
          }
          getSize() {
            return this.size;
          }
          getPos() {
            return this.pos;
          }
          getBufferLength() {
            return this.buffer.length;
          }
          add(...e2) {
            e2.forEach(((e3) => {
              this.buffer[this.pos] = e3, this.pos = (this.pos + 1) % this.size;
            }));
          }
          get(e2) {
            if (e2 < 0 && (e2 += this.buffer.length), !(e2 < 0 || e2 > this.buffer.length)) return this.buffer.length < this.size ? this.buffer[e2] : this.buffer[(this.pos + e2) % this.size];
          }
          getFirst() {
            return this.get(0);
          }
          getLast() {
            return this.get(-1);
          }
          getFirstN(e2) {
            return 0 === e2 ? [] : e2 < 0 ? this.getLastN(-e2) : this.toArray().slice(0, e2);
          }
          getLastN(e2) {
            return 0 === e2 ? [] : e2 < 0 ? this.getFirstN(-e2) : this.toArray().slice(-e2);
          }
          remove(e2, t3 = 1) {
            if (e2 < 0 && (e2 += this.buffer.length), e2 < 0 || e2 > this.buffer.length) return [];
            const r3 = this.toArray(), s2 = r3.splice(e2, t3);
            return this.fromArray(r3), s2;
          }
          removeFirst() {
            return this.remove(0)[0];
          }
          removeLast() {
            return this.remove(-1)[0];
          }
          toArray() {
            return this.buffer.slice(this.pos).concat(this.buffer.slice(0, this.pos));
          }
          fromArray(e2, t3 = false) {
            if (!Array.isArray(e2)) throw new TypeError("Input value is not an array.");
            t3 && this.resize(e2.length), 0 !== this.size && (this.buffer = e2.slice(-this.size), this.pos = this.buffer.length % this.size);
          }
          clear() {
            this.buffer = [], this.pos = 0;
          }
          resize(e2) {
            if (e2 < 0) throw new RangeError("The size does not allow negative values.");
            if (0 === e2) this.clear();
            else if (e2 !== this.size) {
              const t3 = this.toArray();
              this.fromArray(t3.slice(-e2)), this.pos = this.buffer.length % e2;
            }
            this.size = e2;
          }
          isFull() {
            return this.buffer.length === this.size;
          }
          isEmpty() {
            return 0 === this.buffer.length;
          }
        }
        return t2;
      })()));
    })(dist$1);
    return dist$1.exports;
  }
  var distExports = requireDist();
  function checkIsSameTabButConditionsChanged(tab2, serviceRegistry) {
    let s2;
    switch (tab2) {
      case ETab.DynamicFeed:
        s2 = serviceRegistry[ETab.DynamicFeed];
        return !isEqual$2(s2?.config, getDynamicFeedServiceConfig());
      case ETab.Fav:
        s2 = serviceRegistry[ETab.Fav];
        return !isEqual$2(s2?.config, getFavServiceConfig());
      case ETab.Hot:
        s2 = serviceRegistry[ETab.Hot];
        if (s2?.subtab !== hotStore.subtab) return true;
        if (
s2.subtab === EHotSubTab.Rank && s2.service instanceof RankRecService && s2.service.rankTab.slug !== rankStore.slug
        ) {
          return true;
        }
        return false;
      case ETab.SpaceUpload:
        s2 = serviceRegistry[ETab.SpaceUpload];
        return !isEqual$2(s2?.config, getSpaceUploadServiceConfig());
      default:
        return false;
    }
  }
  const MAX_REC_SERVICE_HISTORY_COUNT = 5;
  function useRefresh({
    tab: tab2,
    debug: debug2,
    fetcher,
    preAction,
    postAction,
    updateViewFromService,
    self: self2
  }) {
    const recSelf = useRecSelfContext();
    const {
      serviceRegistry
    } = recSelf;
    useMount(() => {
      refresh("reuse");
    });
    useUnmount$1(() => {
      self2.abortController.abort();
    });
    const refresh = useMemoizedFn(async (refreshType = "refresh") => {
      const isSameTabRefreshing = recSelf.refreshing && recSelf.refreshingTab === tab2;
      if (isSameTabRefreshing) {
        if (checkIsSameTabButConditionsChanged(tab2, serviceRegistry)) {
          debug2("refresh(): tab=%s [start], current refreshing, sametab but conditions change, abort existing", tab2);
          self2.abortController.abort();
        } else {
          debug2("refresh() tab=%s [start], current refreshing, prevent same tab refresh()", tab2);
          return;
        }
      } else {
        debug2("refresh(): tab=%s [start]", tab2);
      }
      const start = performance.now();
      recSelf.setStore({
        refreshing: true,
        refreshingTab: tab2
      });
      self2.setStore({
        refreshError: void 0,
        hasMore: true,
        items: [],
        refreshTs: Date.now()
      });
      const abortController = new AbortController();
      const {
        signal
      } = abortController;
      self2.abortController = abortController;
      await preAction?.();
      function _onAny() {
        recSelf.setStore({
          refreshing: false,
          refreshingTab: void 0
        });
        self2.setStore({
          showSkeleton: false
        });
      }
      function onError(err) {
        _onAny();
        self2.setStore({
          refreshError: err
        });
        console.error(err);
      }
      function onSuccess() {
        _onAny();
        self2.setStore({
          hasMore: getServiceFromRegistry(serviceRegistry, tab2).hasMore
        });
      }
      async function doFetch(service, firstFetch) {
        const [err, currentItems] = await attemptAsync(() => fetcher({
          tab: tab2,
          service,
          abortSignal: signal,
          firstFetch
        }));
        if (signal.aborted) return debug2("refresh(): tab=%s [aborted], ignoring rest code", tab2);
        if (err) return onError(err);
        self2.setStore({
          items: currentItems ?? []
        });
        return true;
      }
      let existingService;
      let willRecreateService;
      switch (refreshType) {
        case "refresh":
          break;
        case "reuse":
          existingService = serviceRegistry[tab2];
          break;
        case "back":
        case "forward": {
          invariant$1(isRecTab(tab2), `only rec tab can perform back/forward`);
          const [canGoBack, canGoForward] = recSelf.getTabBackForwardStatus(tab2);
          if (refreshType === "back" && !canGoBack) throw new Error("cannot go back");
          if (refreshType === "forward" && !canGoForward) throw new Error("cannot go forward");
          const state2 = recSelf.getTabServiceQueueState(tab2);
          invariant$1(state2, `state should not be nil`);
          const {
            len,
            cursor: cursor2
          } = state2;
          const inc = refreshType === "back" ? -1 : 1;
          const newCursor = cursor2 + inc;
          if (newCursor < 0 || newCursor > len - 1) throw new Error("cannot go back/forward");
          const service = recSelf.serviceQueueMap[tab2]?.get(newCursor);
          invariant$1(service, `service should not be nil`);
          existingService = service;
          recSelf.setTabServiceQueueState(tab2, {
            cursor: newCursor,
            len
          });
          serviceRegistry[tab2] = service;
          willRecreateService = false;
          break;
        }
        default:
          assertNever(refreshType);
          break;
      }
      if (existingService) {
        existingService.restore();
        const cachedItems = filterRecItems(existingService.qs.bufferQueue, tab2).slice(0, getGridRefreshCount());
        self2.setStore({
          items: cachedItems
        });
        const success = !!await doFetch(existingService);
        willRecreateService ??= success && !!TabConfig[tab2].swr;
      } else {
        self2.setStore({
          showSkeleton: true
        });
        willRecreateService = true;
      }
      if (willRecreateService) {
        const [err, service] = attempt(() => createServiceMap[tab2]({
          existingService
        }));
        if (err) return onError(err);
        const firstFetch = serviceRegistry[tab2] ? void 0 : true;
        serviceRegistry[tab2] = service;
        updateViewFromService?.();
        if (isRecTab(tab2)) {
          recSelf.serviceQueueMap[tab2] ||= new distExports.RingBuffer(MAX_REC_SERVICE_HISTORY_COUNT);
          const queue = recSelf.serviceQueueMap[tab2];
          queue.add(service);
          const len = queue.getBufferLength();
          recSelf.setTabServiceQueueState(tab2, {
            len,
            cursor: len - 1
          });
        }
        const success = await doFetch(service, firstFetch);
        if (!success) return;
      }
      onSuccess();
      await postAction?.();
      const cost = performance.now() - start;
      debug2("refresh(): tab=%s [success] cost %s ms", tab2, cost.toFixed(0));
    });
    const {
      recSharedEmitter
    } = useRecSelfContext();
    useEmitterOn(recSharedEmitter, "refresh", refresh);
    return {
      refresh
    };
  }
  const iconParkOutlineLoading = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsxs("g", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, children: [
jsx$1("path", { d: "M4 24c0 11.046 8.954 20 20 20v0c11.046 0 20-8.954 20-20S35.046 4 24 4" }),
jsx$1("path", { d: "M36 24c0-6.627-5.373-12-12-12s-12 5.373-12 12s5.373 12 12 12v0" })
    ] })
  ] });
  const ForwardRef$2 = reactExports.forwardRef(iconParkOutlineLoading);
  const debug$2 = baseDebug.extend("components:RecGrid");
  const clsGridColSpanFull = "grid-col-span-full";
  class RecGridSelf {

store = proxy({
      refreshTs: -1,
      showSkeleton: false,
      hasMore: true,
      refreshError: void 0,
      items: []
    });
    useStore = () => {
      return useSnapshot(this.store);
    };
    setStore = (payload) => {
      const wrapRefKeys = ["items", "refreshError"];
      for (const key of wrapRefKeys) {
        if (typeof payload[key] === "object") {
          payload[key] = ref(payload[key]);
        }
      }
      Object.assign(this.store, payload);
    };
    loadedPage = 0;
    abortController = new AbortController();
    loadMoreLocker = {};
    isLocked = (lockKey) => !!this.loadMoreLocker[lockKey];
    lock = (lockKey) => void (this.loadMoreLocker = {
      [lockKey]: true
    });
    unlock = (lockKey) => void (this.loadMoreLocker[lockKey] = false);
    get loadMoreRunning() {
      return this.isLocked(this.store.refreshTs);
    }
  }
  const RecGrid = reactExports.memo(function RecGrid2({
    className: propClassName,
    containerClassName: propContainerClassName,
    shortcutEnabled,
    tab: tab2,
    infiniteScrollUseWindow,
    onScrollToTop,
    scrollerRef,
    ref: ref2
  }) {
    const recSelf = useRecSelfContext();
    const {
      serviceRegistry,
      recSharedEmitter
    } = recSelf;
    const {
      refreshing
    } = recSelf.useStore();
    const self2 = useCreation(() => new RecGridSelf(), []);
    const {
      useCustomGrid,
      gridDisplayMode,
      enableForceColumn,
      forceColumnCount,
      cardMinWidth
    } = useSnapshot(settings.grid);
    const {
      multiSelecting
    } = useSnapshot(multiSelectStore);
    const unmountedRef = useUnmountedRef();
    useSetupGridState();
    const updateViewFromService = useMemoizedFn(() => {
      if (unmountedRef.current) return;
      recSelf.setStore({
        tabbarView: serviceRegistry[tab2]?.tabbarView,
        sidebarView: serviceRegistry[tab2]?.sidebarView
      });
    });
    useMount(updateViewFromService);
    const preAction = useMemoizedFn(() => {
      clearActiveIndex();
      updateViewFromService();
      onScrollToTop?.();
    });
    const postAction = useMemoizedFn(() => {
      clearActiveIndex();
      updateViewFromService();
      self2.loadedPage = 1;
      checkShouldLoadMore();
    });
    const {
      refresh
    } = useRefresh({
      tab: tab2,
      debug: debug$2,
      fetcher: refreshForGrid,
      preAction,
      postAction,
      updateViewFromService,
      self: self2
    });
    reactExports.useImperativeHandle(ref2, () => ({
      refresh
    }), [refresh]);
    const {
      items,
      hasMore,
      refreshError,
      refreshTs,
      showSkeleton
    } = self2.useStore();
    reactExports.useEffect(() => setGlobalGridItems(items), [items]);
    const goOutAt = reactExports.useRef(void 0);
    useEventListener("visibilitychange", (_e) => {
      const visible = document.visibilityState === "visible";
      if (!visible) {
        goOutAt.current = Date.now();
        return;
      }
      if (recSelf.refreshing) return;
      if (self2.loadMoreRunning) return;
      if (tab2 === ETab.Watchlater && goOutAt.current && Date.now() - goOutAt.current > ms("1h")) {
        refresh("reuse");
      }
    }, {
      target: document
    });
    const checkShouldLoadMore = useMemoizedFn(async () => {
      await delay$1(isSafari ? 100 : 0);
      debug$2("checkShouldLoadMore(): footerInViewRef = %s", footerInViewRef.current);
      if (footerInViewRef.current) return loadMore();
    });
    const loadMorePrecheck = useMemoizedFn(() => {
      if (unmountedRef.current ||
recSelf.refreshing ||
self2.abortController.signal.aborted || self2.loadMoreRunning || self2.store.refreshTs < 0 ||
self2.store.refreshError || !self2.store.hasMore) {
        return false;
      }
      return true;
    });
    const loadMore = useMemoizedFn(async () => {
      if (!loadMorePrecheck()) return;
      const startingRefreshTs = self2.store.refreshTs;
      self2.lock(startingRefreshTs);
      let newItems = self2.store.items;
      let newHasMore = true;
      let err;
      try {
        const service = getServiceFromRegistry(serviceRegistry, tab2);
        let more = await service.loadMore(self2.abortController.signal) || [];
        more = filterRecItems(more, tab2);
        newItems = concatRecItems(newItems, more);
        newHasMore = service.hasMore;
      } catch (e) {
        err = e;
      }
      if (err) {
        self2.unlock(startingRefreshTs);
        antNotification.error({
          title: "加载失败",
          description: err.message || err.stack
        });
        throw err;
      }
      {
        const currentRefreshTs = self2.store.refreshTs;
        if (startingRefreshTs !== currentRefreshTs) {
          debug$2("loadMore: skip update for mismatch refreshTs, %o != %o", startingRefreshTs, currentRefreshTs);
          self2.unlock(startingRefreshTs);
          return;
        }
      }
      self2.loadedPage++;
      debug$2("loadMore: loadedPage(%s) len(%s -> %s)", self2.loadedPage, self2.store.items.length, newItems.length);
      self2.setStore({
        hasMore: newHasMore,
        items: newItems
      });
      self2.unlock(startingRefreshTs);
      checkShouldLoadMore();
    });
    const loadToEnd = useMemoizedFn(async () => {
      const notifyKey = "RecGrid:loadToEnd";
      const notifyErrorArgs = {
        key: notifyKey + ":error",
        title: "加载全部",
        duration: 15
      };
      const notifySuccessArgs = {
        title: "加载全部"
      };
      const error = (description) => {
        antNotification.error({
          ...notifyErrorArgs,
          description
        });
        throw new Error("loadToEnd error", {
          cause: description
        });
      };
      if (!querySupportsLoadToEnd()) return error("当前 Tab 不支持加载全部");
      if (self2.store.refreshError) return error("预检查失败: 先前错误");
      if (!self2.store.hasMore) {
        return antNotification.success({
          ...notifySuccessArgs,
          description: "没有更多了"
        });
      }
      while (!loadMorePrecheck()) await delay$1(500);
      while (loadMorePrecheck()) await loadMore();
      antNotification.success({
        ...notifySuccessArgs,
        description: "已完成"
      });
    });
    useEmitterOn(recSharedEmitter, "load-to-end", loadToEnd);
    const fullList = items;
    const videoList = reactExports.useMemo(() => fullList.filter((x) => x.api !== EApiType.Separator), [fullList]);
    const gridRef = reactExports.useRef(null);
    const getScrollerRect = useMemoizedFn(() => {
      if (infiniteScrollUseWindow) {
        const yStart = $headerHeight.get() + 50;
        return new DOMRect(0, yStart, window.innerWidth, window.innerHeight - yStart);
      } else {
        return scrollerRef?.current?.getBoundingClientRect();
      }
    });
    const videoCardEmitterCache = reactExports.useMemo(() => new Map(), [refreshTs]);
    const videoCardEmitters = reactExports.useMemo(() => {
      return videoList.map(({
        uniqId
      }) => {
        const cacheKey2 = uniqId;
        return videoCardEmitterCache.get(cacheKey2) || (() => {
          const instance = new Emittery();
          videoCardEmitterCache.set(cacheKey2, instance);
          return instance;
        })();
      });
    }, [videoList]);
    const [activeLargePreviewUniqId, setActiveLargePreviewUniqId] = reactExports.useState(void 0);
    useEmitterOn(recSharedEmitter, "show-large-preview", setActiveLargePreviewUniqId);
    const activeLargePreviewItemIndex = reactExports.useMemo(() => {
      if (!activeLargePreviewUniqId) return;
      return videoList.findIndex((item) => item.uniqId === activeLargePreviewUniqId);
    }, [fullList, activeLargePreviewUniqId]);
    const {
      activeIndex,
      clearActiveIndex
    } = useShortcut({
      enabled: shortcutEnabled,
      refresh,
      maxIndex: videoList.length - 1,
      gridRef,
      getScrollerRect,
      videoCardEmitters,
      activeLargePreviewItemIndex,
      changeScrollY: infiniteScrollUseWindow ? function({
        offset: offset2,
        absolute
      }) {
        const scroller = document.documentElement;
        if (typeof offset2 === "number") {
          scroller.scrollTop += offset2;
          return;
        }
        if (typeof absolute === "number") {
          scroller.scrollTop = absolute;
          return;
        }
      } : void 0
    });
    const modifyItems = useMemoizedFn((fn) => {
      const val = self2.store.items;
      self2.setStore({
        items: fn(val) ?? val
      });
    });
    const handleRemoveCards = useMemoizedFn((uniqIds, titles, silent) => {
      modifyItems((items2) => {
        const newItems = items2.slice();
        const removedTitles = [];
        for (const [i2, uniqId] of uniqIds.entries()) {
          const index = newItems.findIndex((x) => x.uniqId === uniqId);
          if (index === -1) continue;
          newItems.splice(index, 1);
          const title = titles?.[i2];
          if (title) removedTitles.push(title);
          if (tab2 === ETab.Watchlater) {
            serviceRegistry[tab2]?.decreaseTotal();
          }
          if (tab2 === ETab.Fav) {
            serviceRegistry[tab2]?.decreaseTotal();
          }
        }
        if (!silent && removedTitles.length) {
          if (removedTitles.length <= 3) {
            removedTitles.forEach((_t) => antMessage.success(`已移除: ${removedTitles.join(", ")}`));
          } else {
            antMessage.success(`已移除: ${removedTitles.length}个视频`);
          }
        }
        return newItems;
      });
    });
    const handleMoveCardTo = useMemoizedFn((itemUniqId, pos) => {
      modifyItems((items2) => {
        const index = items2.findIndex((x) => x.uniqId === itemUniqId);
        if (index === -1) return;
        if (pos === "start") {
          const firstNoneSeparatorIndex = items2.findIndex((x) => x.api !== EApiType.Separator);
          return arrayMove(items2, index, firstNoneSeparatorIndex);
        } else if (pos === "end") {
          return arrayMove(items2, index, items2.length - 1);
        }
      });
    });
    useEmitterOn(recSharedEmitter, "remove-cards", (eventArg) => handleRemoveCards(...eventArg));
    useEmitterOn(recSharedEmitter, "move-card-to", (eventArg) => handleMoveCardTo(...eventArg));
    const {
      ref: footerRef,
      inView: __footerInView
    } = useInView({
      root: infiniteScrollUseWindow ? null : scrollerRef?.current || null,
      rootMargin: `0px 0px ${window.innerHeight}px 0px`,
      onChange(inView) {
        if (inView) {
          debug$2("footerInView change to visible");
          attempt(() => footerInViewRef.current = true);
          checkShouldLoadMore();
        }
      }
    });
    const footerInViewRef = useLatest$1(__footerInView);
    const footer = jsx$1("div", { ref: footerRef, className: clsx(clsGridColSpanFull, "flex items-center justify-center py-30px text-size-120%"), children: !refreshing && jsx$1(Fragment, { children: hasMore ? jsxs(Fragment, { children: [
jsx$1(ForwardRef$2, { className: "mr-10px size-40px animate-spin color-gate-primary" }),
      "加载中~"
    ] }) : jsx$1(Fragment, { children: "没有更多了~" }) }) });
    const containerClassName = clsx("min-h-100vh @container-inline-size", propContainerClassName);
    const gridStyleConfig = reactExports.useMemo(() => {
      const {
        videoGrid: videoGrid2,
        videoGridBiliFeed4: videoGridBiliFeed42,
        videoGridCustom: videoGridCustom2,
        videoGridAddonCenterEmpty: videoGridAddonCenterEmpty2,
        gridTemplateColumnsUsingVarCol: gridTemplateColumnsUsingVarCol2,
        gridTemplateColumnsUsingCardMinWidth: gridTemplateColumnsUsingCardMinWidth2,
        narrowMode: narrowMode2
      } = gridClassNames;
      const clsGridTemplateColumns = useCustomGrid && !(enableForceColumn && forceColumnCount) && gridDisplayMode !== EGridDisplayMode.TwoColumnGrid ? gridTemplateColumnsUsingCardMinWidth2 : gridTemplateColumnsUsingVarCol2;
      const baseClass = [
        APP_CLS_GRID,
videoGrid2,
        clsGridTemplateColumns,
        useCustomGrid ? videoGridCustom2 : videoGridBiliFeed42
      ];
      const renderClassName = (...more) => clsx(baseClass, ...more, propClassName);
      if (gridDisplayMode === EGridDisplayMode.TwoColumnGrid) {
        return {
          className: renderClassName(narrowMode2)
        };
      }
      if (gridDisplayMode === EGridDisplayMode.CenterEmptyGrid) {
        baseClass.push(videoGridAddonCenterEmpty2);
      }
      if (!useCustomGrid) {
        return {
          className: renderClassName()
        };
      }
      if (enableForceColumn && forceColumnCount) {
        return {
          className: renderClassName(),
          style: {
            "--col": forceColumnCount.toString()
          }
        };
      } else {
        return {
          className: renderClassName(),
          style: {
            "--card-min-width": `${cardMinWidth}px`
          }
        };
      }
    }, [gridClassNames, useCustomGrid, gridDisplayMode, enableForceColumn, forceColumnCount, cardMinWidth, propClassName]);
    const cardBorderCss = useCardBorderCss();
    const render4 = ({
      gridChildren,
      gridSiblings
    } = {}) => {
      return jsxs("div", { "data-tab": tab2, className: containerClassName, children: [
jsx$1("div", { "data-tab": tab2, ref: gridRef, ...gridStyleConfig, children: gridChildren }),
        gridSiblings
      ] });
    };
    if (refreshError) {
      console.error("RecGrid.refresh error:", refreshError.stack || refreshError);
      return render4({
        gridSiblings: jsx$1(ErrorDetail, { tab: tab2, err: refreshError })
      });
    }
    if (refreshing && showSkeleton) {
      const cardCount = getGridRefreshCount();
      return render4({
        gridChildren: Array.from({
          length: cardCount
        }).fill(0).map((_2, index) => {
          return jsx$1(VideoCard, { loading: true, tab: tab2 }, index);
        })
      });
    }
    const renderItem = (item) => {
      if (item.api === EApiType.Separator) {
        return jsx$1(Divider, { className: clsx(clsGridColSpanFull, clsGateVideoGridDivider), orientation: "horizontal", titlePlacement: "left", children: item.content }, item.uniqId);
      } else {
        const index = videoList.findIndex((x) => x.uniqId === item.uniqId);
        const active = index === activeIndex;
        return jsx$1(VideoCard, { baseCss: [cardBorderCss, getActiveCardBorderCss(active)], tab: tab2, item, active, onRemoveCurrent: (item2, data2, silent) => handleRemoveCards([item2.uniqId], [data2.title], silent), emitter: videoCardEmitters[index], recSharedEmitter, gridDisplayMode, multiSelecting }, item.uniqId);
      }
    };
    return render4({
      gridChildren: jsxs(Fragment, { children: [
        fullList.map(renderItem),
        footer
      ] })
    });
  });
  function RefreshButton({
    className = "",
    style: style2,
    tab: tab2,
    refreshHotkeyEnabled,
    ref: ref2
  }) {
    refreshHotkeyEnabled ??= true;
    const {
      refreshing
    } = useRecSelfContext().useStore();
    const onRefresh = useOnRefresh();
    const btn = reactExports.useRef(null);
    const click = useMemoizedFn(() => {
      if (!btn.current) return;
      if (btn.current.disabled) return;
      btn.current.click();
    });
    reactExports.useImperativeHandle(ref2, () => ({
      click
    }), []);
    useKeyPress$2("r", () => {
      if (shouldDisableShortcut()) return;
      if (!refreshHotkeyEnabled) return;
      click();
    }, {
      exactMatch: true
    });
    const {
      watchlaterItemsOrder,
      popularWeeklyUseShuffle
    } = useSettingsSnapshot();
    const {
      usingShuffle: favUsingShuffle
    } = useSnapshot(favStore);
    const text = tab2 === ETab.AppRecommend || tab2 === ETab.PcRecommend || tab2 === ETab.KeepFollowOnly || tab2 === ETab.Watchlater && watchlaterItemsOrder === WatchlaterItemsOrder.Shuffle || tab2 === ETab.Fav && favUsingShuffle || tab2 === ETab.Hot && isHotTabUsingShuffle(popularWeeklyUseShuffle) ? "换一换" : "刷新";
    const [scope, animate] = useAnimate();
    const onClick = useMemoizedFn((e) => {
      animate(scope.current, {
        rotate: [0, 360]
      }, {
        duration: 0.5,
        type: "tween"
      });
      onRefresh();
    });
    return jsxs(Button$1, { ref: btn, style: style2, className: clsx(clsAntdButton, "[&:disabled]:cursor-wait", className), disabled: refreshing, onClick, children: [
jsx$1(IconForRoll, { ref: scope, className: "size-14px" }),
      text
    ] });
  }
  const sidebarViewWrapperCss = {
    name: "x4d4ct",
    styles: "scrollbar-width:thin;.ant-menu-item-group-title{padding:4px 8px;}.ant-menu-item{margin-block:1px;}ul.ant-menu-item-group-list{font-size:inherit;}"
  };
  function useTabExtraClassName(tab2) {
    const hotSubTab = useSnapshot(hotStore).subtab;
    if (tab2 === ETab.Fav) return "max-w-300px";
    if (tab2 === ETab.DynamicFeed) return "min-w-200px";
    if (tab2 === ETab.Hot && hotSubTab === EHotSubTab.Rank) return "min-w-130px";
  }
  function RecSidebar({
    className: propClassName,
    style: propStyle,
    sidebarView,
    tab: tab2
  }) {
    const visible = useSidebarVisible(tab2);
    const usingClassName = r("h-fit max-w-250px w-max flex-none overflow-x-hidden overflow-y-auto b-1px b-gate-border rounded-15px b-solid", useTabExtraClassName(tab2), propClassName);
    return visible && sidebarView && jsx$1("div", { className: usingClassName, css: sidebarViewWrapperCss, style: propStyle, children: jsx$1(ConfigProvider, { theme: {
      components: {
        Menu: {
          itemHeight: 30
        }
      }
    }, children: sidebarView }) });
  }
  const ModalFeed = reactExports.memo(function ModalFeed2({
    show,
    onHide: onHide2
  }) {
    const {
      grid: {
        gridDisplayMode
      },
      modalFeedFullScreen,
      sidebarAlign
    } = useSettingsSnapshot();
    const {
      usingTwoColumnMode
    } = gridDisplayModeChecker(gridDisplayMode);
    const useFullScreen = !usingTwoColumnMode && modalFeedFullScreen;
    const scrollerRef = reactExports.useRef(null);
    const modalBorderCls = reactExports.useMemo(() => {
      const borderWidth2 = useFullScreen ? "b-5px" : "b-1px";
      return clsx(borderWidth2, "b-gate-primary b-solid");
    }, [useFullScreen]);
    const onScrollToTop = useMemoizedFn(() => {
      if (scrollerRef.current) {
        scrollerRef.current.scrollTop = 0;
      }
    });
    const {
      modalSettingsVisible
    } = useModalsState();
    const shortcutEnabled = [show, !modalSettingsVisible, !useModalDislikeVisible(), !useModalMoveFavVisible()].every(Boolean);
    const recSelf = useInitRecSelf(true);
    const {
      tabbarView,
      sidebarView
    } = recSelf.useStore();
    const {
      tab: tab2,
      direction
    } = useDeferredTab();
    const renderHeader = () => {
      return jsxs("div", { className: clsx(BaseModalClassNames.modalHeader, "gap-x-15px pr-15px"), children: [
jsxs("div", { className: "left flex flex-shrink-1 flex-wrap items-center gap-x-15px gap-y-4px", children: [
jsx$1(VideoSourceTab, {}),
          tabbarView
        ] }),
jsxs("div", { className: "right flex flex-shrink-0 items-center gap-x-8px", children: [
          gridDisplayMode === EGridDisplayMode.TwoColumnGrid ? null : jsx$1(CollapseBtn, { initialOpen: true, children: jsx$1(ModalFeedConfigChecks, {}) }),
jsx$1(RefreshButton, { refreshHotkeyEnabled: shortcutEnabled, tab: tab2 }),
jsx$1(ModalClose, { onClick: onHide2, className: "ml-5px" })
        ] })
      ] });
    };
    const clsModalMask = clsx(usingTwoColumnMode && "bg-black/90%");
    const clsBase = "h-[calc(100vh-30px)] max-h-unset w-[calc(100vw-30px)] pr-0";
    const clsFullScreen = "h-full w-full";
    const clsModal = clsx(clsBase, useFullScreen && clsFullScreen, usingTwoColumnMode && clsTwoColumnModeWidth, modalBorderCls);
    return jsx$1(RecSelfContext.Provider, { value: recSelf, children: jsxs(BaseModal, { show, onHide: onHide2, clsModalMask, clsModal, children: [
      renderHeader(),
jsxs("div", { "data-role": "modal-body", className: clsx("flex flex-1 gap-x-25px overflow-hidden", sidebarAlign === ESidebarAlign.Right && "flex-row-reverse"), children: [
jsx$1(RecSidebar, { tab: tab2, sidebarView, className: "max-h-full" }),
jsx$1("div", { className: "h-full flex-1 overflow-y-auto pr-15px", ref: scrollerRef, children: jsx$1(RecGrid, { tab: tab2, direction, shortcutEnabled, onScrollToTop, infiniteScrollUseWindow: false, scrollerRef }, tab2) })
      ] })
    ] }) });
  });
  function ModalFeedConfigChecks() {
    return jsx$1(Fragment, { children: jsx$1(CheckboxSettingItem, { configPath: "modalFeedFullScreen", label: "全屏", tooltip: "世界清净了~" }) });
  }
  const modalsState = proxy({
    modalFeedVisible: false,
    modalSettingsVisible: false
  });
  function useModalsState() {
    return useSnapshot(modalsState);
  }
  function toggleModalFeed() {
    if (modalsState.modalFeedVisible) {
      hideModalFeed();
    } else {
      showModalFeed();
    }
  }
  function showModalFeed() {
    renderOnce();
    modalsState.modalFeedVisible = true;
  }
  function hideModalFeed() {
    modalsState.modalFeedVisible = false;
  }
  function toggleModalSettings() {
    if (modalsState.modalSettingsVisible) {
      hideModalSettings();
    } else {
      showModalSettings();
    }
  }
  function showModalSettings() {
    renderOnce();
    modalsState.modalSettingsVisible = true;
  }
  function hideModalSettings() {
    modalsState.modalSettingsVisible = false;
  }
  function registerSettingsGmCommand() {
    GM.registerMenuCommand?.("⚙️ 设置", showModalSettings);
  }
  const renderOnce = once(function render3() {
    const container = document.createElement("div");
    container.classList.add("modals-container", APP_CLS_ROOT);
    document.body.appendChild(container);
    const r2 = clientExports.createRoot(container);
    r2.render( jsx$1(AppRoot, { children: jsx$1(ModalsContainer, {}) }));
  });
  function ModalsContainer() {
    const {
      modalFeedVisible,
      modalSettingsVisible
    } = useModalsState();
    return jsxs(Fragment, { children: [
jsx$1(ModalFeed, { show: modalFeedVisible, onHide: hideModalFeed }),
jsx$1(ModalSettings, { show: modalSettingsVisible, onHide: hideModalSettings })
    ] });
  }
  const floatEntryStore = proxyWithLocalStorage({
    align: "right",
    top: 100
}, "float-entry");
  const C = {
    wrapperInner: "flex flex-col items-center gap-y-8px b-1px b-gate-primary rounded-18px b-solid bg-gate-bg p-4px",
    buttonIcon: "size-18px"
  };
  function GateFloatEntry() {
    return jsx$1(DndContext, { children: jsx$1(GateFloatEntryInner, {}) });
  }
  function GateFloatEntryInner() {
    const {
      align,
      top
    } = useSnapshot(floatEntryStore, {
      sync: true
    });
    const tooltipConfig = reactExports.useMemo(() => {
      const factor = align === "right" ? -1 : 1;
      return {
        arrow: false,
        placement: align === "right" ? "left" : "right",
        align: {
          offset: [10 * factor, 0]
        }
      };
    }, [align]);
    const gateEntryHref = reactExports.useMemo(getGateEntryHref, []);
    const {
      attributes: attributes2,
      listeners: listeners2,
      setNodeRef,
      setActivatorNodeRef,
      transform
    } = useDraggable({
      id: "GateFloatEntry"
    });
    useDndMonitor({
      onDragEnd(e) {
        if (e.active.id === "GateFloatEntry") {
          $windowSize.update();
          const rect = wrapperRef.current?.getBoundingClientRect();
          if (!rect) return;
          const top2 = minmax(Math.round(rect.top), 0, window.innerHeight - rect.height);
          let align2 = floatEntryStore.align;
          const shouldChangeAlign = floatEntryStore.align === "right" && rect.left < window.innerWidth / 4 || floatEntryStore.align === "left" && rect.right > window.innerWidth / 4 * 3;
          if (shouldChangeAlign) align2 = floatEntryStore.align === "right" ? "left" : "right";
          appLog("new pos", {
            align: align2,
            top: top2
          });
          floatEntryStore.align = align2;
          floatEntryStore.top = top2;
          wrapperRef.current?.animate([{
            transform: align2 === "right" ? `translateX(-${window.innerWidth - rect.right}px)` : `translateX(${rect.left}px)`
          }, {
            transform: "translateX(0)"
          }], {
            duration: 200,
            easing: "ease-in-out"
          });
        }
      }
    });
    const wrapperRef = useDelegatedRef(setNodeRef);
    const wrapperClassName = r("fixed transition-200 transition-ease-in-out transition-property-right,left", clsZGateFloatEntry, align === "right" && "right--30px pr-6px hover:right-0", align === "left" && "left--30px pl-6px hover:left-0");
    useMount($windowSize.updateThrottled);
    const {
      height: windowHeight
    } = $windowSize.use();
    const usingTop = reactExports.useMemo(() => minmax(top, 0, windowHeight - 150), [top, windowHeight]);
    return jsx$1("div", { ref: wrapperRef, className: wrapperClassName, style: {
      top: `${usingTop}px`,
      transform: CSS.Transform.toString(transform)
    }, children: jsxs("div", { className: C.wrapperInner, children: [
jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
        APP_NAME,
        ": 在新窗口打开"
      ] }), ...tooltipConfig, children: jsx$1(Button$1, { className: "icon-only-round-button", href: gateEntryHref, target: "_blank", children: jsx$1(IconForOpenExternalLink, { className: C.buttonIcon }) }) }),
jsx$1(AntdTooltip, { title: jsxs(Fragment, { children: [
        APP_NAME,
        ": 弹窗打开"
      ] }), ...tooltipConfig, children: jsx$1(Button$1, { className: "icon-only-round-button", onClick: toggleModalFeed, children: jsx$1(ForwardRef$d, { className: C.buttonIcon }) }) }),
jsx$1(Button$1, { className: "icon-only-round-button cursor-move", ...listeners2, ...attributes2, ref: setActivatorNodeRef, children: jsx$1(ForwardRef$e, { className: "size-14px" }) })
    ] }) });
  }
  function useSizeExpression(target, fn, initialValue2) {
    const _fn = useMemoizedFn(fn);
    const box2 = useRefStateBox(initialValue2);
    reactExports.useEffect(() => {
      const observer2 = new ResizeObserver((entries) => {
        for (const entry of entries) {
          if (entry.target === target && entry.contentRect) {
            const val = _fn(entry);
            if (!isEqual$2(box2.val, val)) {
              box2.set(val);
            }
          }
        }
      });
      observer2.observe(target);
      return () => {
        observer2.disconnect();
      };
    }, [target, _fn]);
    return box2.state;
  }
  function useSticky() {
    const stickyRef = reactExports.useRef(null);
    const [sticky, setSticky] = reactExports.useState(false);
    reactExports.useEffect(() => {
      const observe2 = throttle$2(() => {
        if (!stickyRef.current) return;
        const refPageOffset = Math.trunc(stickyRef.current.getBoundingClientRect().top * 10) / 10;
        const stickyOffset = Number.parseInt(getComputedStyle(stickyRef.current).top);
        const stickyActive = refPageOffset <= stickyOffset;
        setSticky(stickyActive);
      }, 16);
      observe2();
      document.addEventListener("scroll", observe2);
      window.addEventListener("resize", observe2);
      window.addEventListener("orientationchange", observe2);
      return () => {
        document.removeEventListener("scroll", observe2);
        window.removeEventListener("resize", observe2);
        window.removeEventListener("orientationchange", observe2);
      };
    }, [sticky]);
    return [stickyRef, sticky];
  }
  const iconParkOutlineArrowRight = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "M42 24H6m24-12l12 12l-12 12" })
  ] });
  const ForwardRef$1 = reactExports.forwardRef(iconParkOutlineArrowRight);
  const iconParkOutlineArrowLeft = ({
    title,
    titleId,
    ...props
  }, ref2) => jsxs("svg", { viewBox: "0 0 48 48", width: "1.2em", height: "1.2em", ref: ref2, "aria-labelledby": titleId, ...props, children: [
    title ? jsx$1("title", { id: titleId, children: title }) : null,
jsx$1("path", { fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 4, d: "M5.799 24h36m-24 12l-12-12l12-12" })
  ] });
  const ForwardRef = reactExports.forwardRef(iconParkOutlineArrowLeft);
  const debug$1 = baseDebug.extend("RecHeader");
  function RecHeader({
    tab: tab2,
    leftSlot,
    rightSlot,
    shortcutEnabled,
    ref: ref2
  }) {
    const {
      pureRecommend,
      showBackForwardButtons,
      multiSelect: {
        showIcon: multiSelectShowIcon
      },
      style: {
        pureRecommend: {
          useStickyTabbar,
          stickyTabbarShadow,
          useWhiteBackground
        }
      }
    } = useSettingsSnapshot();
    const onRefresh = useOnRefresh();
    const _isRecTab = reactExports.useMemo(() => isRecTab(tab2), [tab2]);
    const recSelf = useRecSelfContext();
    const {
      refreshing
    } = recSelf.useStore();
    const [canGoBack, canGoForward] = recSelf.useTabBackForwardStatus(tab2);
    const serviceQueueState = recSelf.useTabServiceQueueState(tab2);
    const serviceQueueStateInfo = serviceQueueState ? jsxs(Fragment, { children: [
      " ",
      "(当前 ",
      serviceQueueState.cursor + 1,
      "/",
      serviceQueueState.len,
      ")"
    ] }) : void 0;
    useKeyPress$2(["shift.comma"], (e) => {
      if (shouldDisableShortcut()) return;
      toggleModalSettings();
    }, {
      exactMatch: true,
      useCapture: true
    });
    const [stickyRef, sticky] = useSticky();
    const scrollToTop = useMemoizedFn(() => {
      if (!pureRecommend) return;
      const container = stickyRef.current?.parentElement;
      if (!container) return;
      const rect = container.getBoundingClientRect();
      const headerHeight2 = $headerHeight.get();
      if (rect.top < headerHeight2) {
        const yOffset = getElementOffset(container).top;
        debug$1("[refresh:scroll] rect.top = %s, headerHeight = %s", rect.top, headerHeight2);
        document.documentElement.scrollTop = yOffset - headerHeight2 + 2;
      }
    });
    reactExports.useImperativeHandle(ref2, () => ({
      scrollToTop
    }));
    const headerHeight = $headerHeight.use();
    const showAccessKeyManage = useShouldShowAccessKeyManage(tab2);
    const usingEvolevdHeader = $usingEvolevdHeader.use();
    const dark = useIsDarkMode();
    const expandToFullWidthCss = useExpandToFullWidthCss();
    const boxShadowCss = (() => {
      let val;
      if (usingEvolevdHeader) {
        val = dark ? "rgba(0, 0, 0, 26%) 0px 2px 10px 1px" : "rgba(0, 0, 0, 13%) 0 1px 10px 1px;";
      } else {
        val = `0 2px 4px ${dark ? "rgb(255 255 255 / 5%)" : "rgb(0 0 0 / 8%)"}`;
      }
      return css("box-shadow:", val, ";", "");
    })();
    const wrapperClassName = r(pureRecommend && useStickyTabbar && ["sticky  mb-10px b-b-1px b-b-transparent b-b-solid", clsZRecHeader, sticky && ["bg-gate-bg", "b-b-gate-bg-lv1"]], sticky && "sticky-state-on");
    const wrapperCss = reactExports.useMemo(() => {
      if (!(pureRecommend && useStickyTabbar)) return;
      const topCss = css("top:", headerHeight - 1, "px;", "");
      const arr = [topCss];
      if (stickyTabbarShadow && sticky) arr.push(boxShadowCss, expandToFullWidthCss);
      return arr;
    }, [pureRecommend, useStickyTabbar, stickyTabbarShadow, sticky, headerHeight, boxShadowCss, expandToFullWidthCss]);
    return jsx$1("div", { ref: stickyRef, "data-role": "tab-bar-wrapper", className: wrapperClassName, css: wrapperCss, children: jsxs("div", { "data-role": "tab-bar", className: clsx(APP_CLS_TAB_BAR, "relative mb-0 h-auto flex flex-row items-center justify-between gap-x-15px px-0 py-8px"), children: [
jsxs("div", { "data-class-name": "left", className: "h-full flex flex-wrap items-center gap-x-15px gap-y-8px", children: [
jsx$1(VideoSourceTab, { className: "flex-none" }),
        leftSlot
      ] }),
jsxs("div", { "data-class-name": "right", className: "h-full min-w-180px flex flex-row-reverse flex-wrap items-center justify-right gap-x-8px gap-y-8px", children: [
jsx$1(RefreshButton, { tab: tab2, refreshHotkeyEnabled: shortcutEnabled }),
        showBackForwardButtons && _isRecTab && jsxs(Fragment, { children: [
jsx$1(AntdTooltip, { arrow: false, title: jsxs(Fragment, { children: [
            "前进",
            serviceQueueStateInfo
          ] }), children: jsx$1(Button$1, { className: "icon-only-round-button", disabled: refreshing || !canGoForward, onClick: () => onRefresh("forward"), children: jsx$1(ForwardRef$1, {}) }) }),
jsx$1(AntdTooltip, { arrow: false, title: jsxs(Fragment, { children: [
            "后退",
            serviceQueueStateInfo
          ] }), children: jsx$1(Button$1, { className: "icon-only-round-button", disabled: refreshing || !canGoBack, onClick: () => onRefresh("back"), children: jsx$1(ForwardRef, {}) }) })
        ] }),
jsx$1(AntdTooltip, { title: "设置", arrow: false, children: jsxs(Button$1, { onClick: showModalSettings, className: "icon-only-round-button", children: [
jsx$1(ModalSettingsHotkey, {}),
jsx$1(IconForConfig, { className: "size-14px" })
        ] }) }),
        multiSelectShowIcon && jsx$1(MultiSelectButton, { iconOnly: true, addCopyActions: true }),
        showAccessKeyManage && jsx$1(AccessKeyManage, { style: {
          marginLeft: 5
        } }),
        rightSlot
      ] })
    ] }) });
  }
  function useExpandToFullWidthCss() {
    const {
      xScrolling,
      bodyWidth
    } = useSizeExpression(document.body, (entry) => {
      const width = entry.contentRect.width;
      const xScrolling2 = !!(width && Math.round(width) > Math.round(window.innerWidth));
      if (!xScrolling2) {
        return {
          xScrolling: xScrolling2
        };
      } else {
        return {
          xScrolling: xScrolling2,
          bodyWidth: width
        };
      }
    }, () => ({
      xScrolling: false
    }));
    return reactExports.useMemo(() => {
      if (!xScrolling) {
        const scrollbarWidth = isMac || isSafari ? "0px" : "20px";
        return css("margin-inline:calc((100% - 100vw + ", scrollbarWidth, ") / 2);padding-inline:calc((100vw - ", scrollbarWidth, " - 100%) / 2);", "");
      } else {
        const w = Math.floor(bodyWidth);
        return css("margin-inline:calc((100% - ", w, "px) / 2);padding-inline:calc((", w, "px - 100%) / 2);", "");
      }
    }, [xScrolling, bodyWidth]);
  }
  function useShouldShowAccessKeyManage(tab2) {
    const {
      accessKey
    } = useSettingsSnapshot();
    return !accessKey && [ETab.AppRecommend, ETab.Liked].includes(tab2);
  }
  function usePlainShortcutEnabled() {
    const {
      modalFeedVisible,
      modalSettingsVisible
    } = useModalsState();
    const arr = [modalFeedVisible, modalSettingsVisible, useModalDislikeVisible(), useModalMoveFavVisible()];
    return arr.every((x) => x === false);
  }
  function PureRecommend() {
    const {
      grid: {
        twoColumnModeAlign
      },
      sidebarAlign
    } = useSettingsSnapshot();
    const {
      usingTwoColumnMode
    } = useGridDisplayModeChecker();
    const shortcutEnabled = usePlainShortcutEnabled();
    const recSelf = useInitRecSelf();
    const {
      tabbarView,
      sidebarView
    } = recSelf.useStore();
    const {
      tab: tab2,
      direction
    } = useDeferredTab();
    const recHeaderRef = reactExports.useRef(null);
    const onScrollToTop = useMemoizedFn(() => recHeaderRef.current?.scrollToTop());
    const headerHeight = $headerHeight.use();
    const sidebarCss = reactExports.useMemo(() => {
      return css("position:sticky;top:", headerHeight + 55, "px;max-height:calc(100vh - ", headerHeight + 55 + 20, "px);", "");
    }, [headerHeight]);
    let clsFlexContainer;
    let clsRecGridContainer;
    let clsRecGrid;
    {
      clsFlexContainer = clsx("flex gap-x-25px", sidebarAlign === ESidebarAlign.Right && "flex-row-reverse");
      clsRecGridContainer = "flex-1";
      clsRecGrid = clsx(usingTwoColumnMode && [clsTwoColumnModeWidth, clsForTwoColumnModeAlign(twoColumnModeAlign, "margin")]);
    }
    return jsxs(RecSelfContext.Provider, { value: recSelf, children: [
jsx$1(RecHeader, { ref: recHeaderRef, tab: tab2, leftSlot: tabbarView, shortcutEnabled }),
jsxs("div", { className: clsFlexContainer, children: [
jsx$1(RecSidebar, { css: sidebarCss, tab: tab2, sidebarView }),
jsx$1(RecGrid, { tab: tab2, direction, containerClassName: clsRecGridContainer, className: clsRecGrid, shortcutEnabled, infiniteScrollUseWindow: true, onScrollToTop }, tab2)
      ] })
    ] });
  }
  const bewlyEnabledSelector = "html.bewly-design:not(:has(#i_cecream,#app))";
  function hasBewlyBewly() {
    return !!document.querySelector(bewlyEnabledSelector);
  }
  function tryDetectBewlyBewly() {
    return tryAction(bewlyEnabledSelector, () => {
      appWarn(`unmount for using bewly-design`);
      root?.unmount();
    }, {
      pollTimeout: 5e3,
      warnOnTimeout: false
    });
  }
  let root;
  async function initHomepage() {
    tryToRemove(".adblock-tips");
    tryToRemove(".vip-login-tip");
    tryAction("html.gray", (el) => el.classList.remove("gray"));
    registerSettingsGmCommand();
    if (hasBewlyBewly()) {
      return appWarn(`quit for using bewly-design`);
    }
    const shouldInit = settings.pureRecommend || inGateEntry() || getOnlyTab();
    if (shouldInit) {
      await initHomepagePureRecommend();
      tryDetectBewlyBewly();
    } else {
      initHomepageGateFloatEntry();
    }
  }
  function initHomepageGateFloatEntry() {
    const container = document.createElement("section");
    container.classList.add(APP_CLS_ROOT);
    document.body.append(container);
    root = clientExports.createRoot(container);
    root.render( jsxs(AppRoot, { children: [
jsx$1(SetupForPage, { antd: true, baseGlobalStyle: true }),
jsx$1(GateFloatEntry, {})
    ] }));
  }
  async function initHomepagePureRecommend() {
    if (isSafari) await delay$1(500);
    tryToRemove("#i_cecream .bili-feed4-layout, body > #app .bili-feed4-layout");
    tryToRemove(".bili-feed4 .header-channel");
    tryToRemove(".palette-button-wrap");
    const biliLayout = document.createElement("div");
    biliLayout.classList.add("bili-feed4-layout", "pure-recommend", APP_CLS_ROOT);
    await poll$1(() => document.querySelector(".bili-feed4 .bili-header"), {
      interval: 20,
      timeout: 2e3
    });
    document.body.append(biliLayout);
    const container = document.createElement("div");
    biliLayout.append(container);
    root = clientExports.createRoot(container);
    root.render( jsxs(AppRoot, { children: [
jsx$1(SetupForPage, { antd: true, baseGlobalStyle: true, homePageGlobalStyle: true }),
jsx$1(PureRecommend, {}),
jsx$1(FloatButton.BackTop, { style: {
insetInlineEnd: "var(--back-top-right, 24px)"
      } })
    ] }));
  }
  function setupForNoneHomepage() {
    setupAppRootForNoneHomepage();
    registerSettingsGmCommand();
  }
  const _setupOnce = once(() => {
    const container = document.createElement("div");
    document.body.appendChild(container);
    const root2 = clientExports.createRoot(container);
    root2.render( jsx$1(AppRoot, { children: jsx$1(SetupForPage, { antd: true, baseGlobalStyle: true }) }));
  });
  function setupAppRootForNoneHomepage() {
    _setupOnce();
  }
  function isInIframe() {
    try {
      return globalThis.self !== window.top;
    } catch {
      return true;
    }
  }
  const globalEmitter = new Emittery();
  const setupForNavigationListeners = once(() => {
    window.navigation?.addEventListener?.("navigatesuccess", () => {
      globalEmitter.emit("navigate-success");
    });
  });
  queueMicrotask(setupForNavigationListeners);
  function initSearchPage() {
    if (isInIframe()) return;
    setupForNoneHomepage();
    if (settings.videoCard.videoPreview.addTo.searchPage) {
      addLargePreviewForSearchResults();
    }
  }
  function addLargePreviewForSearchResults() {
    const run = limitFunction(() => {
      const itemsSelector = ".video-list-item:has(> .bili-video-card),div:has(> .bili-video-card)";
      const list2 = Array.from(document.querySelectorAll(itemsSelector));
      for (const el of list2) addLargePreview(el);
    }, 1);
    run();
    const ob2 = new MutationObserver(() => run());
    ob2.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  const processed = new WeakSet();
  const processedAttr = `${APP_NAMESPACE}-add-large-preview-processed`;
  function addLargePreview(el) {
    if (processed.has(el)) return;
    if (el.getAttribute(processedAttr)) return;
    const prevEl = el.querySelector(".bili-watch-later--wrap");
    if (!prevEl) return;
    const container = document.createElement("div");
    prevEl.after(container);
    processed.add(el);
    el.setAttribute(processedAttr, "true");
    const root2 = clientExports.createRoot(container);
    root2.render( jsx$1(AppRoot, { children: jsx$1(LargePreviewSetup, { el }) }));
  }
  function LargePreviewSetup({
    el
  }) {
    const {
      bvid = "",
      cover
    } = reactExports.useMemo(() => parseCardInfo(el), [el]);
    const cardEl = reactExports.useMemo(() => el.querySelector(".bili-video-card") ?? el, [el]);
    const coverEl = reactExports.useMemo(() => cardEl.querySelector(".bili-video-card__wrap > a"), [el]);
    const hovering = useHover(cardEl);
    const videoCardAsTriggerRef = reactExports.useRef(coverEl);
    const {
      largePreviewActionButtonEl,
      largePreviewEl
    } = useLargePreviewRelated({
      shouldFetchPreviewData: !!bvid,
      hasLargePreviewActionButton: true,
      actionButtonVisible: hovering,
      actionButtonProps: {
        useMotion: true,
        motionProps: {
          initial: {
            opacity: 0
          },
          animate: {
            opacity: 1
          },
          exit: {
            opacity: 0,
            transition: {
              delay: 0
            }
          },
          transition: {
            duration: 0.2,
            ease: "linear",
            delay: 0.2
          }
        }
      },
bvid,
      cid: void 0,
      uniqId: bvid,
      recSharedEmitter: defaultRecSharedEmitter,
      cardTarget: cardEl,
cover,
      videoCardAsTriggerRef
    });
    return jsxs(Fragment, { children: [
jsx$1("div", { className: r(C$2.top("right"), "right-[calc(8px+28px+5px)]"), children: largePreviewActionButtonEl }),
      reactDomExports.createPortal(largePreviewEl, cardEl)
    ] });
  }
  function parseCardInfo(el) {
    let bvid;
    {
      const link = el.querySelector(".bili-video-card__wrap > a")?.href;
      if (link) {
        bvid = /^\/video\/(?<bvid>BV\w+)\//i.exec(new URL(link).pathname)?.groups?.bvid;
      }
    }
    const cover = el.querySelector("picture.v-img.bili-video-card__cover img")?.currentSrc;
    return {
      bvid,
      cover
    };
  }
  const rootElId = `${APP_NAMESPACE}-${crypto.randomUUID()}`;
  async function addActionButtons() {
    if (!state.mid) return;
    const oldSelector = ".h-action";
    const newSelector = ".upinfo .operations";
    await tryAction([oldSelector, newSelector].join(","), (container) => {
      state.href = location.href;
      state.usingNewSpacePage = container.matches(newSelector);
      getFollowedStatus();
      const rootEl = document.createElement("span");
      rootEl.id = rootElId;
      rootEl.classList.add("mr-24px");
      container.prepend(rootEl);
      const root2 = clientExports.createRoot(rootEl);
      root2.render( jsx$1(AppRoot, { children: jsx$1(ActionButtons, {}) }));
    }, {
      pollTimeout: 1e4,
      pollInterval: 1e3
    });
  }
  const state = proxy({
    href: location.href,
    usingNewSpacePage: false,
    followed: false,
    get mid() {
      return parseMid(this.href);
    },
    get collectionId() {
      const u2 = new URL(this.href);
      {
        const reg = /https:\/\/space.bilibili.com\/(?<mid>\d+)\/lists\/(?<collectionId>\d+)(?:\?type=season)?/;
        const match2 = this.href.match(reg);
        if (match2?.groups?.collectionId && (u2.searchParams.get("type") === "season" || !u2.searchParams.get("type"))) {
          return Number(match2?.groups?.collectionId);
        }
      }
      {
        const reg = /https:\/\/space.bilibili.com\/\d+\/channel\/collectiondetail\?/;
        if (reg.test(this.href)) {
          const u22 = new URL(this.href);
          const collectionId = u22.searchParams.get("sid")?.trim();
          if (collectionId) {
            return Number(collectionId);
          }
        }
      }
    },
    get isCollectionPage() {
      return typeof this.collectionId === "number";
    },
    get searchKeyword() {
      const reg = /https:\/\/space.bilibili.com\/\d+\/search/;
      if (!reg.test(this.href)) return;
      const searchParams2 = new URLSearchParams(location.search);
      const keyword = searchParams2.get("keyword");
      return keyword ?? void 0;
    },
    get isSearching() {
      return !!this.searchKeyword?.trim();
    }
  });
  const getFollowedStatus = reusePendingPromise(async () => {
    const followed = await poll$1(() => {
      const list2 = Array.from(document.querySelectorAll(".space-follow-btn")).filter((el) => el.textContent?.trim() === "已关注");
      if (list2.length > 0) return true;
    }, {
      interval: 100,
      timeout: 5e3
    });
    state.followed = !!followed;
  });
  globalEmitter.on("navigate-success", () => {
    state.href = location.href;
    getFollowedStatus();
  });
  function ActionButtons() {
    const {
      mid,
      collectionId,
      followed,
      isSearching,
      searchKeyword
    } = useSnapshot(state);
    if (!mid) return;
    const clsBtn = "w-34px b-white/33% rounded-full hover:b-gate-primary hover:bg-gate-primary";
    const clsIcon = "size-17px";
    let btnSpaceUpload;
    {
      let href = `https://www.bilibili.com/?${SpaceUploadQueryKey.Mid}=${mid}`;
      if (isSearching && searchKeyword) {
        href += `&${SpaceUploadQueryKey.SearchText}=${searchKeyword}`;
      }
      btnSpaceUpload = jsx$1(ActionButton, { className: clsBtn, href, tooltip: `在「${APP_NAME}」中查看 UP 的投稿`, children: jsx$1(IconForSpaceUpload, { className: clsIcon }) }, "btnSpaceUpload");
    }
    let btnDynamicFeed;
    if (followed) {
      const href = `https://www.bilibili.com/?${DynamicFeedQueryKey.Mid}=${mid}`;
      btnDynamicFeed = jsx$1(ActionButton, { className: clsBtn, href, tooltip: `在「${APP_NAME}」中查看 UP 的动态`, children: jsx$1(IconForDynamicFeed, { className: clsIcon }) }, "btnDynamicFeed");
    }
    let btnViewCollection;
    if (typeof collectionId === "number") {
      btnViewCollection = jsx$1(ActionButton, { className: clsBtn, href: `https://www.bilibili.com/?${FavQueryKey.CollectionIdFull}=${collectionId}`, target: "_blank", tooltip: `在「${APP_NAME}」中查看合集`, children: jsx$1(IconForCollection, { className: clsIcon }) }, "btnViewCollection");
    }
    return jsxs("span", { className: "inline-flex items-center gap-x-8px", children: [
      btnViewCollection,
      btnSpaceUpload,
      btnDynamicFeed
    ] });
  }
  function ActionButton({
    href,
    children,
    className,
    style: style2,
    tooltip,
    ...restProps
  }) {
    const {
      usingNewSpacePage
    } = useSnapshot(state);
    const _className = r("h-34px w-150px flex cursor-pointer items-center justify-center b-1px b-white/20% rounded-6px b-solid bg-white/14% text-14px color-white font-700 transition-duration-300 transition-property-all hover:bg-white/40%", className);
    const btn = usingNewSpacePage ? jsx$1("a", { ...restProps, href, className: _className, style: style2, children }) : jsx$1("a", { href, className: clsx("h-f-btn", className), style: {
      width: "auto",
      paddingInline: "15px",
      ...style2
    }, ...restProps, children });
    if (tooltip) {
      return jsx$1(AntdTooltip, { title: tooltip, children: btn });
    } else {
      return btn;
    }
  }
  function parseMid(href = location.href) {
    const url2 = new URL(href);
    const mid = url2.pathname.split("/").map((x) => x.trim()).find(Boolean);
    if (!mid || !/^\d+$/.test(mid)) return;
    return mid;
  }
  function fixCollectionUrl() {
    globalEmitter.on("navigate-success", redirectCollectionUrl);
  }
  function redirectCollectionUrl() {
    const u2 = new URL(location.href);
    if (u2.hostname !== "space.bilibili.com") return;
    const match2 = /^\/(?<mid>\d+)\/lists\?sid=(?<sid>\d+)$/.exec(u2.pathname + u2.search);
    if (!match2) return;
    const newUrl = new URL(`/${match2.groups?.mid}/lists/${match2.groups?.sid}`, location.href).href;
    location.href = newUrl;
  }
  function initSpacePage() {
    setupForNoneHomepage();
    fixCollectionUrl();
    addActionButtons();
  }
  function getBiliPlayer() {
    if (typeof unsafeWindow === "undefined") return;
    return unsafeWindow.player;
  }
  const debug = baseDebug.extend("main:video-play-page");
  async function initVideoPlayPage() {
    setupForNoneHomepage();
    registerGmCommands();
    setupCustomFavPicker();
    await handleFullscreen();
    await handleForceAutoPlay();
  }
  function registerGmCommands() {
    registerOpenInPipCommand();
    registerOpenInIinaCommand();
    registerAddToFavCommand();
  }
  function registerOpenInPipCommand() {
    if (!hasDocumentPictureInPicture) return;
    GM.registerMenuCommand?.("🎦 小窗打开", () => {
      pausePlayingVideo();
      openInPipWindow();
    });
  }
  function registerOpenInIinaCommand() {
    if (!isMac) return;
    GM.registerMenuCommand?.("▶️ IINA 打开", () => {
      pausePlayingVideo();
      openInIina();
    });
  }
  async function handleFullscreen() {
    const targetMode = new URL(location.href).searchParams.get(EQueryKey.PlayerScreenMode);
    debug("targetMode=%s", targetMode);
    const next2 = targetMode === EPlayerScreenMode.WebFullscreen || targetMode === EPlayerScreenMode.Fullscreen;
    if (!next2) return;
    let action2;
    if (targetMode === EPlayerScreenMode.WebFullscreen) {
      action2 = () => document.querySelector('[role="button"][aria-label="网页全屏"]')?.click();
    }
    if (targetMode === EPlayerScreenMode.Fullscreen) {
      action2 = () => document.querySelector('[role="button"][aria-label="全屏"]')?.click();
    }
    const getCurrentMode = () => document.querySelector("#bilibili-player .bpx-player-container")?.dataset.screen || EPlayerScreenMode.Normal;
    const timeoutAt = Date.now() + ms("30s");
    while (getCurrentMode() !== targetMode && Date.now() <= timeoutAt) {
      debug("current mode: %s", getCurrentMode());
      action2?.();
      await delay$1(100);
    }
    debug("handleFullscreen to %s complete", targetMode);
  }
  async function handleForceAutoPlay() {
    if (getBiliPlayerConfigAutoPlay()) return;
    const isON = new URL(location.href).searchParams.get(EQueryKey.ForceAutoPlay) === EForceAutoPlay.ON;
    if (!isON) return;
    const playing = () => {
      const player = getBiliPlayer();
      return !!player && !player.isPaused();
    };
    const timeoutAt = Date.now() + ms("30s");
    while (Date.now() <= timeoutAt && !playing()) {
      getBiliPlayer()?.play();
      await delay$1(1e3);
    }
    debug("handleForceAutoPlay complete, playing = %s", playing());
  }
  function pausePlayingVideo() {
    const player = getBiliPlayer();
    if (player && !player.isPaused()) {
      player.pause();
    }
  }
  function openInPipWindow() {
    const u2 = new URL(location.href);
    u2.searchParams.set(EQueryKey.PlayerScreenMode, EPlayerScreenMode.WebFullscreen);
    const newHref = u2.href;
    openInPipOrPopup(newHref, "");
  }
  function openInIina() {
    const iinaUrl = `iina://open?url=${encodeURIComponent(location.href)}`;
    window.open(iinaUrl, "_self");
  }
  function registerAddToFavCommand() {
    GM.registerMenuCommand?.("⭐️ 加入收藏", () => addToFav());
  }
  async function setupCustomFavPicker() {
    if (!settings.fav.useCustomFavPicker.onPlayPage) return;
    if (!getCurrentPageBvid()) return;
    document.addEventListener("keydown", (e) => {
      if (e.key !== "e") return;
      if (shouldDisableShortcut()) return;
      const target = e.target;
      if (target.closest("bili-comments")) return;
      e.stopImmediatePropagation();
      e.preventDefault();
      addToFav();
    }, {
      capture: true
    });
    const el = await poll$1(() => document.querySelector(".video-fav.video-toolbar-left-item"), {
      interval: 100,
      timeout: 5e3
    });
    el?.addEventListener("click", (e) => {
      e.stopImmediatePropagation();
      e.preventDefault();
      addToFav();
    }, {
      capture: true
    });
  }
  async function addToFav(sourceFavFolderIds) {
    const bvid = getCurrentPageBvid();
    if (!bvid) return antMessage.error("无法解析视频 BVID !");
    const avid = bv2av(bvid);
    if (sourceFavFolderIds === void 0) {
      const result = await UserFavApi.getVideoFavState(avid);
      if (result) {
        sourceFavFolderIds = result.favFolderIds;
      }
    }
    await startModifyFavItemToFolder(sourceFavFolderIds, async (targetFolder) => {
      const success = await handleModifyFavItemToFolder(avid, sourceFavFolderIds, targetFolder);
      if (!success) return;
      const nextState = !!targetFolder;
      const el = document.querySelector(".video-fav.video-toolbar-left-item");
      el?.classList.toggle("on", nextState);
      return true;
    });
  }
  dayjs.extend(duration);
  void (function main() {
    if (IN_BILIBILI_HOMEPAGE) return initHomepage();
    if (IN_BILIBILI_VIDEO_PLAY_PAGE) return initVideoPlayPage();
    if (IN_BILIBILI_SPACE_PAGE) return initSpacePage();
    if (IN_BILIBILI_SEARCH_PAGE) return initSearchPage();
  })();

})(UAParser, axios, SparkMD5, localforage, PinyinMatch);